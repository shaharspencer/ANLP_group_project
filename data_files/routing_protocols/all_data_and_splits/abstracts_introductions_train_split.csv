Unnamed: 0,titles,abstract,introduction
118,CoDiNet: Path Distribution Modeling with Consistency and Diversity for Dynamic Routing.txt,"Dynamic routing networks, aimed at finding the best routing paths in the
networks, have achieved significant improvements to neural networks in terms of
accuracy and efficiency. In this paper, we see dynamic routing networks in a
fresh light, formulating a routing method as a mapping from a sample space to a
routing space. From the perspective of space mapping, prevalent methods of
dynamic routing didn't consider how inference paths would be distributed in the
routing space. Thus, we propose a novel method, termed CoDiNet, to model the
relationship between a sample space and a routing space by regularizing the
distribution of routing paths with the properties of consistency and diversity.
Specifically, samples with similar semantics should be mapped into the same
area in routing space, while those with dissimilar semantics should be mapped
into different areas. Moreover, we design a customizable dynamic routing
module, which can strike a balance between accuracy and efficiency. When
deployed upon ResNet models, our method achieves higher performance and
effectively reduces average computational cost on four widely used datasets.","DYNAMIC routing is a sampleadaptive inference mech anism for neural networks. At inference time, only part of a dynamic routing network would be activated for each sample, which is aimed at reducing computational cost with little performance compromised [1], [2], [3], [4]. In essence, dynamic routing can be considered as a mapping from a sample space to a routing space. As shown in Fig. 1, when samples are presented to a dynamic routing model, they are mapped into a routing space. Each sample’s routing path in the routing space can be represented as a binary vector, consisting of a sequence of toberun and tobeskipped blocks. The model walks through the toberun blocks. From the perspective of space mapping, how inference paths should be distributed in the routing space remains rel atively unexplored. Since dynamic routing is related to two spaces, i.e., a sample space and a routing space, we focus on this question: how do we model the relationship between the two spaces? We expect that the distance between similar samples should be close in the routing space. Otherwise, the distance should be far. Moreover, what kind of samples are similar? We utilize the selfsupervised similarity and encourage the self supervised augmentations walking through close routing paths. Since the images obtained by selfsupervised aug mentations remain semantically and visually unchanged, their routing paths should be close in the routing space. In comparison, images belong to the same semantic class might be signiﬁcantly different due to different background, object layout, and color. The feature extraction patterns of these samples are different so that it is infeasible to utilize close H. Wang, Z. Qin, S. Li are with the College of Computer Science and Technology, Zhejiang University, Hangzhou, Zhejiang, China, 310007. (email: huanyuhello@zju.edu.cn, qinzequn@zju.edu.cn, leizungjyun@zju.edu.cn). X.𝐿𝑖yis with the College of Computer Science and Technology, Zhejiang University, Hangzhou, China, 310007. (email: xilizju@zju.edu.cn). The corresponding author of this paper is Prof. Xi Li. Routing space Samples  Dynamic routing1 0 1 .... 1 1 1 0 1 .... 1 1 1 0 0 .... 0 1 1 0 0 .... 0 1[1,0,1,1,0,0,1,1] [1,0,1,1,1,0,1,1] [1,0,0,0,1,0,0,1] [1,0,0,1,0,1,0,1] Routing pathsFig. 1. Illustration of dynamic routing. A dynamic routing network is a mapping from a sample space to a routing space. Each routing path consists of a sequence of toberun and tobeskipped blocks. The dynamic routing model walks through the toberun blocks. Best viewed in color. routing paths for such visually different images. As shown in Fig. 2, images 𝑎and𝑎0, images𝑏and𝑏0are similar to each other, while 𝑐and𝑐0,𝑑and𝑑0are dissimilar. Therefore, the routing paths of images 𝑎and𝑎0, images𝑏and𝑏0should be the same or similar, while routing paths of images 𝑐and𝑐0, 𝑑and𝑑0should be different. To this end, we explicitly model the relationship between the sample space and the routing space, therein establishing the connection between samples and routing paths. We propose a novel dynamic routing method, termed CoDiNet, to regularize the path distribution in a routing space with the properties of consistency and diversity, based on the aforementioned space mapping. Firstly, the consistency reg ularization makes augmentations of the same sample have similar feature activations, thus forming a speciﬁc routing paths for speciﬁc samples. Parameters on the speciﬁc rout ing path are consistently stimulated by similar samples, which is favorable to parameter sharing among similar samarXiv:2005.14439v3  [cs.CV]  26 May 2021IEEE TRANSACTIONS ON PATTERN ANAL YSIS AND MACHINE INTELLIGENCE 2 Dynamic	Network Routing	SpaceConsistency Diversity Conv	Block Conv	Block Conv	BlockExecute	or	Skip Fig. 2. Illustration of our motivation. Left: Schematic diagram of a dynamic routing network, in which each layer can be either executed or skipped. Middle: A demonstration of the routing space. All potential routing paths compose a binary routing space. Right: Routing paths for similar images should be the same or similar, e.g., 𝑎and𝑎0,𝑏and𝑏0, while routing paths for dissimilar images should be different, e.g., 𝑐and𝑐0,𝑑and𝑑0. Best viewed in color. ples and robustness of the network. At the same time, the diversity regularization makes the routing paths generated by dynamic routing more diverse, which strengthens the exploration of the network. It is evident that the more routing paths are used, the more capacity of the network is utilized. Computational cost is another important issue because the computational ability of different platforms varies con siderably. For instance, the inference speed of ResNet50 [5] on GTX 1080ti (30fps) is much faster than that on Maxwell TitanX (18fps) at a resolution of 224 224. The average cost of dynamic routing networks should be customizable, when the networks are applied to platforms with different computational budgets. To this end, we propose a differen tiable computational cost loss to optimize the average com putational cost of the model and make the computational budgets customizable. The main contributions of CoDiNet can be summarized into three parts: We explicitly model the relationship between the sample space and the routing space, therein establishing the con nection between samples and routing paths. We propose a novel consistencyanddiversity regularized optimizing method modeling the relationships between the two spaces, which makes routing paths optimizable. We design a customizable dynamic routing module and achieve stateoftheart results in terms of computational cost reduction and performance. 2 R ELATED WORKS "
29,A Framework for Vehicle Routing Approximation Schemes in Trees.txt,"We develop a general framework for designing polynomial-time approximation
schemes (PTASs) for various vehicle routing problems in trees. In these
problems, the goal is to optimally route a fleet of vehicles, originating at a
depot, to serve a set of clients, subject to various constraints. For example,
in Minimum Makespan Vehicle Routing, the number of vehicles is fixed, and the
objective is to minimize the longest distance traveled by a single vehicle. Our
main insight is that we can often greatly restrict the set of potential
solutions without adding too much to the optimal solution cost. This
simplification relies on partitioning the tree into clusters such that there
exists a near-optimal solution in which every vehicle that visits a given
cluster takes on one of a few forms. In particular, only a small number of
vehicles serve clients in any given cluster. By using these coarser building
blocks, a dynamic programming algorithm can find a near-optimal solution in
polynomial time. We show that the framework is flexible enough to give PTASs
for many problems, including Minimum Makespan Vehicle Routing,
Distance-Constrained Vehicle Routing, Capacitated Vehicle Routing, and School
Bus Routing, and can be extended to the multiple depot setting.","Vehicle routing problems address the fundamental problem of routing a  eet of vehicles from a common depot to visit a set of clients. These problems Research funded by NSF grant CCF1409520 1arXiv:1807.04308v2  [cs.DS]  25 Feb 2019arise naturally in many real world settings, and are wellstudied across com puter science and operations research. We generalize a class of vehicle rout ing problems by introducing the notions of vehicle load , the problemspecic vehicle constraint (e.g. number of clients visited, distance traveled by the vehicle, client regret, etc.), and  eet budget , the problemspecic  eet con straint (e.g. number of vehicles, sum of distances traveled, etc.). Most vehicle routing problems can then be framed as either MinMax Vehicle Load : minimize the maximum vehicle load, given a bound kon  eet budget (e.g. Minimum Makespan Vehicle Routing ) orMinimum Fleet Budget : minimize the required  eet budget, given a bound Don vehicle load (e.g. DistanceConstrained Vehicle Routing ). In fact, these are two optimization perspectives of the same decision problem: does there exist a solution with maximum vehicle load Dand  eet budget k? 1.1 Main Contributions We present a framework for designing polynomial time approximation schemes (PTASs) for MinMax Vehicle Load andMinimum Fleet Budget in trees. Tree (and treelike) transportation networks occur in building and warehouse layouts, mining and logging industries, and along rivers and coast lines [12, 11]. Our framework applies directly to MinMax Vehicle Load problems and generates results of the following form. Theorem 1. For every >0, there is a polynomialtime algorithm that, given an instance of MinMax Vehicle Load on a tree, nds a feasible solution whose maximum vehicle load is at most 1 +times optimum. An immediate corollary of Theorem 1 is the following bicriteria result for the associated Minimum Fleet Budget problem. Theorem 2. Given an instance of Minimum Fleet Budget on a tree, if there exists a solution with  eet budget kand vehicle load D, then for any  >0, there is a polynomialtime algorithm that nds a solution with  eet budgetkand vehicle load at most (1 +)D. The input to the framework is a rooted tree T= (V;E) with root r2V and edge lengths `(u;v)0 for all (u;v)2E. The root rrepresents thedepot at which all vehicles start. Without loss of generality, the set of clients corresponds to the set of leaves in the tree (any subtree without a client can be safely removed from the instance). Since every edge must then be traversed by at least one vehicle, the problems are equivalent to corresponding treecover problems. As stated, the framework can be customized to a wide range of problems. In Section 4, we illustrate in detail how to customize the framework to give a PTAS for the Minimum Makespan Vehicle Routing problem of nding ktours each starting and ending at a depot rthat serve all clients in Tsuch 2that the makespan , the maximum length of any tour, is minimized. Here, vehicle load is the tour length, and  eet budget is the number of vehicles. A bicriteria PTAS for the associated Minimum Fleet Budget problem, DistanceConstrained Vehicle Routing , follows as a corollary. We will also show how the framework can be applied to give similar re sults for other vehiclerouting variants, including Capacitated Vehicle Routing (see Section 5) and School Bus Routing (see Section 6). Ad ditionally, we show how to generalize to the multiple depot setting (see Section 7). The breadth of the problems listed highlights the real  exibility and convenience of the presented framework. At a high level, the framework partitions the tree into clusters such that there exists a nearoptimal solution that within each cluster has a very simple form, eectively coarsening the solution space. Then, given this simplied structure, a dynamic program can be designed to nd such a nearoptimal solution. The clusters are designed to be small enough so that simplifying vehicle routes at the cluster level does not increase the optimal load by too much, but also large enough that the (coarsened) solutions can be enumerated eciently. To bound the error introduced by this simplication we design a loadreassignment tool that makes cluster coverage adjustments globally in the tree. Finally, standard dynamic programming techniques can result in a large accumulation of rounding error. To limit the number of times that the load of any single route is rounded, we introduce a route projection technique that essentially pays in advance for load that the vehicle anticipates accu mulating, allowing the dynamic program to round only once instead of many times for this projected load. 1.2 Related Work "
433,AGEM: Adaptive Greedy-Compass Energy-aware Multipath Routing Protocol for WMSNs.txt,"This paper presents an Adaptive Greedy-compass Energy-aware Multipath
protocol (AGEM), a novel routing protocol for wireless multimedia sensors
networks (WMSNs). AGEM uses sensors node positions to make packet forwarding
decisions. These decisions are made online, at each forwarding node, in such a
way that there is no need for global network topology knowledge and
maintenance. AGEM routing protocol performs load-balancing to minimize energy
consumption among nodes using twofold policy: (1) smart greedy forwarding,
based on adaptive compass and (2) walking back forwarding to avoid holes.
Performance evaluations of AGEM compared to GPSR (Greedy Perimeter Stateless
Routing) show that AGEM can: (a) maximize the network lifetime, (b) guarantee
quality of service for video stream transmission, and (c) scale better on
densely deployed wireless sensors network.","With the growingup of miniaturization technology a nd the  availability of lowcost hardware, the sensors node s embed  nowadays various kinds of capturing elements such a s  microphones, imaging sensors, and video cameras. In  this  context, the vision of ubiquitous Wireless Multimed ia Sensor  Networks (WMSNs) [1][2][3] has become a reality. A sensor  node gathers desired data information, processes it , and  transmits it to each other using wireless communica tion until  a base station. The base station (also referred to as the sink  node) collects and analyzes the received data from various  sensors and draws conclusions about the monitored a rea.   WMSNs are commonly used for surveillance applicatio ns,  intrusion detection, environmental monitoring, etc.  These  types of applications require addressing additional  challenges  for energyefficient multimedia processing, optimal  routing  and path selection, audio / video rate adaptation t o meet the  network changing topology, and application specific  QoS  guarantee.  Optimal routing in wireless sensor network is a cha llenging  task. Large amounts of research works have been don e to  enable energy efficiency in WSN. A comprehensive su rvey of  routing protocols in WSN has been presented in [4].    Routing protocols developed for WMSNs suggest using   multipath selection scheme to maximize the throughp ut of  streaming data. Examples of these protocols include : MPMPS  (MultiPriority MultiPath Selection ) [5]  and TPGF ( Two Phase Geographical Greedy Forwarding ) [6]. However, such  protocols have to build a complete map of the netwo rk topology to select the optimum routing / transmissi on path  between the source and the destination. They are no t adapted  in largescale, high densely deployed network and f requent  mobility situations.   Geographical routing can achieve scalability in WSN s. GPSR  (Greedy Perimeter Stateless Routing ) [7] was defined to  increase network scalability under large number of nodes.  The advantage is that the propagation of topology i nformation  is required only for a single hop. However, greedy forwarding  relays on localknowledge in which always best node  to  destination is selected. In such a case, selecting the same path  using GPSR will lead to premature dying of nodes al ong this  path.  In this paper, we examine the benefit of geographic al routing  along with multipath localbased route selection an d we  propose a new routing algorithm namely AGEM (an Ada ptive  GreedyCompass EnergyAware Multipath) routing prot ocol  that leverages both energy constraint and QoS sensi tive  stream such as audio and video.   The design of AGEM was driven by the following poin ts:  • Shortest path transmission:  multimedia applications  generally have a delay constraint which requires th at the  multimedia streaming in WSNs should always use the  shortest routing path which has the minimum endto end  transmission delay.   • Multipath transmission:  Packets of multimedia stream are  generally large in size and the transmission requir ement  can be several times higher than the maximum  transmission capacity of sensor nodes.   • Load balancing : because of the density of a WSNs, a load  balancing feature during the design of a routing pr otocol  has to be considered to avoid frequent node failure s and  consequently to maximize the network lifetime.  • Node selection : in densely deployed network, different  candidate neighbors may be used for packet forwardi ng.  AGEM uses adaptive compass  method to select candidate  neighbor nodes which are in the line of sight towar ds the  target the destination.   The rest of this paper is organized as follow. To m ake this  paper self readable, we expose in section II the ro uting  protocols that influenced the design of AGEM. In se ction III,  we present the functionalities of AGEM protocol. In  section  IV, the performance evaluation of AGEM will be pres ented.  Section V will conclude this paper. II.  RELATED WORK   "
429,Spores: Stateless Predictive Onion Routing for E-Squads.txt,"Mass surveillance of the population by state agencies and corporate parties
is now a well-known fact. Journalists and whistle-blowers still lack means to
circumvent global spying for the sake of their investigations. With Spores, we
propose a way for journalists and their sources to plan a posteriori file
exchanges when they physically meet. We leverage on the multiplication of
personal devices per capita to provide a lightweight, robust and fully
anonymous decentralised file transfer protocol between users. Spores hinges on
our novel concept of e-squads: one's personal devices, rendered intelligent by
gossip communication protocols, can provide private and dependable services to
their user. People's e-squads are federated into a novel onion routing network,
able to withstand the inherent unreliability of personal appliances while
providing reliable routing. Spores' performances are competitive, and its
privacy properties of the communication outperform state of the art onion
routing strategies.","Recent years have been marked by multiple highpro/f_ile mass surveillance scandals, involving a diverse range of players, from state agencies [ 31,34], to large technology /f_irms [ 6], through startups with close links to academia [ 6,27,32,54]. In this context, journalists and whistleblowers must be extremely careful when sourcing or exchanging sensitive or damaging information, but they unfortunately still lack the technical means to fully circumvent corporate and governmental surveillance eﬀorts. Although data encryption is o/f_ten used as a /f_irst line of defense to protect con/f_idential information, it is unfortunately insuﬃcient on its own to fully protect the parties involved in a remote exchange of data [ 17,20]. Without additional countermeasures,metadata such as a user’ location and activity can usually still be tracked, thus revealing what each user shared with whom and when. /T_he exposure of metadata seriously weakens user privacy; as famously emphasized by a former NSA and CIA director: ” We kill people based on metadata. ” [37]. Anonymity networks have been proposed to lower the risk of online spying. /T_hey notably hide the identity of the client, most o/f_ten using mix networks [ 8] or onion routing [ 13,16]. /T_hese approaches basically mangle user requests through a series of relay servers, eﬀectively hiding the link between sender and receiver. To bootstrap such anonymity networks, relays need to be suﬃciently numerous, available, distributed over many autonomous systems, and to provide enough bandwidth. For instance, Tor [ 13], the most popular onion routing implementation, relies on relays maintained by volunteer operators. On average, 6000 connected relays handle the traﬃc of 2 million online users1. /T_his small amount of relays relative to the userbase makes Tor particularly prone to a/t_tacks such as traﬃc analysis [ 47]. Tor’s infrastructure is also in part centralised, as 10 Directory Authorities (DAs) compute an hourly consensus listing online relays and providing means to contact them. /T_he DAs constitute a single point of failure, and could be subverted, just like any other relay. We argue that embracing a peertopeer (P2P) strategy—where any participating user also acts as a relay—would notably improve onion routing security by drowning malevolent entities in an ocean of honest peers. We are not the /f_irst to advocate more decentralisation, as many a/t_tempts at building P2P anonymous datasharing networks [ 10,15,18,35,43] have been proposed in the last decades. Typically, such solutions leverage onion routing with added components to perform e.g. node discovery in a decentralised fashion. Alas, frequent dis/connections of participating peers ( churn ) hinder these systems’ performances [ 28], making them unusable in practice. 1See Tor Metrics at h/t_tps://metrics.torproject.org/ .arXiv:2007.04766v1  [cs.DC]  2 Jul 2020In this paper, we propose S/p.sc/o.sc/r.sc/e.sc/s.sc , a fully decentralised anonymous /f_ile exchange protocol, adapted from traditional onion routing. To sustain the unavoidable churn, we revisit P2P by leveraging machine learning in order to predict peers’ availability. Towards this goal, we make two assumptions on the peers: we consider that each participating device belongs to a particular user, and that each user owns several devices (encouraged by the multiplication of appliances per household [ 1]). We thus propose the concept of esquads : an esquad is constituted of a single user’s devices, that model their user’s behaviour by exchanging information through gossip messaging. Using their user behavioural model, each device can predict its future state of availability. We use these estimates to propose a novel onion routing mechanism, called Probabilistic Onion Routing (P/o.sc/r.sc). With P/o.sc/r.sc, onion routes may include several candidate relays at each hop, such that a message can go through the route as long as one candidate is online per hop. Users employ the availability prediction to ensure that the routes they create will remain available with a good probability, without sacri/f_icing their privacy. In addition, P/o.sc/r.sc is stateless—all routing information is contained in the headers—enabling shortlived relay servers to pass on messages as soon as they join the network, eschewing any bootstrap phase. Building on P/o.sc/r.sc,S/p.sc/o.sc/r.sc/e.sc/s.sc enables two users to exchange a /f_ile in complete anonymity: /f_irstly, the two users exchange /f_ile metadata and routing information outofband (using another communication channel than S/p.sc/o.sc/r.sc/e.sc/s.sc ); then, using the routes they agreed upon, their respective esquads collaborate to perform the /f_ile exchange through S/p.sc/o.sc/r.sc/e.sc/s.sc , without revealing their identities to the rest of the network. /T_he proposed service is quite similar to OnionShare2, without the security limitations of Tor, and without the need to spawn a web service prior to the exchange. We say that S/p.sc/o.sc/r.sc/e.sc/s.sc is ana posteriori /f_ile exchange service. Our contributions are the following: We introduce the concept of esquads , and build a intraesquad protocol, that allows devices owned by the same user to create user behavioural models and thus, to estimate their future availability. Based on the esquad predictions, we introduce Probabilistic Onion Routing ( P/o.sc/r.sc), a onion routing protocol tailored for networks with high degrees of churn. We use P/o.sc/r.sc to realise S/p.sc/o.sc/r.sc/e.sc/s.sc , an anonymous /f_ile transfer service. A/f_ter an initial outofband exchange of metadata, two users can privately exchange a /f_ile. /T_he transfer remains eﬃcient despite the network’s unreliability, and ensures a be/t_ter anonymity than existing onion routing approaches. 2An anonymous /f_ile exchange service backed by Tor’s hidden services, see h/t_tps://onionshare.org/ ./T_he remainder of this chapter is organised as follows: we /f_irst present our protocol and its subsystems in section 2, before presenting our a/t_tack model and security properties in section 3. An evaluation of S/p.sc/o.sc/r.sc/e.sc/s.sc is proposed in section 4. We make a review of the state of the art in section 5, and /f_inally conclude the paper in section 6. 2 Our approach 2.1 2.2 2.3 2.4 Figure 1. /T_he subsystems constituting S/p.sc/o.sc/r.sc/e.sc/s.sc . From bo/t_tom to top: the esquad overlays (Sec. 2.1) and the global overlay (2.2) enable Probabilistic Onion Routing (2.3), which lies at the core of the S/p.sc/o.sc/r.sc/e.sc/s.sc anonymous /f_ile exchange service (2.4). S/p.sc/o.sc/r.sc/e.sc/s.sc is constituted of several subsystems, as depicted in Fig. 1. At the root of our proposal is predictive routing, which is made possible by having every peer publish predictions about their future connectivity. Each peer in the network is a device owned by an individual, who possesses several appliances. /T_heir appliances exchange information about their user through a private esquad overlay (Sec. 2.1); there is one private overlay per participating user. Devices use this information to build a model of their user, and make predictions about their future availability. /T_his estimate is regularly published by each device, along with their network address and public key, on the global overlay (Sec. 2.2). /T_his overlay enables peer discovery at the scale of the whole network. Using the above information, any device can intelligently build Probabilistic Onion Routes ( P/o.sc/r.scs, see Sec. 2.3), a new kind of onion route featuring several relays per hop, in order to maximise the route’s availability despite the relays’ churn. Finally, Sec. 2.4 presents the anonymous /f_ile exchange protocol in itself, S/p.sc/o.sc/r.sc/e.sc/s.sc , that anonymises a /f_ile transfer through P/o.sc/r.scs, while making use of each user’s esquad for increased dependability. 2.1 /T_he private esquad overlay An esquad overlay is constituted only of devices owned by the same user. Its role is to make any userrelated information available to the whole set of devices. 22.1.1 Sharing the user’s behaviour /T_he esquad overlay is based on the S/p.sc/r.sc/i.sc/n.sc/k.sc/l.sc/e.sc/r.sc Gossiper algorithm [ 30], extended with acknowledgements [ 5] to be/t_ter resist churn. As in S/p.sc/r.sc/i.sc/n.sc/k.sc/l.sc/e.sc/r.sc , we assume each user owns a set of devices D. /T_he user’s activity is an evergrowing sequence S=fr1; : : : ; ri; : : :gof interactions ri. Each device dinitially only knows about interactions that took place on it, Sd. /T_hrough the esquad overlay, all nodes of the esquad share their local interactions to obtain S=Ð d2DSd. Interactions are timestamped, and totally ordered. Contrarily to S/p.sc/r.sc/i.sc/n.sc/k.sc/l.sc/e.sc/r.sc , an interaction can be either a device usage event or a /f_ile exchange event. A /f_ile exchange is tied to a single device (sender or receiver), and all the esquad needs to know what device is involved in which /f_ile exchange. To this end, an interaction ris constituted of the following /f_ields: r=¹ts;d;typ;fº2RDTF such that: ts2Ris the interaction timestamp, d2D is the descriptor (see Sec. 2.2) for the device where the interaction rtook place,T=fUSE;DL;ULgis the set of interaction types (resp. device usage, new /f_ile download, or new /f_ile download). When typ= DL (resp. UL), f2F contains the unique ID of the /f_ile that just started downloading (resp. uploading) on d. When typ= USE, it means that device d was connected at time ts. Devices issue a USE message when they are grabbed, and every Tseconds while they remain connected. 2.1.2 Modelling the user’s behaviour Given the sequence of devices’ usage SU=fr2S;r:typ=USEg, each device needs to compute its own probability Pi¹dºof staying online in the near future, before advertising it. First of all, using only SU, each device builds an availability sequence X=X1; : : : ; Xi; : : :, where Xicontains the set of online devices during the interval »ti;ti+1»(see Eq. 1). /T_he observation sequence has a period of T:8i;ti+1=ti+T. /T_he sequence Xcan be represented as a 2D sparse matrix of booleans. Xi¹dº=1() 9r2SU;r:d=d^tir:ts<ti+1:(1) Now, to predict Pi¹dº, we consider that the stochastic process Xfollows the Markov property: ‘the future only depends on the present, not on the past’. We use the hypothesis in Eq. 2. As a result, the probability for dto be online in the near future only depends on its probability to stay online a/f_ter the current round Xi=x. To estimate this probability, we simply count3the number of times the current situation xled to a situation where dwas also online (Eq. 3): Pi¹dº=P»Xi+1¹dº=1jXi=x; : : : ; X0=x0¼ =P»Xi+1¹dº=1jXi=x¼ (2) = Xj2X;Xj=x^Xj+1¹dº=1	 0j<i  Xj2X;Xj=x	 0j<i(3) Given the high dimensionality of the state space, it might happen that xwas never seen before, leading to an unde/f_ined Pi¹dºIn such a case, we estimate the probability that dstays online two turns in a row as fallback. 2.2 /T_he global overlay To creates P/o.sc/r.scs, each device needs to know some other online devices’ descriptors. For a device d, a descriptor contains its address @ d, its public key pkd, and its estimated probability of remaining online Pi¹dº.dalso knows its own private key skd, that it uses to decipher messages encrypted with pkd. Given the decentralised nature of S/p.sc/o.sc/r.sc/e.sc/s.sc , we cannot rely on a central registry of online peers as e.g. Tor does. We use instead a global Random Peer Sampling (RPS) service [ 23,51]. Essentially, each node maintains a view VRPScontaining lV other devices’ descriptors. Every TRPSseconds, the view is updated as follows: a device dpops the oldest descriptor d0 from its view, then swaps a prede/f_ined number of lgossip elements fromVRPSwith d0. Both devices add a fresh descriptor of themselves to the view exchange. If d0was oﬄine, its descriptor is simply removed from d’s view, with no further modi/f_ication to VRPS. /T_his allows for two things: /f_irstly, each device’s view con tains a constantly changing random sample of participating devices; secondly, stale descriptors get removed from one’s view a/f_ter a bounded time, such that VRPSmostly contains online devices’ descriptors. Given their epidemic nature, RPS services are very sensitive to Byzantine a/t_tacks, where malicious nodes gossip bad views in order to disrupt the randomness of the neighbourhood graph. Several proposals overcome this limitation, sometimes by relying on a trusted thirdparty [ 2], sometimes by computing a reputation of the peers [ 4,24]. We leverage on the la/t_ter, so as to remain entirely decentralised. 2.3 P/o.sc/r.scs: Probabilistic Onion Routes Legacy Tor primer Onion routing makes connections between a client (say Alice) and their correspondent (Bob) go through two or more servers (or relays) before reaching their destination. With Tor, to create a route, Alice randomly picks three relays to constitute the path, and incrementally establishes TLS connections to each of them through the 3Because we work with lowprobability events observed with small amounts of data, there is a possibility that an event never occurs in X. To counter that, we apply addone smoothing [46] while computing probabilities. We le/f_t this engineering optimization out of the demonstration for clarity. 3Message Mi: Li envelope: EiLi addresses: @iLi cipher: Ci @1 E1C1 @2 E2C2 @3 E3C3 @B EBCBA BL1L2L3Or: A L1L2L3Por:. . . LB . . .. . .. . .Figure 2. In Onion Routing (OR), each layer Lis constituted of only one node. In Probabilistic Onion Routing ( P/o.sc/r.sc), there are several candidate nodes that each message can go through at each layer. /T_he bo/t_tom part of the plot shows the format of aP/o.sc/r.scmessage, and the message eﬀectively sent by Alice to relays inL1. route. Once the route is established, it constitutes a persistent twoway TCP stream, although the traﬃc is internally chunked into /f_ixedsize messages (or cells). Cells contain a header and a payload, that are encrypted altogether by the client several times: once per relay. Upon reception of a cell from the sender to its destination, each relay deciphers it using the encryption keys negotiated during the TLS connection bootstrap. Bob /f_inally receives the message originally wri/t_ten by Alice, and can answer back on the same pipe. Messages on this direction are incrementally encrypted by the relays, such that Alice receives Bob’s message hidden under three layers of encryption. She decrypts it using the keys that were negotiated with the relays during the connection establishment. /T_he anonymizing property stems from the fact that each hopLionly knows the address of the previous relay Li"
339,PlanT: Explainable Planning Transformers via Object-Level Representations.txt,"Planning an optimal route in a complex environment requires efficient
reasoning about the surrounding scene. While human drivers prioritize important
objects and ignore details not relevant to the decision, learning-based
planners typically extract features from dense, high-dimensional grid
representations containing all vehicle and road context information. In this
paper, we propose PlanT, a novel approach for planning in the context of
self-driving that uses a standard transformer architecture. PlanT is based on
imitation learning with a compact object-level input representation. On the
Longest6 benchmark for CARLA, PlanT outperforms all prior methods (matching the
driving score of the expert) while being 5.3x faster than equivalent
pixel-based planning baselines during inference. Combining PlanT with an
off-the-shelf perception module provides a sensor-based driving system that is
more than 10 points better in terms of driving score than the existing state of
the art. Furthermore, we propose an evaluation protocol to quantify the ability
of planners to identify relevant objects, providing insights regarding their
decision-making. Our results indicate that PlanT can focus on the most relevant
object in the scene, even when this object is geometrically distant.","The ability to plan is an important aspect of human intelligence, allowing us to solve complex nav igation tasks. For example, to change lanes on a busy highway, a driver must wait for sufﬁcient space in the new lane and adjust the speed based on the expected behavior of the other vehicles. Hu mans quickly learn this and can generalize to new scenarios, a trait we would also like autonomous agents to have. Due to the difﬁculty of the planning task, the ﬁeld of autonomous driving is shifting away from traditional rulebased algorithms [1, 2, 3, 4, 5, 6, 7, 8] towards learningbased solu tions [9, 10, 11, 12, 13, 14]. Learningbased planners directly map the environmental state represen tation (e.g., HD maps and object bounding boxes) to waypoints or vehicle controls. They emerged as a scalable alternative to rulebased planners which require signiﬁcant manual effort to design. Interestingly, while humans reason about the world in terms of objects [15, 16, 17], most existing learned planners [9, 12, 18] choose a highdimensional pixellevel input representation by rendering bird’s eye view (BEV) images of detailed HD maps (Fig. 1 left). It is widely believed that this kind of accurate scene understanding is key for robust selfdriving vehicles, leading to signiﬁcant interest in recovering pixellevel BEV information from sensor inputs [19, 20, 21, 22, 23, 24]. In this paper, we investigate whether such detailed representations are actually necessary to achieve convincing planning performance. We propose PlanT, a learningbased planner that leverages an objectlevel representation (Fig. 1 right) as an input to a transformer encoder [25]. We represent a scene as a set of features corresponding to (1) nearby vehicles and (2) the route the planner must follow. We show that despite the low feature dimensionality, our model achieves stateoftheart results. We then propose a novel evaluation scheme and metric to analyze explainability which is generally applicable to any learningbased planner. Speciﬁcally, we test the ability of a planner to identify the objects that are the most relevant to account for to plan a collisionfree route. 6th Conference on Robot Learning (CoRL 2022), Auckland, New Zealand.arXiv:2210.14222v1  [cs.RO]  25 Oct 2022Figure 1: Scene Representations for Planning. As an alternative to the dominant paradigm of pixellevel planners (left), we show the effectiveness of compact objectlevel representations (right). We perform a detailed empirical analysis of learningbased planning on the Longest6 bench mark [26] of the CARLA simulator [27]. We ﬁrst identify the key missing elements in the design of existing learned planners such as their incomplete ﬁeld of view and suboptimal dataset and model sizes. We then show the advantages of our proposed transformer architecture, including improve ments in performance and signiﬁcantly faster inference times. Finally, we show that the attention weights of the transformer, which are readily accessible, can be used to represent object relevance. Our qualitative and quantitative results on explainability conﬁrm that PlanT attends to the objects that match our intuition for the relevance of objects for safe driving. Contributions. (1) Using a simple objectlevel representation, we signiﬁcantly improve upon the previous state of the art for planning on CARLA via PlanT, our novel transformerbased approach. (2) Through a comprehensive experimental study, we identify that the ego vehicle’s route, a full 360° ﬁeld of view, and information about vehicle speeds are critical elements of a planner’s input representation. (3) We propose a protocol and metric for evaluating a planner’s prioritization of obstacles in a scene and show that PlanT is more explainable than CNNbased methods, i.e., the attention weights of the transformer identify the most relevant objects more reliably. 2 Related Work "
377,Power control in reactive routing protocol for Mobile Ad Hoc Network.txt,"The aim of this work is to change the routing strategy of AODV protocol (Ad
hoc On Demand Vector) in order to improve the energy consumption in mobile ad
hoc networks (MANET). The purpose is to minimize the regular period of HELLO
messages generated by the AODV protocol used for the research, development and
maintenance of routes. This information is useful to have an idea about battery
power levels of different network hosts. After storing this information, the
node elect the shortest path following the classical model used this
information to elect safest path (make a compromise) in terms of energy.
Transmitter node does not select another node as its battery will be exhausted
soon. Any node of the network can have the same information's about the
neighborhoods as well as other information about the energy level of the
different terminal to avoid routing using a link that will be lost due to an
exhausted battery of a node in this link. Analytical study and simulations by
Jist/SWANS have been conducted to note that no divergence relatively to the
classical AODV, a node can have this type of information that improves the
energy efficiency in ad hoc networks.","A Mobile Adhoc Network (MANETs) [1] is a collectio n of autonomous nodes or terminals that  communicate together by forming a multihop radio n etwork and maintaining connectivity  decentralized. The nodes can move and their network  topology may be temporal. Each node acts  as a customer, server and router. In such network, there is no centralized administration. Each  node can join the network or it leave at any time.   Routing protocols in such networks can be classifie d mainly into three categories:   • Proactive routing protocols: They are based on the same principle as wired networks  routing. Paths in this type of routing are calculat ed in advance. Each node maintains multiple  routing tables by exchanging control packets betwee n neighbors. Indeed, if a node wants to  communicate with one another, it has the ability to  view local routing table and create path it  needs. OLSR [2](Optimized Link State Routing) and F SR [3](Fisheye State Routing) are  examples of proactive routing protocols.  International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 2, April 2012   54       • Reactive routing protocols: On the Contrary of proa ctive protocols, reactive protocols  calculate the route on request. If a source node ne eds to send a message to a destination node,  then it sends a request to all members of the netwo rk. After receiving the request, the  destination node sends a response back to the sourc e. However, the routing application  generates a slow pace because of the research paths  which can degrade application performance.  Such protocol has the disadvantage of being very co stly in terms of energy and packets  transmission when determining routes but has the ad vantage of not having to hold unused  information in routing tables. AODV [4] is an examp le of reactive protocols which are  described below.  • Hybrid routing protocols: Hybrid routing protocols or ""mixed"" combine the previous  two types of routing (proactive and reactive). The proactive protocol is applied in a small area  around the source (limited number of neighbors), wh ile the reactive protocol is applied beyond  this perimeter (distant neighbors). This combinatio n is performed in order to exploit the  advantages of each method and overcome their limita tions. ZRP [8] (Zone Routing Protocol)  and CBRP [7] (Cluster Based Routing Protocol) are t wo major examples of hybrid protocols.  One of the major and most critical factors in ad ho c networks is the limited battery energy. A  large amount of works is focused on this setting to  reduce the consumption of batteries. The  waste of energy may be due to the regular exchange of unnecessary control messages to have  more reliability.   AODV (Ad hoc OnDemand Distance Vector Routing Pro tocol) is a reactive routing protocol  designed by Charles E. Perkins and Elizabeth M. Roy er [4]. This protocol uses four types of  control messages in the aim to send data packets. T he first type is HELLO messages. This type  of messages, exchanged periodically to maintain a n eighborhood base. RREQ, RREP, RRER,  are used to establish a path to destination when an y node wants to send a data. This number of  control packet has a signified effect of the waste of resources.   To overcome the problem of energy consumption in th is protocol, we designed a new solution  that reduces the HELLO messages number exchanged an d to include the factor of energy  consumption that will be useful later for the routi ng messages. Firstly, we minimize the  exchange number of Hello messages. Secondly, we rep lace the regular periodic instant of  sending hello message by another proportionally to the energy stored in the battery of the node.  The node receiver of this hello message, do the inv ersely action to extract information  proportionally to the node sender energy, and the s ame information enclosed in hello message.   Insert this parameter does not affect the operation  or the information included in messages  exchanged and then we can obtain new information th at we can use to elect path. We call the  new protocol PCAODV (Power Control AODV).   This paper is organized as follows: we present the AODV routing protocol in Section 2. In  Section 3, we detail the related work, we expose th e used model and parameters in section 4,  and we formalize our solution and we present the ne w protocol called PCAODV in section 5.  In the rest of the paper, we illustrate, in section  6, an analytical comparative study between the  classical and the new protocol. In section 7, we pr esent a simulation evaluation, of the tow  protocol using JiST/SWANS simulator. We conclude th is paper and present future work in  Section 8.  2.  AD HOC ONDEMAND DISTANCE VECTOR ROUTING PROTOCOL   2.1. Overview  AODV [4] [5] is a reactive protocol that is based o n the concept of distance vector routing  protocols as its name mean. The algorithm of AODV i s inspired from the combination of a International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 2, April 2012   55       proactive and a reactive protocol [24, 25]. The pat h discovers and maintains is similar to the  process used in DSR [26]. The uses of HELLO message  exchange to establish a neighborhood  base and sequence number method are used in DSDV [2 7]. AODV present more performance in  static and bulky networks. These factors present ma jor challenges to MANETs routing protocol  researchers.   AODV performs route discovery request and saves onl y used routes in the routing table. It use  four different control message called HELLO, RREQ, RREP, and RRER message. In order to  transmit data packets, it broadcasts a route reques t RREQ (Route REQuest message) in the  wholly networks. Three cases are possible upon rece ipt of a RREQ message by any node. In the  first, if the node that received this message provi des a route to the requested destination in its  routing table, it responds with another type of mes sage RREP (Route REPly message). In the  second case, if it hasn’t information about the des tination, it will retransmit the message to its  neighbors that have not yet received. If all the ne ighbors have received the same message and/or  the node has lost the connection, it responds with an error message RERR (Rout ERRor  message).  After receiving a reply message, the sou rce node starts sending data packets along  the shortest path.  Other than these messages, AODV uses only one type of periodic message is HELLO message,  in order to maintain the Neighborhood basis.  In either case, the source node waits for a predefi ned timeout, the route establishment response  to the destination, and then it retransmits another  RREQ by increasing the maximum number of  hops (TTL: Time To Live). If after repeating this p rocess a limited number and the source get  nothing, it declares the absence of this destinatio n.   To maintain routes, AODV use an ACTIVE_ROUTE_TIMEOU T (ART) that equal to 3 second  [28]. If and defined routes between tow nodes, is n ot used within this period, then this node is  not sure if this route is yet available or not, it rebroadcast a RREQ if needs   2.2. Motivation  To exchange these types of route establishment mess ages, each node periodically exchange  HELLO messages to maintain a neighborhood base and the routing table. Since the regular  exchange of both control messages amplifies conside rably the energy consumption, and  bandwidth.   Generally, MANETs are characterized by limited ener gy and bandwidth. With the exchange of  this considerable number of control messages to est ablishment of routes, this aggravates the  resources and performances, precisely in the case o f bulky networks. One of major causes of  exchange of these message is the lost of paths, res ult of the exhausting of a node battery. To  overcome this problem, we suppose that all nodes co mposed the networks have information  about the energy stored in the batteries of its nei ghborhood. It avoid the routing using a node  that it battery will be exhausted and take into acc ount the nodes that can be used.  To do this, we propose a mechanism that reduces the  exchange of this type of message and use  it to inform about the energy state of the other no des in keeping the same performances of the  standard protocol. Using hello message, all nodes e xchange a new type of information about the  energy stored in battery, without changing the fiel ds composed this message, and simply tuning  the instant of sending it.  International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 2, April 2012   56       3.  RELATED WORK   "
149,Towards Better Bus Networks: A Visual Analytics Approach.txt,"Bus routes are typically updated every 3-5 years to meet constantly changing
travel demands. However, identifying deficient bus routes and finding their
optimal replacements remain challenging due to the difficulties in analyzing a
complex bus network and the large solution space comprising alternative routes.
Most of the automated approaches cannot produce satisfactory results in
real-world settings without laborious inspection and evaluation of the
candidates. The limitations observed in these approaches motivate us to
collaborate with domain experts and propose a visual analytics solution for the
performance analysis and incremental planning of bus routes based on an
existing bus network. Developing such a solution involves three major
challenges, namely, a) the in-depth analysis of complex bus route networks, b)
the interactive generation of improved route candidates, and c) the effective
evaluation of alternative bus routes. For challenge a, we employ an
overview-to-detail approach by dividing the analysis of a complex bus network
into three levels to facilitate the efficient identification of deficient
routes. For challenge b, we improve a route generation model and interpret the
performance of the generation with tailored visualizations. For challenge c, we
incorporate a conflict resolution strategy in the progressive decision-making
process to assist users in evaluating the alternative routes and finding the
most optimal one. The proposed system is evaluated with two usage scenarios
based on real-world data and received positive feedback from the experts.","•D. Weng, Z. Deng, and Y. Wu are with State Key Lab of CAD&CG, Zhejiang University, Hangzhou, China and Zhejiang Lab, Hangzhou, China. Email: fdweng, zikun rain, ycwu g@zju.edu.cn. Y. Wu is the corresponding author. • C. Zheng and M. Ma are with Zhejiang Lab, Hangzhou, China. Email: chbozheng@gmail.com, mamzaug@foxmail.com. • Jie Bao and Yu Zheng are with JD Intelligent Cities Research, Beijing, China and JD Intelligent Cities Business Unit, JD Digits, Beijing, China. Email: baojie@jd.com, msyuzheng@outlook.com. • Mingliang Xu is with School of Information Engineering, Zhengzhou University, Zhengzhou, China and Henan Institute of Advanced Technology, Zhengzhou University, Zhengzhou, China. Email: iexumingliang@zzu.edu.cn.In the last few centuries, the public transit bus service has become one of the most widely deployed public transportation backbones worldwide because of its ﬂexibility and affordability. Bus routes are typically updated every 3–5 years because the travel demand of bus riders is constantly changing [44]. However, revising bus routes remains difﬁcult because a) it is hard to analyze the performance of a huge and complex bus network to determine which routes are problematic, and b) a large solution space constituted by many factors involved in the planning Manuscript received xx xxx. 201x; accepted xx xxx. 201x. Date of Publication xx xxx. 201x; date of current version xx xxx. 201x. For information on obtaining reprints of this article, please send email to: reprints@ieee.org. Digital Object Identiﬁer: xx.xxxx/TVCG.201x.xxxxxxx 1arXiv:2008.10915v3  [cs.HC]  5 Nov 2020process [61] needs to be extensively evaluated. Most bus networks are planned and updated manually or by ana lyzing small datasets based on planners’ knowledge [22, 47, ]. Such methods can be laborious and timeconsuming. To identify feasible bus routes, datadriven planning methods [29, 46, 55], including the mathematical and heuristic ones, have been proposed to extract the routes based on predeﬁned criteria. However, most of these methods act as a black box, generating an optimized result based on the given input data and parameters without explanations. Therefore, verifying the quality of the generated routes or adjusting the parameters to ﬁnd an improved solution is difﬁcult for domain experts. The interpretability of route generation has been further studied by Chen et al. [17] and Weng et al. [63]. Rather than producing a potentially unsatisfactory route, they propose to generate a set of Paretooptimal transit routes , where none of the routes is better than any other route for all given criteria. However, experts are still required to manually compare among hundreds of routes and determine the most optimal one. In this study, we collaborated with the experts from the transportation and urban computing domains to develop a solution that facilitates efﬁcient analysis and incremental planning of bus routes. Inspired by the urban data analytics studies [39, 64], we employ a visual analytics approach to integrate domain knowledge with the computational power of the Paretooptimal route extraction method [63], thereby enabling the experts to interactively interpret the performance of complex bus networks and evaluate the alternative routes generated in realtime. Developing such a solution poses the following three challenges: Indepth analysis of complex bus route networks. The performance of bus route networks must be extensively evaluated ﬁrst to detect the ineffective parts that need to be replanned. However, bus route networks that operate in a large city may comprise a hierarchy of thousands of bus routes and stations, producing millions of trip records per month. Analyzing such a complex dataset for deﬁcient routes poses challenges in the scalability and effectiveness of the proposed solution. Interactive generation of improved route candidates. The Pareto optimal route search model [63] can be used to generate potential route alternatives to the detected deﬁcient routes. However, the constraints provided by the model are insufﬁcient for many practical scenarios, for example, planning the routes via a few key stops. Moreover, since the model is progressive and timeconsuming, the experts need to know when the results are sufﬁciently good to stop the search. Effective evaluation of alternative bus routes. A large number of route alternatives will be generated with the model. These alternatives can be diverse and complicated. The experts request that they should be kept in the loop to make informed and transparent decisions. However, the volume, diversity, and complexity of the generated candidates prohibit the experts from effectively evaluating these candidates based on topologies or performance criteria to identify the most optimal one. To address these challenges, we propose BNV A (Bus Network Visual Analytics system), a novel visual analytics system that helps bus route planners analyze and improve the performance of bus route networks. For the ﬁrst challenge, we adopt a hierarchical exploration approach comprising network, route, and stop levels and propose a novel matrix view to facilitate the analysis of passenger ﬂows and transfers; for the second challenge, we extend the model to support various constraints and integrate tailored visualizations to depict the performance of the generated routes in realtime; for the third challenge, we develop a progressive decisionmaking strategy based on route aggregation to help users evaluate the topologies and criteria of alternative routes. The contributions of this study are as follows: •We characterize the user requirements in analyzing and improving the performance of bus route networks; •We extend the Paretooptimal route generation model to support additional constraints from practical scenarios; •We develop a novel visual analytics system for bus route planning, featuring a route matrix view for passenger ﬂow analysis and a conﬂict resolution strategy for progressive route decisionmaking; •We evaluate our approach with two usage scenarios based on a realworld dataset and received positive feedback from experts.2 R ELATED WORK "
58,Quantum Locker Using a Novel Verification Algorithm and Its Experimental Realization in IBM Quantum Computer.txt,"It is well known that Grover's algorithm asymptotically transforms an equal
superposition state into an eigenstate (of a given basis). Here, we demonstrate
a verification algorithm based on weak measurement which can achieve the same
purpose even if the qubit is not in an equal superposition state. The proposed
algorithm highlights the distinguishability between any arbitrary single qubit
superposition state and an eigenstate. We apply this algorithm to propose the
scheme of a Quantum Locker, a protocol in which any legitimate party can verify
his/her authenticity by using a newly developed quantum One-Time Password (OTP)
and retrieve the necessary message from the locker. We formally explicate the
working of quantum locker in association with the quantum OTP, which
theoretically offers a much higher security against any adversary, as compared
to any classical security device.","Grover’s search algorithm is the optimal algorithm for achieving quad ratic speedup in searching a particular “marked” state from an uniformly distribute d database [ 1]. A gener alization of the algorithm [ 2–11] allows for any arbitrary superposition state of the quantum database instead of the equal superposition state [ 2,3]. Using the standard Grover’s algo rithm, a marked state can not be obtained from the initial state of t he quantum database with 100% success. However, the same can be achieved with certain ty by a modiﬁcation of Grover’s algorithm as proposed by Hoyer [ 4]. Long also presents a modiﬁed search algorithm with a zero theoretical failure rate [ 5], where the algorithm searches a marked state from an evenly distributed database using phase matching condition [ 6,7]. Liu [8] generalized Long’s algorithm, in which multimarked states are searched with cert ainty from an arbitrary Nitem complex initial amplitude distributed quantum database ( Nis not necessarily 2n). In the scheme proposed by Liu, a system of multimarked states can be deterministically searched from an arbitrary initial state of an unsorted database , of any arbitrary size. Let us consider a particular case, in which we intend to extract the stat e|1/an}bracketri}htfrom the database having arbitrary superposition state α|0/an}bracketri}ht+β|1/an}bracketri}ht(α,β∈C,β/ne}ationslash= 0). In order to do so, the machine that executes the algorithm must have a prioriknowledge of the coeﬃcients αand β. But what if these coeﬃcients are unknown? Liu’s scheme fails to ove rcome this issue, which has been tackled by our proposed algorithm which can search a particular marked state from an arbitrary superposition state with asymptotic dete rminism, even if the initial state is unknown to the machine. Intheabove example, if we takethe initial databasestateto bethe state|0/an}bracketri}ht(β= 0), then Liu’sschemefailsaltogether, sinceoneofthealgorithm’sparameter sbecomesindeterminant. However, the database will remain in the state |0/an}bracketri}htif our algorithm is operated. Hence, besides being a quantum search algorithm, this also serves as an algo rithm for veriﬁcation, as it can asymptotically distinguish a single qubit eigenstate of any bas is from an unknown and arbitrary single qubit superposition state. We apply this novel r esult of the algorithm to propose a scheme of a quantum locker for which the motivation is d escribed as follows. Before the advent of electronic information storage and transfe r, a classical locker with a physical key was the only means available for secure storage of con tents. The need to trans mit information securely called for advanced methods of user authe ntication, e.g.passwords 2[12]. The onset of the digital era has consequentially paved the way for highly secure means of information storage and retrieval such as elockers. However , the digitization era also brought with it increased vulnerability of static passwords to replay attacks [13]. Recently, onetime passwords (OTPs) [ 14] based on pseudorandom numbers have gained popularity, which are timelimited and suitable for highly conﬁdential transaction s. Over the past few years, the focus has shifted towards the deve lopment of security pro tocols that exploit some of the exclusive features of quantum mech anics, which may oﬀer higher security than their classical counterparts. One such feat ure is the ‘nocloning theo rem’ [15], which forbids the construction of an exact replica of a generic/un known quantum state. This property is greatly beneﬁcial in quantum cryptosyste ms as it enables two com municating parties to detect whether or not an adversary has inte rcepted the transmitted message. Many quantum security schemes have been devised which have proved to be unconditionally secure protocols for safeguarding information [ 16–21]. Such protocols ef fectively use quantum phenomena like superposition and entangleme nt [22]. Some of these information security techniques include a quantum key distribution s cheme [16–21,23,24], quantum identiﬁcation scheme [ 25–27], quantum digital signature scheme [ 28], quantum cheque scheme [ 29,30], to name a few. There have been many works in the past few years regarding the re alization of OTPs in quantum format. A quantum onetime password based on a set of nentanglements (Bell States) was proposed by Mihara [ 31]. Besides, recent works have led to the realization of robust authentication protocols based on quantum passwords [ 32,33]. Recently, encrypted data storage by the application of a disordered ﬁeld on photonic qua ntum memories has been accomplished [ 34]. The proposed quantum locker is one of many applications realizable in t he future which will practically use quantum passwords. In our proposed scheme, t he locker does not involve anyclassicaloperations,nordoesitrequirebitstostoretheoutp ut. Inthecourseofourwork, we hold the assumption that the sharing of entanglement between t he two communicating parties considered is secure and can be preserved indeﬁnitely witho ut getting decohered or otherwise lost by other means [ 16,35]. All quantum channels and gates used in our scheme are assumed to be free from decoherence and errors. Recently, a series of quantum information processing tasks [ 36–50] have been run us ing IBM quantum computer. Hence, motivated by this fact, we have used IBM’s 5 qubit 3quantum processor ‘ibmqx4’ to carry out the experimental proce dure to explicitly show the working of our proposed veriﬁcation algorithm and demonstrate th e scheme of a Quantum Locker. II. RESULTS Veriﬁcation Algorithm Figure 1. Circuit illustrating the Veriﬁcation Box V. This algorithm uses a veriﬁcation box V(Fig.1) to discriminate two nonorthogonal states, i.e., |0/an}bracketri}ht, and a generic state |φ/an}bracketri}ht ≡α|0/an}bracketri}ht+β|1/an}bracketri}ht. The proposed scheme is composed of several iterations of a weak measurement protocol [ 51], where an ancillary qubit |δL/an}bracketri}ht(in the state|0/an}bracketri}ht) is weakly coupled to the system. After each iteration, a projectiv e measurement is performedontheancilla, which slightly perturbsthestateofthesy stem (|φ/an}bracketri}ht). Theevolution of the coupled system ( |φ/an}bracketri}ht⊗|δL/an}bracketri}ht) after each iteration is described by the following unitary operatorU, U= [Rz(θ)⊗I2][cosθI4−isinθC0NOT12] (1) whereI2andI4denote identity matrices of order 2 and 4 respectively. Here, C0NOT12 ﬂips the target qubit only when the control qubit is in state |0/an}bracketri}ht. It is to be noted that the operatorUdescribing theevolution ofthecoupled system issimply the Controlled0−Rx(2θ) operation, where the operator Rx(2θ) acts on the ancilla (target) qubit only if the system (control) qubit is in state |0/an}bracketri}ht. Here,θis a parameter intrinsic to the locker, which is an arbitrarily small value ( θ→0). At the end of the ﬁrst iteration, the operator Utransforms the composite system |φ/an}bracketri}ht|δL/an}bracketri}htinto the following state, U|φ/an}bracketri}ht|δL/an}bracketri}ht ≡(αcosθ|0/an}bracketri}ht+β|1/an}bracketri}ht)|0/an}bracketri}ht−αisinθ|0/an}bracketri}ht|1/an}bracketri}ht (2) It can be veriﬁed that the operation Controlled0−Rx(2θ) can be implemented by using universal single qubit gates and CNOTgate, as shown by the following circuit (Fig. 2). 4Figure 2. Circuit depicting the implementation of U≡Controlled0−Rx(2θ). After the execution of the unitary transformation U, a projective measurement (in z basis) isperformedontheancillaryqubit, resulting inoutcomes |0/an}bracketri}htand|1/an}bracketri}htwithprobabilities p0andp1respectively. p0=|α|2cos2θ+|β|2≈1−|α|2θ2(3) p1=|α|2sin2θ≈ |α|2θ2(4) In the limit θ→0, the probability of obtaining the state |1/an}bracketri}hton measurement of the ancilla is negligible. Hence, assuming the outcome of the ancilla state to be|0/an}bracketri}ht, the state of the system collapses to |φ/an}bracketri}ht=αcosθ|0/an}bracketri}ht+β|1/an}bracketri}ht/radicalbig |α|2cos2θ+|β|2 ≈(αcosθ|0/an}bracketri}ht+β|1/an}bracketri}ht)(1−|α|2θ2)−1 2 ≈(α(1−θ2 2)|0/an}bracketri}ht+β|1/an}bracketri}ht)(1+1 2|α|2θ2) =α(1−|β|2θ2 2)|0/an}bracketri}ht+β(1+|α|2θ2 2)|1/an}bracketri}ht (5) Evidently, after one iteration, the state of the system is perturb ed. Denoting α′= α(1−|β|2θ2 2) andβ′=β(1+|α|2θ2 2), it is to be noted that |α′|<|α|, while|β′|>|β|, provided α/ne}ationslash= 0 andβ/ne}ationslash= 0. The state of the system is weakly perturbed towards the zbasis eigen state|1/an}bracketri}ht. If we repeat the unitary transformation Uon the composite system, followed by a measurement on the ancillary qubit, the probability of obtaining the ancilla in the state |1/an}bracketri}ht, will bep′ 1≈ |α′|2θ2, which is less than p1. Hence, the state of the ancilla collapses to the state|0/an}bracketri}htwith an even higher probability than the previous one. In this case, t he state of the system |φ/an}bracketri}htis further perturbed towards the state |1/an}bracketri}ht. In other words, the coeﬃcient of the eigen state |1/an}bracketri}htin the superposition state of the system increases slightly in magnitu de. If we repeat this protocol a large number of times (while assuming th at the state |0/an}bracketri}htis obtained in each measurement), we will obtain the ﬁnal state |φ/an}bracketri}htof the system (initially in the stateα|0/an}bracketri}ht+β|1/an}bracketri}ht) arbitrarily close to the zbasis eigen state |1/an}bracketri}ht. Our assumption, that 5the state |0/an}bracketri}htis obtained after every measurement of the ancilla, is justiﬁable sinc eθcan take any arbitrary small value ( θ→0), such that the probability of getting |1/an}bracketri}htis also extremely small (having a θ2dependence). Additionally, our assumption is greatly aided by the fa ct that the probability of obtaining the state |1/an}bracketri}htdecreases with each iteration, since it has a |α|2dependence, and |α|decreases with each iteration. It is evident that, after each iteration of the veriﬁcation box, the state of the system does not change if it is initially in any of the zbasis eigenstates {|0/an}bracketri}ht,|1/an}bracketri}ht}. It can also be pointed out that the eigen states of the zbasis act as “ﬁxed points” for the evolution protocol mentioned above, where |0/an}bracketri}htand|1/an}bracketri}htbehave as unstable and stable ﬁxed points respectively. However, if a generic superposition state α|0/an}bracketri}ht+β|1/an}bracketri}ht(α,β/ne}ationslash= 0) is fed into our veriﬁcation box, then the state of the system asymptotically a pproaches the stable ﬁxed point|1/an}bracketri}ht. In this way, we can distinguish the eigenstate |0/an}bracketri}htfrom any arbitrary superposition stateα|0/an}bracketri}ht+β|1/an}bracketri}ht. A single iteration of the standard Grover’s algorithm rotates any ar bitrary single qubit state|ψ/an}bracketri}htthrough an angle ofπ 2about the zaxis, implying that the state transforms back to itself periodically after 4 iterations. Our veriﬁcation algorithm use s an ancillary qubit, which is weakly coupled to the system qubit. It involves a repetitive se ries of coupling and decoupling of theancilla (environment) with thesystem. Hence, som e informationabout the state of the system is leaked to the environment. During the proce ss, the coupling between thetwoqubitsisfollowedbymeasurement oftheancillain zbasis, whichresultsincollapsing the state of the ancilla to a zbasis eigenstate ( |0/an}bracketri}ht) with high probability. Correspondingly, the state of the system is only weakly perturbed, towards the oth er eigenstate ( |1/an}bracketri}ht). This results in decoupling the system from the environment. The same pr ocedure for coupling and decoupling is repeated a large number of times. Thecouplingprocesstakesplacebymeansoftheunitarytransfor mationU≡Controlled0− Rx(2θ). To preserve the eigenstate |0/an}bracketri}htand transform any other arbitrary state to the eigen state|1/an}bracketri}ht, theControlled0−Rx(2θ) operation is used. In a way, it prevents any information about the state of the system related to the eigenstate |0/an}bracketri}htfrom passing to the environment (ancilla). The operation Uis also equivalent to the operation [ Rz⊗I]e−iC0NOT12θ, acondi tional“decay” operation, which acts as an eigenstate ampliﬁer, amplifying the eigenstate |1/an}bracketri}htin the superposition state |ψ/an}bracketri}ht. Quantum Locker: Based on a Quantum OTP 6Deﬁnition of a Quantum Locker and a Quantum OTP Informally, the proposed scheme of a quantum locker consists of t hree stages, •First stage, where a message and certain parameters, required for the veriﬁc ation of One Time Password (OTP), are fed into the locker. •Second stage, where a quantum OTP state is teleported to the intended receiver. •Third stage, whereaprotocolispresentedfortheveriﬁcationoftheOTPandt ransfer of the message. Ideally, an OTP is expected to have the following properties, •Veriﬁability, i.e., it can be veriﬁed by the locker. •Unforgeability, i.e., an OTP can neither be counterfeited nor can it be used more than once to access the message stored in the locker. The Quantum Locker Scheme For the purpose of brevity, two parties, Alice and Bob, are introdu ced to describe the scheme. Initially, theyshareamaximally entangled pairofqubits inthe state,|00/angbracketright+|11/angbracketright√ 2, which is to be used as the teleportation channel between the two. Alice st ores a message along with an OTP in the locker, situated at a secure location accessible to b oth parties, so that Bob could access the message in the future. She then teleports th e OTP to Bob, by using which he veriﬁes his authenticity and retrieves the message from th e locker. Locker: It consists of mqubits which store the message (named as message qubits), and one ancillary qubit, which are inaccessible to any outside party. The m essage qubits can be either|0/an}bracketri}htor|1/an}bracketri}ht. Themqubit message is, therefore, an arbitrary string composed of |0/an}bracketri}hts and|1/an}bracketri}hts only. Let/vextendsingle/vextendsingle/vextendsinglea(i) L/angbracketrightBig and|δL/an}bracketri}htdenote the ithmessage qubit and the ancillary qubit, in the locker respectively. The locker has an input slot through which a ny party may input the password qubit, as well as mother input slots into which the party may place mqubits in|0/an}bracketri}htstate, meant for retrieving the message. In the whole scheme, it is assumed that Bob has the prior knowledge about the basis of the stored message qub its. The Protocol Storage of Message And Password 7Themmessage qubits in the locker are initially prepared in |0/an}bracketri}htstate. Now, Alice encodes her message in the locker by applying X gates on the requisite messag e qubits, in order to make a binary string of |0/an}bracketri}hts and|1/an}bracketri}hts. This feature is provided by the locker itself. For reasons that have been stated in a later subsection, a string with a ll qubits in |0/an}bracketri}htstate is not a valid message. Henceforth, for password purposes, Alice mu st randomly choose and input the values of θ1,θ2andθ3to the locker, where θ1,θ2,θ3ǫ[−π,π]. These values act as parameters for the rotation operator denoted by, R−1(θ1,θ2,θ3), whereR−1(θ1,θ2,θ3) = Rx(−θ1)Ry(−θ2)Rz(−θ3). Generation of OTP State Alice owns an ancilla qubit which is initially kept in |0/an}bracketri}htstate. She is equipped with a portable device which can perform the operation, R(θ1,θ2,θ3) =Rz(θ3)Ry(θ2)Rx(θ1), where θ1,θ2andθ3are the same parameters previously used as inputs to the locker. S ince this device is portable, she can perform this operation anytime and anyw here at her will. Alice generates the OTP state denoted by, |ψ/an}bracketri}htby performing the above operation on her ancilla qubit, and sends it to Bob through the teleportation channel. Veriﬁcation of OTP Forretrieving themessage, Bobmust storetheteleportedstate ,|ψ/an}bracketri}htinaqubit. Thelocker implements the operation R−1(θ1,θ2,θ3) on this qubit to create a new state, represented by |φ/an}bracketri}ht. He also keeps mqubits (named as blank qubits) possessing |0/an}bracketri}htstate in the speciﬁed slots of the locker. For the purpose of veriﬁcation, a veriﬁcation b oxVhas been designed, the detailed working of which has already been discussed. The veriﬁc ation boxVacts on|φ/an}bracketri}ht and produces two distinguishable results depending on whether the qubit entered by some party is in the state |ψ/an}bracketri}ht(the state originally prepared by Alice) or not. CASE I  Entering Correct Password: In this case, the password entered into the locker is in the state |ψ/an}bracketri}ht. The operation of R−1(θ1,θ2,θ3) on|ψ/an}bracketri}htyields|φ/an}bracketri}ht ≡ |0/an}bracketri}ht. The state does not change by applying the veriﬁcation box Von|φ/an}bracketri}hta large number of times. CASE II  Entering Wrong Password: In this case, the password entered into the locker is in a state |ψ′/an}bracketri}ht, which is diﬀerent from the state |ψ/an}bracketri}ht. The operation of R−1(θ1,θ2,θ3) on|ψ′/an}bracketri}htyields|φ/an}bracketri}ht ≡α|0/an}bracketri}ht+β|1/an}bracketri}ht, whereαandβare arbitrary complex numbers. In this case, after the operation of the veriﬁcation box Va large number of times, the state |φ/an}bracketri}htis transformed into the state |1/an}bracketri}ht, which can be distinguished from the state |0/an}bracketri}ht. Transfer of Message 8After the operation of the veriﬁcation box Von|φ/an}bracketri}ht, a measurement is performed on this qubit (in zbasis). To transfer the ithmessage qubit/vextendsingle/vextendsingle/vextendsinglea(i) L/angbracketrightBig to theithblank qubit/vextendsingle/vextendsingle/vextendsingleb(i) L/angbracketrightBig , we use the circuit shown in Fig. 3. Figure 3. A C2NOT gate is used for transferring information from the ithmessage qubit/vextendsingle/vextendsingle/vextendsinglea(i) L/angbracketrightBig to theithblank qubit/vextendsingle/vextendsingle/vextendsingleb(i) L/angbracketrightBig . This transfer of information takes place only if the qubit |φ/an}bracketri}htis found to be in the state |0/an}bracketri}htafter the measurement. There aremsuch Toﬀoli gates as used in Fig. 3, where the ﬁrst control qubit is the same (|φ/an}bracketri}ht, following measurement) for all gates, while the second control an d the target qubits of theith Toﬀoli gate are in/vextendsingle/vextendsingle/vextendsinglea(i) L/angbracketrightBig and/vextendsingle/vextendsingle/vextendsingleb(i) L/angbracketrightBig states respectively. It can be easily seen that the measurement of |φ/an}bracketri}htgives the outcome |0/an}bracketri}htwhen the entered password is correct. Hence,/vextendsingle/vextendsingle/vextendsingleb(i) L/angbracketrightBig becomes |1/an}bracketri}htif/vextendsingle/vextendsingle/vextendsinglea(i) L/angbracketrightBig is in the state |1/an}bracketri}ht, otherwise it remains in the state |0/an}bracketri}ht. Thus, the information stored in the message qubits is transferred to the blan k qubits entered into the locker by the party, which are now ready for retrieval. For the case when the entered password is incorrect, measureme nt of|φ/an}bracketri}htfollowing the veriﬁcation box gives the outcome |1/an}bracketri}htwith an arbitrarily high probability. Hence, none of the/vextendsingle/vextendsingle/vextendsingleb(i) L/angbracketrightBig is ﬂipped, resulting in no transfer of information. This explains why/vextendsingle/vextendsingle/vextendsinglea(i) L/angbracketrightBig =|0/an}bracketri}ht∀i is not a valid message we consider this case as “informationless”. III. METHODS "
163,An Efficient and User Privacy-Preserving Routing Protocol for Wireless Mesh Networks.txt,"Wireless mesh networks (WMNs) have emerged as a key technology for next
generation wireless broadband networks showing rapid progress and inspiring
numerous compelling applications. A WMN comprises of a set of mesh routers
(MRs) and mesh clients (MCs), where MRs are connected to the Internet backbone
through the Internet gateways (IGWs). The MCs are wireless devices and
communicate among themselves over possibly multi-hop paths with or without the
involvement of MRs. User privacy and security have been primary concerns in
WMNs due to their peer-to-peer network topology, shared wireless medium,
stringent resource constraints, and highly dynamic environment. Moreover, to
support real-time applications, WMNs must also be equipped with robust,
reliable and efficient routing protocols so as to minimize the end-to-end
latency. Design of a secure and efficient routing protocol for WMNs, therefore,
is of paramount importance. In this paper, we propose an efficient and reliable
routing protocol that also provides user anonymity in WMNs. The protocol is
based on an accurate estimation of the available bandwidth in the wireless
links and a robust estimation of the end-to-end delay in a routing path, and
minimization of control message overhead. The user anonymity, authentication
and data privacy is achieved by application of a novel protocol that is based
on Rivest's ring signature scheme. Simulations carried out on the proposed
protocol demonstrate that it is more efficient than some of the existing
routing protocols.","cept to meet the challenges in nextgeneration wireless networks s uch as providing ﬂexible, adaptive, and reconﬁgurable architecture while oﬀering co steﬀective solu tions to service providers. WMNs are multihop wireless networks fo rmed by mesh routers (which form a wireless mesh backbone) and mesh clients. Th e mesh routers provide a rich radio mesh connectivity which signiﬁcantly reduces the upfront de ployment cost of the network. Mesh routers are typically stationa ry and do not have power constraints. However, the clients are mobile and energyco nstrained. Some mesh routers are designated as gateway routers which are conne cted to the Internet through a wired backbone. A gateway router provides access to c onventional clients and interconnects ad hoc, sensor, cellular, and other networkst o the Internet. A mesh networkcan provide multihop communication paths between wireles s clients, thereby serving as a community network, or can provide multihop paths bet ween the client and the gateway router, thereby providing broadband Internet access to the clients. As WMNs become an increasingly popular replacement technology for lastmile connectivity to the home networking, community and neighborhood networking, it is imperative to design an eﬃcient resource management system for these networks. Routing is one of the most challenging issues in resource management for supporting realtimeapplicationswith stringentQoSrequirements. However,m ost ofthe existing routing protocols for WMNs are extensions of protocols originally de signed for mobile ad hoc networks (MANETs) and thus they perform suboptimally. This paperpresentsan eﬃcientand secureroutingprotocolforW MNs that isable to handle stringent QoS requirements of realtime applications while p roviding user ∗Innovation Lab, Tata Consultancy Services Ltd, Bengal Inte lligent Park, Salt Lake Electronics Complex, Kolkata  700091, INDIA. (jaydip.sen@tcs.com). Q uestions, comments, or corrections to this document may be directed to that email address. 12 JAYDIP SEN privacy in a secure way. It involves a very low control overhead and hence provides a high network throughput when the number of data sources in the network is large. While issues such as reduction of control overhead of routing and e nhancement of network throughput have been addressed for WMNs in [1], the prot ocol proposed in this paper is more eﬃcient than those schemes as observed in the sim ulation results. The key contributions of the paper are as follows: (i) It exploits net work topolog ical information to increase the eﬃciency of route discovery proce ss and uses multi point relay (MPR) nodes and circular routing (discussed in Section 4) to enhance the network throughput by reducing the control overhead. (ii) I t computes a reliable link quality estimator and utilizes it in route selection. (iii) It provides a f ramework for reliable and robust estimation of available bandwidth and endto end delay in a routing path so that ﬂow admission with guaranteed QoS for applica tions can be made. It also ensures that the number of retransmission required is minimized. (iv) It provides a simple mechanism to identify selﬁsh nodes who consume n etwork re sources but do not cooperate with other nodes in forwarding pack ets for others. (v) It presents a novel user anonymization scheme that enables secu re authentication of the users while protecting their privacy. The rest of this paper is organized as follows. Section 2 describes re lated work on routinginWMNs. Section3discussessomeimportantchallengesinrou tinginWMNs. Section 4 describes the details of the proposed routing protocol. S imulation results are presented in Section 5. Finally, Section 6 concludes the paper wh ile highlighting some future scope of work. 2. Related Work. Although signiﬁcant amount of work has been done on rout "
332,Interception in Distance-Vector Routing Networks.txt,"Despite the large effort devoted to cybersecurity research over the last
decades, cyber intrusions and attacks are still increasing. With respect to
routing networks, route hijacking has highlighted the need to reexamine the
existing protocols that govern traffic routing. In particular, our pri- mary
question is how the topology of a network affects the susceptibility of a
routing protocol to endogenous route misdirection. In this paper we define and
analyze an abstract model of traffic interception (i.e. eavesdropping) in
distance-vector routing networks. Specifically, we study al- gorithms that
measure the potential of groups of dishonest agents to divert traffic through
their infrastructure under the constraint that messages must reach their
intended destinations. We relate two variants of our model based on the allowed
kinds of lies, define strategies for colluding agents, and prove optimality in
special cases. In our main theorem we derive a provably optimal monitoring
strategy for subsets of agents in which no two are adjacent, and we extend this
strategy to the general case. Finally, we use our results to analyze the
susceptibility of real and synthetic networks to endogenous traffic
interception. In the Autonomous Systems (AS) graph of the United States, we
show that compromising only 18 random nodes in the AS graph surprisingly
captures 10% of all traffic paths in the network in expectation when a
distance-vector routing protocol is in use.","Several recent events have demonstrated that internet routing protocols are particularly vulnerable to misdi rections in routing [6, 10, 11, 15]. This brings up the question: How vulnerable are trustbased communication protocols to malicious agents who can abuse this trust? To answer this question, we present and study a model of trac interception in routing networks largely inspired by reallife incidents. See Figure 1 for an example. In practice, a wide range of routing protocols are devel oped and implemented for communications. For exam ple, the Border Gateway Protocol (BGP) is used for interdomain communications between autonomous sys tems in the modern Internet; distancevector and link state routing protocols are used for intradomain com munications. Instead of going into the technical details of the protocols and their business models, we study a mathematical and parsimonious model for trac in terception in general. The model closely resembles the distancevector protocols such as the Routing Informa tion Protocol (RIP) [12, 16]. Due to their simplicity and eciency, distancevector protocols are widely used in moderatesize IP networks and ad hoc mobile networks [13, 23]. Therefore, in this work we study a theoretical model for \distance frauds"" [21] in an abstract setting of distancevector protocols, and aim to provide a start ing point to investigate security issues of other complex routing protocols.The model is stated formally in Section 3, but can be loosely described as follows. For a graph Gin which ver tices are agents, a subset Sof agents are designated \col luders"" and the rest are \honest"". Honest agents main tain a distancevector recording their believed distances to all other agents in the network, broadcasting this in formation to their immediate neighbors in each round and updating their beliefs with the information broad casted to them. When honest agents send or forward a message, they route it to any neighbor that is closest to the message's recipient. Meanwhile, colluding agents have knowledge about the entire graph and want to max imize the number of messages that are routed through at least one member of S. They can achieve this by lying in their broadcasts to their neighbors making it appear they are closer to the message's destination than they actually are. As a result, the honest agents will unknowingly for ward messages to the colluding agents along a potentially suboptimal path (See, for example, Figure 1). While it would seem easy for the colluding agents to lie in order to intercept messages, we impose the additional requirement that every message must eventually reach its intended destination, as frequently dropped messages would raise an alarm causing the colluders to be discov ered. This makes strategy design dicult for the collud ing agents, as they must carefully balance lying in order to attract messages while not overstating their proximity to the recipient which would cause neverending cycles. Solving this problem not only provides a tool for anaarXiv:1507.05206v3  [cs.CR]  30 Mar 20162 Figure 1. An incident in connection with trac interception as reported in [15], where a \colluding agent"" (square) in Ukraine, broadcasts a false distance and intercepts a message sent from an honest agent in Texas whose target is the British Telecom, that services the UK Atomic Weapon's Establishment. The solid line indicates how the message should be routed under the presence of only honest agents. The dotted line demonstrates how the message is routed when the \colluding agent"" (square) broadcasts a false distance, and reroutes the message to its intended target. The above image is a simplication of the documented rerouting, as the circle in the UK is in fact representative of multiple honest agents (autonomous systems). lyzing the susceptibility of a network to endogenous in formation interception, but further informs protocol de signers of the vulnerability of honest agents naively fol lowing protocols of this type. Our contributions are to analyze this model at many levels from both theoretical and practical perspectives. In this article, we accomplish the following: Formulate appropriate generalized combinatorial models for trustbased communication in networks (Section 3); Demonstrate that the case where each colluding agent may broadcast a dierent piece of infor mation to each of its neighbors, the nonuniform broadcast model, reduces to the case where each individual colluding agent must broadcast the same information to its neighbors, the uniform broadcast model (Proposition 4.2); Given a set of malicious agents Swhere none of them are adjacent, provide the optimal strategy re garding how the agents of Sshould broadcast (The orem 5.1); Show that optimally choosing a set of colluding agents is NPcomplete (Section 4.1); and Provide simulations demonstrating that, for various types of realworld and synthetic networks, a very small portion of colluding agents, acting strategi cally, can in fact intercept a signicant proportion of messages. These results add a new perspectiveon the attack tolerance of scalefree networks [1]. In addition to being vulnerable to connectivity attacks by removing high degree nodes, they are vulnerable even to random interception attacks (Section 6). This paper is organized as follows. In Section 2 we review related work. In Section 3 we dene our models, and discuss their complexity in Section 4. In Section 5 we dene our strategies, and in Section 5.2 we prove the optimality of our strategy (Theorem 5.1). We generalize the strategy of Theorem 5.1 to the general case of con nected agents in Section 5.3. In Section 6 we empirically evaluate the quality of our strategies, and in Section 7 we conclude with open problems. 2. RELATED WORK "
187,Routing protocols for mobile sensor networks: a comparative study.txt,"This paper presents a comparison of cluster-based position and non
position-based routing protocols for mobile wireless sensor networks to outline
design considerations of protocols for mobile environments. The selected
protocols are compared on the basis of multiple parameters, which include
packet delivery ratio, packet loss, network lifetime, and control overhead
using variable number of nodes and speeds. The extensive simulation and
analysis of results show that position-based routing protocols incur less
packet loss as compared to the non position based protocols. However,
position-based protocols require localization mechanism or a GPS for the
location information, which consumes energy and affects the network lifetime.
Alternatively, non position-based protocols are more energy efficient and
provide extended network lifetime.","Wireless sensor networ k (WSN ) is a network of sensor nodes that are distributed over a certain  area to monitor a physical phenomenon, such a s temperature, humidity , or fire. WSN  consist of  a large number of  sensor nodes and a resource rich sink node(s) that acts as a gateway to other  networks or a final destination  [1]. The sensor nodes are characterized by limited battery power,  processing capacity, and memory resources [2].  Therefore, WSN s require low foot print  communication schemes , which utilize minimum resources without compromising the required  quality of service. Moreover, due to limited energy of the sensor nodes,  the energy efficiency is   one of the most important  design considerations  of the WSN routing protocols  [3]. However,  mobility of sensor nodes makes  the routing  process challenging and complex , which  hampers  the energy efficiency of the routing protocols .  An overwhelming majority of the current resea rch on sensor networks consider  static networks  [1, 2 , and 4 ]. However, there exist  many applications [ 6, 7] which require mobile nodes,  for  instance, habitat monitoring,  battlefield surveillance, and object tracking. In mobile WSNs,  unpredictable topology changes and frequent  path failures make the routing challengi ng [2] ,  because  path breakage leads to increase  in the endtoend delay and packet loss [8]. Some routing schemes assume that the sensor nodes can directly communicate with  the sink node [7,  8, and 9]. This assumption restricts the  geographic scalability , but is countered by multi hop  routing schemes . Considering the mobility and resource constrained environment , WSNs  require  energy aware routing protocols , capable of decreasing  the packet loss , and enhancing   robustness against mobility of nodes. Furthermor e, WSN protocols  require  scalability and  aptitude  to coup with dynamicity of the network that is caused by  the mobility  [10, 11] . To  achieve this , backup strategies are required which  enable  data packet s to reach a destination in  the presence of  mobility [ 12].  In this study, we focus the comparison of cluster based position and non position based  hierarchal routing schemes based  on multiple performance factors , such as energy efficiency ,  overhead , and packet loss. We select six routing protocols for comparison , which are studied  thoroughly for  variable  network densities and node speeds . The  performance metrics that are  used for the evaluation of the protocols include , average packet delivery ratio, network lifetime,   average number of control packets sent during the protocol operation, and average percentage of  packet loss.   The remainder of this paper is organized as follows. Section 2  contains  the related work . Section  3 presents the comparison strategy.  Section 4 consists  of results and discussion , whereas Section  5 concludes the paper.   2. RELATED WORK   "
165,The Aligned-Coordinated Geographical Routing for Multihop Wireless Networks.txt,"The stateless, low overhead and distributed nature of the Geographic routing
protocols attract a lot of research attentions recently. Since the geographic
routing would face void problems, leading to complementary routing such as
perimeter routing which degrades the performance of geographic routing, most
research works are focus on optimizing this complementary part of geographic
routing to improve it. The greedy forwarding part of geographic routing
provides an optimal routing performance in terms of path stretch. If the
geographic routing could adapt the greedy forwarding more, its performance
would be enhanced much more than to optimize the complementary routing such as
perimeter routings. Our work is the first time to do so. The aligned physical
coordinate is used to do the greedy forwarding routing decision which would
lead more greedy forwarding. We evaluate our design to most geographic routing
protocols, showing it helps much and maintain the stateless nature of
geographic routing.",2 Related work 
39,A New Energy Efficient Routing Algorithm Based on a New Cost Function in Wireless Ad hoc Networks.txt,"Wireless ad hoc networks are power constrained since nodes operate with
limited battery energy. Thus, energy consumption is crucial in the design of
new ad hoc routing protocols. In order to maximize the lifetime of ad hoc
networks, traffic should be sent via a route that can be avoid nodes with low
energy. In addition, considering that the nodes of ad hoc networks are mobile,
it is possible that a created path is broken because of nodes mobility and
establishment of a new path would be done again. This is because of sending
additional control packets, accordingly, energy consumption increases. Also, it
should avoid nodes which have more buffered packets. Maybe, because of long
queue, some of these packets are dropped and transmitted again. This is the
reason for wasting of energy. In this paper we propose a new energy efficient
algorithm, that uses a new cost function and avoid nodes with characteristics
which mentioned above. We show that this algorithm improves the network energy
consumption by using this new cost function.","N ad hoc network is a distributed system  consisting of  many mobile stations with no predetermined topology and central control. The  mobile stations in an ad hoc network communicate wirelessly in a selforganized manner.  Such networks can be used in situations where  either there is no other wireless communication  infrastructure present or where such infrastructure cannot be used.  Routing in ad hoc networks is one of the most  important issues which is discussed in this area, because of unique characteristics of such networks like moving nodes, lack of st able infrastructure, self  configuration, and etc. Since all nodes in such networks are mobile means, energy is one of the most important and vital issues for those ones. Routing is one of the issues that discussion of energy has welldeserved influence on it.   There are various parameters in energy efficient  routing algorithms that have a role and called cost metrics. It can be referred to some of these metrics such as transmission power of node for sending packets, residual energy of node battery, drain rate of node battery, the number of hops between source and       destination, and etc.  Energy efficient algorithms use one or combination  of metrics and create cost fu nctions. Then, they use cost  functions to select appropriate path between source  and destination.  There are numerous and various algorithms, each  has own weakness and power.  This paper introduces a new combination of cost  metrics and creates a new cost function. Routing algorithm uses this new cost function to select the best path between source and destination. This cost function uses nodes for routing in some way, as a result, sending additional control packets is decreased and then energy consumption of each nodes decreased too.  2 RELATED WORKS   "
93,Reliable data delivery in ICN-IoT environments.txt,"In an IoT environment, which is characterized by a multitude of
interconnected smart devices with sensing and computational capabilities, many
applications are (i) content-based, that is, they are only interested in
finding a given type of content rather than the location of data, and (ii)
contextualized, that is, the content is generated and consumed in the proximity
of the user. In this context, the Information-Centric Networking (ICN) paradigm
is an appealing model for efficiently retrieving application data, and the
service decentralization towards the network edge helps to reduce the core
network load being the data produced by IoT devices mainly confined in the area
where they are generated. MobCCN is an ICN-based data delivery protocol that we
designed for operating efficiently in such context [1][2], where static and
mobile IoT devices are enriched with ICN functions. Specifically, MobCCN
leverages an efficient routing and forwarding protocol, exploiting
opportunistic contacts among IoT mobile devices, to fill the Forwarding
Interest Base (FIB) tables so as to correctly forward Interest packets towards
the intended data producers. In this paper, we aim to enhance the reliability
of MobCCN by exploring different retransmissions mechanisms, such as
retransmissions based on number of duplicate Interests that are received for
the same requested content, periodic retransmissions, single path versus
disjoint multi-path forwarding, hysteresis mechanism and combinations of them.
Extensive simulation results show that, among the analysed MobCCN variants, the
one that implements both periodic retransmissions and a hysteresis-based
retransmission process ensures the highest delivery rates (up to 95\%) and the
shortest network path, with a very limited traffic overhead due to
retransmissions.","The Internet of Things (IoT) refers to the paradigm where a massive number of interconnected devices with sensing and computational capabilities, uniquely addressable, forms a dy namic network to communicate with each other or with the Internet without human intervention [3]. IoT devices are ex tremely heterogeneous in terms of resource capabilities, lifes pan and communication technologies. On the one end of the spectrum, there are static, tiny and batterypowered devices with limited computational and memory capabilities, which are em bedded with sensors and actuators. These IoT devices are typ ically used to collect and exchange sensed data about the state of physical objects, processes and environments, and to react to this information by performing appropriate control actions. On the other end of the spectrum, the physical environment is also sprinkled with more powerful IoT devices, e.g., smartphones carried by mobile users, or vehiclebased sensing platforms, which can produce, collect, request, consume data through context aware applications. Previous research studies have proposed to leverage these less resourceconstrained mobile devices to act as “data mules” so as to facilitate the collection and distribu tion to other nodes of the data generated by the tiny sensor Corresponding author Email addresses: eleonora.borgia@iit.cnr.it (Eleonora Borgia), raffaele.bruno@iit.cnr.it (Raaele Bruno), andrea.passarella@iit.cnr.it (Andrea Passarella)nodes [4, 5, 6]. Recently, this architectural design has gained further popularity thanks to new 4G /5G capabilities, and in par ticular D2D communications and Proximity Services (ProSe), which provide the enabling mechanisms to discover other mo bile devices in close proximity and to communicate with them directly [7, 8]. Motivated by these considerations, we envision a scenario where at the edge of the network there are regions where IoT data is produced by local static IoT devices, and this data is collected and distributed to other devices in the over all area by leveraging an intermediate layer of mobile users’ devices, as shown in Figure 1. Typical application scenarios for this framework can be identiﬁed in the smartcity context. For instance, localized information about discounts or coupon deals from nearest shops in a mall can be forwarded using D2D communications between users’ personal devices to the peo ple walking in the area. Similarly, images captured by camera based sensors that are installed in city hot spots can forwarded to the interested users without using expensive cellular commu nications. Note that these applications are typically delay tol erant and not critical, namely minimal latency is not a critical factor. Furthermore, the intrinsic data redundancy (e.g., multi ple cameras taking similar images of a scene) makes acceptable to loose some of the transmitted messages. From the above discussion, it should be clear that this study speciﬁcally targets the emerging category of contentcentric IoT applications rather than hostcentric ones. In such type of ap plications, the goal of the communication process is to searcharXiv:2204.10104v2  [cs.NI]  22 Apr 2022for a speciﬁc content (mainly generated in the proximity of the user), and not to identify the location of the device that origi nated or currently stores that content. It is important to remind that the InformationCentric Networking (ICN) architecture [9] was originally proposed to support contentcentric applications in the Internet, such as ﬁle sharing and media streaming. How ever, the ICN paradigm has been also proposed as an alterna tive networking architecture for IoT [10, 11]. The basic ICN design principle is to adopt content naming, meaning that each content is assigned a unique and locationindependent name. The content retrieval process then follows a receiverdriven ap proach, as content segments (or chunks) are exchanged using a request /response model. Additional appealing ICN features are innetworking caching, request aggregation, mobility support, and content security [9]. As the integration of ICN mechanisms into IoT environ ments has a strong potential to fulﬁl the requirements of content centric IoT applications, in this work we investigate how to im plement an ICNbased framework in the scenario illustrated in Figure 1, to provide reliable and scalable IoT data collection and distribution by leveraging users’ mobile devices. In our previous work we have already proposed MobCCN, a routing and forwarding protocol that is compliant with ICN paradigms (namely CCN [12] and NDN [13]), and leverages D2D commu nications to allows users’ mobile devices to opportunistically exchanged data collected by nearby static IoT devices. To per form precise forwarding decisions, MobCCN exploits the con cept of utility of a node towards a given content, i.e., a measure ment of how frequently a node meets other nodes that store the requested content in their local caches. These utility values are exchanged during opportunistic contacts among mobile nodes, to create a dynamic gradientbased contentdissemination graph used to redirect content requests and retrieve the content e  ciently. We presented the main idea of MobCCN in [1] and its performance in [2], where we have proved that, although ad ditional signalling tra c is needed to build more e cient for warding tables by computing and exchanging the utility value for each type of content available in the network, this approach ensures a more precise detection of either the relevant content producers or the nodes that cache the relevant content. This yields a remarkable reduction of total network tra c and cache usage when compared with an epidemicbased routing protocol with a small degradation of the delivery rate in most cases, and an increase of endtoend delays. The retransmissionbased loss recovery mechanisms typi cally used by CCN, which are inherited in MobCCN, are known to be not very e cient in lossy or mobile networks [14]. The goal of this study is to shed some light on the performance improvements that could be achieved if more sophisticated re transmission mechanisms are used in MobCCN, and the con sequential tradeo s between increased reliability (i.e., higher delivery rate), and delays or network tra c overheads. Speciﬁ cally, the standard CCN retransmission scheme simply retrans mits pending Interest packets periodically or when a duplicate one is received, using the reverse path traversed by the inter est packet. In this work we explore alternative retransmission approaches. Speciﬁcally, we consider schemes that leverage Figure 1: Illustrative example of the reference network scenario considered in this study. path diversity (i.e., the packet loss processes are expected to operate independently for di erent paths) by sending retrans missions over a di erent path than the reverse path. Note that multipath routing is also beneﬁcial to distribute more evenly the tra c load due to retransmissions. In addition, we also investigate adaptive scheme to set up the periodic retransmis sion timer, which leverages utility hysteresis to control the re transmission frequency. We have integrated the proposed re transmission strategies into the MobCCN prototype, and eval uated the advantages and disadvantages of each of them un der a variety of scenarios using the OMNeT ++network sim ulator1. Simulation results show that the hysteresisbased ap proach, called MobCCN AH, achieves the best performance, with delivery rates in the range of [8595]%, about 1520% higher than the ones obtained by basic MobCCN, when suf ﬁcient bandwidth is available for the retransmissions. On the contrary, in bandwidthlimited scenarios the performance of the dierent retransmission policies tends to converge. The rest of the paper is organised as follows. Section 2 overviews the most related research work. Section 3 brieﬂy presents the basic MobCCN protocol. In Section 4 we describe the proposed retransmission strategies. Section 5 introduces the simulation setup. In Section 6 we present the comprehensive performance comparison. Finally, Section 7 draws the main conclusions of the paper. 2. Related work "
346,Inferring Catchment in Internet Routing.txt,"BGP is the de-facto Internet routing protocol for exchanging prefix
reachability information between Autonomous Systems (AS). It is a dynamic,
distributed, path-vector protocol that enables rich expressions of network
policies (typically treated as secrets). In this regime, where complexity is
interwoven with information hiding, answering questions such as ""what is the
expected catchment of the anycast sites of a content provider on the AS-level,
if new sites are deployed?"", or ""how will load-balancing behave if an ISP
changes its routing policy for a prefix?"", is a hard challenge. In this work,
we present a formal model and methodology that takes into account policy-based
routing and topological properties of the Internet graph, to predict the
routing behavior of networks. We design algorithms that provide new
capabilities for informative route inference (e.g., isolating the effect of
randomness that is present in prior simulation-based approaches). We analyze
the properties of these inference algorithms, and evaluate them using publicly
available routing datasets and real-world experiments. The proposed framework
can be useful in a number of applications: measurements, traffic engineering,
network planning, Internet routing models, etc. As a use case, we study the
problem of selecting a set of measurement vantage points to maximize route
inference. Our methodology is general and can capture standard valley-free
routing, as well as more complex topological and routing setups appearing in
practice.","Routing between networks (or Autonomous Systems–AS) in the Inte rnet takes place via the Bor derGatewayProtocol(BGP)[ 41].BGPisapolicybased,destinationorientedpathvectorpr otocol, whereanASreceivespathstoadestinationnetworkfromitsneig hbors,selectswhichpathtopre fer based on its local routing policies, and advertises it to ot her neighbors based on its export policies. This typically results in asymmetric paths betwe en networks [ 20]. Each destination net work has control only over its ownrouting decisions, and typically cannot control or even know how other networks route their traﬃc toit. Knowing how networks route traﬃc to a destination is important for (i) network planning or monitoring( e.g.,allocationofnetworkresources,detectionofroutinganomali es)[9,13,22],and(ii) indirect control –if possible– of routing decisions of other netw orks (e.g.,through manipulation of BGP announcements, selection of local routing policies, estab lishment of new links) [ 29,30]. Speciﬁcally,foradestinationnetwork,itisofparticularint erest toknowfromwhichofits ingress points(e.g.,border routers) it should expect to receive traﬃc from other networks under a given routing conﬁguration [2].We consider thefollowing indicative examples. Thiswork hasbeenfundedbythe European Research Council grant ag reement no. 338402. Authors’ addresses:Pavlos Sermpezis, Institute of Computer S cience, FORTH, Heraklion, Greece, sermpezis@ics.forth.gr; VasileiosKotronis, Instituteof Computer Science, FORTH,Heraklion, Greece, vkotronis@ics.forth.gr.ExampleA: AregionalISP R,whosenetworkspansaregionoftwomajorcities, cit/y.altAandcit/y.altB,has asingle upstream tier1 ISP TAand connectsto it at cit/y.altA.Toavoid overloading itsinfrastructure incit/y.altA,Rdecides to connect to another tier1 ISP TBatcit/y.altB. However, after connecting with TB,Robserves that 90%of the incoming Internet traﬃc still enters its ne twork atcit/y.altA, therefore the new setup fails to balance R’s load among its infrastructure in the two cities. In fact, how to select a transit provider, is a question that lacks a clear answ er, and engages operators in active discussions [35]. Example B: A content provider Capplies IP anycast ( i.e.,announces the same IP preﬁx) [ 9,13,29, 33,49]fromthreesites. Duetotraﬃcincrease, Cdecidestoaddonemoreanycastsite. Itneedsto selectwheretodeployandhowtoconnectthenewsite,inordertob estsplit thetraﬃcamongits sites.Theongoingresearch in IP anycasting, e.g.,[13,28,49],indicates that thisis a problem that is notwellunderstood yet. While a network can partially determine how other networks route traﬃc to it through pas sive (e.g.,BGP data [ 37]) or active ( e.g.,traceroute, ping) measurements [ 2,9,13,27,32,49],mea surements canprovideinformation onlyforan existing depl oyment.However, inmanyapplications (traﬃc engineering, peering decisions, network resilience, etc.) [30], it is important to know, i.e., predict,howtheroutingbehaviorofothernetworkswillchange inadvance ,beforeanetworkactu allyaltersitslocalpoliciesorconnections. Moreover,evenwhenitispossibletoaﬀordseveraltrials to test diﬀerent traﬃc engineering(TE)decisions, thelarge numbe rof possible options limits the eﬃciency and/or applicability of this “trialanderror” appr oach,unless an informed methodology isused. To this end, the primary goal of this paper is to provide an informative inference or prediction forthe catchment of the ingress points of a network, under a give n (existing or not) topological and routing conﬁguration . With the term “catchment” (see, e.g.,[13,29,49]) of an ingress point mof a destination network ndst,we denotetheset ofnetworksthatroute theirtraﬃcto ndstthroughm. Routeinferenceisidentiﬁedasachallengingtask[ 29,30],duetotheinherentcomplexityofthe behavior of BGP mechanisms,and lack ofpublic data fornetworks ’ routing policies(in fact,only coarse estimates are available, e.g.,the ASrelationships [ 5,31]).Moreover, the related problems (e.g.,TEoptimization) that mayarise in practiceare typically ofc ombinatorialnature [ 34]. Thecommonapproachto predict routes is to use models,such a sthe valleyfree model[ 17] or othervariants[ 15,34,40],thatsimulatetheInternetroutingprocess(BGP)basedonava ilabledata. Policiesaretypicallyinferredfrompublicdata[ 5,34],andwhenthereislackof,orcoarsegrained, knowledgeofpolicies,theyarearbitrarilyselected( e.g.,randomtiebreaking),inordertoproceed toasimulationandobtainaprediction.However,asimulatorc omputesonlyoneofallthepossible outcomesper simulation run.Thus,this approachcanlead to a noutput that is heavily aﬀected by the introduced randomness (e.g.,breaking randomly a tie for a central AS in each simulation, may lead to high catchment for an ingress point min one simulation run, and to low catchment in anotherrun).Mostimportantly,theoutput doesnotreveal whatistheeﬀectoftherandomness ,e.g., how manyroutesare aﬀectedby an arbitrarily chosenpolicy. In this paper, we revisit the problem of route/catchment infer ence, and propose a framework andmethodologyforaninformativeinferencethatquantiﬁesthec ertainty/uncertaintyinthepre diction for every network (isolating the eﬀect of randomness), a nd reveals the factors that aﬀect theinference( e.g.,certainpoliciesornetworks).Thisinturnenablesthedevelo pmentofadvanced methods for optimizing traﬃc engineering, selecting peering stra tegies, or conducting measure ment campaigns.Speciﬁcally: •We formallymodel(Section 2) and study the problem of inferring the catchmentof the ingress pointsofanetwork. Tothisend,we proposeagraphstructure,theRgraph,thatca neﬃciently 2encode rich information about the routing behavior, and isolate the eﬀect of randomness (Sec tion3.1). •Wedesignandanalyticallystudymethodologiesthatinfercatc hmentinexistingorhypothetical scenarios (Section 3). We identify the networks for which a certain inference is possi ble, even under coarseestimates of routing policies and topology(Secti on3.2),calculate the probabilistic inference for the remaining networks (Section 3.3), and enhance the inference when some ora cles (e.g.,frommeasurements ) are given (Section 3.4). The code for an implementation of the proposed methodsis available in [ 46]. •Asausecaseofourframework,weconsiderandstudytheproblem ofmaximizingtheinference ofcatchmentunderalimitedbudgetofmeasurements.Wepropose aneﬃcientgreedyalgorithm, whichleverages thestructure ofthe Rgraph,forselectingt hemeasurement targets(Section 4). Ouranalysisshedslightonthecomplexityofproblemsrelate dtorouteinference,andcanbeof more generalinterest. While the main focus of the paper is on establishing a theoreti cal framework for catchment in ference, we provide an initial evaluation of our approach in realistic Internet routing scenarios throughextensivesimulations andrealexperiments ,andprovideinsightfulresults(Section 5).We present related work in Section 6, and conclude by discussing potential applications and future research directionsin Section 7. As a ﬁnal remark, we would like to stress that our goal is not to pr opose a new interdomain routingmodel[ 17],orinfermoreaccuratelytheroutingpoliciesintheInternet[ 34],buttoprovide inference methods and insights on top of anygiven model and set of policies. Finally, we believe that our methods can be useful for more general applications of BGP (or, similar policyoriented pathvectorprotocols),apart frominterdomain routing,su ch asin iBGP or datacenters[ 26]. 2 MODEL We present our model in Section 2.1, and provide the necessary deﬁnitions related to route infer ence in Section 2.2. In Section 2.3we discuss how the commonlyused valleyfree model[ 17] can be capturedasa specialcase ofour genericmodel.Importantnot ation is summarized in Table 1. 2.1 Network and Routing We assume a network with a set ofnodes Nand edgesE.Anode maycorrespond to a single AS, orapartofanAS( e.g.,incaseoflarge/distributedASes;similarlytotheconcepto f“quasirouters” in [34]), or even a group of ASes with the same routing policies ( e.g.,siblings). For brevity, and without loss of generality, in the remainder we consider that a no de represents a single AS1, and an edge corresponds to a peering link between two ASes. We refer to the nodes connected with an edgeto anode i,asthe neighborsof i. Routing protocol and policies. Nodes use BGP [ 41] to establish routes towards diﬀerent In ternet destinations. The main operation of BGP is described as f ollows. A destination node ndst announces a preﬁx. Every other node ilearns from its neighbors paths to ndst(i.e.,its preﬁx), storestheminalocalroutingtable(RoutingInformationBase, RIB),andselectsoneofthemasits bestpathto ndst(accordingto, e.g.,itslocalpreferences ).Then,imayadvertisethisbestpathtoits neighbors(accordingto its exportpolicies ). Apathcontainsasequenceofnodes;wedenoteapathfrom itojaspi→j,andusethefollowing notation: pi→j=[i,x,/y.alt,...,z,j],i,x,/y.alt,...,z,j∈N 1Thestudy of [ 34] showed that more than 98% of theASes can beaccurately (w.r. t.interdomain routing behavior) repre sentedas a singlenode/“quasirouter”. 3Wefurtherdenotethebestpathfrom itoj(i.e.,thepaththat iprefers–amongallpathsinitsRIB– to reachj)asbpi→j. Best path selection . Each node iassigns a local preference to each of its neighbors. We denote the set of local preferences in the network as Q={qij∈R:i,j∈ N,eij∈ E}. Note that localpreferencesareingeneralasymmetric, i.e.,qij/nequalqji.Ifpathsarelearnedfrommorethanone neighbors,then iprefersthepathlearnedfromtheneighborwiththehighestloc alpreference[ 41]. If a node ihas the same local preference for two neighbors jandk(qij=qik), then the selection isbasedonothercriteria (“tiebreakers”),suchaspathle ngth(seeSection 3.5),theMEDattribute, IGPmetrics,time ofadvertisement, etc.[ 10]. Pathexport. Whenanode iselectsabestpathfor ndstviaaneighbor j,itmayadvertise(export) thispathtoall,someornoneofitsneighbors.Wedenotethesetof exportpoliciesasH={hijk∈ {0,1}:i,j,k∈N,eij,eik∈E}, wherehijk=1 denotes that iexports to ka path learned from j(andhijk=0 otherwise). Typically, both export policies and local pref erences are based on the economicrelationshipsbetweenthenodes,andareconsistentwith eachother.Therefore,itissafe toassumeforpracticalsetupsthat qij=qiℓ⇒hijk=hiℓk,∀k,i.e.,routeslearnedfromneighbors with the same localpreference are similarly treated2. Remark on the generality of the model: (i) The proposed model allows to capture generic routing policies by carefully selecting the quantities QandH; even sophisticated perpreﬁx policies can becapturedbyconsideringdiﬀerentpolicies QpandHpperpreﬁx p.(ii)Themodelcanbeapplied ingenericsettings:whenthedetailedpoliciesofanodeareknow nbyexplicitlysettingthe Qand Hvalues;orwhenwehaveonlycoarsegrainedinformationaboutt hem(seeSection 2.3);oreven whenweentirelylackpolicyinformationforsomenodes,wherei tsvaluesforQandHcanbeset equalto a defaultvalue, thuswithout excluding anypossible o utcome. Eligiblepaths. We deﬁne the eligiblepaths ofa node ito a node ndst,asthe pathsthat can be in the RIB of i; thus, one of them can be selected by ias its best path to ndst. The eligible paths are later used in the route inference methodology(Section 3.2). D/e.sc/f.sc/i.sc/n.sc/i.sc/t.sc/i.sc/o.sc/n.sc1(E/l.sc/i.sc/g.sc/i.sc/b.sc/l.sc/e.sc/p.sc/a.sc/t.sc/h.sc). Aneligiblepath pi→ndstisapathfrom itondstthat(i)conforms to the routing policies QandH, and(ii) can beselected by ias itsbestpath to ndst. Theﬁrst condition in Def. 1dictatesthatonlypathsthat canbereceived by i(i.e.,be in itsRIB) canbeeligible.Forexample,if hijk=0,theniwillnot exportto kapathlearnedfrom j,andthus the path[k,i,j,...,ndst]does not conform to the routing policies Hand cannot be eligible. The secondconditionexcludespathswhicharenotpreferreddueto i’slocalpreferences.Forinstance, letihave in its RIB two paths p(1) i→ndst=[i,j,...,ndst]andp(2) i→ndst=[i,k,...,ndst]. Ifqij>qik, thenp(2) i→ndstisnoteligible,since p(1) i→ndstwillalwaysbepreferredby i.However, if qij=qik,both pathsare eligible. 2.2 IngressPoints andCatchment Ingresspoints. Letanetwork ndstthatoriginatesapreﬁx,andisconnectedtoitsneighbors(and receives traﬃc) through a set of ingress points M. An ingress point can be a router interface of ndstthatis used exclusively in a private peering link( e.g.,with its upstream provider) or arouter at an IXPthatconnects ndstto multiple other networks( i.e.,the membersofthe IXP). 2In case a node has diﬀerent export policies for neighbors of same loca l preference, we can split the node into more than one subnodes (withthesame neighborsand local preferences),each of themcorresponding toone exportpolicy. 4Table1. ImportantNotation. GNetworkgraph;G(N,E,Q,H) NSetof nodes inG ESetof edges eijinG QLocalpreferencesQ={qij∈R:i,j∈N,eij∈E} HExportpolicies H={hijk∈{0,1}:i,j,k∈N,eij,eik∈E} pi→jPath fromnode itonodej bpi→jBestpath fromnode itonodej MIngress pointsof thedestinationnode ndst i⊲mNoderoute; ireachesndstthroughtheingress point m πi(m)Routeprobabilityfornode iand ingress point m,Eq.(1) fRoutingfunction, Eq.( 2) GRRgraph;GR(NR,ER) Remark:This notion can be generalized for the case where multiple nodes announce the same preﬁx (MultiOrigin AS, or MOAS). A virtual node ndstcan be connected to these MOAS nodes, whichthen serve asthe ingress pointsof ndst. Catchment:mappingnodestoingresspoints. Letassumew.l.o.g.thateachneighbor jofndst isdirectlyconnectedto ndstthroughexactlyoneingresspoint m,m∈M.Wedenotethisas j⊲m. Every other node i,i∈N,selectsa best path bpi→ndsttowardsndst,e.g., bpi→ndst=[i,x,...,/y.alt,ndst] wherexis a neighbor of i, and/y.alta neighbor of ndst. In this example, if /y.alt⊲m,m∈ M, then bpi→ndst⊲mandi⊲m. D/e.sc/f.sc/i.sc/n.sc/i.sc/t.sc/i.sc/o.sc/n.sc2(N/o.sc/d.sc/e.sc/r.sc/o.sc/u.sc/t.sc/e.sc/ C/a.sc/t.sc/c.sc/h.sc/m.sc/e.sc/n.sc/t.sc). Theroute ofanode iism,andisdenotedas i⊲m,wheniroutesitstraﬃcto ndstthroughtheingress pointmofndst. Thecatchment of an ingresspoint misthe setof nodes i∈N, forwhich itholdsthat i⊲m. We would like to stress that the “route” of a node i, as deﬁned in Def. 2and used throughout thepaper,indicatesonlyhowthetraﬃcof ientersthenetworkof ndst(i.e.,thelast hopclosestto ndstinbpi→ndst),andnot the entire ASpath. Route probability and Routing function. In many cases we cannot determine which is the bestpathofanode i,e.g.,whenthepaths pi→ndst(i)arenotknown,or(ii)areknownbutthelocal preferencesareunknown.Wecapturethisuncertaintyinaprobabil isticway,bydeﬁningthe route probability as: πi(m)=Prob{bpi→ndst⊲m},i∈N,m∈M (1) Furthermore,wedeﬁnethe routingfunction f:N→M∪{ 0}thatmapsnodes( i∈N)toingress points(m∈M)as: f(i)=/braceleftbiggm ,ifπi(m)=1 0 ,otherwise(2) In other words, f(i)=m/nequal0 denotes a certainty for the route of node i(andf(i)=0 denotes uncertainty). 52.3 A SubCase:the ValleyFree (VF)Model ThenetworkandroutingmodelofSection 2.1aregenericandcandescribetheBGPsetupsencoun tered in practice. Here, we present how the valleyfree (VF) routing model [ 17] can be captured as a special case of our model. The VF model is widely considere d in related work as a useful ap proximationforInternetrouting,thuswebelieve thatthissec tionwillfacilitateotherresearchers to applyour framework. In the VF model, each pair of adjacent nodes has either a customertoprovider or apeerto peerrelationship. We denote a relationship between two nodes i,j(i,j∈N,eij∈ E) asℓij∈ {c2p,p2p,p2c},e.g.,ℓij=c2pwheniisacustomerof j.Notethatwhenℓij=c2pthenℓji=p2c,but p2prelationships are typicallysymmetric (e.g.,settlementfr ee peering). Under the VF model, a node iprefers paths received from customers to paths from peers or providers, andpathsfrompeerstopathsfromproviders. We de notethispathpreferenceas p2c≻ p2p≻c2pand we cancapture this in our modelbyassigning localpreference sasfollows: qij>qik⇔ℓij≻ℓik (3) Moreover,whenanodehasabestpathfor ndstthroughacustomer,itadvertisesthispathtoall its neighbors(customers,peers,providers); and when the bes t path is through a peer or provider, it advertises this path onlyto itscustomers: hijk=/braceleftBigg 1,ifℓik=p2corℓij=p2c 0,otherwise(4) It is worth noting that in practice, only coarse estimates of the ASrelationshipsℓijare known (e.g.,CAIDAASrelationship dataset [ 5]),whilethedetailedlocalpreferences qijaretypicallynot madepublicbynetworks.Hence,itiscommonlyassumedthat qij=qik⇔ℓij=ℓik,i.e.,anetwork assigns equallocalpreferences to allneighborsofthe sametyp e [4]. 3 ROUTEINFERENCE Theproblem. Ourgoalistoinferthroughwhichingresspointeachnode ireachesthedestination nodendst(or, equivalently, the routeof each node / the catchment of each ingress point). In this section,wetacklethisproblem,andprovide methodsforthero uteinference.Ourmethodologyis summarized asfollows. Methodologyoverview. We ﬁrst calculateforevery node i∈Nallits eligible pathsto ndst(see Def.1), and encode them in a directed acyclic graph (DAG) rooted in ndst; we call this graph the RoutingGraph orRgraph(Section3.1).TheRgraphisthebasicstructure,onwhichourinference methodologyisbuilt. Proceedingto inference, we ﬁrst focuson the nodesfor which a certaininference can be made (Section3.2);our goal is to calculate f(i),∀i∈N. We infer the values of the routing function f based on the structure of the Rgraph;when ihas only one eligible path pi→ndst, and this path is throughtheingress point m,thenf(i)=m.However, andmost importantly ,theRgraphenables todeterminenonzerovaluesof f(i)(i.e.,certaininference)alsoforsomenodesthathavemultiple eligible paths; even without knowing whichofthem isthe best p ath,or enumeratingall ofthem. We then focus on nodes with uncertain routes, i.e.,fori∈Nwithf(i)=0, and present a framework and methodology for probabilistic inference of routes (Section 3.3). We calculate the route probabilities πi(m)forall nodes i∈Nand ingress points m∈M. Next, we study how to enhance(certainor probabilistic) infere nce, when oracles(e.g., measure ments) are given fora set of nodeswith uncertain routes(Section 3.4). 6Table2. Inference Methodology Overview. TypeofInference MethodologyCertain Probabilistic Oracles Shortestpath preferenceSequenceof steps/ algorithms. (*B/e.sc/l.sc:any exact orapproximate belief updating algorithm[ 24]) /check (/check)Alg.1⇒(Alg.5⇒)Alg.2 /check (/check)Alg.1⇒(Alg.5⇒)Alg.2⇒Alg.3 /check /check (/check)Alg.1⇒(Alg.5⇒)Alg.2⇒Alg.3⇒Alg.4 /check /check (/check)Alg.1⇒(Alg.5⇒)Alg.2⇒Alg.3⇒B/e.sc/l.sc Finally, we consider the case where nodes prefer shorter paths that conform to their routing policies(thisfrequentlyholdsinpractice[ 1,10]),andincorporatethispreferenceinourframework bymodifyingthe Rgraph;this enablesroute inference formore no des(Section 3.5). Theaforementionedinferencemethods(certain,probabilistic, withoracles)canbeusedindepen dently or complementarily. Table2gives an overview of the inference methodology,namely, the sequenceofsteps(algorithms)neededforapplyingthediﬀerent routeinferencevariantsproposed in this paper. Comparison to simulation models. Simulationbased approaches [ 15,17,34,40] return a sin gle outcome of catchment each time. Running a simulation more tha n once, may give diﬀerent outcomes, since simulators typically employ randomization t o determine the best path when not suﬃcient knowledge ( e.g.,theQ,Hor tiebreaker values) is available. For example, let the ou t come for nodes iandjof the ﬁrst (denoted in the superscript) simulation run be bp(1) i→ndst⊲m1 andbp(1) j→ndst⊲m1, and of the second run be bp(2) i→ndst⊲m1 andbp(2) j→ndst⊲m2. Based solely on theseoutcomes,onecannotanswerthefollowingquestions: Whatwouldbetheoutcomeofathird run? Will ialways route to m1,or didit happentwice due to random tiebreaking? Which rou te (m1 orm2)ismoreprobablefor j, if wesimulate all possibletiebreaking combinations? Our methodology provides answers to these questions (and with l ow complexity algorithms), where simulationbased modelswould need several simulation runs (of muchhigher complexity) toprovide onlyanapproximateanswer.Forinstance,thecertain inferencealgorithm(Section 3.2) infers whether iwill always route to m1, and the probabilistic inference algorithm (Section 3.3) calculatesthe percentageof allpossible outcomesin which jwill route to m1. 3.1 Buildingthe Rgraph WedesignAlgorithm 1tobuildtheRgraph GRthatencodesalleligiblepathsto ndst.Anyeligible pathpi→ndst,∀i∈N,canbeextractedbyprocessing GR.Figure1showsanexampleofaRgraph rootedin ndst. Input/Output. Algorithm 1receivesasinputanetworkgraphanditsroutingpolicies G(N,E,Q,H), and a destination node ndst∈N. It returns as output the Rgraph GR(NR,ER), which is a DAG rootedin node ndst. Workﬂow. First, Algorithm 1simulates the operation of BGP; when needed, “ties” are broke n randomly, e.g.,if multiple paths from neighbors with equal local preferences exist, one of them is selected randomly as the best path. This randomness does not aﬀect the construction of the R graph, since all incoming path advertisements exist in the RIB of a nodei(Pi, returned in line 1), and are taken into account (loop in line 6). Then, it initializes the Rgraph by adding only the nodes, without adding any edge ( line 2). For each node i(lines 3–18 ), it accesses its RIB Piand 7NodeEligiblepath(s) f(n) n1[n1,ndst] m1 n2[n2,ndst] m2 n3[n3,n1,ndst] m1 n4[n4,n1,ndst] 0 [n4,n2,ndst] n5[n5,n2,ndst] m2 n6[n6,n4,n1,ndst]0 [n6,n4,n2,ndst] n7[n7,n1,ndst] m1 [n7,n3,n1,ndst] n8[n8,n5,n2,ndst]0 [n8,n6,n4,n1,ndst] [n8,n6,n4,n2,ndst] Fig. 1. Example of a Rgraph (le/f_t), and the corresponding elig ible paths and valuesof the routing function freturned by Alg. 2for every node (right). The destination node ndsthas two ingress points m1andm2 through which itconnects to its neighbors n1andn2,respectively. ﬁnds all neighborsthat advertised a path for ndst(i.e.,the nextto ihopsin the RIBpaths; line7), and selects the set of the neighbors ( best_nei/afii10069.italhbors ) with the highest local preference ( max_q). The paths from these neighbors are the eligible paths of i, since they (a) exist in the RIB and (b) arefromneighborswiththehighestlocalpreference(asreque stedbyDef. 1).Foreachneighbor k ofiinbest_nei/afii10069.italhbors ,it addsa directed edgefrom ktoi. Complexity: O(|N|·|E|) .The computational complexity of Algorithm 1is dominated by the complexity of running a BGP simulation ( line 1) which is equivalent to this of the centralized BellmanFord algorithm O(|N|·|E|) . The loopin lines 3–18 examines every edge in the graph at most onceand runsin O(|E|). The following theorem formally states that (i) any path in the R graph is eligible and (ii) any eligible path isencodedin the Rgraph. T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc1. Apathpi→ndstisaneligiblepath ifandonlyif itcanbeconstructedbystartingfrom ndstandfollowing asequence ofdirected edgesin Rgraph GRuntil reaching i. P/r.sc/o.sc/o.sc/f.sc.Theproofis given in Appendix A. /square 3.2 Route Inference on the RGraph We proceed to infer through which ingress point a node iroutes its traﬃc to ndst, by exploiting the structure of the Rgraph.We demonstrate this inference usi ng the example of Fig. 1, where it is given that n1⊲m1andn2⊲m2(i.e.,f(n1)=m1andf(n2)=m2). CaseA:When thebestpathisknown,the route inference isstr aightforward (fromEq.( 2)). Noden3hasonlyoneway/pathtoreach ndst(i.e.,byfollowinglinksintheRgraph;seeTheorem 1). Thispath is throughnode n1,andsince f(n1)=m1,it followsthat f(n3)=f(n1)=m1. Case B: Route inference is possible, even when the best path c annot be determined. Node n7 has two incoming links from nodes n1 andn3; it selects only one of them to form its best path, based on its local preferences to n1 andn3. Without knowing these local preferences, we cannot infer the best path. However, since both n1 andn3 route traﬃc through the same ingress 8Algorithm 1 Building the Rgraph. Input:Network graphG(N,E,Q,H);destination node ndst. 1:P←R/u.sc/n.scBGP_R/a.sc/n.sc/d.sc/o.sc/m.scT/i.sc/e.scB/r.sc/e.sc/a.sc/k.sc (G(N,E,Q,H),ndst) /*P={Pi:i∈N},wherePiistheBGP RIBof i*/ 2:GR(NR,ER):NR←N;ER←∅ 3:fori∈Ndo 4:best_nei/afii10069.italhbors←∅ 5:max_q←−∞ 6:forpi→ndst∈Pido 7: k←G/e.sc/t.scN/e.sc/i.sc/g.sc/h.sc/b.sc/o.sc/r.sc(i,pi→ndst) 8: ifqik<max_qthen 9: continue 10: elseifqik>max_qthen 11: best_nei/afii10069.italhbors←{k} 12: max_q←qik 13: else /*qik=max_q*/ 14: best_nei/afii10069.italhbors←best_nei/afii10069.italhbors∪{k} 15: endif 16:endfor 17:ER←ER∪{eki:k∈best_nei/afii10069.italhbors} 18:endfor 19:returnGR(NR,ER) point (f(n1)=f(n3)=m1),selecting either path leads to the same value of the routing function: f(n7)=m1. Case C: Route inference might not be possible for some nodes. On the contrary to n7, while noden4hasalsotwoincominglinks,theyarefromnodes n1andn2forwhichitholdsthat f(n1)/nequal f(n2).Thus,in thiscase we cannot infer whichpathwill be selected,a ndwe write f(n4)=0. Theaboverulescanbeappliedsequentiallyforallnodesinthe Rgraph.Algorithm 2formalizes thisinference process. Input/Output. Algorithm 2receivesasinputaRgraph,adestinationnode ndst(rootofthegraph), andamappingoftheneighborsof ndsttoitsingresspoints M.Itreturnsthevaluesoftherouting function fforall nodesin the Rgraph. Workﬂow. Algorithm 2starts from the neighbors of ndstand sets the values of faccording to their mapping to ingress points ( lines 2–7). Then, it calculates a topological ordering3of the R graph nodes ( line 8) and sequentially visits nodes starting from those that are clos er to the ndst (lines 9–20 ). For each node i, it calculates the set of routes(Def.2) of its parent nodes CRi(lines 10–14), which are the candidate routes for node i. If some of the parents do not have a certain route (0∈CRi) or there are more than one candidate routes ( |CRi|/nequal1), then it cannot make a certainroute inferencefornode i,andsets f(i)=0(lines15–16 ).Otherwise ( i.e.,thereisonlyone candidate route for i), an inference is made and the route of iis set equal to this of its parent(s) (line18). Remark:Visitingnodesintheirtopologicalorderensurescorrectnesso fthealgorithm, i.e.,thatthe routing function of a node iwill not be misinferred ( e.g.,f(i)=0 instead of f(i)=m,m∈M). 3Atopologicalsort/ordering Tofadirectedgraph G(N,E)isalinearorderingofitsnodes Nsuchthatforeverydirected edgeeij∈ Efrom node i∈ Nto nodej∈ N,icomes before jin the sort/ordering T. For example, in Fig. 1, node numbering( n1, ..,n8) corresponds toa topological ordering. 9Algorithm 2 Inferenceon the Rgraph. Input:RgraphGR(NR,ER); destination node ndst; mapping (⊲) of the neighbors of ndstto ingress pointsM. 1:f(i)←0,∀i∈NR /*Initialization */ 2:dst_nei/afii10069.italhbors←{i∈NR:endst,i∈ER} 3:fori∈dst_nei/afii10069.italhbors,m∈Mdo 4:ifi⊲mthen 5: f(i)←m 6:endif 7:endfor 8:T←T/o.sc/p.sc/o.sc/l.sc/o.sc/g.sc/i.sc/c.sc/a.sc/l.scS/o.sc/r.sc/t.sc( GR) 9:fori∈T\{ndst∪dst_nei/afii10069.italhbors}do 10:CRi←∅ /*Candidateroutes for node i*/ 11:Pi←{j∈NR:eji∈ER} /*Parentsof i*/ 12:forj∈Pido 13: CRi←CRi∪{f(j)} 14:endfor 15:if(0∈CRi)or(|CRi|/nequal1)then 16: f(i)←0 17:else 18: f(i)←CRi 19:endif 20:endfor 21:returnf(i),∀i∈NR This is because all parent nodes of i, which are the only nodes that aﬀect the route of this node, will have beenvisited beforenode i. Complexity: O(|NR|+|ER|).The topological sort in line 8is of complexity O(|NR|+|ER|)and the loopin lines9–20 is ofcomplexity O(|ER|)since it visits eachedgein ERexactlyonce. 3.3 ProbabilisticRoute Inference The goal of probabilistic inference is to calculate the route p robabilities πi(m)(deﬁned in Eq. ( 1)). Hence, even for nodes for which a certain inference is not possible , theprobabilities πi(m)can provide extra information that can be useful ,e.g.,to predict the total load per ingress point by takingthe expectation over the route probabilities: Traf fic_Load(m)=/summationtext.1 i∈NTi·πi(m) (5) whereTiistheknowntraﬃcloadfrom itondst(Ticanbeestimatedindependentlyofthedeploy ment/routing setup ,e.g.,fromNetﬂow statistics or similarly to the system proposedin [13]). TheRgraphasaBayesianNetwork(BN). Toproceedtoprobabilistic routeinference,wehan dle the Rgraph as a Bayesian network (BN)4, where a node ican take a value m∈M, and the respectiveprobability isgivenby πi(m).BasedonBNproperties(andthe causality intheRgraph ,i.e.,children nodes select routes learned from their parents and not th e opposite ),the following expression can be used to calculate the probabilities πi(m), from the probabilities of the parents 4A BN is a directed acyclic graph (DAG), where a directed edge eijdenotes a dependence of node jon nodei[24]. We remind that the Rgraph is a DAGthat encodes routing path dependencies ;e.g.,a directed edge eijdenotes that node iis thenexthop of jin a pathpj→ndstfromjtondst. 10Algorithm 3 Probabilistic route inference on the Rgraph. Input:RgraphGR(NR,ER); ingress pointsM;routing function f(i),∀i∈NR; probabilities pij,∀eji∈ ER. 1:πi(m)←0,∀i∈NR,m∈M /*Initialization */ 2:T←T/o.sc/p.sc/o.sc/l.sc/o.sc/g.sc/i.sc/c.sc/a.sc/l.scS/o.sc/r.sc/t.sc( GR) 3:fori∈Tdo 4:iff(i)/nequal0then 5: πi(f(i))←1 6:else 7: Pi←{j∈NR:eji∈ER} /*Parentsof i*/ 8: forj∈Pido 9: form∈Mdo 10: πi(m)←πi(m)+πj(m)·pij 11: endfor 12: endfor 13:endif 14:endfor 15:returnπi(m),∀i∈NR,m∈M (Pi) ofi: πi(m)=/summationtext.1 j∈Piπj(m)·pij (6) wherepijtheprobabilityfor itopreferapathfrom jthananyotherparentnode,and/summationtext.1 j∈Pipij=1. Algorithm 3applies the above equation and calculates the probabilistic route inference on a Rgraph. Input/Output. Algorithm 3receives as input the Rgraph, the ingress points, the values of the routing function and the probabilities pij, and returns the route probabilities πi(m),∀i∈N,m∈ M. Workﬂow. Algorithm 3initializes all probabilities to zero ( line 1) and starts visiting all nodes according to a topological sort ( lines 2–14 ). If a visited node ihas a certain route m, then it sets theprobability πi(m)equalto1( lines4–5).Otherwise,itappliesEq.( 6)tocalculate πi(m)fromthe probabilities of the parent nodes ( lines 7–13 ). Visiting nodes in a topological order satisﬁes that the probability of allparent nodes Piwill have been calculatedbefore visiting i. Complexity: O(|NR|+|ER|).Similarly to the certain inference methodology, the complexi ty of thetopologicalsortin line2isO(|NR|+|ER|),andthisoftheloopin lines3–14 isO(|ER|).However, Algorithm 3isusedwithAlgorithm 2(seeTable 2),whichmeansthatthetopologicalsortisalready calculatedin Algorithm 2andcan bepassed as input to Algorithm 3. Settingthevaluesoftheprobabilities pij.Algorithm 3andEq.(6),requiretheprobabilities pij to be known. We stress that these probabilities are not the local preferences qij(which are equal for all the parents of a node in the Rgraph; cf. Algorithm 1), but other criteria based on which a node will break ties, such as, the router IP address or the tim e of the received BGP announce ments[50].Insomecases,thesecriteria(andtherespectiveprobabil ities)canbeinferredfrompast measurements, e.g.,[34]. However, given no prior knowledge on the criteria or in the ca se where thetiebreakervalueschangeovertime,theprobabilitiesc anbesettoequalvalues(uniformly)for allparents in the Rgraph, i.e.,pij=1 |Pi|,∀j∈Pi. 113.4Inference underOracles Weproceedtostudyhowtoenhancethecertainorprobabilistic routeinference ,whenan“oracle” forthevalueoftheroutingfunctionforasetofnodes X,X⊂N,withpreviouslyuncertainroutes (f(i)=0,∀i∈X),isgiven.Obviously,thevaluesof ffornodesinXaretriviallyinferred(fromthe oracle).However, here we show that an oraclefor the routing function foraset of nodes X, enables route inference fora–potentially– largerset of nodes Y,Y⊇X. “Oracles” in reality. In practice, an “oracle” can be obtained by a measurement, such as BGP messages/RIBscollectedat some node, e.g.,through a route collector[ 48] (passive measurement), or traceroutes/pings (see,e.g.,[13])from a node towards the destination node ndst(active mea surement). In the remainder, we consider oracles in the context o f a measurement, however, our methodologyisvalid in the generalcase,independently ofhow th e oracleis obtained. Remark:Actualmeasurementsareapplicableonlyinthecaseofanexist ingdeployment ,wherea destinationnode ndsthasalreadyestablishedconnectionsandannouncespreﬁxestoitsnei ghbors. Themeasurementenhancedinferencecanthenbeusefulforlightw eightrouteinference, e.g.,with only a few, instead of exhaustive [ 13], measurements. However, the oracleenhanced inference techniquescanbeusefulforplanningpurposes(hypotheticalsc enarios)aswell, e.g.,identifyingthe optimal locations for installing monitoring equipment to eﬃcientl y monitor future deployments and routing conﬁgurations(see, e.g.,Section4). WeuseagaintheexampleofFig. 1todemonstratethemeasurementenhancedinferencemetho dology.Thebasicinferencemethodology(Sections 3.2and3.3)cannotinferwithcertaintytheval uesffornodes n4,n6,andn8(seerightcolumnofthetableinFig. 1).Byconductingmeasurements forsome ofthese nodes,the following casesofroute inference ar e possible. Case A: The routes of the measured nodes are directly inferre d.When we measure a node i, weeitherlearnitsbestpath( e.g.,fromBGPdata,traceroutes)orthroughwhichingresspoint mit routes traﬃcto ndst(pings[13]).In bothcases,we candirectlyinfer f(i). CaseB:Theroutesofthechildrenofmeasurednodesmightbei nferred.Ifnoden4ismeasured, thentheroute of n6canbedirectlydeterminedaswell,sincetheeligiblepathsf orn6arethrough n4, and thus it must hold f(n6)=f(n4). However, if n6 is measured, it is not always possible to infer the route of n8 as well: if f(n6)=m2=f(n5), then we can infer f(n8)=m2, whereas if f(n6)=m1/nequalf(n5),then we cannot infer with certainty the route of n8. Case C: The routes of the parents of measured nodes might be in ferred.Ifn6 is measured, then we can directlyinfer the route for n4(since, asdiscussed above, it must hold f(n6)=f(n4)). Ifn8 is measured there are two cases: (i) if f(n8)=m1, then, since f(n5)=m2 (see Fig. 1), we can infer that n8 selects its best path through n6 and thus f(n6)=f(n8);(ii) iff(n8)=m2, then we cannot infer with certainty through which node is the best path o fn8, and, in contrast to the previous case,we cannotinfer f(n6). Algorithm 4is based on the aforementioned guidelines to enhance the route infe rence in a R graph,given a set oforacles. Input/Output. Algorithm 4receivesasinputaRgraph,theingresspoints,thevaluesofth erout ing function fand the probabilities π(whichare calculated by Algorithms 2and3, respectively), and a set of oraclesthat map nodesto ingress points. It returns the updated values ofthe routing function f. Workﬂow. For each node i∈ Xfor which an oracle is provided, Algorithm 4calls the func tionS/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc , which updates the routing function fand probabilities π(lines 1–5). Speciﬁcally, S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc setsthevalueoftheroutingfunctionequaltotheoneoftheprov idedoracle( line8),and updatestheprobabilitiesfornode i(lines9–10 ).Then,itﬁndsthesubset CPioftheparentnodes Pi 12Algorithm 4 Enhancinginference with measurements. Input:RgraphGR(NR,ER);ingresspointsM;routingfunction f;probabilities π;setofmeasurednodes Xand their mapping ( ⊲) toingress points. 1:fori∈X,m∈Mdo 2:ifi⊲mthen 3:(f,π)←S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc(i,m,f,π,GR) 4:endif 5:endfor 6:returnf 7:function S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc (i,m,f,π,GR) 8:f(i)←m 9:πi(m)←1 10:πi(d)←0,∀d/nequalm 11:Pi←{j∈NR:eji∈ER} /*Parentsof i*/ 12:CPi←{j∈Pi:πj(m)>0} /*Candidateparents */ 13:if|CPi|=1andf(CPi)=0then 14:(f,π)←S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc(CPi,m,f,π,GR) 15:endif 16:Ci←{j∈NR:eij∈ER,f(j)=0} /*Childrenof iwithoutinferredroute */ 17:forj∈Cido 18: Pj←{k∈NR:ekj∈ER} 19: CRj←∅ /*Candidateroutesfor j*/ 20: fork∈Pjdo 21: CRj←CRj∪{f(k)} 22: endfor 23: if|CRj|=1andCRj/nequal0then 24:(f,π)←S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc(j,m,f,π,GR) 25: endif 26:endfor 27:return(f,π) 28:endfunction ofi,whichmayroute(oractuallyroute)throughthesameingress pointwith i(lines11–12 ).These are the candidate nodes that can be in the best path bpi→ndst. If there is only one such candidate parentnode(|CPi|=1),thenwithcertaintythisnodehasthesameroutewith i.Hence,incasethe route forthisnodeis not alreadyinferred ( f(CPi)=0),there isa new inference forthisnodeand S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc is called. After making the inferences for the parents of i(lines 13–15 ), the algorithm proceedstoinferenceforthechildrennodesof i(lines16–26 ).Foreachchild jwithoutaninferred route (line 16), it collects the distinct values of the routing function of its parentsPj(lines 18–22 ). Ifthereisonlyonesuchvalue CRj,andCRj/nequal0,thenitmeansthatalltheparentnodesof jroute traﬃc to CRj(in fact, in this case it holds that CRj≡m). Thus an inference for the route of jis possible, and S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc is called.Finally, S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc returns the updated fandπ. Complexity: O(|NR|).The method S/e.sc/t.scR/o.sc/u.sc/t.sc/e.sc is called at most once per node (even if called recursively), i.e.,up to|NR|times; for moredetails see Theorem 2andits proofin Appendix C. Problempropertiesandcomplexity. AsdiscussedinSection 3.3,theRgraphisaBN.Whenan oracleisgiven,theprobabilitiesinthisBNcanbeupdatedto inferextraroutes.However,updating exactly the probabilities πis NPhard (Lemma 1), since the Rgraph is a multiplyconnected BN 13(andnota polytree)[11].However,eﬃcientalgorithmsto approximate theupdatedprobabilities π exist [24]. L/e.sc/m.sc/m.sc/a.sc 1. Updating the probabilities πin the Rgraph to their new values π′when an oracle is given, isNPhard. P/r.sc/o.sc/o.sc/f.sc.Theproofis given in Appendix B. /square Algorithm 4isbasedonBNbeliefpropagationmethods[ 24].Themaindiﬀerenceisthatitdoes not aim to update exactly all the probabilities π, but only the probabilities whose new value π′is either1or0.Thisissuﬃcientforacertainrouteinference(for thenodesforwhichthisispossible), and cantakeplace in polynomialtime,asTheorem 2states. T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc 2. Algorithm 4updates the probabilities πfor all nodes ifor which maxmπ′ i(m)=1 holds, in polynomialtime O(NR). P/r.sc/o.sc/o.sc/f.sc.Theproofis given in Appendix C. /square 3.5 Preference ofShorter Paths The Rgraph encodes all eligible paths, given the set of local preferencesQ. In practice, a node commonly preferstheshortest(intermsofAShops)amongthepathsle arnedfromneighborsofequal local preference (i.e.,its parents in the Rgraph) [ 10].This common behavior is widely considered in related work as well, e.g.,[1,19,40]. Hence, route inference under the assumption of shortest path preference isrelevant to real network operations. Here,weshowhowtoincorporatetheshortestpathpreferencei nourmethodology.Wedothis in Algorithm 5, by modifying the Rgraph to eliminate the eligible paths that are always longer andthusneverpreferredbyanode. Speciﬁcally,assumingpreferenceofshorterpaths,meansthat not all the paths in the Rgraph are eligible anymore. For examp le, in the Rgraph of Fig. 1, node n7 has two paths; however, the path through n1 is shorter and preferred. The path through n3 is not eligible anymore,andthusthe edgebetween n3andn7must be removed. Input/Output. Algorithm 5receives as input the Rgraph, modiﬁes it, and returns the modiﬁ ed Rgraph. Workﬂow. A minimum length (of eligible paths) Liis set for each node i, and is initialized to 0 forndst, and to∞for every other node ( line 1).Lidenotes the minimum length of the eligible pathspi→ndst.Anodewillprefertheshorterpaths,andthustheobjectiveis toremove thelonger paths of a node from the Rgraph.To this end, starting from nodesc loser tondstand following a topological sort, the set of parents Piof the node iis calculated, and the value of Liis set equal to the minimum value Lj,j∈Pi, plus one ( lines 3–7). The parents that have longer paths to ndst willneverbepreferredbyanode i.Hence,theincomingedgesto ifromsuchparentsareremoved fromthe Rgraph( line8). Complexity: O(|NR|+|ER|).The complexity of the topological sort in line 2isO(|NR|+|ER|), and this of the loop in lines 3–9 isO(|ER|). Similarly, Algorithm 5is used with Algorithm 2(see Table2),whichmeansthat thetopologicalsort is calculatedonly once . T/h.sc/e.sc/o.sc/r.sc/e.sc/m.sc3. ApplyingAlgorithm 5on aRgraph,can only increase (notdecrease) theset ofnode s with certain routes. P/r.sc/o.sc/o.sc/f.sc.We provide asketch ofthe proofin Appendix D. /square 14Algorithm 5 Rgraphtransformationfor shortest path preference. Input:RgraphGR(NR,ER);destination node ndst. Ouput:(updated)Rgraph GR(NR,ER). 1:Lndst←0;Li←∞,∀i∈NR\{ndst} /*Initialization */ 2:T←/t.sc/o.sc/p.sc/o.sc/l.sc/o.sc/g.sc/i.sc/c.sc/a.sc/l.sc_/s.sc/o.sc/r.sc/t.sc( GR) 3:fori∈T\{ndst}do 4:Pi←{j∈NR:eji∈ER} 5:forj∈Pido 6: Li←min{Li,Lj+1} 7:endfor 8:ER←ER−{eji∈ER:Lj+1>Li} 9:endfor 10:returnGR(NR,ER) 4 USECASE: EFFICIENT MEASUREMENTS In this section, we investigate how to eﬃciently select measure ments in order to increase the (certain)inferenceundera routingconﬁguration.Speciﬁcally,we considerthefollowingproblem. The problem. Given a budget of Bmeasurements, what is the optimal set of nodes to be measured that maximizes the (certain) routeinference in the Rgraph ? The above problem may emerge in the context of a number of measur ementrelated applica tionsintheInternet,suchashowtoeﬃcientlyselectasetofvanta gepointsfromwhichtotrigger dataplane measurements ( e.g.,select the best set of RIPE Atlasprobes [ 42],given a limit on mea surement credits), or how to optimally deploy monitoring infras tructure for passive ( e.g.,route collectors)or active ( e.g.,probes) measurements. Intheremainder,westudythisproblem: inSection 4.1weshowthatitishardtobesolvedexactly or even approximated (since it requires exponential –to the numb er of nodes– complexity), and in Section 4.2wepropose a greedy algorithm for eﬃcient measurement selection, leveraging the Rgraph’sstructure andproperties. 4.1 ProblemFormulation and Properties Problemformulation. LetX,X⊆NR,beaset ofnodesforwhichwe have anoracle(i.e., route measurement), and let x,x∈M|X|, the routes of nodes in X(i.e.,xis a vector of size|X|, taking values in state space M|X|). We will denoteX⊲x. For example, ifXconsists of three nodes {n1,n2,n3},whichroutetoingresspoints {m1,m2}asfollows: n1⊲m1,n2⊲m1,n3⊲m2,thenwe denotex={m1,m1,m2}. Given a setXand its routes x, we denote asNCR(X⊲x)thenumber of nodes with a certain routegiven these oracles: NCR(X⊲x)=|{i∈NR:f(i)/nequal0|X⊲x}| (7) Note that we cannot know through which ingress point each measured node routes its traﬃc beforeconductingameasurement.Hence,toevaluatetheeﬀectiv eness ofselectingaset ofnodes, we consider all the possible measurement outcomes x,x∈ M|X|. To this end, we denote the expected number of nodeswith acertain route , undera set ofmeasured nodes Xas: EP[NCR(X)]=/summationdisplay.1 x∈M|X|NCR(X⊲x)·P(X⊲x) (8) whereP(X⊲x)denotesthe probability ofrealization of themeasurements ou tcomex. 15Then,given a budget of at most Bmeasurements, and a set Y,Y⊆NRof nodeswhich can be measured(e.g.,formeasurementswith RIPEAtlas, Ycanbe theset ofASesthat hostat least one probe),theoptimization problemcanbe expressed as5: P/r.sc/o.sc/b.sc/l.sc/e.sc/m.sc1. maxX⊆YEP[NCR(X)],s.t.|X|≤B Modularity of the objective and the greedy algorithm. Problem 1belongs to the class of combinatorial problems of maximizing a set function under a card inality constraint. Lemma 2 summarizes the properties of the objective function of Probl em1, which allow us to characterize its complexityand approximability. L/e.sc/m.sc/m.sc/a.sc2. TheobjectivefunctionofProblem 1is(i)nonnegativeandmonotone,(ii)nonsubmodular, (iii) nonsupermodular. P/r.sc/o.sc/o.sc/f.sc.Theproofis given in Appendix E. /square Ontheonehand,iftheobjectivefunctionofProblem 1wassubmodular ,thenapplyingagreedy algorithm, of polynomial to NRnumber of evaluations of the objective function EP[NCR(X)], would come with an approximation guarantee of 1 −1/eof the optimal solution [ 25]. On the other hand, if it was supermodular , then the problem would be NPhard to approximate [ 25]6. However, in the generic case of the Rgraph we consider, with a m onotone neither submodular, nor supermodular, objective, it has been recently shown that a pplying a greedy algorithm still comeswithapproximationguarantees(however,worsethanin thecaseofasubmodularfunction 1−1/e) and usually the performancein practice is not far fromthe opti mal [3].Therefore,in the following, we design a greedy algorithm for Problem 1, which starts with an empty set X0=∅, andateachstep kaddstosetXk−1thenodethatincreasesthemosttheexpectednumberofnodes with certain inference,i.e., Xk=Xk−1∪argmaxi∈Y\Xk−1EP/bracketleftbigNCR(Xk−1∪{i})/bracketrightbig Remark:The approximation of the greedy algorithm depends on the submodularity ratio and curvature of the objective function, which in our case is determined by the structure of the R graph [3]. While deriving approximation guarantees as a function of str ucture and properties of theRgraphisaninteresting researchdirection,itisoutofth escopeofthispaper,andwedeferit to future work. Complexityinevaluatingtheobjective. AsecondchallengeinsolvingProblem 1,evenwitha greedyalgorithm,isthattheevaluationoftheobjectivefu nction(Eq.( 8))ineachstep,involvesthe calculationoftheprobabilities P,whichmayrequirealsoexponentialto |N|time(seeSection 3.4). Wedemonstratethiswiththefollowingexample.Let Xkbethesetoftheﬁrst knodesselectedby the greedy(or,any) algorithm,and a node j/nelementXk. Toevaluate the value of the objective function whenadding node jto theset ofmeasurements, we needto proceedasfollows: EP/bracketleftBig NCR(Xk∪{j})/bracketrightBig =/summationdisplay.1 x/summationdisplay.1 mNCR(Xk∪{j}⊲x∪m)·P(Xk∪{j}⊲x∪m) =/summationdisplay.1 x/summationdisplay.1 mNCR(Xk∪{j}⊲x∪m)·P(j⊲m|Xk⊲x)·P(Xk⊲x) 5Generalizations of the problem can be expressed as well, e.g.,by weighting with wi(e.g.,based on the incoming traﬃc loadfrom i) theimportance ofknowingtheroute ofeach node iandmodifying thedeﬁnition oftheobjective function in Eq.(7)asNCR(X⊲x)=/summationtext.1 i∈{NR:f(i)/nequal0|X⊲x}wi,and/orassigningdiﬀerentmeasurementcosts cipernodeibymodifying theconstraint as/summationtext.1 i∈Xci≤B. 6Maximizing a supermodular function is equivalent to minimizing a submodul ar function, which is NPhard when the sizeof thesetis constrained. 16whereweappliedtheBayestheoremtoexpressthejointprobab ilityasaproductoftheconditional probability. In the last equation, we can calculate the terms NCR(Xk∪{j}⊲x∪m)using Algorithm 4 (inO(N)steps), and the terms P(Xk⊲x)are already calculated in the k−1 step of the greedy algorithm. The remaining terms P(j⊲m|Xk⊲x)correspond to the updated probabilities πjfor nodej, given the set of oracles Xk⊲x. As discussed in Section 3.4, the exact calculation of the updatedprobabilities πis NPhard. In the greedy algorithm we propose, we trade accuracy for eﬃc iency in the calculations for π at eachstep, and updatethe probabilities πwith an approximate (“belief propagation”) method. 4.2 A GreedyAlgorithm WepresentthegreedyalgorithmweproposeforProblem 1,whichisbuiltupontheaforementioned guidelines. Input/Output. Algorithm 6receives asinput a Rgraph,thevaluesoftherouting function fand the probabilities π, a set of nodesYthat are eligible to be measured, and a measurement budget B.It returnsa setXof sizeB,containing thenodesto be measured. Workﬂow. Aftertheinitialization( line1),Algorithm 6entersthegreedynodeselectionloop( lines 2–6), where at each iteration a node iis added to the set of measured nodes X(line 4). The node thatisaddedistheonethat–ifmeasured–increasesthemostth eexpectednumberofnodeswith a certain route ( line3).Theexpectation is calculatedby Eq.( 8)using theprobabilities P, i.e., P(X∪{j}⊲x∪m)=P(j⊲m|X⊲x)·P(X⊲x)=π(X⊲x) j(m)·P(X⊲x) (9) where we denote π(X⊲x) j(m)=P(j⊲m|X⊲x). Note that π(∅⊲x) j(m)=πj(m). After adding node ito setX, the probabilities π(X⊲x)andP(X⊲x), which will be needed in the next iteration, are calculatedusing theapproximate method U/p.sc/d.sc/a.sc/t.sc/e.scP/r.sc/o.sc/b.sc/a.sc/b.sc/i.sc/l.sc/i.sc/t.sc/i.sc/e.sc/s.sc (line5). Themethod U/p.sc/d.sc/a.sc/t.sc/e.scP/r.sc/o.sc/b.sc/a.sc/b.sc/i.sc/l.sc/i.sc/t.sc/i.sc/e.sc/s.sc calculatestheprobabilities P(X∪{j}⊲x∪m)andπ(X⊲x) j(m), ∀possible measurement outcomes ( lines 9–15 ). The former probabilities are calculated by using Eq. (9) and previous values ( line 10). The latter probabilities are calculated approximately i nlines 12–14. First, for the given outcome X∪{j}⊲x∪m, Algorithm 4is used to calculate the set of nodes with certain inference Z(lines 12–13 ). We remind that Algorithm 4(called in line 11) is a belief propagation method to update the probabilities o f all the nodes with a certain route inferenceafterameasurement/oracleisgiven.Fortheremainingno des(withuncertaininference), we approximately update their probabilities by taking into ac count the inference for nodes in Z andapplyingonlyforwardbeliefpropagationintheRgraph(i. e.,onlyinthedirectionofitsedges). In other words, when a certain inference is made for a node i∈Z,we consider only its eﬀect on theprobabilitiesofthe(directandindirect)childrenof i,andneglecttheeﬀectontheprobabilities ofitsparents. Thiscanbedone byremovingfromtheRgraphallt heincomingedgestonodesin Z(line 13), and then applying Algorithm 3(line 14), which starts at the roots of the Rgraph and throughforward beliefpropagation calculatesthe probabi litiesπfor allnodes. Finally, we would like to remark that considering only forward be lief propagation is the most reasonable choice in many use cases of ourframework;namely,wh en the detailed preferences of a nodeito its parents pijare not known and their values are arbitrarily set, e.g.,to equal values amongallparents (seediscussion in Section 3.3). 17Algorithm 6 Selection ofthe set of nodesto be measured. Input:RgraphGR(NR,ER);ingress pointsM;routingfunction f;probabilities π; set ofmeasurement eligible nodesY,withY⊆NR; measurement budget B,withB<|Y|. 1:X←∅;P(∅⊲m)←1;P(i⊲m)←πi(m),∀i∈Y,m∈M /*Initialization */ 2:while|X|<Bdo /*Thegreedynodeselectionloop */ 3:i←argmaxj∈Y\XE(P,π)[NCR(X∪{j})] 4:X←X∪{ i} 5:π,P←U/p.sc/d.sc/a.sc/t.sc/e.scP/r.sc/o.sc/b.sc/a.sc/b.sc/i.sc/l.sc/i.sc/t.sc/i.sc/e.sc/s.sc (X,i,π,P) 6:endwhile 7:returnX 8:function U/p.sc/d.sc/a.sc/t.sc/e.scP/r.sc/o.sc/b.sc/a.sc/b.sc/i.sc/l.sc/i.sc/t.sc/i.sc/e.sc/s.sc (X,i,π,P) 9:forx∈M|X|,m∈Mdo 10: P(X∪{j}⊲x∪m)←P(X⊲x)·π(X⊲x) i(m) 11: f←A/l.sc/g.sc/o.sc/r.sc/i.sc/t.sc/h.sc/m.sc 4(GR,M,f,π(X⊲x),X∪{i}⊲x∪m) 12:Z←{j∈NR:f(j)/nequal0} 13:G′ R←GR/parenleftbigNR,ER−{ejℓ∈ER:ℓ∈Z}/parenrightbig 14: π(X⊲x,i⊲m)←A/l.sc/g.sc/o.sc/r.sc/i.sc/t.sc/h.sc/m.sc 3(G′ R,M,f) 15:endfor 16:returnπ,P 17:endfunction 5 PERFORMANCEEVALUATION In this section, we apply the proposed methods to the Internet AS graph. Using realistic simula tions, we evaluate the capability of our methodology to infer I nternet routes, and discuss related insights. 5.1 Setup WebuildtheASleveltopologyusingtheexperimentallycolle ctedCAIDAASrelationshipdataset[ 5]. This contains a list of ∼452kpeering links between ∼62kASes, and their relationships ℓij∈ {p2c,p2p,c2p}.Weconsider a single node perAS,valleyfree routing, and set the pol iciesaccord ing to Section 2.3(Eq. (3) and Eq. ( 4)). In the simulations, we break ties for routes received from neighborsofthesametype( e.g.,fromtwocustomers)arbitrarily.However,intheinference,w eas sumethatwedonotknowhowexactlythenodesbreakties(otherwi seinferencewouldbetrivial). To account for this (assumed) lack of knowledge, we consider in t he inference the more generic valuesˆqij=ˆqik⇔ℓij=ℓik,i.e.,equal preferences for all neighbors of the same type. This take s intoaccountallpossibletiebreakingoutcomes,andcorrespond stoapracticalscenario,wherewe would like toinfer catchmentwith coarse knowledgeof thepolic ies (ℓij). At each simulation, we create a new node ndst, add it to the topology, and add c2plinks (with ndstthecustomer)to|M|randomlyselectednodes;these |M|nodesareassumedtobeconnected in diﬀerent ingress points of ndst. We announce a preﬁx from ndst, and run (simulate) BGP. For eachdiﬀerent scenario setup, we conduct1000simulation runs. 5.2 Gainsfrom the RgraphbasedInference A main contribution of the proposed methodology(basic/cert ain inference, Sections 3.1and3.2) isthat it achieves to (i)encodealleligible pathsin a simple graph,and(ii) exploit thestructure of the Rgraph to infer routes even for nodes with multiple eligib le paths. The simulation results in Fig.2quantifythese gains. 18 2  4  8160200040006000800010000120001400016000 # Ingress Points# Nodesnodes with certain inferencenodes with 1 eligible path (a) Proposed vs.Naive Inference10010110210310400.20.40.60.81 # Eligible Paths per NodeCDF certain inferenceuncertain inference (b) EligiblePaths Fig.2. (a)Numberofnodeswithcertaininference,andnumbe rofnodeswithoneeligiblepath.(b)Distribu tion of the number of eligible paths per node, for nodes with c ertain and uncertain inference; setup with 2 ingress points. Figure2(a)comparestheaveragenumberofnodesforwhichourmethodology inferredacertain route (white bars), and the average number of nodes with only one el igible path (black bars). For scenarios in which the network hastwo ingress points (leftmost b ars),our methodology infersthe routes of almost an order of magnitude more nodes than a naive inference (that infers routes only for nodes with a single eligible path). As the number of ingress po ints increases, the number of eligible paths –and thus the uncertainty– increases as well; how ever, even for a large number of ingresspoints(rightmostbars),ourmethodologyinfersaround twotimesmorenodesthananaive approach. Moreover,Fig. 2(b)showsthat50%(0.5inyaxis)ofthenodesforwhichaninference canbemade (continuous line), have more than 10 eligible paths (xaxis); r espectively, in 20% of the inferences (0.8in yaxis)the nodeshave morethan100eligible paths.Thisf urtherhighlightsthegainsfrom exploiting the structure ofthe Rgraphtowards makingcertai n inferences. 5.3 Rgraphvs.SimulationbasedInference Asdiscussedearlier,onecouldusesimulationbasedapproac hestoestimatethecatchment[ 17,34, 40]. Since each simulation run returns a single outcome (which is a ﬀected by the randomness in tiebreaking),severalrunsareneededtocalculateestimates ofthecatchment.Onthecontrary,our methodology exactlycalculates the statistics for catchment, in a lightweight way (computational complexityisapproximatelyequaltoonesimulation run).The resultsin Fig. 3demonstrate these advantagesofour methodology. In Fig.3(a), we present results for 5 indicative scenarios (xaxis); in eac h of them ndstis con nectedto a randomlyselected pair of ingress points, i.e.,M={m1,m2}.For each scenario we do the following. (i) We run 1000 simulations, assuming shortest p ath preference, and for each run wemeasure thecatchmentof m1;we present thedistribution oftheresults inboxplots( SIMS).(ii) We then applyour methodologytocalculatethe following quant ities: Lower(LOW)andUpper(UPP)bounds :Thecertaincatchment |CC(m1)|ofm1,whereCC(m1)= {i∈N:f(i)=m1}, (calculatedby Algorithm 2) is alower bound for the catchment of m1, since morenodes(whoseinferenceisnotcertain)mayrouteto m1aswell.Respectively,an upperbound forthecatchmentof m1isgivenby|N|−|CC(m2)|,sincethenodesin CC(m2)cannotrouteto m1. Wepresent thelower/upperboundswith( RGLOWSP /RGUPPSP )andwithout ( RGLOWNOSP / 191 2 3 4 5 Index of ingress point pair (#)020406080100Catchment of 1st ingress point (%)RGUPPN0SP RGUPPSPRGAVGNOSP RGAVGSPRGLOWNOSP RGLOWSPSIMS (a) Rgraph vs simulations in space1 20 40 60 80 100 120 140 Simulation run (#)404244464850Catchment of 1st ingress point (%)RGAVGSP SIMSCMAVG (b) Rgraph vssimulations intime Fig.3. (a)Simulationresultsandinferencesforthecatchm entof1stingresspoint( m1)fordiﬀerentscenarios. (b)Catchmentof1stingresspoint( m1)forascenario,calculatedasacumulativemovingaverageo fdiﬀerent simulation runs( CMAVG) and aspredictedbyour methodology ( RGAVGSP ). RGUPPNOSP )shortest path preference. Meanvalue(AVG) :Wecalculatethemeanvalueofthecatchmentfor m1as/summationtext.1 iπi(m1),wherethe route probabilities πiare calculatedby the probabilistic inference Algorithm 3, with (RGAVGSP ) and without ( RGAVGNOSP )assuming shortest path preference. Somemainobservationsandinsightsfromthecomparisonofthes imulationresults( SIMS)with ourpredictions are: (i) The predicted mean values RGAVGSP with shortest path preference ( i.e.,as in the simulation setup)coincidealways withtheaveragevaluescalculatedfromthesimulationresu lts(SIMS).Note though that our prediction requires only a single simulation r un, whereas simulationbased ap proaches require several runs to converge to the mean value. We demonstrate this in Fig. 3(b), which shows that the average value of catchment calculated fr om simulation runs (continuous line),needs almost 100 runs to converge to the predicted mean value (dashed line). The presented results are forthe 3rd scenario ofFig. 3(a); however, similar patternswere observed across allthe pairswe examined. (ii) As expected, none of the simulation results is outside the boundsRGLOWSP andRGUPPSP . Whentheupperandlowerboundsarecloser,simulationresults aremoreconcentratedaroundthe mean.The distance between the lower/upper bounds shed light on th e eﬀect of the randomness in a simulation .Forexample,inthe4thscenario,theboundscoincide,thussho wingthatthecatchment is not aﬀected by the tiebreaking process; or,equivalently, k nowing only coarse estimates of the policies is enough for an accurate prediction. On the other hand ,in the 1st scenario, the distance between the boundsis larger,which implies that measurements would be neededfor an accurate calculationofthe catchment. (iii) Theboundsthatare calculatedwithout assuming shortes t path preference ( NOSP)are looser, since they account for a larger set of possible scenarios. The di ﬀerence between the predictions with (SP) and without ( NOSP)shortest path preference reveals the eﬀect of the path length s in a routingconﬁguration.Thisknowledgecanbeusefulintraﬃcengine ering.Forexample,inthe2nd scenario,the two upperboundsare very close.Thismeansthat the maximumcatchmentof m1is aﬀectedmainlybythelocalpreferencesandnotbythepathlengths .Hence,evenifweincreasethe lengthofthepathsto m2throughpathprepending,thiswouldnotincreasesigniﬁcantlyth ecatch ment ofm1. On the contrary, the large distance between the two lowerbounds in the same 2nd 202 4 8 16 # Ingress Points020406080100% of NodesNOMON RVRIS LG RAPING RATRACE ALL (a) Base Model2 4 8 16 # Ingress Points020406080100% of NodesNOMON RVRIS LG RAPING RATRACE ALL (b) Base Model+SP Preference Fig. 4. Distribution (over 1000simulation runs) of the percentage of nodeswith a certain in ference (yaxis), inscenarioswithdiﬀerentnumberofingresspoints(xaxis). Boxplotscorrespondtodiﬀerentsetupswithout andwith measurements,for scenarios(a) withoutand (b)withpreference ofshorterpaths (SP). scenario,indicatesthatapplyingpathprependingtoannouncementst hroughm1,cansigniﬁcantly decrease its catchment. 5.4 CompletenessofInference InFig.2(a)weseethat, e.g.,for|M|=2acertaininferenceispossiblefor ∼15kofthetotal∼62k nodes in the graph. Here, we investigate for how many nodes (compl eteness) our methodology returnsa certaininference,withorwithoutmeasurements. Remark:probabilistic inferenceismade forall nodes(see Section 3.3). To consider realistic scenarios, we simulate measurements fro m the vantage points of several real Internet measurement platforms: •RouteViews [48] andRIPE RIS [43] (RV_RIS) provide BGP RIBs and updates collected from more than400ASesworldwide. •RIPEAtlas [42]comprisesmorethan25 kprobes(in∼3.5kASes),i.e.,devicesabletorunpings (RA_PING)ortraceroutes ( RA_TRACE )towards certain Internet destinations. •Looking Glasses (LG) are servers that provide the BGP RIBs of the networks (ASes) t hey are hosted in.We use the Periscopeplatform[ 6],to obtain a list ofLGsin 883ASes. Remark:The BGP data of a network ior traceroutes from itondstcan provide a route oracle for all the nodes in the best path bpi→ndst. Pings from ndsttoican provide a route oracle only for i[13]. Figure4showsforhowmanynodesacertaininferenceispossibleindiﬀere ntsetups.Somekey observations are: (i) The number of inferences decreases with the number of ingress p oints. Although this is ex pected,ourmethodologyquantiﬁeshowthisbehaviorisaﬀect edbydiﬀerentparameters(number ofingress points, measurement setup, etc.). (ii)Assumingpreferenceofshorterpathsleadstosigniﬁcantly moreinferences.Forinstance,even without measurements (red boxplots  NO_MON) the median percentages increase from 5% −19% (Fig.4(a)) to 42%−76%(Fig. 4(b)). 210246810050100150200250300350400 # Measurements# Extra Inferred NodesGreedy (1000 probes) Greedy (100 probes) Random (a) 2975uncertain nodes0246810010002000300040005000 # Measurements# Extra Inferred NodesGreedy (1000 probes) Greedy (100 probes) Random (b) 11918uncertain nodes Fig. 5. Number of extra nodes whose routes can be inferred with certainty (yaxis) when a set of measure mentsXisprovided(|X|inxaxis),intwoscenarioswith(a)lowand(b)highnumberofn odeswithinitially uncertain route. (iii) Public measurement platforms can signiﬁcantly enhance infe rence. Their contribution is cru cialwhenmanyingresspointsareinuse; e.g.,inFig.4(a)for|M|=16usingallplatformsincreases inference from5%to 49%,and in Fig. 4(b)from42%to 79%. (iv) Interestingly enough,even alightweight measurement camp aignwith pings(blackboxplots RA_PING;e.g.,assuggestedin[ 13]),canachievealmostthesameenhancementwithemployingall platformstogether.However, we simulated pingsonlytoRIPE A tlasprobes(3.5kmeasurements), incontrastto[ 13]thatrequiresordersofmagnitudemoremeasurements;combini ngourmethod ologywith that techniquecouldpotentially lead toeven more e ﬃcient route inference. 5.5 EﬀicientMeasurements Next,weevaluatetheabilityofAlgorithm 6toselectasetofnodestobemeasured.Weconsidertwo scenarios with|M|=2,taking into accountonly the ∼20knonstub nodes ofthe ASgraph,and apply Algorithm 2to calculate the certain inference. The number of nodes whose rou tes cannot be inferred with certainty are 2975 (“low”) and 11918 (“high”) i n the scenarios of Fig. 5(a)and Fig.5(b), respectively. To enhance inference, we conduct measurements to a set of nodesX, and thenapplyAlgorithm 4. InFig.5wepresentresultsfortheextranumberofnodeswhoseroutesare inferred with certainty after the measurements. Sets Xare selected with the greedy Algorithm 6 among 100 and 1000 nodes with RIPE Atlas probes (continuous lines, “ Greedy”), or are selected randomlyamongnodeswithRIPEAtlasprobes(dashedline,“Random ”).Themainobservation is thatselectingthenodestobemeasuredwiththeproposedalgor ithmissigniﬁcantlymoreeﬃcient than a random selection. Our algorithm is able to select a good s et of nodes, and its eﬃciency increaseswhentheset ofavailablenodes(withprobes)islarg er(“Greedy1000”vs.“Greedy100”). Comparing the results in Fig. 5(a)and5(b), reveals that the careful selection of the set Xis more crucialforscenarioswithhigh–initial–uncertainty(Fig. 5(b));e.g.,asinglemeasurementfromthe node selected with our algorithm can infer with certainty up to 1 000extra routes (“Greedy 1000” in Fig.5(b)). 225.6RealWorldEvaluation Besides simulations, here, we provide evaluation results fr om measurements and experiments in the real Internet. Measurements for MOAS preﬁxes. The proposed inference framework can be applied on top of any given topology and routing model ( i.e.,it takes this information as input). As a result, its accuracy depends on how complete andaccuratethe knowledge of (i) the routing policies Qand Hand (ii) the ASlevel graphis(perfectknowledgeleadsto 100% inference accuracy). We veriﬁed this by comparing our inference results against real B GP routing entries collected frommorethan200routecollectorsofRIPERIS[ 43]andRouteViews[ 48]foraround300preﬁxes that are anycasted by more than one AS ( i.e.,MultiOrigin AS, MOAS) in the Internet [ 7]. When usingtheVFmodel(seeSection 2.3)andtheavailableASrelationships[ 5],theachievedaccuracy (fornetworkswhoseroutingentriesareavailable)is6070%7,whichcomplieswiththeobservedac curacyoftheVFmodelforInternetrouting[ 1].Asacomparison,theaccuracyofsimulationbased catchment prediction in these scenarios is 10% lower than the a ccuracy of the certain inference with shortest path preference. Introducing ﬁnegrained reﬁnement s in the routing policies for some nodes,increases accuracy;we tested this by considering pe rpreﬁx policies,similarly to [ 1]. Speciﬁcally, we reran our inference by “correcting” ( i.e.,replacing, adding, removing) in the R graph the links close to the anycasters (starting from the ﬁrst h ops), with the actually observed linksinthemeasuredpaths. Forexample,ifalinkwasnotinclude dintheinitialtopologydataset (ASrelationships [ 5]), but was observed in the real measurements, we added it in th e Rgraph to increase the completeness of the topology;or, if an observed l ink existed in the topology,but did not appear in the Rgraph ( i.e.,due to an inaccurate routing policy), we similarly added it in t he “corrected”Rgraph. With a 30% of the links observed by the mo nitors being corrected,the aver ageaccuracyincreases to 80%.Thisobservation validates th at the inference accuracydependson the underlyingknowledgeofthe topologyand routing policies. Moreover, the structure of the Rgraphprovides further insi ghts about what are the important linksandpoliciesforaroutingconﬁguration,andhowmissinginform ation(e.g.,topologyincom pleteness) would aﬀect inference. For example, a link that is in t he topology dataset but does not appear in the Rgraph, does not aﬀect the inference, i.e.,missing this link ( e.g.,in an incomplete dataset)wouldnotbeimportant.Similarly,alinkthatappears intheRgraphbutremovingitdoes notaﬀectthe certaininferenceofanynode,wouldnotbeimportantfortheexaminedrouting con ﬁguration. This information could be used –similarly to our ex periments– to design methodsfor targetedcorrections( e.g.,throughtargetedmeasurements) of atopology/routingmodel. Anycast experimentswiththe PEERING testbed. We conductedcontrolled IP anycast exper iments in the real Internet using the PEERING testbed [ 39,44], which owns ASNs, IP preﬁxes and has BGP connections with operational networks in several locat ions around the world. We announce the same preﬁx from diﬀerent PEERING locations, i.e.,ingress points. Figure 6shows thefractionofthecatchmentofeachingresspointinfourexper imentscenarios(SC0,SC1,SC2, andSC2*),asmeasuredfromtheRIPERIS[ 43]andRouteViews[ 48]routecollectors(blackbars), and inferred using ourframework(Eq.( 5) withTi=T,∀i) ontop of theVF model(white bars). We consider an initial scenario (“SC0”), where a network has two ingress points, AMSand UFMG(formoredetailsaboutthePEERINGlocationssee[ 39]).AsseeninFig. 6,theloaddistribu tion is highly skewed towards AMS; our inference captures this imbalance, with a 10% deviation 7An interesting observation is that assuming shortest path preference (Section3.5) increases the inference completeness from30%to65%,withoutsigniﬁcantlyaﬀectingtheaccuracy; thissup ports therealworldrelevanceofthisassumption [ 1, 19,40]. 23AMS UFMG other00.20.40.60.81Fraction of catchmentExperiment Inference (a) SC0AMS UFMG other00.20.40.60.81Fraction of catchmentExperiment Inference (b) SC1AMS UFMG other00.20.40.60.81Fraction of catchmentExperiment Inference (c) SC2AMS UFMG other00.20.40.60.81Fraction of catchmentExperiment Inference (d) SC2* Fig. 6.Experiments in the real Internet with the PEERING testbed: Ca tchment of the ingress points { AMS, UFMG, other } in four deployments/scenarios (SC0, SC1, SC2, SC2*) a s observed from monitors in the Internet(blackbars)andpredictedusing our framework (wh ite bars). from measured values. The network would like to evaluate whet her it can balance the load by addingmoreingresspoints,beforeproceedingtoanactualdeplo yment(i.e.,hypotheticalscenario). Oneoption(“SC1”)istoaddanextraingresspoint(atthePEERI NGlocation GRNET).However, our inference (white bars for SC1) predicts that this would ha ve only a small eﬀect on the load distribution, andthusit wouldbe anineﬃcient deployment.Our ex perimental results (blackbars for SC1) verify this behavior, i.e., the added ingress point i n SC1 (“other” bars) attracts a small percentage of traﬃc. Hence, the network considers a second option (“SC2”) to add two other ingress points (at the PEERING locations ISIandUW). Our inference predicts that SC2 would (i) move a signiﬁcant fraction of load from AMSto the added ingress points, and (ii) not aﬀect theloadof UFMG,i.e.,SC2achievesabetterloadbalancingthanSC1.Whiledeviati ons between inferredandmeasuredcatchmentexistalsohere(duetotheempl oyednaiveVFmodel),theactual behavior isapproximated well by ourpredictions. Moreover,wecalculatedthecertaincatchment withoutshortestpathpreferencefor AMSinSC2, whichcorrespondstoa“lowerbound”(cf.Section 5.3)fortheAMScatchment,i.e.,underanypath lengthcombination.We foundthe AMScertain catchmenttobealmostzero(notshownin Fig. 6). This means that the short path lengths towards AMSare the main causes for traﬃc to be routed tothisingresspoint.Therefore,prependingtheannouncementsfrom AMS(toartiﬁciallyincrease pathlengths)couldfurtherdecreasetheattractedload.Inf act,sincethe AMScertaincatchmentis verysmall,anintensiveprependingcouldevendiminishtheloadi nAMS.Weveriﬁedthisthrough experiments(“SC2*”)withtheingresspointsofSC2,wherewe prepended5hops(i.e.,morethan the medianASpath lengthin the Internet [ 45])in the announcementsfrom AMS. 6 RELATED WORK "
142,An Opportunistic AODV Routing Scheme : A Cognitive Mobile Agents Approach.txt,"In Manets Dynamics and Robustness are the key features of the nodes and are
governed by several routing protocols such as AODV, DSR and so on. However in
the network the growing resource demand leads to resource scarcity. The Node
Mobility often leads to the link breakages and high routing overhead decreasing
the stability and reliability of the network connectivity. In this context, the
paper proposes a novel opportunistic AODV routing scheme which implements a
cognitive agent based intelligent technique to set up a stable connectivity
over the Manet. The Scheme computes the routing metric (rf) based on the
collaboration sensitivity levels of the nodes obtained based through the
knowledge based decision. This Routing Metric is subsequently used to set up
the stable path for network connectivity. Thus minimizes the route overhead and
increases the stability of the path. The Performance evaluation is conducted in
comparison with the AODV and sleep AODV routing protocol and validated.","    The information diffusion dynamics has become seaml ess with the increased use of pervasive  computing devices. The MANET is one among the impor tant technologies supporting pervasive  computing by enhancing the mobility in the dynamic environment. MANET's [1] are distributed,  selfconfigurable, infrastructure less Ad hoc class  of wireless networks with no fixed  apparatus.  MANET's find applications in many areas ranging fro m commercial to critical as well  from consumer to the military . MANET's diversified use is due to its features su ch as robustness  to cope up with dynamic network topology; fluctuati ng, high bit error rate and various links;  collaboration among the nodes and so on  [2]. The typical applications are in dynamic unplanned  situations [3] requiring emergency management such as recovery from disasters; an earthquake,  flood, chemical accidents and so on.  MANET's can h andle the volatile topology [4] through  dynamic routes. It has hosted routing protocols [5]  such as AODV, DSR, DSDV, and TORA and  so on. Even though an investigation says no specifi c protocol is sufficient for all the scenarios,  AODV [6] is the popular imploded ondemand reactive , table driven protocol.   International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.8, No.1/2/3, June 2017  2 AODV consists of two phases of routing, i.e., route  discovery and route maintenance. AODV  discovers routes when required and are maintained j ust as long as needed. When a node wishes to  send a packet to some destination, on the unavailab ility of the current path initiates the route  discovery phase by broadcasting route request (RREQ ) packet. On comparison, AODV  outperforms DSR protocol [7] [8] in stressful situa tions having increased mobility and traffic due  to fewer delay requirements.    However, the AODV protocol exhibits several pitfall s that need to overcome for better  connectivity during the information diffusion. The major limitation of the protocol is the routing  overhead [9]. It only maintains the link informatio n between the communication nodes. Link  failures will be more at higher mobility, triggerin g more route request packets, and thus the  network has to suffer from the high frequency of ro ute discovery phases which degrades the  performance. Mostly, these link breakages are due t o lack of resources such as energy, memory,  and width, computing power and the mobility of node s.     There is a need for a novel scheme that minimizes t he route request overhead by identifying the  resource requirement and takes knowledge based deci sion prior the link breakage. An efficient  resource pooling technique is required to identify,  manage and track the resource on time. Thus  the probability of link breakage can be determined and proactively notified to the mobile nodes.  Using the information the node needs to take an int elligent decision towards maintaining the  connectivity without triggering the route rediscov ery phase. But due to the dynamic mobility of  the nodes, getting the resourceful node for computa tion and connectivity will be difficult with  conventional AODV scheme, as it requires an endto end connectivity between the source and  destination. Hence a computing paradigm is needed t hat makes use of the intermittent  connectivity within the network based on opportunis tic contacts between nodes. The paper  proposes a novel intelligent scheme to reduce the r outing overheads of the AODV scheme using  opportunistic computing technique based on cognitiv e theory.    1.1  OPPORTUNISTIC COMPUTATION     An opportunistic computing is a kind of pervasive c omputing [10], which takes the benefits of  randomness and uncertainty in the environment to es tablish the communication opportunistically  between pairs of diverse devices and applications. The opportunistic computation takes place in  the nodes that are part of an opportunistic network .    1.2  OPPORTUNISTIC NETWORK (O N)    It is the class of MANET's which exploits the conta ct opportunity among the nodes for the  communication between the source and destination wi thout the endtoend connectivity [11]. The  favorable circumstances such as interconnectivity, contextactivity and so on, create the contact  opportunities.    Formulation of opportunistic network:    Let us consider a graph of MANET, G{V, E}, with ‘V'  number of nodes and ‘E' wireless links  among them as shown in figure 1.  International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.8, No.1/2/3, June 2017  3      Figure 1: MANET set represented by graph G {V, E} w ith ‘n’ number of V and ‘n1' number of E.    Then H{P, L}  be the subgraph of G with P  ={ n k} number of nodes and L={ l i,j }, where i ≠j  wireless links as shown in figure 2, where S repres ents the opportunistic network area.     Then H is called an opportunistic network over a Eu clidean plane ‘S’ iff the affinity of  opportunistic contact between the nodes n i P and n j P is greater than the average degree of  opportunistic contact ( ) between the two nodes as shown in figure 2.     i.e.,  ,          P {}  { , } ( )       ( , ) avg  i j i j if L  H P L n n S if n n  ∅ = =  =∆ ≥ ∆ U     ∆ denotes the degree of opportunistic contact betwee n the nodes and .  The degree of opportunistic contact of node n i w.r.t its neighboring nodes (k) is, .  Similarly for n j,  .    Let D {N, W} the weighted contact graph with N numb er of neighbor nodes and W weight  matrix= {w ij } be the sub graph of H. Weight matrix indicates th e relationship strength between  the nodes i and j. The weight w ij  is a correlated matrix of the parameters contact f requency f ij and  the  sum of all contact durations t ij .       Where, σf and σt are empirical standard deviations and i, j ∈ N.    The w ij  is transformed to a scalar value W ij  using the principal component.     The average degree of opportunistic contact , N is the number of connected neighbors.   International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.8, No.1/2/3, June 2017  4      Figure 2: Formation of an Opportunistic network rep resented by sub graph H (P, L) within the MANET  graph G (V, E)    1.3  OPPORTUNISTIC CONTACT (O C)    The nodes which are within the reachable region are  said to be in opportunistic contact if they  share any one or all of the characteristics such as  the common goal, shared context activity,  same  background,  common destination and so on. The degr ee of opportunistic contact ( ∆) indicates the  affinity between the nodes to have an opportunistic  contact.     Therefore the Opportunistic contact between the nod es n i and n j is { , } max { } 0kOC n n i j i i= ∆ =U        where, the degree of opportunistic contact  ∆      for OC   n   nodes Number of nodes having the affinity  Total umber of =   The number of nodes having affinity for OC is given  by,   1( ) n k ka n nrc π =∑ ,   where a(n) represents the affinity of node n toward s the OC and is given by,     ( )  E { }  Sa n Cn Rn Ln  ∈= ∪ ∪  ΕaU    Εdenotes the MANET environment with s ⊆ Ε.  Let C n be the set of context activities in E at time NT.   Let R n be the set of resource available in E at time NT.  Let L n be the set of nodes towards same destination in E at time NT.    The ∆ is parameterized using the metric called Opportunistic Contact level (OCL).  The various  context activities at the K th node will choose the OCL into any one of the 3 set levels within range  of {02}, where 0 is the highest degree and 2 is th e least.       The j th  context activity of the K th  node is given by, ( ) ( ) ( )  (l , ) k K  j ij ij C k x =    where l ij  is the link between the nodes n i and n j. x ij  is the context similarity metric between the  nodes n i and n j.  Similarly, R j(k) and L j(k) can be computed.    International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.8, No.1/2/3, June 2017  5 The x ij  is a function of the three context parameters. The age of la st context match (A m), which is  obtained from the timestamp attached with each context match.  The number of context matches  between the nodes (N m) obtained from log history. The location traces in the history log gives the  similar context location (Lm).     Let {Tr i} be the set of location traces for node n i and {Tr j} be the set of location traces for node n j  then,      The contact similarity metric x ij (k)  is given by,    ( )  ( )  ( ) 0      j=1,2,....n  if 0  x  0.5  k  , then    0.5  x   1  k   then k ij  k ij  k ij x if ε δ      ≥ ∀  ≤ ≤ ∀ ∈ Ε  ≤ ≤ ∀ ∈ Ε      Where εdenotes the Vagrant context similarity and δ denotes the maximum context similarity.   The computation performed on nodes by opportunistically availing the ot her resources of the  environment, along with resources available on its device wi thin the opportunistic network is  called opportunistic computation . Here each node exploits the transient unpredicted contacts to   cooperate and share each other's content, resources, and servi ces [11, 12] (M. Conti, 2010).    1.4  COGNITIVE THEORY     Cognitive Agent [12, 13], is an intelligent software agent . It is an autonomous and responsive  entity which reflects the state of information of the environm ent which is represented using  cognitive terms. Similar to human perceptual experience and under standing of the surrounding  environment, CA's can provide an immediate or a controlled response  to the changes in the  environment [14, 15]. Cognitive agents have selflearning, self improving and selfinstructible  ability [17, 18] and therefore, reduce the network overhead. Co gnitive agents are suitable for  adaptive, dynamic, contextbased behaviourism, decision making, huma n mobile network  interaction system [16, 19, and 20] and so on.    1.5  PROPOSED COAODV     The proposed Cognitive agents based Opportunistic AODV (COAODV) sc heme uses Mobile  cognitive agent (MCA).  The mobile nodes in the network embed the MC A with them. The MCA  is having communication with all reachable MCA's track the  availability of resources through the  BehaviorObservationBelief (BOB) cognitive model (b s bsbu et al., 2009) and generates the  recommendations about resource availability based on the routing fa ctor. Upon the  recommendation, the AODV routing protocol will opportunistic ally route the messages towards  the destination before losing the current connectivity and avoids the triggering of the route  discovery process .    Organization of the paper:  The rest of the paper is organized as follows, Section 2 give s some  of the related works, Section 3 discusses the proposed scheme, section 4 illustrates the results,  and finally, Section 5 draws conclusions. International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.8, No.1/2/3, June 2017  6 2. R ELATED WORKS   "
52,Generalizing Multi-party Contract Signing.txt,"Multi-party contract signing (MPCS) protocols allow a group of signers to
exchange signatures on a predefined contract. Previous approaches considered
either completely linear protocols or fully parallel broadcasting protocols. We
introduce the new class of DAG MPCS protocols which combines parallel and
linear execution and allows for parallelism even within a signer role. This
generalization is useful in practical applications where the set of signers has
a hierarchical structure, such as chaining of service level agreements and
subcontracting.
  Our novel DAG MPCS protocols are represented by directed acyclic graphs and
equipped with a labeled transition system semantics. We define the notion of
abort-chaining sequences and prove that a DAG MPCS protocol satisfies fairness
if and only if it does not have an abort-chaining sequence. We exhibit several
examples of optimistic fair DAG MPCS protocols. The fairness of these protocols
follows from our theory and has additionally been verified with our automated
tool.
  We define two complexity measures for DAG MPCS protocols, related to
execution time and total number of messages exchanged. We prove lower bounds
for fair DAG MPCS protocols in terms of these measures.","A multiparty contract signing (MPCS) protocol is a communication protocol that allows a number of parties to sign a digital contract. The need for MPCS protocols arises, for instance, in the context of service level agreements (SLAs) and in supply chain contracting. In these domains (electronic) contract negotia tions and signing are still mainly bilateral. Instead of negotiating and signing one multiparty contract, in practice, multiple bilateral negotiations are conducted in parallel [21]. Because negotiations can fail, parties may end up with just a subset of the pursued bilateral contracts. If a party is missing contracts with providers or subcontractors, it faces an overcommitment problem. If contracts with customers are missing, it has an overpurchasing problem [8]. Both problems can be prevented by using fair multiparty contract signing protocols. Existing optimistic MPCS protocols come in two  avors. Linear MPCS pro tocols require that at any point in time at most one signer has enough infor mation to proceed in his role by sending messages to other signers. Broadcast ?This is the extended version of [14].arXiv:1501.03868v2  [cs.CR]  17 Feb 2015MPCS protocols specify a number of communication rounds in each of which all signers send or broadcast messages to each other. However, neither of the two kinds of protocols is suitable for SLAs or supply chain contracting. The rea son is that in both domains, the set of contractors typically has a hierarchical structure, consisting of main contractors and levels of subcontractors. It is unde sirable (and perhaps even infeasible) for the main contracting partners and their subcontractors to directly communicate with another partner's subcontractors. This restriction immediately excludes broadcast protocols as potential solutions and forces linear protocols to be impractically large. In this paper we introduce MPCS protocol specications that support arbi trary combinations of linear and parallel actions, even within a protocol role. The message  ow of such protocols can be specied as a directed acyclic graph (DAG) and we therefore refer to them as DAG MPCS protocols. A central requirement for MPCS protocols is fairness . This means that either all honest signers get all signatures on the negotiated contract or nobody gets the honest signers' signatures. It is well known that in asynchronous communi cation networks, a deterministic MPCS protocol requires a trusted third party (TTP) to achieve fairness [5]. In order to prevent the TTP from becoming a bottleneck, protocols have been designed in which the TTP is only involved to resolve con icts. A con ict may occur if a message gets lost, if an external ad versary interferes with the protocol, or if signers do not behave according to the protocol specication. If no con icts occur, the TTP does not even have to be aware of the execution of the protocol. Such protocols are called optimistic [1]. We focus on optimistic protocols in this paper. DAG MPCS protocols not only allow for better solutions to the subcon tracting problem, but also have further advantages over linear and broadcast MPCS protocols and we design three novel MPCS protocols that demonstrate this. One such advantage concerns communication complexity. Linear protocols can reach the minimal number of messages necessary to be exchanged in fair MPCS protocols at the cost of a high number of protocol \rounds"". We call this theparallel complexity , which is a generalization of the round complexity mea sure for broadcast protocols, and dene it in Section 4.3. Conversely, broadcast protocols can attain the minimal number of protocol rounds necessary for fair MPCS, but at the cost of a high message complexity. We demonstrate that DAG MPCS protocols can simultaneously attain best possible order of magnitude for both complexity measures. As discussed in our related work section, the design of fair MPCS protocols has proven to be nontrivial and errorprone. We therefore not only prove our three novel DAG MPCS protocols to be fair, but we also derive necessary and sucient conditions for fairness of any optimistic DAG MPCS protocol. These conditions can be implemented and veried automatically, but they are still non trivial. Therefore, for a slightly restricted class of DAG protocols, we additionally derive a fairness criterion that is easy to verify. Contributions. Our main contributions are (i) the denition of a syntax and interleaving semantics of DAG MPCS protocols (Section 4.1); (ii) the denition 2of the message complexity and parallel complexity of such protocols (Section 4.3); (iii) a method to derive a full MPCS specication from a skeletal graph , including the TTP logic (Section 5); (iv) necessary and sucient conditions for fairness of DAG MPCS protocols (Section 5.3); (v) minimal complexity bounds for DAG MPCS protocols (Section 6.1); (vi) novel fair MPCS protocols (Section 6.2); (vii) a software tool that veries whether a given MPCS protocol is fair (described in Appendix A).3 2 Related Work "
426,On The Recovery Performance of Single- and Multipath OLSR in Wireless Multi-Hop Networks.txt,"In this paper, we study and improve the recovery properties of single and
multipath routing strategies when facing network failure situations. In
particular, we focus our study on two MANET routing protocols: OLSR and its
multipath extension MP-OLSR. In various wireless multi-hop network
environments, especially in multiple chain topologies, we define and seek to
evaluate the latency introduced by these protocols to find a new path after a
link failure. Theoretical estimations and simulation results show that, under
dual chain-topologies, this latency can be too long and incompatible with the
needs of loss and delay constrained applications. As the source nodes cannot
detect link failures immediately because of the delay incurred by the
well-known nature of link state protocols in general, and of OLSR Topology
Control (TC) messages in particular, these nodes keep sending packets along
broken paths. We thus study the inconsistencies between the actual network
topology and the nodes' own representation. After analyzing the consequences of
this long latency, we seek to alleviate these problems with the introduction of
adapted mechanisms. We propose three new different schemes and accordingly
extend the original OLSR and MP-OLSR protocols in order to decrease the
expected latency and improve the protocol performance. Simulation results show
a steep decrease of the latency when using these new schemes in dual
chain-topologies. We also discuss these results in terms of packet loss,
end-to-end delay and overhead.","mechanisms. We propose three new different schemes and accordingly exte nd  the original OLSR and MP OLSR protocols in order to decrease the expected  latency and improve the protocol performance. Simulation results show a steep  decrease of the latency when using these new schemes in dual chain topologies.  We also discuss these results in terms of packet loss, end toend delay and  overhead.    Keywords : ad hoc networks, multipath routing, link state protocols, fault  tolerance .  1   Introduction   A Mobile Ad Hoc Network (MANET) is formed by a collection of wireless mobile  nodes which can dynamically exchange and relay data. Provided there is at least one  path from a source to a destination, this pair can thus communicate, even if not in  direct radio range. However, while the multi hop nature of MANETs facilitates the  connection between  nodes, those networks face many traffic impediments, often  provoked by rapidly changing topologies. Some causes for those continuous changes  are unpredictable node mobility patterns and fluctuating radio link quality. Moreover,  some of those nodes may be energy and bandwidth constrained. For these reasons, paths between source destination pairs are generally unstable over time and one  primary objective of MANET routing protocols is to alleviate such instability by  performing optimal path discovery and main tenance. For these protocols, performing  an efficient recovery, i.e. limiting data loss and incurred delays after a link failure, is a  desirable feature and a challenging issue. In this context, introducing some form of  fault tolerance is one of the expect ed benefits of multipath routing, along with load  balancing and route aggregation. Multipath protocols provide backup paths in case  unacceptable degradations or failures are detected on the active paths. As a result,  faster and more efficient recoveries ar e meant to follow route failures. However, this  efficiency greatly depends on the failure detection speed and on how fast corrective  measures are applied by the multipath routing protocol.  As an illustration, t he authors  of [16]  experimented  on a real MANE T made of 18 OLSR nodes . In particular, they  introduced or removed nodes and measured  the consecutive recovery time s by the  surrounding nodes . According to t heir results , it takes  about 4 to 10 second  for the  updated topology information corresponding to an appearing node to be  disseminated  through the whole MANET. Likewise,  a disappearing node  event and the subsequent   lost link  information dissemination take about 7 to 11 seconds to reach the most  remote nodes of the considered MANET. Such measurements  highlight that  a high  rate of topological events such as those previously mentioned can result in significant  dissemination times and  inconsistenc ies in network views , which can negatively   affect the network performance.  This study only concerns the single pa th routing  OLSR in the specific context of nodes appearance/disappearance.   In our work , we aim at deepening the study of recovery time and propose new  schemes  to single  and multipath OLSR routing which  are designed to improve the  recovery properties  as we ll as the performance  of the routing protocols . More  precisely, we are interested in the ir performance in various topologies, among which  Wireless Mesh Network ( WMN ) topologies, where node mobility, compared to that  of general MANET topologies, is signific antly reduced or null. This context is of  utmost importance for operators as an efficient WMN deployment is dependent of  network topology, among other important key factors [5]. When deploying WMN,  network operators not only seek to create uniform wireless  access coverage by  judiciously placing WMN nodes on the designated area, they also need to provide  adequate backhaul connectivity. For this latter issue, WMN are increasingly seen as  an efficient alternative to known wired and wireless backhaul technologi es [6],  especially when cost efficiency is sought, for instance in emerging regions, where  operators do not necessarily deploy wired backhaul infrastructures.  But for a wide  acceptance of WMN as backhaul network, it is important that the recovery process  does not imply unacceptable delays for some networking applications, like for  instance, Telephony over IP ( ToIP ) or streaming.   The rest of the paper is organized as follows. We first present works related to  recovery mechanisms  in Section 2. In Section 3, we provide an analysis of the delay  recovery  related to long latencies produced by OLSR and MP OLSR in dual chain  topology networks. Then, we propose  in Section 4 three different adapted schemes.  Afterwards, we discuss performance evaluation results  in Sec tion 5 . We finally  present the concluding remarks and the ongoing work.     2   Related Works   "
216,On the Use of Smart Ants for Efficient Routing in Wireless Mesh Networks.txt,"Routing in wireless mesh networks (WMNs) has been an active area of research
for the last several years. In this paper, we address the problem of packet
routing for efficient data forwarding in wireless mesh networks (WMNs) with the
help of smart ants acting as intelligent agents. The aim of this paper is to
study the use of such biologically inspired agents to effectively route the
packets in WMNs. In particular, we propose AntMesh, a distributed
interference-aware data forwarding algorithm which enables the use of smart
ants to probabilistically and concurrently perform the routing and data
forwarding in order to stochastically solve a dynamic network routing problem.
AntMesh belongs to the class of routing algorithms inspired by the behaviour of
real ants which are known to find a shortest path between their nest and a food
source. In addition, AntMesh has the capability to effectively utilize the
space/channel diversity typically common in multi radio WMNs and to discover
high throughput paths with less inter-flow and intra-flow interference while
conventional wireless network routing protocols fail to do so. We implement our
smart ant-based routing algorithm in ns-2 and carry out extensive evaluation.
We demonstrate the stability of AntMesh in terms of how quickly it adapts
itself to the changing dynamics or load on the network. We tune the parameters
of AntMesh algorithm to study the effect on its performance in terms of the
routing load and end-to-end delay and have tested its performance under various
network scenarios particularly fixed nodes mesh networks and also on mobile WMN
scenarios. The results obtained show AntMesh's advantages that make it a
valuable candidate to operate in mesh networks.","Wireless mesh networks (WMNs) have emerged as a pro mising technology for the provision of  last mile broadband Internet access infrastructure in both urban and rural environments. Such  networks are characterized as fixed backbone WMNs w here relay nodes are generally static and  are mostly supplied by permanent power sources [1].  With the availability of offtheshelf, low  cost, commodity networking hardware, it is possible  to incorporate multiple radio interfaces  operating in different radio channels on a single m esh router; thus forming a multiradio mesh  network. This enables a potential large improvement  in the capacity of mesh networks  compared to singleradio mesh networks [20]. Howeve r, due to the shared nature of the wireless  medium, nodes compete with each other to access the  wireless channel, resulting in possible  interference among nodes which may affect traffic i n the network. Furthermore, the fact that  nodal density in a typical WMN is high compared to other wireless networks, make the flow  interference issue in WMNs more severe. Incorporati ng techniques to specifically address these  characteristics in a WMN routing protocol could imp rove the overall network flow capacity or  performance of individual flows in the network.   Generally, routing algorithms can be defined as mul tiobjective optimization problems in a  dynamic stochastic environment. However, formalizin g routing as such optimization problem International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 2, April 2012   118       requires complete knowledge of traffic flows betwee n each node in the network; this is  prohibitively difficult to model in the presence of  rapidly changing network dynamics (found in  typical WMNs). Therefore, heuristic policies are of ten used to create quasioptimal routing in  WMNs. There has been a significant body of research  in designing efficient heuristic based  routing protocols and metrics for WMNs (for a quick  overview see [2  5]). In the wired  networking domains, a new family of routing algorit hms has been proposed based on swarm  intelligence by Dorigo et al. called Ant Colony Opt imization (ACO) framework [6, 7], which is  a metaheuristic approach for solving hard optimiza tion problems.   ACO algorithms draw their inspiration from the beha viour of real ants, which are known to find  the shortest path between their nest and a food sou rce by a process where they deposit  pheromones along trails (acting like a local messag e exchange in a communication network).  Ants generally start out moving at random, however,  when they encounter a previously laid  trail, they can decide to follow it, thus reinforci ng the trail with their own pheromone substance.  This process is thus characterized as a positive fe edback loop, where the probability with which  an ant chooses a path increases with the number of ants that previously chose the same path [7].  Hence, In ACO framework, artificial ants  probabilistically and iteratively converge to a  solution by taking into account pheromone trails de posited by other ants and other local  heuristics. Artificial ants move stochastically (in stead of deterministically) in the solution space,  therefore they can explore a wider variety of possi ble solutions of a problem independently and  in parallel. A more detailed explanation of the ACO  framework can be found in [6].   1.1 Problem Addressed  In this paper, we address the problem of packet rou ting for efficient data forwarding in wireless  mesh networks. Since most of the traffic in a mesh network usually flows between regular nodes  and a few Internet gateways (i.e., rarely endtoen d between regular nodes). This can result in an  uneven loading of links and can cause certain paths  to be saturated. Similarly, the existence of  interflow interference among the nodes and intraf low interference within a transmission path  may affect traffic loads on mesh nodes in a multir adio WMN. The main objective of any mesh  routing protocol is thus to effectively distribute the traffic by selecting channel diverse paths  with less inter/intra flow interference.  1.2 Our Contributions  The salient features of our work that set us apart from the existing routing protocols in WMNs  are listed as follows:  • We propose a distributed routing mechanism which en ables the use of smart ants to  probabilistically and concurrently perform the rout ing and data forwarding in order to  stochastically solve a dynamic network routing prob lem.  • We formally define the properties and conditions ne cessary in the design of such smart  ant based routing algorithm for WMNs. These smart a nts help to effectively utilize the  space/channel diversity typically common in multi r adio WMNs.   • One interesting result is that smart ants has the c apability to discover high throughput  paths with less inter and intraflow interference w hen conventional wireless network  routing protocols fail to do so.  • The stability of any routing protocol depends upon how quickly it adapts itself to the  changing dynamics of the network. We demonstrate th rough simulations that AntMesh  quickly converges to the best path under situations  when traffic characteristics change.  We tune the parameters of AntMesh algorithm to stud y the effect of these on the  performance in terms of the routing load and endto end delay.  • To the best of our knowledge, our proposed forwardi ng technique is among the first  works that investigates the use of smart ants in WM Ns and demonstrates a possible good  performance advantage. International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 2, April 2012   119       1.3 Paper Organization  The rest of the paper is organized as follows. We s tart with providing an overview of some of  the existing ACO based routing protocols in wireles s networks in Section II. The concept of  smart ants in mesh networks and the necessary prope rties that they should possess are discussed  in Section III. We will explain the working of our smart antbased routing algorithm (AntMesh)  in Section IV together with the description of how smart ants are used in AntMesh to capture  the traffic load and inter/intra flow interference in WMNs. We describe the implementation  details of AntMesh followed by simulation results t o evaluate its performance to existing  routing schemes in Section V. Finally we conclude t he paper in Section VI.   2.  RELATED WORK   "
392,Statistical Analysis of Privacy and Anonymity Guarantees in Randomized Security Protocol Implementations.txt,"Security protocols often use randomization to achieve probabilistic
non-determinism. This non-determinism, in turn, is used in obfuscating the
dependence of observable values on secret data. Since the correctness of
security protocols is very important, formal analysis of security protocols has
been widely studied in literature. Randomized security protocols have also been
analyzed using formal techniques such as process-calculi and probabilistic
model checking. In this paper, we consider the problem of validating
implementations of randomized protocols. Unlike previous approaches which treat
the protocol as a white-box, our approach tries to verify an implementation
provided as a black box. Our goal is to infer the secrecy guarantees provided
by a security protocol through statistical techniques. We learn the
probabilistic dependency of the observable outputs on secret inputs using
Bayesian network. This is then used to approximate the leakage of secret. In
order to evaluate the accuracy of our statistical approach, we compare our
technique with the probabilistic model checking technique on two examples:
crowds protocol and dining crypotgrapher's protocol.","A number of randomized protocols have been proposed to ensur e the secrecy of certain facts which must not be disclosed while some consequences of these facts have to be made observable. There could be several motivations for this secrecy such as individual p rivacy expectations or negotiations among mutually untrusted parties. For example, a voting machine w ould be expected to retain the anonymity of the voter while recording his vote and hence, the vote reco rding protocol would do some periodic random reordering of votes. Other more involved examples of randomized protocols are contractsigning protocol, privacypreservingauction protocol andcrowds protocol for routingmessages. These protocols achieve this hiding of secret information by using randomiz ation to obfuscate the relation between the secret data and the observable data. The goal of these protoc ols is to make it diﬃcult for an attacker to learn the secret from the observable data. Since the correctness of security protocols is veryimporta nt, formal veriﬁcation of security protocols has been widely studied in literature. Deterministic protocol s can be modeled as labeled transition systems and formal techniques such as model checking can be used for s tate exploration to verify properties expressed in temporal logic. Randomized security protocol s can be modeled as discrete time Markov chains (DTMCs) or Markov decision processes (MDPs) and prob abilistic model checking techniques can be used to verify properties expressed in stochastic tempor al logic which is temporal logic augmented with probabilities. A key issue with these randomized protocols is that their imp lementations can be imperfect. For ex ample, in the Dining Cryptographers protocol [10], the coins being used by the cryptographers might be biased which might reveal probabilistic information abo ut which cryptographer paid. Another ex ample is that in the Crowds Protocol [18], the crowd might be infested by moleswhich provide their observation to the adversary. This might be used by an advers ary to guess the sender of a message with greater accuracy. The goal of this project is to develop a statistical techniqu e for analyzing the protocol implementa tions and quantifying the anonymity loss. While trying to va lidate the implementation of the security protocols, we make the following assumptions.1. The implementation is not created in an hostile environme nt and any implementation error is only an unintended bug such as use of poor pseudorandom generato rs. If the implementation is hostile, it can contain bugs which can not be easily detected by random sampling. For example: a crowds protocol implementation which would fail to anonymize for a particular path would not necessarily be detected as erroneous by our technique. 2. The implementation might have other vulnerabilities whi ch make it possible to compromise it. Our analysis is limited to secrecy guarantees provided by the im plementation and not to whether it is vulnerable to attacks. 3. The quality of the source of randomization while testing i s thesameas when the implementation is deployed. If the source of randomization deteriorates and b ecomes more deterministic, the secrecy guarantees checked during testing will no longer hold true. We assume that the implementation of the protocol is provide d to us as a blackbox. The reason we consider the implementation as a black box is because unlike protocols which are public, implementa tions could be an executable binary or a hardware implementa tion or an IP core and we would be able to check the implementation’s correctness only by observin g its inputs and outputs. Our approach to learn probabilistic dependencies is inspir ed from the work in reverse engineering genetic networks [17,14,21] where a similar problem exists . Molecular and cellular processes form com plex stochastic feedback networks where the regulatory mol ecules that control expression of genes are themselves controlled by other genes. Hence, an important p roblem is to reconstruct functional net work architectures from the observed time series of gene exp ression data. This requires discovering probabilistic dependencies among the diﬀerent genes. In ve rifying an implementation of a randomized protocol, we can obtain a number of sample traces (over both s ecret and observed values) of its working, and then use that to construct dependency of observed values from secret values. Once the probabilistic dependency of the observable values on the secret data has been learnt statisti cally from the traces of the randomized protocol implementa tion, the task of measuring the information leaked by the security protocol is similar to the channel cap acity estimation problem. We compare the estimates obtained by our technique with that from probabil istic model checking to validate its accu racy. We use the two examples1used in [5]  dining cryptographers and crowds for compariso n. The novel contributions made in this paper are  1. This is a ﬁrst completely statistical approach to verifyi ng probabilistic security protocols and does not require any modeling of protocol as DTMC or MDP. This tech nique requires only sampling over the traces obtained by running the protocol implementa tion. We are not aware of any existing blackbox testing approach for verifying security protoco ls. 2. We experimentally compare our technique with probabilis tic model checking. The rest of the paper is organized as follows. In Section 2, we discuss related works. We present our statistical approach in Section 3. The experimental analys is of our approach is presented in Section 4. We mention some limitations of our work in Section 5 and concl ude by identifying some future work in Section 6. 2 Related Works "
422,Derivation of Network Reprogramming Protocol with Z3.txt,"Networks protocols are the heart of communication networks. An efficient
network protocol does maximum utilization of the underlying network
capabilities. Network Protocol synthesis is the process of synthesizing or
deriving network specific protocols from the requirements of a given specific
network. In this report, we present a step-by-step approach for the automated
synthesis of network protocols from the network specifications. Using SMT
solvers to automate the protocol generation is the key idea behind the
presented synthesis approach. The protocols generated using this approach
followed the most optimal way of data transmission for the given network
requirements.","Communication in any given network is guided and con trolled by the protocol speciﬁed for that network, which are a set of rules, procedures and formats that any device in that network is required to comply. In other words, every network has its own set of requirements, and at any point in time every component of the network follows or acts as per a speciﬁc manual that helps satisfy these requirements. Given the network requirements, the goal of this project is to automate the generation of such a manual from those require ments. This process of generating or synthesizing the network protocol from the network requirements is called protocol synthesis. With several existing network protocols already available, generating an entirely new protocol for a network may seem inessential. However, generating or synthesizing network speciﬁc protocols has its own advantages. Especially, the problem with existing protocols is that they focus on optimizing only one or two resources. For example, protocols like Ad hoc OnDemand Distance Vector [1], Dynamic Source Routing in Ad Hoc Wireless Networks [2], Adaptive Distance Vector [3], Destinationsequenced distancevector routing [4], DREAM [5] (Position Based Routing), LAR [6] (Position Based Routing), etc., focus on performing routing in such a way that routes span minimal distance or are computed dynamically based on the current location of destination node. However, when communicating between two devices distance is not the only requirement that needs to be minimized. There are several other features like data rate, bandwidth, power, loss Fig. 1. Hybrid Network Example rate, etc., that may have to be considered as the requirements of a given network. So using existing protocols may not be the best solution when networks have wide variety of requirements. This calls for the need for customized network protocols that take into consideration several types of network requirements. For instance consider the simple real world scenario shown in ﬁgure II. A,B,C,D,Eare nodes in the given home/ofﬁce network. Nodes B,C,Eare connected wireless to the other devices in the network, denoted by dotted lines, and nodes AandDare connected wirelessly. Node Ahas unlimited power, whereas nodes BandCrun on battery. Node Bis closer to node Cthan node A, and similarly the distance between nodes CandAis more than the distance between nodes CandB. Now in such a network, if one chooses to use distance based protocols like AODV , ADV or DSDV , route BtoCwould be preferred for data transmission than the route or link between nodes BandAsince Bis closer to Cthan to A. However, since Ahas higher power capability it would be better for Bto acquire/transmit data to Arather thanCsince Chas limited power which could be saved or utilized for several other critical tasks. One possible solution to this problem could be the use of energy efﬁcient network protocols like [7], [8], [9]. But problem lies in the fact that distance and power are not the only requirements that have to be considered in any given network. For example in the same network let node Bbe a security device that performs intruder sensing and triggers an alarm when needed, and let node Cbe a video monitoring device. In this scenario the requirement ofarXiv:1709.06604v1  [cs.DC]  19 Sep 2017Fig. 2. SMT Solver outline Fig. 3. SMT Solver with network requirements as input node Bis low latency where as with node Cthe requirement is high bandwidth and low jitter. So a network protocol that is tailored to the various aspects of this network is required. Moreover, customized protocols achieve maximum utilization of the underlying network capabilities, which is not guaranteed by the existing general purpose protocols. Satisﬁability Modulo Theorem (SMT) Solvers [10] have proven to be a blessing to mathematicians and computer sci entists in the past few decades. They are useful for automated veriﬁcation of programs, proving correctness of programs, symbolic execution based software testing, and for synthesis [11]. Given a set of logical formulas as input, SMT solvers answer the decision problem that if the given set of logical formulas (that may share common variables) are satisﬁable, i.e., if there exists some set of values for the variables included in the formulas such that the logical formulas always evaluate to true. If the provided logical formulas are satisﬁable, then the solver provides values (or range of values) that satisfy the given formulas. If the provided logical formulas are not satisﬁable, then the solver provides counter examples or indicates aspects that refrain the formulas from being satisﬁed. These input formulas are also called assertions or constraints that need to hold at all times. The satisfying values returned by the solver when the given formulas are satisﬁable are also called models. Z3 [12] is one of the most widely used SMT solvers developed at Microsoft Research and has been an essential part of several research works in cloud computing [13], networking [14],[15], model checking, etc. As mentioned in the previous paragraph SMT solvers are used for synthesis, and since Z3 has proven to be useful in research in networking, we use Z3 in this project to automate the process of protocol synthesis. The assertions or logical formulas provided as input to the SMT Solver Z3 are the network requirements as shown in II. If the provided network requirements are satisﬁable then Z3 provides a model which corresponds to the desired network protocol. By following this approach network protocols for broadcasting in shared channel network, and for data transmission in a simple neighborhood based network were generated. The generated data transmission protocols were simulated in NS3 and com pared with slightly modiﬁed versions of an existing wireless protocol in NS3 with wiﬁ nodes based on CSMA to evaluate its performance. Organization of the paper. The rest of the report is Fig. 4. Ordering Tree Example [16] Fig. 5. Corresponding CCS notation [16] organized as follows: in section II we will discuss some of the existing research performed on the topic of protocol synthesis. In section III we brieﬂy introduce the methods used in the project for synthesizing network protocols. In section IV we will provide further design details of the method used for synthesis. In section V we discuss the results obtained such as the network protocols generated and their simulation results in the network simulator. In section VI we consider some extended research ideas and methods to overcome the shortcomings of the currently used methods and methods to widen their applicability. Finally, in VII we provide the overall project summary and state some lessons learnt during the course of this project. III. R ELATED WORK "
150,Enhancing Routing Security in IoT: Performance Evaluation of RPL Secure Mode under Attacks.txt,"As the Routing Protocol for Low Power and Lossy Networks (RPL) became the
standard for routing in the Internet of Things (IoT) networks, many researchers
had investigated the security aspects of this protocol. However, no work (to
the best of our knowledge) has investigated the use of the security mechanisms
included in RPL standard, mainly because there was no implementation for these
features in any IoT operating systems yet. A partial implementation of RPL
security mechanisms was presented recently for the Contiki operating system (by
Perazzo et al.), which provided us with an opportunity to examine RPL security
mechanisms. In this paper, we investigate the effects and challenges of using
RPL security mechanisms under common routing attacks. First, a comparison of
RPL performance, with and without its security mechanisms, under four routing
attacks (Blackhole, Selective-Forward, Neighbor, and Wormhole attacks) is
conducted using several metrics (e.g., average data packet delivery rate,
average data packet delay, average power consumption, etc.). This comparison is
performed using two commonly used Radio Duty-Cycle protocols. Secondly, and
based on the observations from this comparison, we propose two techniques that
could reduce the effects of such attacks, without having added security
mechanisms for RPL. An evaluation of these techniques shows improved
performance of RPL under the investigated attacks, except for the Wormhole
attack.","Routing is one of the most researched ﬁelds in the world of IoT, due to the constraint nature of these devices. Introduced by Internet Engineering Task Force (IETF), RPL [1] had become the standard for routing in many IoT networks as it was designed to efﬁciently use the constrained resources of IoT devices, while providing effective routing services. Routing security was an integral part of RPL’s design with several, but optional, security mechanisms available [1]. Since it became a standard in 2012, RPL gained a great deal of research interest, with many of the literature focus ing on the security aspects of routing using the protocol, such as types of routing attacks, new mitigation methods and Intrusion Detection Systems (IDSs), and securityminded Objective Functions (OFs) [2]–[6]. Interestingly, there has been no research discussing the effects of using RPL’s security mechanisms, speciﬁcally under routing attacks. This is most probably due to the lack of implementation of RPL’s security A. Raoof and C. Lung are with the Department of Systems and Computer Engineering, Faculty of Engineering and Design, Carleton University, Ottawa, ON, Canada (email: ahmed.raoof@carleton.ca; chlung@sce.carleton.ca) A. Matrawy is with the School of Information Technology, Carleton University, Ottawa, ON, Canada (email: ashraf.matrawy@carleton.ca)mechanisms in any of the available IoT Operating Systems (OSs), such as Contiki OS [7] and TinyOS [8]. However, recently Perazzo et al. in [9] provided a partial implementation of RPL’s security mechanisms for Contiki OS, which added Preinstalled Secure Mode (PSM) and the optional replay protection mechanism. This implementation provided us with the basis upon which the work in this paper is built on. In this paper, we have experimentally investigated RPL’s performance under four common routing attacks using several metrics to analyze and compare the performance between having RPL’s security mechanisms enabled or disabled. The work in this paper provides a signiﬁcant extension to our previous conference paper [10]. Speciﬁcally, we ﬁrst introduced a new scenario for an RPL Wormhole attack to the evaluation. Then, we extended the evaluation of RPL’s performance from using one Radio DutyCycle (RDC) proto col (the ContikiMAC protocol) to include the effect of using another commonly used RDC protocol, namely the NullRDC protocol  see §IVD. Finally, for the two techniques we proposed in [10] to improve RPL’s performance under the investigated attack, we conducted an extensive evaluation of these two techniques and their effects on RPL’s performance under the investigated attacks and using the two underlying RDC protocols. Our contributions can be summarized as follows: Through more than a thousand experiments, we provided a performance comparison for RPL between the Unse cured Mode (UM) and PSM; the latter is examined with and without the optional replay protection. We showed that running RPL in PSM (without replay protection) does not use more resources than UM, even under an attack. We veriﬁed that RPL in PSM can stop external adver saries from joining the IoT network for the investigated attacks, except for the Wormhole attack. Furthermore, we showed that the optional replay protection also provides excellent mitigation against the Neighbor attack. How ever, it needs further optimization to reduce its effect on energy consumption. We observed and analyzed the effect of the investigated attacks on the routing topology and proposed two simple techniques that could help reduce the effects of the inves tigated attacks, without using external security measures such as IDSs or added security mechanisms. Another performance comparison of the implementation of the proposed techniques was conducted. The results showed improved performance of RPL under the Black hole and SelectiveForward attacks, in terms of packet delivery rate (PDR) and endtoend (E2E) latency.arXiv:2004.07815v2  [cs.NI]  11 Jul 2020IEEE INTERNET OF THINGS, VOL. XX, NO. X, XXX 2020 2 The rest of this paper goes as follows: Section II looks into the related works. In section III an overview of RPL and its security mechanisms is presented. Section IV discusses our evaluation methodology, setup, assumptions, adversary model, and attack scenarios. Evaluation results are analyzed in section V. Section VI discuses our observations from the results and proposes two suggestions to be used when designing RPLbased IoT networks. In addition, an implementation of the proposed suggestions is evaluated and the results are discussed. Finally, our work is concluded in VII. II. R ELATED WORKS "
248,Dynamic Packet Scheduling in Wireless Networks.txt,"We consider protocols that serve communication requests arising over time in
a wireless network that is subject to interference. Unlike previous approaches,
we take the geometry of the network and power control into account, both
allowing to increase the network's performance significantly. We introduce a
stochastic and an adversarial model to bound the packet injection. Although
taken as the primary motivation, this approach is not only suitable for models
based on the signal-to-interference-plus-noise ratio (SINR). It also covers
virtually all other common interference models, for example the multiple-access
channel, the radio-network model, the protocol model, and distance-2 matching.
Packet-routing networks allowing each edge or each node to transmit or receive
one packet at a time can be modeled as well.
  Starting from algorithms for the respective scheduling problem with static
transmission requests, we build distributed stable protocols. This is more
involved than in previous, similar approaches because the algorithms we
consider do not necessarily scale linearly when scaling the input instance. We
can guarantee a throughput that is as large as the one of the original static
algorithm. In particular, for SINR models the competitive ratios of the
protocol in comparison to optimal ones in the respective model are between
constant and O(log^2 m) for a network of size m.","In order to exploit the full potential of wireless communica tion, it is crucial to suitably deal with the eﬀect of interference, being one of the main limits of a wirel ess network’s performance. Simultaneous transmissions may collide but only if they are not far enough apart. So in order to utilize the available time as eﬃcient as possible, parallel communication has to b e going on in spite of interference. In recent time, the resulting algorithmic problems have attained muc h interest, particularly the ones in the SINR model. Here, interference constraints are modeled much mor e realistically than in conventional models derived from graph theory. The SINR model takes accumulatio n of interference into account and allows to consider the eﬀects of power control. That is, for each tra nsmission an individual power can be selected. This technology has been shown to have a giant impa ct on the network’s performance in theory as well as in practice. So far, algorithmic studies in the SIN R model have mainly considered problems of the following ﬂavor. Given a set of ntransmission requests, compute a schedule of minimum lengt h such that all transmissions can be carried out successfully , possibly with the freedom of selecting the transmission powers. Although algorithmically challengi ng, this is a very limited view as it does not take into consideration that transmission requests actually ar ise over time. For communication requests arriving in a network by adversa rial injection or a stochastic process over time, algorithmic research has mainly considered two s cenarios. In packetrouting networks the focus lies on multihop communication in a wireline network . That is, packets have to use intermediate nodes until reaching their target node. The restriction is t hat on each communication link only a single packet may be transmitted in a time slot. In scheduling probl ems on a multipleaccess channel , a number of users have to share a channel but only one user can successf ully transmit over the channel at a time. Although both approaches have also been applied in the context of wireless networks, they do not account for the geometry of the network. Packet routing n etworks neglect all eﬀects of interference between communication links. In contrast, the multipleac cesschannel model overestimates interference as it does not take the locality of interference into conside ration. In this paper, we aim at bridging the gap between these diﬀere nt settings. We consider a general model for dynamic packet injection that allows to take the as pects of interference into consideration. For example, this includes the mentioned advantages of the S INR model such as the spatial separation of transmission but also diﬀerent transmission powers and t he fact if transmission powers are ﬁxed or can be chosen by the protocol. In order to cover these diﬀeren t variants, our approach is quite general. Although the SINR model was the primary motivation, this has the interesting consequence that virtually all interference models are covered, such as the multiplea ccess channel, the radionetwork model, the protocol model, and distance2 matching. Furthermore pack etrouting networks allowing that each edge or each node transmits or receives one packet at a time can be m odeled as well. We study stable scheduling protocols. That is, the expected time for each pa cket from injection until delivery (latency) is bounded. Our objective is to build pro tocols of maximal throughput that guarantee stability. In order to express this performance, we say that a protocol is γcompetitive if the following holds. Assuming that there is some way an optimal protocol co uld serve all arising transmission requests, our protocol would be able to do so as well if time was stretche d by the factor γ. Technically, we consider transmission requests arising from stochastic and adversa rial injection. In the stochastic model, the injection by a ﬁnite number of independent users has to be a co nvex combination of feasible sets, scaled by factorγ. In addition to that, we adapt the popular model of a window ad versary. During each interval of lengthw, the adversary may only inject packets that could be served i n that time, scaled by γ. We make use of the results for scheduling static transmissio n requests by giving a blackbox trans formation to the dynamic model. For a number of algorithms, t he exact throughput bound can be transferred to the dynamic case. Using comparisons to the op timal static schedule length, this yields competitive ratios that are as good as the approximation fac tor of the static algorithms. 11.1 Our Contribution We introduce a model for adversarial and stochastic packet i njection in a wireless network that is suitable for SINR models. Like in a packetrouting network, injected packets may have to use intermediate nodes in order to reach the ﬁnal destination. For this purpose, the network nodes correspond to vertices of a graph that are connected by an edge if a transmission can take place between them. Due to the diversity in assumptions, we model the aspects of interference in a gen eric and abstract way. We choose a suitable matrixWquantifying the relative amount of interference of one edge on another one. Based on this matrix, we deﬁne an adversarial and a stochastic injection m odel, limiting the average amount of packets injected per time slot by the injection rate ρas follows. If F(e) is the average number of packets using edgeethen each entry of the vector W·Fhas to be bounded by ρ. The deﬁnition is motivated by linear interference measures for the SINR model. Consider a static singlehop instance in which npackets have to be transmitted from their sender to the respe ctive receiver, the interference measure deﬁned by the matrix Wis given as I= maxe∈E/summationtext e′∈EWe,e′R(e′). Here,R(e) denotes the number of packets that have to be transmitted via the edgee. Examples of existing static scheduling algorithms generate schedules of length O(I·logn) orO(I+ log2n) with high probability for the respective interference measure I. In related work [23, 36, 39] typically a protocol for dynamic injection is built by repeatedly running a static algorithm for a suitably long time. In our case this do es not have the desired eﬀect in general. For example, when scaling the number of communication requests per edge, an O(I·logn) schedule length increases superlinearly since both Iandnincrease. Thus, having more packets the throughput decreas es. In order to deal with this problem we show in the ﬁrst step how t o transform these algorithms to ones that are suitable for dense instances. We exploit the fact that th ere are only mpossible communication links. This allows us to improve the scaling behavior of an algorith m computing schedules of length O(f(n)·I) with high probability to O(f(m)·I+g(m,n)), wheref(m) only depends on the network size and g(m,n) grows sublinearily in n. The algorithms resulting from the ﬁrst transformation are s uitable to be used in the dynamic scenario. Here, we divide time into suﬃciently long time frames. In eac h of them, the static algorithm is executed with the intention that each injected packet is transmitted via one hop in each time frame. However, packets may fail due to too many injected packets or collisio ns in the algorithm. These packets are treated by separate executions of the algorithm. This proto col is shown to be stable for injection rates corresponding to the throughput of the respective static al gorithm. As a result, we obtain the static approximation factor as the competitive ratio. In particul ar, for the SINR model we achieve competitive ratios between constants and O(log2m). The expected latency of a packet is also shown to be poly logarithmic in the size of the network. Depending on the properties of the algorithm, we obtain a dis tributed protocol. In order to run the transformation, the network nodes only need the knowledge o f a global clock, and the size of the network, the injection rate and (for the case of adversarial injectio n) the window size. It is reasonable that this information is available to each network node as it is static , that is, it does not depend on the packet injections and can be set at the deployment time. Furthermor e, we show that being aware of a global clock is inevitable. When assuming only local clocks, no pro tocol for the SINR model with uniform transmission powers can be m/2 lnmcompetitive. Achieving O(m)competitiveness is trivial by falling back to the multipleaccess channel model. 1.2 Related Work "
242,Fuzzy informer homed routing protocol for wireless sensor network.txt,"A wireless sensor network consists of several sensor nodes. Sensor nodes
collaborate to collect meaningful environmental information and send them to
the base station. During these processes, nodes are prone to failure, due to
the energy depletion, hardware or software failure, etc. Therefore, fault
tolerance and energy efficiency are two important objectives for reliable
packet delivery. To address these objectives a novel method called fuzzy
informer homed routing protocol is introduced. The proposed method tries to
distribute the workload between every sensor node. A fuzzy logic approach is
used to handle uncertainties in cluster head communication range estimation.
The simulation results show that the proposed method can significantly reduce
energy consumption as compared with IHR and DHR protocols. Furthermore, results
revealed that it performs better than IHR and DHR protocols in terms of first
node dead and half of the nodes alive, throughput and total remaining energy.
It is concluded that the proposed protocol is a stable and energy efficient
fault tolerance algorithm for wireless sensor networks.","  A wireless sensor network (WSN) is a selfconfigure d or selforganized network. It contains a  collection of small, low powered sensor nodes with limited transmission range and the base  station or sink [1, 2]. Sensor nodes in wireless se nsor networks are prone to failure because of  hardware and software failures, instability of comm unication link, battery depletion, dislocation,  etc. Therefore, there is a needfor an efficient fau lt tolerance mechanism to manage or identify the  fault and take appropriate action while it occurs [ 3]. A collector node has restricted capability in   sensing and collecting meaningful environment infor mation within its range. It generally transfers  the sensed and collected data to the base station. The sensor nodes consume energy while sensing,  processing, receiving and transferring data [4]. In  the majority of cases, they have the same amount  of energy which is not replaceable [5] or replacing  the battery is impossible [6, 7]. Hence, energy  efficiency is an important design objective in a wi reless sensor network.    To aggregate and transmit sensed data through effic ient manner, the network can be clustered or  partitioned into the number of clusters. Each clust er in the network has a cluster head. It generally  receives the sensed data from cluster members then aggregates and transmits to the base station International Journal of Computer Networks & Commun ications (IJCNC) Vol.11, No.4, July 2019    44  [8].In the clustering manner, selection of a suitab le cluster head is very important, it can reduce  energy depletion of sensor nodes and increase the l ifetime of the wireless sensor network [9, 13].   Generally, clustering procedures utilize two method s, electing cluster heads with higher  remaining energy and revolving them periodically to  balance energy depletion of the sensor nodes  all over the network for prolonging the network lif etime.    Utilizing intelligent methods improve the efficienc y of wireless sensor network [10]. As an  intelligent technique, fuzzy logic is the most powe rful tool that can be used for clustering  procedure. In a wireless sensor network, it can be used to select suitable cluster heads [9, 11].  Fuzzy logic has several advantages over traditional  methods for instant, design time,  computational complexity and development cost are l ow and it is more flexible [12].Sointhis  paper, a novel fault tolerance algorithm named Fuzz y Informer Homed Routing (FIHR) protocol  is introduced and simulated for wireless sensor net works using fuzzy logic. It is derived from the  Informer Homed Routing (IHR) protocol [13] and Dual Homed fault tolerant Routing (DHR)  protocol [14]. Clustering procedure in IHR and DHR protocols is based on a probabilistic model  same as LEACH protocol. Moreover, it is probable th at some cluster heads are located in a  particular zone. It means that primary cluster head s are not picked out in a distributed manner.  The proposed FIHR is a distributed competitive clus ter head selection with fault tolerance  algorithm. The proposed method efforts on allocatin g suitable communication range to the tentative  primary cluster heads. To make wise decisions to se lect primary cluster heads (PCHs), the  introduced FIHR method employs fuzzy logic inferenc e system and uses the distance to the base  station and the remaining energy of available senso r nodes during simulation time. Furthermore,  each primary cluster head will choose the nonclust er head locally with the higher energy left as its  backup cluster head (BCH). To achieve fault toleran ce, every BCH will control the aliveness of  relevant PCH based on the beacon message it receive s from its PCH in each round.    We compare the effectiveness of FIHR protocol with IHR and DHR protocols in terms of first  node dead, half of the nodes alive and total residu al energy level of the network at various rounds.  The results show that the proposed FIHR protocol ou tperforms IHR and DHR protocols. It is  concluded that the suggested FIHR protocol is stabl e as well as energy efficient fault tolerance  protocol for WSNs.    The rest of this article is organized as follows: S ection 2 is about related works, in section 3  Preliminaries will be discussed, in section 4 the p roposed FIHR protocol will be introduced, in  section 5 clustering with fuzzy logic system will b e discussed, section 6 is about simulation  results and discussions, and finally we conclude th e paper in section 7.    2.  RELATED WORK   "
415,Contention Based Routing in Mobile Ad Hoc Networks with Multiple Copies.txt,"Routing the packets efficiently in mobile ad hoc network does not have end to
end paths. Multiple copies are forwarded from the source to the destination. To
deal with such networks, researches introduced flooding based routing schemes
which leads to high probability of delivery. But the flooding based routing
schemes suffered with contention and large delays. Here the proposed protocol
""Spray Select Focus"", sprays a few message copies into the network, neighbors
receives a copy and by that relay nodes we are choosing the shortest route and
then route that copy towards the destination. Previous works assumption is that
there is no contention and dead ends. But we argue that contention and dead
ends must be considered for finding efficiency in routing. So we are including
a network which has contention and dead ends and we applied the proposed
protocol. We can say that this protocol works well for the contention based
network.","outing efficiently in a mobile ad hoc network does  not have end to end path from the source to the destination. The concept of connected, stable network  over which data can be routed reliably rarely holds there.  In case of wireless signals are subject to multipath propagation, fading and interference making wireless links  unstable and lossy [1]. Additionally, [6] frequent node  mobility significantly reduces the time a good link exists and constantly changes the network connectivity graph.  As a result wireless connectivity is volatile and usually  intermittent and complete endtoend paths will not exist [1]. Tactical networks may also choose to operate in an  intermittent fashion for Low probability of interception  and low probability of detectio n.  Deep space networks  and underwater networks often have to deal with para meters such as long propagation delays and or intermit tent connectivity, as well [8] [9]. These networks are referred to as Delay tolerant networks [10].     These networks can neither make any assumptions  about the existence of a cont emporaneous path to the des tination nor assume accurate knowledge of the destina tion’s location or even addresses.     Under such intermittent connectivity or networks conditions many traditional protocols fail. The biggest chal lenge is that to enable networking in intermittently con nected or mobile network environment is routing.    Conventional internet routing protocols as well as routing  schemes for mobile ad hoc ne tworks assume that a com plete path exists between a source and a destination and  try to discover these paths before any useful data is sent.  Thus if no endtoend paths exist most of the time, these protocols fail to deliver any data to all but the few con nected nodes.       However this does not mean that packets can never be delivered in these networks. In mobility assisted routing  [6] a message could be sent over an existing link, get buf fered at the next hop until the next link in the path comes up and so on and so forth, un til it reaches its destination.  The utilitybased flooding scheme is quite fast in some  scenarios, the overhead involv ed in terms of bandwidth,  buffer space, and energy dissipation is often prohibitive  for small wireless devices. In  multicopy scheme, more  than one copy per message was used and in singlecopy scheme only route one copy per message can considera bly reduce resource waste. So  no routing scheme for in termittently connected environments currently exists that can achieve both small delays and prudent usage of the  network and node resources.     The problem of contention in the network and dead ends are not concentrated in the previous works. But we  say that contention and dead ends are important factors  to be considered. Ignoring contention and dead ends will give inaccurate results [9].      For this reason the implementation  of multi‐copy  protocols  called Spray routing is introduced  [2] by con‐ sidering contention  and dead ends in the network.           R  © 2010 Journal of Computing http://sites.google.com/site/journalofcomputing/ ————————————————    E.Jenefa JebaJothi is with the Department of Computer Science and Engi neering, Anna University Tirunelv eli, Tirunelveli, Tamilnadu.    Dr. V. Kavitha is with the Department of Computer Science and Engineer ing, Anna University Tirunelv eli, Tirunelveli, Tamilnadu.    T.Kavitha  is with the  Department  of Computer Science and Engineering,  Anna University Tirunelveli,  Tirunelveli, Tamilnadu.       15   2 R ELATED WORK  "
425,Finding Top-k Optimal Sequenced Routes -- Full Version.txt,"Motivated by many practical applications in logistics and
mobility-as-a-service, we study the top-k optimal sequenced routes (KOSR)
querying on large, general graphs where the edge weights may not satisfy the
triangle inequality, e.g., road network graphs with travel times as edge
weights. The KOSR querying strives to find the top-k optimal routes (i.e., with
the top-k minimal total costs) from a given source to a given destination,
which must visit a number of vertices with specific vertex categories (e.g.,
gas stations, restaurants, and shopping malls) in a particular order (e.g.,
visiting gas stations before restaurants and then shopping malls).
  To efficiently find the top-k optimal sequenced routes, we propose two
algorithms PruningKOSR and StarKOSR. In PruningKOSR, we define a dominance
relationship between two partially-explored routes. The partially-explored
routes that can be dominated by other partially-explored routes are postponed
being extended, which leads to a smaller searching space and thus improves
efficiency. In StarKOSR, we further improve the efficiency by extending routes
in an A* manner. With the help of a judiciously designed heuristic estimation
that works for general graphs, the cost of partially explored routes to the
destination can be estimated such that the qualified complete routes can be
found early. In addition, we demonstrate the high extensibility of the proposed
algorithms by incorporating Hop Labeling, an effective label indexing technique
for shortest path queries, to further improve efficiency. Extensive experiments
on multiple real-world graphs demonstrate that the proposed methods
significantly outperform the baseline method. Furthermore, when k=1, StarKOSR
also outperforms the state-of-the-art method for the optimal sequenced route
queries.","Optimal sequenced route (OSR) querying [32], [33], a.k.a., generalized shortest path querying [29], aims at ﬁnding a ro ute with minimum total cost (e.g., travel distance or travel tim e), passing through a number of vertex categories (e.g., restau r ants, banks, gas stations) in a particular order (e.g., visi ting banks before restaurants). This problem has many practical applications in route planing [14], [19], crisis managemen t, supply chain management, video surveillance, mobilityas a service [13], and logistics [29], [32]. However, it is often the case that the optimal sequenced route with the minimum total cost may not be the best choice for all users since different users may have different personal preferences [10], [28], [ 36]. Consider the example shown in Figure 1, where a vertex represents a pointofinterest and is associated with a cat egory, e.g., shopping mall ( MA), restaurant ( RE), or cinema ( CI)a (MA)  c (MA) b (RE)  d (CI) e (RE)  f (CI)  ts856 3 5 35 10 43 10 10  3 15  Figure 1. A road network graph G and edge weights represent travel costs, e.g., travel time o r fuel consumption. Suppose that Alice plans a trip which star ts from location sand wishes passing through a shopping mall, a restaurant, and then a cinema and ﬁnally reaching destinati ont. This plan can be formalized with an OSR query with category sequence/an}bracketle{tMA,RE,CI/an}bracketri}ht. The optimal sequenced route for Alice is s→a→b→d→twith a cost of 20. However, if Alice prefers restaurant eto restaurant b, route s→a→e→d→twith a cost of 21 is more preferable. In addition, if the shopping mall at vertex chas sale promotions, routes→c→b→d→twith a cost of 22 can also be a good candidate. In these cases, returning only the optimal seque nced route may not sufﬁciently satisfy users’ varying preferenc es. This motivates us to study the top koptimal sequenced routes (KOSR) querying that returns kroutes that satisfy the given category order and have the kleast total costs. In this paper, we focus on ﬁnding the top koptimal se quenced routes in general graphs, where edge weights may not satisfy triangle inequality. Unfortunately, the KOSR prob lem on general graphs has not been addressed carefully before, though the OSR problem has been extensively studied. In [32], the progressive neighbor exploration algorithm PNE is proposed to solve the OSR problem on general graphs. In [29], a dynamic programming based algorithm GSP is formulated, which outperforms PNE signiﬁcantly and is considered as the stateoftheart for solving the OSR problem on general gra phs. However, by simply extending existing solutions for the OSR problem, it is unlikely, if it is not impossible, to achie ve efﬁcient solutions for the KOSR problem. In particular, dy namic programming based GSP is unable to be extended to solve the KOSR problem due to lack of sufﬁcient information for other sequenced routes. Although PNE can be extended to handle the KOSR problem by iteratively ﬁnding the next optimal sequenced route, the efﬁciency is low since all part ially explored sequenced routes whose costs are less than the cost of thekth optimal sequenced route must be examined, whereasmost of them can be avoided being extended. It is nontrivial to devise an efﬁcient solution for solving KOSR due to two challenges. The ﬁrst is how to ﬁlter un necessary partially explored sequenced routes when explor ing the graph. To conquer this challenge, we propose a dominance relationship between two partially explored sequenced rou tesr andr′. Ifrdominates r′, the optimal (i.e., leastcost) feasible sequenced route extended from ris always better than that ofr′. Thus, the exploring of routes that are extended from r′ can be postponed until a complete sequenced route extended fromroccurs in the result set. Furthermore, inspired by A∗ algorithm [21], we estimate the cost of each partially explo red sequenced route to the destination, and explore the partial ly explored routes according to their estimated total costs, w hich further reduces the searching space. The second challenge is how to efﬁciently ﬁnd the ith nearest, not merely the nearest, neighbor in a category, as this operation is invoked frequently when solving KOSR. For example, recall that we may want to recommend the top3 optimal sequenced routes to Alice in Figure 1. More than one nearest neighbors in category MA for vertex s, i.e.,aandc, are required to be explored. A simple and intuitive implementat ion of the operation is to apply Dijkstra’s algorithm, which is however very costly. To overcome this weakness, we build an inverted label index for each category by employing hop labeling technique [1], [2], [4], [5], [9] on the original gr aph in an offline manner. In this way, the ith nearest neighbor in a category can be identiﬁed efﬁciently in an online manner by simply looking up the inverted label index. To the best of our knowledge, this is the ﬁrst compre hensive work to study the KOSR problem. The paper makes four contributions. First, we propose a dominance relation ship between partially explored sequenced routes and develop an algorithm based on the dominance relationship to reduce the searching space signiﬁcantly when solving the KOSR problem . Second, we propose a heuristic method that is able to estimat e the minimal total cost of partially explored sequenced rout es, which enables the develop of an A∗like algorithm to further reduce the searching space for solving the KOSR problem. Third, we propose an inverted label index which facilitates the operation that identiﬁes the ith nearest neighbor in a category for a given vertex, which improves the efﬁciency of both algorithms. Finally, we report on a comprehensive empirical study over different realworld graphs, showing that the proposed algorithms signiﬁcantly outperform the basel ine method for KOSR and the stateoftheart method for OSR. II. R ELATED WORK "
255,PIS: A Multi-dimensional Routing Protocol for Socially-aware Networking.txt,"Socially-aware networking is an emerging paradigm for intermittently
connected networks consisting of mobile users with social relationships and
characteristics. In this setting, humans are the main carriers of mobile
devices. Hence, their connections, social features, and behaviors can be
exploited to improve the performance of data forwarding protocols. In this
paper, we first explore the impact of three social features, namely physical
proximity, user interests, and social relationship on users' daily routines.
Then, we propose a multi-dimensional routing protocol called
Proximity-Interest-Social (PIS) protocol in which the three different social
dimensions are integrated into a unified distance function in order to select
optimal intermediate data carriers. PIS protocol utilizes a time slot
management mechanism to discover users' movement similarities in different time
periods during a day. We compare the performance of PIS to Epidemic, PROPHET,
and SimBet routing protocols using SIGCOMM09 and INFOCOM06 data sets. The
experiment results show that PIS outperforms other benchmark routing protocols
with the highest data delivery ratio with a low communication overhead.","TODAY a large volume of mobile data trafﬁc is transferred via 3G cellular networks which make them overloaded. To tackle this problem, proximity based wireless technologies such as Bluetooth and Wi Fi have been used as promising solutions to lighten the network trafﬁc among mobile users. Sociallyaware networking (SAN) [1] is a new trend of delay tolerant networks (DTNs) [2] and opportunistic communications [3][4], which exploits social properties of mobile carrier s (i.e., users) to design efﬁcient networking protocols. In this setting, mobile nodes employ storecarryandforward mechanism to communicate with each other with the help of their shortdistance and lowcost devices in order to share data objects (e.g., pictures, advertisement s, software updates) among interested users. The basic idea of SAN is to exploit the users’ social context information to improve the performance of data routing protocols. To achieve this goal, spatiotemporal and connectivity properties of the mobile users are captured in an efﬁcient way. When a mobile node contacts others, all the encoun tered nodes could be candidates for relaying her mes sages to the destination node. Nevertheless, selecting ap propriate encounter nodes is a very challenging problem. One potential approach is to forward a message to nodes which are closer to the destination (a greedy strategy). In this context, some investigations on human movement patterns have been carried out to explore the spatio F. Xia, L. Liu and B. Jedari are with the School of Software, Da lian University of Technology, China. S. K. Das is with the Computer Science Department, Missouri U niversity of Science and Technology, USA. Corresponding author: Feng Xia; Email: f.xia@ieee.org. Manuscript received XX XX, 2014; revised XX XX, 20XX.temporal properties of mobile users and predict their future contacts [5], [6], [7]. Since the physical location of mobile users vary, more stable social factors should be considered to make efﬁcient and effective routing decisions. To overcome the shortcomings in mobility based routing approaches, several socialaware routing protocols for SAN paradigm have been proposed in the literature (see [8] for a survey). Some recent social aware routing protocols such as [9], [10], [11], [12] make forwarding decisions based on the users’ social char acteristics and similarities. In particular, social netwo rk analysis techniques are used to extract meaningful social relationships among mobile users. The main motivation is that the social behaviors of mobile nodes have long term characteristics, which provide reliable connectivit y among them. In this paper, we take multiple social characteristics of users into consideration to design a stable routing pro tocol in the SAN paradigm. Considering the users’ daily routines, we observe that three social factors namely physical proximity, interests, and social relationship i n ﬂuence the performance of data forwarding. The physical proximity indicates direct contacts among mobile nodes. When two nodes come into the communication range of each other, they can exchange their messages. The physical proximity is a popular factor which is used in many existing routing protocols extensively [9], [13], [14]. The second factor is the user interests which in dicate their preferences for data. Based on Homophily concept [15], individuals with common interests tend to meet each other more often and perform similar actions. Furthermore, their interests are stable for a long time. The third factor is social relationships such as friendship, family, or colleague which describes the users’ personal relations. Nodes with strong social relationships contactIEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. X, NO. X, XX 20XX 2 Fig. 1. Human mobility: regularity and social characteris tics in daily routine. each other more frequently and regularly. Friendship based routing [16] is a wellknown example in this regard which identify the social ties among mobile nodes based on their contact history and thus form social communities. The basic idea of our novel approach lies in the fact that integration of these social attributes can be utilized to improve the overall efﬁciency of a routing protocol since each of these parameters can affect a data delivery protocol in different time periods. For example, One (or more) factors may work in the current time period while others may work in a future time period. It may also be possible that these three factors work simultaneously in some other occasions. We provide an example to illustrate our idea. Let us consider Alice’s regular mobility pattern in different tim e periods during a working day. She takes a bus from 7:30 to 8:30, works between 8:30 and 17:00, goes to a gym to exercise from 17:00 to 19:00, and comes back home at the end of the day. In each time period, different social characteristics are exhibited. Moreover, she could share data with different people such as strangers in a bus (geographic proximity), colleagues in her ofﬁce (colleague relationship), friends (common interests) and family members (family relationship). It is difﬁcult to determine which social characteristic always plays the decisive role throughout the day. Therefore, Alice could select appropriate forwarders by comprehensively fus ing social properties of people around her, as well as temporal dimensions (time regularity). In this paper, we propose a multidimensional rout ing protocol, namely ProximityInterestSocial relation  ship (PIS) protocol for sociallyaware networking (SAN) paradigm. The PIS protocol integrates multiple social dimensions of mobile users in a utility function to select the best intermediate nodes and improve the overall routing performance. In this method, a time slotmanagement mechanism is used to manage the social information of users in different time periods. Our major contributions can be summarized as fol lows: •We analyze real mobility traces of mobile users and explore three social factors: physical proximity, user interests, and social relationships in order to make a stable and adaptable routing protocol in the SAN paradigm. Then, we introduce a multidimensional routing protocol, called PIS protocol based on the social properties of mobile nodes. •Based on the users’ daily routine, we present a time slot management mechanism in PIS to keeptrack of contact records, self/contact interests, and di renct/indirect social relationship information. This mechanism uses the social properties of mobile users in different time slots to reﬂect the movement routines in different time periods. •We apply an efﬁcient copy control mechanism to control data congestion in the PIS protocol and decrease the network overhead. •We compare PIS to three benchmark routing proto cols, Epidemic [17], PROPHET [18], and SimBet [13] using SIGCOMM09 [19] and INFOCOM06 [20] real world traces. The experimental results demonstrate that our protocol guarantee higher performance of routing which achieves the highest data delivery ratio with a low communication overhead. The remainder of this paper is organized as follows. Section II provides a review of related works on SAN. Sections III and IV presents the PIS protocol and its implementation details. Section V describes the perfor mance evaluation results of PIS in comparison with other wellknown routing protocols. Finally, we conclude the paper in Section VI. 2 R ELATED WORK "
461,Scalable Many-Objective Pathfinding Benchmark Suite.txt,"Route planning also known as pathfinding is one of the key elements in
logistics, mobile robotics and other applications, where engineers face many
conflicting objectives. However, most of the current route planning algorithms
consider only up to three objectives. In this paper, we propose a scalable
many-objective benchmark problem covering most of the important features for
routing applications based on real-world data. We define five objective
functions representing distance, traveling time, delays caused by accidents,
and two route specific features such as curvature and elevation. We analyse
several different instances for this test problem and provide their true
Pareto-front to analyse the problem difficulties. We apply three well-known
evolutionary multi-objective algorithms. Since this test benchmark can be
easily transferred to real-world routing problems, we construct a routing
problem from OpenStreetMap data. We evaluate the three optimisation algorithms
and observe that we are able to provide promising results for such a real-world
application. The proposed benchmark represents a scalable many-objective route
planning optimisation problem enabling researchers and engineers to evaluate
their many-objective approaches.","Optimal route planning (or pathﬁnding) is among the most challenging tasks for industrial and logistical applications [1]. Any improvement in the results can have a considerable impact on many factors, such as fuel consumption and the environment. The current stateoftheart route planning al gorithms usually consider the travel time and the distance in the optimisation. However, speciﬁc applications encounter additional criteria such as the curvature of the route, the elevation (ascent), or environmental issues such as air pollution caused by fuel consumption. These criteria can profoundly inﬂuence the practicability of the solutions. For instance, for animal transportation, we need to additionally minimise the number of curves in the route (or maximise the smoothness). Reducing the length of the route can help to reduce fuel consumption, while possibly increasing the travelling time. Other criteria such as the ascent of a path can be considered for heavy vehicles which can consume more fuel on such nonﬂat routes. The goal of this paper is to propose a manyobjective route planing problem representing ﬁve objective functions which at the same time are highly related to their realworld J. Weise and S. Mostaghim are with the Institute for Intelligent Cooper ating Systems, Otto von Guericke University Magdeburg, Germany email: fjens.weise,sanaz.mostaghim g@ovgu.de.counterparts. This realworld problem can be considered as scalable in terms of complexity, since the size of the search space can be varied, inﬂuencing the objective functions as well in terms of search space size. To the best of our knowledge, there is no work in the literature which considers all of these criteria at the same time. Similar to the existing navigation and route planning algorithms, we work on a graphbased approach for addressing this manyobjective problem. We additionally apply the benchmark characteristics to the realworld data from OpenStreetMap in Berlin. Our results show that this problem can be used both as a benchmark and as well as a realworld application. We additionally provide the true Paretofront of 491 benchmark instances, their respective Paretosets and the code to generate speciﬁc instances of the proposed benchmark. The paper is structured as follows. In Section II, we provide an overview of the related works. Section III is dedicated to the manyobjective pathﬁnding problem, the proposed encoding and the objective functions. In section V, we provide ex periments using three stateoftheart optimisation algorithms, and in Section VD, we transfer the benchmark and objective functions to realworld road map data. Section VI concludes the paper and gives an overview of future work. II. R ELATED WORKS "
345,Distributed Robust Geocast Multicast Routing for Inter-Vehicle Communication.txt,"Numerous protocols for geocast have been proposed in literature. It has been
shown that explicit route setup approaches perform poorly with VANETs due to
limited route lifetime and frequent network fragmentation. The broadcast based
approaches have considerable redundancy and add significantly to the overhead
of the protocol. A completely distributed and robust geocast approach is
presented in this paper, that is resilient to frequent topology changes and
network fragmentation. A distance-based backoff algorithm is used to reduce the
number of hops and a novel mechanism to reduce redundant broadcasts is
introduced. The performance of the proposed protocol is evaluated for various
scenarios and compared with simple flooding and a protocol based on explicit
route setup.","Considerable research eﬀort is concentrated on inter vehicle comm unication (IVC), which is expected to make road transport safer and more c omfortable, while reducing travel time. The term vehicular ad hoc networks (VAN ETs) is frequently used for mobile ad hoc networks (MANETs) in the contex t of IVC, highlighting its distinct characteristics. Diﬀerences include, high nod e velocity, constrained mobility (to roads), anonymity of the users, and availa bility of posi tion information through global positioning system (GPS). The high n ode mo bility in a VANET causes frequent changes in the network topology an d the network is subject to frequent fragmentation. Furthermore, t he route lifetime drops to nearly route discovery time for more than a few hops [1]. Giv en these characteristics, it is generally accepted that VANETs should use so me form of geographical routing. Several algorithms that use location inform ation for eﬃ cientroutediscoveryhavebeenproposed[2].Formanyoftheapplic ationsofIVC listed above, especially safety and traﬃc control applications, it is d esirable to send a message to a particular geographic region. The multicast of a message to nodes satisfying a set of geographicalcriteriais called geocast. Severalalgorithms for geocasting have been proposed based on location information [3 ,4]. These algorithms, though distributed compared to other traditional rou ting protocols, require at least some state information, like the knowledge of neighb or nodes.Keepingstateinformationaddsoverheadandconsumesresource slikebandwidth and memory. In this paper we propose Distributed Robust Geocast (DRG), a geo cast ap proach designed for VANETs that is completely distributed, without control overhead and state information and is resilient to frequent topolog y changes. We use a distancebased backoﬀ similar to [5–8] for directed and restr icted ﬂooding. However, unlike [5–8], our approachis not limited to a onedimensional road and a onedimensional target region. We use a stateless forwarding a lgorithm that eﬃciently spreads the message through the target region and ens ures delivery to all relevant nodes. The forwarding algorithm can work for twod imensional street networks as well as onedimensional highways and a target region of any shape. Furthermore, the algorithm is resilient to the underlying rad io transmis sion range model and can work with noncircular transmission range models caused by fading and pathloss. The algorithm can overcome tempor ary network partitioning or temporary lack of relay nodes and has a mechanism to prevent loops. We also show a completely distributed method for keeping a mes sage alive in the target region thereby ensuring that a node entering the reg ion even after the spread of message receives the message. 2 Related Work "
224,Link Capacity Planning for Fault Tolerant Operation in Hybrid SDN_OSPF Networks.txt,"Link capacity dimensioning is the periodic task where ISPs have to make
provisions for sudden traffic bursts and network failures to assure
uninterrupted operations. This provision comes in the form of link working
capacities with noticeable amounts of headroom, i.e., spare capacities that are
used in case of congestions or network failures. Distributed routing protocols
like OSPF provide convergence after network failures and have proven their
reliable operation over decades, but require overprovisioning and headroom of
over 50%. However, SDN has recently been proposed to either replace or work
together with OSPF in routing Internet traffic. This paper addresses the
question of how to robustly dimension the link capacities in emerging hybrid
SDN/OSPF networks. We analyze the networks with various implementations of
hybrid SDN/OSPF control planes, and show that our idea of SDN Partitioning
requires less amounts of spare capacity compared to legacy or other hybrid
SDN/OSPF schemes, outperformed only by a full SDN deployment.","Robust link dimensioning is the periodic task where operators of carrierclass IP networks make provisions for sudden trafﬁc bursts and network failures to assure congestionfree operations. Network operators are re quired to provision – in addition to possibly deployed backup capacities in the physical layer – working capacities with noticeable amounts of headroom , i.e., fractions of the capacities that are unused under nor mal conditions to avoid overutilization (and thus a degradation of network service quality) in case of a network failure. An essential asset for the calcula tion of the required headroom is the exact knowledge about the behavior of the control plane in case of sudden events. In the legacy networks this is Open Shortest Path First (OSPF). Today, more and more efforts concentrate on the socalled hybrid network ing paradigm [1]–[7] combining OSPF with Software Deﬁned Networking (SDN), not the least as it provides advantages of both the legacy and SDNbased routing. In case of failures, distributed routing protocols, like the legacy OSPF, provide an automatic (autonomous and thus not manipulable) routing convergence and have proven their reliable operation over decades, but require signiﬁcant overprovisioning of link capacities(e.g., link utilizations of <50% in the Internet2 back bone [8]). SDN on the other hand provides complete programmability (if desired) that allows for an optimal loadbalancing, which in case of failure would require signiﬁcantly less headroom. Restoration techniques in SDN are to be implemented in the central controller or as an application on top of the controller, like [9]. Therefore, approaches for a hybrid SDN/OSPF control plane appear attractive from the perspective of capac ity headroom: they provide the automatic convergence of OSPF, while requiring potentially less link capacity headroom, like in SDN. What the exact beneﬁts of hybrid networking are for fault tolerance, however, has not been studied yet. In this paper, we analyze the problem precisely, and provide a quantitative comparison focused on headroom requirements for various hybrid networks. We study typical hybrid control planes that follow a ”shipspassinginthenight” strategy, whereby legacy routing and SDN control paradigms are oblivious to what the other one conﬁgures. We additionally con sider our in [10] proposed new scheme for hybrid SDN/OSPF operation called SDN Partitioning , where SDN switches are used as invisible border nodes to partition the OSPF routing domains. In this scheme, SDN nodes appear to their legacy neighbors as regular OSPF routers, while they actually act as simple pro tocol repeaters that forward all OSPF messages to the centralized SDN controller. Based on a new iterative heuristic for faulttolerant capacity planning, we show that hybrid networking in general requires less head room than OSPF. In addition, we show that our idea of SDN Partitioning requires the least amount of spare capacity compared to legacy protocols or other hybrid schemes, outperformed only by full SDN deployment. The rest of the paper is organized as follows: Sec tion II discusses the related work. Section III presents the technological background of hybrid networking. The faulttolerant capacity planning is detailed in Sec tion IV. Our numerical study is presented in Section V and Section VI concludes the paper.arXiv:1604.05534v1  [cs.NI]  19 Apr 2016Sub Domain 1 Sub Domain 2  Sub Domain 3  a b  IP Link   OpenFlow   Switch   OpenFlow   Channel  Central  SDN  Controller   Hybrid  SDN/OSPF  Switch   OSPF   Router  Fig. 1: The architectures of the two analyzed control planes: a) stacked hybrid and b) SDN Partitioning . II. R ELATED WORK AND OURCONTRIBUTION "
196,Transport Capacity of Distributed Wireless CSMA Networks.txt,"In this paper, we study the transport capacity of large multi-hop wireless
CSMA networks. Different from previous studies which rely on the use of
centralized scheduling algorithm and/or centralized routing algorithm to
achieve the optimal capacity scaling law, we show that the optimal capacity
scaling law can be achieved using entirely distributed routing and scheduling
algorithms. Specifically, we consider a network with nodes Poissonly
distributed with unit intensity on a $\sqrt{n}\times\sqrt{n}$ square
$B_{n}\subset\Re^{2}$. Furthermore, each node chooses its destination randomly
and independently and transmits following a CSMA protocol. By resorting to the
percolation theory and by carefully tuning the three controllable parameters in
CSMA protocols, i.e. transmission power, carrier-sensing threshold and
count-down timer, we show that a throughput of
$\Theta\left(\frac{1}{\sqrt{n}}\right)$ is achievable in distributed CSMA
networks. Furthermore, we derive the pre-constant preceding the order of the
transport capacity by giving an upper and a lower bound of the transport
capacity. The tightness of the bounds is validated using simulations.","Wireless multihop networks have been increasingly used in civilian and military applications. In a wireless multihop network, nodes communicate with each other via wireless multihop paths, and packets are forwarded collaboratively hopbyhop by intermediate relay nodes from sources to their respective destinations. Studying the capacity of these networks is an important problem. Capacity of large wireless networks has been extensively investigated with a particular focus on the throughput scal ing laws when the network becomes sufﬁciently large [1]– [11]. Two metrics are widely used in the study of network capacity: transport capacity and transmission capacity. The transport capacity quantiﬁes the endtoend throughput that can be achieved between sourcedestination pairs whereas the transmission capacity, often used together with another metric outage probability, quantiﬁes the achievable singlehop rates in large wireless networks. The transport capacity is useful to capture the impact of network topology, routing and T. Yang is with the School of Electrical and Information Engineering, The University of Sydney. Email: tao.yang@sydney.edu.au. G. Mao is with the School of Computing and Communications and Center for Realtime Information Networks, The University of Technology, Sydney, and National ICT Australia. Email: guoqiang.mao@uts.edu.au. W. Zhang is with the School of Electrical Engineering & Telecommunica tions, The University of New South Wales. Email: wzhang@ee.unsw.edu.au. X. Tao is with National Engineering Lab. for Mobile Network Security, Bei jing University of Posts and Telecommunications. Email: taoxf@bupt.edu.cn. This research is funded by ARC Discovery projects: DP110100538 and DP120102030.scheduling algorithms on network capacity [1]–[6], [8]–[10], [12]–[14]. Comparatively, the transmission capacity is more useful when the focus is on the impact of physical layer details, e.g., fading, interference and signal propagation model, on the capacity of large networks [15]–[19]. In this paper, we focus on the study of the transport capacity. In the groundbreaking work [6] by Gupta and Kumar, it was shown that in a static network of nnodes uniformly and i.i.d. on an area of unit size and each node is capable of transmitting atWbits/second and using a ﬁxed and identical transmission range, the achievable pernode throughput is  Wpnlogn when each node chooses its destination randomly and inde pendently. If nodes are optimally and deterministically placed to maximize capacity, the achievable pernode throughput becomes  Wpn . In a more general setting, assuming only that power attenuates with distance following a powerlaw relationship, Xie and Kumar [11] showed that  1pn is an upper bound on the pernode throughput of wireless net works, regardless of the scheduling and routing algorithm being employed. Since then, a number of solutions have been proposed to achieve the above upper bounds under various network settings and using various routing and scheduling algorithms [1]–[6], [8]–[10], [12]–[14]. In [4], Franceschetti et al. considered the same network as that in [6] except that nodes are allowed to use two different transmission ranges. They showed that by using a routing scheme based on the socalled “highway system” and a centralized/deterministic time division multiple access (TDMA) scheme, the pernode throughput can reach  1pn even when nodes are randomly located. Speciﬁcally, the highway system is formed by nodes using the smaller transmission range, whereas the larger trans mission range is used for the last mile, i.e., between the source (or destination) and its nearest highway node. The existence of highway system was established using the percolation theory. Other work in the ﬁeld includes [5] in which Grossglauser and Tse showed that in mobile networks, by leveraging on the nodes’ mobility, a pernode throughput of  (1) can be achieved at the expense of large delay. Their work [5] has sparked huge interest in studying the capacitydelay tradeoffs in mobile networks assuming various mobility models and the obtained results often vary greatly with the different mobility models being considered, see [20]–[25] and references therein for examples. In [26], Chen et al. studied the capacity of wireless networks under a different trafﬁc distribution. In particular, they considered a set of nrandomly deployed nodes transmitting to a single sink or multiple sinks where the sinks can be either regularly deployed or randomly deployed.arXiv:1405.4380v1  [cs.NI]  17 May 20142 They showed that with single sink, the transport capacity is given by  (W); withksinks, the transport capacity is increased to  (kW)whenk=O(nlogn)or (nlognW) whenk=   (nlogn). Furthermore, there is also signiﬁcant amount of work studying the impact of infrastructure nodes [27] and multipleaccess protocols [28], [29] on the capacity and the multicast capacity [30]. We refer readers to [31] for a comprehensive review of related work. The above work of Franceschetti et al. [4] and Gupta and Kumar [6], [11], and most other work in the ﬁeld [2], [3], [8]– [10], [12], [13], established the capacity of wireless multihop networks using centralized scheduling and routing schemes, which may not be appropriate for largescale networks being investigated in [4], [6], [11]. In a recent work [1], Chau et al. took the lead in studying the throughput of CSMA networks. They showed that CSMA networks can achieve the pernode throughput  1pn , the same order as networks using optimal centralized TDMA, if multiple back off countdown rates are used in the distributed CSMA protocol and packets are routed using the highway system proposed in [4]. While the use of distributed CSMA for scheduling in [1] constitutes a signiﬁcant advance compared with the centralized TDMA considered in previous work, the routing scheme in [1] still relies on the highway system, which needs centralized coordination to identify the highway nodes and to establish the highway. The centralized routing scheme used in [1] is not compatible with the distributed CSMA scheduling scheme. In this sense, the routing and scheduling scheme in [1] is not entirely distributed and may not be suit able for largescale networks. Furthermore, the deployment of the highway system in CSMA networks requires two different carriersensing ranges to be used: a smaller carriersensing range used by the highway nodes and a larger carriersensing range used by the remaining nodes to access the highway. The use of two different carriersensing ranges may exacerbate the hidden node problem in CSMA networks, which will be explained in detail in Section V. To conquer the potential hidden problem brought by the use of two different carrier sensing ranges, the entire frequency bandwidth is divided into two subbands for use by the two types of nodes employing different carriersensing ranges respectively. This imposes ad ditional hardware requirements on the nodes and also causes spectrum waste. Based on the above observation, we are motivated to de velop a distributed scheduling and routing algorithm to achieve the orderoptimal throughput in CSMA networks in this paper. Speciﬁcally, by resorting to the percolation theory and by carefully tuning the three controllable parameters in CSMA protocols, i.e., transmission power, carriersensing threshold and countdown timer, we show that a throughput of  1pn is achievable in distributed CSMA networks. Furthermore, we analyze the preconstant preceding the order of the transport capacity by giving an upper and a lower bound of the transport capacity. The tightness of the bounds is established using simulations. The following is a detailed summary of our contributions: We develop a distributed routing and scheduling algorithm that is able to achieve the orderoptimal throughput in CSMA networks. More speciﬁcally, the routing deci sion relies on the use of local neighborhood knowledge only and each node competes for channel access in a dis tributed and randomized manner using CSMA protocols. We demonstrate that by jointly tuning the carriersensing threshold and the transmission power, the hidden node problem can be eliminated even for nodes using different carriersensing thresholds, different transmission powers and a common frequency band. This is different from the techniques used in the previous work [1] where nodes using different carriersensing ranges have to use different frequency band for transmission. The technique devel oped provides guidance on setting the carriersensing threshold and the transmission power to avoid the hidden node problem in CSMA networks in a more general setting. We analyze the preconstant preceding the order of the transport capacity by giving an upper and a lower bound of the transport capacity. As pointed out in [31], the pre constant is important to fully understand the impact of various parameters on network capacity. Extensive simulations are carried out which validate the tightness of our analytical results. The rest of this paper is organized as follows. Section II reviews related work; Section III presents the network model and deﬁnes notations and concepts used in the later analysis; Section IV describes the routing algorithm and analyzes the trafﬁc load of each node; Section V presents the solution for obtaining a hidden node free CSMA network; Section VI optimizes the medium access probability for each node by tuning the back off timer and analyzes the pernode throughput under our proposed communication strategy; Finally, Section VII concludes the paper. II. R ELATED WORK "
136,Formal specification of the FlexRay protocol using FocusST.txt,"FlexRay is a communication protocol developed by the FlexRay Consortium. The
core members of the Consortium are Freescale Semiconductor, Robert Bosch GmbH,
NXP Semiconductors, BMW, Volkswagen, Daimler, and General Motors, and the
protocol was respectively oriented towards embedded systems in the automotive
domain. This paper presents a formal specification of the FlexRay protocol
using the FocusST framework. This work extends our previous research of formal
specifications of this protocol using Focus formal language.","The FlexRay Consortium developed approx. 20 years ago a timetriggered protocol for em bedded systems in vehicles, cf. [22]. The core advantages of this protocol, in comparison for eventdriven protocols, are deterministic real time message transmission, fault tolerance, in tegrated functionality for clock synchronisation, and higher bandwidth. FlexRay static cyclic communication schedules and systemwide syn chronous clocks allow to apply distributed control algorithms used in drivebywire applications. In our previous work [31, 18, 19, 20], we intro duced the FlexRay specication using the Focus specication language [6] and the correspond ing verication using the Isabelle/HOL theorem prover [23], cf. also [31, 32, 37]. That formal ization was based on the \Protocol Specication 2.0""[12]. In this paper we present an extended version of this specication: we apply the FocusSTframe work to allow for a better readability as well as highlighting the timing aspects of the specica tion. Outline: Section 2 introduces the basic prin ciples of the FocusSTframework. Section 3 presents the core features of the FlexRay proto col along with their formal specications in Fo cusST. Section 4 discusses the related work. Fi nally, Section 5 summarises the paper.2 FOCUSST FocusST[39, 41] is an extension of the Focus framework to increase the readability and under standability of the formal specication. The Fo cusSTspecication layout is similar to Focus , but it has a number of new features based on hu man factor analysis within formal methods, cf. [46, 34, 36]. The rst step towards elaboration the Fo cusSTframework was the optimisation of the Fo cusspecication layout were discussed in [35]. In both frameworks, specications are based on the notion of streams , but the formalisation of this concept is done in dierent ways: The input and output streams of a Focus component are map pings of natural numbers Nto single messages and, in the case of timed streams, toppresent ing the clock ticks. The FocusSTinput and out put streams of a component are always timed. They are formalised as a mapping from Nto lists of messages that are transmitted within the cor responding time intervals. Thus, FocusSThas streams of two kinds ( Tdenotes a list of ele ments of type T): •Innite timed streams M1to specify the in put and the output streams are formalised by N!T; •Finite timed streams Mto specify timed streams truncated at some point of time are formalised by ( T).arXiv:1801.04979v1  [cs.LO]  14 Dec 20173 FLEXRAY PROTOCOL A FlexRaybased system is built from a num ber of nodes, connected via a network cable. The nodes might have dierent congurations. On each node •a FlexRay Controller is running (a network cable connects the FlexRay controllers of all nodes) •a number of automotive applications are run ning. The FlexRay message transmission model is based on rounds : each round consist of a constant number of slots, time intervals of the same length. A node can broadcast its messages to other nodes at statically dened slots. At most one node can do it during any slot. A high level architecture of FlexRay is presented in Figure 1. FlexRayController(c1)	   FlexRayController(cn)	   Cable	   recv	   send1	    sendn	   …	   store1	   storen	   get1	   getn	   return1	   returnn	    Figure 1: Architecture of the FlexRay protocol To specify FlexRay formally, the following data types are dened: •A FlexRay message consists of a message ID and the actual data that provided by the a faulttolerant communication layer FTCom (FaultTolerant Communication, cf. [24]) of the OSEKtime operationg system [25]: Message =msg (msgID :N;ftcdata :Data ) •A FlexRay frame consists of a slot ID and pay load (the messages that have to be transmit ted), which is dened as a nite list of type Message Frame =frame (slot:N;data :Message) •A FlexRay bus conguration Cong onsists of the scheduling table schedule of a node and the length of the communication round cLength : Cong =conf (schedule :N;cLength :NA scheduling table of a node consists of a num ber of slots in which this node should be send ing a frame with the corresponding identier (identier that is equal to the slot). 3.1 Logical components of the system Even having small changes in the syntax might lead to a signicant increase of readability and understandability of a formal language. For ex ample, numbering the formulas allowing implicit constructs can be very helpful. To increase the readability of FocusST, we use socalled implicit elsecase constructs: •if there is no explicit mentioning of the value of an output stream for a particular transac tion, then the corresponding time interval of this stream should be empty; •if there is no explicit mentioning of the value of a variable after a particular transaction, then this variable should keep its current value. FlexRayArch (c 1; :::;cn2Cong) timed in return 1; :::;return n:Frame out store 1; :::;store n:Frame ;get1; :::;getn:N loc send 1; : : : ; send n;recv:Frame asm A1 8i2[1::n] :msg1(return i) A2 DisjointSchedules (c1; : : : ; cn) A3 IdenticCycleLength (c1; : : : ; cn) gar G1 ( recv) := Cable (send 1; : : : ; send n) G2 8i2[1::n] : (store i;send i;geti) := FlexRayController (ci)(return i;recv) Figure 2: FlexRay Architecture specied in FocusST Figure 2 presents the architecture of the FlexRay communication protocol specied in FocusST. Its assumptionpart consists of three constraints: A1: all bus congurations have disjoint scheduling tables, A2: all bus congurations have the equal length of the communication round,A3: each controller can receive at most one data frame each time interval from the environ ment' of the system. The guaranteepart represents architecture of the FlexRay communication protocol: the system consists of the component Cable and ncompo nents FlexRay Controller (one controller compo nent for each of nnodes). The component Cable represents the trans mission properties of a physical network cable: every received FlexRay frame has to be resent to all connected nodes, cf. Figure 3. Thus, if one of the controllers send a frame, it should be be transmitted to all nodes, i.e., to all other con trollers in the system. The specication has only one formula in the assumption part: it expresses that all input streams of this component have to be disjoint. This assumption is fullled due to the properties of the FlexRayController compo nents and the overall system assumption that the scheduling tables of all nodes are disjoint (cf. as sumption A2 of the FlexRayArch specication). The guarantee part of this specication has also only one formula: the predicate Broadcast speci ed in in Section 3.2 below. Cable timed in send 1; :::;send n:Frame out recv:Frame asm A1 disjinf(send 1; :::;send n) gar G1 Broadcast (send 1; :::;send n;recv) Figure 3: Specication of the cable component The specication FlexRayController represent the controller component for a single node, cf. Figure 4. The specication does not have any assumptions on the input streams of this compo nent, which is highlighted by truein the assump tion part. The guaranteepart represents archi tecture of this component, as this component is is a composite one and is built from the compo nents Scheduler and BusInterface . Scheduler activates BusInterface according to the FlexRay schedule, cf. Figure 5: every time tinterval, which is equal (modulo the length of the FlexRay communication cycle) to some frame identier i, the frame with this identier. TheFlexRayController(c 2Cong) timed in return ;recv:Frame out store ;send :Frame ;get:N loc activation :N asm true gar G1 ( activation ) := Scheduler (c) G2 ( store ;send ;get) := BusInterface (activation ;return ;recv) Figure 4: Specication of the controller component Scheduler(c 2Cong) timed out activation :N univ s2N asm true gar G1 8t2N: s2schedule (c)!activationt=hsi where s=mod(t;cycleLength (c)) Figure 5: Specication of the scheduler component BusInterface timed in activation :N;return ;recv:Frame out send ;store :Frame ;get:N asm true gar G1 Receive( recv ;store ;activation ) G2 Send( return ;send ;get ;activation ) Figure 6: Specication of the bus interface component frame identier corresponds in the scheduler table to the number of the slot in the communication round. BusInterface (cf. Figure 6) species the inter action with other nodes of the FlexRay system, i.e., on what time interval what FlexRay framemust be send from the node, and how the sended frames should be received. The component is specied using by two auxiliary predicates, Send and Receive , described in Section 3.2. 3.2 Auxiliary predicates We dene the following auxiliary predicates to specify the FlexRay protocol: DisjointSched ules,IdenticCycleLength , and FrameTransmis sion,Broadcast ,Send and Receive , cf. Figure 7. A sheaf of channels of type Cong •fulls the predicate DisjointSchedules , if all bus congurations have disjoint scheduling ta bles; •fulls the predicate IdenticCycleLength , if all bus congurations have the equal length of the communication round. The predicate FrameTransmission denes the correct message transmission: if the time interval tis equal (modulo the length of the FlexRay com munication round) to the element of the scheduler table of the node k, then only the node kis al lowed to send data at the tth time interval. The predicate Broadcast describes properties of FlexRay broadcast. The predicates Send and Receive dene the Focus relations on the streams to represent respectively data send and data re ceive by FlexRay controller. 3.3 Specication of requirements The specication FlexRayReq represents require ments on the protocol, cf. Figure 8: If the scheduling tables are correct in terms of the pred icates DisjointSchedules (all bus congurations have disjoint scheduling tables) and IdenticCycle Length (all bus congurations have the equal length of the communication round), and also the FlexRay component receives in every time in terval at most one message from each node (via channels return i, 1in), then •the frame transmission must be correct in terms of the predicate FrameTransmission ; •FlexRay component sends in every time in terval at most one message to each node via channels getiand store i, 1in). Please note that the assumption part of this spec ication is equal to the assumption part of the specication FlexRayArch . To demonstrate that the specied FlexRay system fulls the requirements we need to proveDisjointSchedules c1; :::;cn2Cong 8i;j2[1::n];j6=i: 8x2rng :schedule (ci);y2rng :schedule (cj) : x6=y IdenticCycleLength c1; :::;cn2Cong 8i;j2[1::n] : cycleLength (ci) =cycleLength (cj) FrameTransmission store 1; :::;store n;return 1; :::;return n2Frame! get1; :::;getn2N! c1; :::;cn2Cong 8t2N;k2[1::n] : lets=mod(t;cycleLength (ck))in s2schedule (ck)! gett k=hsi ^ 8j2[1::n];j6=k:storet j=returnt k Broadcast send 1; :::;send n;recv2Frame! 8t2N: 9k2[1:::n] :sendt k6=hi ! recvt=sendt k Send return ;send2Frame!;get ;activation 2N! 8t2N: activationt6=hi ! gett=activationt^sendt=returnt Receive recv ;store2Frame!;activation 2N! 8t2N: activationt=hi ! storet=recvt Figure 7: Specications of the auxiliary predicates that the specication FlexRayArch is a renement of the specication FlexRayReq .FlexRayReq (c 1; :::;cn2Cong) timed in r1; : : : ; rn:Frame out s1; : : : ; sn:Frame ;g1; : : : ; gn:N asm A1 8i2[1::n] :msg1(ri) A2 DisjointSchedules (c1; : : : ; cn) A3 IdenticCycleLength (c1; : : : ; cn) gar G1 FrameTransmission (r1; : : : ; rn; s1; : : : ; sn;g1; : : : ; gn;c1; : : : ; cn) G1 8i2[1::n] : msg1(gi)^msg1(si) Figure 8: Specications of the FlexRay requirements 4 RELATED WORK "
269,Into Summarization Techniques for IoT Data Discovery Routing.txt,"In this paper, we consider the IoT data discovery problem in very large and
growing scale networks. Specifically, we investigate in depth the routing table
summarization techniques to support effective and space-efficient IoT data
discovery routing. Novel summarization algorithms, including alphabetical
based, hash based, and meaning based summarization and their corresponding
coding schemes are proposed. The issue of potentially misleading routing due to
summarization is also investigated. Subsequently, we analyze the strategy of
when to summarize in order to balance the tradeoff between the routing table
compression rate and the chance of causing misleading routing. For experimental
study, we have collected 100K IoT data streams from various IoT databases as
the input dataset. Experimental results show that our summarization solution
can reduce the routing table size by 20 to 30 folds with 2-5% increase in
latency when compared with similar peer-to-peer discovery routing algorithms
without summarization. Also, our approach outperforms DHT based approaches by 2
to 6 folds in terms of latency and traffic.","The rapidly increasing number of IoT devices result s in the  creation of a torrent of data. These data may be st ored and  managed at the edge or regional sites of the Intern et. For  example, many smart cities may host their IoT data in the  municipal databases. Many manufacturers may host th eir IoT  data at their own sites. Data from smart vehicles w ill probably  stay with the vehicles or at the roadside units. As  can be seen,  a lot of IoT data are being created and hosted in a  dispersed  way over the Internet. These peertopeer (p2p) dat a sources  can be discovered and made use of to achieve more a dvanced  data analysis and knowledge discovery.  To enable IoT data stream discovery, annotation is an  important issue. Discovery literature has considere d raw  keywords and multiattribute annotation (MAA) model s for  annotation [1]. Many machineinterpretable semantic  models  for annotating the IoT data streams, such as the se mantic sensor  network, FiestaIoT, etc., have been proposed. Howe ver,  complex annotations may significantly degrade the I oT data  discovery performance. In this work, we consider MA A based  IoT data annotation and query specifications. The s emantic  based annotations can be converted into MAA to faci litate  efficient routing.  Data discovery in p2p networks under keywords and M AA  based annotations has been widely investigated. Man y existing  works are DHT (distributed hash table) based [2], w hich hashes data objects to specific nodes in the network. They  are very  effective for some objects but are not suitable for  IoT data.  Basic DHT schemes require data to be stored at the hashed  locations. IoT data streams are generally continuou s flows and  moving them to potentially far away hosts based on DHT can  cause major overhead. Some works use the hashed nod es as the  pointers pointing to the actual IoT data locations [1] [3], but  these approaches imply space and communication over head,  especially in handling MAA based lookups.  Unstructured discovery routing approaches, such as [4] [5],  require the maintenance of a routing table or routi ng  information cache. These discovery routing schemes are  similar to IPbased routing, except that the routin g tables and  the discovery queries are indexed by keywords inste ad of IP  addresses. One important issue in unstructured p2p routing is  the design of the routing table for maintaining or caching the  routing information. Since many IoT data streams ar e hosted  by resourceconstrained nodes at the edge of the ne twork,  routing table size on these nodes has to be confine d. In IP  networking, space concern is addressed by compressi ng the  routing tables using the “summarization” technique [6].  However, very few works have considered space effic ient  routing table design or summarization techniques.  In this paper, we consider data discovery in p2p Io T  networks at the edge of the Internet (including res ource constrained edge servers and IoT nodes). We focus o n the  space efficiency issue in query routing for discove ry of data  streams annotated by the MAA model. Specifically, w e use the  summarization techniques to achieve space efficienc y, which  have been widely used in IPbased routing.  How to summarize keywords used in data discovery  routing ? Summarization in IPbased routing relies on the  hierarchical structure of the domain names [6]. Sum marization  of numerical values can also be done intuitively by  union of  individual ranges [5]. For summarizing keywords, a natural  extension of these methods is alphabetical based   summarization, which compresses multiple keywords i nto  their longest common prefix. However, alphabetical based  method depends on how likely we can find proper key word  groups that can be summarized into common prefixes.  If the  group of keywords that can be summarized does not s how up  together in a routing table, then it will be diffic ult to compress  the table. In fact, experimental results show that the  effectiveness of alphabetical based summarization i s limited.  To avoid the dependency on keyword distributions, w e can  use hashing to randomize the set of keywords in the  system to  a uniformly distributed coding space to allow summa rization    to occur in a more uniform manner. Accordingly, we also  consider the hash based  summarization in this paper.  When considering keyword distributions carefully, w e can  see that relevant keywords may have some regionaliz ed  appearance. For example, some cities are major manu facturing  sites for certain products, such as Detroit for aut omotive  manufacturing, Chicago for steel industry, etc. Spe cific sensor  data streams for production line monitoring for the  specific  industries may include many semantically similar ke ywords. In  a smart city setting, sensors with similar function alities, such  as for traffic observation, pollution monitoring, t rash tracking,  etc., may be used throughout the city. The descript ors for these  sensor data streams will also have significant simi larities. To  achieve potentially better routing table compressio n by making  use of the regionalized keyword similarity distribu tions, we  also consider the meaning based  summarization to summarize  IoT data descriptors with similar keywords and expe ct that it  will yield a better compression ratio.  Is summarization for keywords feasible ? With keywords  indexing the routing tables, how do we know which k eywords  (routing table entries) can be aggregated? This is straightfor ward for IP based routing, for numerical ranges, an d for the  alphabetical based method, but difficult in other a pproaches.  Having keywords such as temperature, pressure, flow  rate, etc.,  in a routing table, how do we know whether they can  be  summarized? No work has specifically addressed this  issue.   We design novel coding schemes to maintain parentc hild  summarization relations to enable the identificatio n of the child  keywords that can be summarized and the parent keyw ord to  be summarized into. These coding schemes can furthe r  improve space efficiency of the routing tables. Thu s, we allow  routing information to be summarized instead of thr own away  to achieve space efficiency as well as routing effe ctiveness.  How to know when to summarize ? Unlike IP based  routing, where same domain prefixes have a high pro bability  of implying the same routing directions, keyword ba sed  summarization does not have the same implication. A ssume  that a parent keyword  has three child keywords , , and   (i.e., , , and  can be summarized into ). During  summarization, how do we know  has three child keywords?  This is an issue even for alphabetical based summar ization.  Again, we need to maintain the ontology at each rou ting node,  which is not feasible. Also, should we require that   summarization to  can only be done when all the 3 child  keywords appear in the routing table (full coverage ) or allow a  partial set of these keywords to be summarized into   (partial  coverage). With IP addressing, this is less a probl em due to its  domain based design. But in keyword based routing, requiring  full coverage reduces the routing table compression  ratio and  allowing partial coverage may result in misleading routing. In  this paper, we not only analyze the impact of the “ coverage”  threshold, but also develop novel schemes to comput e  coverage for truly realizing the summarization stra tegies.  Experimental study . We crawled the web, obtained 100K  IoT data streams, and extracted their descriptors [ 7].  Accordingly, we conducted indepth experiments to s tudy the performance of our summarization strategies under d ifferent  settings. We also compared our approach with DHTba sed and  other unstructured routing solutions in largescale  IoT  networks. Experimental results show that our summar ization  solutions yield great space efficiency for routing tables.  In the rest of the paper, Section II discusses the related  literature. In Section III, we formally define our multiattribute  annotation model and our discovery routing problem.  Section  IV discusses the three summarization strategies and  the  algorithmic designs to realize them. Section V cons iders the  summarization coverage issue and discusses the sche mes to  enable coverage computation. Experimental results a re  presented in Section VI. Section VII concludes the paper.  II.  RELATED WORKS   "
357,State Analysis and Aggregation Study for Multicast-based Micro Mobility.txt,"IP mobility addresses the problem of changing the network point-of-attachment
transparently during movement. Mobile IP is the proposed standard by IETF.
Several studies, however, have shown that Mobile IP has several drawbacks, such
as triangle routing and poor handoff performance. Multicast-based mobility has
been proposed as a promising solution to the above problems, incurring less
end-to-end delays and fast smooth handoff. Nonetheless, such architecture
suffers from multicast state scalability problems with the growth in number of
mobile nodes. This architecture also requires ubiquitous multicast deployment
and more complex security measures. To alleviate these problems, we propose an
intra-domain multicast-based mobility solution. A mobility proxy allocates a
multicast address for each mobile that moves to its domain. The mobile uses
this multicast address within a domain for micro mobility. Also, aggregation is
considered to reduce the multicast state. We conduct multicast state analysis
to study the efficiency of several aggregation techniques. We use extensive
simulation to evaluate our protocol's performance over a variety of real and
generated topologies. We take aggregation gain as metric for our evaluation.
  Our simulation results show that in general leaky aggregation obtains better
gains than perfect aggregation. Also, we notice that aggregation gain increases
with the increase in number of visiting mobile nodes and with the decrease in
number of mobility proxies within a domain.","     IP mobility addresses the problem of changing the network pointofattachment transparently during movement. Mobile IP [4][5] is the proposed standard by IETF. However, several studies [1][3][7] have shown that Mobile IP has several drawbacks ranging from triangle routing and its effect on network overhead and endtoend delays, to poor performance during handoff due to communication overhead with the home agent.      Multicastbased mobility [1][2] has been proposed as a promising solution to the above problems, incurring less endtoend delays and fast smooth handoff. In such architecture, the mobile node is assigned a multicast address to which it joins through base stations it visits throughout its movement. Handoff is performed through standard multicast join/prune mechanisms.      In a previous routeanalysis simulation study [1] we have shown that,  on average, multicastbased mobility experiences around half the network overhead, endtoend delay and handoff delays experienced by basic Mobile IP, and clearly outperforms its variants even with optimizations.      Nonetheless, the multicastbased architecture for interdomain mobility suffers from several problems concerning multicast state scalability with the growth in number of mobile nodes, and, subsequently, number of groups. The architecture also requires ubiquitous multicast deployment and more complex security measures.      To alleviate these problems, we propose an intra domain multicastbased mobility solution. In thisarchitecture, a mobile node is assigned a multicast address within a domain that it uses for micro mobility. The allocated multicast address is locally scoped (i.e., unique only domainwide). This allows for a domainwide address allocation scheme, in which a mobility proxy (or a group of proxies) allocates multicast addresses for visiting mobiles. These addresses are locallyscoped and are used temporarily by the mobiles for micro mobility while moving within the domain. The mobile proxy performs interdomain mobility on behalf of the visiting mobile, then tunnels the packets multicast  to the mobile. The multicast address of a mobile does not change throughout its movement within the domain. Since the multicast addresses are locallyscoped and the joins go through the mobility proxy, the multicast address allocation scheme is performed per domain (as opposed to requiring an interdomain architecture). Also, this provides potential for multicast state aggregation opportunities. In addition, we conduct multicast state analysis to quantify aggregation gains over various topologies for random movement patterns. We investigate two kinds of bit wise aggregation; perfect and leaky aggregation. Our results show that leaky aggregation leads to better aggregation gain at the expense of extra unnecessary traffic. Also, we note that aggregation gain reduces with the increase in number of mobility proxies, increase in number of nodes in the network and increase in the average node degree. The rest of this paper is organized as follows. Section 2 presents related work. Section 3 provides an overview of multicastbased mobility, while Section 4 discusses the issues associated with inter domain multicastbased mobility and motivates our approach for multicastbased micro mobility. Section 5 presents our basic architecture and Section 6 provides architectural discussion. State aggregation isexplained in Section 7. Simulation results and their analysis are presented in Section 8. Section 9 concludes and presents future work. 2. RELATED WORK "
87,The impact of propagation environment and traffic load on the performance of routing protocols in ad hoc networks.txt,"Wireless networks are characterized by a dynamic topology triggered by the
nodes mobility. Thus, the wireless multi-hops connection and the channel do not
have a determinist behaviour such as: interference or multiple paths. Moreover,
the nodes' invisibility makes the wireless channel difficult to detect. This
wireless networks' behaviour should be scrutinized. In our study, we mainly
focus on radio propagation models by observing the evolution of the routing
layer's performances in terms of the characteristics of the physical layer. For
this purpose, we first examine and then display the simulation findings of the
impact of different radio propagation models on the performance of ad hoc
networks. To fully understand how these various radio models influence the
networks performance, we have compared the performances of several routing
protocols (DSR, AODV, and DSDV) for each propagation model. To complete our
study, a comparison of energy performance based routing protocols and
propagation models are presented. In order to reach credible results, we
focused on the notion of nodes' speed and the number of connections by using
the well known network simulator NS-2.","Before using a wireless network or installing the s tations of a cellular network, we have to  determine the radio waves’ targeted coverage. The t argeted radio coverage has a crucial  economic impact because it determines the equipment  to be utilized. In other words, the bigger  the coverage is, the less antennas are required to cover the region or to reach a grand area.  Besides, the radio coverage depends on several para meters such as the emission power.  However, the environment where the waves spread and  the utilized frequency also play a crucial  role. The radio propagation waves are controlled by  strict rules, mainly when there are obstacles  between the transmitter and the receiver [1], [2]. Among the changes a wave may undergo, we  can cite: reflection, diffraction, diffusion and ab sorption (figure 1). The metrics used are packet  delivery fraction, delay, throughput and energy. Th e remainder of the paper is outlined as  follows: Section (2) focuses on the radio propagati on models types. Section (3) discusses of  routing protocols concepts in ad hoc networks. In S ection (4) the methodologies of simulation  are introduced. Section (5), we investigate the imp act of radio propagation models on the  performances of routing protocols in ad hoc network s and the energy consumption. Finally, we  present our conclusions in Section (6). International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.1, January 2012  76           Figure 1.  The different physical phenomena disturb ing radio signal propagation    2. RADIO PROPAGATION MODELS   In a propagation model, we use a set of mathematica l models which are supposed to provide an  increasing precision. Propagation radio models are three types: path loss, shadowing and fading.  The first type can be expressed as the power loss d uring the signal propagation in the free space.  The second type is characterized by fixed obstacles  on the path of the radio signal propagation.  The third category is the fading which is composed of multiple propagation distances, the fast  movements of transmitters and receivers units and f inally the reflectors [3].  2.1.  Free Space Model  The free space model assumes that in the ideal prop agation condition between the transmitter  and the receiver, there is only one clear line of s light (LOS) path. The following equation  calculates the received signal power in a free spac e with distance (d) from the sender:  LdGGPdPrtt r222 )4 ()( πλ=                                                  (1 )  Where tP  is the power transmission (in watts), tG and rG  are the antenna gains of the  transmitter and receiver respectively. L is the sys tem loss factor. λ is the wave length and d is  the distance between the transmitter and the receiv er [4], [5].    2.2. TwoRay Ground Model   The free space model mentioned above states that th ere is only one single direct path. In fact,  the signal reaches the receiver through multiple pa ths (due to reflection, refraction and  scattering). The twopath model attempts to account  for this phenomenon. In other words, the  model advocates that the signal attains the receive r via true paths: a lineofslight path and a  path through which the reflected wave is received [ 6]. In the twopath model, the received  power is represented by:  LdhhGGPdPrtrtt r422 )(=                                          (2)  Where th and rh are the heights of the transmitter and receiver re spectively. Nonetheless, for  short distances, the tworay model does not give ac curate results because of in oscillation  caused by the constructive and destructive combinat ion of the two rays. The propagation model  in the free space is instead, still used where d is  small. Hence, in this model, we calculate cd as  a crossover distance. When cdd<, we use the first equation, but when cdd>, the second  equation is used. At the crossover distance, equat ions (1) and (2) give similar results.  Consequently, cd can be calculated as: International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.1, January 2012  77       λπrt chhd4=                                                 (3)     2.3 Shadowing Model  Both the free space and the tworay models predict the received power in terms of the distance.  They also represent a communication area as an idea l circle. In fact, the received power at a given  distance varies randomly because of multipath prop agation effects, known as fading effects.  Thus, the two aforementioned models predict the mea n received power at distance d. The  shadowing model is two fold [7]. The first model is  the path loss model represented by )(dPr. It  employs a close in distance 0das follows:    β    = 00 )()( dd dPdP rr                                                (4)  β is called the path loss exponent, and is often emp irically determined by filed measurement.  Equation (4) implies that β = 2 in free space propagation. The table.1 gives t ypical values of β [8].   Table 1: Some Typical values of path loss β  Environment β     Outdoor   Free space 2  Shadowed urban  area 2.7 to 5    In building Lineofsight 1.6 to 1.8  Obstructed 4 to 6    Langer values of β correspond to more obstructions and thus faster de crease in average received  power as distance becomes larger. From equation (4) , we have:     −=     0 0log 10 )()( dd dPdP dB rrβ                                     (5)  The second part of the shadowing model reflects the  variations of received power at certain  distance. It is a lognormal random variable. The o verall model is represented by:  dB  dB rr dd dPdPΧ+   −=     0 0log 10 )()(β                            (6)  Where dB Χ is Gaussian random variable with zero mean and sta ndard deviation σdB. σdB is  called shadowing deviation, and also obtained throu gh measurement in the real environment.  Table 2 displays some typical values of σdB. This equation is also labelled a lognormal  shadowing model.  Table 2: Typical values of shadowing deviation σdB  Environment dB σ (dB)  Outdoor 4 to 12  Office, hard partition 7  Office, soft partition 9.6  Factory , line of sight  3 to 6   Factory, obstructed 6.8    2.4. SmallScale Fading model: Rayleigh and Rice  This fading model depicts the rapid fluctuations of  the received signal due to multipath fading.  This fading phenomenon is generated by the interfer ence of at least two types of transmitted  signals to the receiver with slight time intervals [9], [10]. The outcome may vary according to  fluctuations and to different phases in terms of mu ltiple factors such as: delay between waves, International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.1, January 2012  78       the intensity and the signal band width. Hence, the  system performance may be attenuated by  the fading. However, there are several techniques t hat help stopping this fading. The signal  fading were monitored according to a statistical la w wherein the most frequently used  distribution is Raleigh’s [11]. The transmitted sig nal is, thus, conditioned by the following  phenomena: reflection, scattering and diffusion. Th anks to these three phenomena, the  transmitted power may reach the hidden areas despit e the lack of direct visibility (NLOS)  between the transmitter and receiver. Consequently,  the amount of the received signal has a  density of Rayleigh:  ( )  <∞≤≤ −= 0 , 00 , ) exp( 22 x pour x pour Px Px xf                                            (7)  Where, P is the average received power. In case whe re there is a direct path (LOS) between the  transmitter and receiver, the signal no longer obey s to Rayleigh's law but to Rice’s. The  probability density of Rice is represented by:    ( )    <∞≤≤    +     +−−+ = 0 , 00 ,) 1 (21exp ) 1 (2 )(02 x pour x pour PKKx IPx KKPKx xf         (8)  Where K is the ratio of the power received in the d irect line and in the path, P is the average  power received and )(0xI  is the zeroorder Bessel function de fined by:   ∫− =π θθπ2 00 ) cos exp( 21)( d x xI ,                                                     (9)  The density of Rice (Equation 8) is reduced to the density of Rayleigh (Equation 7) in the case  of an absence of a direct path which means that K=0  and thus )(0xI =1.  2.5. Nakagami model  This distribution encompasses several other distrib utions as particular cases. To describe  Rayleigh distribution, we assumed that the transmit ted signals are similar and their phases are  approximate. Nakagami model is more realistic in th at it allows similarly to the signals to be  approximate. Since we have used the same labels as in Rayleigh and Rice cases, we  have ∑=ij ier rθ. The probability density of Nakagami related to r is represented by:   ( ) ( )0 , exp 22 12 ≥    Ω− Ω Γ=− rmr  mrmrPmm m r                                         (10)  Where )(mΓ is gamma function, ()2rE=Ω and (){} )(222r Var rE m=  with the constraint 21≥m .  Nakagami model is a general distribution of fading which is reduced to Rayleigh’s distribution  for m=1 and to unilateral Gaussian model for m=1/2.  Besides, it represents pretty much rice  model and it is closer to certain conditions in the  lognormal distribution [12], [13] and [14].  3.  AD HOC ROUTING PROTOCOLS    Ad hoc routing protocols are based on fundamental p rinciples of routing such as: Inundation  (flooding), the distance Vector, the routing to the  source and the state of the site. According to  the way routes are created and maintained during th e data delivery, the routing protocols can be  characterised into two categories: proactive and re active [15]. Among the tested protocols in this  study, only DSDV is proactive and the others (DSR a nd AODV) are all reactive. Proactive  protocols update route information periodically, wh ereas reactive protocols establish routes only  when needed. Here is a summary of the routing proto cols assessed in this paper.         International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.1, January 2012  79       3.1. Dynamic Source Routing (DSR)   During the discovery process of routing, a source n ode generates a routerequest packet which  needs a new route to a certain destination. The rou te request is connected through the network  until it reaches some nodes with a route to destina tion. A reply packet containing all information  of intermediate nodes is sent back to the source. T he sent packets contain a list of all nodes  through which they have to transit. This list can b e huge in a network with a big diameter. The  nodes do not need the routing table. There are two DSR basic operations: the route discovery  and the route maintenance. In order to cut down the  expenses and the frequency of the route  discovery, every single node keeps track of the pat hs thanks to reply packets. These paths are  used until they become useless [16].    3.2. Adhoc OnDemand Distance Vector protocol (AOD V)  AODV has a way for route request close to that of D SR. However, AODV does not perform a  routing to the source. Every single node on the pat h refers to a point towards its neighbour from  which it receives a reply. When a transit node need s broadcasts a route request to a neighbour, it  also stores the node identifier in the routing tabl e from which the first reply is received. To  check the links state, AODV uses control messages ( Hello) between direct neighbours. Besides,  AODV utilizes a sequence number to avoid a round tr ip and to ensure using the most recent  routes [16].  3.3. DSDV Protocol  The algorithm DSDV (Dynamic destination Sequenced D istance Vector) [16] has been  constructed for mobile networks. Each mobile statio n keeps a routing table which contains all  possible destinations, number of hops to reach the destination, sequence number  (SN)  associated with the node destination to distinguish  the new routes of the old a ones and avoid  the formation of round trip routing. The table upda ting is periodically transmitted across the  network so as to sustain the information consistenc y, and thus generates an important traffic.  4. METHODOLOGY  "
380,An Approach to Provide Security in Mobile Ad-Hoc Networks Using Counter Mode of Encryption on Mac Layer.txt,"Security in any of the networks became an important issue in this paper we
have implemented a security mechanism on Medium Access Control layer by Assured
Neighbor based Security Protocol to provide authentication and confidentiality
of packets along with High speed transmission for Ad hoc networks. Here we have
divided the protocol into two different parts. The first part deals with
Routing layer information; in this part we have tried to implement a possible
strategy for detecting and isolating the malicious nodes. A trust counter for
each node is determined which can be actively increased and decreased depending
upon the trust value for the purpose of forwarding the packets from source node
to destination node with the help of intermediate nodes. A threshold level is
also predetermined to detect the malicious nodes. If the value of the node in
trust counter is less than the threshold value then the node is denoted
'malicious'. The second part of our protocol deals with the security in the
link layer. For this security reason we have used CTR (Counter) approach for
authentication and encryption. We have simulated all our strategies and schemes
in NS-2, the result of which gives a conclusion that our proposed protocol i.e.
Assured Neighbor based Security Protocol can perform high packet delivery
against various intruders and also packet delivery ratio against mobility with
low delays and low overheads.","1.1 Mobile Ad hoc Networks   A mobile Ad hoc network (MANET) is a collection of two  or more devices equipped  with wireless communication and networking capabilities [3]. Such an Ad hoc network  is infrastructure less, self organizing, adaptive and does not re quire any centralized  administration . If  two  such  devices  are located within transmission range of each  other, they can communicate directly. Two non adjacent devices can communicate only  if other devices between them are in Ad hoc network and are will ing to forward packets  for them. Since the nodes are mobile, the network topology may change rapidly and  unpredictably over time. Because of lack of centralized administration, all the network  activities like discovering of topology and message delivering are executed by nodes  themselves.  1.2 Security threats   There are different types of attacks that are recorded in the current mobile A dhoc networks but  the most vulnera ble attack on 802.11 MAC is DoS . In this form of attack the attacker may  corrupt frames  easily by adding some bits or ignoring the ongoing transmission . Whereas  among the  connecting nodes the binary exponential scheme can favors  the last node which has  to capture effect . In capture effect the nodes are heavily loaded and tries to consume th e  channel by sending the data continuously, thus resulting the lightly loaded neighbor to back off  endlessly taking the factor that the malicious node will try to take the advantage of capture  effect vulnerability. Whereas the nodes that tend to make the p assive attack with the aim of  saving battery for communication are considered to be selfish. The various sorts  of attacks on  MANET are categorized as:   1.2.1 Flooding attack:    It is a version of Denial ofservice attack. The malicious node sends a huge numb er of  unnecessary request packets to such a node which may or may not be a part of the  network in which the malicious node is included. As a consequence, the bandwidth of  the network is consumed highly and degradation of the network throughput is followed,   thus the total network gets disrupted.   1.2.2 Black hole attack:   The malicious node sends fake reply packets to the source node denoting its fabricated  sequence number higher than that of the other nodes and claiming itself as a node  through which a suffic ient optimum path is declared. As a result, the traffic of the  network is bound to pass through the malicious node. Then the malicious node can  easily misuse the traffic and even it can discard the useful traffic to disrupt the network.                                                                                                                     RP                               RP               Fig: Black hole attack    S        D   A  S = S ource   D= D estination  RP= R eply P ackets  1.2.3 Wormhole attack:   It is basically a partnership attack where attackers may be more than o ne in number and  work together to forge the targeted node. This is the most serious attack on MANET. A  high speed network is also used here. Source sends request packets which are falsely  passed through the attackers’ zone. The attacker or malicious nodes then pass these  request packets to destination through a high speed link faster than any other link from  source to destination. As the requests come faster through the false high speed link, the  destination node also selects the same path to send its reply  packets. When reply packets  are arrived at the source through the attackers’ zone source node also starts sending its  data through the path in which the attackers are included without being aware of it. As a  result all the data passes through the maliciou s nodes.                                        Target                                                Fig : Wormhole attack     1.2.4 Session Hijacking:   It is a critical attack on MANET where the malicious node behaves like a legitimate  node. The a ttacker node takes advantage of first phase authentication. This attack can be  considered as one of the results of IP address spoofing and results in denial ofservice  attack. As a result the targeted system gets unavailable.      S  A1       D A2    S  A1       D A2    A1 = Attacker 1          A2 = At tacker2      Wireless Link                     Wormhole Link        Request Packet        Request Through Wormhole        Response Packets    1.2.5 Routing attacks:   Diffe rent types of attacks can be done on the routing protocol used in a MANET. One  of the most important type is routing table overflow. Here, the attacker node (malicious)  creates a number of routes to some nonexistence nodes to prevent the formation of  succe ssful routes and thus it harms the protocol implementation. Another form of such  attack is routing table poisoning where the malicious nodes creates false routing updates  or modifies the original routing update packets.   1.2.6 Repudiation:   In this form of a ttack, the malicious node simply ignores its responsibility over the  communication. Though it have total or partial role in the communication made, it  simply denies its tasks done.     2.  RELATED WORK  "
277,A Crowd-enabled Solution for Privacy-Preserving and Personalized Safe Route Planning for Fixed or Flexible Destinations (Full Version).txt,"Ensuring travelers' safety on roads has become a research challenge in recent
years. We introduce a novel safe route planning problem and develop an
efficient solution to ensure the travelers' safety on roads. Though few
research attempts have been made in this regard, all of them assume that people
share their sensitive travel experiences with a centralized entity for finding
the safest routes, which is not ideal in practice for privacy reasons.
Furthermore, existing works formulate safe route planning in ways that do not
meet a traveler's need for safe travel on roads. Our approach finds the safest
routes within a user-specified distance threshold based on the personalized
travel experience of the knowledgeable crowd without involving any centralized
computation. We develop a privacy-preserving model to quantify the travel
experience of a user into personalized safety scores. Our algorithms for
finding the safest route further enhance user privacy by minimizing the
exposure of personalized safety scores with others. Our safe route planner can
find the safest routes for individuals and groups by considering both a fixed
and a set of flexible destination locations. Extensive experiments using real
datasets show that our approach finds the safest route in seconds. Compared to
the direct algorithm, our iterative algorithm requires 47% less exposure of
personalized safety scores.","Ensuring safe travel on roads is essential for the develop ment of a safe city. While traveling on roads in any mode (e.g., walking, cycling or driving), people face many incon veniences like theft, robbery, pickpocketing, and accidents; women face harassment like eveteasing and unwanted physical touch [1], [2], [3], [4], [5]. The shortest or the fastest route is not always the best choice. People would like to travel a little bit longer on a safer route that avoids those inconveniences. Journey planners like Google or Bing Maps do not show the risky roads to travelers. Since the safety of a road may change with time, it is not easy for a traveler to know the safest route for traveling from a source to a destination location. To meet the traveler’s need on roads, we introduce a safe route planner that ﬁnds the safest routes (SRs) with crowdsourced data and computation. Our safe route planner supports four important query types: (i) safest route (SR) query . (ii) ﬂexible safest route (FSR) query , (iii) group safest route (GSR) query , and (iv) group ﬂexible safest route (GFSR) query . An SR query ﬁnds the SR between a sourcedestination pair within a distance constraint. Some times a user may have the ﬂexibility for the destination; for example, a user would be happy to visit any of the branches of a superstore within a distance constraint if the safety level of the route to reach the superstore is increased. Inspired by this scenario, an FSR query ﬁnds the SR within a distance constraint by considering a ﬁxed source and a set of destination locations. On the other hand, the GSR and the GFSR queries extend the SR and FSR queries for groups, respectively. A group of people may want to meet for a F.T. Islam, T. Hashem, and R. Shahriyar are with the Department of Com puter Science and Engineering, Bangladesh University of Engineering and Technology, Dhaka, Bangladesh Email: fariha.t13@gmail.com, tanzimahashem@cse.buet.ac.bd, rifat@cse.buet.ac.bdvariety of purposes; sometimes their destination is ﬁxed (e.g., a speciﬁc restaurant), and sometimes it is ﬂexible (e.g., a set of restaurants). A GSR query ﬁnds the set of SRs from the independent source locations of the group members to the ﬁxed destination, whereas a GFSR query ﬁnds the set of SRs from the independent source locations of the group members by considering a set of ﬂexible destinations. In Section 2, we explain these queries with examples. The data needed for computing the SRs may come from ofﬁcial reports and the personal travel experiences of the crowd. The latter is more valuable than the former one due to its recency and adequacy. However, travel experiences are often sensitive and private data, and people, especially women, do not feel comfortable sharing their detailed travel experiences and harassment data with others [6]. These factors have inspired us to develop a privacyenhanced safe route planning system by not sharing the personalized travel experiences of the crowd with a centralized entity or others. Our approach ensures the privacy of crowd data and personalizes the safety score (SS) of a user’s travel experi ence (both safe and unsafe) with respect to the user’s travel pattern. If two users face the same unsafe event on two different roads, then these roads may have different SSs considering the frequency and recency of the users’ visits on those roads. Ignoring the personal travel pattern of the users would reduce the quality of data and the accuracy of the query answer. We develop a model to quantify a user’s travel experience for a visited area into a personalized safety score (pSS) based on different parameters like frequency and recency of the user’s visits, location, time, and type of inconveniences faced. Users store their pSSs of their known areas on their own devices or any other private storage (e.g., cloud storage) and use them to ﬁnd the SRs for others. The transformation of a user’s travel experience into a pSS is a oneway mapping. From the revealed pSS of a user, it is notarXiv:2112.13760v2  [cs.DB]  9 Sep 2022JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015 2 possible to pinpoint the type of incident faced by the user. It may only allow an adversary to infer highlevel information on a user’s travel experience (e.g., a user has encountered an unsafe event without knowing the unsafe event type). To further enhance user privacy, we minimize the amount of pSS information shared to evaluate the SRs. We develop efﬁcient query processing algorithms that ﬁnd the SRs from the reﬁned search space and minimize the exposure of pSS information. Since the number of possible routes between a sourcedestination pair is extremely high, a naive algorithm cannot ﬁnd the SRs in real time. Our search space reﬁnement techniques allow our query pro cessing algorithms to ﬁnd the SRs with signiﬁcantly reduced processing overhead. Every user is not familiar with all roads, and it is also not feasible to involve a user for all queries. For a speciﬁc SR query or its variant, we identify the users who are familiar with the query relevant area and select them as query relevant group members. The trustworthiness of the query answer depends on the overall knowledge of the selected queryrelevant group members. To show the credibility of the answer, we present a new measure called conﬁdence level [7], [8] in the context of ﬁnding the SRs and variants. Existing safe route planners involve a centralized entity to ﬁnd the SRs using crime or accident data collected from reports [9] or crowd [10] or both [11], [12], [13]. They have major limitations: Ignore the privacy issues of the crowd harassment and incident data and thus suffer from data scarcity problem. Missing incident data can cause a system to return a route that is not actually safe and put a traveler at risk. Do not personalize the crowd’s travel experiences by considering a user’s travel pattern, which is essential to improve the accuracy of the query answer. Do not consider individual distances associated with different SSs for ranking the routes. For example, if two routes have the same lowest SS, then the route for which a user has to travel less distance with the lowest SS is the safest one, though its total distance might be greater than that of the other route. Do not show any measure to represent the trustworthi ness of the identiﬁed SRs. In recent years, the increase of the computational power and storage in smartphones has enabled researchers to envision for crowdsourced systems [7], [8]. To the best of our knowledge, we propose the ﬁrst privacyenhanced and personalized solution for safe route planning with crowd sourced data and computation. Our solution overcomes the limitations of existing route planners. Our contributions in this paper are as follows: We present a model to quantify a user’s travel experi ences into irreversible pSSs and modify the indexing technique, Rtree to store pSSs. Based on pSSs, we design a privacyenhanced crowdenabled solution for the SR queries and variants. We select the users who have the required knowledge in a query relevant area, and we guarantee the credibility of the query answer evaluated based on the data of the selected group members in terms of the conﬁdence level.We develop optimal algorithms, direct and iterative, to efﬁciently evaluate the SRs. The direct algorithm reveals group members’ pSSs only for the query relevant area. The iterative one further reduces the amount of shared pSSs at the cost of multiple communications per group member. We generalize our direct and iterative algorithms to efﬁciently process the SR query and its variants: FSR, GSR, and GFSR queries. We show that the direct appli cation of the direct and iterative algorithms to ﬁnd SRs between a sourcedestination pair to evaluate SR query variants incur excessive processing overhead in most cases. We run extensive experiments with real datasets and evaluate the effectiveness and efﬁciency of our ap proach. This paper extends the work in [14], where we intro duced a novel SR query and proposed the ﬁrst privacy enhanced and personalized solution to solve those queries with crowdsourced data and computation. In this paper, we enhance the work in the following ways: (i) we improve our safe route planner by introducing SR query variants: FSR, GSR, and GFSR queries, (ii) we provide generalized direct and iterative algorithms for efﬁcient processing of the SR query and its variants, (iii) we show the complexity analysis and performance analysis of our modiﬁed Rtree, (iv) we provide the formal privacy attacker model and privacy proof, (v) we present new experimental analysis to show the efﬁciency of our generalized direct and iterative algorithms for the SR query variants, and the effectiveness of ﬁnding SRs over the shortest routes and the safest routes without any distance constraint. 2 P ROBLEM FORMULATION The road network N= (V;E)consists of a set of vertices V and a set of road segments E. The vertices represent the start or the end or the intersection points of roads. An edge eij2 Erepresenting a road segment connects the vertex vito the vertexvj, wherevi;vj2V. A routeRconsists of a sequence of verticesR= (vi1;vi2;:::;vijRj), whereeik"
466,Performance Analysis of MANET Routing Protocols Using An Elegant Visual Simulation Tool.txt,"The task of simulation is often complicated for which many naive users often
seek for relatively easier solutions. In many cases, simulations are done
without any visual output which makes them non-attractive. In this paper, we
present ViSim; a new simulation tool that has a user-friendly graphical
interface. ViSim could be useful for researchers, students, teachers in their
works, and for the demonstration of various wireless network scenarios on
computer screen. It could make the task of simulation more exciting and enhance
the interest of the users without going into complex command-only text
interface. ViSim is not a simulation engine rather it calls ns-2 simulations in
the background and makes the task easy for the users to visualize the
simulation in Windows environment. Though ViSim is mainly a simulation
demonstration tool, any user with the knowledge of ns-2 and Tcl scripting is
also allowed to do necessary modifications and quick configurations for any
other MANET routing scenario. Using our simulation tool, we measured the
performances of several Mobile Ad-hoc Network (MANET) routing protocols. In
this paper, we present the performance analysis of three prominent MANET
routing protocols; DSDV, DSR, and AODV using our tool. The details of various
features of ViSim, brief descriptions of the selected routing protocols and
their comparisons, details about the performed experiments, and the gained
results are presented in this work.","In this modern era, the communications technology has advanced at a tremendous pace. The growing  trend of using wireless communications capability bui lt into common accessories such as laptops, PDAs,  mobile phones provides us with a sea of nodes that curren tly lies at best not utilized to its fullest and at  worst constantly fighting for the sliver of frequency spectrum that is being shared by multiple providers.  Wireless adhoc routing protocols show promise in bringing the order and ha rmony to this chaotic  situation.   A Mobile Adhoc Wireless Network (MANET) is a collection of autonomous nodes that communicate  with each other by forming a multihop network, mainta ining connectivity in a decentralized manner [1],  [2]. It consists of a set of mobile hosts comm unicating amongst themselves using wireless links, without  the use of any other communication support faciliti es such as basestations. The nodes in a MANET can  be PDAs, laptops or any other device that is capable  of transmitting and receiving information. Each node  in such a network acts as a host or end system (trans mitting and receiving data) as well as a router at the  same time. The nodes in a MANET are generally mob ile and may go out of range of other nodes in the  network. Therefore, Routing in MANET is difficult since mobility causes frequent network topology  changes and requires more robust and flexible mechanis m to search for and maintain the routes. When the  network nodes move, the established paths may break a nd the routing protocols must dynamically search  for other feasible routes. With a changing topology, ev en maintaining connectivity is very difficult. In  addition, keeping the routes loop free is more di fficult when the hosts move. Besides handling the  topology changes, routing protocols in MANET must d eal with other constraints, such as low bandwidth,  limited energy consumption, and high error rates; all of which may be inherent in the wireless  environment. Furthermore, the possibility of asymme tric links caused by different power levels among  mobile hosts and other factors such as terrain c onditions make routing protocols more complicated.  Because of these challenging features of MANET, it has been under tremendous scrutiny and interest  from the time of its emergence and by this time, nu merous works have tried to address various issues. Routing in MANET is one of the welladdressed topi cs. Though many routing protocols have already  been proposed and wellaccepted in the research community because of their given promise and  performance, there still remains the n ecessity of a flexible, userfriendly simulation tool that can make the  task of simulation and visualization of routing protocols easier. Many simulators can successfully  simulate various routing protocols of MANET. Ho wever, there are only a few tools to handle the  simulations with a graphical interfa ce. This particular fact has moti vated us to design and develop a  simulation tool so that the users could be able to deal with complex simulation scenarios in a much easier  way without getting in volved into the commandonly interface.  We have named our simulation tool ‘ViSim’. Currently  the version 1.0 (ViSim 1.0) is available. We  will talk in detail about our tool later in this paper.  ViSim could help a network administrator to choose a  particular adhoc routing protocol for a specific scenario through analyzing the graphs for different  routing protocols. Alongside describing various aspects a nd features of ViSim, we have also analyzed the  performances of the prominent routing protocols for MANET using our tool. We have also discussed the  features of the routing protocols so that the reader s could get some idea how they operate in a MANET  setting.    The rest of the paper is organized as follows: Sec tion 2 gives a brief description of three major MANET  routing protocols – DSDV, DSR and AODV that we have used for our performance analysis. Section 3 describes ViSim that we have developed to inves tigate various simulation scenarios. After doing the  performance evaluations, the obtained results a bout Throughput, Goodput, and Routing Loads are  presented in Section 4. Section 5 talks about some relevant works and comparative features of ViSim and other tools, and finally Section 6 concludes the pa per mentioning the achievements from this work with  future directions for research and objectives.    2 ANALYZED MANET ROUTING PROTOCOLS  We have analyzed three well known routing protoc ols for MANET. Before discussing our performance analysis and results, in this section we briefly me ntion the operational methods and major features of  these protocols.    2.1 Dynamic DestinationSequenced Distan ceVector Routing Protocol (DSDV)  DSDV [3] is a proactive routing protocol which is developed on the basis of BellmanFord routing [4]  algorithm with some modifications. In this protocol , each mobile node in the network keeps a routing  table. Each of the routing table contains the list of  all available destinations and the number of hops to  each. Each table entry is tagged with a sequence numbe r which is originated by the destination node.  Periodic transmissions of updates of the routing tables help maintaining the topology information of the  network. If there is any new significant change for the routing information, the updates are transmitted  immediately. So, the routing information updates might either be periodic or eventdriven. DSDV  protocol requires each mobile node in the network to advertise its own routing table to its current  neighbors. The advertisement is done either by broa dcasting or by multicasting. By the advertisements,  the neighboring nodes can know about any change that  has occurred in the network due to the movements  of nodes.  The routing updates could be sent in two ways: one is  called a ‘full dump’ and another is ‘incremental’.  In case of full dump, the entire routing table is sent to the neighbors whereas in case of incremental  update, only the entries that require changes are se nt. Full dump is transmitted relatively infrequently  when no movement of nodes occur. The incremental upda tes could be more appropriate when the network  is relatively stable so that extra traffic could be  avoided. But, when the movements of nodes become  frequent, the sizes of the incremental updates become la rge and approach the network protocol data unit  (NPDU). Hence, in such a case, full dump could be u sed. Each of the route up date packets also has a  sequence number assigned by the transmitter. For upda ting the routing information in a node, the update  packet with the highest sequence number is used as the highest number means the most recent update  packet. Each node waits up to certain time interval to transmit the advertisement message to its neighbors  so that the latest information with better route to  a destination could be informed to the neighbors.   2.2 Dynamic Source Routing (DSR)  DSR [5] is a reactive routing protocol which allows nodes in the MANET to dynamically discover a  source route across multiple network hops to any des tination. In this protocol, the mobile nodes are  required to maintain route caches  or the known routes. The route cache is updated when any new route is  known for a particular entry in the route cache.   Routing in DSR is done using two phases: route disc overy and route maintenance. When a source node  wants to send a packet to a destination, it first c onsults its route cache to determine whether it already  knows about any route to the destination or not. If alread y there is an entry for that destination, the source  uses that to send the packet. If not , it initiates a route request broa dcast. This request includes the  destination address, source address, and a unique iden tification number. Each intermediate node checks  whether it knows about the destination or not. If the in termediate node doesn't know  about the destination,  it again forwards the packet and eventually this reaches the destin ation. A node processes the route  request packet only if it has not previously processed the packet and its address is not present in the route  record of the packet. A route reply is generated by the destination or by any of the intermediate nodes  when it knows about how to reach the destination.    2.3 Ad Hoc OnDemand Distance Vector Routing (AODV)  AODV [6] is basically an improvement of Dynami c DestinationSequenced DistanceVector (DSDV)  routing protocol. But, AODV is a reactive routing protoc ol instead of being proactive. It minimizes the  number of broadcasts by creating routes based on demand, which is not the case for DSDV. When any  source node wants to send a packet to a destination,  it broadcasts a route request (RREQ) packet. The  neighboring nodes in turn broadcast the packet to  their neighbors and the process continues until the  packet reaches the destination. During the process of forwarding th e route request, intermediate nodes  record the address of the neighbor from which the first copy of the broadcast packet is received. This record is stored in their route tables, which helps for establishing a reverse path. If additional copies of the  same RREQ are later received, these packets are discar ded. The reply is sent us ing the reverse path. For  route maintenance, when a source node moves, it can reinitiate a route discovery process. If any  intermediate node moves within a particular route, the neighbor of the drifted node can detect the link  failure and sends a link failure notification to it s upstream neighbor. This process continues until the  failure notification reaches the source node. Based on the received information, the source might decide  to reinitiate the route discovery phase.  Each of these routing protocols was tested in our si mulation experiments. The details of our works and  our built prototype are mentioned in the following sections.    3 VISIM: A VISUAL SIMULATION TOOL    3.1 Building Blocks of ViSim  We have used two software in Windows environment for our work; ActiveTcl and Microsoft Visual  Basic. Before describing ViSim’s features and func tionalities, in this subsection we talk about these  briefly.    ActiveTcl is an industrystandard Tcl distribution, available for Windows, Linux, Mac OS X, Solaris,  AIX and HPUX. This software creates an environm ent in Windows to run the ns2 [7] simulations and  .tcl scripts. It is capable of executing the simulation f aster than cygwin [8]. This package contains ns.exe  and nam.exe, two executable files. Once a .tcl scrip t is written referring to a particular scenario with  specifications of different simulation parameters such as ad hoc routing protocol name, number of nodes,  nodal positions, MAC layer type, simu lation area, time, etc; ActiveTcl can run the simulation in Windows  environment. For details of ActiveTcl and its latest ve rsions, the readers are encouraged to visit the URL;  http://www.activestate.com/activetcl/  .  Microsoft Visual Basic is a popular software that we have used for developing ViSim prototype so that it can connect the simulation related tasks with a user friendly graphical interface. For our work, we have  used ActiveTcl8.3.5 and Visual Basic 6.0.    3.2 Overview of ViSim  Our graphical simulation tool, ViSim is built using Vi sual Basic 6.0 in order to make comparisons among  various MANET routing protocols since there are very few prototypes available today for performing  such type of task. Most of the available tools are somewhat not userfriendly. Hence, keeping that in  mind, we built ViSim in such a way that any naive user can also be able to use th is tool to visualize the  background simulations done in ns2 (that is r un with the help of ActiveTcl in Windows operating  system). ViSim runs associated .tcl files for all the three mentioned protocols (DSDV, DSR, AODV) and  extracts the required information from the trace files that  are generated. Eventually the graphs are plotted  for different performance indicators such as Throughput, Goodput, and Routing Loads. ViSim can make  the task of a network administrator easy to decide wh ich routing protocol  would be better for a particular  MANET scenario.    Figure 1. Visual Simulation Tool Interface, ViSim 1.0 (run in Windows XP)    3.3 Different Working Areas  Figure 1 shows the ViSim prototype/tool when it is r un in Windows environment for the first time. The graphical interface has some working areas and functi onalities that should be known before using it for  analysis of various parameters. There are main ly four portions/areas on the ViSim interface:  (a) Simulation:  In this area, three routing protocols are mentioned. Clicking on the names of each  protocol gives the options of simulating three netw ork scenarios using that particular protocol. The  network scenarios could be modified as required in the .tcl scripts that run in the background.   (b) Comparison:  This area has the options; Throughput vs Time, Goodput (Packets), Routing Load  (Packets), Goodput (Bytes), and Routing Load (Bytes). A ll these buttons are used to select the parameters  that the user needs for the pe rformance analysis and comparison among the routing protocols.   (c) Scenarios and Protocols: This area specifies the options of th ree network scenarios (radio buttons)  and three routing protocols (tick boxes). Also it has two buttons namely; ‘Simulate’ and ‘Create Graph’.  ‘Simulate’ button is used for playing the simulations and ‘Create Graph’ is used to plot the comparison  graphs.  (d) Output:  Output area is the rightbottom area which is shown as a blank window area when ViSim  is run for the first time. Based on the choice of vari ous options, the outputs or further options are shown  in this area. The graphs are also plotted on this area when the user chooses the option of creating graphs  after performing various simulations and comparisons.      Figure 2. DSR simulation options   3.4 Functionalities of ViSim with Examples  Now, let us see the functionalities of ViSim with some practical examples. Let us suppose that we want to  visualize the simulation for DSR for a particular netw ork scenario. For this task, first we have to click  DSR button under simulation area. After clicking DS R button, ViSim shows three more options (DSR  Simulation 1, DSR Simulation 2, and DSR Simulation 3) on the output area as shown in Figure 2.   From these three options any one could be chosen. For our task, let us choose DSR Simulation 3. After  clicking this button, ViSim calls ns2 in its backgro und, then reads .tcl file that specifies the simulation  scenario 3, generates .nam and .tr files. Once the .n am and .tr files are generated, ViSim calls the NAM  (Network Animator tool) in its background and reads the generated .nam files. Consequently, it shows a  display for visual simulation [see Figure 3].  On the NAM screen, there are few buttons such as pl ay, forward, backward, stop buttons available to  control the simulation as these are done usually in Li nux based environment with ns2 and NAM. To see  the visual simulation on the screen, the play button sh ould be clicked. Like any other simulation using  NAM, we can also change the step size of the simulation.      Figure 3. The output after choosing DSR Simulation 3   Now, if we want to make comparisons among thr ee different protocols for performance analysis, we  have to choose a specific network scenario. In our case, let us select Scenario 1. Then we have to select  three mentioned protocols (or, any two or one) and side by side the performance indicators should be  clicked from the five options in the comparison ar ea. Figure 4 shows the output where we selected  ‘Throughput Vs Time’.      Figure 4. An example where ‘Throughput vs Time’, Scenario 1, and three protocols are selected  for running the simulations    Once the simulations are performed by clicking the ‘S imulate’ button, we can use the generated results  in the background for plotting comparison graphs. Basi cally, this ‘Simulate’ button facilitates performing  various simulations with three protocols for a particul ar network scenario at the same time. This reduces  the burden of doing the tasks repeatedly or selecting one protocol at a time under Simulation area. Once  all the simulations are completed, the graph can be generated by clicking the ‘Create Graph’ button. By  clicking ‘Create Graph’ button, we send the command to  read the generated .tr files (trace files) and  extract the required information/values from those. These values are used to plot the graphs for different  protocols for a specific scenario and for different performance indicators. Figure 5 shows a sample output  of what we have done so far (as an important note it should be mentioned that each simulation and plotting of graph takes a bit time as required by ns 2; for example in our case, it took about 25 seconds to  plot the graph on the ViSim output area).      Figure 5. A sample output graph (Throughput vs Time) using network scenario 1, all three  protocols; DSDV, DSR, and AODV are compared     Let us talk about the working mechanism of ViSim buttons a bit. When the user selects the simulation  option in order to view the simulation for a partic ular scenario corresponding to the selected ad hoc  network protocol, ViSim calls up a .bat file which contai ns shell script. This shell script calls the ns2 and  feeds files or file having extension .tcl, according to the choice of simulation. Then ns2 generates trace  file (extension .tr) and nam file (extension .nam). After that NAM is called via shell script and using  NAM the script feeds .nam file into NAM which gi ves a GUI (Graphical User Interface) popup and using  it, a user can actually observe the simulation. Agai n, when the user selects the Comparison option  and  clicks Create Graph after performing simulations, ViSim gathers the .tr files according to the choice of  protocol, reads those and according to the performan ce indicators, it filters the data and picks up  important information to  generate the graph.  For ViSim, we have used some given network sp ecifications. Note that any specification can be  modified in the .tcl files according to the requireme nts to simulate another ne twork setting. Also, various parameters used in ViSim code c ould be given new values. We are planning to make ViSim an open source tool so that it could be customized to fit a particular wireless network (MANET, Wireless Sensor  Network, etc.) scenario.    3.5 ViSim Operational Flow    Figure 6. Diagram of the operational flows of ViSim    A diagram of the operational flows of ViSim is presented in Figure 6. This figure shows that after running  ViSim, a user first needs to choose between two op tions: Simulation or Comparison. For simulation, the  user is given the options of three simulations (with three different network scenarios) for each of the three  routing protocols: AODV, DSR, and DSDV. Choosi ng any option of any simulation scenario calls NAM  and then the visual simulation can be seen. On the other hand, choosing comparison gives five  comparison options, then the user needs to select a pa rticular scenario and click any one, two, or three  routing protocols to compare. After that the user is given the option of simulation of all the selected items  at a time or plotting of comparison graph. If there is no simulation done be fore plotting graph using ‘Create Graph’ option, it returns nothing and the out put area shows blank space as usual; otherwise, if the  simulations are performed and then the ‘Create Graph’ option is chosen, the relevant graph is plotted on  the output area.    3.6 ViSim File Organization and Simu lation Scenario Modification   In this subsection we briefly talk about the file organization that is used in our tool. After installing  ViSim a particular folder appears in which several .tcl  files are kept. For any .tcl file, the general format  that is used is: [The naming convention: a + Adhoc  protocol (X) + Scenario (Y).tcl]=axy.tcl, where x  represents the protocol whose value ranges from 0 to  2 and y represents the scenario whose value also  ranges from 0 to 2. Now, every value of x or y is asso ciated with the file name. Let us have a look at  Table 1 for a clear idea regarding the naming convention that is used.  Table 1. File Naming Convention ([row+column] values in the cells)   0  (Scenario 1) 1  (Scenario 2) 2  (Scenario 3)  0  (AODV) 00 01 02  1  (DSR) 10 11 12  2  (DSDV) 20 21 22    From the above table, we may draw the following c onclusions regarding the selection of a particular  .tcl file for working:  a00 = “AODV Simulation for scenario 1""  a01 = ""AODV Simulation for scenario 2""  a02 = ""AODV Simulation for scenario 3""  a10 = ""DSR Simulation for scenario 1"" a11 = ""DSR Simulation for scenario 2""  a12 = ""DSR Simulation for scenario 3""  a20 = ""DSDV Simulation for scenario 1"" a21 = ""DSDV Simulation for scenario 2""  a22 = ""DSDV Simulation for scenario 3""    Therefore, if a user needs to change a file’s sp ecifications, say for example; the 2nd scenario of DSR  routing protocol, he needs to open the a11.tcl file and do necessary changes. The user’s manual is also  available in ViSim website (mentioned later) which te lls more about these facilities. We have noted this  information here to indicate that ViSim could be  used both as a simulation demonstration tool and a  simulator tool for MANET routing protocols.     4 PERFORMANCE EVALUAT IONS AND RESULTS    In this section, we present the obtained results from our performed experiments using ViSim tool.     4.1 Simulation Parameters and Specifications   Table 2 shows the specifications and paramete rs that we used for our experiments:  Table 2. Simulation Parameters  Simulation Parameter Value  Channel Type Wireless Channel  Radiopropagation model Two Ray Ground Model  Network interface type Wireless Physical MAC type 802_11 b Interface Queue Type Dr op Tail Primary Queue  Antenna model Omni Direction Number of Mobile nodes 310 Ad Hoc Routing Protocol DSDV, DSR, AODV Simulation Area 500m x 400m Simulation Time 150 ms Traffic Type TCP Nodal speed  310 m/s Packet size 1040 Byte (Data Packets) 40 bytes(Acknowledgement Packets)  60 Bytes (Routing Packets)  Total Number of different Scenarios  15    To evaluate the performances of various routing prot ocols we took three network scenarios; Scenario 1  with 3 nodes, Scenario 2 and 3 with 10 nodes with different mobility characteristics. Comparisons among  different protocols were based on the aggregate of the performance metrics resulting from the simulations  of 15 different scenarios that had been performed  for each protocol separately. To measure the  performances, we used the following metrics:  Throughput:  The total bytes received by the destination node per second (Data packets and Overhead).  Goodput:   Goodput (In terms of Number of Packets): The ratio of the total number of data packets that ar e sent from the source to the total number of packets  that are transmitted within the ne twork to reach the destination.  Goodput (In terms of  Packet Size in Bytes):  The ratio of the total bytes of data that are sent from the source to the total bytes that are transmitted  within the network to reach the destination.  Routing Load: Routing Load (In terms of Number of Packets):  The ratio of the total number of routing packets th at are sent within the network to the total number  packets that are transmitted within th e network to reach the destination.  Routing Load ( In terms of Packet Size in Bytes):  The ratio of the total bytes of routing packets that  are sent within the network to the total number of  bytes that are transmitted within the network to reach the destination.   4.2 Simulation Results  To illustrate our experimental results using our tool, we first present all the outputs of 15 different cases  in the Figure 7, Figure 8, Figure 9, Figure 10, and Figure 11.       (a)   (b)    (c) Figure 7. Throughput vs Time (a) Scenario 1 (b) Scenario 2 (c) Scenario 3 [y axis represents  Throughput (KB) and x axis represents Time (seconds)]    (a)    (b)   (c)  Figure 8. Goodput (packets) (a) Scenario 1 (b) Scenario 2 (c) Scenario 3    (a)   (b)    (c) Figure 9. Routing Load (packets) (a) Scenario 1 (b) Scenario 2 (c) Scenario 3    (a)    (b)   (c)  Figure 10. Goodput (bytes) (a) Scenario 1 (b) Scenario 2 (c) Scenario 3    (a)   (b)    (c)  Figure 11. Routing Load (bytes) (a) Scenario 1 (b) Scenario 2 (c) Scenario 3     Figure 12. Throughput vs Time.  Figure 12 shows the aggregated result for ‘Throughpu t vs Time’ where we analyzed the total bytes  received by the destination node per second (Data pack ets and overhead). Based on the results that we see  here, the following comments could be made:  AODV:  starts off quickly and the data rate is more stable.  DSR:  starts off quickly however we can see that ther e are lots of fluctuations in the data rate.  DSDV:  takes time to start off but the data rate has lesser fluctuations.    Figure 13. Goodput for three MANET routing protocols   We calculated Goodput in terms of number of packets and the packet size in bytes. Now, if we analyze  the graph presented in Figure 13, we can see that on an average, if 100 packets are transmitted in the  network, 19 packets would be data packets for AODV, 16 for DSR, and 24 for DSDV. In term of bytes,  on an average; if 100 bytes of packets are transm itted through the network, 36 bytes would be data  packets for AODV, 28 bytes for DSR, and 48 bytes for DSDV. From these data, we could deduce that;  though DSDV takes time to converge, it actually is sending more data packets in number as well as in  bytes than that of AODV and DSR. Now, the rest of the percentage of each individual graph will be the  overheads that contain routing packets and acknowledgements.    Figure 14. Routing loads for differe nt experimented MANET protocols     We again calculated routing loads in terms of numbe r of packets and the packets size in bytes. The  results are presented in Figure 14. Again we can see that; though DSR has a bette r throughput, it actually  contains more overhead for routing packets. Howeve r, DSDV has a relatively lower routing load than AODV and DSR.     5 RELATED WORKS AND SALIEN T FEATURES OF OUR WORK  "
317,A Lightweight and Scalable Physical Layer Attack Detection Mechanism for the Internet of Things (IoT) Using Hybrid Security Schema.txt,"The Internet of Things, also known as the IoT, refers to the billions of
devices around the world that are now connected to the Internet, collecting and
sharing data. The amount of data collected through IoT sensors must be
completely securely controlled. To protect the information collected by IoT
sensors, a lightweight method called Discover the Flooding Attack-RPL (DFA-RPL)
has been proposed. The proposed DFA-RPL method identifies intrusive nodes in
several steps to exclude them from continuing routing operations. Thus, in the
DFA-RPL method, it first builds a cluster and selects the most appropriate node
as a cluster head in DODAG, then, due to the vulnerability of the RPL protocol
to Flooding attacks, it uses an ant colony algorithm (ACO) using five steps to
detect attacks. Use Flooding to prevent malicious activity on the IoT network.
In other words, if it detects a node as malicious, it puts that node on the
detention list and quarantines it for a certain period of time. The results
obtained from the simulation show the superiority of the proposed method in
terms of Packet Delivery Rate, Detection Rate, False Positive Rate, and False
Negative Rate compared to IRAD and REATO methods.","The Internet of Things has affected all aspects of our lives and developed over time due to the  advancement of technologies such as wireless communications, sensors, and large scale computing.  There are many uses for the Internet of Things, ranging from common home appliances to large scale  and critical safety systems  [15]. The number of IoT devices can be expected to exceed 50 billion by  2030. However, despite the many benefits of the Internet of Things , there are potential intruders who       Reza Fotohi *        R_fotohi@sbu.ac.ir; Fotohi.reza@gmail.com      Hossein Pakdel    Hos.pakdel.eng@iauctb.ac.ir     1    Faculty of Computer Science and Engineering, Shahid Beheshti University, G. C. Evin,  Tehran 1983969411, Iran   2    Department of Computer Engineering, Central Tehran Branch, Islamic Azad University, Tehran, Iran   can compromise the normal behaviour  of sensors. This necessitates safe and secure IoT design. One of  these dangerous attacks is the flooding attack. A flooding attack falls into the category of DDoS  attacks. This attack tries to minimize the capacity of the desired thing to respond to the r equest of other  normal things by sending RREQ messages too much and keeping things busy and prevent other things  from accessing this service.  In this paper, to solve such problems, a method based on ACO and  DODAG is used to prevent dangerous attacks such a s flooding to have a safe routing in the network.        The proposed DFA RPL method consists of two main parts, in the first part, clustering and  selecting the cluster head to create DODAG is done, and in the second part, Flooding attack detection  is done u sing ACO algorithm. The first part is used to create an optimal DODAG that has the best  nodes as a parent. The task of the second part is to detect malicious things, which are most likely  Flooding nodes that try to disrupt network operations by sending a l arge number of messages. These  malicious nodes are detected using the ACO algorithm and using five steps. Its destructive activity in  the network is prevented by the sound that if the node is found to be malicious, that node will be  placed on the detention  list and will be quarantined for a certain period of time. The proposed DFA  RPL scheme can efficiently create an optimal DODAG and manage the Flooding attack on the  network.        The organization of the different sections of this paper is as follows: Sect ion 2 describes the latest  related work related to the topic of this paper. The proposed DFA RPL approach with all its details  and subsections is given in Section 3. Section 4 of this paper presents the performance evaluation in  which the simulation result s of the proposed method and the other two methods were compared and  discussed. Conclusion This article is presented in the final section.           2 Related work   "
428,Certification of Compact Low-Stretch Routing Schemes.txt,"On the one hand, the correctness of routing protocols in networks is an issue
of utmost importance for guaranteeing the delivery of messages from any source
to any target. On the other hand, a large collection of routing schemes have
been proposed during the last two decades, with the objective of transmitting
messages along short routes, while keeping the routing tables small.
Regrettably, all these schemes share the property that an adversary may modify
the content of the routing tables with the objective of, e.g., blocking the
delivery of messages between some pairs of nodes, without being detected by any
node.
  In this paper, we present a simple certification mechanism which enables the
nodes to locally detect any alteration of their routing tables. In particular,
we show how to locally verify the stretch-3 routing scheme by Thorup and Zwick
[SPAA 2001] by adding certificates of $\widetilde{O}(\sqrt{n})$ bits at each
node in $n$-node networks, that is, by keeping the memory size of the same
order of magnitude as the original routing tables. We also propose a new
name-independent routing scheme using routing tables of size
$\widetilde{O}(\sqrt{n})$ bits. This new routing scheme can be locally verified
using certificates on $\widetilde{O}(\sqrt{n})$ bits. Its stretch is3 if using
handshaking, and 5 otherwise.","1.1 Context Arouting scheme is a mechanism enabling to deliver messages from any source to any target in a network. The latter is typically modeled as an undirected connected weighted graph G= (V;E) whereVmodels the set of routers and Emodels the set of communication links between routers. All edges incident to a degree dnode are labeled from 1 to d, in an arbitrary manner, and the label at a node uof an incident edge eis called the port number of edgeeatu. A routing scheme consists of a way of assigning a routing table to every node of the given network. These tables should contain enough information so that, for every target node t, each node is able to compute the port number of the incident edge through which it should forward a message of destination t. The routing tables must collectively guarantee that every message of any source sand any target twill eventually be delivered to t. Two scenarios are generally considered in the literature. One scenario allows the routing scheme to assign names to the nodes, and each target is then identied by its given name. The Additional support from ANR Project DESCARTES. This work was done during the rst author visit to Institut de Recherche en Informatique Fondamentale (IRIF) in 20162017. yAdditional support from ANR Project DESCARTES and Inria Project GANG. 1arXiv:1704.06070v2  [cs.DC]  21 Oct 2017other, called name independent , is assuming that xed names are given a priori (typically, a name is restricted to be the identity of a node), and the scheme cannot take benet of naming nodes for facilitating routing. Among many criteria for evaluating the quality of routing schemes, including, e.g., the time complexity for constructing the routing tables, the two main parameters characterizing a routing scheme are the sizeof its routing tables, and the stretch . The stretch of a routing scheme is the maximum, taken over all pairs of sourcetarget nodes, of the ratio between the length of the route generated by the scheme from the source to the target, and the length of a shortest path between these two nodes. During the last two decades, there has been an enormous eort to design compact routing scheme (i.e., schemes using small tables) of low stretch (i.e., with stretch upper bounded by a constant) { see, e.g., [1, 2, 3, 4, 11, 16, 20, 21, 23]. A breakthrough was achieved in [23] where almost tight tradeos between size and stretch were explicitly demonstrated. In particular, [23] showed how to design a routing scheme with tables of sizeeO(pn) bits and stretch 3, in any network1. All the aforementioned routing schemes share the property that nodes do not have the capability to realize that the routing tables have been modied (either involuntarily or by an attacker). That is, a group of nodes may be provided with routing tables which look consistent with a desired routing scheme, but which do not achieve the desired performances of that scheme (e.g., large stretch, presence of loops, etc.). Indeed, the nodes are not provided with sucient information to detect such an issue locally, that is, by having each node inspecting only the network structure and the tables assigned to nodes in its vicinity. 1.2 Objective The objective of this paper is, given a routing scheme, to design a mechanism enabling each node to locally detect the presence of falsied routing tables, in the following sense. If one or more tables are erroneous, then at least one node must be able to detect that error by running a verication algorithm exchanging messages only between neighboring nodes. Our mechanism for locally verifying the correctness of routing tables is inspired from proof labeling schemes [19]. It is indeed based on assigning to each node a certicate , together with its routing table, and designing a distributed verication algorithm that checks the consistency of these certicates and tables by having each node inspecting only its certicate and its routing table, and the certicate and routing table of each of its neighbors. The set of certicates assigned to the nodes and the verication algorithm running at all nodes in parallel must satisfy that: (1) if all tables are correctly set, then, with some appropriate certicates, all nodes accept , and (2) if one or more tables are incorrectly set, then, for every assignment of the certicates, at least one node must reject . The second condition guarantees that the verication algorithm cannot be cheated: if the tables are incorrect, there are no ways of assigning the certicates such that all nodes accept. Rephrasing the objective of the paper, our goal is to assign certicates to nodes, of size not exceeding the size of the routing tables, enabling the nodes to collectively verify the correctness of the routing tables, by having each node interacting with its neighbors only. 1.3 Our Results We show how to locally verify the stretch3 size eO(pn) routing scheme by Thorup and Zwick [23]. Our certication mechanism uses certicates of eO(pn) bits at each node, that is, these certi cates have size of the same order of magnitude as the original routing tables. Hence, verifying 1The notations eOande  ignore polylogarithmic factors. 2the scheme in [23] can be done without modifying the scheme, and without increasing the mem ory space consumed by that scheme. We also show that the same holds for the whole hierarchy of routing schemes proposed in [23] for providing a tradeo between size and stretch. The situation appears to be radically dierent for nameindependent routing schemes. The stretch3 nameindependent routing scheme by Abraham et al. [2] also uses tables of size eO(pn) bits. However, each table includes references to far away nodes, whose validity does not appear to be locally veriable using certicates of reasonable size. On the other hand, a simplied version of the scheme in [2] can be veried locally with certicates of size eO(pn) bits, but its stretch becomes at least 7. Therefore, we propose a new nameindependent routing scheme, with tables of size eO(pn) bits that can be veried using certicates on eO(pn) bits as well. This new routing scheme has stretch at most 5, and the stretch can even be reduced to 3 using handshaking2. The routing scheme of Arias et al. [3] has also stretch 5, but it does not appear to be locally veriable with certicates of reasonable size, and using handshaking does not enable to reduce the stretch. All our results are summarized in Table 1. name scheme stretch independent veriable comment [23] 3 no yes { [3] 5 yes ? { [2] 3 yes ? { this paper 5 yes yes { this paper 3 yes yes handshaking Table 1: Summary of our results compared to previous work. All the listed routing schemes have space complexity of eO(pn) bits. Our verication algorithms for these schemes use certicates oneO(pn) bits. 1.4 Related Work "
298,Expressivity of Time-Varying Graphs and the Power of Waiting in Dynamic Networks.txt,"In infrastructure-less highly dynamic networks, computing and performing even
basic tasks (such as routing and broadcasting) is a very challenging activity
due to the fact that connectivity does not necessarily hold, and the network
may actually be disconnected at every time instant. Clearly the task of
designing protocols for these networks is less difficult if the environment
allows waiting (i.e., it provides the nodes with store-carry-forward-like
mechanisms such as local buffering) than if waiting is not feasible. No
quantitative corroborations of this fact exist (e.g., no answer to the
question: how much easier?). In this paper, we consider these qualitative
questions about dynamic networks, modeled as time-varying (or evolving) graphs,
where edges exist only at some times.
  We examine the difficulty of the environment in terms of the expressivity of
the corresponding time-varying graph; that is in terms of the language
generated by the feasible journeys in the graph. We prove that the set of
languages $L_{nowait}$ when no waiting is allowed contains all computable
languages. On the other end, using algebraic properties of quasi-orders, we
prove that $L_{wait}$ is just the family of regular languages. In other words,
we prove that, when waiting is no longer forbidden, the power of the accepting
automaton (difficulty of the environment) drops drastically from being as
powerful as a Turing machine, to becoming that of a Finite-State machine. This
(perhaps surprisingly large) gap is a measure of the computational power of
waiting.
  We also study bounded waiting; that is when waiting is allowed at a node only
for at most $d$ time units. We prove the negative result that $L_{wait[d]} =
L_{nowait}$; that is, the expressivity decreases only if the waiting is finite
but unpredictable (i.e., under the control of the protocol designer and not of
the environment).","1.1 HighlyDynamicNetworks Computing in static networks (complex or otherwise) is a sub ject which has been intensively studied from many point of views (serial/distributed, centralized/dec entralized, ofﬂine/online, etc.), and it is one of the central themes of distributed computing. Computing in dynamicnetworks, that iswhere thestructure of the networkchangesintime,isrelativelylessunderstood. Ext ensiveresearchhasbeendevotedtosystemswhere the network dynamics are due to faults(e.g., node or edge deletions or additions). Indeed faultt olerance is probablythemostprofound concernindistributed computin g. Faultshoweverarelimitedinscope,bounded 1in number, and are considered anomalies with respect to the c orrect behaviour of the system. The study of computing insystems wherethenetwork faults areactually e xtensive andpossibly unbounded isatthe core oftheﬁeldofselfstabilization; thegoaloftheresearchi stodeviseprotocolsthat,operatinginsuchextreme faultyconditions,areneverthelessabletoprovidecorrec tsolutionsifthesysteminstabilitysubsides(forlong enough time). Also inthis case, faults in the network struct ure are considered anomalies withrespect to the correct behaviour of the system. What about systems where the instability never ends? where t he network is never connected? where changesareunbounded andoccurcontinuously? wheretheyar enotanomaliesbutintegralpartofthenature of the system? Such highly dynamic systems do exist, are actually quite wid espread, and becoming more ubiquitous. The most obvious class is that of wireless ad hoc mobile netwo rks: the topology of the communication network, formed by having an edge between two entities when t hey are in communication range, changes continuously in time as the movement of the entities destroy s old connections and creates new ones. These changes can be dramatic; connectivity does not necessarily hold, at least with the usual meaning of con temporaneous endtoend multihop paths between any pair o f nodes, and the network may actually be disconnected at every time instant. These infrastructure less highly dynamic networks, variously called delaytolerant ,disruptivetolerant ,challenged ,opportunistic , have been long and extensively investigated by the engineering community and, more recently, by distrib uted computing researchers, especially with regards to the problems of broadcast and routing ( e.g.[22,27, 33]). Inthesenetworks,theprotocoldesignerhasnoaprioriknow ledgenorcontroloverthetrajectoriesofthe entities. However, similar highly dynamic conditions occu r also when the mobility of the entities follows a predictable pattern, e.g. periodic or cyclic routes, like i n the case of public transports with ﬁxed timetables, lowearthorbiting(LEO)satellitesystems,securityguard s’ tours,etc. (e.g.,see[28,32]). Interestingly, sim ilar complex dynamics occur also in environments where ther e is no mobility at all, e.g., in social networks (e.g. [12,24]). Note that when dealing with these dynamic networks, most of t he basic network and graph concepts  such as path, distance, diameter, connected components, et c  have no meaning without atemporal context; indeed, all the usual connectivity concepts have to be exten ded to a temporal version to take into account the realities of the environments being modeled. 1.2 Journey andWait From a formal point of view, the highly dynamic features of th ese networks and their temporal nature are captured by the model of timevarying graphs (or evolvinggraphs), where edges between nodes exist only at some times, a priori unknown to thealgorithm designer (e. g., see [4,7,10, 14,16,17, 18,21,25, 26]). A crucial aspect of dynamic networks, and obviously of time varying graphs, isthat a path from anode to another might still exist over time, even though at no time the path exists in its entirety. It is this fact that renders routing, broadcasting, and thus computing pos sible in spite of the otherwise unsurmountable difﬁculties imposed by the nature of those networks. Hence, the notion of “path over time”, formally called journey, isafundamental concepts andplays acentral roleinthe deﬁ nition of almost all concepts related to connectivity intimevarying graphs. Examined extensively, under a variety of names (e.g., tempo ral path, scheduleconforming path, time respecting path, trail), informally a journey is a walk <e1,e2,...,ek>and a sequence of time instants <t1,t2,...,tk>where edgeeiexists at time tiand its latency ζiat that timeis such that ti+1≥ti+ζi. While the concept of journey captures the notion of “path ove r time” so crucial in dynamical systems, it does not yet capture additional limitations that some of t hese environments can impose on the use of the journeys during acomputation. More speciﬁcally, there are systems that provide the entities with store carryforwardlike mechanisms(e.g.,localbuffering); t husanentitywantingtocommunicatewithaspeciﬁc 2other entity at time t0, can wait until the opportunity of communication presents i tself. There are however environments wheresuchaprovisionisnotavailable(e.g., therearenobufferingfacilities), andthuswaiting isnot allowed. Intimevarying graphs, this distinction is the one between a directjourney where ∀i,ti+1= ti+ζi, and anindirectjourney where ∃i,ti+1>ti+ζi. With regards to problem solving, any restriction, imposed b y the nature of the system on the protocol designer, has clearly an impact on the computability and com plexity of problems. In dynamic networks, computing (already a difﬁcult task) is intuitively more dif ﬁcult in environments that do not allow waiting than inthose wherewaiting ispossible; that is, environmen ts wheretheonly feasible journeys arethedirect ones are clearly more challenging (for theproblem solver) t han those where journeys can be indirect. In the common view of the environment as the adversary that th e problem solver has to face, an en vironment that forbids waiting is clearly a more difﬁcult (i .e. stronger) adversary than the one that allows waiting. The natural and immediate question is “how much stronger is the adversary if waiting is not al lowed?”which can be reexpressed as: “if waiting is allowed, how much easier is to solve problems? ”, or simply“what is the computational power of waiting?” A ﬁrst difﬁculty in addressing these important questions is that most of the terms are qualitative, and currently there are no measures that allow to quantify even t he main concepts e.g. “complexity” of the environment, “strength” of the adversary, “difﬁculty” of s olving problems, etc. In this paper, motivated by these qualitative questions, we examine the complexity of the environment (modeledasatimevaryinggraph)intermsofits expressivity , andestablishresultsshowingthe(surprisingly dramatic) difference that the possibility of waiting creat es. 1.3 Contributions Givenadynamicnetworkmodeledasatimevaryinggraph G,ajourneyin Gcanbeviewedasawordonthe alphabet oftheedgelabels; inthislight, theclassoffeasi ble journeysdeﬁnesthelanguage Lf(G)expressed byG, wheref∈ {wait,nowait }indicates whether or not indirect journeys are considered f easible by the environment. Wefocus on the sets of languages Lnowait={Lnowait(G) :G ∈ U}andLwait={Lwait(G) :G ∈ U}, whereUisthesetofalltimevarying graphs; thatis,welookatthel anguages expressed whenwaitingis,or isnot allowed. Foreachof thesetwosets, thecomplexity ofr ecognizing anylanguage intheset(that is,the computational power needed bythe accepting automaton) deﬁ nes the level of difﬁculty of the environment. We ﬁrst study the expressivity of timevarying graphs when w aiting is not allowed, that is the only feasible journeys are direct ones. Weprove that the set Lnowaitcontains all computable languages. That is, weshowthat,foranycomputablelanguage L,thereexistsatimevaryinggraph GsuchthatL=Lnowait(G). Wenext examine the expressivity of timevarying graphs if i ndirect journey are allowed. Weprove that Lwaitispreciselythesetof regularlanguages. Theproofisalgebraicandbasedonordertechniq ues, relying on a theorem by Harju and Ilie [19] that enables to characteri ze regularity from the closure of the sets from a well quasiorder. In other words, we prove that, when waiti ng is no longer forbidden, the power of the accepting automaton (i.e., the difﬁculty of the environmen t, the power of the adversary), drops drastically from being as powerful as a Turing machine, to becoming that o f a FiniteState Machine. This (perhaps surprisingly large) gap isameasure of the computational po wer of waiting. To better understand the power of waiting, we then turn our at tention to bounded waiting ; that is when indirect journeys are considered feasible if the pause betw een consecutive edges in the journeys have a bounded duration d >0. In other words, at each step of the journey, waiting is allow ed only for at most d time units. Weexamine the set Lwait[d]of the languages expressed by timevarying graphs when wait ing is allowed upto dtimeunits. Weprove thenegative result that for any ﬁxed d≥0,Lwait[d]=Lnowait,which implies that the complexity of the environment is not affect ed by allowing waiting for a limited amount of 3time. Asaresult, thepoweroftheadversary isdecreased onl yifithasnocontrol overthelength ofwaiting, i.e., if the waiting is unpredictable. 1.4 Related Work "
13,A Low Overhead Reachability Guaranteed Dynamic Route Discovery Mechanism for Dense MANETs.txt,"A crucial issue for a mobile ad hoc network is the handling of a large number
of nodes. As more nodes join the mobile ad hoc network, contention and
congestion are more likely. The on demand routing protocols which broadcasts
control packets to discover routes to the destination nodes, generate a high
number of broadcast packets in a larger networks causing contention and
collision. We propose an efficient route discovery protocol, which reduces the
number of broadcast packet, using controlled flooding technique. The simulation
results show that the proposed probabilistic flooding decreases the number of
control packets floating in the network during route discovery phase, without
lowering the success ratio of path discoveries. Furthermore, the proposed
method adapts to the normal network conditions. The results show that up to 70%
of control packet traffic is saved in route discovery phase when the network is
denser.","In wireless ad hoc networks, the nodes communicate without the aid of any infrastructur e. There are many  challenges involved in the design of these networks. One particular challenge is involved with the routing  of data packets. Typically, the source and the destination nodes for a particular data packet are not within  direct communication r ange. This leads to a multihop scenario where the packets must be routed and  forwarded through the other nodes in the network on the way to the destination. Many routing algorithms,  like those found in [1 4], have been proposed  for ad hoc networks.   In real  networks, nodes may join and leave, some (or all) nodes are highly mobile, and node tonode  channels are subject to strong fading. In such cases, the problem of finding routes between given source  and destination nodes can present significant difficulties . In particular, there are situations when nodes  have to resort to broadcasting. This causes the effect known as “broadcast storm” in large networks,  which has been studied in literature [5 9]. Under certain conditions the route discovery process can  consu me significant portion of network resources and becomes detrimental to overall network  performance and stability. For example, if more route discovery processes are initiated  by different  sources than can be sustained, then they will likely to fail resulti ng in more retransmissions. In this  scenario, the network can become inundated with route request packets and the overall network  throughput can significantly decrease.   2. FACTORS AFFECTING ROUTING PERFORMANCE    Various factors like Link capacity, Link and node capability, network density, etc. affects the  performance of the network . The main factors addressed in this paper are the following.   2    2.1. Network Scaling   Scalability can be broadly defined as whether the network is able to provide an acceptable leve l of service  even in the presence of large number of nodes in the network. It is one of the most important open issues  of ad hoc networks. Firstly, ad hoc networks suffer, by nature, from the scalability problems in capacity.  In a non cooperative network, where Omni directional antennas are being used, the throughput decreases  at a rate  N, where N is the number of nodes  [10]. That is, in a network with 100 nodes, a single device   gets approximately one tenth of the theoretical data rate of the network interf ace card at the maximum.  This problem, however, cannot be solved except by physical layer improvements, such as smart antennas.   Routing protocols also set some limits for the scalability of ad hoc networks. Route acquisition and  service locations are examp les of task that will require considerable overhead, which will grow rapidly  with the network size. Proactive routing is not applicable in a dense and dynamic environment due to  huge amount of broadcast message of topology changes. Reactive protocols allow  deploying large  networks in the expense of increased route acquisition lat ency. Demands for shorter latencies for route  acquisition limit the network size drastically.   2.2. Flooding   Broadcast (diffusion of a message from a source node to all nodes in the network) is a common operation  in ad hoc networks, and it is used by several routing protocols. Flooding (also called blind broadcast) is  the simplest broadcast protocol: each node rebroadcasts the message once and discards duplicates.  AODV, SLS, GSR, DSR and HSLS use flooding with various improvements (usually by changing the  TTL value of the broadcast packet to limit propagation in the network). The flooding approach is reliable  but has a high overhead for the routing protocol (in term of number of packet s and MAC layer access)  and the number of collisions dramatically increases in the case of dense networks  [18].   3. RELATED WORK   "
74,Self-stabilizing Overlays for high-dimensional Monotonic Searchability.txt,"We extend the concept of monotonic searchability for self-stabilizing systems
from one to multiple dimensions. A system is self-stabilizing if it can recover
to a legitimate state from any initial illegal state. These kind of systems are
most often used in distributed applications. Monotonic searchability provides
guarantees when searching for nodes while the recovery process is going on.
More precisely, if a search request started at some node $u$ succeeds in
reaching its destination $v$, then all future search requests from $u$ to $v$
succeed as well. Although there already exists a self-stabilizing protocol for
a two-dimensional topology and an universal approach for monotonic
searchability, it is not clear how both of these concepts fit together
effectively. The latter concept even comes with some restrictive assumptions on
messages, which is not the case for our protocol. We propose a simple novel
protocol for a self-stabilizing two-dimensional quadtree that satisfies
monotonic searchability. Our protocol can easily be extended to higher
dimensions and offers routing in $\mathcal O(\log n)$ hops for any search
request.","Due to the growth and relevance of the Internet, the importance of distributed systems is increasing. Such systems are needed, for instance, in social media networks or multiplayer games and have to support a large number of participants. However, as soon as such a system has become large, the occurrence of changes or faults are not an exception but the rule. In order to recover from an arbitrary state to a legitimate one, distributed protocols are needed that are selfstabilizing . Most of the proposed selfstabilizing protocols only show that the system eventually converges to a legitimate state, without considering the monotonicity of the actual recovery ∗This work is partially supported by the German Research Foundation (DFG) within the Collaborative Research Center “OnTheFly Computing” (SFB 901). †Paderborn University, Germany. {michael.feldmann, ckolb, scheideler}@upb.de 1arXiv:1808.10300v1  [cs.DC]  30 Aug 2018process. Monotonicity means that the functionality of the system regarding a speciﬁc property never gets worse as time progresses, i.e., for two points in time t, t/primewith t < t/prime, the functionality of the system is better in t/primethan in t. In this paper we are interested in searching , as this is one of the most important operations in a distributed system. We study systems that satisfy monotonic searchability : If a search request for node wstarting at node vsucceeds at time t, then every search request for winitiated by vat time t/prime> tsucceeds as well. Previous work on monotonic searchability [ 16] [17] proposed selfstabilizing protocols for onedimensional topologies (for instance a sorted list). Still, up to this point it is not known how to come up with an eﬃcient selfstabilizing protocol for highdimensional settings that satisﬁes monotonic searchability. Highdimensional settings are relevant for example in wireless adhoc networks or social networks where processes are deﬁned by multiple parameters. This paper introduces a novel protocol BuildQuadTree for a selfstabilizing quadtree along with a routing protocol SearchQuad that satisﬁes monotonic searchability and terminates after O(logn)hops on any input. To the best of our knowledge, this is the ﬁrst protocol that combines selfstabilization and monotonic searchability for the two dimensional case. In addition, one can easily extend our protocols in order to work for multiple dimensions. For the twodimensional case, we expand the notion of monotonic searchability to an even stronger and more realistic property, which we call geographic monotonic searchability and show that SearchQuad satisﬁes this property as well. Our protocols stand out due to their simplicity and elegance and do not enforce restrictive assumptions on messages, as it has been done for the universal approach [17]. 1.1 Model We consider a twodimensional square Pof unit side length and model the distributed system as a directed graph G= (V, E)with nnodes. Each node v∈Vrepresents a single peer and can be identiﬁed via its unique position inPgiven by coordinates (vx, vy)∈ [0,1]2. We deﬁne||(u, v)||as the Euclidean distance between two nodes u, v∈V, i.e., ||(u, v)||=/radicalBig (ux−vx)2+ (uy−vy)2. Additionally, each node vmaintains local protocol based variables and has a channel v.Ch, which is a systembased variable that contains incoming messages. We assume a channel to be able to store any ﬁnite number of messages. Messages are never duplicated or get lost in the channel. If a node uknows the coordinates of some other node v, then ucan send a message mtovby putting mintov.Ch. There is a directed edge (u, v)∈Ewhenever ustores (vx, vy)in its local memory or when there is a message in u.Chcarrying (vx, vy). In the former case, we call that edge explicitand in the latter case we call that edge implicit. Nodes may execute actions: An action is a standard procedure and has the form /angbracketleftlabel/angbracketright(/angbracketleftparameters/angbracketright) :/angbracketleftcommand/angbracketright, where labelis the name of that action, parameters deﬁnes the set of parameters and command deﬁnes the statements that are executed when 2calling that action. It may be called locally or remotely, i.e., every message that is sent to a node has the form /angbracketleftlabel/angbracketright(/angbracketleftparameters/angbracketright). An action in a process visenabledif there is a request for calling it in v.Ch. Once the request is processed, it is removed from v.Ch. There is a special action called Timeout that is not triggered via messages but is executed periodically by each node. We deﬁne the system state to be an assignment of a value to every node’s variables and messages to each channel. A computation is an inﬁnite sequence of system states, where the state si+1can be reached from its previous state siby executing an action in si. We call the ﬁrst state of a given computation the initial state . We assume fair message receipt , meaning that every message of the form /angbracketleftlabel/angbracketright(/angbracketleftparameters/angbracketright)that is contained in some channel, is eventually processed. We place no bounds on message propagation delay or relative node execution speed, i.e., we allow fully asynchronous computations and nonFIFO message delivery. Our protocol does not manipulate node coordinates and thus only operates on them incomparestoresend mode, i.e., we are only allowed to compare node coordinates to each other, store them in a node’s local memory or send them in a message. We assume for simplicity that there are no corrupted coordinates in the initial state of the system, i.e., coordinates of unavailable nodes. One could use failure detectors to solve this, but this is not within the scope of this paper, since without them the problem of guaranteeing monotonic searchability is still nontrivial. Having node coordinates to be readonly also makes sense in our setting, as these are usually delivered by an external component that is not in control of our protocol, for instance like GPS. In initial states there may exist corrupted messages in node channels, i.e., messages containing false information. We will argue that at a certain point in time, all of these messages will be processed and no more corrupted messages are in the system. Nodes are able to issue search requests at any point in time: A search request is a message Search(v,(x, y)), where vis the sender of the message and (x, y)∈[0,1]2are the coordinates we want to search for. A search request is delegated along edges in G according to a given routing protocol, until the request terminates , i.e., either the node with coordinates (x, y)is reached or the request cannot be forwarded anymore. Note that (x, y)do not necessarily need to be coordinates of an existing node, i.e., in such a case the routing protocol may just stop at some node that is close to (x, y). Upon termination at node w, the reference of wis returned to the sender v(in the pseudocode we indicate this via a return statement). 1.2 Problem Statement In this paper we consider the standard deﬁnition for selfstabilization: Deﬁnition 1 (Selfstabilization) .A protocol is selfstabilizing w.r.t. a set of legitimate states if it satisﬁes the following two properties: 1.Convergence: Starting from an arbitrary system state, the protocol is guaranteed to 3arrive at a legitimate state. 2.Closure: Starting from a legitimate state, the protocol remains in legitimate states thereafter. We are interested in topological selfstabilization in this paper, meaning that our self stabilizing protocol is allowed to perform changes to the overlay network G. In order for our protocol to work, we require the directed graph Gcontaining all explicit and implicit edges to be at least weakly connected initially. Once there are multiple weakly connected components in G, these components cannot be connected to each other anymore as it has been shown in [ 12] for comparestoresend protocols. For a graph that contains multiple weakly connected components, our protocol converts each of these components to our desired topology. Consider the following deﬁnition of (standard) monotonic searchability: Deﬁnition 2 (Monotonic Searchability) .A selfstabilizing protocol satisﬁes monotonic searchability according to some routing protocol Rif it holds for any pair of nodes v, w that once a search request Search (v,(wx, wy))returns wat time t, any search request Search (v,(wx, wy))initiated at at time t/prime> talso returns w. Realizing monotonic searchability in selfstabilizing systems is a nontrivial problem, because once a Search (v,(wx, wy))request returns wtov, it cannot trivially be guaranteed that wis found again by vat later stages, due to the modiﬁcation of edges by the self stabilizing protocol. The above deﬁnition diﬀers in a minor detail compared to the deﬁnition stated in [ 16] [17]: The initial search request issued by vterminates at time t, but Scheideler et. al. deﬁne the time step tto be the one at which the initial search request was generated by v. They use a probing approach to check for a node vwhether vis still waiting for the result of a previously issued search request and cache all search requests searching for the same target. The same approach can be applied to our protocol as well to overcome this, but for the sake of simplicitiy we use the slightly modiﬁed deﬁnition stated above. In twodimensional scenarios it is more realistic to search for geographic positions rather than for concrete node addresses. To handle this, we introduce the following deﬁnition of geographic monotonic searchability. Deﬁnition 3 (Geographic Monotonic Searchability) .Let(x, y)∈[0,1]2be an arbitrary position in P. Let w∈Vbe the node that would be returned by Search (v,(x, y))if the system is in a legitimate state. A selfstabilizing protocol satisﬁes geographic monotonic searchability according to some routing protocol Rif in case the system is in an arbitrary state and Search (v,(x, y))returns wat time t, then any request Search (v,(x, y))initiated at time t/prime> talso returns w. 4This deﬁnition is even stronger than (standard) monotonic searchability, i.e., a pro tocol satisfying geographic monotonic searchability also satisﬁes monotonic searchability. Therefore we focus on geographic monotonic searchability for the rest of this paper. We aim to solve the following problem: Given a weakly connected graph of nnodes with coordinates in P, construct a selfstabilizing protocol along with a routing protocol such that geographic monotonic searchability is satisﬁed. 1.3 Our Contribution In the following we summarize our contributions: (1)We propose a novel selfstabilizing protocol BuildQuadTree that arranges the nodes in a quadtree. BuildQuadTree is based on a special kind of subdivision of Pinto subareas inducing an ordering via a spaceﬁlling curve (see Section 2) and theBuildList protocol (Section 3.1). To the best of our knowledge this is the ﬁrst selfstabilizing protocol for the quadtree structure. (2)Along with the selfstabilizing protocol BuildQuadTree we propose the routing pro tocol SearchQuad . When searching for coordinates (x, y), the protocol returns the node w, which lies within the same subarea as (x, y). We show that BuildQuadTree along with SearchQuad satisﬁes geographic monotonic searchability (and thus also standard monotonic searchability). (3)We get an upper bound of O(logn)on the number of hops for a search message (i.e, the amount of times a search message is delegated until it terminates) if we assume that the Euclidean distance ||(u, v)||between any pair of nodes (u, v)∈Vis at least 1/n. This is particularly an improvement on the protocols proposed in [ 16] [17] regarding the maximum number of hops for searching a target, even for target addresses that do not exist (see Section 1.4 on related work). (4)Finally, one can easily extend BuildQuadTree andSearchQuad to work in high dimensional settings, realizing the ﬁrst selfstabilizing protocol for octtrees  the highdimensional equivalent of quadtrees  that even satisﬁes geographic monotonic searchability. This makes our protocols highly versatile. The rest of the paper is structured as follows: After stating some related work, we describe our topology for the quadtree in Section 2. Then we present our novel protocol BuildQuadTree in Section 3 along with the routing protocol SearchQuad . Before we conclude in Section 6, we analyze our protocols in Section 4 and discuss how to extend BuildQuadTree andSearchQuad to work in highdimensional settings in Section 5. 51.4 Related Work "
363,MAC-aware Routing Metrics for the Internet of Things.txt,"Wireless medium access control (MAC) and routing protocols are fundamental
building blocks of the Internet of Things (IoT). As new IoT networking
standards are being proposed and different existing solutions patched,
evaluating the end-to-end performance of the network becomes challenging.
Specific solutions designed to be beneficial, when stacked may have detrimental
effects on the overall network performance. In this paper, an analysis of MAC
and routing protocols for IoT is provided with focus on the IEEE 802.15.4 MAC
and the IETF RPL standards. It is shown that existing routing metrics do not
account for the complex interactions between MAC and routing, and thus novel
metrics are proposed. This enables a protocol selection mechanism for selecting
the routing option and adapting the MAC parameters, given specific performance
constraints. Extensive analytical and experimental results show that the
behavior of the MAC protocol can hurt the performance of the routing protocol
and vice versa, unless these two are carefully optimized together by the
proposed method.","Internet of Things (IoT) has been introduced in 1999 to envis ion the concept of connecting physical objects, such as sensors and smart ph ones, supporting direct wireless connection to the internet. This enables an immense variety of applications in an Internetlike framework [1]. Any termin al connected to the Internet will be able to interact with these objects. Applic ations include among others, building and industrial automation, healthcare, personal wireless com munications, smart grids, and security. However, to suppor t such an increasing number of emerging applications, the wireless medium acces s control (MAC) and the routing protocols must be inherently scalable, interop erable, and they must have a solid standardization base to support future innovat ions. Diﬀerently from classic wireless ad hoc and sensor network ap plications, IoT applications have complex and heterogeneous requirements . The network perfor mance is not only measured in terms of throughput, but other i ndicators, such as reliability, delay, andenergy consumption, mustbejointl y optimized andadapted to diﬀerent application scenarios [2]. Assuming a network of several objects in terconnected to support an IoT application where eﬃcient in formation routing is essential, the decision over diﬀerent routing paths highly d epends on link perfor mance indicators, which are inﬂuenced by the MAC parameters . On the other side, the routing determines the distribution of the traﬃc l oad in the network, which signiﬁcantly aﬀects the aforementioned performance i ndicators. Therefore, it is ineﬃcient to design MAC and routing protocols separate ly and their joint adaptation is essential to achieve the desired network perf ormance. The essential question is which are the metrics that enable such an eﬃcient joint adaptation. By following a classic layered design process, standardiza tion bodies such as IEEE and Internet Engineering Task Force (IETF) are working independently on the design of the future MAC and routing protocols for IoT. According to 2recent surveys [3], the protocol stack for IoT applications integrates the IEEE 802.15.4 [4] standard for physical and MAC layers, and the IP v6 routing protocol for low power and lossy networks (RPL) [5]. The IEEE 802.15.4 deﬁnes ﬂexible physical and MAC layers for low data rate and low power applic ations. The standard has been adopted with some modiﬁcation also by a num ber of other so lutions, including ZigBee, WirelessHART, ISA100 [6], and it already represents more than 50% of the building and industrial automation mark et [7]. At the net workinglayers, theIPv6routingprotocol forlow power andl ossy networks (RPL) represents the reference standard proposed by the IETF for I Pv6compatible IoT applications. Inthis paper, weﬁrstemphasizethemaincharacteristics of theIEEE802.15.4 MAC and the IETF RPL protocols. We then present an analysis to characterize the protocols mutual eﬀects and their dynamics. In particula r, we show that the level of contention at the MAC layer impacts the routing d ecisions in an unexpected manner. In addition, we show that in the presence of dominant paths in the network, i.e., paths with high traﬃc forwarding , the performance indicators at the MAC layer are signiﬁcantly aﬀected. Based o n our analysis, we propose metrics that guide the interactions between MAC and routing, and we introduceamechanism that selects theappropriaterouting metricandadapts the corresponding MAC parameters to fulﬁll one of the most impor tant requirement of several IoT applications: minimize the energy consumpti on in the network, given reliability and delay constraints. Our methodology starts from the modeling of the behavior of t he current pro tocols, motivating in this ways the design of new eﬃcient met rics. The proposed metrics are numerically and experimentally validated in a r ealistic environment and in comparison to existing metrics. To the best of our know ledge this is the ﬁrst paper to present in depth modeling of the protocol inter actions, to propose cross layer routing metrics supported by a protocol selecti on and adaptation 3mechanism, and to give an extensive experimental study wher e approaches in literature are compared. We believe that the outcome of this work could give important insights to inﬂuence the standardization proces s for the IoT. The rest of the paper is organized as follows. In Section 2, we survey the re latedliterature. Section3, givesanoverviewofthebasicf unctionalities/parameters of the IEEE 802.15.4 MAC and the IETF RPL protocols. In Sectio n 4, we motivate our analysis and emphasize the importance of cross layer interactions, considering the requirements of IoT applications. In Secti on 5, the interactions among MAC and routing are modeled. Then, Section 6 presents n ovel MAC aware routing metrics, following the lines of our analysis. In Section 7, we present the experimental evaluation of the proposedmetrics in comp arison to existing ap proaches. Finally, Section 8 concludes the paper. 2. Related Work "
81,Accurate prediction of core-level spectra of radicals at density functional theory cost via square gradient minimization and recoupling of mixed configurations.txt,"State-specific orbital optimized approaches are more accurate at predicting
core-level spectra than traditional linear-response protocols, but their
utility had been restricted on account of the risk of `variational collapse'
down to the ground state. We employ the recently developed square gradient
minimization (SGM, J. Chem. Theory Comput. 16, 1699-1710, 2020) algorithm to
reliably avoid variational collapse and study the effectiveness of orbital
optimized density functional theory (DFT) at predicting second period element
1s core-level spectra of open-shell systems. Several density functionals
(including SCAN, B3LYP and $\omega$B97X-D3) are found to predict excitation
energies from the core to singly occupied levels to high accuracy ($\le 0.3$ eV
RMS error), against available experimental data. Higher excited states are
however more challenging by virtue of being intrinsically multiconfigurational.
We thus present a CI inspired route to self-consistently recouple single
determinant mixed configurations obtained from DFT, in order to obtain
approximate doublet states. This recoupling scheme is used to predict the C
K-edge spectra of the allyl radical, the O K-edge spectra of CO$^+$ and the N
K-edge of NO$_2$ to high accuracy relative to experiment, indicating
substantial promise in using this approach for computation of core-level
spectra for doublet species (vs more traditional time dependent DFT, EOM-CCSD
or using unrecoupled mixed configurations). We also present general guidelines
for computing core-excited states from orbital optimized DFT.",Linearresponse time dependent density functional theory (TDDFT)1{3is very widely used to model electronic excited states of chemical species. TDDFT is an appealing ap proach as it is computationally inexpensive ( O(N3
193,"A Process Algebra for Wireless Mesh Networks used for Modelling, Verifying and Analysing AODV.txt","We propose AWN (Algebra for Wireless Networks), a process algebra tailored to
the modelling of Mobile Ad hoc Network (MANET) and Wireless Mesh Network (WMN)
protocols. It combines novel treatments of local broadcast, conditional unicast
and data structures.
  In this framework we present a rigorous analysis of the Ad hoc On-Demand
Distance Vector (AODV) protocol, a popular routing protocol designed for MANETs
and WMNs, and one of the four protocols currently standardised by the IETF
MANET working group.
  We give a complete and unambiguous specification of this protocol, thereby
formalising the RFC of AODV, the de facto standard specification, given in
English prose. In doing so, we had to make non-evident assumptions to resolve
ambiguities occurring in that specification. Our formalisation models the exact
details of the core functionality of AODV, such as route maintenance and error
handling, and only omits timing aspects.
  The process algebra allows us to formalise and (dis)prove crucial properties
of mesh network routing protocols such as loop freedom and packet delivery. We
are the first to provide a detailed proof of loop freedom of AODV. In contrast
to evaluations using simulation or model checking, our proof is generic and
holds for any possible network scenario in terms of network topology, node
mobility, etc. Due to ambiguities and contradictions the RFC specification
allows several interpretations; we show for more than 5000 of them whether they
are loop free or not, thereby demonstrating how the reasoning and proofs can
relatively easily be adapted to protocol variants.
  Using our formal and unambiguous specification, we find shortcomings of AODV
that affect performance, e.g. the establishment of non-optimal routes, and some
routes not being found at all. We formalise improvements in the same process
algebra; carrying over the proofs is again easy.","2 AdhocOnDemandDistance Vector RoutingProtocol 4 2.1 BasicProtocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.2 Detailed Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 3 Abstractions Chosen 8 3.1 Timing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3.2 Optional Protocol Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3.3 Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 4 AProcess Algebra forWireless Mesh RoutingProtocols 10 4.1 ALanguage for Sequential Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 4.2 ALanguage for Parallel Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 4.3 ALanguage for Networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 4.4 Results on the Process Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 4.5 Optional Augmentation toEnsure NonBlocking Broadcas t . . . . . . . . . . . . . . . . 17 4.6 Illustrative Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 5 DataStructure forAODV 20 5.1 Mandatory Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 5.2 Sequence Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 5.3 Modelling Routes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 5.4 Routing Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 5.5 Updating Routing Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 5.5.1 Updating Precursor Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 5.5.2 Inserting NewInformation inRouting Tables . . . . . . . . . . . . . . . . . . . 24 5.5.3 Invalidating Routes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 5.6 Route Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 5.7 Queued Packets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 5.8 Messages and Message Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 5.9 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 6 ModellingAODV 30 6.1 TheBasic Routine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 6.2 DataPacket Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 6.3 Receiving Route Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 6.4 Receiving Route Replies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 6.5 Receiving Route Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 6.6 TheMessage Queue and Synchronisation . . . . . . . . . . . . . . . . . . . . . . . . . 37 6.7 Initial State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 7 Invariants 38 7.1 Stateand Transition Invariants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 7.2 Notions and Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 7.3 BasicProperties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 7.4 WellDeﬁnedness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46A.Fehnker, R.J.van Glabbeek, P.H¨ ofner, A.McIver, M.Port mann &W.L.Tan iii 7.5 TheQuality of Routing Table Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 7.6 LoopFreedom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 7.7 Route Correctness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 7.8 Further Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 7.8.1 Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 8 7.8.2 Route Requests and RREQIDs . . . . . . . . . . . . . . . . . . . . . . . . . . 59 7.8.3 Routing Table Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 8 Interpreting theIETFRFC3561 Speciﬁcation 62 8.1 Decreasing Destination Sequence Numbers . . . . . . . . . . . . . . . . . . . . . . . . 62 8.2 Interpreting theRFC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 8.2.1 Updating Routing Table Entries . . . . . . . . . . . . . . . . . . . . . . . . . . 63 8.2.2 SelfEntries inRouting Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 8.2.3 Invalidating Routing TableEntries . . . . . . . . . . . . . . . . . . . . . . . . . 75 8.2.4 Further Ambiguities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 8.2.5 Further Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 8.3 Implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 8.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 9 Formalising Temporal Properties of RoutingProtocols 89 9.1 Progress, Justness and Fairness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 9.2 Route Discovery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 9.3 Packet Delivery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 10 AnalysingAODV—ProblemsandImprovements 102 10.1 Skipping the RREQID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 10.2 Forwarding the Route Reply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 10.3 Updating withthe Unknown Sequence Number . . . . . . . . . . . . . . . . . . . . . . 107 10.4 FromGroupcast toBroadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 10.5 Forwarding the Route Request . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 11 Related Work 119 "
284,Formal Black-Box Analysis of Routing Protocol Implementations.txt,"The Internet infrastructure relies entirely on open standards for its routing
protocols. However, the majority of routers on the Internet are closed-source.
Hence, there is no straightforward way to analyze them. Specifically, one
cannot easily identify deviations of a router's routing functionality from the
routing protocol's standard. Such deviations (either deliberate or inadvertent)
are particularly important to identify since they may degrade the security or
resiliency of the network.
  A model-based testing procedure is a technique that allows to systematically
generate tests based on a model of the system to be tested; thereby finding
deviations in the system compared to the model. However, applying such an
approach to a complex multi-party routing protocol requires a prohibitively
high number of tests to cover the desired functionality. We propose efficient
and practical optimizations to the model-based testing procedure that are
tailored to the analysis of routing protocols. These optimizations allow to
devise a formal black-box method to unearth deviations in closed-source routing
protocols' implementations. The method relies only on the ability to test the
targeted protocol implementation and observe its output. Identification of the
deviations is fully automatic.
  We evaluate our method against one of the complex and widely used routing
protocols on the Internet -- OSPF. We search for deviations in the OSPF
implementation of Cisco. Our evaluation identified numerous significant
deviations that can be abused to compromise the security of a network. The
deviations were confirmed by Cisco. We further employed our method to analyze
the OSPF implementation of the Quagga Routing Suite. The analysis revealed one
significant deviation. Subsequent to the disclosure of the deviations some of
them were also identified by IBM, Lenovo and Huawei in their own products.","The Internet owes much of its success to open standards. These standards are being developed in an iterative and open process. They are the fruit of extensive delibera tions, trial implementations, and testing. Furthermore, open standards are thoroughly documented and freely available, so they can be readily scrutinized at any time even after their creation. It is generally believed that open standards led to a more robust and secure Inter net. Routing protocols are a prime example of open stan dards. They are a critical part of the Internet infrastruc ture, allowing seamless interoperability between separate networks. In stark contrast to the open nature of routing proto col standards, the Internet infrastructure predominantly relies on proprietary and closedsource routers made by large vendors like Cisco. A router’s vendor can add, re move or alter the standardized functionality of a rout ing protocol as it sees ﬁt, as long as interoperability with other vendors’ routers is preserved. Even so, it is not uncommon to have two routers of different ven dors that, under some networking scenarios, cannot co operate seamlessly [17]. Vendors have several possible motivations for deviating from the standardized function ality [5]: development cost reduction, optimization of the protocol functions, or increasing customers’ switching cost to other vendors. Additionally, inadvertent devia tions may rise due to misunderstanding of the standard or failure to implement it completely. Identifying these deviations is crucial to assessing their full impact on a network’s resilience and security. But the routers’ closed source makes this a difﬁcult chal lenge for the security community. To address this chal lenge, we leverage formal analysis methods that assist in identifying deviations of a routing protocol implementaarXiv:1709.08096v1  [cs.CR]  23 Sep 2017tion from its standard. Our analysis is blackbox: access to the implementation’s source code or binary code is not required. We only assume the ability to send pack ets to the router and observe its external behavior. This includes the packets sent by the router and information explicitly available through its user interface. Its black box nature makes our analysis applicable to any router with minimal changes. We use a modelbased testing approach [9, 35] in which a reference model of a system under test (SUT) is formulated. The model embodies the desired func tionality for that system and serves as the basis for test generation. Each test has a desired outcome as deter mined by the model. The tests are then executed against the SUT and the resulting outcome is compared to the desired result. In our case, the model is formally de ﬁned according to the protocol’s standard. The SUT is the router’s implementation of the protocol, and a failed test indicates a deviation of the implementation from the standard. We use concolic execution [21, 30] to automat ically generate tests from our model. Concolic testing is a dynamic symbolic execution technique for system atically generating tests along different execution paths of a program. It involves concrete runs of the program over concrete input values alongside symbolic execution. Each concrete execution is on a different path. The paths are explored systematically and automatically until full coverage is achieved. The modelbased testing approach has been success fully employed to ﬁnd bugs in open source software as well as in opensource implementations of onetoone network protocols such as TCP and UDP [13]. How ever, routing protocols involve multiple participants. In the realm of these complex multiparty protocols, model based testing can not be practically applied due to scal ability issues. The functionality of routing protocols de pends on the dynamics between the participants, their relative locations in the network, and the role each par ticipant plays. A certain protocol may expose parts of its functionality only in speciﬁc complex interactions be tween the participants. Therefore, the number of tests re quired to verify the protocol’s functionality may be pro hibitively high. We propose practical optimizations to the model based testing procedure that signiﬁcantly reduce the number of tests generated while still covering the en tire functionality of the model. Our main optimization merges different tests that pass through a joint intermedi ate state. Namely, we merge two long test scenarios that reach the same intermediate state into a single shorter test scenario that starts from the intermediate joint state. This optimization is especially useful for test scenarios in which multiple packets are sent. For example, consider two nonidentical sequences of packets, P1 and P2, thatare sent during two test scenarios, t1 and t2, respectively. Assume that the model ends up in the same ﬁnal state fol lowing each of the two tests. Therefore, a test having a sequence of packets of the form P1jjP(the sequence of packets in P1 followed by a sequence of packets in P) can be merged with a test that has the sequence P2jjP. The merged test shall have a sequence of packets Pand it should be executed from an initial state that is identical to the intermediate joint state of the original two tests. Our optimized method allowed us to implement the ﬁrst practical tool to automatically identify deviations in blackbox implementations of one of the most complex and widely deployed routing protocols on the Internet – OSPF (Open Shortest Path First) [25]. The OSPF pro tocol is a widely used intradomain routing protocol de ployed in many enterprise and ISP networks. We applied the tool to search for deviations in the OSPF implementa tion of the largest router vendor in the world – Cisco. We analyzed three different versions of Cisco’s implementa tion of OSPF in IOS1and found 7 signiﬁcant deviations, most of which compromise the security of the network. Two of them were found in the latest version of IOS. The deviations were acknowledged by Cisco. To further demonstrate the generality of our tool, we also employed it to analyze the OSPF implementation of the Quagga Routing Suite [3] – the most popular open source routing software. The analysis of Quagga re vealed one signiﬁcant deviation. To summarize, our contributions are as follows: 1. We propose efﬁcient optimizations to the applica tion of modelbased testing to routing protocols. 2. We devised the ﬁrst practical tool that automatically identiﬁes deviations in blackbox implementations of the OSPF routing protocol. 3. We found multiple logical vulnerabilities in widely used OSPF implementations by Cisco, Quagga and others. The remainder of the paper is organized as follows, Section 2 gives background on symbolic execution and concolic testing. Section 3 discusses the formal proce dures we use to analyze an implementation of a routing protocol and the optimizations we employ to reduce the number of tests. In Section 4 we describe the application of the formal procedures to a tool that analyzes OSPF implementations. In Section 5 we describe the evalua tion of the method against Cisco’s and Quagga’s OSPF implementation and detail the deviations we discovered. Section 6 discusses the advantages and limitations of our 1Cisco’s IOS is a software family that implements all network ing and operating system functionality in many of Cisco’s routers and switches. 2approach. Finally, Section 7 presents related work and Section 8 concludes the paper. 2 Preliminaries 2.1 Symbolic execution Symbolic execution [16] allows analyzing the execution paths of a program and generating corresponding test cases. The input variables of the program are deﬁned as symbolic variables. Then, the program is symboli cally run, where symbolic expressions represent values of the program variables. On each execution path a constraint is obtained by collecting all the symbolic ex pressions that correspond to conditional branches on that path. The pathconstraint is a quantiﬁerfree ﬁrstorder formula over the symbolic variables. Its solutions form a set of concrete values of the input variables for which the program runs via the same execution path. A test that covers this path is then derived from this solution, con taining concrete values of the input variables. Concolic testing ([21, 30]) is a dynamic symbolic ex ecution technique to systematically generate tests along different execution paths of a program. It involves con crete runs of the program over concrete input values alongside symbolic execution. Initially, some random concrete input values are chosen. During a run of the pro gram with this input, symbolic constraints are gathered over the conditional branches of the current execution. Thus, at the end of the run the symbolic pathconstraint is obtained. A constraint solver is then used to construct the next concrete execution on a different path. This can be achieved, for instance, by negating the last conjunct on the pathconstraint not already negated. A new solu tion for the variant of the pathconstraint with negations should necessarily steer a new concrete execution over a different path. This process is repeated systematically and automatically. Finally, the process terminates based on some time limit, coverage criteria, or when full cov erage is achieved. 2.2 Threat Model Our analysis is securitymotivated, namely we seek to ﬁnd deviations in routing protocol implementations that may compromise the security of the network. To serve this purpose we design the model, on which we base our testing, such that it incorporates an attacker model that ﬁts a plausible threat to the network. We adopt the common threat model found in the literature ([37, 39, 23, 26]). This model assumes the attacker has the ability to send routing advertisements to any router within the rout ing domain. This assumption can be trivially achieved by an attacker that gained control over a single router Figure 1: The ﬂow of our method within the routing domain. The attacker can gain control of a router, for example, by remotely exploiting an imple mentation vulnerability on the router. Several such vul nerabilities have been published in the past (e.g., CVE 20100581, CVE20100580, and CVE20092865). The attacker’s goal is to poison the routing tables of other routers. Because the attacker would like to control the routing domain for an extended period of time, the poisoning should be persistent. Namely, the attack’s ef fects will not be immediately reverted once the attacker ﬁnishes executing the attack. 3 Blackbox analysis procedures In this section we describe the procedures that compose our method of analyzing a routing protocol. We use a modelbased testing approach. The model includes a network topology, where each node executes its mod eled protocol. We test the protocol’s functionalities by systematically generating protocol messages and sending them to nodes within the network topology. Each sent message triggers a different execution path of the model. The details of the method’s ﬂow are given in Section 3.1. Generally speaking, the described method ﬂow can be applied to any network protocol; however, a naive appli cation of this method to a complex multiparty routing protocol will have severe scalability issues in the con colic execution phase, known as the path explosion prob lem. In this phase a prohibitively high number of tests may be generated. In Section 3.3 we propose optimiza tions that reduce the number of tests generated without loss of functionality cover of the model. 3.1 The method ﬂow The method ﬂow is depicted in Figure 1. Below we ex plain each numbered box in that ﬁgure: 1. Produce a symbolic model of a network topology on which the protocol will be executed. Symbolic 3topology can represent any concrete topology. It al lows us to generate tests of the protocol under var ious topologies, thereby covering speciﬁc protocol behaviors that are topologydependent. The sym bolic topology is fed to the next stage in the process. We further elaborate on the symbolic model of the network topology we use in Section 3.2. 2. Given a symbolic network topology, the model pro duces a run of the protocol. Each execution path of the model is represented by a concrete run that starts from the standard initial state on the chosen topology. In the standard initial state, all the nodes are consistent and stable. Additionally, all their in coming message queues are empty. During the run, messages of the protocol are sent to the nodes, and the run terminates in a stable state after no messages are sent between any nodes on the network. 3. Applying the concolic execution tool on the sym bolic model of the routing protocol generates a test ﬁle for each execution path of the model. Each test ﬁle contains the sent message and the initial and ﬁ nal local states for all nodes in the network. Each execution path is ﬁnite and reaches a stable state in which there are no more messages that need to be sent between the routers. 4. Each generated test ﬁle is executed on the SUT. During the test execution the routers are activated and initialized according to the model’s initial state. Then one or more messages are sent to the routers, and after the routers’ states become stable again, they are read and compared to the expected state obtained from the model. If the existing state of the routers does not match the model’s expected state, the test fails. 5. A failed test represents a deviation of the SUT’s im plementation from the protocol standard. The failed test is accompanied with traces of all messages ex changed between the routers during the run of the test, both on the model and on the SUT. Comparing these traces facilitates the analysis of the deviation. The main advantages of the above method is as fol lows: 1. Automatic – once the protocol’s model and topol ogy are determined, the identiﬁcation of deviations is fully automatic. A deviation may pose a security vulnerability in the SUT, but this is not always the case. Further manual analysis is required to infer what kind of effect the deviation has on security of the implementation.2. Full coverage – the generated tests cover the entire functionality of the protocol’s model. This allows to test the model against relatively small topologies with few routers while still being able to check ob scure corners of the protocol. Our evaluation in Sec tion 5 illustrates this very nicely. 3. Modularity – the analyzed model need not detail the protocol in its entirety. The model may only include parts of the protocol deemed relevant to the secu rity analysis or parts that may be considered more prone to deviate from the standard. The model may abstract away irrelevant details or even omit them entirely. Furthermore, the analysis may also be split into separate stages, each focusing on a speciﬁc part of the protocol. 3.2 The topology symbolic model We model two types of network links: pointtopoint and multiple access. The former connects only two routers while the latter connects any number of routers. Gener ally, the two link types are handled differently by routing protocols in terms of the routing advertisements describ ing them. We assume the topology has a predetermined number of routers and a predetermined number of mul tiple access links, denoted by nandm, respectively. A symbolic topology model represents any topology that hasnrouters and mmultiple access links. We do not constrain the number of pointtopoint links; it can be any number between 0 andn(n"
420,Routing Protocols Performance in Mobile Ad-Hoc Networks Using Millimeter Wave.txt,"Self-Organized networks (SONs) have been studied for many years, and have
attracted many researchers due to their substantial applications. Although the
performance of such networks in the lower band networks (sub-6 GHz band
frequencies) has been well studied, there are only sparse studies on SON in
higher frequency bands, such as the millimeter wave (mmWave) band ranges
between 28GHz and 300GHz. mmWave frequencies have attracted many researchers in
the past few years because of its unique features and are now considered as an
important part of the next generation of wireless communications namely (5G).In
this paper, we study the performance of some well-known routing protocols in
the case of mmWave Mobile Ad hoc Networks (MANET) using the ns-3 mmwave module
that was developed recently. SONs are within the goals for the next release of
the 3GPP New Radio (NR) standardization process (Release-16) for the 5G, which
makes the study of the behavior of such frequency bands for these networks an
important activity towards achieving such goal. Mathematical and simulation
results show a great improvement in the routing protocols delivery rates and
power consumption when using mmWave compared to the sub6GHz band frequencies.","  Mobile Adhoc Networks (MANETs) have been studied f or many years and they are the  networks formed solely from mobile User Equipement (EU) that are cooperating to exchange  data in an Infrastructureless environment [4]. MAN ET can be used for many applications include  the tactical edge operations, disastrous areas, and  in the congested environments like campuses  and stadiums where many users are willing to exchan ge information directly with each other or  using others’ devices are routers. Fifth generation  (5G) of wireless communications is intended to  provide much higher data rates and much lower endt oend overtheair (OTA) latency [7]. Some  prospective applications for the 5G (besides the tr aditional cellular communications) are the  wireless virtual reality (VR), Augmented Reality (A R), Device to Device (D2D) communications  in the network edges, and the autonomous vehicles i n the Vehicular Adhoc Networks (VANET)  [1], [7], which can be part of an infrastructural o r infrastructureless networks. Millimeter wave  frequencies (mmWave) are expected to have a major r ole in the 5G standards [2]. They have their  advantages of huge available bandwidth (several GHz ) and reduced delay, while they also have  some limitations that are related to the limited tr ansmission range, and the need for transmitting  narrow beams to cover larger distances. This work i s intended to test the performance of a mobile  adhoc network that consists of only mmWave user eq uipment (UE) without eNodeB (or gNodeB  as suggested recently by the 3GPP [3]). The deliver y ratio of data that is transmitted between any International Journal of Computer Networks & Commun ications (IJCNC) Vol.10, No.4, July 2018  24  two mobile nodes in the network is of a significant  importance for the feasibility and stability of  the mmWave MANET applications. This type of network s with dynamic topology (because of  mobility and lack of Infrastructure) is unsuitable for traditional endtoend routing algorithms,  and that is why many MANET routing protocols have b een proposed to control forwarding data  from any node to any other node in the multihop MA NET network [4].    Traditional routing protocols for adhoc networks a re usually dependent on the broadcast nature  of wireless signals in the sub6 GHz band [8]. With  the mmWave’s directional antennas and  beam forming, this argument about wireless signals is no longer true. To compensate for such a  shortage, mmWave devices use many approaches to sca n the entire environment around them like  beam sweeping, random beam forming (RBF), et al. [2 0] and send narrow directional beams  towards the intended destination nodes to mitigate the large propagation path loss.    Our contributions can be summarized as:    • We list some of the well known and the recently s uggested channel models and the  corresponding path propagation loss and the expecte d received power for each case.    • We investigate the effect of multiple mmWave chan nel models (for different environments) that  have been measured in recent years [12], [14] on th e performance (delivery rate, error rate,  energy efficiency, ...etc.) of some wellknown MANE T routing protocols in the literature.    • We prove with the help of simulation that using m mWave frequency bands (ex. 28GHz) with  the traditional routing protocols for mobile ad hoc  networks can improve the performance and  reduce the energy consumption to a large extent.    The rest of this paper will be organized as follows . Section 2 will show some related work to the  MANET generally and the mmWave in MANET. Section 3 will explain some features of the  used protocols and how their performance is expecte d to improve by using mmWave frequencies.  In sections 4 and 5, we will talk about the perform ance evaluation metrics and the results of  performance evaluation respectively. Finally, secti on 6 will conclude the paper and give some  ideas about our future work in this field.    2.  RELATED WORK   "
313,VOUTE-Virtual Overlays Using Tree Embeddings.txt,"Friend-to-friend (F2F) overlays, which restrict direct communication to
mutually trusted parties, are a promising substrate for privacy-preserving
communication due to their inherent membership-concealment and
Sybil-resistance. Yet, existing F2F overlays suffer from a low performance, are
vulnerable to denial-of-service attacks, or fail to provide anonymity. In
particular, greedy embeddings allow highly efficient communication in arbitrary
connectivity-restricted overlays but require communicating parties to reveal
their identity. In this paper, we present a privacy-preserving routing scheme
for greedy embeddings based on anonymous return addresses rather than
identifying node coordinates. We prove that the presented algorithm are highly
scalalbe, with regard to the complexity of both the routing and the
stabilization protocols. Furthermore, we show that the return addresses provide
plausible deniability for both sender and receiver. We further enhance the
routing's resilience by using multiple embeddings and propose a method for
efficient content addressing. Our simulation study on real-world data indicates
that our approach is highly efficient and effectively mitigates failures as
well as powerful denial-of-service attacks.","Anonymous and censorshipresistant communication is essential for providing freedom of speech. In the last years, threats to this essential human right have emerged in western countries as well, mainly in the form of selfcensorship caused by the fear of seemingly private communication being recorded1. Due to the natural vulnerability of publicly known servers to sabotage and corruption, completely distributed solutions for anonymous communication and content dis tribution are required. However, the openness of distributed systems presents a vulnerability, enabling attackers to inltrate the system with a large number of forged participants, as can seen e.g., from attacks on the Tor [1] network in 1http://www.theguardian.com/commentisfree/2013/jun/17/chillingeffectnsasurveillanceinternet 1arXiv:1601.06119v1  [cs.CR]  22 Jan 201620142. F2F overlays circumvent the problem of connecting to permanently changing strangers by restricting connectivity to participants sharing a mutual realworld trust relationship. Hence, adversaries need to resort to social engineering attacks for inltration of the network. However, largescale privacypreserving commu nication in F2F overlays requires additional measures to achieve anonymity, failure and attack resilience, and eciency. Multiple studies have shown that deployed F2F overlays such as Freenet [2] are highly inecient and vulnerable to attacks [3,4]. Virtual overlays have been proposed as an ecient alternative [3,5], but recent work has shown that they inherently require unacceptable high stabilization costs [6]. A potential solution is presented by greedy network embeddings such as [7, 8]. Greedy embeddings allow for highly ecient greedy routing in arbitrary connectivityrestricted overlays. For this purpose, they rst construct a span ning tree of the network and then assign coordinates based on a node's position in the spanning tree. However, a participant can only contact a nontrusted con tact when knowing its coordinate in the network. Though only direct neighbors can directly map the embedding coordinate to a realworld identity, arbitrary participants can reconstruct the social graph based on the revealed coordinates. Participants can then easily be identied from the social graph structure [9] and correlated with their activities in the network due to the coordinate acting as a persistent pseudonym. In this manner, governmental and commercial institu tions as well as curious strangers can track individual or all users and establish detailed proles of their behavior. Possibly even their opinions and interests, published unencrypted in a supposedly anonymous manner, are revealed to the adversary. Thus, network embeddings in their unaltered form fail to provide receiver anonymity. For utilizing the high eciency of network embedding, our rst requirement is a modied addressing and routing protocol that provides both eciency and (receiver) anonymity. Second, due to the fragility of spanning trees in the pres ence of network dynamics and attacks, the resilience of the embedding to both failures and denialofservice attacks needs to be drastically increased. Rather than only dropping messages, we assume that the adversary rst strategically sabotages the embedding algorithm to maximize the impact of its censorship. Third, ecient content storage and retrieval requires the existence of a suitable content addressing scheme for network embeddings. Our solution addresses the above problems by i) introducing anonymous return addresses to provide receiver anonymity, ii) constructing multiple em beddings and using backtracking during routing to increase the resilience, and iii) utilizing the network embedding to provide a routing protocol for a vir tual overlay, thus avoiding the enormous stabilization costs of previous virtual overlays. Our embedding algorithm assigns coordinates in the form of vectors of bbit strings, so that nodes in the same subtree of the spanning tree share the same 2https://blog.torproject.org/blog/torsecurityadvisoryrelayearlytrafficconfirmationattack 2prex, similar to the PIE embedding [8]. Rather than revealing the coordinate, the receiver then generates an anonymous return address by applying a hash cascade to the elements of the coordinate vector salted with a random seed. After publishing the return address and the seed, the receiver can be contacted eciently without revealing any information that is not required for routing. Furthermore, a node can publish several anonymous return addresses by vary ing the seed, In this manner, it can construct distinct pseudonyms for distinct contexts, e.g., one pseudonym for each forum discussion it participates in. The revealed information can be further reduced by applying an additional layer of encryption at the price of a reduced eciency. By routing in multiple embeddings, we aim to increase the probability of nding a route despite the disruption of routes in some but not all embeddings. We propose a purely local algorithm for the construction of multiple spanning trees of highly dierent structures to provide largely nodeindependent routes. In addition, backtracking and a modied distance are integrated into the routing to further improve resilience and avoid congestion. We evaluate our solution both by a formal security analysis and an exten sive simulation study. In the security analysis, we prove a receiver can never be uniquely identied from a return address. Our simulation study indicates that our scheme is highly ecient compared existing approaches in terms of the number of messages required for routing. Furthermore, the resilience is greatly improved. In fact, the routing terminates successfully in the vast majority of cases despite the presence of node failures or powerful attackers, which manip ulate the embedding and routing as well as forge connections to honest nodes. 2 Related Work "
335,Performance Analysis of Probabilistic Rebroadcasting in Grid FSR for MANET.txt,"Mobile Ad-hoc Network (MANET) is the self organizing collection of mobile
nodes. The communication in MANET is done via a wireless media. Ad hoc wireless
networks have massive commercial and military potential because of their
mobility support. Due to demanding real time multimedia applications, Quality
of Services (QoS) support in such infrastructure less networks have become
essential. QoS routing in mobile Ad-Hoc networks is challenging due to rapid
change in network topology. In this paper, we focused to reduce flooding
performance of the Fisheye State Routing (FSR) protocol in Grid using ns-2
network simulator under different performance metrics scenario in respect to
number of Nodes. For example, the connection establishment is costly in terms
of time and resource where the network is mostly affected by connection request
flooding. The proposed approach presents a way to reduce flooding in MANETs.
Flooding is dictated by the propagation of connection-request packets from the
source to its neighborhood nodes. The proposed architecture embarks on the
concept of sharing neighborhood information. The proposed approach focuses on
exposing its neighborhood peer to another node that is referred to as its
friend-node, which had requested/forwarded connection request. If there is a
high probability for the friend node to communicate through the exposed routes,
this could improve the efficacy of bandwidth utilization by reducing flooding,
as the routes have been acquired, without any broadcasts. Friendship between
nodes is quantized based on empirical computations and heuristic algorithms.
The nodes store the neighborhood information in their cache that is
periodically verified for consistency. Simulation results show the performance
of this proposed method.","The principal objective of a routing protocol is efficient  discovery and establishment of a route between the source and the destination so that there can be a timely and efficient  delivery of information between them. A Locating Service is  used to locate the receiver inside the network. It dynamically maps the logical address of the receiver to its current location    in   the   network.   Once   the   receiver   is located, routing  and forwarding algorithms are used to route the information through the MANET. The routing is done using onehop transmission service provided by the enabling technologies to  construct an endtoend (reliabl e) delivery services, from  sender to one or more receivers.  A  number  of features are  expected to be supported by the routing protocols  which  include  parameters  like  minimal control  &  processing   overhead,  loop  freedom  & prevention, efficient dynamic  topology establishment and maintenance, scalability,  support for unidirectional links, security & reliability and support for  Quality of Service.[4,5]  The rest of this paper is organized as follows: First of all, we  make a brief survey on FSR in section II with my previous research work. In section III, proposed work in grid FSR to  reduce flooding. Section IV presents the Results and Discussion.  Section V presents the Simulation Results of performance evaluation of various Parameters and section VI concludes the  paper.       2.     Related work  "
451,A Novel Approach to Quality of Service Provisioning in Trusted Relay Quantum Key Distribution Networks.txt,"In recent years, noticeable progress has been made in the development of
quantum equipment, reflected through the number of successful demonstrations of
Quantum Key Distribution (QKD) technology. Although they showcase the great
achievements of QKD, many practical difficulties still need to be resolved.
Inspired by the significant similarity between mobile ad-hoc networks and QKD
technology, we propose a novel quality of service (QoS) model including new
metrics for determining the states of public and quantum channels as well as a
comprehensive metric of the QKD link. We also propose a novel routing protocol
to achieve high-level scalability and minimize consumption of cryptographic
keys. Given the limited mobility of nodes in QKD networks, our routing protocol
uses the geographical distance and calculated link states to determine the
optimal route. It also benefits from a caching mechanism and detection of
returning loops to provide effective forwarding while minimizing key
consumption and achieving the desired utilization of network links. Simulation
results are presented to demonstrate the validity and accuracy of the proposed
solutions.","DURING the 30 years since the discovery of the ﬁrst quantum protocol [1], quantum technology has grown signiﬁcantly and is rapidly approaching high levels of maturity. The next natural step in the evolution of quantum systems is to study their performance, suitability and convergence with applications used in everyday life. Signiﬁcant progress in the development of quantum equipment has been reﬂected through a number of successful demonstrations of QKD networks [2– 7] but without showing the clear suitability to assess how such networks compete with their classical counterparts under M. Mehic is with Department of Telecommunications, Faculty of Electrical Engineering, University of Sarajevo, Bosnia and Herzegovina and VSBTechnical University of Ostrava, Czech Republic; email: mi ralem.mehic@ieee.org P. Fazio is with Department DIMES, University of Calabria, Italy S. Rass is with the System Security Group, Institute of Applied Informatics, AlpenAdria Universität Klagenfurt, A9020 Klagenfurt, Austria O. Maurhart is with AIT Austrian Institute of Technology GmbH, Digital Safety & Security Department, Vienna, Austria M. Peev and A.Poppe are with Huawei Technologies Duesseldorf GmbH, Munich, Germany J.Rozhon and M.V oznak are with the VSBTechnical University of Ostrava, Czech Republic M. Niemiec is with AGH University of Science and Technology, Krakow, Poland TCOM version based on Michael Shell’s bare_jrnl.tex version 1.3.reallife conditions and in realtime trafﬁc. The trafﬁc in these networks was mainly considered with equal importance and it was treated with same priority. While such approach may be acceptable for some applications, it is not suitable for voice, video and collaborative applications. Since not all network trafﬁc is equal, it should not be treated equally. Hence, different applications may have different service requirements with respect to quality of service (QoS). This paper addresses the question of using realtime communication in QKD net works by considering QoS mechanisms. The primary goal is to provide an adequate QoS model that includes trafﬁc classiﬁcation and marking mechanisms, QKD link metrics that can be used to accurately describe the state of the network, and a scalable routing protocol that minimizes the consumption of key material through equitable utilization of network resources. QKD networks differ from traditional networks in several aspects: Although theoretical and pioneering results have been published in the ﬁeld of quantum repeaters and quantum relays [8–10], in practice they remain unachievable with current technology1[11, 13]. Therefore, communication is realized in a hopbyhop [2] or key relay manner [3, 14]. Both methods rely on the assumption that all nodes along the path between the sender and the receiver must be fully trusted, forming a trusted relay QKD network [2, 15, 16]. Nodes are connected with QKD logical links, referred to below as links, which employ two distinct channels: a quantum channel, which is used for transmission of raw cryptographic keys encoded in certain photon properties, and a public channel, used for veriﬁcation and process ing of the exchanged values. Each quantum channel is always a pointtopoint connection between exactly two nodes [17], while public channels can be implemented 1The idea behind implementing quantum routers is to use quantum entan glement of photons to communicate over different quantum channels. In short, it means that multiple particles are linked together such that the measurement of one particle’s quantum state determines the possible quantum states of the other particles. Even when the particles are separated by a large distance, they still make up a joint quantum system. The ﬁdelity of a quantum state decreases exponentially with the distance of its qubits due to noisy quantum channels [11, 12]. In addition, quantum memory is required to implement a quantum repeater according to [9, 10]. Although implementations of quantum memories exist, which can store a qubit for between several milliseconds to one second or even more, this is still too short for practical applications.arXiv:1810.03857v2  [cs.NI]  10 Oct 2018JOURNAL OF L ATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015 2 as any conventional connection which can include an arbitrary number of intermediate devices [18]. The key rate is interconnected with a length of optical ﬁber such that a longer distance implies a lower key rate due to absorption and scattering of photons [11, 19– 21]. Although key rates of 1 Mbps and above have been achieved [5, 22–24], such solutions are limited to very short distances. Therefore, both endpoints of the corre sponding link implement key buffers (storages) of limited capacity, which are gradually ﬁlled at their maximum key rate with the processed cryptographic key, referred to below as key material, and subsequently used for encryption/decryption of data ﬂow [17, 25]. Key material denotes the symmetric cryptographic keys that are gener ated during the QKD process, stored in buffers (storages) and used subsequently for cryptographic operations over user trafﬁc. Without key material, cryptographic operations cannot be performed, and a link can be described as temporarily unavailable [15]. To provide informationtheoretically se cure (ITS) communication, the key tends to be applied with a OneTime Pad (OTP) cipher and authenticated using an ITS message authentication scheme such as WegmanCarter when communicating over a public chan nel [26–28]. As a result, ITS communication requires more bits of key material than the length of the secured message [17]. The type of encryption algorithm used and the volume of network trafﬁc to be encrypted determines the key storage emptying speed, referred to as the key consumption rate. The key consumption rate denotes the rate of key material being taken from buffers (storages) and used for cryptographic operations. Similarly, the charging key rate (or simply key rate) denotes the rate of new key material generation, that is, the rate of adding new keys to the buffers (storages) [3, 17, 29]. To meet the requirement to bypass untrusted nodes, in practice, QKD networks are usually deployed as overlay pointtopoint networks which exhibit selﬁsh behavior, acting strategically to optimize performance and resulting in dynamic and unpredictable link performance [17, 25, 30–32]. Overlay networks use existing underlying net works in an attempt to implement a better service; one of their most important features is the independence of the path offered by Internet service providers (ISP). This paper is organized as follows: Section II covers re lated work, Section III points out the signiﬁcant resemblance between QKD and adhoc networks, and Section IV deﬁnes the requirements for providing QoS in QKD networks. In Section V we propose a novel QoS model including a GP SRQ routing protocol. The simulation setup is presented in Section VII, with Section VIIA presenting the evaluation of obtained results. Section VIII concludes the paper. II. R ELATED WORK "
320,Relational Deep Reinforcement Learning for Routing in Wireless Networks.txt,"While routing in wireless networks has been studied extensively, existing
protocols are typically designed for a specific set of network conditions and
so cannot accommodate any drastic changes in those conditions. For instance,
protocols designed for connected networks cannot be easily applied to
disconnected networks. In this paper, we develop a distributed routing strategy
based on deep reinforcement learning that generalizes to diverse traffic
patterns, congestion levels, network connectivity, and link dynamics. We make
the following key innovations in our design: (i) the use of relational features
as inputs to the deep neural network approximating the decision space, which
enables our algorithm to generalize to diverse network conditions, (ii) the use
of packet-centric decisions to transform the routing problem into an episodic
task by viewing packets, rather than wireless devices, as reinforcement
learning agents, which provides a natural way to propagate and model rewards
accurately during learning, and (iii) the use of extended-time actions to model
the time spent by a packet waiting in a queue, which reduces the amount of
training data needed and allows the learning algorithm to converge more
quickly. We evaluate our routing algorithm using a packet-level simulator and
show that the policy our algorithm learns during training is able to generalize
to larger and more congested networks, different topologies, and diverse link
dynamics. Our algorithm outperforms shortest path and backpressure routing with
respect to packets delivered and delay per packet.","The problem of routing in wireless networks is much more challenging than that in wired networks: the shared nature of the wireless medium reduces perdevice bandwidth, while the variability of wireless signal propagation and device mobility introduce topology uncertainty. While many routing algorithms have been developed for wireless networks (see §III), they typically assume operation under very speciﬁc network conditions. For example, routing algorithms developed for ad hoc networks assume an always connected network, with a focus on ﬁnding an optimal path (e.g., in terms of latency) from a source to a destination; conversely, routing strategies for delay or disruption tolerant networks assume a mostly disconnected network, and hence the focus is to determine, after encountering another device, whether to forward a packet to that device, so as to optimize some performance criteria (e.g., the latency until the packet is delivered to the destination). In this paper, we ask the following question: Can we design a generalizable routing algorithm that seamlessly adapts to different network conditions? In other words, we seek to design a routing algorithm that works regardless of trafﬁc pattern,congestion level, network connectivity, or link dynamics. Such a strategy is desirable since the optimal routing algorithm can be very different depending on the network conditions. For example, consider a wireless network that is initially connected and then becomes disconnected due to device failures or link dynamics. In this scenario, a routing algorithm whose goal is to ﬁnd a connected endtoend path (e.g., through route discovery requests as in DSR [1] or AODV [2]) will initially succeed, but will eventually fail to deliver any packets when the network becomes disconnected. Alternatively, consider a wireless network that ﬂuctuates between periods of low and high congestion. In this scenario, the use of backpressure routing [3] can achieve optimal performance during the high congestion periods, but leads to performance inferior to many other algorithms during the low congestion periods. One way to design an adaptive routing algorithm is to identify a set of target network conditions to handle, identify the appropriate routing strategy for each, and then switch strategies as needed. This approach risks instability if network conditions change frequently or algorithms take a long time to converge. Reinforcement learning (RL) [4] allows for an alternate approach in which an RL agent trained on a set of target network conditions learns to make routing decisions even in an uncertain and timevarying environment. Qrouting [5] is the ﬁrst RLbased routing algorithm. Since then, many more have been proposed, see [6] and the references within. Recently, advances in deep reinforcement learning (DRL), which uses neural networks to approximate the decision space, have motivated the design of DRLbased routing algorithms (see §III). However, existing RL and DRLbased routing strategies do not easily generalize to other scenarios because they encode assumptions about network topology and possible actions into the neural network that is used to make routing decisions. In this work, we develop a novel DRLbased routing strategy that is able to generalize to different network conditions. We focus on distributed routing, allowing individual agents to make routing decisions: this supports scalability and provides redundancy in the case of network dynamics. We make the following contributions to DRLbased routing design: Relational features. To enable our algorithm to scale to larger networks and generalize to other network conditions, we input relational features to the deep neural network used to approximate the routing decision space. This not only allowsarXiv:2012.15700v1  [cs.NI]  31 Dec 2020data from all DRL agents to be used to train the neural network, but also allows each agent to independently use the same neural network for decisionmaking during testing. Packetcentric decisions. We transform the routing problem into an episodic task by viewing packets , rather than devices, as the DRL agents that must learn a routing policy. This packet centric approach provides a more natural way to propagate and model rewards accurately. Extendedtime actions. We use extendedtime actions or options [7] to model the time spent by a packet waiting in a queue, which reduces the amount of training data needed and allows the learning algorithm to converge more quickly. We evaluate our approach using a packetlevel network simulator. Extensive results demonstrate that our approach is both generalizable and scalable, and signiﬁcantly outperforms shortest path routing [8] and backpressure routing [3] with respect to packets delivered and delay. The rest of this paper is organized as follows. §II gives background on routing, §IV overviews our DRL algorithm, §V provides simulation results, §III describes related work, and §VI gives our conclusions. II. R OUTING IN MULTI HOP WIRELESS NETWORKS Consider a wireless network with a set of nodes, i.e., wireless devices,V. LetN=jVjdenote the number of devices in the network. Each device transmits via a wireless channel. Two devices that are within transmission range can communicate with each other. Let Etdenote the set of wireless links present at timet. Due to interference and possible link dynamics, Et can vary over time. We assume that devices are stationary; device mobility leads to other interesting challenges, which we leave to future work. All devices are capable of receiving and forwarding packets as well as serving as a source or destination. Each device v2Vhas a ﬁnite queue which can buffer a maximum of Bpackets. The routing decision at a device v is to choose the neighbor to which to send a packet from v’s queue (typically the packet at the front of the queue). A packet carries a timetolive (TTL) ﬁeld, which is decremented by one at each intermediate device that forwards the packet. A packet is forwarded until it either reaches its destination, its TTL becomes zero, or it is dropped upon arrival at a device whose queue is full. Two goals of routing are to (i) maximize throughput, i.e., the packet delivery rate, while (ii) minimizing delay, i.e., the time from a packet being generated at the source to being delivered to its destination. When a network’s trafﬁc load changes, or topology changes in the network itself cause trafﬁc load changes, a static routing strategy that ignores congestion can lead to poor performance. For instance, shortest path routing, which selects the path between a source and destination solely based on the number of hops, leads to low throughput when the shortest path is congested. In contrast, an adaptive routing algorithm typically leads to either high throughput with large delay, or low throughput with small delay. One example is backpressure routing [3], which routes packets dynamically based on the amount of congestion in the network. As we shall see in §V, when the per device queue size, B, is large, it leadsto high throughput at the cost of large delay, since packets ﬂow through the network following the lowest congestion gradient at each device, and may take many hops to reach the destination. When Bis small, it leads to lower delay at the cost of low throughput since many packets are dropped. In general, it is difﬁcult to achieve both high throughput and low latency simultaneously under dynamic trafﬁc conditions. III. R ELATED WORK "
260,An Efficient Loop-free Version of AODVv2.txt,"Ad hoc On Demand distance Vector (AODV) routing protocol is one of the most
prominent routing protocol used in Mobile Ad-hoc Networks (MANETs). Due to the
mobility of nodes, there exists many revisions as scenarios leading to the loop
formation were found. We demonstrate the loop freedom property violation of
AODVv2-11, AODVv2-13, and AODVv2-16 through counterexamples. We present our
proposed version of AODVv2 precisely which not only ensures loop freedom but
also improves the performance.","MobileAdhocNetworks (MANETs) havediﬀerent applicationsfromm il itary to disastrous situations where there is no network infrastru cture and nodes can freely change their locations due to mobility of nodes. Mob ility is the main feature of MANETs which makes them powerful and at the s ame time error prone in practice. The process of the protocol design a re not straightforward and simulations are used to validate the protocol. However, all possible scenarios are not covered during simulations. Since there is no base station or ﬁxed network infrastructure, ev ery node acts as a router and keeps the track of the previously seen packe ts to ef ﬁciently forward the received messages to desired destinations. I n essence, ∗Corresponding author Email addresses: b.yousefi@alumni.ut.ac.ir (Behnaz Youseﬁ), fghassemi@ut.ac.ir (Fatemeh Ghassemi) Preprint submitted to Computer Networks March 24, 2021MANETs need routing protocols in order to provide a way of communic ation between two indirectlyconnected nodes. Ad hoc On Demand Distance Vector (AODV) routing protocol [1] is o ne of the most popular routing protocol used in MANETs. It has two ma in ver sions, each one with several subversions. The AODV speciﬁcation is given in plain English, no pseudo code or implementation is provided. It brings out lots of ambiguities which may lead to diﬀerent implementations, or e ven worse, could cause the violation of important properties of AODV su ch as loop freedom. For example, while modeling the ADOV v2 (version 11), w e confronted some ambiguities that we worked them out through com munica tion with the AODV authors. For instance, when there are more tha n one unconﬁrmed routes, which one is going to be used? The answer was the best one as we speculated. Also what happens if it fails to receive an ackfrom the best one? The answer was it is going to use the second best rout e and go on till it gets an ack. It was also not clear when rerrmessages are sent while dealing with unconﬁrmed routes, which turns out that they are never going to be sent if the route is unconﬁrmed . Therefore, it is really necessary to have a precise speciﬁcation while easy to read and understand. w Rebeca modeling language was introduced in [2] for the formal speciﬁcation a nd ver iﬁcation of MANET protocols. It not only provides a means to specify a protocol precisely in a Javalike syntax, but also it is supported by a tool to verify given properties, e.g. loop freedom, on the protocol. Beside s, adding new features or updating the existing network protocols invalidate s all the veriﬁcations that have been done on the older versions. Therefor e, as the process of developing the AODV protocol is an ongoing one, its veriﬁ cation should be too. In [2], the applicability of wRebeca is shown through the modeling and veriﬁcation of the AODVv2 (version 11) protocol. In this paper, we focus on several versions of AODVv2 and their sh ort comings to assure loop freedom. First, we provide a short introduc tion of wRebeca and its important aspects in Section 2, and then we procee d by ex plaining AODVv2 concisely in Section 3. We demonstrate the routing ta ble maintenance procedure of its subversions and in their consequent , the sce narios leading to the violation of the loop freedom property of AODVv 211, AODVv213, and AODVv216 through counterexamples in Section 4 . Such scenarios, found automatically by our framework, have been comm unicated with the AODV group to be validated. We explain the reason in the prot ocol design which leads to the loop freedom violation of AODVv216 and pre sent two solutions to amend the protocol in Section 5. Then, we discuss a n exces 2sive restriction, which the protocol applies to ensure its loop freed om, and its consequence on the performance of the protocol. Finally, we pr esent our proposed version of AODVv216 which not only ensures loop freedo m but also improves the performance. Inspecting all loop scenarios, mak es it clear that loop formations are caused by updating the routing table not c arefully enough. In fact, there are many factors that must be considere d while up dating the routing table, such as sequence numbers and route cos ts. Keeping the routing table loopfree even gets more sophisticated by mainta ining more than one route per each destination. For example, in case only one r oute per each destination exists in the routing table, a new route with a great er se quence number than the existing ones simply replaces it, but now sho uld it be added to the routing table or replace all other routes? As we se e in Section 4, adding such a new route to the routing table may lead to th e loop formation. As a matter of fact, the main cause of loop formation in A ODVv2 (version 13) and (version 16) was mishandling the situation as a cons equence of which a new route with the greater sequence number is added to t he rout ing table. In the all versions of AODV, there is a function which enfor ces the loop freedom condition through verifying that each incoming route is not a subsection of any existing routes. Nevertheless, when an incomin g route has a greater destination sequence number, this function gets ignore d to value its freshness. This kind of avoidance does not cause any problem wh en there is at most one route to each destination and the incoming route upda tes the existing one. However, when there are more than one route to eac h desti nation, the incoming route does not update all the existing ones whic h may lead to the loop formation. 2. Actor Model and the wRebeca Language The computational model of actors [3, 4] has been introduced for the purpose of modeling concurrent and distributed systems. Such mo deling has become very popular in practice [5, 6, 7]1. Actors, the primitives of compu tation, are independent, well encapsulated, and of course run co ncurrently. Each actor has its own state indicated by its state variables and its e ncap sulation prohibits other actors to access its state variables direct ly. Each actor communicates with others only through message passing and owns a 1Scala programming language supports actormodels http://www.scalalang.org 3mailbox with a unique address to store the received messages. The b ehavior of an actor is deﬁned in terms of a set of message server s which specify how the actor reacts upon processing each received message. For ex ample, if one actor wants to change the other actor state variable, it should do it through sending an update message to the other actor. The way this messa ge is going to be processed is declared in the corresponding message server o f the other actor. In this model, message delivery is guaranteed but is not inor der. This policy implicitly abstracts from the eﬀects of network, i.e., delays over diﬀerent routing paths, message conﬂicts, etc., and consequent ly makes it a suitable modeling framework for concurrent and distributed applic ations. The modeling language Rebeca [8] provides an operational interpret ation of the actor model through a Javalike syntax to ﬁll the gap between formal veriﬁcation techniques and the realworld software engineering of concurrent and distributed applications. It is empowered through various exte nsions introduced for diﬀerent domains such as probabilistic systems [9], re altime systems [10], software product lines [11], and broadcasting environ ment [12]. Mobility is the intrinsic characteristic of the MANETs which aﬀects the correctness of MANET protocols. We extended Rebeca with the co ncepts of MANETs to model such networks in a more succinct way, socalled wRe beca[2]. It is supported by a toolset for eﬃcient veriﬁcation of wRebeca models regarding the mobility of nodes. wRebeca provides essential primi tives for the modeling of MANET protocols, namely unicast, multicast and broadcast communications, abstracting the services of the data link layer. Furthermore, the concepts of connectivity and the underlying to pology are considered for actors. The message delivery is guaranteed for th e receiving actors connected to a sender and also is inorder as communication s are one hop. Such an extension allows the modeler to setup the initial topolog y and specify the dynamic aspect of the networks, i.e., how the underlying topol ogy changes through the novel concept of network constraints . A network constraint establishes a set of static (dis)connectivity relations a mong the nodes. Therefore, a wRebeca model is analyzed for all mobility scen arios respecting the constraints. The wRebeca is reasonably suitable fo r modeling MANET protocols. In this setting each network node executing an in stance of a MANET protocol can be represented through an actor with so me state variables and message servers. There is a complete mapping betwee n mes sages deﬁned by the protocol speciﬁcation , e.g., an IETF draf, and message servers. The content of the message is passed through the mess age server arguments. The body of a message server encodes how a received message 4is going to be processed as deﬁned by the speciﬁcation. The informa tion re quired to be maintained by each node is modeled by state variables. He nce, there is a good traceability, from the model back to the protocol. I f we ﬁnd a problem in the model, then we can trace it back into the protocol ea sier. The faithfulness of the framework to the MANET domain, make it usa ble for analysis and design of such protocols [13]. As mentioned earlier, wRebeca is an extension of Rebeca with a Java like syntax to easily read and apply. Every wRebeca model consists of t wo parts: the reactive class declaration part and the main part. Various comp onents of the system are modeled through declaring diﬀerent reactive classe s. Each re active class hastwo major parts: onefor maintaining its state, whic h is called statevars , and the other for specifying its reaction upon receiving diﬀerent messages, i.e., message server s. The body of message servers may consist of conditional, assignment, and communication statements. The sy ntax of communication statements that worth mentioning are broadcast, multicast, and unicast. Broadcasting a message is like calling a function, by indica ting a message server name along with its parameters. Unicasting/Multic asting a message is slightly diﬀerent since we need to mention the receivers. In addition, in case of unicast the modeler can specify what is going to ha ppen regarding to the success or failure of the communication. The second part of a wRebeca model is the mainpart which declares the instances of deﬁned reactive classes and their initialization. Furthe rmore, the modeler can deﬁne a set of constraints to restrict the topolog y changes in network. For instance, if it is known that two nodes would never ge t connected, i.e, they would never get into each other communication range, the topologies in which these node are connected together can be r uled out frompossible topologiesby expressing aconstraint by which the link b etween these node is disconnected. Example. Figure 1 shows the wRebeca speciﬁcation of the AODV protocol. Forbrevitysomepartsofthecodehavebeenabstractedaway. N etworknodes running an instance of AODV are modeled by a reactive class, lines (1 60). Each node has a routing table and an IP which is modeled by the state v ari ables, lines(25). Every nodecanreceive diﬀerent routingmessag es, i.e.rreq, rrep, andrerr. Theprocedureofhandling thesemessages ismodeled through declaring diﬀerent message servers while each one is responsible for handling a speciﬁc message. For example, the message server recrreqis responsible for handling received rreqmessages, lines (2141). In line 38, an rreqmessage 5is broadcast while an rrepis unicast in line 26. Modeler has speciﬁed the behavior of the protocol based on the delivery status, lines (283 5). The sec ond part of a Rebeca model is the mainpart, lines (6570), where rebecs get instantiated from declared reactive classes, for example n1 fromNode. The ﬁrst pair of parentheses specify the initial topology by indicating th e name of other rebecs which are initially in the rebec neighborhood. For exa mple, n2 is initially connected to n1 andn4. The second pair of parentheses, after colon, specify the parameters of the initial message which is going to be pro cessed by the declared initialmessage server. Each reactive class declaration at least has one message server namely initialwhich acts like a constructor in objectoriented languages and used for initialization purposes, lin es (69). For example, initializing state variables, routing table variables and st arting a new route discovery by sending a new packet. As mentioned earlier , the mainpart in wRebeca hasanother part named network constraints , lines (69 71). This part is used to reduce the domain of the possible topologies . For example, if it is impossible for n1 to get out of the communication range of n2 and vice versa, modeler can express this situation by declaring a ne twork constraint containing the relation con(n1,n2). /square 3. Overview of AODVv2 The AODV protocol is under continuous development and its working group publish a new version at most every 6 months with the aim to impr ove the protocol and amend its shortcomings. However, all its (sub)v ersions almostfollowthesamedesignconcept. Morespeciﬁcally, ituses some speciﬁc routing packets, e.g., rreq,rrep, andrerr, but the way these packets are sent and processed diﬀers in every version. In this section, we brieﬂy ex plain the common procedure of route discovery and maintenance among its v ariants. The wRebeca speciﬁcation of its common code between versions 10, 11, 13, and 16 is given in Figure 1. Some parts of the code, abstracted in this speciﬁcation, e.g., the one commented by “processing code”, vary in diﬀerent versions. In this protocol, routes are built upon route discovery requests a nd main tained in nodes routing tables for further use. The routing table co ntains information about discovered routes and their status: The followin g infor mation is maintained for each route: •SeqNum: destination sequence number 61reactiveclass Node(){ 2statevars { 3intsn,ip; 4int[] dsn,rst,hops,nhop; 5} 6msgsrv initial (inti, 7boolean starter){ 8 ... /∗Initilization code ∗/ 9} 10msgsrvrecnewpkt(int data,intdip) 11{ 12if(rst[dip ]==1) 13 {.../∗forward packet ∗/} 14else{ 15 sn++; 16 rec rreq(0,dip , 17 dsn[dip ],self,sn,self,5);} 18} 19msgsrvrecrreq (inthops, intdip,intdsn,int oip,intosn,int sip,intmaxHop) 20{ 21booleangenmsg =false; 22 ... /∗processing code ∗/ 23if(genmsg == true){ 24 if(ip == dip ){ 25 sn = sn+1; 26 unicast(nhop[oip ], 27 rec rrep(0 , dip , sn , oip ,self)) 28 succ: { 29 rst[oip ] = 1; 30 } 31 unsucc: { 32 if(rst[oip ] == 1) 33 {.../∗error∗/} 34 rst[oip ] = 2;}35 }else{ 36 hops = hops + 1; 37 if(hops<maxHop) { 38 rec rreq 39 (hops ,dip,dsn,oip, 40 osn ,self,maxHop); } 41}}} 42msgsrvrecrrep(inthops ,intdip,intdsn, 43intoip,intsip){ 44booleangenmsg =false; 45 ... /∗processing code ∗/ 46if(genmsg == true){ 47 if(ip == oip ){ 48 ... /∗forward packet ∗/} 49 else{ 50 hops = hops+1; 51 unicast(nhop[oip ],recrrep 52 (hops ,dip,dsn,oip,self)) 53 succ: { 54 rst[oip ]=1; 55 } 56 unsucc: { 57 if(rst[oip ] == 1) 58 {...}/∗error∗/ 59 rst[oip ] = 2;} 60}}} 61msgsrvrecrerr(intsource, 62intsip,int[] riprsn) 63{.../∗error recovery code ∗/} 64} 65main{ 66 Node n1(n2,n4):(0, true); 67 Node n2(n1,n4):(1, false); 68 ... 69constraints { 70 and( con(n1,n2), con(n3,n4)) 71} 72} Figure 1: The AODV speciﬁcation given in wRebeca 7•routestate: the state of the route to the destination •Metric: indicates the cost or quality of the route, e.g., hop count, the length of the path from the node to the destination via the respect ive next hop •NextHop: IP address of the next hop to the destination The routing table of each node is modeled by a set of variables of arra y type, namelydsn,rst,hops, andnhopto denote SeqNum,routestate,Metric, andNextHop, respectively. In addition, dipandoipdenote destination and originatorIPs which areused asindexes to retrieve the information of aroute to destination/originator in such arrays. For instance, rst[oip] denotes the route state to the originator. Whenever a node intends to send a data packet to another, i.e., whe n it receives a newpktmessage, it looks up its routing table to see if it has a valid route to the intended destination, line 12 of recnewpkt. In case it ﬁnds a route, it sends the data packet through the next hop spec iﬁed in that route, otherwise it starts a route discovery by broadcasting a ro ute request, i.e.rreqafter increasing its sequence number, lines (1417) of recnewpkt. Whenever a node receives a new routing packet, rreq, it updates its routing table with new information to keep it uptodate, abstracted code at line 22 ofrecrreq.rreqmessages containroutetowardsa sourcewhilerrepmessages carry route information towards a destination . Therefore, as an rreqpacket proceeds towards the destination, in each node, a backward path , a path to thesourcefrom the node, gets constructed. Similarly, a forward path , a path to thedestination from the node, is built while rreppackets traverse the constructed backward path from the destination towards the source. Each node upon receiving an rreqmessage looks up its routing table and if it has a route to the requested destination it would reply through sending anrrep, lines(2535)of recrreqotherwise, itresendsthe rreqmessageafterincreasing thehop count if themaximum number of hopcount limit is not reached, lines (3640) of recrreq. Whenever a node receives an rrepmessage, it updates its routing table accordingly to construct a forward path , the abstracted code at line 45 of recrrep. When the rrepreaches the source, abstracted code at line 48 ofrecrrep, a bidirectional route has been formed and the data packet can be sent through nexthops on nodes routing tables towards the d estination. When a node which is not the source receives a recrrepmessage, it unicasts therecrreptoward the source after increasing the hop count, lines (4958) 8ofrecrrep. In addition to the rreqandrreppackets, there is an rerrpacket which is sent whenever a node fails to send a packet through a validroute, line 33 of recrreqand line 58 of recrrep, in order to informs other interested nodes in the broken route about the failure. Fromversion 10, a new ability hasbeen added to the protocolto main tain more than one route to a destination. For each destination, multiple routes may exist with diﬀerent nexthops, i.e., unconﬁrmed nexthop, a nexthop which its bidirectionality has not been conﬁrmed yet. Whenever an rrepis going to send a package to an unconﬁrmed nexthop, it must request an ack from the receiver to become sure about its bidirectionality. This new feature improves the performance since for sending a packet there is no ne ed to wait for a nexthop to get conﬁrmed , and consequently its route to become valid. Although having multiple routes to one destination has its beneﬁts, it can lead to a loop formation when it is used with not required precautions a s we are going to explain in the following section. 4. Loop formation Scenarios Weexplainhowdiﬀerentversions ofAODVv2protocoltrytopreven t loop formation and how they fail to do so through counterexamples whic h are ob tained by our tool. The AODV protocol manuscript has diﬀerent sec tions, e.g. initialization, adjacency monitoring, route maintenance and pro cessing received route information [1]. For the purpose of loop formation av oidance, we will focus on the processing received route information part of the speci ﬁcation since a loop is formed if and only if preventative measures hav e not been taken to account while updating the routing tables. Therefor e, in the section for the sake of simplicity, we only focus on evaluating receive d route information and consequently updating the routing tables, abstra cted in the speciﬁcation of Figure 1 and commented by “processing code”. For a com prehensive speciﬁcation, we refer the interested reader to their corresponding IETF drafts. 4.1. AODVv211 Thisversionmaintainsmorethanonenexthoppereachdestinationw hich increases the probability of packet delivery since if one route gets b roken, there may be other routes that can be used as an alternative.2When there 2https://tools.ietf.org/html/draftietfmanetaodvv2 11 9aremorethanoneroute, thebestonewouldbeused. Thebestrou teischosen based on the concept of route state andcost. Route states are determined by the concept of neighbor state s of next hops which determines the adjacency states of the node’s neighbors, and can have one of the following va lues: •Conﬁrmed: indicates that a bidirectional link to that neigh bor exists. This state is achieved either through receiving an rrep mess age in re sponse to a previously sent rreq message, or an rrep ack message as a response to a previously sent rrep message (requested an rre pack) to that neighbor. •Unknown: indicates that the link to that neighbor is current ly unknown. Initially, the states of the links to the neighbors are unkno wn. •Blacklisted: indicates that the link to that neighbor is uni directional. When a node has failed to receive the rrep ack message in response to its rreq message to that neighbour, the neighbor state is c hanged to blacklisted. Hence, it stops forwarding any message to it fo r an amount of time, ResetTime. After reaching the ResetTime, the neigh bor’s state will be set to unknown. Such information are kept in the neighbor table of each node. Route states, the states of the routes to each destination, are kept in the rout ing table and can have one of the following values: •unconﬁrmed : when the neighbor state of the next hop is unknown; •active: when the link to the next hop has been conﬁrmed, and the route is currently used; •idle: when the link to the next hop has been conﬁrmed, but it has not been used in the last activeinterval; •invalid: when the link to the next hop is broken, i.e., the neighbor st ate of the next hop is blacklisted. A route is called validif it is either active or idle. Although there can exist more than one unconﬁrmed route to each destination, there can be only one validroute to each destination. When a route state to a destination get s changed to valid, all the routes to the same destination are removed from routing table. 104.1.1. Updating the Routing Table Every received route message contains a route and consequently is eval uated to check for any improvement. Note that an rreqmessage contains a route to its source while an rrepmessage contains a route to its destination. Therefore, as the routes are identiﬁed by their destinations, in th e former case, the destination of the route is the originator of the message and in the latter, it is the destination of the message. Note that we say a rout er is betterthen others if it has either a greater sequence number than other s or an equal sequence number while its cost, e.g., hop count, is less than oth ers. The routing table must be updated if one of the following conditio ns is realized: •no route to the destination exists in the routing table: the route is added to the routing table. •all the existing routes to the destination are unconﬁrmed , i.e., their next hops are unconﬁrmed : the route is added to the routing table. •the incoming route is a better route than the existing valid one: if the next hop of the incoming route is conﬁrmed , it updates the exist ing valid route with the received route, otherwise it adds the receive d route to the routing table since it may be conﬁrmed in the future and consequently, replaces the existing route. •the incoming route is a better route than the existing invalid one: it updates the existing invalid route with the incoming route. 4.1.2. Loop Formation Scenario In this version no constrain has been applied to the unconﬁrmed nexthop of an incoming route prior its addition to the routing table when the ro ute status of the existing routes are unconﬁrmed (the second case in Section 4.1.1). This lack of restriction easily leads to a looping scenario which is described in the following. Assume that each route entry of the rou ting table has the following format: ( dest,nexthop,hopcount,seqnum,routestate), where the ﬁrst element indicates IP of the destination, the second , IP of the next hop, the third, the length of the route to the destination, th e forth, the sequencenumberofthedestination, andthelast, theroutestat e, respectively. Consider a network of four nodes as shown in Figure 2. 11n3n1 n4 n2 Figure 2: The network topologyn4n1 n2 n3 (a)n4n1 n2 n3 (b) Figure 3: Two possible network topologies for a network of four nodes 1.n1initiates a route discovery procedure for destination n3by broad casting an rreqmessage with the sequence number 2. 2.n2receivesrreqmessageasitisaneighborof n1. Sinceitistheﬁrsttime thatn2has received an rreqmessage from n1, the neighbor state of n1 is set tounconﬁrmed . Therefore, the route state of the received route is unconﬁrmed , andn1adds the incoming route ( n1,n1,1,2,unconﬁrmed ) toitsroutingtable. Since n2isnottheintendeddestinationoftheroute request, it rebroadcasts an rreqmessage. 3.n4also receives the rreqmessage sent by n1(simultaneous with n2) and inserts the incoming route ( n1,n1,1,2,unconﬁrmed ) to its routing table towards n1similar to n2. Then, it rebroadcasts the rreqmessage. 4.n2afterreceivingthe rreqmessagesentby n4,addstheroute( n1,n4,2,2, unconﬁrmed ) to its routing table since the existing route to n1, i.e., (n1,n1,1,2,unconﬁrmed ), isunconﬁrmed . 5.n4also adds ( n1,n2,2,2,unconﬁrmed ) to its routing table after pro cessing the message rreqsent byn2. At this point a loop is formed between n2andn4. 6.n3receives the rreqmessage sent by n1vian2, and since it is the destination, it sends an rrepmessage towards n2. 7. Assume that n1moves out of the communication ranges of n2andn4. 8.n2receives the message rrepsent byn3and as the route state of the routes towards n1isunconﬁrmed , it unicasts an rrepmessage one by one to the existing next hops, i.e., n1andn4, till it gets an ack. Due to the movement of n1, it receives no ack from n1and the route with the next hop n1is removed from the routing table. However, it receives an ack from n4. Therefore, the neighbor state of n4is set toconﬁrmed and subsequently the respective route state towards n1tovalid. 9.n4by receiving the message rrepfromn2unicasts it to its next hops, i.e.,n1andn2, similar to n2. Since it only receives an ack from n2, it 12updates its routing table by validating n2as its next hop to n1, and hence a loop is formed between n2andn4over valid routes. 4.2. AODVv213 After communicating ourresult onAODVv211totheAODVgroup, t hey revised the protocol to restrict the addition of unconﬁrmed routes when all the existing routes to a destination are unconﬁrmed . Hence, only the second step of the procedure of Section 4.1.1 is revised: an incoming route is added totheroutingtableifalltheexisting routestoitsdestinationare unconﬁrmed while the incoming is better the existing ones.3 4.2.1. Loop Formation Scenario AlthoughthescenarioofSection4.1.2isprohibited, aloopscenariooc curs due to resending the rreqmessages in a network of four nodes with the topologies shown in Figure 3. At ﬁrst nodes are connected to each o ther as shown in Figure 3a. 1.n1initiates a route discovery procedure for destination n4by broad casting an rreqmessage to n3with the sequence number 2. 2.n3inserts the incoming route ( n1,n1,1,2,unconﬁrmed ) to its routing table and broadcasts an rreqmessage to its neighbors, n2andn4. 3.n2upon receiving the message rreqsent byn3updates its routing table and adds the incoming route ( n1,n3,2,2,unconﬁrmed ) to its routing table. 4. topology changes at this point and n2moves into the communication range of n1, gets connected to n1, whilen3leaves the communication range of n1, gets disconnected from n1, which leads to the network topology shown in Figure 3b. 5.n1, which has not received an rrepmessage yet, resends the message rreqafter increasing its sequence number to 3 (due to the timeout to receive such a reply). 6.n2receives the incoming route ( n1,n1,1,3,unconﬁrmed ), since it is a better route it would be added to the routing table. Then, n2broad casts an rreqmessage to its neighbors, i.e., n3andn4. 3https://tools.ietf.org/html/draftietfmanetaodvv2 13 137.n3evaluates the received message sent by n2and adds the incoming route (n1,n2,2,3,unconﬁrmed ) to its routing table since the sequence number of the received message is greater than the stored one, i.e , (n1,n1,1,2,unconﬁrmed ). At this point a loop has been formed be tween nodes n2andn3, similar to the step 5 of the scenario explained in Section 4.1.2 for version 11. Therefore, continuing with a scenario similar to the steps 69 of the scenario for version 11, a loop is forme d between n2andn3over valid routes. Thisloopscenariooccursbecausetheexistingunconﬁrmedroute( n1,n1,1, 2,unconﬁrmed )hasnotbeenreplacedbythereceivedbetterroute( n1,n2,2,3, unconﬁrmed ). Instead, the received new route is only added to the table. We remark that a new routereplaces anexisting one only when the rout e state of the existing route is invalidor the route state of the new route is conﬁrmed . 4.3. AODVv216 It is the last AODVv2 protocol which applies even more restrictions f or updating the routing table to ensure loopfreedom.4It maintains at most two routesforeachdestinationwhileoneis (in)valid andtheotheris unconﬁrmed . Toprevent loopsinthisversion, anincoming routeupdates theexist ing route with the same status. In case no route exists with the same status , it will be added to the table. Therefore, the routing table always keeps bet ter routes for each status. 4.3.1. Updating the Routing Table The updating procedure has been revised accordingly: •no route exists to the destination: the route is added to the routin g table. •the incoming route is better than the existing one. Two cases can be distinguished: 1. there is only one matching route with the same destination: –the route state of the existing route is invalid: the incoming route must replace the existing one; 4https://tools.ietf.org/html/draftietfmanetaodvv2 16 14–the route state of the incoming route and the existing one are the same: the incoming route should replace the existing one. –the route state of the incoming route is unconﬁrmed and it oﬀers improvement to the existing validroute: the incoming route should be added to the routing table. 2. there are two matching routes with the same destination where one isvalid/invalid and the other is unconﬁrmed : –if the incoming route oﬀers improvement to the existing route with the same status, then it should replace it. –if the existing route is invalidand the incoming route is valid: the existing route is replaced by the incoming route even if the incoming route does not oﬀer improvement. 4.3.2. Loop Formation Scenario The loop scenario is given for a network of four nodes with the netwo rk topologiesshowninFigure4withtheinitialtopologyillustratedinFigure 4a: 1.n1initiates a route discovery procedure for destination n4by broad casting an rreqmessage to n3with the sequence number 2. 2.n3inserts the incoming route ( n1,n1,1,2,unconﬁrmed ) in its routing table and broadcasts an rreqmessage to n2andn4. 3.n2receives the message rreqsent byn3and updates its routing table by inserting the route ( n1,n3,2,2,unconﬁrmed ) into its routing table. 4.n2becomes aware that its connectivity to n3is bidirectional, for exam ple through receiving an rrepackfromn3in response of a sent rrep message for another route, therefore the neighbor state of n3is up dated to conﬁrmed and route states of all those routes which use n3 as their next hops must be updated to valid. As a result, the route entry (n1,n3,2,2,unconﬁrmed ) ofn2’s routing table gets updated to (n1,n3,2,2,valid). 5. the topology changes at this point and n3moves out of the communica tion range of n1whilen2enters the communication range of n1, which lead to the network topology shown in Figure 4b. 6.n1resends another rreqmessage with the increased sequence number of 3 ton2(due to the timeout for receiving a reply). 7.n2processes the received rreqmessage from n1, since it has the greater sequence number than the stored one, it is used to update the rou ting 15n4n1 n2 n3 (a)n4n1 n2 n3 (b)n4n1 n2 n3 (c) Figure 4: Three possible network topologies for a network of four n odes table. As the stored route with next hop n3isvalid, the incoming route (n1,n1,1,3,unconﬁrmed ) is added to the routing table as a new route. Then,n2broadcasts the received rreqto its neighbors. 8. the topology changes at this point and n3moves into the communica tion range of n1, gets connected to n1which leads to network topology shown in Figure 4c. 9. assume that the connectivity status of n3ton1becomes bidirectional, therefore the route entry ( n1,n1,1,2,unconﬁrmed ) ofn3’s routing table gets updated to ( n1,n1,1,2,valid). 10.n3receives the incoming route ( n1,n2,2,3,unconﬁrmed ) via the rreq message sent by n2. Since the incoming route has a greater sequence number than the stored one and the stored one is valid, it will be added to the routing table. At this point a loop between n2andn3is formed. Again by continuing with a scenario similar to the steps 69 of the scenario for version 11, a loop is formed between n2andn3over valid routes. By examining the counter example, we realize that a loop is formed as the loop freedom condition is not always considered and consequent ly, the new route will be added to the routing table when the sequence numb er is greater than the existing valid one. To amend this situation, we prop ose two options: 1. The loop freedom condition should be always considered. Therefo re, if the new route does not satisfy the loop freedom condition, it must n ot be used to update the routing table even if it has a greater sequenc e number. 2. The new route with a greater sequence number will be added to th e routing table while all the existing routes are removed from the rout ing table. 16n4n1 n2 n3n5 n6 n7 (a)n4n1 n2 n3n5 n6 n7 (b) Figure 5: Two possible network topologies for a network of seven no des These two approaches diﬀers regarding how they prioritize a new ro ute with a greater sequence number and an existing route. The ﬁrst solutio n prefers to keep the valid one by ignoring the new route with a greater sequen ce number while the second one favors the new route with a greater se quence number over existing routes even the valid ones. Nevertheless, we believe that there is a better approach which not only ensures loop freedo m but also boosts the performance by maintaining more eligible routes for forw arding a packet to a destination. Irrespective of which solution is being adop ted, we demonstrate through an example how the protocol fails to forwar d a packet while there could have existed a route if the routing table had been up dated better. The example is given for a network which consists of seven n odes with the topologies shown in the Figure 5. 1.n1initiates aroutediscovery procedure forthe destination n7bybroad casting an rreqmessage with the sequence number 2. 2.n2,n3, andn4update their routing tables upon receiving the rreq message sent by n1, and broadcast the rreqmessage to their neighbors. 3.n5receives the rreqmessage sent by n2and after updating its routing table broadcasts it. 4.n6receivesthe rreqmessagesentby n5andaddstheroute( n1,n5,3,2,unconﬁrmed ) to its routing table. Then, it broadcasts the rreqmessage to n7. 5. assume that the connectivity status of n5ton6becomes bidirectional, therefore,theroute( n1,n5,3,2,unconﬁrmed )getsupdatedto( n1,n5,3,2,valid). 6.n6receives the rreqmessage sent by n3andsince it isabetter routeand thestoredoneisa validone,theincomingroute( n1,n3,2,2,unconﬁrmed ) is added to the routing table. 7.n6receives the rreqmessage sent by n4and since it doe not improve the existing unconﬁrmed route, it gets discarded. 178. the topology changes at this point as n5andn3move out of the com munication range of n6which leads to the network topology shown in Figure 5b. 9.n7receives the rreqmessage sent by n6and since it is the destination, it replies through sending an rrepmessage to n6. 10.n6receives the rrepmessage sent by n7. To forward its rrepmessage to the originator, i.e. n1, it has two next hops in its routing table to the destination n1:n3andn5. Bothnexthopsaregoingtofailtodeliverthe message since they have got disconnected due to the topology cha nge. Although the route through n4does exist, it had been ignored. Asthe number of nodes increases, the chance of having more than oneuncon ﬁrmedrouteandconsequently, theeﬀectofignoringthemontheperfor mance raises. In the following section, we present a solution which not only s atisﬁes the loop freedom invariant but also improves the performance by pr eserving multiple routes for each destination. 5. Proposed Procedure for Updating the Routing Table According to the scenarios mentioned for the diﬀerent versions of AODV, the main reason leading to loop formation is ignoring the loop freedom c on dition. In the previous subsection we presented two solutions. While these solutions are loopfree, they impose some restrictions which can de grade the performance. Hence, we present the modiﬁed version of these ap proaches while lifting the unnecessary restriction so that it is possible to have m ultiple routes to the same destination. Although it is possible to have an inﬁn ite number of routes, it is more realistic to bound it since there is a trade oﬀ between the storage cost and the performance. 5.1. Solution 1: Preferring Hop count to Freshness In this approach we treat an incoming route with a greater sequenc e number in a same way we handle an incoming route with an equal sequen ce number compared to the existing routes. It means that the loop fr eedom condition is always checked. The procedure of evaluating the incomin g route and updating the routing table is modiﬁed accordingly: •no route exists to the destination: the route is added to the routin g table. 181if(dsn[oip ][0]==−1) 2{ 3 dsn[oip ][0]=osn ; 4if(neighstate[sip ]==true){ 5 rst[oip ][0]=1; 6}else{ 7 rst[oip ][0]=0;} 8 hops[oip ][0]=hops ; 9 nhop[oip ][0]=sip ; 10 dsn[oip ][0]=osn ; 12 process msg =true; 13}else{ 14booleanloopFree= true; 15for(inti=0;i<N;i++){ 16if(dsn[oip ][ i] == −1){ 17 continue; 18} 19if(dsn[oip ][ i]>osn|| hops[oip ][ i]<hops){ 20 loopFree= false; 21 break; 22} 23} 24if(loopFree) { 25for(inti=0;i<N;i++){26 if(nhop[oip ][i]==−1|| nhop[oip ][i]==sip ) 27 { 28 route num = i; 29 break; 30 } 31} 32 hops[oip ][routenum]=hops ; 33 nhop[oip ][routenum]=sip ; 34 dsn[oip ][routenum]=dsn ; 35if(neighstate[sip ]==true) 36{ 37 rst[oip ][routenum]=1; 38 for(inti=0;i<N;i++) 39 { 40 dsn[oip ][ i]=−1; 41 hops[oip ][ i]=−1; 42 nhop[oip ][i]=−1; 43 } 44}else{ 45 rst[oip ][routenum]=0; 46} 47 process msg =true; 48} 49} Figure 6: The ﬁrst solution for updating the routing table 19•the sequence number of the incoming route is equal or greater tha n all the existing routes to the same destination while its cost, e.g., hop count, is equal or less than all the existing routes: the incoming rou te is added if the bound has not been already reached. •otherwise, no change is applied to the table. The precise speciﬁcation of this procedure is depicted in the Figure 6 . This code replaces the abstracted code at line 22 in the speciﬁcation of Fig ure 1 in the body of the message server handling rreq. We remark that rreq andrrepmessages have parametrizes such as the hop count that the mess age has been relayed from the originator, destination IP, destination s equence number, originator IP (the origin of the message), and sender IP, speciﬁed byhops,dip,dsn,oip, andsip, respectively. As the destination of the route in an rreqmessage is its originator, this code uses oipin its evalua tions. However, the destination of the route in an rrepmessage is identiﬁed bydip. Therefore, the code replacing the abstracted code at line 45 in th e body of the message server handling rrepwill be the same while dipis used in the evaluations. As more than one route is maintained for each des ti nation, the variables dsn,rst,hops,nhopof the speciﬁcation of Figure 1 become two dimensional of size n×n, wherenis the number of nodes. The second dimension keeps information of the alternative routes via diﬀ erent next hops for each destination. Thus, hops[i][j] indicates the hop count of thejth route to the destination i. Similarly, rst[i][j] refers to the state of thejth route to the destination with IP iwhich can have the values 0, 1, or 2 to indicate that the route is unconﬁrmed ,valid, orinvalid, respectively. Furthermore, a variable neighstateis added to the speciﬁcation to keep the adjacency state of the neighbors, where neighstate[i] =trueindicates that the node is adjacent to the node with the IP address i, whilefalseindicates that its adjacency status is either unknown orblacklisted (since timing issues are not taken into account, these two statuses are considered t he same). Lines 112 addthe incoming routeif no routepreviously exists. The r oute state of the incoming route is set in terms of the neighbor state of t he sender message, i.e., neighstate[sip]. Lines1422check whether theincomingroute is abetter routethan theexisting ones. If theincoming route is a loop free, in this solution a route which is not older or longer than the existing ones , then the routing table gets updated, lines 2448. Lines 2630 check whe ther there already exists a route from the sender that must be updated or it s hould 20be added to the ﬁrst empty location. If the neighbor state of the s ender is conﬁrmed , alltheother routesmust beclearedbyreinitializing corresponding elements to −1, lines 3743. 5.2. Solution 2: Preferring Freshness to Hop count In this approach, we favor incoming routes with greater sequence num bers over the existing routes even the valid ones. Since keeping rou tes with diﬀerent sequence numbers jeopardizes the satisfaction of the lo op freedom property, alltheexisting routestothesamedestinationastheinc omingroute must be removed from the routing table prior to adding the new rout e to the routing table. •no route exists to the destination: the route is added to the routin g table. •the sequence number of the incoming route is equal to the existing o ne while its cost, e.g. hop count, is equal or less than the existing one: t he incoming route is added if the bound has not been reached already. •the sequence number of the incoming route is greater than all the e xist ing routes to the same destination: the incoming route is added to th e routing table after removing all the existing routes to the destinat ion. The precise speciﬁcation of this procedure is depicted in Figure 7. Va riables rstandnhopsare deﬁned twodimensional similar to Section 5.1. However, dsnandhopsarrays are deﬁned onedimensional since in this solution we always keep routes with the greatest destination sequence numbe r and the least hop counts, and hence all the route to the same destination w ill have the same destination sequence number and hop count. Lines 314 a dds the incoming route to the routing table when no route exists to the dest ination. Theninline18, the loop free conditionischecked, inthissolutionweconsider a route loopfree if it has a larger destination sequence number or a n equal one while it has a better hop count than the existing ones. If the neig hbor state of the sender is conﬁrmed , the route must be added to the table with thevalidroute state while all the other routes are cleared, lines 2231. In lines 3444, therouting tablegetsupdated withtheincoming routew hich has a better hop count. Otherwise, the route has a greater destinat ion sequence number while itshopcount is worse than theexisting one. Lines 4654 checks whether there exists a valid route to the destination. If there is no such a 21route to prevent loop formation, all the other routes must be clea red prior to adding the new route the routing table, Lines 5666. 6. Related Work "
414,Opportunistic Routing in Quantum Networks.txt,"Unlike classical routing algorithms, quantum routing algorithms make use of
entangled states - a type of resources that have a limited lifetime and need to
be regenerated after consumption. In a nutshell, quantum routing algorithms
have to use these resources efficiently, while optimizing some objectives such
as the total waiting time. Current routing algorithms tend to keep a routing
request waiting until all of the resources on its path are available. In this
paper, we introduce a new way of managing entanglement resources in an
opportunistic fashion: a request can move forward along its path as soon as
possible (even if some resources on its path are not ready). We show that this
opportunistic approach is fundamentally better than conventional approaches. In
particular, our results indicate that this new approach achieves a 30-50%
improvement in the average total waiting time and average link waiting time
compared with several state-of-the-art routing algorithms. As a by-product of
this work, we develop a new simulator for quantum routing, which can be used to
evaluate various design choices under different scenarios.","Quantum systems are able to offer superior advantages for certain applications (e.g., [1]–[6]). These applications either do not have a classical solution, or their classical solutions have signiﬁcantly worse performance. The spectacular laws of quantum mechanics allow quantum systems to be inherently more suitable for certain complex problems. An indispensable part of most of these quantum systems is a quantum network. Quantum networks are used to transfer quantum information between quantum computers, and this information is conveyed through qubits, which are the quantum counterparts of bits. The promising performance and applica tions of quantum networks serve as the building ground for a future quantum Internet [7]. Unfortunately, the same laws of quantum mechanics also create spectacular challenges speciﬁc to quantum systems (see, e.g., [8]). These challenges make quantum networks funda mentally different than their classical counterparts, and require new methods to deal with them. Technological limitations, noise, and interaction with the environment are also among the main reasons for these challenges [9]–[12]. Speciﬁcally, the state of a quantum network is constantly changing. This is partly due to the fact that the links of a quantum network have ﬁnite lifetimes, and partly because their generation is probabilistic. The highly dynamic nature of quantum networks makes routing in such networks highly nontrivial. Traditional (clas sical) routing algorithms rely on the robustness of the networkto a great extent, and then design recovery procedures in which changes in the state of the links and the nodes are effectively handled. In quantum networks, the state is constantly chang ing, so we need routing algorithms that deal with this inherent dynamism as the main issue rather than a side case. The basis of such algorithms would be an efﬁcient approach towards allocating the limited and temporary resources of a quantum network to the incoming requests, while managing the constant regeneration of the resources. Most of the existing quantum routing algorithms, such as [9], [13], [14], make a design choice that adversely affects the overall performance. Basically, existing routing algorithms wait for all of the resources (i.e., links) a request needs to be ready and then start to forward the request on its selected path. This design choice is conservative and leads to inefﬁ cient usage of the network resources. We argue that a more opportunistic approach better suits the unique characteristics of quantum networks. In particular, we believe that a request should be forwarded along the path as soon as it is possible to move forward, even if it is a single hop. As we will show in this paper, such opportunism increases the efﬁciency of any routing algorithm by decreasing the average total time required for a group of requests to reach their destinations. To the best of our knowledge, we are the ﬁrst to demonstrate and analyze opportunism in quantum networks. In particular, we have implemented three existing routing algorithms and demonstrated the fundamental superiority of opportunism by using both theoretical analysis and simulations. Moreover, we have shown that opportunism can be added to almost any routing algorithm as an addon. Finally, we have designed and implemented a simulator that can serve as a common ground for implementing several routing algorithms with various de sign choices. In fact, all three of the mentioned algorithms have been implemented with this simulator. We will opensource our simulator, making it a useful tool for quantum routing research. Our simulator has integrated the essential design choices of quantum routing, such as multipath routing [14], [15], having recovery paths [13], and having contentionfree paths. In summary, our contributions are as follows: We introduce and analyze opportunism as a new perspec tive for managing quantum networks, and demonstrate its superiority with both theoretical analysis and simulations. We provide a simulator that can be used to implement different quantum routing protocols since it providesarXiv:2205.08479v3  [cs.NI]  15 Jun 2022common functionalities and many design choices. It can also be used to compare stateoftheart protocols through different metrics and setups. The rest of the paper is organized as follows. Section II provides an overview of quantum networks and quantum routing. Section III delves into opportunistic routing. Sec tion IV describes our system model. Section V presents our theoretical analysis. The simulation results, together with a brief explanation of our simulator, are presented in Section VI. Finally, the related work, and conclusion and future work are presented in Sections VII, and VIII, respectively. II. Q UANTUM NETWORKS In this section, we review some basics of quantum networks. A. Components Similar to many other networks, a quantum network con sists of nodes and links . The nodes of a quantum network are quantum computers, which are connected through both classical and quantum channels (such as ﬁber optics).1The links of a quantum network are entangled qubit pairs (between two nodes), because they play a crucial role in quantum communication as explained below. The quality of qubit transmission over physical links de grades exponentially as the length of the link increases [10], [11], [17]–[19]. Therefore, quantum teleportation [20] is used to “transfer” quantum information. More speciﬁcally, during quantum teleportation, an entangled qubit pair between two nodes is consumed to teleport a qubit between them. This qubit is not sent via a physical link but is obtained at the destination through a series of measurements and classical communication. Generalizing quantum teleportation, entanglement swap ping [21] enables qubit transfer between two arbitrarily distant nodes by using a chain of intermediate nodes which perform a series of measurements and operations. Basically, a simple swapping protocol consumes entangled qubits between two nodes with an intermediate node to establish entanglement between these two nodes. Fig. 1 illustrates a simple swapping scenario. Several protocols have been proposed for entangle ment swapping (e.g., [11], [22], [23]). To sum up, entangled pairs indeed play a crucial role in quantum networks, serving as the basic unit of resource required for successful quantum communication. This explains why they are considered as links of a quantum network. Throughout this paper, we will use the terms “generating” or “establishing” a link to refer to creating a pair of entangled qubit pairs between two adjacent nodes. B. Limitations Quantum networks are generally hard to manage due to the following limitations. 1The nodes of a quantum network may also include quantum repeaters [16], which facilitate longdistance quantum communication. For simplicity, we assume quantum computers have this functionality as well.1) Nodes: Current prototypes for quantum computers have rather limited storage capacity for qubits [24]. This limits the number of entanglements (i.e., links) they can establish with other nodes in the network. 2) Qubits: Qubits have different quality metrics, such as ﬁdelity [25]. Generally, the quality of a qubit decreases over time (due to noise and interaction with the environment). A qubit may become useless after a certain threshold, which de pends on the application (e.g., entanglement distillation [26]). In other words, qubits, and therefore links, have ﬁnite life times. 3) Links: As explained before, links of a quantum network have ﬁnite lifetimes. Moreover, the process of generating a link is probabilistic [9], [10], [13]. In each attempt, there is a probability of failure. 4) Swapping: Similar to link generation, each swapping attempt is also probabilistic with a certain failure probabil ity [11]. C. Quantum Routing With quantum teleportation and swapping, quantum com munication can be carried out in a line network. However, a quantum network may have a more complicated topology, making the transfer of qubits nontrivial. To cope with such complexity as well as the dynamic nature of a quantum network as explained in Section IIB, a typical quantum routing algorithm contains the following stages [13]: 1)Reception: First, a number of routing requests are generated in the network. 2)Path Selection: Based on certain rules (see, e.g., [27]), several paths are selected for every request, either of ﬂine [13] or on the ﬂy. The links of these paths are usually reserved for the corresponding request. 3)Generation: Then, links are generated along the paths for every request. 4)Forwarding: Finally, once all of the required links are ready along a path, the corresponding request is forwarded based on a certain swapping pattern. Indeed, most existing routing algorithms follow the above order with few exceptions having a little modiﬁcation. For example, the algorithm proposed in [14] performs the “Path Fig. 1: A simple swapping step. The big circles are quantum nodes, and the little circles are qubits. Lines represent entan glement (i.e., links).Selection” stage after the “Generation” stage (whereas many other algorithms do the opposite). Unlike most of the existing algorithms, our proposed ap proach is not related to speciﬁc details like how the paths are selected, and is instead more related to efﬁcient management of the resources. We achieve this by proposing a new forward ing stage for any type of routing algorithms. Speciﬁcally, as explained in Section III and demonstrated in Section VI, our proposed approach, which is opportunistic in nature, can be used as an addon to many existing routing algorithms. III. O PPORTUNISTIC ROUTING In this section, we give a highlevel overview of our oppor tunistic routing. Our key observation is the following: Most existing routing protocols conduct the forwarding stage rather conservatively. More speciﬁcally, a typical routing algorithm (e.g., [9], [13], [14]) often waits until allof the links in a path are ready and then forwards the request by initiating the swapping process. We believe that such a conservative approach fails to exploit the highly dynamic nature of quantum networks for the following reasons. First, since links have ﬁnite lifetimes, it is inefﬁcient to wait for all of the links of a particular path to get established. For example, some already established links may time out even before the remaining links get established, leading to a waste of resources. Second, when a request reserves the links of its path, these links cannot be reserved by other requests. Third, since swapping is also probabilistic and it takes time to ﬁnish, by waiting for all of the links to get generated, we unnecessarily lose the opportunity to do some of the swappings while the generation is still not ﬁnished. Therefore, by being less conservative, we can enable two types of gain. By leveraging the resources more efﬁciently, we can allow every request to reach its destination faster, and at the same time prevent it from being a hindrance to other requests. Based on the above explanations, we propose a modiﬁed forwarding stage as follows: 4)Forwarding: The request is forwarded along the path as soon as it is possible, even if it is only a single hop. Fig. 2 shows an example of being opportunistic in a simple scenario. The blue (pink) request is going from the leftmost (rightmost) node to the rightmost (leftmost) node. At each step, a random number of links are generated (green links), and then the requests consume the generated links, restoring them to the nongenerated (black) state. Instead of waiting for all of the links to be ready, the requests take the opportunity of moving forward when they can. For simplicity, the intermediate steps in which links consecutively fail to get generated are omitted. The gain caused by being opportunistic is worth more ex planation. To this end, imagine a scenario in which Nrequests want to go from the same source to the same destination. Fig. 3 shows such a scenario. With an ordinary, nonopportunistic routing algorithm, each one of these requests has to wait for all of the links of the path to be ready, and then it gets forwarded. This means that the requests have to wait Ntimes the time needed for a single request, on average. However, Fig. 2: A simple opportunistic routing example. The green color on a link means that it is generated. Note that links support twoway qubit transfer. by acting opportunistically, we can exploit the generated links as soon as it is possible for a request to move forward, and then regenerate the consumed links for the other requests. This clearly demonstrates the twofold gain of opportunism: 1) each request reaches the destination sooner because a part of the waiting time for the link generation is used to perform some of the swappings, and 2) resources are freed more quickly, resulting in less waiting time for requests which are waiting for the prior requests to complete transmission. We call the ﬁrst gain as the swapping gain and the second one as the reservation gain. Fig. 3: Another example for opportunistic routing. The swap ping and reservation gains can be seen in this ﬁgure. The green color on a link means that the link is generated. There is a subtle point about the forwarding stage, which is worth mentioning. Forwarding a request can be interpreted in two ways. First, the request may actually be forwarded along the path, as a continuation of the swapping process. That is, as soon as a swapping step is successful along the path, the request can be forwarded to the corresponding intermediate node using teleportation. Alternatively, the request can wait until the swapping process is completely ﬁnished, and then it can be sent from the source to the destination using a single quantum teleportation step. Both of these approaches can be considered opportunistic in the sense explained inthe previous paragraphs, as long as the swapping process is started as soon as it is possible. Indeed, this perspective suggests that opportunism can be leveraged in two layers: ﬁrst in leveraging the generation time for a part of swapping, and then in acting opportunistically during the swapping process. Both of these “forwarding” methods have their advantages and disadvantages. With the former method, the request does not need to start from the beginning if a part of the swapping process fails, while on the other hand, it will consume a part of the corresponding intermediate node’s memory, possibly harming the routing of other requests. With the latter method, no extra resources are used for serving the request, but it has to start from the beginning every time a part of the swapping process fails. For a neat illustration, the ﬁgures of this paper demonstrate the former method, so that requests are actually moving forward as more links are generated. However, we have chosen the latter method for swapping in the simulations, and requests have to start from the beginning if their swapping process is not successful. As a ﬁnal consideration, as explained in Section IIC, opportunism is an approach targeting the general management of quantum networks, and it can be used in any algorithm since it does not depend on speciﬁc details. Details like how the resources are allocated and the paths are selected are not important at this level. The point is to treat the links of a network as precious resources and use them as soon as possible. This mindset can even be extended to be an integral part of a quantum network layer protocol (e.g., [28]). A.kopportunism The opportunism discussed in this section is somewhat greedy and extreme: a request moves as soon as it can move. This may not be harmful in networks with a low number of requests, but the more the requests get, the harder it gets for the network to manage the resources. On a large scale, forwarding a request as soon as a link is available may decrease the efﬁciency of routing for some other request. Additionally, requests may have different degrees of priority. Therefore, the opportunistic approach needs to have a degree of ﬂexibility to provide dynamic routing means for a highly dynamic quantum network. To this end, we introduce kopportunism . Recall that the proposed forwarding stage required a request to move forward once it is possible, even for one hop. We can change this stage as follows: 4)Forwarding: The request is forwarded along the path as soon as the ﬁrst kimmediate and consecutive hops are available. Fig. 4 shows an example of a 2opportunistic approach, in which a request is going from the leftmost node to the rightmost node. Here, the request does not move forward unless the two immediate and consecutive links are ready. Intuitively, this new opportunism provides us with a spectrum of choices, allowing us to impose a distributed control over every request’s greediness. Indeed, the extreme opportunism introduced at the beginning of Section III is a 1opportunistic Fig. 4: An example of a 2opportunistic approach. The green color on a link means that the link is generated. approach. Now, this spectrum of opportunism, obtained by changingk, which we call the degree of opportunism, provides natural means for managing requests with different priorities. That is, we can assign lower values of kfor requests with higher priorities. In this way, highpriority requests will be able to leverage the links of the network sooner than the other requests, and the higher kgets for a request, the lower its chances are to use a link for its transmission. IV. S YSTEM MODEL A. Network, Nodes, and Links We model a quantum network as a graph. The nodes of the graph are quantum computers, and the edges of the graph are the links (i.e., entangled pairs). For simplicity, we assume that at most one link can exist between any two adjacent nodes, because such a simple setup is sufﬁcient to demonstrate the advantage of our opportunistic routing. Unlike [9], [29], we do not use virtual links, i.e., entanglement between nonadjacent nodes, as a primary resource. The reason for this choice is also similar. We want to demonstrate that links are precious resources and have to be consumed opportunistically, and it does not matter if they are between adjacent or nonadjacent nodes. We use (s;d)to denote a request. Here, sis the source and dis the destination. When it is clear from the context, we may also use rfor a single request, and frign i=1for a group of requests. We denote the lifetime of an entangled pair (i.e., a link) as L. We assume that quantum nodes have inﬁnite memories. B. Entanglement Generation and Swapping We assume that every entanglement generation attempt between adjacent nodes succeeds with probability pGEN=p. Entanglement generation for a link is continuously attempted until the link is generated. Furthermore, once a link is con sumed or timed out, it starts the generation process again. Finally, we assume that every swapping attempt succeeds with probabilitypSWAP.C. Waiting Time We divide the waiting time of a request into two parts as follows. Swapping: It is the time required for a swapping process over a given number of links. Generation: It is the amount of time it takes for all of the links required for the path of the request to get generated. We consider a discretetime model, in which every time step is equal to the time it takes to attempt an entanglement generation between two adjacent nodes. Furthermore, we also assume that a single swapping step takes place at the end of each time slot. That is, each request has a chance of one swapping step at the end of each slot. The waiting times are explained in the following sections. 1) Swapping waiting time: Different algorithms have been suggested for entanglement swapping (e.g., [22]). Any algo rithm can be selected for this process, and each would lead to a certain formula for the waiting time. We denote the total time it takes to swap over Mlinks astSWAP(M). 2) Generation waiting time: We denote the amount of time required for a path with Mlinks to be generated as W(M;p). We also denote the time required for link iof this path to get established by Ti. Note thatfTigare i.i.d. and they follow a geometric distribution with parameter p. Note also that W(M;p)is a random variable, and we denote R(M;p) =EfW(M;p)g. It is shown in [10], [30] that, if L=1, R(M;p) =MX k=1M k("
302,EHRP : An effective hybrid routing protocol to compromise between energy consumption and delay in WSNs.txt,"Sink mobility is seen as a successful strategy to resolve the hotspot problem
in Wireless Sensor Network (WSN). Mobile sinks roam in the network and collect
data from special nodes such as Cluster Heads (CH) by means of short-range
communications which improves the energy efficiency. Numerous mobile sink based
routing protocols have been proposed, however, they incur high delays
especially in large scale networks where the mobile sink has to travel for a
long distance to collect data from CHs and consequently they failed to ensure a
tradeoff between energy efficiency and delay. To resolve this issue, we propose
in this paper an Effective Hybrid Routing Protocol termed as EHRP. The main aim
of this protocol is to combine between single-hop and multi-hop routing.
Indeed, when the mobile sink arrives at a cluster it collects its data while
the other distant CHs continue to send their data using our proposed improved
Ant Colony Optimization (ACO) algorithm to avoid the waiting-time. The existing
ACO algorithms use in the distance heuristic which is not practical in real
world and fail to consider relevant statistic information of energy (e.g.,
minimum energy, average energy) in path selection which leads to unbalanced
energy consumption in the network. To address these issues, the proposed
routing algorithm employs the Received Signal Strength Indicator (RSSI) and
statistic information of energy to consume energy efficiently and decrease the
probability of sending failure. The performance of the proposed routing
protocol is tested and compared with those of the relevant routing protocols.
The simulation results show that, in comparison with its counterparts, EHRP
succeeds to minimize energy consumption and delay as well as enhancing the
packet delivery ratio.","A WSN is made up of lowcost, energyautonomous devices capable of monitoring physical or environmen tal conditions (temperature, humidity, noise, vibration, pressure, movement, pollution, etc.), of performing cer tain calculations, and of collaborating to transmit their data using single hop or multihop routing via wireless links to a nal user via a unique node called sink. The energy resource of the sensor node is generally a bat tery. However, in most sensor network applications, the nodes are deployed in hostile environments and it is im practical to recharge or replace their batteries. There fore, the overall lifetime of the network depends com pletely on that of the battery. Among the many existing solutions for eectively minimizing energy consumption in WSNs, one of the most recognized is the hierarchical organization of the network into clusters [5]. However, in multihop clusterbased WSNs, the CHs near the sink consume more energy than the rest of nodes since each CH gathers, transmits the data packets from its ownarXiv:2201.03910v1  [cs.NI]  11 Jan 2022cluster members, and also relays the collected data of other CHs. Accordingly, the CHs near the sink deplete their energy rapidly, which results in energy holes and premature network death [27]. This problem is known as the hotspot problem. One of the prominent solutions proposed to overcome this issue is the sink mobility [20]. The mobile sink travels in the network to collect data through short communications distances. Hence, the load on CHs is alleviated owing to the fact that the sink visits each CH in turn to collect its data via 1hop communication scheme. As a result, signicant energy is saved and the network lifetime is increased. Mobile sink methods are devised into two main cate gories i.e. single mobile sink and multiple mobile sinks. Several works [15, 18, 26] have been done in the rst category but they suer from the delay incurred during data collection. To overcome this issue, the authors in [11, 22, 24] have proposed the use of many mobile sinks. Indeed, in a large area, collecting data from an individ ual sensor node by mobile sinks is energyecient but it takes a long time that means large delay. In a nutshell, these methods failed to ensure a compromise between energy eciency and delay. Therefore, the aim of this paper is to realize this compromise in order to enhance the network performance. In this paper, we allow the clustering to be done only once to avoid energy overhead and save signi cant amount of energy [17]. In parallel with this, we propose the use of multiple mobile sinks in order to alleviate the hotspot problem. So in each round, a mo bile sink moves to a given cluster and the other CHs in other clusters send their data to this sink using a multihop routing algorithm. The literature has indi cated that the ACO algorithm is very useful for data routing [21]. It is clear to see that signicant eorts [1, 2, 9, 12, 19, 23, 25] have been made to improve energy eciency and balancing using ACO algorithm. However, when applying the ACO to WSN routing op timization, still there are the following shortage that decreases its performance and precludes its practical application. Most researchers consider the distance be tween two nodes as the ecient factor in energy con sumption, but this is not valid in all circumstances be cause if there is an obstacle between nodes, the ob tained signal's intensity (power) will be small. Also, these works ignore the impacts of energy statistics (e.g., average energy, minimum energy) which brings unbal anced energy consumption. In the proposed work, the heuristic function is improved using RSSI and the path is selected based on energy statistics and path length. In summary, the proposed work allows 1) energy eciency via CH selection in a roundrobin method and round by round sink data gathering technique and theproposed improved ACO algorithm as well as (2) lower latency such that individual CHs do not wait until the coming of the sink but they still send their data to the sink. The main contributions of this paper are : {We devise an improved heuristic function which con siders RSSI for energy eciency and reliable data transmission purposes. Also, the path is selected based on statistic information of energy (e.g. av erage energy, minimum energy). {Existing mobile sink based routing protocols failed to ensure tradeo between energy eciency and de lay especially in large scale networks. Thus, to x this issue, we propose to combine single hop and multihop schemes within a clustered and multiple mobile sinks based WSN. {We perform extensive simulations on the proposed protocol and compare its results with those of two recent and relevant protocols [11, 24]. The simula tion results show that our proposed protocol per forms better than these protocols with respect to dierent main metrics : energy consumption, net work lifetime, average delay, and packet delivery ra tio. The remainder of this paper is organized as follows. In section 2, we present the related works. Section 3 detailed our proposed routing protocol. Section 4 gives a theoretical analysis of delay and lifetime. The perfor mance evaluation is given in Section 5. Section 6 con cludes and gives future work. 2 Related works "
37,Divide and Conquer: Partitioning OSPF networks with SDN.txt,"Software Defined Networking (SDN) is an emerging network control paradigm
focused on logical centralization and programmability. At the same time,
distributed routing protocols, most notably OSPF and IS-IS, are still prevalent
in IP networks, as they provide shortest path routing, fast topological
convergence after network failures, and, perhaps most importantly, the
confidence based on decades of reliable operation. Therefore, a hybrid SDN/OSPF
operation remains a desirable proposition. In this paper, we propose a new
method of hybrid SDN/OSPF operation. Our method is different from other hybrid
approaches, as it uses SDN nodes to partition an OSPF domain into sub-domains
thereby achieving the traffic engineering capabilities comparable to full SDN
operation. We place SDN-enabled routers as sub-domain border nodes, while the
operation of the OSPF protocol continues unaffected. In this way, the SDN
controller can tune routing protocol updates for traffic engineering purposes
before they are flooded into sub-domains. While local routing inside
sub-domains remains stable at all times, inter-sub-domain routes can be
optimized by determining the routes in each traversed sub-domain. As the
majority of traffic in non-trivial topologies has to traverse multiple
sub-domains, our simulation results confirm that a few SDN nodes allow traffic
engineering up to a degree that renders full SDN deployment unnecessary.","Distributed IP routing protocols, like OSPF or ISIS, have worked consistently and predictably in the cur rent Internet and have proven their reliable operation over time. Software Deﬁned Networking (SDN), on the other hand, is a new networking paradigm based on a logically centralized and programmable control plane, that has gained a lot of attention recently. In fact, most network equipment vendors have announced the intention to build devices that support the OpenFlow protocol, the de facto SDN messaging standard, or have already released OpenFlowcapable products [1]. Migrating to a fully SDNenabled operation is how ever not without issues and new costly investments. In fact, ISPs are still reluctant regarding the change of the control plane paradigm in their networks from distributed tocentralized , as distributed routing pro tocols operate consistently and predictably over years, efﬁciently control real life conditions, and reliably re N S D N S D  N S D Fig. 1: Partitioning OSPF with SDN: LSA ﬂooding is limited by SDN nodes, and each SDN participates in the OSPF protocol of their corresponding subdomains. cover from network failures. A migration to SDN, on the other hand, requires new hardware, new tools, and new expertise for network administrators, while SDN still ﬁghts with some hardtokill scalability precon ceptions [2]. It is therefore no surprise that a lot of work has recognized the importance of the socalled SDN/OSPF hybrid networking paradigm [3]–[6] and many OpenFlow devices support a hybrid mode. In the current approaches, the SDN nodes build their regular forwarding tables from OSPF, while the SDN controller can insert higher priority rules (also with more sophisticated matching parameters). In this paper, we propose a new method for SDN/OSPF hybrid networking. Our method is fun damentally different from any previous work as we partition the initial OSPF domain with SDN nodes into subdomains, such that routing protocol updates for intersubdomain paths can be overridden at SDN border nodes by the SDN controller, e.g., for trafﬁc engineering purposes. This requires that neighboring subdomains are connected only via SDN nodes and do not have any direct links otherwise. The advantage of our idea over other hybrid approaches is that our partitioning method can be implemented into an op erational OSPF network by operating the SDN nodesarXiv:1410.5626v1  [cs.NI]  21 Oct 2014initially (i.e., during the migration) in plain OSPF mode. It follows that the SDN nodes in our scheme belong to allsubdomains to which they are connected. Figure 1 illustrates the idea. When all subdomain border nodes are replaced with SDNenabled devices and an optimized routing has been determined, the SDN nodes start the update process in the individual subdomains by ﬂooding routing updates that are in dividually tuned per subdomain. Our method capital izes on the advantages of distributed routing protocols by letting the routing inside each subdomain be based on OSPF solely so that it remains unchanged and stable at all times. At the same time, intersubdomain routes can be optimized by determining the routes in each traversed subdomain. As the majority of trafﬁc in nontrivial topologies has to traverse multiple sub domains, our simulation results conﬁrm that a few SDN nodes allow trafﬁc engineering up to a degree that renders the full SDN deployment unnecessary. The rest of the paper is organized as follows: Sec tion II discusses the related work and Section III presents the network architecture. The mathematical model of the trafﬁc engineering logic is presented in Section IV. Section V presents the performance study and Section VI the conclusions. II. R ELATED WORK "
348,Mathematical Modeling of Routes Maintenance and Recovery Procedure for MANETs.txt,"Routing is one of the most mysterious issues from the birth of networks up
till now. Designing routing protocols for Mobile Ad hoc Networks (MANETs) is a
complicated task because unpredictable mobility patterns of mobile nodes
greatly effect routing decisions. Various routing protocols are designed to
improve this very problem. Different simulator based routing protocols are
designed but these protocols might fail during deployment because of the
testing procedures of simulators. In this study, a novel formal model for
routes management is proposed for MANETs. Formal methods are the most novel
techniques based purely on mathematics and are used for the verification,
validation of critical systems/models and guarantee the correctness and
completeness of hardware/software systems. The proposed routing model is a
complete and detailed graph based logical model defined in VDM-SL (formal
language) and then verified and validated by using VDM-SL toolbox.","Ad hoc network is a blend of wirelessly connected nodes  regardless of fixed/dedicated infrastructure and is designed  for some specific application according to the demand [1].   These networks do not require complex, pre defined  topology, and continuous monitoring. The most dynamic  class of ad hoc networks is Mobile Ad hoc networks  (MANETs) in which nodes (every communicable entity)  are free to move causing a random change in the  topology  every time a mobile node changes its position. These  networks may have mobile or static nodes connected to  function remarkably in unattended and random fashion.  MANETs are made flexible by implementing  selfconfiguring capability that means whene ver a node is  added or removed from a network, it gets automatically  registered or unregistered from the network respectively  [2]. A very weak connectivity among nodes is observed in  MANETs because nodes move with variable speed and  follows unpredictable m ovement pattern causing a very  random topology. Figure 1 shows the random topology of  MANETs in which a rounded boundary shows the  network area in which seven mobile nodes i.e. A, B, C, D, E, F, G are connected to create a network. The first circle  shows t he network topology at time T0 at which the nodes  are connected as shown within that circle but in the second  circle the network at T0 is transformed in a different  topology at time T1 in which all nodes change their  positions and some mobile nodes are add ed and some  leaves the network.       Fig. 1   MANET Topology at T0 and T1   Nodes join and leave the network according to their  coverage spectrum and have very lesser and weak  connections among the nodes due to their randomly  changing mobility [3]. The network setup of these  networks is peer to peer network architecture and no nodes  have more rights than other [4]. Routing protocols for  MANETs should have some special features to deal with IJCSNS International Journal of Computer Science and Network Security , VOL.18 No.8,  August  2018    58  the mobility changes, for example, it must be totally  dispersed, adaptive  to recurrent variations in topology, it  should involve a least number of mobile nodes for   route/path discovery and maintenance, and must have  lowest time for connectivity set up, should be limited to  some specific area, must have no loop and self governan ce  against mobile routes [5]. MANETs have vast range of  deployment applications where there is a need of quick  and temporary network setups like military, civilian,  safety critical applications etc. The criticality of these  applications made MANETs topolog y and connectivity  and more accurately said to be ‘routing ’, more critical and  sensitive.   There are various routing protocols designed for MANETs  categorized based on the mobility model, these protocols  may follow to learn route to the desired destination where  there are mobile nodes. These protocols are designed to  bear problems like power depletion, lower bandwidth, and  high error rates, while taking routing decisions and  selection of the most suitable node (termed as relay node)  for routing packet from s ource to destination [6]. Almost  all protocols for MANETs are tested and validated through  simulation techniques for the realization of real time  network prediction but these techniques do not ensure the  correctness and consistency of the designed protocol .  There are many disasters in the past that happens due to  weak testing techniques that includes vasa ship drowning  that was a result of untested design and the explosion of  launch vehicle Ariane 5 []. The reason behind its  explosion was not following the verification results. As we  have observed that MANETs are also designed for safety  critical applications like military decisions, border  surveillance, therefore, the topology and routing decisions  of these networks are needed to be verified so that there i s  lesser probability of its failure. In this study, we have  focused on design, testing and validation methods of  routing protocols for MANETs as we have observed that  this is one of the most critical issue to get addressed  properly. Numerous tools are inte nded for the employment  of graph theory based MANETs but formal methods are  mathematical tools and techniques that provide the proof  for verification, validation, correctness of software and  hardware systems. Trend is now shifting towards  verification of n etworks through formal methods.   In this paper, we have formally verified routing  mechanism of traditional AODV protocol that is  specifically designed for MANETs and introduce route  recovery procedure to ensure maximum connectivity  among nodes. In literatur e [1l9], protocol is designed by  using Z notation which is a very abstract level formal  language and the routings described was not sufficient for  routes management in terms of bogus routes deletion and  recovery. Therefore, in this paper, a complete formal ly  verified routes management procedure is described by  using VDM SL (Vienna Development Method Specification language) [7] because it has detailed  level specification writing feature that covers almost all  the functional and non functional necessities of the  proposed mode [8]. The verification of the proposed  model is then done by using VDM SL Toolbox.   2. Related Work   "
130,Fidelity-Guarantee Entanglement Routing in Quantum Networks.txt,"Entanglement routing establishes remote entanglement connection between two
arbitrary nodes, which is one of the most important functions in quantum
networks. The existing routing mechanisms mainly improve the robustness and
throughput facing the failure of entanglement generations, which, however,
rarely include the considerations on the most important metric to evaluate the
quality of connection, entanglement fidelity. To solve this problem, we propose
purification-enabled entanglement routing designs to provide fidelity guarantee
for multiple Source-Destination (SD) pairs in quantum networks. In our
proposal, we first consider the single S-D pair scenario and design an
iterative routing algorithm, Q-PATH, to find the optimal purification decisions
along the routing path with minimum entangled pair cost. Further, a
low-complexity routing algorithm using an extended Dijkstra algorithm, Q-LEAP,
is designed to reduce the computational complexity by using a simple but
effective purification decision method. Then we consider the common scenario
with multiple S-D pairs and design a greedy-based algorithm considering
resource allocation and rerouting process for multiple routing requests. To
verify the effectiveness and superiority of the proposed algorithms, extensive
simulations are conducted, and the simulation results show that the proposed
algorithms not only can provide fidelity-guarantee routing solutions, but also
has superior performance in terms of throughput, fidelity of end-to-end
entanglement connection, and resource utilization ratio, compared with the
existing routing scheme.","In recent years, quantum information technologies have been widely developed and achieved remarkable break throughs especially in secure communications [1]. Along with the concept validation of quantum repeater and longdistance quantum communications [2, 3], the quantum network, which is foreseen to be a “gamechanger” to the classic network, is being developed at a rapid pace. In a quantum network, quantum nodes (including quantum processors and repeaters) are interconnected via optical links, and they can generate, store, exchange, and process quantum information [4, 5]. When two faraway quantum nodes, serving as source and destination, attempt to exchange information, the quantum network ﬁrst establishes the entanglement connection between them, and then information is transmitted in the form of quantum bits (called qubits ) over entanglement connection J. Li, M. Wang, K. Xue, N. Yu and Q. Sun are with the School of Cyber Science and Technology, University of Science and Technology of China, Hefei 230027, China. J. Lu is with the Department of Electronic Engineering and Information Science, Dalian Maritime University, University of Science and Technology of China, Hefei 230027, China. Corresponding Author: K. Xue (kpxue@ustc.edu.cn) Alicerepeater quantum nodequantum memory Entangled pairqubit data qubitAlice Bob Alice Bobdata Teleportation Alice BobBobEntangled pair （a）Entanglement establishment （b）Teleportationdata data（c）Multiple entangled pairs establishment （d）Entanglement swapping and remote teleportationrepeater TeleportationdataFig. 1. Illustration of information transmission in a quantum network, data qubit represents the state that Alice wished to teleport [9, chapter 4]. (a)(b) an arbitrary single qubit can be sent using shortdistance quantum teleportation. (c)(d) establishment of remote entanglement connection through entanglement swapping, data transmission using longdistance quantum teleportation. experiencing noisy channel to the destination [6]. As shown in Fig. 1, to establish such endtoend entanglement connection, entangled pairs between adjacent nodes are ﬁrst generated. After that, quantum repeater connects quantum nodes over longer distances by performing entanglement swapping, i.e., joint Bell state measurements at the local repeater aided by classical communication [7]. To build up a largescale functional quantum network with satisfying the dynamic requests from SourceDestination (S D) pairs, the critical problem we have to face ﬁrstly is how to select routing path and utilize network resources efﬁciently (such as limited entangled pairs on each edge). Recently, some existing studies are dedicated to solve such problem [8], and propose multiple entanglement routing designs to improve the robustness and throughput facing the failure of entanglement generations. Although the development of quantum network is currently at the primitive stage, these routing designs bring a good start to facilitate the process of quantum networks’ construction in the future. However, an important metric to evaluate the quality of re mote entanglement connection, entanglement ﬁdelity, is rarely considered in the exisitng entanglement routing designs. In practice, due to the noise in the system, quantum repeaters sometimes might not generate entangled pairs with a certain desired ﬁdelity, which brings negative effects on various quanarXiv:2111.07764v4  [quantph]  22 Jun 20222 tum applications [10]. For example, in quantum cryptography protocols (e.g., BB84 protocol), an entanglement ﬁdelity lower than the quantum bit error rate can reduce the security of key distribution [11]. To improve the ﬁdelity of entanglement connection and satisfy the requirement of quantum applica tions, a technique called entanglement puriﬁcation can be used to increase the ﬁdelity of entangled pairs [12]. It consumes shared lowerﬁdelity entangled pairs along the link between adjacent nodes to obtain one higherﬁdelity entangled pair. By adopting puriﬁcation technique, the entanglement routing can provide ﬁdelity guarantee for endtoend entanglement connection. Nevertheless, due to the nonlinear relationship between ﬁdelity improvement and resource consumption in pu riﬁcation operation, the additional puriﬁcation decision makes the entanglement routing problem more complicated. Thus, how to design such ﬁdelityguaranteed entanglement routing remains an unsolved problem. Based on such considerations, in this paper, we focus on puriﬁcationenabled entanglement routing design under the ﬁdelity constraint in general quantum networks. To address the complicated entanglement routing problem, we ﬁrst study the entanglement routing problem in single SD pair scenarios, and respectively propose an iterative routing algorithm to obtain the optimal solution and a lowcomplexity routing algorithm to obtain nearoptimal but efﬁcient solution. To obtain the optimal puriﬁcation decisions, we also analyze the characteristic of puriﬁcation operations and propose an optimal decision approach. After that, we further study the entanglement routing problem in multiple SD pairs scenarios, and propose a greedybased routing algorithm considering two resource allocation methods. We also conduct extensive simulations to show the superiority of the proposed algorithms compared with the existing ones. Although the existing work [13] has already proposed an entanglement distribution design and imposed a minimum endtoend ﬁdelity as a requirement, it does not take puriﬁcation into consideration and then the ﬁdelity of each Bell pair cannot be further improved. Thus, to the best of our knowledge, this is the ﬁrst work that provides endtoend ﬁdelityguaranteed entanglement routing with pu riﬁcation decision, which can fully leverage the advantages of puriﬁcation operation and signiﬁcantly improve the endtoend ﬁdelity with abundant lowﬁdelity Bell pairs. The contributions of this paper can be summarized as follows: For the requirement of highquality entanglement con nections from various quantum applications, we propose the ﬁrst entanglement routing and puriﬁcation design that provides endtoend ﬁdelityguaranteed connections for SD pairs in “advance generation” model based quan tum networks. For single SD pair scenarios, we devise two novel entanglement routing algorithms, i.e., QPATH and QLEAP, respectively. The former one can obtain multiple routing paths for satisfying single SD pair and provide the optimal routing solution with minimum en tangled pair cost, and the latter one can efﬁciently provide the routing solution with minimum ﬁdelity degradation and has the advantage of low computational complexity. Based on the routing solutions provided by algorithmsdesigned for single SD pair, we further consider the routing problem in multiple SD pairs scenarios as a resource allocation problem, and propose a greedybased routing design, which leverages two important factors of a given routing solution, i.e., resource consumption and degree of freedom, to globally allocate entanglement resources for various routing solutions and improve the efﬁciency of resource utilization. To verify the effectiveness of the proposed algorithms, extensive simulations are conducted. Compared to the existing routing scheme with puriﬁcation decisions, the proposed algorithms not only provide ﬁdelityguaranteed routing solutions, but also show the signiﬁcant superiority in terms of throughput, the average ﬁdelity of the end toend connections, and network resource utilization. The rest of this paper is organized as follows. Firstly, related work is discussed in Section II. Then, the motivation, the network model and the routing problem considered in this paper are given in Section III. After that, the entanglement routing designs for single SD pair and multiple SD pairs are given in Section IV and Section V , respectively. Finally, the performance evaluation is conducted in Section VI and conclusions are drawn in Section VII. II. R ELATED WORK "
158,A Multi-Path Certification Protocol for Mobile Ad Hoc Networks.txt,"A mobile ad hoc network (MANET) is a collection of autonomous nodes that
communicate with each other by forming a multi-hop radio network and
maintaining connections in a decentralized manner. Security remains a major
challenge for these networks due to their features of open medium, dynamically
changing topologies, reliance on cooperative algorithms, absence of centralized
monitoring points, and lack of clear lines of defense. Most of the routing
protocols for MANETs are thus vulnerable to various types of attacks. For
security, these protocols are highly dependent on cryptographic key exchange
operations. This paper presents a multi-path certification protocol for
efficient and reliable key exchange among the nodes in a MANET. Simulation
results have shown the effectiveness and efficiency of the protocol.","MANET is a collection of wireless hosts that can be   rapidly deployed as a multihop packet radio  network without the aid of any established infrastr ucture  or centralized administrator. Such networks can be used  to enable next generation battlefield applications,   including situation awareness systems for maneuveri ng  war fighters, and remotely deployed unmanned micro sensor networks. MANETs have some special   characteristic features such as unreliable wireless  media  (links) used for communication between hosts, const antly  changing network topologies and memberships, limite d  bandwidth, battery, lifetime, and computation power  of  nodes etc. While these characteristics are essentia l for the  flexibility of MANETs, they introduce specific secu rity  concerns that are absent or less severe in wired ne tworks.  MANETs are vulnerable to various types of attacks.  These include passive eavesdropping, active interfe ring,  impersonation, and denialofservice. Intrusion  prevention measures such as strong authentication a nd  redundant transmission can be used to improve the  security of an ad hoc network. However, these techn iques  can address only a subset of the threats. Moreover,  they  are costly to implement. The dynamic nature of ad h oc  networks requires that prevention techniques should  be  complemented by detection techniques, which monitor      security status of the network and identify malicio us  behavior.  One of the most critical problems in MANETs is the  security vulnerabilities of routing protocols. A se t of  nodes in a MANET may be compromised in such a way  that it may not be possible to detect their malicio us  behavior easily. Such nodes can generate new routin g  messages to advertise nonexistent links, provide  incorrect link state information, and flood other n odes  with routing traffic, thus inflicting Byzantine fai lure in the  network. Several secure routing protocols have been   proposed for MANETs based on cryptographic  mechanisms [1]. Almost all of them assume the exist ence  of a secure channel through which a security associ ation  has been established between the source and the  destination. However, the prerequisite for such a s ecure  channel to exist is the existence of a security ass ociation.  This creates a routing security interdependency cycle  [2].   In this paper, an efficient key exchange protocol i s  proposed for MANETs that can be easily integrated w ith  a routing protocol thereby providing an integrated  framework of routing and security and solving the r outing  security interdependency cycle. The rest of this pa per is  organized as follows. Section II presents some rela ted  work in MANET security. Section III describes the  proposed protocol. Section IV provides performance  evaluations of the protocol through simulations. Fi nally  Section V provides concludes the paper.  II.  RELATED WORK   "
404,An Efficient Mobile Gateway Selection and Discovery Based-Routing Protocol in Heterogeneous LTE-VANET Networks.txt,"Coupling cellular communication networks with vehicular ad hoc networks
(VANET) can be a very interesting way out for providing Internet access to
vehicles in the road. However, due to the several specific characteristics of
VANETs, making an efficient multi-hop routing from vehicular sources to the
Internet gateways through Long Term Evolution (LTE) technology is still
challenging. In this paper, an Internet mobile gateway selection scheme is
proposed to elect more potential vehicles to behave as gateways to Internet in
VANETs. Therefore, the discovery and the selection of route to those mobiles
gateways is carried out via an efficient multiple metrics-based relay selection
mechanism. The objective is to select the more reliable route to the mobile
gateways, by reducing the communication overhead and performing seamless
handover. The proposed protocol is compared with one recent protocol based on
packet delivery ratio, average end-to-end delay and overhead. The results show
that the proposed protocol ameliorates significantly the network performance in
the contrast of the other protocol.","  Internet access for VANETs will be an integral part of transport  intelligent system applications.  Indeed, this intelligent transportation field is constantly evolving, especially in recent years where  many wireless technologies have been applied to effectively share and provide data services.  Available technologies inc lude, IEEE 802.11p [1], [2], UMTS (3G) [3], LTE and LTE Advanced  (4G) [1],[4] and recently millimeter wave vehicular communications (5G)  [5].    VANETs are a promising technology that has much potential in the development of Intelligent  Transport Systems (ITS) by enabling a wide range of applications and services on the road. In  these networks, high speed mobile units, in particular vehicles, te nd to communicate with each  other, or even with roadside infrastructure. The WAVE (Wireless Access for V ehicular  Environments) protocol stack specifies an architecture including a IEEE 1609 set of standards  that are integrated with the IEEE 802.11p/WAVE st andard to adapt existing technologies  (802.11), support new technologies (such as IPv6), and define security mechanisms.   International Journal of Computer Networks & Communications (IJCNC) Vol.15, No.2, March 2023   58 IEEE 802.11p is the standard dedicated to vehicle tovehicle (V2V) and vehicle toinfrastructure  (V2I) communications in the DSRC band , on which the WAVE stack is based for the support and  the improvement of the physical layer and the media access control (MAC) layer. The IEEE  802.11p band is 5.9 GHz, consisting of seven channels, each with a frequency equal to 10 MHz,  and can communicat e within a short radio range of about 300 m. It allows data to be exchanged at  a rate of up to 27 Mbps. IEEE 802.11p protocol has shown its effectiveness for communicating  vehicles within a VANET network,  but many re searche rs [6],[7] have demonstrated  that in many  situations due to different characteristics of VANETs such as high mobility and unexpected  driver behavior, there are still several issues such as frequent link disconnection, network  topology changes , frequent fragmen tation, reliability requirement of safety applications, limited  coverage and so on, that make IEEE 802.11p protocol behave inefficiently and disable to satisfy   quality of services requirement of multiple application of VANETs and different requesting  commu nication requirement of ITS services. With the aim of overcoming certain constraints ,  various works have been proposed to integrate VANETs and cellular communication networks as  complementary components in a heterogeneous network architecture.  IEEE 802.11p  offers  high  data rate while cellular networks provide  extensive  coverage and support mobility.  The General  Packet Radio Service (GPRS), Universal Mobile Telecommunications System (UMTS) and Long  Term Evolution (LTE) are remarkable ones.     LTE is a wirele ss access technology, categorized as 4G wireless broadband. It was developed  under the Third Generation Partnership Project (3GPP). The LTE operates in a packet switched  manner and does not have a circuit switched domain, unlike GSM/GPRS and UMTS [8]. LTE is  intended to manage better system capacity and wireless coverage over large geographic areas. It  brings many advantages including support for multiple antennas, seamless incorporation with  other systems, lower latency, higher peak data rates, operating c osts, etc. Theoretically, LTE is 5  to 10 times faster than 3G(UMTS) since it provides high speed data download measured in  several hundred megabits per second (Mbps), compared to some tens of Mbps for 3G and it can  offer transfer latency lower than 5ms [6]. The LTE technology effectiveness, either in cost or in  performance, is due to its simplified network architecture which is based on Internet Protocol (IP)  and to advanced algorithms which allow better use of resources. In LTE , the base station eNBs  (evolved NodeBs) provide the gateway between mobile terminals, radio antennas, and the core  network of LTE operators to optimize all the UE’s (User Equipment) communication in a flat  radio network structure. The eNB has many feature s within an LTE network such as Radio  Resource Management, Routing data from the user plane to the service gateway, planning and  transmission of broadcast information, etc.     According to [9], utilizing protocols in heterogeneous networks instead of solely relying on IEEE  802.11p can lead to improved reliability in vehicular communication and significantly reduce  undesired delays in various vehicular applications.  This paper introduces a novel protocol called  the Internet mobile gateway selection and discove ry based routing protocol (IMGsdRP) that aims  to provide a reliable and efficient method for establishing Internet access in VANETs. The  protocol is specifically designed to maintain a stable and long lasting connection to the Internet  while ensuring high throughput and meeting the quality of service requirements of applications in  the ITS environment. Overall, the IMGsdRP protocol offers a promising solution for addressing  the challenges associated with Internet connectivity in VANETs.  The innovative IMGsd RP  routing protocol has been meticulously designed to confront the aforementioned challenges and  accomplish the stated objectives through a series of significant contributions, as enumerated  below.      By integrating key  metrics to  carefully  select potential Internet mobile gateways and  establish reliable multi hop pathways to them , IMGsdRP protocol can satisfy the quality  of services , particularly with respect to throughput, latency, and data packet delivery for International Journal of Computer Networks & Communications (IJCNC) Vol.15, No.2, March 2023   59 Internet access applications in VANETs , ensurin g seamless and uninterrupted  connectivity for vehicles  in the road.    The IMGsdRP  protocol  can make efficient use of the limited network resources,  particularly  bandwidth. For this purpose, the protocol used timer based  selection  strategy  to select the most suitable  vehicles to act as gateways and  then eventually  opt for  relays  to achieve  their IEEE 802.11p coverage without flooding network  with unnecessary  traffic .    The protocol IMGsdRP adopted a hybrid mobile gateway discovery process where it  combined the advantages of proactive and reactive approaches. The objective is to reduce  delay and overhead associated with  establishing a route to the mobile gateways.  Moreover, possessing a group of routes  to various mobile gateways and their  corresponding lifetime i n its routing table, a source vehicular node can  seamlessly   transfer the connection to the new Internet gateway before the current  one ends. Thus, the  IGMsdRP can perform a seamless handover at a reasonable time.    The IMGsdRP protocol  utilizes  some parti cular vehicles, such as  public transport  vehicles like taxis, and buses,  as mobile gateways.  This approach intercepts continual   handoffs at LTE base stations and reduces the associated signaling overhead by only  having a limited number of mobile gateways pres ent in the network.      The layout of this paper is as follows. Section 2 presents the review of the existing related works.   The proposed routing protocol IMGsdRP is detailed in Section 3. The performance of the  proposed mechanisms is evaluated in Section 4.  Finally, we give the conclusion and future work  directions in Section 5.     2. RELATED WORKS   "
381,"Evaluating and Comparing Probability of Path Loss in DSDV, OLSR and DYMO at 802.11 and 802.11p.txt","In this paper, we present path loss model for VANETs and simulate three
routing protocols; Destination Sequenced Distance Vector (DSDV), Optimized Link
State Routing (OLSR) and Dynamic MANET On-demand (DYMO) to evaluate and compare
their performance using NS-2. The main contribution of this work is enhancement
of existing techniques to achieve high efficiency of the underlying networks.
After extensive simulations in NS-2, we conclude that DSDV best performs with
802.11p while DYMO gives outstanding performance with 802.11.","Mobile Ad hoc Network (MANETs) is collection of independent mobile users taken as mobile nodes that  communicate through wireless links. The creation of network protocols for these network topologies is a complex  issue. Vehicular Ad hoc Networks (VANETs) are distributed, Self assembling communication networks that are  made up of multiple autonomous moving vehicles, and peculiarized by very high node mobility. The major purpose  of VANETs is providing pr otection and ease to the travelers.   There is no single unique protocol that is convenient for all networks impeccably. The protocols have to  commensurate to network’s unique characteristics, such as density, scalability and the mobility of the nodes. The  routing protocols subdivided into table driven and on demand based on the behavior of protocols. In table driven,  proactive protocols are based on periodic exchange of control messages and maintaining routing tables. Each node  maintains complete information  about the network topology locally. However, the reactive protocol tries to discover  a route only on demand, when it is necessary. It usually takes more time to find a route compared to a proactive  protocol. Our stimulation work is based upon comparison of three protocols in MANETs and VANETs named as  OLSR [1], DSDV [2] and DYMO [3].     2. RELATED WORK AND MOTIVATION   "
382,A Review of the Energy Efficient and Secure Multicast Routing Protocols for Mobile Ad hoc Networks.txt,"This paper presents a thorough survey of recent work addressing energy
efficient multicast routing protocols and secure multicast routing protocols in
Mobile Ad hoc Networks (MANETs). There are so many issues and solutions which
witness the need of energy management and security in ad hoc wireless networks.
The objective of a multicast routing protocol for MANETs is to support the
propagation of data from a sender to all the receivers of a multicast group
while trying to use the available bandwidth efficiently in the presence of
frequent topology changes. Multicasting can improve the efficiency of the
wireless link when sending multiple copies of messages by exploiting the
inherent broadcast property of wireless transmission. Secure multicast routing
plays a significant role in MANETs. However, offering energy efficient and
secure multicast routing is a difficult and challenging task. In recent years,
various multicast routing protocols have been proposed for MANETs. These
protocols have distinguishing features and use different mechanisms","An ad hoc network consists of a collection of auton omous mobile nodes formed by means of  multihop wireless communication without the use of  any existing network infrastructure. Ad  hoc networks have become increasingly relevant in r ecent years due to their potential  applications in battlefield, emergency disaster rel ief and etc. In an ad hoc network, each mobile  node can serve as a router. A mobile adhoc network  (MANET) is characterized by mobile  nodes without any infrastructure. Mobile nodes self organize to form a network over radio links.  The goal of MANETs is to broaden mobility into the area of autonomous, mobile and wireless  domains, where a set of nodes form the network rout ing infrastructure in an adhoc manner.  This emerging trend has stirred the support of appl ications which range from highly dynamic  Vehicular ad hoc networks (VANETs) to less dynamic applications such as moderately mobile  peertopeer wireless networks.   In ad hoc networks, nodes communicate with each oth er by way of radio signals, which are  broadcast in nature. Broadcast is a unique case of multicast, wherein all nodes in the network  should get the broadcast message. Multicasting is a  communication process in which the  transmission of packets (message) is initiated by a  single user and the message is received by  one or more end users of the network. Multicasting in wired and wireless networks has been  advantageous and used as a vital technology in many  applications such as audio/ video  conferencing, corporate communications, collaborati ve and groupware applications, distance  earning, stock quotes, distribution of software, ne ws and etc [1]. Under multicast  communications, a single stream of data can be shar ed with multiple recipients and data is only  duplicated when required [1]. International journal on applications of graph theo ry in wireless ad hoc networks and sensor networks  (GRAPHHOC) Vol.2, No.2, June 2010  2   In the wired settings, there are two popular multic ast tree schemes: shortestpath tree and core based tree. The procedure to construct shortestpat h multicast trees ensures the shortest path  from every source to every destination, but a sourc e node has to construct a tree rooted at itself.  Hence, there would exist too many shortestpath tre es existing in the network. In corebased  multicast trees, shortest path from the source node  to the destination node cannot be guaranteed,  but only one tree would be needed to connect the se t of the source nodes to a set of the receiver  nodes.   Security is a more sensitive issue in MANETs than a ny other networks due to lack of  infrastructure and the broadcast nature of the netw ork. While MANETs can be quickly set up as  needed, they also need secure routing protocols to add the security feature to normal routing  protocols. The need for more effective security mea sures arises as many passive and active  security attacks can be launched from the outside b y malicious hosts or from the inside by  compromised nodes [2]. Key management is a fundamen tal part of secure routing protocols;  existence of an effective key management framework is also paramount for secure routing  protocols. Several security protocols have been pro posed for MANETs, there is no approach  fitting all networks, because the nodes can vary be tween any devices.   However, it would be a difficult and challenging ta sk to offer energy efficient and reliable  multicast routing in MANETs. It might not be possib le to recharge / replace a mobile node that  is powered by batteries during a mission. The inade quate battery lifetime imposes a limitation  on the network performance. To take full advantage of the lifetime of nodes, traffic should be  routed in a way that energy consumption is minimize d. In recent years, various energy efficient  multicast routing protocols have been proposed. The se protocols have unique attributes and  utilize different recovery mechanisms on energy con sumption. This project will provide a  comprehensive understanding of these multicast rout ing protocols and better organize existing  ideas and work to make it easy to design multicast routing in MANETs. The goal of this paper  is to help researchers to gain a better understandi ng of energyefficient and secure routing  protocols available and assist them in the selectio n of the right protocol for their work. The rest  of the paper is organized as follows: Section 2 pre sents related work on comparisons and  surveys of multicast routing protocols for MANETs. Section 3 describes the energyefficient  multicast routing protocols and Section 4 describes  the securitybased multicast routing  protocols surveyed for MANETs. Section 5 concludes the paper.  2.  RELATED WORK   "
115,Link Quality and MAC-Overhead aware Predictive Preemptive Routing Protocol for Mobile Ad hoc Network.txt,"In Ad Hoc networks, route failure may occur due to less received power,
mobility, congestion and node failures. Many approaches have been proposed in
literature to solve this problem, where a node predicts pre-emptively the route
failure that occurs with the less received power. However, this approach
encounters some difficulties, especially in scenario without mobility where
route failures may arise. In this paper, we propose an improvement of AODV
protocol called LO-PPAODV (Link Quality and MAC-Overhead aware Predictive
Preemptive AODV). This protocol is based on new metric combine more routing
metrics (Link Quality, MAC Overhead) between each node and one hop neighbor.
Also we propose a cross-layer networking mechanism to distinguish between both
situations, failures due to congestion or mobility, and consequently avoiding
unnecessary route repair process. The LO-PPAODV was implemented using NS-2. The
simulation results show that our approach improves the overall performance of
the network. It reduces the average end to end delay, the routing overhead, MAC
errors and route errors, and increases the packet delivery fraction of the
network.","An ad hoc network consists of mobile nodes, which  communicate with each other through multihop route s.  Nodes cooperate with their neighbors to route data  packets to their final destinations. In ad hoc netw orks,  network topology is changing continuously because o f  the node movement. To maintain the communication  between nodes, many routing protocols have been  proposed, which are classified under two categories :  tabledriven and ondemand routing protocols.    Ondemand routing protocols discover routes only wh en  the source needs to send packets. Therefore, there is  almost no route maintenance overhead, whereas the r oute  discovery before data transmission increases the de lay.  However, if the link failure happened, nodes should   inform the sources to change the existing route and   retransmit the packets that were lost due to link f ailure.  Therefore, ondemand routing protocols increase del ay  and decrease the successful packet arrival ratio. T his  causes the reduction of the packet delivery ratio.   Several approaches have been proposed [3,4] to flex ibly  anticipate link failure by adding a function that p redicts  the link failure in one of the popular ondemand ro uting  protocols which is Ad hoc Ondemand Distance Vector   (AODV).     Previous approaches encounter some difficulties,  especially in scenario without mobility. The proble m is  that these approaches predict link failures based o f RSS  information and interpret that it happened due to n ode  mobility, where actually it was due to congestion.  Therefore, the process of route repair should not b e  performed since it increases even more the congesti on,  decreasing the overall performance of the network.    Transmitting information to a neighboring node in M AC  layer is preceded by the exchange of Request To Sen d  (RTS)/Clear To Send (CTS) frames. If this  communication fails, the MAC layer waits (back off time)  and retries later. After several failed attempts, t he MAC  layer informs the routing layer using a cross layer   interaction. In our approach, the cause of that  unsuccessful communication is sent to the routing l ayer.  If the last received power of the destination node  indicates that it is reachable, the routing layer i s informed,  using the variable xmit_reason with the value  XMIT_REASON_HIGH_RSS. Depending on this  information a node will decide whether it performs a  route repair or not.      In this paper, we propose Link Quality and MAC Overhead aware Predictive Preemptive Ad hoc On Demand Distance Vector (LOPPAODV), it is an on demand routing protocol  based on new metric combin e  more routing metrics (Link Quality, MAC Overhead),  that aims to create congestionfree routes by makin g use  of information gathered from the MAC layer. Also we   propose a crosslayer networking mechanism to  distinguish between both situations, failures due t o  congestion or mobility, and consequently avoiding  unnecessary route repair process, where we use a “R oute  Failure Prediction Technique” based on the Lagrange   interpolation for estimating whether an active link  is  about to fail or will fail.     The rest of the paper is organized as follows. Sect ion 2  describes related works; section 3 describes an ove rview   of AODV; the proposed protocol is presented in sect ion 4  and its performance is evaluated and compared with that  of PPAODV in section 5. Some conclusions are given in  section 6.  2. Related Works  "
76,Routing protocol for wireless quantum multi-hop Mesh backbone network based on partially entangled GHZ state.txt,"Quantum multi-hop teleportation is important in the field of quantum
communication. In this study, we propose a quantum multi-hop communication
model and a quantum routing protocol with multi-hop teleportation for wireless
mesh backbone networks. Based on an analysis of quantum multi-hop protocols, a
partially entangled Greenberger--Horne--Zeilinger (GHZ) state is selected as
the quantum channel for the proposed protocol. Both quantum and classical
wireless channels exist between two neighboring nodes along the route. With the
proposed routing protocol, quantum information can be transmitted hop by hop
from the source node to the destination node. Based on multi-hop teleportation
based on the partially entangled GHZ state, a quantum route established with
the minimum number of hops. The difference between our routing protocol and the
classical one is that in the former, the processes used to find a quantum route
and establish quantum channel entanglement occur simultaneously. The Bell state
measurement results of each hop are piggybacked to quantum route finding
information. This method reduces the total number of packets and the magnitude
of air interface delay. The deduction of the establishment of a quantum channel
between source and destination is also presented here. The final success
probability of quantum multi-hop teleportation in wireless mesh backbone
networks was simulated and analyzed. Our research shows that quantum multi-hop
teleportation in wireless mesh backbone networks through a partially entangled
GHZ state is feasible.","Quantum communication technology is a popular subject of research in the field of  quantum information [1 5]. There are two methods to transmit quantum information  between nodes. One involves the direct transfer of quantum states, whereas the other  facilita tes the indirect transfer of such states through quantum teleportation.  Considering that qubits are sensitive to the environment and, hence, that some loss of  information can occur, when quantum information needs to be transferred between two                                                                       distant nodes , quantum teleportation is a more feasible method. Quantum teleportation  is thus widely used to transmit quantum information, and quantum entanglement is  usually exploited in quantum teleportation. At the beginning of such a transfer,  communication resourc es are usually EPR pairs, named after Einstein, Podolsky, and  Rosen. Bennett et al. proposed the first protocol for long distance quantum  communication [1], which was experimentally verified in 1997 by Bouwmeester et al.  [2]. Entanglement swapping helps ov ercome the distance limitation between two nodes.  It introduces intermediate nodes to realize entanglement in point to point  communication. In recent years, partially entangled states have garnered significant  interest [6 15]. Sheng et al. proposed a schem e for efficient, two step entanglement  concentration b ased on arbitrary W states [6]. Gour proposed faithful teleportation with  partially entangled states [7]. Dai et al. presented a scheme where a partially entangled  Greenberger Horne Zeilinger (GHZ) st ate and a partially entangled W state are used  as the quantum channel to teleport an unknown two particle state from a sender to either  of two receivers [8].    In the future, long distance transmission of quantum information through networks  will emerge as an important field of research. With the development of quantum  communication, research on multi hop teleportation is required [16 20]. In order to  transmit quantum information between nodes that do not share direct entanglement,  intermediate nodes are usu ally introduced. Quantum channels can be built through  entanglement shared by adjacent nodes. Shi et al. proposed a quantum wireless multi  hop network where quantum information is transmitted hop by hop through  teleportation, and W states are used as entan gled resource [16]. Cai et al. proposed a  quantum bridging method to teleport qubits using partially entangled states in hop by hop transmission [17]. Wang et al. [19] proposed and verified a method to help teleport  a quantum state from source to destination. In this method, intermediate nodes can  implement teleportation in parallel. In our previous work, we proposed a quantum  multi hop teleportation protocol based  on a partially entangled GHZ state [20].   While wireless technology has provided flexible methods for classical  communication networks, it is rarely used in quantum communication networks even  though there is exciting potential for application. Few studies  have addressed complex,  wireless quantum communication networks [19 23]. Wang et al. proposed a quantum  routing protocol that can reduce end toend communication delay by using  simultaneous measurements [19]. Cheng et al. proposed a quantum routing mechan ism  using quantum teleportation in a hierarchical network architecture [20]. Yu et al.  proposed a routing protocol for a wireless ad hoc quantum communication network  (WAQCN) [21].   In this paper, we describe our proposed model for a wireless quantum multi hop  communication network with a mesh backbone structure. In this network, we introduce  a special node, called the edge route node, to connect the client node with the backbone.  By studying existing quantum multi hop protocols, we selected a partially ent angled  GHZ state as the entangled resource: we have studied this in [18] in the context of  quantum channels. The proposed routing protocol is different from the classical routing  protocol in that the processes of quantum route finding and quantum channel     establishment occurs simultaneously in ours. In the route finding process, the Bell state  measurement results of each hop are piggybacked to the quantum route finding packet.  This routing protocol reduces the total number of packets and the magnitude of the  air  interface delay.   The rest of this article is organized as follows: In Section 2, we describe our design  of a mesh structure in wireless quantum networks. Section 3 is devoted to an analysis  of prevalent research on quantum multi hop teleportation. We  also revise our past  insights on quantum multi hop teleportation based on a partially entangled GHZ state.  In Section 4, a quantum communication routing protocol based on the partially  entangled GHZ state is proposed for multi hop teleportation in wireles s mesh networks.  In Section 5, quantum channel establishment in the proposed routing protocol is  deduced. An example of routing transmission is presented in Section 6. The  corresponding success probability of quantum teleportation in this network is analyz ed  and simulation results are provided in Section 7. Finally, we draw our conclusions in  Section 8.     2. A mesh structure  in wireless quantum multi hop communication   ：Route nodes in the mesh backbone network ：Edge route nodes in the mesh backbone network ：Client Nodes outside the mesh backbone network Fig.1  A mode l of the wireless quantum communication network     The wireless mesh network (WMN) is a self organizing and self healing network  that has been employed for classical wireless communication. It is an easily scalable  and low cost network that uses a multi hop routing mechanism and a hierarchy  configuration. The WMN consists of mesh routers and mesh clients. Mesh routers are  stationary or have minimal mobility, and serve as the backbone of the WMN in  providing wireless access to mesh clients. Mesh clients are removable.      Based on the traditional WMN, a mesh str ucture is introduced to wireless quantum  communication, and a model of this wireless quantum mesh network is shown in Fig.  1. The figure shows that there are three kinds of nodes and two kinds of channels. The  gray oval represents the scope of the mesh bac kbone network, similar to mesh routers  in the traditional WMN. The backbone network is composed of route nodes and edge  route nodes. The square nodes in the gray oval are route nodes that do not directly  connect to client nodes. Triangular nodes, called ed ge route nodes, act as bridging  points to implement quantum and wireless access between nodes in the mesh backbone  network and client nodes outside the network. The circular nodes represent client nodes  that have a direct quantum and wireless channel with a neighboring edge route node.  Every edge route node has a client list to record addresses of client nodes connected to  it.   There are two kinds of communication channels in this distributed wireless quantum  network: classical wireless and quantum wireless  channels. The solid lines in Fig. 1  represent classical communication channels and the dotted lines represent quantum  communication channels. Classical information such as measurement results and Bell  pair types are transmitted through classical wireless channels. Only when classical and  quantum routes exist simultaneously can quantum information be transmitted between  nodes. Nodes along the quantum route share entanglement one by one, and quantum  information is transferred through the quantum route. Nodes  along the classical route  can transfer classical information. For two nodes, if there is a direct classical or a  quantum route between them, they are called neighbor nodes in quantum or wireless,  respectively. For client nodes connected to the same edge r oute node, quantum  information can be teleported directly between them or through their edge route node.  For nodes not connected with the same edge route node, a quantum route through the  backbone network can be selected to realize long distance quantum co mmunication by  introducing intermediate route nodes. With this method, quantum information can be  transferred hop by hop from source nodes to destination nodes.     3.  Related works on quantum multi hop channels   "
23,Approximate performance analysis of generalized join the shortest queue routing.txt,"In this paper we propose a highly accurate approximate performance analysis
of a heterogeneous server system with a processor sharing service discipline
and a general job-size distribution under a generalized join the shortest queue
(GJSQ) routing protocol. The GJSQ routing protocol is a natural extension of
the well-known join the shortest queue routing policy that takes into account
the non-identical service rates in addition to the number of jobs at each
server. The performance metrics that are of interest here are the equilibrium
distribution and the mean and standard deviation of the number of jobs at each
server. We show that the latter metrics are near-insensitive to the job-size
distribution using simulation experiments. By applying a single queue
approximation we model each server as a single server queue with a
state-dependent arrival process, independent of other servers in the system,
and derive the distribution of the number of jobs at the server. These
state-dependent arrival rates are intended to capture the inherent correlation
between servers in the original system and behave in a rather atypical way.","1.1 Motivation This work is motivated by web server farms. Server farms have gained popularity for pro viding scalable and reliable computing and web services. Most commonly the objective in analyzing such a system lies in the determination of an optimal or nearoptimal load balancing routing protocol so as to maximize the performance of the system, see, e.g., [1, 6, 8], where the performance of interest is usually the mean response time for an arbitrary job. In this paper the objective is to report some interesting properties of the arrival  ow to each server and suggest an approximation approach for the GJSQ routing protocol. We consider farms with heterogeneous servers, which is motivated by the dierent hardware and the wide variety of computing capacities regarding processing power and memory access performance seen in practice in server farms [13]. We assume that service requests arrive to the system according to a Poisson process. Upon arrival, a frontend dispatcher routes the request to one of the servers. After the request has been routed to the server, we assume that it cannot balk or jokey. All requests routed to a server are sharing the provided service (think of bandwidth, Department of Mechanical Engineering, Eindhoven University of Technology yDepartment of Mathematics and Computer Science, Eindhoven University of Technology zDepartment of Industrial Engineering & Innovation Sciences, Eindhoven University of Technology Email address: j.selen@tue.nl 1arXiv:1509.05533v2  [math.PR]  23 Nov 2015CPU, or RAM). We assume a PS service discipline at each server since it closely approximates the scheduling policies [7, 10] employed by most commodity operating systems (e.g., Linux CPU timesharing) and is a popular policy in computing centers (e.g., Cisco Local Director, IBM Network Dispatcher and Microsoft Sharepoint, see [3] for a survey). In [5] the authors consider a server farm consisting of homogeneous servers, where upon arrival jobs are routed according to the JSQ routing protocol. This protocol in case of homo geneous servers, due to the PS service discipline, is performing nearoptimal in terms of the mean response time. However, as indicated by Whitt in [15], the JSQ policy is far from optimal in case of heterogeneous servers. In [2] the authors comment on the performance of various systems under dierent routing protocols and conclude that the shortest expected delay (SED) routing protocol is nearoptimal in terms of mean response time. The SED policy is a policy that routes jobs upon arrival to the queue promising the minimum expected delay (which also includes the processing time). In case of exponential jobsize distributions, the GJSQ and SED routing protocols are identical and in case of homogeneous servers GJSQ and JSQ are the same. However, in case of general jobsize distributions and heterogeneous servers we assume that the only available information are the service rates and the number of jobs at each server, i.e. we do not keep track of residual processing times. Due to the complexity and the various challenges that the model at hand presents, we restrict our analysis to the case of two heterogeneous servers with a general jobsize distri bution under the GJSQ routing protocol. From here onwards we refer to this model as the M=G (1;s)=2=GJSQ=PS system, abbreviated as the GJSQ model, where Gis the jobsize dis tribution and 1 and sare the service rates at servers 1 and 2, respectively. The approach described in this paper can be seen as a rst stepping stone towards the analysis of heteroge neous server farms with PS servers; a very broad area, full of interesting problems. Moreover, the ideas presented here extend the work of Gupta et al. [5] on the analysis of the JSQ routing for homogeneous web server farms. 1.2 Related work "
344,Anypath Routing Protocol Design via Q-Learning for Underwater Sensor Networks.txt,"As a promising technology in the Internet of Underwater Things, underwater
sensor networks have drawn a widespread attention from both academia and
industry. However, designing a routing protocol for underwater sensor networks
is a great challenge due to high energy consumption and large latency in the
underwater environment. This paper proposes a Q-learning-based
localization-free anypath routing (QLFR) protocol to prolong the lifetime as
well as reduce the end-to-end delay for underwater sensor networks. Aiming at
optimal routing policies, the Q-value is calculated by jointly considering the
residual energy and depth information of sensor nodes throughout the routing
process. More specifically, we define two reward functions (i.e., depth-related
and energy-related rewards) for Q-learning with the objective of reducing
latency and extending network lifetime. In addition, a new holding time
mechanism for packet forwarding is designed according to the priority of
forwarding candidate nodes. Furthermore, a mathematical analysis is presented
to analyze the performance of the proposed routing protocol. Extensive
simulation results demonstrate the superiority performance of the proposed
routing protocol in terms of the end-to-end delay and the network lifetime.","THE Internet of Things (IoT), as a promising networking paradigm, can render convenient and efﬁcient services for a wide range of application domains without manual inter vention [1]–[4]. With an increasing interest in observing and exploring marine resources, the concept of IoT has extended to underwater environments, forming the socalled Internet of Underwater Things (IoUT) [5]–[7]. The IoUT is committed to providing interconnectivity among intelligent underwater devices to monitor vast unexplored underwater areas [8]. As critical infrastructure in the IoUT, underwater sensor networks (UWSN) have found numerous underwater applications [9], such as offshore oil exploration and extraction, environmental observation for scientiﬁc exploration, ocean disaster preven tion, mine recognition, and navigation assistance [10]–[14]. Fig. 1 illustrates the architecture of the UWSN. Due to the harsh underwater environment and high deployment costs, Yuan Zhou is a visiting fellow with the Department of Electri cal Engineering, Princeton University, Princeton, NJ, USA. (email: yuanzhou@princeton.edu) Yuan Zhou and Tao Cao are with the School of Electrical and In formation Engineering, Tianjin University, Tianjin 300072, China. (email: zhouyuan@tju.edu.cn, caotao@tju.edu.cn) Wei Xiang is with the College of Science, Technology and Engi neering, James Cook University, Cairns QLD 4870 Australia. (email: wei.xiang@jcu.edu.cn) Underwater  sensor nodeSinkOnshore   monitoring  center SeabedWater  surfaceFig. 1. Schematic of the UWSN. deploying UWSNs is much more challenging than deploying terrestrial wireless sensor networks (WSNs) [15]–[17]. Acoustic communications are preferred for UWSNs because they provide longer propagation distances [18]. However, the propagation speed of underwater acoustic waves is approxi mately 1500 m/s [19], resulting in large propagation latency for underwater networking services. In addition, energy efﬁ ciency has also been a major design concern for UWSNs due to the high communication energy cost [20] and the limited energy [21]. Anypath routing (a.k.a. opportunistic routing) [22] is con sidered an effective strategy for both energy efﬁciency and propagation latency in UWSNs. Using anypath routing, a subset of neighboring nodes is selected by the sender as the forwarding candidates according to certain criteria, e.g., energy efﬁciency and latency. Meanwhile, these selected forwarding candidates are assigned different priorities so that they can cooperate with each other to elect the appropriate nexthop forwarder which minimizes redundant packet transmission. To address the energy efﬁciency problem, many anypath routing protocols for UWSNs favor the shortest path to for ward sensory data so as to minimize energy consumption [22]–[24]. However, some nodes may be overburdened with transmitting too many packets and become hot spots in these methods. These hot spots may fail prematurely due to energy exhaustion, disrupting the operations and shortening the life time of the entire UWSN [25]–[27]. To extend the network lifetime, it is proposed encourage packet forwarding via the nodes with more residual energy [28]–[30].arXiv:2002.09623v1  [cs.NI]  22 Feb 2020IEEE INTERNET OF THINGS JOURNAL 2 To tackle the latency issue, some anypath routing protocols are proposed by employing greedy approaches to reduce the endtoend delay [31]–[33]. However, the greedy approaches do not consider the longterm rewards. Thus, using these algorithms, the next hop chosen by the current node may not be the global optimal one for the whole routing path. Moreover, fulldimensional location information is usually required in the routing design process of these methods, which may not be practical in the underwater environment. In order to simultaneously tackle the issues of high endto end latency and low energy efﬁciency in UWSNs, this paper proposes a novel Qlearningbased localizationfree anypath routing (QLFR) protocol. By using the Qlearning algorithm, the QLFR protocol takes the longterm reward into account, and thus is able to make a global optimal routing decision. Two reward functions, i.e., the depthrelated and energy related rewards, are designed for Qlearning. More elaborately, with the depthrelated reward function, the proposed routing protocol does not require knowledge of the fulldimensional localization of nodes; instead, it only needs to know the depth information which can be easily obtained with a hydraulic pressure gauge. With the energyrelated reward function, the nodes with more residual energy are more likely to forward data packets. As a result, the workload among sensor nodes is more balanced. We also design a new holding time mechanism for anypath packet forwarding. With such a mechanism, the forwarding candidate nodes are scheduled to transmit data packages in accordance with their priority levels. In addition, a multipath suppression scheme is proposed to further reduce unnecessary transmissions and to improve energy efﬁciency. The main contributions of this paper are summarized as follows. 1) Different from other Qlearning based routing protocols which simply choose the neighbor with the maximum Q value as the next hop, we design a priority mechanism according to the Qvalue when choosing an appropriate next hop; 2) We design a new holding time mechanism for any path routing, according to the priority optimized by Q learning. To the best of our knowledge, we are the ﬁrst to use the reinforcement learning technique to design anypath routing protocols in UWSNs; and 3) We propose a multipath suppression scheme to further reduce unnecessary transmissions while ensuring a high packet delivery ratio. The rest of this paper is organized as follow. Section II provides an overview of the related work on routing protocols for UWSNs. In Section III, we ﬁrst present the network topology architecture, and then model the UWSN routing problem in the general framework of Qleaning. Section IV describes the proposed QLFR algorithm in detail and Section V elaborate on the corresponding routing protocol. A theo retical analysis of the protocol performance is presented in Section VI. Simulation results and discussions are reported in Section VII. Finally, concluding remarks are drawn in Section VIII. Symbols used in the following sections are listed and deﬁned in Table I.TABLE I SYMBOL LIST Parameters Deﬁnition S;A;P;R Set of states, actions, transition probabilities and rewards in reinforcement learning theory, respectively St;At State and action in timestep t r; Reward function and policy in reinforcement learning theory V(s);V(s) Expected reward when starting in state s, following policy and the corresponding approximated value in Qlearning Q(s;a);Q(s;a)Expected reward after taking action a in states, following policy and the corresponding approximated value in Qlearning  ; Discount factor and learning rate in calculating Qvalue ce Residual energyrelated reward function cd Depthrelated reward function eres(si) Residual energy of node si eini(si) Initial energy of node si depth (si) Depth of node si d(si;sj) Difference between the depth of node siandsj n The sequence number of a sensor node in the priority list  Holding time k;b Parameters of holding time R Maximal transmission range of a node v0 Speed of acoustic waves in water tmax Maximal propagation delay of one hop v Movement speed of nodes in UWSN A(l;f) Attenuation of underwater acoustic signal with frequency fkHz at transmission distancelmeters SNR (l;f) Average signaltonoise ratio p(l;f;M ) Packet error rate when the size of packet isMbits Psi"
364,Empirical Evaluation of the Heat-Diffusion Collection Protocol for Wireless Sensor Networks.txt,"Heat-Diffusion (HD) routing is our recently-developed queue-aware routing
policy for multi-hop wireless networks inspired by Thermodynamics. In the prior
theoretical studies, we have shown that HD routing guarantees throughput
optimality, minimizes a quadratic routing cost, minimizes queue congestion on
the network, and provides a trade-off between routing cost and queueing delay
that is Pareto-Optimal. While striking, these guarantees are based on idealized
assumptions (including global synchronization, centralized control, and
infinite buffers) and heretofore have only been evaluated through simplified
numerical simulations. We present here the first practical decentralized
version of HD algorithm, which we refer to as Heat-Diffusion Collection
Protocol (HDCP), for wireless sensor networks. We present a thorough evaluation
of HDCP based on real testbed experiments, including a comparative analysis of
its performance with respect to the state of the art Collection Tree Protocol
(CTP) and Backpressure Collection Protocol (BCP) for wireless sensor networks.
We find that HDCP has a significantly higher throughput region and greater
resilience to interference compared to CTP. However, we also find that the best
performance of HDCP is comparable to the best performance of BCP, due to the
similarity in their neighbor rankings, which we verify through a Kendall's-Tau
test.","Low power wireless sensor networks tend to be used for lowdata rate ap plications. However, their scaling in terms of network size as well as operation under low duty cycles is often limited due to bandwidth constraints. Routing algorithms that can utilize the full bandwidth capacity of the network are there fore very important and continue to be a subject of research and development. Throughput Optimality: In network theory, the ability to fully utilize the available bandwidth in a network is tied to the notion of throughput op timality. An algorithm is said to be throughput optimal if it has the ability to maintain stable queues at any set of arrival rates that could possibly be stabilized by at least one algorithm. The BackPressure (BP) routing algorithm [1] was the rst queueaware routing protocol to oer in theory a throughput optimality guarantee under general link state and trac conditions. It has been translated to practice in the form of the Backpressure Collection Protocol (BCP) [2] for wireless sensor networks, which was shown to provide improved capacity and robustness to link dynamics compared to the stateoftheart queueunaware treebased routing protocols (e.g., the well known Collection Tree Protocol, CTP [3]). What is Heat Diusion (HD) algorithm? The Heat Diusion (HD) al gorithm [4] is our recently proposed alternate queueaware throughput optimal routing policy for wireless networks. It is derived from a combinatorial ana log of the classical Heat Diusion equation in Thermodynamics (where queue size is analogous to temperature, and packet  ow to heat  ow) that takes into account wireless interference constraints. Moreover, in [5] we have shown that the underlying mathematical formalism is also essentially the same as current  ows in resistive circuits. Therefore, the link penalties corresponding to resis tances can be incorporated into HD routing in a way that allows for minimizing a specic form of average routing cost referred to as the Dirichlet routing cost. 2The Dirichlet routing cost is dened as the product of a link's cost and square of the respective link's  ow rate. Moreover, the HD algorithm also minimizes the overall queue congestion of the network among the class of throughput op timal algorithms that make decision based on only current queue occupancies and link statistics. The HD routing algorithm guarantees to operate on the Pareto boundary if both routing costs and queue occupancies are considered in the objective function. We detail the HD algorithm in Section 3. Motivation of Our Work: In theory, the HD routing algorithm goes beyond just throughput optimality guarantees to provide additional signicant improvements in average queue sizes (delay) and average routing costs (such as expected transmission count, ETX1) compared to traditional Backpressure routing. To date, this HD algorithm has remained a theoretical and idealized construct that requires a centralized implementation. This centralized version requires a complete knowledge of a network and a NPhard scheduling procedure at each time and assumes that buer sizes are unbounded at all nodes. What has been missing in the literature is a practical implementation of the HD policy that is distributed and works with nite buer lengths, and whose performance is studied comprehensively on a real wireless testbed. We seek to address this gap. Our Contribution: Our contribution in this paper is multifold. First , we present the rstever decentralized version of the HeatDiusion algorithm and present a Contiki OS [7] based practical protocol implementation for data collection in wireless sensor networks: the Heat Diusion Collection Protocol (HDCP). This also include practicallymotivated enhancements of the original Heat Diusion algorithm, modications to the link weight calculations, and a link switching scheme to diversify the link usage. Second , we propose and evalu ate a new method of dynamic ETX calculation suitable for any dynamic routing algorithm, including the previously proposed BCP [2] as well as HDCP. Third , 1The expected transmission count (ETX) is a wellknown link quality metric in the context of wireless communication which represents the average number of transmissions required for every successful packet transfer [6]. 3we present and analyze the data collected from an extensive set of practical experiments conducted with HDCP utilizing forty ve nodes on a real wireless sensor network testbed. Based on these data, we discuss the variation in the performance of HDCP under dierent parameters. Fourth , we compare HDCP with a ContikiOS implementation of BCP [2] as well as CTP [3]. We show that on the real testbed, HDCP oers signicant improvements in performance over CTP in terms of throughput as well as resilience to external interference and node failures. We also show that the performance of HDCP is similar to BCP, and through evaluation of a Kendall's Tau similarity measure, show that this is due to similar rankings among the neighbors. Finally , we also verify that HDCP performs well with a low power communication stack (CXMAC, a version of XMAC[8] that is provided in Contiki, with 5% duty cycle). Paper Organization: The rest of the paper is organized as follows. In Section 2, we present a brief overview of the existing related works followed by a brief summary of the theoretical HD algorithm in Section 3. We introduce the proposed Heat Diusion Collection Protocol in Section 4. Section 5 explains the practical implementation details of HDCP for the real experiment based comparative analysis of HDCP presented in Section 6. The similar empirical performance between HDCP and BCP is analyzed and explained in Section 7. Section 8 concludes the paper. 2. Related Works "
25,Energy Aware Clustering Protocol(EACP) For Heterogeneous WSNs.txt,"Energy saving to prolong the network life is an important design issue while
developing a new routing protocol for wireless sensor network. Clustering is a
key technique for this and helps in maximizing the network lifetime and
scalability. Most of the routing and data dissemination protocols of WSN assume
a homogeneous network architecture, in which all sensors have the same
capabilities in terms of battery power, communication, sensing, storage, and
processing. Recently, there has been an interest in heterogeneous sensor
networks, especially for real deployments. This research paper has proposed a
new energy aware clustering protocol (EACP) for heterogeneous wireless sensor
networks. Heterogeneity is introduced in EACP by using two types of nodes:
normal and advanced. In EACP cluster heads for normal nodes are elected with
the help of a probability scheme based on residual and average energy of the
normal nodes. This will ensure that only the high residual normal nodes can
become the cluster head in a round. Advanced nodes use a separate probability
based scheme for cluster head election and they will further act as a gateway
for normal cluster heads and transmit their data load to base station when they
are not doing the duty of a cluster head. Finally a sleep state is suggested
for some sensor nodes during cluster formation phase to save network energy.
The performance of EACP is compared with SEP and simulation result shows the
better result for stability period, network life and energy saving than SEP.","  Wireless sensor network consists of a large number of tiny sensors and a sink or base station. Sink  generally acts as a gateway for other network.  Sen sors not only sense the region, but also able to  do computation, storage and communication to other sensors, including remote located base  station by using a wireless medium. A tremendous am ount of research activities has been going  on in sensor networks due to their vital importance  to a number of civilian and military  applications. Wireless sensor networks are used for  battlefield surveillance, for monitoring and  tracking of nuclear plants and hazard locations [4] ,[5],[6],[7],[8],[9],[10]. Sensors are battery  operated devices therefore it is crucial that they utilize their energy in an effective manner to  increase the life of the network.     WSNs are usually deployed in a random way without a ny pre planning and exposed to terrible  and dynamic environments. Sensor networks have to w ork for years without any attention from  the external world. As a result, conventional algor ithms which are suitable for other wireless  networks like MANET (Mobile Adhoc Network) and cell ular system cannot be applied directly to  WSN [4], [5], [6]. Effective organization of the no des to form clusters can save a significant International Journal of Computer Networks & Commun ications (IJCNC) Vol.6, No.4, July 2014  24  amount of network energy [9].  In hierarchical or c luster based routing high energy nodes do the  data processing and transmission while low energy n ode sense the region. It is an effective way to  reduce the energy consumption of the network by per forming data aggregation or data fusion to  decrease the number of transmissions to base statio ns [4], [11], [21]. Sensor network are of two  types: homogeneous and heterogeneous. When all the sensors of the network have the same  capacity in terms of energy, storage and computatio n it is known as a homogeneous sensor  network. However when the sensor nodes differ from each other in terms of energy, storage and  computation it creates a heterogeneous network. Het erogeneity in sensor network helps in  increasing the network lifetime and reliability. In  this paper an energy aware clustering protocol is  proposed to maximize the network lifetime. The prot ocol suggests a novel technique for cluster  heads election and introduces a gateway concept for  advance nodes to transfer the data load of  normal cluster heads to base station. To save the e nergy of the network further, a sleep state is  suggested for some sensor nodes.     The rest of this paper is organized as follows. In section 2, the related work is briefly reviewed.  Section 3 explains the detail of purposed protocol.  Section 4 exhibits the performance of EACP  by simulations and compares it with SEP. The paper is concluded in section 5 with the direction  for future work.      2.  RELATED WORK   "
213,A Trustworthy and well-organized data disseminating scheme for ad-hoc wsns.txt,"Wireless Sensor Networks (WSNs) generate massive amount of live data and
events sensed through dispersedly deployed tiny sensors. This generated data
needed to be disseminate to the sink with slight consumption of network
resources. One of the ways to efficiently transmit this bulk data is gossiping.
An important consideration in gossip-based dissemination protocols is to keep
routing table up to date. Considering the inherent resource constrained nature
of adhoc wireless sensor networks, we propose a gossip based protocol that
consumes little resources. Our proposed scheme aims to keep the routing table
size R as low as possible yet it ensures that the diameter is small too. We
learned the performance of our proposed protocol through simulations. Results
show that our proposed protocol attains major improvement in network
reachability and connectivity.","A wireless sensor network (WSN) [17] is a mu ltihop wireless network consisting of spatially  distributed autonomous sensors with sensing, computation and wireless communication  capabilities. Each sensor is ge nerally a constrained device w ith relatively small memory,  restricted computation capability, short range wireless transmitterreceiver and limited builtin  battery. The deployment of sensors can be done in a random fashion ( e.g., airplane dropping in a  disaster management scenario), or placed manually in strategic locations ( e.g., for intrusion  detection or target tracking applications). These sensor nodes distributed over a given area are  used to monitor and disseminate the collected ev ents towards a base station, or sink, for post analysis and processing. Typica l sensed phenomena includes te mperature, humidity, position,  speed, motion, and others used in applications ranging from health care and logistics, through  agriculture, forestry, civil and construction  engineering, to surveillance and military  applications.   Applications for wireless sensor networks [17] fall in three major categories: (i) Periodic  sensing: sensors are always monitoring the physical environment and continuously reporting  measurements to the sink, such as in  weather monitoring applications; (ii) Eventdriven: sensors  operate in a silent monitoring state and are programmed to notify about events, such as the  presence of objects in intrusion detection, targ et tracking or military applications; and (iii)  Querybased: the generated data reports are kept available within the sensor network, and  sensors react to the sink’s queries by returning the corresponding requested measurements and  events.  International Journal of Computer Networks & Communications (IJCNC), Vol.2, No.3, May 2010             171 Since sensor nodes are energy limited and may fail at any moment, this data delivery is far from  secure. Therefore, it is important to design no vel solution to allow a robust and reliable data  dissemination. Take the example of a geographic al area being monitored for security breaches.  Many dissemination protocols have been proposed to allow the dissemination of the collected  events towards a static sink. All the events ge nerated must reliably transmit to the sink node.  Wireless adhoc networks are formed by a set of hosts that communicate with each other over a  wireless channel. They provide an exclusive communication model. Each node has the ability to  communicate directly with another node (or several of them) in its physical neighbourhood.  They operate in a selforganized and decentralized manner and message communication takes  place via multihop spreading. Any packet sent from one node to another may pass through a  number of intermediate nodes acting as routers. The deployed adhoc WSNs pose great challenges in reliable sensed data delivery. Due to the small transmission  range of sensor nodes  the data is forwarded using multiple hops where unexpected node failure is common at each  hop. Routing techniques in adhoc sensor network gives priority to reliable transmission as the  loss of important information prevents these sens or networks from fulfilling its primary purpose  and hence this information loss should be avoided.   The commonly used routing protocols uses single path routing or multiple path routing  techniques to deliver the data , without providing reliable in formation dissemination and hence  the overhead involve is same for all information. This paper presents a reliable data  dissemination technique with efficient reso urce management for adhoc WSNs. The major  contribution of the proposed scheme is to reduce the overhead of the acknowledgement. The  proposed protocol is based on a simple idea of delaying the acknowledgement when and where possible. The acknowledgment is being delayed till it reaches the N th node conditionally the Nth  node has the strength to send acknowledgement back to the source. At the same time, if the  source node has the same signal strength, it will send the next data chunk directly to the Nth  node. Thus, saving considerable amount of network resources. Even the collision can be  avoided by allocating the time slots plus ensuring the coordination among the nodes.   The proposed protocol works for adhoc WSNs and is not Applicable for WSNs because of  relatively large number of nodes in the sensor networks. Again in WSN, it is not possible to  build a global addressing scheme for the deployment of a large number of sensor nodes as the  overhead of ID maintenance is high. Second, in  contrast to typical communication networks,  almost all applications of sensor networks require  the flow of sensed da ta from multiple sources  to a particular BS. This, however, does not preven t the flow of data to be in other forms (e.g.,  multicast or peer to peer). The remainder of the paper is organized as follows. Section 2 describes of the related work. Section 3 provides a detail description of our proposed protocol.  In Section 4 we discuss the simulation results and analyse the performance and cost of our  algorithm. Finally, we conclude the paper in Section 5.   2. RELATED WORK   "
452,Noise in the Clouds: Influence of Network Performance Variability on Application Scalability.txt,"Cloud computing represents an appealing opportunity for cost-effective
deployment of HPC workloads on the best-fitting hardware. However, although
cloud and on-premise HPC systems offer similar computational resources, their
network architecture and performance may differ significantly. For example,
these systems use fundamentally different network transport and routing
protocols, which may introduce network noise that can eventually limit the
application scaling. This work analyzes network performance, scalability, and
cost of running HPC workloads on cloud systems. First, we consider latency,
bandwidth, and collective communication patterns in detailed small-scale
measurements, and then we simulate network performance at a larger scale. We
validate our approach on four popular cloud providers and three on-premise HPC
systems, showing that network (and also OS) noise can significantly impact
performance and cost both at small and large scale.","Due to ﬂexibility and costeffectiveness, running HPC ap plications in the cloud has become an appealing solution and a potential alternative to onpremise systems [1], [2]. Scientiﬁc applications from different domains already run on the cloud, including multiphysics simulations [3], [4] and biomedical applications [5], [6]. One of the main advantages of cloud computing is the possibility to run an application on the most appropriate computational resources in a costeffective way. Instances that can be deployed in the cloud come with a wide variety of architectural characteristics in terms of memory, CPUs, accelerators, and network bandwidth. On the CPU side, it is possible to select between different processors, with different numbers of cores, clock frequency, and architecture, ranging from commercial offtheshelf Intel and AMD processors to custom ARM processors like the ARM Graviton processor deployed by AWS [7]. Cloud providers also offer a wide choice of accelerators that includes different types and gener ations of GPUs [8], TPUs ( Tensor Processing Units ) [9], and FPGAs [10]. Similarly, different instances provide different network bandwidths. Users can deploy instances with 100 Gb/s networks on most major cloud providers and, in some cases, even 200 Gb/s and 400 Gb/s instances (on Azure and AWS, respectively). Finally, cloud vendors frequently deploy new hardware, differently from onpremise HPC systems, where compute resources have lifecycles spanning multiple years.However, all this ﬂexibility comes at a cost. Although we can expect minor differences in the compute performance between an HPC instance in the cloud and an equivalent server in an onpremise HPC system [11], [12], the network performance can signiﬁcantly differ. Indeed, in some cases, the network connecting those instances in the cloud signiﬁ cantly differs from a traditional HPC network. For example, packets might be routed using ECMP [13], [14], [15] in a congestionoblivious way, and can thus experience a higher latency if multiple network ﬂows are mapped on the same paths [16], [17], [18]. On the contrary, HPC systems often deploy adaptive routing to react more promptly to congestion in the network [19], [20]. Also, differently from most HPC systems, some providers do not use Remote Direct Memory Access (RDMA), or run instances on tapered networks [15]. All these factors can contribute to increase network latency, decrease network bandwidth, and increase network noise [21], [22], [23], [24], [25] (i.e., performance variability induced by the use of the network). This limits the scalability and tampers costeffectiveness. Although HPC applications can scale up to 42 million cores [26] on onpremise HPC systems, it is still not clear how far HPC applications could scale on the cloud. Traditionally, cloud environments have been considered a good match for loosely coupled or embarrassingly parallel workloads, but network performance has been seen as one of the main bottlenecks preventing their adoption for tightly coupled computations [27], [11], [28], [29], [30], [31]. Assessing the network performance and the impact of noise on scalability is even more relevant if we consider that the gap between compute and network performance increases. For example, from 2010 to 2018, the computational throughput of the Top 500 HPC systems [32] increased by 65x, while the off node communication bandwidth only increased by 4.8x [33], [34]. Thus we expect, in the future, network performance to be even more relevant for HPC applications running on the cloud. In this work, we focus on network performance and noise, assessing the impact on performance, scalability, and cost of tightlycoupled HPC communication patterns at scale. Because collecting statistically sound measurements at the scale of thousands of HPC VMs would be too expensive (and on some cloud providers not even feasible), we ﬁrst perform detailed network performance and noise measurement at small scale.arXiv:2210.15315v2  [cs.DC]  1 Nov 2022TABLE I ANALYZED SYSTEMS :FOR EACH OF THEM WE DETAIL THE CPU, M EMORY AND NETWORK CHARACTERISTICS .CINDICATES THE NUMBER OF PHYSICAL CORES . INSTANCE COSTS AS REFERRED TO THE JULY, 18 2022 FOR THE EAST US AVAILABILITY ZONE . SYSTEMINSTANCE TYPECPU M EMORYPERHOUR INSTANCE COST (COMMITTED )PERHOUR INSTANCE COST (ONDEMAND )BANDWIDTH NETWORK ROUTINGTRANSPORT PROTOCOLAWSNormal c5.18xlarge2x18C Intel Xeon Platinum 8124M @ 3GHz144 GB 1.34 USD 3.06 USD 25 Gb/s Fat Tree [14] ECMP [14] SRD [14] HPC (Metal) c5n.metal2x18C Intel Xeon Platinum 8124M @ 3GHz192 GB 1.475 USD 3.88 USD 100 Gb/s Fat Tree [14] ECMP [14] SRD [14] HPC c5n.18xlarge2x18C Intel Xeon Platinum 8124M @ 3GHz192 GB 1.475 USD 3.88 USD 100 Gb/s Fat Tree [14] ECMP [14] SRD [14]AZURENormal F72s v236C Intel Xeon Platinum 8370C/8272CL/8168144 GB 1.116 USD 3.045 USD 30 Gb/s Fat Tree [35] ECMP [35] N.A. HPC HC44rs2x22C Intel Xeon Platinum 8168 @ 2.70GHz352 GB 2.218 USD 3.168 USD 100 Gb/sNonBlocking Fat Tree [36]Static/ Adaptive [37]InﬁniBand [36] HPC (200 Gb/s) HB120rs v22x60C AMD Epyc 7V12 @ 2.45 GHz456 GB 1.8 USD 3.6 USD 200 Gb/sNonBlocking Fat Tree [36]Static/ Adaptive [37]InﬁniBand [36]GCPNormal c2standard602x15C Intel Cascade Lake @ 3.10GHz240 GB 1.25 USD 3.1321 USD 32 Gb/sJupiter (3:1 Blocking Fat Tree) [15]ECMP [15]TCP/IP + Intel QuickData[38] HPC c2standard602x15C Intel Cascade Lake @ 3.10GHz240 GB 2.148 USD 4.03 USD 100 Gb/sJupiter (3:1 Blocking Fat Tree) [15]ECMP [15]TCP/IP + Intel QuickData[38]ORACLENormal VM.Optimized3.Flex18C Intel Xeon Gold 6354 @ 3GHz256 GB N.A. 1.188 USD 40 Gb/sNonBlocking Fat Tree [39]N.A. N.A. HPC (Metal) BM.Optimized3.362x18C Intel Xeon Gold 6354 @ 3GHz512 GB N.A. 2.712 USD 100 Gb/sNonBlocking Fat Tree [39]N.A. RoCEv2 [40]DAINTHPC (Metal) 2x18C Intel Xeon E52695 v4 @ 2.10GHz64 GB 1.02 USD [41] 1.73 USD [41] 82 Gb/sCray Aries (Dragonﬂy) [42]PerPacket Adaptive [42]FMA [42]ALPS HPC (Metal) 2x64C AMD EPYC 7742 @ 2.25GHz256 GB N.A. N.A. 100 Gb/sHPE Cray Slingshot (Dragonﬂy) [19]PerPacket Adaptive [19]RoCEv2 [19]DEEPESTHPC (Metal) 2x12C Intel Xeon Gold 6146 @ 3.20GHz192 GB N.A. N.A. 100 Gb/sMellanox InﬁniBand EDR (Fat Tree) [43]Static/ AdaptiveInﬁniband [43] On one side, we analyze this data to spotlight differences in network performance and noise between different cloud and onpremise HPC systems. On the other side, we use this data to calibrate the LogGOPSim simulator [44], [45], and to simulate the scalability and cost at a larger scale (up to 16K HPC VMs). We deﬁne the concepts of latency noise and bandwidth noise , and assess the network performance and its impact on scalability of HPC and normal instances of four major cloud providers and of three onpremise systems (with different net work technology). We also assess OS noise (i.e., performance variability introduced by OS processes), and we show how different type of noise impact application performance and cost both at small and large scale, for both latency and bandwidth dominated communication patterns. We describe in Sec. II the main characteristics of HPC cloud solutions, in Sec. III we analyze the network performance of both cloud and onpremise HPC systems, with a focus on OS and network noise in Sec. IV. Then, we simulate how noise affects performance at scale in Sec. V, and discuss related work in Sec. VII. Eventually, Sec. VIII draws conclusions.II. HPC IN THE CLOUD In this section we measure and analyze the network per formance of HPC systems in the cloud at a small scale, to understand better some peculiarities and limitations of those systems. In this paper, we analyze four of the major cloud providers: Amazon AWS [46], Google GCP [47], Microsoft Azure [48], and Oracle Cloud [49]. We also analyze three on premise HPC systems: Piz Daint [50] (referred as Daint in the following) and Alps [51], both deployed at the Swiss National Supercomputing Centre, and DEEPEST [43], deployed at the J¨ulich Supercomputing Centre. We analyze cloud instances of different types, including HPC instances (with different network bandwidth) and normal compute instances. We outline the different analyzed systems, instance types, and their main characteristics in Table I. In the following we analyze in detail the different instance types (Sec. IIA), their network features (Sec. IIB), and their cost (Sec. IIC). A. Instances, CPUs, and OS In the following, with the term HPC instances , we refer to those instances providing at least 100 Gb/s networking.For AWS, we evaluate both baremetal and non baremetal HPC instances. Azure and GCP provide only non baremetal HPC instances, whereas Oracle only provides baremetal HPC instances. To have a fair comparison, we selected instance types with similar CPUs when possible. We used Intel CPUs on all the cloud instances except for the 200 Gb/s instances of Azure, which only have AMD EPYC CPUs. For normal instances, we selected those that provide a similar network bandwidth and core count. For completeness, we also report the amount of RAM memory on each instance type. All four providers guarantee that HPC instances are run on separate physical servers. For the normal instances we selected CPUs with a high core count to have them allocated on two separate servers. This is necessary to ensure that when measuring network performance the two VMs are actually using the network. For the cloud providers we report in the Instance Type column the name of the instances we used. On all cloud providers, we use the virtual machine (VM) images and operating system suggested for the HPC instances. These were: Amazon Linux 2 on AWS [52], CentOS 7.7 on Azure [53], CentOS 7.9 on GCP [54], and Oracle Linux 7.9 on Oracle. Daint and Alps run a Cray Linux Environment (CLE) OS based on SUSE Linux Enterprise Server v15.2, and DEEP EST runs Rocky Linux v8.5. B. Network The four cloud providers and the DEEPEST system deploy a fat tree topology. According to the most recent documenta tion we found, Azure, Oracle, and DEEPEST deploy a non blocking network [36], [55], GCP a 3:1 blocking network [15], whereas we did not ﬁnd any additional detail on network over or underprovisioning for AWS. Both AWS and GCP use ECMP routing [13], Azure employs adaptive routing [37] for HPC instances, and for Oracle we did not ﬁnd any information on routing. The routing protocol plays a crucial role in network performance. For example, ECMP is congestion oblivious and might suffer from ﬂow collisions [16], [17], [18], increasing the network bandwidth variability (see Sec. IVC). Daint and Alps deploy a dragonﬂy interconnect (Cray Aries [42] and Slingshot [19] respectively) with adaptive routing. Each of the evaluated cloud providers uses a different transport protocol. AWS provides its proprietary RDMA like protocol called SRD ( Scalable Reliable Datagram ) [14], which resembles in some aspects InﬁniBand verbs [56]. It provides reliable outoforder delivery of packets and uses a custom congestion control protocol. The AWS Nitro Card [57] implements the reliability layer, and the Elastic Fabric Adapter (EFA) provides OSbypass capabilities. To react to congestion, SRD monitors the round trip time (RTT) and forces packets to be routed differently by changing some of the ﬁelds used by ECMP to select the path. This approach is probabilistic and might allow avoiding congested paths, but, differently than truly adaptive routing, it does not allow selecting the least congested path nor any speciﬁc path. Azure and DEEPEST use RDMA through InﬁniBand [36], Oracle uses RDMA over Converged Ethernet (RoCEv2) [40],whereas GCP does not use RDMA and relies on TCP/IP. To minimize data movement overheads, GCP uses Intel’s QuickData DMA Engines [58] to ofﬂoad payload copies of larger packets. Daint uses a proprietary RDMA protocol [42] (FMA), whereas Alps uses RoCEv2 [19]. C. Cost Table I shows the perhour cost charged to the user as of July 18, 2022. For the cloud systems, we report the cost for the East US availability zone. We consider both the cost for a committed 3years usage with upfront payment and the ondemand cost without any minimum commitment. Please note that 3years is the maximum commitment allowed on those providers (and that leads to the lowest perhour cost), whereas when having no commitments we have the highest perhour cost. For Daint, we report the cost for a minimum usage of 10;000 compute hours, as well as the on demand cost, both for nonacademic partners. Academic partners have discounted rates and this would otherwise lead to an unfair comparison. For Alps and DEEPEST there is no publicly available information on the perhour cost. On AWS, the main difference between the normal and HPC instances we selected is the support for Elastic Fabric Adapter (EFA), which provides the 100 Gb/s networking. Thus, we can estimate the 3years committed cost of the highperformance networks at around 0.135 USD per hour per VM, and an ondemand cost of 0.82 USD. Similarly, we selected the same instance type for normal and HPC instances on GCP. The only difference is that we enabled the socalled Tier 1 network on the HPC instance, which provides 100 Gb/s network bandwidth. On GCP, we can thus estimate the cost of the HPC network at around 0.9 USD per hour per VM [59] (both for the committed and ondemand cost). Unfortunately, Azure and Oracle do not provide the same instance in HPC and nonHPC ﬂavors, and it is thus not possible to isolate the cost of the HPC network from the rest. Also, we observe that whereas the ondemand cost of 100 Gb/s instances is lower than the cost of 200Gb/s instances, this is not true for the 3years committed usage. Indeed, at the time of the writing, committing for a 3years usage led to a 30% discount for 100 Gb/s instances, and to a 50% discount for the 200Gb/s ones. III. N ETWORK PERFORMANCE We measure network performance using the Netgauge tool [60], that provides detailed, samplebysample measure ments (fundamental for estimating network noise in Sec. IV). We used the Message Passing Interface (MPI) backend and, on each system, the MPI library recommended by the provider1. a) Methods: We created an account on each provider, and used our own funding and/or academic credits, without coordinating with the providers. The clusters have been cre ated and tuned following the guidelines publicly available 1On Azure we used HPCX v2.8.3 on HPC instances and Open MPI v4.1.2 on normal instances. We used Open MPI v4.1.1 on AWS, Intel MPI v2018.4.274 on GCP, Open MPI v4.0.4 on Oracle, Cray MPICH v7.7.18 on Daint, Cray MPICH v8.1.12 on Alps, and Open MPI v4.1.3 on DEEPEST.1B 16B 256B 4KiB 64KiB 1MiB 16MiB Message Size 0 20 40 60 80 100Bandwidth (Gb/s) AWS 1B 16B 256B 4KiB 64KiB 0 20 40RTT/2 (us) 1B 16B 256B 4KiB 64KiB 1MiB 16MiB Message Size GCP 1B 16B 256B 4KiB 64KiB 0 20 40RTT/2 (us) Concurrent Communications 1 2 4 8 16Fig. 1. Bandwidth for HPC instances as a function of message size and number of concurrent connections between the two servers. Inner plots show RTT/2 for small messages. in the documentation of the cloud providers. After running the benchmarks, we contacted the leads of the cloud busi ness of each of the providers, sharing a draft of the paper with them. They assessed the correctness of our evalua tion, and we integrated their feedback in the paper. Only in one case we improved the performance by applying a technique not described in the publicly available documen tation, that we describe in the text (see the comment about theFI_EFA_TX_MIN_CREDITS in Sec. IIIA). On all the providers, if not speciﬁed otherwise, we allocated the two VMs (or the two servers) on the same rack. The only exception is Oracle, where it is not possible to explicitly control the allocation. We analyze in detail the impact of allocation on performance and noise in Sec. IV. A. Bandwidth Saturation All the four analyzed cloud providers claim a 100 Gb/s bandwidth on Intelbased HPC instances. However, this is true only under certain conditions. For example, AWS documents a maximum permessage bandwidth of 25Gb/s [61]. Even if not explicitly documented, we observed similar limitations on GCP. One possible reason justifying this behavior is that even if the instance exposes a single 100 Gb/s NIC, it might be equipped with multiple 25Gb/s NICs (or a multiport NIC). While some providers explicitly documented this for nonHPC instances, the speciﬁc conﬁguration is often unclear for HPC ones. For this reason, we can expect a higher bandwidth when sending a message over multiple connections. To assess if this is the case, we run a pingpong benchmark between two nodes. We establish multiple concurrent connections between the two nodes, by running multiple processes per node and letting each pair of processes send/receive disjoint parts of the message. For example, a 16MiB pingpong with 16 processes per node runs 16 concurrent pingpongs between 16 processes on the ﬁrst node and 16 processes on the second node, each with a 1MiB message. We report the results of this experiment for AWS and GCP in Figure 1. We report the bandwidth as the message size divided by half the round trip time (RTT/2), and the inner plotsshow the RTT/2 for small messages. Each point in the plot is the average over 1000 runs, whereas the band around the point represents the standard deviation. We do not report the results for the other systems since they can saturate the bandwidth even with a single connection (we show results in the next section). On AWS we increased the bandwidth by increasing the maximum number of inﬂight packets to 1024 (by setting theFI_EFA_TX_MIN_CREDITS environment variable). On both AWS and GCP the bandwidth increases when increasing the number of concurrent communications (up to 80Gb/s with 16 processes per node). Also, when using a single connection, the bandwidth drops for messages larger than 4MiB. This is caused by a morethanlinear increase in last level cache (LLC) misses, that we measured by using the perf tool. For example, on AWS, we observe a 4 increase in LLC misses when going from 1MiB to 4MiB messages, but a 8increase when moving from 4MiB to 16MiB messages. This effect is not present when using more concurrent com munications because the message is split among the processes, each transmitting a smaller message. We also observe that having more processes per node increases the RTT of small messages, due to additional overhead and contention on the NIC access. For this reason, only large messages should be sent with multiple concurrent connections. Instead of having more processes sending a part of the message each, we could have a single process sending multiple smaller messages. For example, some MPI libraries provide the possibility to stripe messages transparently over multiple connections (e.g., by using the btl_tcp_links command line ﬂag on Open MPI [62]). However, we did not observe any performance improvement compared to the single connection case. Observation 1: On AWS and GCP , the peak bandwidth on a single connection is 50Gb/s and 30Gb/s respectively. A bandwidth of 80Gb/s can only be reached by forcing messages to be concurrently sent/received by/from multi ple processes on different connections.1B 16B 256B 4KiB 64KiB 1MiB 16MiB Message Size020406080100Bandwidth (Gb/s) 1B 16B 256B0102030RTT/2 (us) AWS AzureGCP OracleAlps DaintDEEPESTFig. 2. Unidirectional bandwidth on different providers as a function of the message size. Inner plots show RTT/2 for small messages. For AWS and GCP we report the results with optimal number of connections (1 for minimizing RTT/2 for small messages, and 16 for maximizing bandwidth on large messages). B. Unidirectional Bandwidth and Latency Figure 2 shows the RTT/2 and bandwidth of different providers as a function of the message size. For the cloud providers we selected the 100 Gb/s instances (baremetal when available). For AWS and GCP, we report the RTT results with a single connection (lowest RTT on small messages), and for bandwidth, the results with 16 concurrent connections (highest bandwidth on large messages). Regarding the latency (i.e., the RTT/2 for 1 byte messages), we observe that Azure, Oracle, and the onpremise systems exhibit a 12 microseconds latency for HPC instances. On the other hand, both AWS and GCP are characterized by much higher latencies (20 and 10 microseconds respectively). Concerning the bandwidth, Azure, Oracle, Alps, and DEEP EST achieve a bandwidth higher than 90 Gb/s for 16MiB messages. On Daint, we measured 75 Gb/s peak bandwidth for 16MiB messages (NICs on Daint have an injection bandwidth of 82 Gb/s [42]). AWS and GCP reach a peak bandwidth of circa 70 Gb/s (using 16 concurrent connections). Oracle achieves the 90% of the declared bandwidth with 256KiB messages, Alps, Azure and DEEPEST with 2MiB messages, Daint with 4MiB messages, and AWS and GCP only achieve the 70% of the declared bandwidth with 16MiB messages. Observation 2: Azure and Oracle achieve network latency and bandwdith comparable to that of onpremise HPC systems. On the other hand, GCP and AWS achieve 25% lower bandwidth and 10x higher latency. C. Bidirectional Bandwidth To measure the bidirectional bandwidth, we perform two simultaneous pingpongs between two nodes, with each ping pong starting from a different node. In Figure 3, we report the results of this experiment, and we compare the peak unidirec tional and bidirectional bandwidth with 16MiB messages. For AWS Azure GCP Oracle Alps Daint DEEPEST 0 25 50 75 100Bandwidth (Gb/s) Unidirectional BidirectionalFig. 3. Peak unidirectional and bidirectional bandwidth. both AWS and GCP, we use 16 concurrent connections. In some cases, we observe a peak bidirectional bandwidth lower than the peak unidirectional bandwidth. For example, on Daint this is caused by message requests and responses sharing the same data path, decreasing the peak theoretical bandwidth per direction to 64 Gb/s [42]. 1000ms 800ms 600ms 400ms 200ms 0ms InterMessage Interval0.51.01.5RTT/2 (1MiB msgs) Fig. 4. Distribution of RTT/2 (ms) of 1MiB transfers on GCP HPC instances, for different intermessage intervals. D. Trafﬁc Burstiness We now investigate the impact of trafﬁc burstiness on network performance. To assess this, we execute a 1MiB ping pong between two nodes, varying the intermessage interval ,1B 256B 64KiB 16MiB Message Size 0 20 40 60Bandwidth (Gb/s) AWS 1B 16B 256B 15 20 25 30RTT/2 (us) 1B 256B 64KiB 16MiB Message Size 0 50 100 150 200Bandwidth (Gb/s) Azure 1B 16B 256B 0 10 20 30 40RTT/2 (us) 1B 256B 64KiB 16MiB Message Size 0 20 40 60Bandwidth (Gb/s) GCP 1B 16B 256B 10 15 20 25RTT/2 (us) 1B 256B 64KiB 16MiB Message Size 0 25 50 75 100Bandwidth (Gb/s) Oracle 1B 16B 256B 0 10 20 30 40RTT/2 (us) Normal HPC HPC (Metal) HPC (200 Gb/s)Fig. 5. Unidirectional bandwidth for the different instance types described in Table I, organized by provider. Inner plots show the RTT/2 for small messages. Note that each plot uses a different scale. i.e., the time between two subsequent message transmissions between 0 and 1 second. To exclude any pipelining effect, the benchmark waits for a message to be completely received before sending the next one. We repeat each experiment for 20 iterations, with 10 warmup iterations. We did not observe any impact of burstiness on the performance, except for GCP, for which we report the results in Figure 4. We show on the X axis the interval between two subsequent messages, and on the Y axis the RTT/2 (milliseconds). We observe how, when the time interval between subsequent messages is one second, a 1MiB message requires around 1.5 milliseconds to be transferred from the source to the destination. On the other hand, when we decrease the inter message interval, the RTT starts decreasing, and, eventually, the RTT/2 becomes lower than 0.5 milliseconds. We observed this behavior consistently in multiple runs, in different days, and at different times of the day. Our initial assumption was that this could be related to the Andromeda network virtualization stack, used by GCP for forwarding packets over the network [38]. To scale on very large networks, and avoid storing thousands of VM toVM forwarding rules on each VM, the Andromeda VM host stack sends all the packets for which it does not have a route to Hoverboard gateways. If the Andromeda control plane detects that a ﬂow exceeded some bandwidth usage threshold, it installs direct VMtoVM forwarding rules in the VM host stack, so that highbandwidth ﬂows are forwarded directly to the destination VM without the need to traverse the Hoverboard gateways to resolve the forwarding rule. Althoughthis works well for bandwidthintensive ﬂows, bursty ﬂows might not trigger the installation of a forwarding rule in the software stack of the source VM, thus incurring in the extra latency required to traverse a Hoverboard gateway. However, after a discussion with GCP engineers (that were able to reproduce and conﬁrm the issue) we believe that this is not caused by Hoverboard. Indeed, the same behaviour also happens if the two communicating process run on the same node, thus using shared memory rather than the network for communicating. We also exclude issues with the MPI implementation, since we observed the same behavior when communicating directly using TCP rather than MPI. This is also not caused by CPU power saving features, that were disabled during the tests. We are currently investigating, with the help of GCP engineers, the reasons for this behaviour, that are likely related to virtualization. Observation 3: On GCP , large delays between mes sages can increase the RTT/2 up to 3x compared to the case where messages are sent back to back. E. HPC vs. Normal Compute Instances Figure 5 reports the unidirectional bandwidth and RTT/2 for the different instance types and cloud providers described in Table I. For GCP and AWS we report the bandwidth when us ing 16 concurrent connections. For Azure normal compute in stances, we achieved the highest bandwidth (14 Gb/s) with two concurrent connections, and we observed bandwidth degradation when running more than two concurrent connections. We believe that on Azure normal instances concurrent connections are needed because each VM uses multiple NICs with lower bandwidth, as documented by Azure [63]. The Azure 200 Gb/s instances reach the peak bandwidth with 16MiB messages. Also, we observe that normal compute instances on Azure are characterized by the lowest bandwidth, whereas AWS normal instances can achieve a 25Gb/s bandwidth, Oracle normal instances achieve a bandwidth of 40Gb/s, and GCP achieve even higher bandwidth than that declared (40Gb/s versus 32Gb/s). Regarding the latency, on AWS, HPC instances are char acterized by a marginally lower RTT/2 compared to normal instances. On Azure, we observed a 30 microseconds RTT/2 on normal instances, much higher than that observed on the HPC instances (around 12 microseconds). The same holds for Oracle, where on normal instances we observed a latency of almost 30 microseconds. On GCP, we observed no difference in the latency between normal and HPC instances. Observation 4: On AWS and GCP , HPC instances communicate with the same latency as normal instances, whereas on Azure and Oracle HPC instances communi cate with a latency 1020x lower than normal instances. IV. N ETWORK AND OS N OISE Application performance can signiﬁcantly vary across dif ferent runs due to effects such as OS and network noise [34], [64], [65]. To analyze how these different types of noise can affect the performance of a large scale system, we now describe how they affect the different terms that contribute to the time needed to deliver a message according to the LogGP model [66]. We focus on this model because, although simple, it captures the fundamental aspects of network communica tions, and allows us to implement a solid simulation method ology (discussed in Sec. V). LogGP models the time needed for sending a message of sbytes as T(s) = 2o+L+(s"
311,Differentiable Molecular Simulations for Control and Learning.txt,"Molecular dynamics simulations use statistical mechanics at the atomistic
scale to enable both the elucidation of fundamental mechanisms and the
engineering of matter for desired tasks. The behavior of molecular systems at
the microscale is typically simulated with differential equations parameterized
by a Hamiltonian, or energy function. The Hamiltonian describes the state of
the system and its interactions with the environment. In order to derive
predictive microscopic models, one wishes to infer a molecular Hamiltonian that
agrees with observed macroscopic quantities. From the perspective of
engineering, one wishes to control the Hamiltonian to achieve desired
simulation outcomes and structures, as in self-assembly and optical control, to
then realize systems with the desired Hamiltonian in the lab. In both cases,
the goal is to modify the Hamiltonian such that emergent properties of the
simulated system match a given target. We demonstrate how this can be achieved
using differentiable simulations where bulk target observables and simulation
outcomes can be analytically differentiated with respect to Hamiltonians,
opening up new routes for parameterizing Hamiltonians to infer macroscopic
models and develop control protocols.","At the atomic level, physical processes are governed by differential equations containing many degrees of freedom. Macroscopic phenomena in matter emerge from microscopic interactions that can be simulated through numerical integration of the equations of motion. In classical simulations, these equations of motion are derived from a Hamiltonian quantity H. In quantum simulations, they are derived from a Hamiltonian operator ^H. Examples of microscopic quantities from simulations are time series of positions, velocities, and forces on atoms and molecules. From these, a rich family of macroscopic observables can be calculated to describe the conﬁgurational and temporal correlation functions of atoms. These observables determine different properties of the simulated materials. Preprint. Under review.arXiv:2003.00868v2  [physics.compph]  24 Dec 2020Classically, simulating the positions of particles with conserved energy requires integrating the Hamiltonian equations of motion: dpi dt="
12,Feasibility Evaluation of VANET using Directional-Location Aided Routing (D-LAR) Protocol.txt,"Vehicular Ad hoc Networks (VANETs) allow vehicles to form a self-organized
network without any fixed infrastructure. VANETs have received wide attention
and numerous research issues have been identified in the recent time. The
design and implementation of efficient and scalable routing protocols for
VANETs is a challenging task due to high dynamics and mobility constraints. In
this paper, we have proposed D-LAR (Directional-Location Aided Routing), is an
extension of Location Aided Routing (LAR) with Directional Routing (DIR)
capability. D-LAR is a greedy approach based-position based routing protocol to
forward packet to the node present in request zone within the transmission
range of the source node as most suitable next-hop node. We have justified the
feasibility of our proposed protocol for VANET.","Vehicular Ad hoc Network (VANET) is a rapidly  emerging new class of mobile ad hoc networks. VANET  consists of a large number of vehicles providing  connectivity to each other. We assume that vehicles move  in every direction with high mobility. Neighboring  vehicles that are within a transmission range directly  communicate over a wireless links.  If source and  destination vehicle are not in direct commun ication range  of each other, then they communicate through intermediate  node in multi hop fashion .    VANETs have a large potential to improve the traffic  safety and travel comfort of drivers and passengers  [1].  For example vehicles can communicate detour, traffic  congestion, and accident information with the nearby  vehicles to reduce the traffic jam near the affected areas.  Rescue vehicles could instantly receive exact location  information of the accident site to reach there faster. Toll could be automatically paid, traffic signals equipped with  communication equipments could more accurately control  intersection traffic. Although fixed infrastructure is not  required for VANET, however fixed network nodes may  be used in the form of roadside units. These roadside units  open up a wide variety of services for vehicular ad hoc  networks such as serving as a gateway to the Internet,  serving up geographical data etc [2 ].    The work in  this paper involves two steps.  First, we  explain the proposed routing protocol in VANET which is  very essential to establish a path for packet transmission  between nodes. In second step , we evaluate  the feasibility  of VANET for the dense traffic scenario  using proposed  routing protocol  [3]. Our work  only focuses on a densely  connected city network.     Unlike traditional ad hoc and ot her routing protocols,  position based routing protocols present  challenging and  interesting pr operties of VANETs [4,  5]. A position based  routing protocol does  not require any information on the  global topology, but uses the local information of  neighboring nodes that restricted to the transmission range  of any forwarding node. Due to this restrictions, it gives  low overhead of their creation and maintenance. General ly  position based routing is based on greedy forwarding  scheme that guarantees loop free operation. The local  information about the physical location of nodes can be  provided by the Global Positioning System (GPS), if  vehicular nodes are  equipped with a GP S receiver [6, 7 ].  Over the last few years, there have been numerous  variations of position based routing protocols such as LAR  and DIR protocols examined in the literature [ 8, 9].     In this work, we study the performance of both LAR and  DIR protocols  and propose a new protocol based on  greedy forwarding approach, that we call Directional Location Aided  Routing (D LAR) protocol. In this  protocol, we first draw a straight line between source and  destination. Then the packet is forwarded in the request  zone t o the direct neighbor having direction closest to the  line drawn  between source and destination .     The rest of th e paper is organized as follows. We discuss  the related work in section 2. In section 3, the design of D  LAR routing protocol is introduced. Se ction 4 presents the  performance analysis of the proposed protocol. Finally, we  conclude the paper in section 5.   2. Related Work   "
376,On the properties of path additions for traffic routing.txt,"In this paper we investigate the impact of path additions to transport
networks with optimised traffic routing. In particular, we study the behaviour
of total travel time, and consider both self-interested routing paradigms, such
as User Equilibrium (UE) routing, as well as cooperative paradigms, such as
classic Multi-Commodity (MC) network flow and System Optimal (SO) routing. We
provide a formal framework for designing transport networks through iterative
path additions, introducing the concepts of trip spanning tree and trip path
graph. Using this formalisation, we prove multiple properties of the objective
function for transport network design. Since the underlying routing problem is
NP-Hard, we investigate properties that provide guarantees in approximate
algorithm design. Firstly, while Braess' paradox has shown that total travel
time is not monotonic non-increasing with respect to path additions under
self-interested routing (UE), we prove that, instead, monotonicity holds for
cooperative routing (MC and SO). This result has the important implication that
cooperative agents make the best use of redundant infrastructure. Secondly, we
prove via a counterexample that the intuitive statement `adding a path to a
transport network always grants greater or equal benefit to users than adding
it to a superset of that network' is false. In other words we prove that, for
all the routing formulations studied, total travel time is not supermodular
with respect to path additions. While this counter-intuitive result yields a
hardness property for algorithm design, we provide particular instances where,
instead, the property of supermodularity holds. Our study on monotonicity and
supermodularity of total travel time with respect to path additions provides
formal proofs and scenarios that constitute important insights for transport
network designers.","Trafﬁc routing is a core transportation problem. It is con cerned with directing multiple agents, with aligned or con ﬂicting interests, to their destinations. Relevant applications include: road trafﬁc [1], air trafﬁc [2], crowd control [3], and internet packets [4]. With the advent of Connected Autonomous Vehicles (CA Vs), we expect mobility paradigms to undergo a fundamental change, as we transition from (selfinterested) human control to semi (or fully) automated cooperative paradigms [5]. This will lead to a decrease in unpredictable routing behaviours caused by human decision making, paving the way for greater trafﬁc efﬁciency [6, 7]. Despite of this shift from nonautomated to semi (or fully) automated trafﬁc control, in most cases, the underlying Corresponding author 1Matteo Bettini and Amanda Prorok are with the Prorok Lab and the Department of Computer Science and Technology, University of Cambridge, Cambridge, United Kingdom, email: fmb2389,asp45 g@cl.cam.ac.ukTABLE I: Summary of our results on the properties of total travel time with respect to path additions in transport networks. Multi Commodity (MC) and System Optimal (SO) are cooperative routing formulations while User Equilibrium (UE) is selfinterested. Total travel time w.r.t. path additions MC SO UE Monotonic nonincreasing 3 3 7 Thm 3 Thm 2 Braess [13] Supermodular (general case) 7 7 7 Thm 4 Thm 5 Thm 5 Supermodular (special case) 3 3 3 Thm 6 Thm 7 Thm 7 infrastructure (e.g., transport network) remains the one that was originally designed for human control. While many research efforts focus on developing algo rithms for trafﬁc planning and control, the transport network is often regarded as a ﬁxed constraint. On the other hand, as we can observe from historic trends, every change to mobility systems was followed by a change to the transport network infrastructure [8]. We aim to anticipate this trend by investigating the properties of environment modiﬁcations under several (ﬁxed) routing strategies. The problem of optimizing the transport network topol ogy is known as the Network Design Problem (NDP) [9]. This problem is generally NPhard [10] and, thus, optimal solutions for large instances are computationally infeasi ble. Analysing the properties of the objective function, on the other hand, could provide us with additional tools for the design of approximation algorithms with known suboptimality bounds. In particular, for set functions that satisfy the property of diminishing returns, also known as sub/supermodularity, nearoptimal approximations can be found [11, 12]. It is thus fundamental to provide an analysis of the properties of objective functions for network design under different routing objectives and paradigms. In this work, we study the theory of transport network de sign through iterative path additions to derive and categorize its formal properties. We model trafﬁc as ﬂow traversing a transport network represented as a graph. Under this formu lation, we consider three different routing problems tasked with guiding each agent to its destination: i) minimum cost multicommodity network ﬂow problem (MC) [14], where agents experience constant travel times, ii) system optimal (SO) routing [15], where travel time is dependent on edge congestion and agents cooperate to minimize the systems’ cost (total travel time), and iii) user equilibrium (UE) rout ing[15], also known as Wardrop equilibrium [16], where travel time is dependent on edge congestion and agents are routed to minimize their individual travel time. These routingarXiv:2207.04505v1  [cs.MA]  10 Jul 2022paradigms are coordinated as they all require a centralised routing infrastructure, following three different optimisation objectives. We furtherly refer to MC and SO as cooperative routing, as they optimise for the system’s beneﬁt, and to UE as selfinterested routing, as it optimises for individual agents. We are interested in analysing the properties of total travel time for these routing problems under path additions to the transport network. We thus introduce the concepts of trip spanning tree and trip path graph which allow us to formalise what we consider an initial transport network and the space of its possible path additions. This model is then leveraged to prove our properties of interest. Firstly, while Braess [13] has shown that total travel time is not monotonic nonincreasing with respect to path additions under selfinterested UE routing, we prove in our formulation that this does notoccur for cooperative routing (MC and SO). This result has the important implication that cooperative agents make the best use of redundant paths in the network. Secondly, we prove that the intuitive statement ‘adding a path to a transport network always grants greater or equal beneﬁt to users than adding it to a superset of that network’ is false. In other words, we prove that total travel time is not supermodular with respect to path additions. This is valid both when agents are routed according to their own interest (UE) and when they are cooperating for the system’s beneﬁt (MC and SO). We provide a counterexample to support our proofs. While this counterintuitive result states that the supermodularity of path additions cannot be leveraged in approximation algorithms for general network optimisation, we provide particular instances where, instead, the property of supermodularity holds. In this scenario only parallel path additions are allowed, making it suitable to represent network design settings where physical additions can overlap but virtual network paths are kept parallel (e.g., by creating dedicated lanes). Our results are summarised in Table I. This work contains the following contributions: We present the problem of network design via iterative path additions and we introduce a graph structuring framework for network design which leverages the new concepts of trip spanning tree and trip path graph . Braess’ example [13] ﬁts in this framework. We prove that, for cooperative agents, the total travel time is monotonic nonincreasing with respect to path additions. We prove with a counterexample that, in the general case, the total travel time is notsupermodular with respect to path additions for both cooperative and self interested agents. We introduce and prove a special case where super modularity holds (i.e., restricted supermodularity) and can thus be leveraged for designing approximation algorithms for speciﬁc network design instances. The paper is structured in the following way: Section II goes through the relevant related work, Section III discusses some preliminaries, in Section IV our formulation is in troduced, Section V goes through the routing paradigmsused, Section VI describes our formalization of the initial transport network and its extension via path additions, Sec tion VII investigates the properties of total travel time with respect to path additions, discussing monotonicity and non supermodularity, to then focus on particular supermodular instances, and, ﬁnally, Section VIII concludes the paper. II. RELATED WORK "
168,XMasq: Low-Overhead Container Overlay Network Based on eBPF.txt,"Recent years have witnessed a widespread adoption of containers in cloud
computing. While containers simplify and accelerate application development,
the existing container network technologies either incur significant overhead,
which hurts performance for distributed applications, or lose flexibility or
universality, which hinders the widespread deployment in production.
  We design and implement XMasq, an eBPF-based container overlay network, to
eliminate the extra overhead while keeping flexibility and universality. We
take full advantage of eBPF and design a cache-based network virtualization
mechanism and a redirect-based intra-host data path in XMasq. XMasq closes the
performance gap between overlay networks and host networks. Compared to
standard overlay networks, XMasq improves the TCP throughput by 18% and the
Request-Response transaction rate by 101%; XMasq also reduces the latency of
Memcached by 28.3%, PostgreSQL by 14.6% and Nginx by 29%. Compared to container
native-routing networks, XMasq does not require the underlay network being able
to foward packets using container IPs. Compared to Slim, which only supports
TCP traffic, XMasq is protocol independent and thus all the applications can
benefit from XMasq. We deploy XMasq as a plugin of Antrea, which is a Container
Network Interface (CNI).","Containers are becoming increasingly popular for largescale application deployment in cloud computing because they are flexible and lightweight. By bundling an application along with all its dependencies and configuration files into one con tainer image, containers bring forth the ability to build once and run anywhere [7]. In addition, containers share the host OS kernel rather than simulating an entire OS, thus are more lightweight than virtual machines. Container orchestration tools like Kubernetes [ 13], Docker Swarm [ 8], etc., further reduce the container management complexity, by enabling autodeployment, autoscaling, autohighavailability, etc.Property OverlayNative routingMacvlan/ IpvlanSlim XMasq Performance % ! ! !! Flexibility ! % % !! Universality ! ! ! %! Table 1: Comparation between overlay network, nativerouting network, Slim, macvlan and XMasq. The container network is a key for containers to com municate with each other and hold distributed applications. We usually expect the container network can provide low overhead, highperformance network while keeping the flex ibility of containers. However, none of the existing container networks can meet all these expectations. High overhead and poor performance. Container over lay networks using VXLANlike protocols can completely decouple the applications and the underlay network, which ensures the flexibility of both. However, it brings about signif icant overhead [ 47]. Our experiments show that, compared to a host network, the single TCP flow throughput of an overlay network is about 25%lower, while the TCP request response transaction rate is 55% lower. At the same time, the CPU utilization is significantly higher on both experi ments (34%  44% higher in throughput experiment and 34%  37% higher in transaction experiment). The root cause of the above performance gap is that the overlay network has a more complicated data path than the host network. In an overlay network, a packet traverses extra network stacks compared to the host network. Depending on different im plementations, the overlay network also incurs overhead when packets are forwarded intrahost and sent between the namespaces. We analyze the overhead in §2 in detail. Hurt flexibility or universality. Most of the Kubernetes CNIs provide a container network option in which container packets are directly forwarded to the underlay network with out extra encapsulation, such as hostgw in Flannel [ 10], 1arXiv:2305.05455v1  [cs.NI]  4 May 2023SIGCOMM’23, September 1014, 2023, New York City, US Shengkai .et al. nativerouting in Cilium [ 5]. Some of these container net works can provide performance that is close to the host net work [ 6], but they require either all hosts in the same L2 net work or the underlay network natively routing the container packets, both of which hurt the flexibility of the containers. Techniques like macvlan, SRIOV [ 26], and ipvlan also hurt the flexibility because they require reconfiguration of the infrastructure to apply any changes on overlay IP. Besides, Slim [ 47] proposes a container overlay network that imple ments network virtualization by manipulating connection level metadata, which make the packets in the container directly use sockets on hosts. Slim maintains part of the flex ibility of overlay container networks and supports container migration. However, Slim only supports TCP, which hurts the universality of the container network. We design and implement XMasq, an eBPFbased light weight container overlay network that attains high perfor mance, flexibility, and universality at the same time. XMasq offers an ebpfbased, highly optimized data path, which can be easily integrated into existing CNI plugins. (We have tested XMasq in Flannel and Antrea.) Our detailed contribu tions are summarized as follows: (1)We carefully decompose and analyze the overhead of the standard container overlay network, which in spires us the design of XMasq. (2)We design a cachebased network virtualization that provides a lowoverhead overlay network with full flex ibility for applications and underlay network. XMasq caches the IP and MAC addresses and the destination container NIC indexes, and implements network vir tualization by rewriting IPs and MACs of the packets. In this way, XMasq can skip the encapsulation and intrahost forwarding while maintaining the flexibility and being agnostic to the transportlayer protocols. (3)We optimize the eBPF redirect datapath and combine it with the cachebased network virtualization. Using eBPF redirect, XMasq skips the packet processing in host namespace and eliminates the overhead of intra host forwarding and namespace traversing. (4)We add the support for flexible network policies in XMasq with low overhead. This includes dataplane and controlplane policies. (5)We test XMasq by microbenchmark tools and reveal the significant improvement on performance and CPU utilization compared to the standard overlay network. We also test XMasq on popular distributed applications and show the improvement on latency and throughput on these applications. XMasq’s source code is available at https://github.com/ nothepeople/XMasq. This work does not raise any ethical issues.2 BACKGROUND AND MOTIVATION We first analyze the shortages of the common container net works. Known that the overlay network has the best flexibil ity and universality, we further analyze the performance and the overhead of the overlay network. The analysis motivate us to design XMasq. 2.1 The Container Networks The container networks are a key component of container clusters, enabling containers to communicate with each other and with the outside world. Typically there are four kinds of container networks: Host network. In the host network, containers share the host’s networking namespace and use the host IP. Host mode offers performance that is very close to that of the bare metal network [ 43]. But because the containers on the same host share the same IP, they have to coordinate the ports, which largely hurts the flexibility of applications. This limitation makes host mode very rarely used in practice [14]. Nativerouting network. In a nativerouting network, each container is assigned a unique IP and is isolated from the host namespace. Many Kubernetes CNIs, including Antrea [ 1], Cilium [ 5], Flannel [ 10], offer the option to use nativerouting network. In this mode, the physical network is responsible for correctly routing container packets. This can be achieved by either placing all hosts in a single L2 network or installing routing rules for container IPs to the physical network. In ad dition, the routing tables should also be aware of the changes of container IPs. These requirements hurt the flexibility, scal ability and manageability of nativerouting networks. Macvlan/Ipvlan network. The macvlan/ipvlan networks enable containers to have different IP addresses from the host. By using macvlan or similar hardware implementations (e.g., SRIOV), the physical NIC can emulate multiple virtual NICs with different IP and MAC that can be attached to the contain ers. Ipvlan is similar to macvlan, except that the virtual NICs have the same MAC address. However, the shortcomings of these networks are similar to those of the nativerouting network: the physical network must ensure the routability of container IPs, which can impede network flexibility. Overlay network. To maintain the flexibility of the ap plications and the physical network, it is popular to use the overlay network. In the overlay network, each container has its own IP address, and container packets are encapsulated using protocols like VXLAN or GENEVE when sent to con tainers on other hosts. The physical network can only handle the routing of host IPs. The overlay network completely de couples the container and the underlay network, and ensures the flexibility of both. Connectionbased overlay network Slim [ 47] intro duces a connectionbased overlay network that can improve 2XMasq: LowOverhead Container Overlay Network Based on eBPF SIGCOMM’23, September 1014, 2023, New York City, US /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000017/uni00000013/uni00000019/uni00000013/uni0000001b/uni00000013/uni00000014/uni00000013/uni00000013/uni0000002a/uni00000045/uni00000053/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni00000046/uni0000004c/uni0000004f/uni0000004c/uni00000058/uni00000050 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000049/uni0000004f/uni00000044/uni00000051/uni00000051/uni00000048/uni0000004f /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000018/uni00000014/uni00000013/uni00000014/uni00000018/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni00000046/uni0000004c/uni0000004f/uni0000004c/uni00000058/uni00000050 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000049/uni0000004f/uni00000044/uni00000051/uni00000051/uni00000048/uni0000004f /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000046/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000015/uni00000013/uni00000013/uni00000017/uni00000013/uni00000013/uni00000019/uni00000013/uni00000013/uni0000004e/uni00000035/uni00000048/uni00000054/uni00000058/uni00000048/uni00000056/uni00000057/uni00000056/uni00000012/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni00000046/uni0000004c/uni0000004f/uni0000004c/uni00000058/uni00000050 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000049/uni0000004f/uni00000044/uni00000051/uni00000051/uni00000048/uni0000004f /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000047/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000018/uni00000014/uni00000013/uni00000014/uni00000018/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni00000046/uni0000004c/uni0000004f/uni0000004c/uni00000058/uni00000050 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000049/uni0000004f/uni00000044/uni00000051/uni00000051/uni00000048/uni0000004f /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 Figure 1: Comparation of Cilium, Antrea, and Calico with the host network. The first row is the throughput and the CPU utilization on receiver side. The second row is the requestresponse result and the correspond ing CPU utilization. Note that the number of Virtual Cores is equal to the sum of the utilizations of all the 48 cores on the receiver node. the performance of the overlay network. When containers on different hosts set up TCP connections, the Slim router establishes a connection in the root namespace and forwards access to the connection into the container. However, Slim have significant limitations. First, when setting up connec tions, Slim must first establish an overlay connection for service discovery, leading to longer connection setup times. Second, Slim only supports connectionbased protocols and does not support other protocols such as UDP, which limits its universality. There is also an eBPF version of this kind of network [34] and the shortages are similar. Due to the importance of flexibility for container networks, we focus on analyzing and improving overlay networks. 2.2 The Overhead of Overlay Networks We perform a microbenchmark to demonstrate the overhead of the overlay networks. The testbed is built on top of a base Kubernetes cluster (v1.23.6), including API server, placement engine, etcd, etc. We run the experiments on Cloudlab with three c6525100g nodes [ 35]. Each machine has an AMD EPYC 7402P 24core processor@2.80GHz. Each core of the processer has 2 physical thread, thus there are 48 virtual cores on one machine. And each machine has 128GB ECC memory, and a dualport Mellanox ConnectX5 Ex 100 GBNIC. The host NIC is configured to use Receive side scaling (RSS). We use Ubuntu 20.04 with kernel version 5.18. We use iperf3 [ 12] to measure the throughput between the server and the client, and use the RR (RequestResponse) test in Netperf [ 18] to measure the requestresponse transaction rate. The RR test measures the rate of one byte roundtrips that can be performed in sequence over a connection. The lower latency for a network packet, the higher transaction rate can achieve. Mpstat [ 17] is used to measure the CPU utilization. We measure the CPU utilization on the receiver host because Cai et al. [33] show that the TCP network stack on the receiver side is the CPU bottleneck. In both iperf3 and RR tests, we run parallel tests. In a parallel test, we deploy multiple server and client container pairs on two hosts. All the server containers are on one host and all the client containers are on the other host. Then, all of the container pairs start testing at the same time, which can test the parallel performance of the overlay networks. We select the most widely used CNIs (Container Network ing Interface), including Cilium [ 5], Antrea [ 1], and Calico [ 3] to represent the performance of the overlay network. The intrahost data paths of these CNIs are different. For example, Antrea uses OVS [ 42], Cilium and Calico uses bpf redirect. But all these overlay networks use VXLANlike network stack to encapsulate the container packets. We select the host network as the performance upper bound of overlay networks. The performance of the host network is tested by running applications on host directly. The result of the experiments are shown in Figure 1. First, the throughput results of the overlay networks have a significant gap to the host network, as shown in Figure 1(a)(b). In the single flow test, the throughput of all overlay networks is about 25% lower than that of the host network. At the same time, the CPU utilization of overlay networks is 34%  44% higher than that of the host network. In 2parallel and 4parallel tests, Antrea performs a little bit better and Calico performs a little worse. But the throughput and the CPU utilization of all of them are significantly worse than the host network. In 8, 16, 32parallel tests, all the networks can saturate the host network and thus the throughput becomes the same. But the CPU utilization of the overlay network is much higher (at most 142%). As for the RR test, the results of the overlay networks are much worse than that of the host network, too, as shown in Figure 1(c)(d). In all of the experiments, the RR results of overlay networks are 45%  58% lower. At the same time, the CPU utilization of overlay networks is 20%  37% higher. In conclusion, the microbenchmarks show that the overlay networks incur significant performance degradation com pared to the host network. The performance degradation includes lower throughput, worse latency, and higher CPU utilization. 3SIGCOMM’23, September 1014, 2023, New York City, US Shengkai .et al. Application Overlay Network Stack Bridge/OVS etc. Physical NICUnderla y Network StackContainer vNICpairPhysical Host Application Overlay Network StackContainer vNICpair① ② ③ ④ ⑤ ⑥⑦⑧⑨⑩ Figure 2: The sender and receiver side data path of a typical overlay network.Overhead Taxonomy Sending Path Receiving Path Overlay network stack① 18%Allocating skb⑩ 20%Releasing skb Header encapsulating Header receiving Netfilter Netfilter Namespace Traversing② 8%Transmit queuing ⑨ 4%Transmit queuing Soft IRQ scheduling Soft IRQ scheduling Intrahost forwarding③ 17%Packet routing⑧ 20%Packet routing Netfilter Netfilter Transmit queuing Underlay network stack④ 24%VXLAN encapsulating ⑦ 29%VXLAN receiving Netfilter Netfilter Link layer processing⑤ 33%Transmit queuing ⑥ 27%GRO Table 2: Overhead breakdown of the sender and receiverside data path of a standard overlay network. ①⑩is onetoone corresponding to the tagged location in Figure 2. The proportion of time for each part is also shown in the table. GRO is short for Generic receive offload. 2.3 Overhead Breakdown for Overlay Networks To decompose the overhead in the overlay networks, we analyze the data path through the CPU profiles and the kernel source code. The sender and receiver side data path of a typical overlay network is shown in Figure 2. The overhead incurred by the overlay network is highlighted by the orange boxes. The breakdown of the overhead on both sides of the data path is listed in Table 2. We classify the overhead by the logical place that it occurs. We use CPU profiles to find out the percentage that each overhead class takes up in the whole processing time. The detail analysis is as below. Overlay network stack. The overlay network stack in teracts with the application directly. Taking the sender path as an example, the application first writes data to the sock ets. Then the overlay network stack allocates an skbfor the data and encapsulates the packet headers layer by layer. The receiver path works in the similar way. Besides, to filter and mangle packets, kernel uses netfilter in the network stack. Netfilter checks rules and tracks connections on both the sending and receiving sides for all of the packets, which also incurs overhead. The overlay network stack takes up 18% and 20% time in the whole processing time of the sending path and the receiving path. Namespaces Traversing. The containers run applica tions in individual namespaces and use vNIC pairs to com municate with the root namespaces. This can incur overhead when packets traverse vNIC pairs. This includes the trans mit queuing overhead on the sender vNIC and the software interrupts scheduling overhead on the receiver vNIC. In Cil ium, the namespace traversing overhead is eliminated on the receiving path using bpf redirect peer , but it still existson the sending path [ 6]. The namespace traversing takes up 8% and 4% time in the sending path and the receiving path. Intrahost forwarding. The packets of the overlay net work need to be forwarded between physical NIC and vNICs inside containers. The data path of forwarding varies in differ ent overlay network implementations. For example, Antrea uses OVS, Flannel uses Linux bridge and Cilium uses bpf redi rect. Except for bpf redirect, all of the forwarding data path incur more or less forwarding overhead. Besides, to support the rules that match on the state (e.g. new, established) of connections, some of the data path (e.g. in OVS [ 21]) tracks the connections. This can incur extra overhead. In addition, there is transmit queuing overhead of the sender path to the underlay network stack again. Intrahost forwarding takes up 17% time on the sending path and 20% time on the receiving path. Underlay network stack. VXLANlike protocols encap sulate L2 frames and VXLANlike headers within L4 UDP datagrams. Usually, the encapsulation is done by the under lay network stack that resides in the root namespace. The stack encapsulates or decapsulates the VXLANlike header, UDP header, IP header and MAC header. Netfilter also checks the rules for the packets and track connections in the un derlay network stack. Underlay network stack takes up 24% time on the sending path and 29% time on the receiving path. Link layer processing. The link layer processing over head on the sender side is mainly the transmit queuing as that at vNIC pair. And the overhead on the receiver side is mainly caused by Generic receive offload (GRO). On the receiving of the packets, kernel first tries to coalesce packets from the same flow to larger packets. GRO can reduce the number of packets delivered to the network stack, and thus 4XMasq: LowOverhead Container Overlay Network Based on eBPF SIGCOMM’23, September 1014, 2023, New York City, US lower the CPU overhead. Link layer processing takes up 33% and 27% time in the sending path and the receiving path. Compared to the host network communication, we can see that the namespace traversing, the intrahost forwarding, and the underlay network stack are the extra overhead of the overlay network . Our design, XMasq, focuses on elimi nating the extra overhead while keeping the flexibility and universality of the container networks. 3 OVERVIEW XMasq is a flexible, universal container overlay network with very low overhead. XMasq creates a virtual network like other overlay network implementations while being trans parent to container applications and the underlay network. Unlike Slim only supports connectionbased protocols (e.g., TCP), XMasq supports all transportlayer protocols. XMasq works on the packet level and creates a lowoverhead fast path for each pair of interhost containers. XMasq is implemented with eBPF, a technology that runs sandboxed programs in a privileged context such as the ker nel. Developers can safely and efficiently extend the capabil ities of the kernel with eBPF. eBPF programs can be attached to kernel hook points (e.g., TC or XDP) and are triggered each time the kernel executes through the hook points. XMasq includes three eBPF programs that are hooked to TC of dif ferent NICs. Each time a packet goes through TC of these NICs, it will be processed in the program hooked there. eBPF can store data in a map data struct residing in kernel space, called eBPF map. XMasq uses eBPF maps to store data used in packet forwarding and policy enforcement. To eliminate the extra overhead in the overlay network analyzed in §2.3, a simple idea is to cache all the information that are needed in forwarding, and use a express data path to forward packets. The design of XMasq is based on this idea. XMasq designs a cachebased network virtualization mechanism and a redirectbased intrahost data path. These two designs are tightly combined and take full advantage of eBPF. The cachebased network virtualization mechanism replaces the encapsulating and intrahost routing. In XMasq, the forwarding of the container packets includes masquerading and restoring. The masquerading of packets is on the sender host, which rewrites the overlay network IP and MAC of original container packets to the ones of the underlay network. Thus, the packets can be routed in the underlay network after masquerading. The restoring of packets is on the receiver host, which rewrites the IP and MAC of the masqueraded packets to the ones of the overlay network. Then, the packet can be forwarded to the receiver container. Both masquerading and restoring rely on the local cache on each host. The local cache entry is theLocal MAC Container or Node MAC. Used in packet masquerading or restoring. Remote MAC Local IP Container or Node IP. Used in packet masquerading or restoring. Remote IP Refresh timeTime of last query or update. Used in cache recycling. Restore key Restore key. Used in packet restoring. Container ifkeyContainer NIC index. Used in packet redirecting after restoring. Table 3: The pathinfo struct. It is used in masquerad ing and restoring in XMasq and is stored in eBPF maps. struct as shown in Table 3. Each cache entry corresponds to one container pair∗. With the data in the cache, XMasq can forward the container packets without the help of the underlay network stack and bridge/OVS. The cache is stored in eBPF maps and queried by the eBPF programs of XMasq. The cache should be initialized when a new pair of containers starts communication. For clarity, we call the cache pathinfo cache . Redirectbased intrahost data path eliminates the extra overhead. The redirect means redirecting packets to other NICs on the same host. The eBPF programs on some hooks (e.g., TC, XDP) can indicate the requirement of packet redirecting when it returns. Then the kernel will redirect the packet to the target NIC with very low overhead. We have extended the eBPF networking capacity for XMasq to redirect packets between the container NIC and the physical NIC. With the help of bpf redirect, the packets can jump over the namespace traversing, intrahost forwarding data path (e.g., OVS), and underlay network stack and thus eliminate the overhead. XMasq includes the following components, as shown in Figure 3: 1) three eBPF programs, masqprog, restoreprog, and initprog; 2) four eBPF maps, masq map, restore map, podinfo map and rules map, which are local storage of XMasq; 3) two userspace programs, XMasq daemon, and policy con troller. Most functions of XMasq are realized in eBPF programs. The masqprog, hooked on TC at the egress of the container NIC, is responsible for masquerading container packets. The initprog, hooked on TC at the egress of the host NIC, handles cache initialization. The restoreprog, hooked on TC at the ingress of the host NIC, is used to restore packets. Given the overall design of XMasq, we still need to over come three major challenges. ∗For clarity, we call two ordered containers on different hosts as a container pair. Take two ordered host as a host pair. 5SIGCOMM’23, September 1014, 2023, New York City, US Shengkai .et al. Application Overlay Network Stack Bridge/OVS etc. Physical NICUnder Network StackContainer vNICpairData P ath Masqpr og Restoreprog  Initprog eBPF Maps Userspace   program K VPodIP PodInfo 1) PodInfo map K VPodIP PathInfo 2) Masq map K VPathKey PathInfo 3) Restore map K VRule Action 4) Rules mapXMasq Deamon Policy Contr oller Figure 3: Architecture of XMasq. XMasq includes 3 eBPF programs in the data path, 4 eBPF maps, and 2 user space programs. The eBPF programs is shown in white boxes with the eBPF logo (the bee). Challenge #1: XMasq erases some fields of the original packet headers on the sender host, then how to identify pack ets that belong to different container pairs on the receiver host? XMasq uses a restore key to identify packets belonging to different container pairs. The restore key is coordinated between the sender and the receiver host when a container pair starts communication for the first time. XMasq should make sure the restore key of a container pair is unique to the same host pair to ensure a masqueraded packet with a restore key can be restored correctly. Challenge #2: The pathinfo cache includes information about the remote host, so how to initialize the pathinfo cache with low overhead? Because all of the information needed by XMasq is carried in the VXLANencapsulated packets, an intuitive idea is to use these packets. We design a nearly zero overhead initialization mechanism based on the idea. When the first packet of a container pair starts transmitting, XMasq will let the packet go through the backup standard over lay network. During the transmitting of the packet, XMasq works as a spy. XMasq simply reads the VXLAN packet on the sender and receiver host and thus can get the information to fill up the pathinfo cache. The coordination of the restore key is also done in this step. Challenge #3: XMasq can reduce the overhead on the overlay network data path by skipping the underlay network stack, intrahost forwarding, and namespace traversing. Will this cause some capabilities on the original path unavailable for XMasq? The capabilities include access control, rate limit, QoS, etc. Then how to solve this problem in XMasq? For access control, XMasq stores rules in an eBPF hash map and Application Overlay Network Stack Bridge/OVS etc. Physical NICUnder Network StackContainer vNICpairHost Initprog Application Overlay Network Stack Bridge/OVS etc. Physical NICUnder Network StackContainer vNICpairHost (a) Standar d Overlay Network(b) XMasq Egress Data P ath Ingress Data P athMasqpr og RestoreprogFigure 4: Journey of an overlay network packet in: (a) standard overlay network, (b) XMasq. In (b), initprog is faded out because it only works during initializa tion. queries the map when transmitting packets to decide the action. For rate limit and QoS, users can still use the tctool to enforce data plane policies on containers as usual. 4 DESIGN This section we describe the design of XMasq in detail. The two core designs of XMasq are the cachebased network virtualization and the redirectbased intrahost data path. 4.1 CacheBased Network Virtualization In this section, the overall design of the cachebased net work virtualization, and the design of cache initialization and recycling mechanisms are presented. The overall design. XMasq caches all the required infor mation for network virtualization to avoid the encapsulation and intrahost forwarding overhead. The cache of XMasq is implemented in eBPF hash maps, including masqmap and restoremap. To reduce the packet header overhead, XMasq directly modifies the packet headers instead of adding new headers. The data path of XMasq is shown in Figure 4 and the changes of the packets in the data path is shown in Figure 5. On the sender host, XMasq masquerades the container packets in the masqprog. This process modifies the IP and MAC addresses of the original container packets. The MAC addresses are modified to the ones of the underlay network, and the IP addresses are modified to that of the source and destination hosts. 6XMasq: LowOverhead Container Overlay Network Based on eBPF SIGCOMM’23, September 1014, 2023, New York City, US MAC Header:   Container MACIP Header:   Container IPPayload:   TCP/UDP/ICMP ... MAC Header:   Host MACIP Header:   HostIP & RestoreKeyPayload:   TCP/UDP/ICMP ...Masqpr ogPayload:   TCP/UDP/ICMP ...Restoreprog (a)   Original P acket(b)   Masqed P acket(c)   Restored PacketMAC Header:   Container MACIP Header:   Container IP Figure 5: The content of an overlay network packet forwarded by XMasq. (a) The original packet from con tainers. (b) The masqueraded packet (c) The restored packet To make sure the modified packet can be restored back, XMasq also needs to write a restore key to the packet during masquerading. The restore key is used to distinguish differ ent container pairs belonging to the same host pair. Thus, the restore key should be unique within one host pair. The specific field to write the restore key and the width of it depend on users’ choice. It can be written to any fields in the IP header that are useless for the users in forwarding, e.g., ID, DSCP, and Option. And the width of it depends on the width of the chosen field. The width of the restore key limits the maximum number of container pairs on a host pair that XMasq supports. For example, if the restore key uses IP ID field with 16 bits, then it supports 216pairs of containers on a host pair. After writing the restore key to the packet, which is called the masqueraded packet, XMasq sends it out to the underlay network. The masqmap is a cache used in masquerading. Each entry corresponds to a container pair. The key of the map is the source and destination container IPs, and the value is the pathinfo struct as shown in table 3. The MAC and IP addresses in the struct are those of the host pair where the containers run. The restore key is also stored in the struct. On the receiver host, XMasq restores the masqueraded packet according to the host IP and the restore key in the restoreprog. The restore process includes modifying IP and MAC addresses back to the container’s ones. Then the pack ets can be forwarded to the receiver container. The restoremap is a cache for restoring. The key of the map is a struct of the source and destination host IP and the restore key, which uniquely identifies one container pair on the same host pair. The value is the pathinfo struct that includes the MAC and IP addresses of the container pair. The destination container NIC index is also in the struct. This is used in bpf redirect. The initialization of the cache. All of the information in the masqmap and restoremap should be initialized beforequerying. The initialization is actually adding new cache entries to the maps. XMasq initializes the cache when a new container pair communicates for the first time. The process is shown in Figure 6. XMasq uses a roundtrip of the encapsulated packets to ini tialize. During the transmitting of the encapsulated packets, XMasq just works as a spy. XMasq can get the MAC and IP addresses from the encapsulated packets. For the container NIC index, We use a userspace program, XMasq daemon, to parse and store the NIC index when a new container is provisioned. And the restore key is allocated during the ini tialization. The initialization packets go through two steps. First, the initprog allocates the restore key and parses the headers, as tagged in Figure 6 ①. The initialization packets will be passed to the standard overlay network by the masq prog. After the packet is encapsulated, the initprog can parse the MAC and IP headers of both containers and hosts. Then a restore key is allocated, in random or sequence. The key is used to restore the masqueraded packet on local host, so it should be delivered to the peer host. Therefore, the restore key will be written to the userdefined field in the header. The packet then is sent out to the underlay network. Then, the restoreprog on the receiver host parses the restore key, as tagged in Figure 6 ②. When receiving an encapsulated packets, the restoreprog parses the restore key written to the userdefined field, and stores it to the masq map. Then, the packet is handled by the standard overlay network and finally arrived at the destination container. The above process can fill up half of the masqmap and restoremap on both hosts. Then the reply of this encapsu lated packet will go through a similar but reverse process and finishes the whole initialization process. The recycling of the pathinfo cache. XMasq updated theRefresh time each time it access to a cache entry. And a background program, XMasq daemon, keeps running to check and delete the expired cache periodically. Both of the check period and expiration time are configurable by users. To ensure all the masqueraded packets can be properly restored, the daemon should delete an entry in the masqmap before the corresponding entry in the restoremap on its peer host. This can be guaranteed by setting a longer expiration time for the restoremap than the masqmap. 4.2 Redirectbased Intrahost Data Path The local cached headers and NIC indexes make it possi ble for XMasq to finish all the network virtualization and intrahost forwarding processes in eBPF programs. There fore, packets can skip the processes (as described in §2.3) in the kernel. XMasq uses bpf redirect to directly forward pack ets to another NIC after masquerading or restoring packets. 7SIGCOMM’23, September 1014, 2023, New York City, US Shengkai .et al. Application Overlay Network Stack Bridge/OVS etc. Physical NICUnder Network StackContainer vNICpairHost 1 Masqpr og Restoreprog  Initprog Application Overlay Network Stack Bridge/OVS etc. Physical NICUnder Network StackContainer vNICpairMasqpr og Restoreprog  Initprog Host 2 ①Value Restore keyHost MAC Host IP container MAC container IP NIC index① ④Container IPKey Map v alue Restore keyMap K ey ① ② ③ ④③container MAC container IP NIC indexMap v alue Restore keyMap K eyValue Restore keyHost MAC Host IP③ ②Container IPKey ① ①(a) Masq Map on Host 1 (b) Restore Map on Host 1 ③(c) Masq Map on Host 2 (d) Restore Map on Host 2③ Figure 6: The cache initialization process of XMasq. XMasq uses the roundtrip encapsulated packets to initialize the cache. ①④mark the four events where part of the cache is filled up. The filled fields is also marked in the table (a)  (d). The bpf redirect is performed by the Linux kernel. The kernel simply modifies the devfield in sk_buff which indi cates the device that the packet belongs to. There are differ ent redirecting types, including redirect within root names pace (e.g., bpf redirect ), and to other namespace (e.g., bpf redirect peer ,bpf redirect rpeer ). The type and the target of redirecting can be set by eBPF helper functions. XMasq uses bpf redirect rpeer andbpf redirect peer . bpf redirect peer is used to redirect packets from ingress port of NICs in the root namespace to ingress port of NICs in other namespaces. This is introduced by Cilium to the Linux kernel [ 30]. We use it in the restoreprog to redirect packets from the ingress of physical NIC to the ingress of destination container NIC. The restoreprog calls thebpf_redirect_peer helper function to set the target. Af ter the program returning, the kernel will get the devpointer of the destination NIC, and rewrite the devfield in sk_buff . bpf redirect rpeer is used to redirect packets from the egress port of NICs in the nonroot namespaces to the egress port of NICs in the root namespace. We introduce this redi rect function to the kernel. The design of bpf redirect rpeer is similar to bpf redirect peer . First, the eBPF program set the target by bpf_redirect_rpeer helper function. Then, the kernel gets the target devpointer and rewrites devfield. This kernel logic is added to skb_do_redirect . In XMasq, it is used to redirect packets from the egress of container NIC to the egress of the physical NIC after masquerading of packets. (Note that bpf redirect peer only works in the ingress direction.) The redirect overhead of TC eBPF programs is low. This is not only because the redirect simply modifies a field of sk_buff , but also because the redirect can be done in one go without scheduling any new interrupts or data copy.4.3 Support for Flexible Network Policies Dataplane policies. XMasq uses TC tools to support data plane policies, including rate limiting and QoS. Although XMasq skips some kernel processing in its data path, the conventional functions (e.g. dataplane policies) of the TC tool still work for XMasq. The TC tool supports the conventional functions or eBPF programs by attaching differ ent qdiscs (queueing discipline) [ 28]. There are many qdiscs used to implement conventional functions, such as sch_htb , sch_mq . And the eBPF programs belong to qdisc sch_clsact . sch_clsact qdisc’s hook operates completely independent from conventional qdiscs [ 27]. Therefore, XMasq can still use TC tools to enforce dataplane policies. Controlplane policies. XMasq supports standard L3 and L4 access control with low overhead. The access control rules are defined by a fivetuple (src/dst IP, protocol, and src/dst port) and the action (allow or deny). The rules support wildcard match. XMasq uses an eBPF hash map to store the access control rules. The key of the rules map is the fivetuple and the value is the action. The user space program, Policy Controller, can add or delete the rules in the map. When adding rules, the controller first checks if any existing rules conflict with the new one. If so, the new rule cannot be added. XMasq checks the rules map when masquerading, restoring, and initializing. The packets will be dropped if the queried action is Deny. We design a rule cache mechanism to accurate the match ing on rules. If a packet cannot match a rule exactly by five fields, XMasq will add the match result to the rules map. For example, if XMasq finds that a packet matches an Allow rule by three fields, then XMasq will add an Allow rule that ex actly matches the packet to the rules map. And the following 8XMasq: LowOverhead Container Overlay Network Based on eBPF SIGCOMM’23, September 1014, 2023, New York City, US packets belongs to the same flow can match the rule with only one query. 5 EVALUATION & ANALYSIS We evaluate XMasq against the host network and the existing container networks in this section. We first microbenchmark the performance and CPU utilization. The performance in cludes throughput, latency, and connection setup time. We then evaluate the performance for popular distributed ap plications, including Memcached [ 15], PostgreSQL [ 24], and Nginx [ 19]. The host network cannot provide network iso lation for containers, but its performance offers an upper bound for container communication. The standard container network encapsulates container packets by host network headers, and its performance serves as a baseline for con tainer networks. We will show in this section that XMasq, as a new container network technology, closes the performance gap between container networks and host networks. We use the same testbed described in §2.2, except that we modify the Linux kernel to support bpf redirect rpeer. We deploy XMasq as a plugin of the Antrea CNI (encap mode), which is responsible for allocating subnets for containers and forwarding the initialization packets of XMasq. 5.1 Microbenchmarks As in §2.2, iperf3 [ 12], and netperf [ 18] are used to measure the throughput and requestresponse (RR) transaction rate (RR transaction rate reflects the latency performance). Mp stat [ 17] is used to measure the CPU utilization. We perform both TCP and UDP tests. For TCP, we measure the CPU uti lization on the receiver host because the bottleneck is on the receiver side. For UDP, we measure the CPU utilization on the sender host because packet loss is unpredictable in the underlay network. In order to saturate the network, we also perform parallel tests. The results of Antrea and Calico is very close. For clarity, we compare XMasq with Antrea in following analysis. TCP microbenchmarks. The throughput, RR, and CPU utilization results are shown in Figure 7 (a) – (d). XMasq sig nificantly improves the throughput and RR results while uti lizing fewer CPU resources. In the throughput experiments, compared to Antrea, XMasq improves the throughput by 18.1% and 29.2% in 1parallel and 2parallel tests while the CPU utilization is 9.5% and 13.6% lower . In 8, 16, and 32 parallel experiments, all the container networks saturate the 100Gb physical bandwidth. But XMasq utilizes 50.2%, 48.7%, and 45.0% fewer CPU resources. For the RR experiments, all the RR results of XMasq in 1, 2, 4, and 8parallel experiments are about 100% higher than Antrea. In 8, 16parallel experiments, the improvements are82% and 67%. And the CPU utilization of XMasq is 14%  21% lower at the same time. UDP microbenchmarks. The results are shown in Fig ure 7 (e) – (h). The UDP throughput of XMasq is 41.6% higher than Antrea in the 1parallel experiment, while the CPU utilization remains the same. In 2, 4parallel experiments, XMasq improves the UDP throughput by 48.0% and 53.8%, while the CPU utilization is only 4.0% and 16.9% higher. In 8, 16, and 32parallel experiments, the improvement in through put and CPU utilization is much smaller. This is because, the bottleneck moves from the CPU to the physical network. Actually, XMasq almost reaches the performance’s upper bound (the host network). For the RR experiments, XMasq improves the UDP RR per formance by 45.7%  62.7% in different parallel experiments, while the CPU utilization is very close to the Antrea (no higher than 7.7%). Network Policy. XMasq supports network policies, in cluding rate limiting, QoS, and access control. All the policies take effect immediately. We examine an example scenario where rate limiting and access control are applied. We run a pair of XMasq containers on different hosts and continually run an iperf3 test between them. We add some rate limiting and access control policies on one of the containers. We use tc[28] command to enforce ratelimiting policies and the policy controller to enforce access control policies. Figure 8(a) shows the throughput of a container over 60 seconds. When there is no policy, the throughput is about 34 Gbps. Then we enforce ratelimiting policies with 20Gb, 10Gb, and 5Gb limits. Soon after the policies are applied, the throughput drops to 18.8Gb, 9.82Gb, and 4.96Gb, respectively. We finally apply an access control policy that denies this container’s IP. As expected, the throughput drops to zero. We have also compared the performance of XMasq with and without access control policies. There is no significant difference between the results. This is because the overhead of checking a hash map is very small. Connection Setup. We write a C++ script to test the TCP connection setup time on different container networks†. In the C++ script, the client repeats setting up and closing TCP connections to the server for 100 times, and record the average connection setup time. The connection setup time results are shown in Figure 8(b). Compared to Antrea, the TCP connection setup time of XMasq is 26.5% lower. This is because XMasq eliminates the overhead of the standard overlay networks. Compared to Slim, XMasq is 85.7% faster for connection setup. The reason is that Slim needs to per form service discover in order to setup connections, which takes several RTTs. †Netperf’s CRR test can measure the TCP connection setup time, but it does not work in Slim containers. 9SIGCOMM’23, September 1014, 2023, New York City, US Shengkai .et al. /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000017/uni00000013/uni00000019/uni00000013/uni0000001b/uni00000013/uni00000014/uni00000013/uni00000013/uni0000002a/uni00000045/uni00000053/uni00000056  /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000018/uni00000014/uni00000013/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000046/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000015/uni00000013/uni00000013/uni00000017/uni00000013/uni00000013/uni00000019/uni00000013/uni00000013/uni0000004e/uni00000035/uni00000048/uni00000054/uni00000058/uni00000048/uni00000056/uni00000057/uni00000056/uni00000012/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000047/uni0000000c/uni00000003/uni00000037/uni00000026/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000018/uni00000014/uni00000013/uni00000014/uni00000018/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000048/uni0000000c/uni00000003/uni00000038/uni00000027/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000018/uni00000013/uni00000014/uni00000013/uni00000013/uni0000002a/uni00000045/uni00000053/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni00000049/uni0000000c/uni00000003/uni00000038/uni00000027/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000014/uni00000013/uni00000015/uni00000013/uni00000016/uni00000013/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni0000004a/uni0000000c/uni00000003/uni00000038/uni00000027/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000015/uni00000018/uni00000013/uni00000018/uni00000013/uni00000013/uni0000001a/uni00000018/uni00000013/uni0000004e/uni00000035/uni00000048/uni00000054/uni00000058/uni00000048/uni00000056/uni00000057/uni00000056/uni00000012/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000014/uni00000015/uni00000017/uni0000001b/uni00000014/uni00000019/uni00000016/uni00000015 /uni0000000b/uni0000004b/uni0000000c/uni00000003/uni00000038/uni00000027/uni00000033/uni00000003/uni00000029/uni0000004f/uni00000052/uni0000005a/uni00000031/uni00000058/uni00000050/uni00000013/uni00000018/uni00000014/uni00000013/uni00000014/uni00000018/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056 /uni0000004b/uni00000052/uni00000056/uni00000057 /uni0000005b/uni00000050/uni00000044/uni00000056/uni00000054 /uni00000046/uni00000044/uni0000004f/uni0000004c/uni00000046/uni00000052 /uni00000044/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 Figure 7: TCP and UDP microbenchmark results of the host network, XMasq, Calico, and Antrea. Both Calico and Antrea create standard overlay networks. The first row is the TCP test results, and the second is the UDP test results. The first column is the throughput results, and the second column is its CPU utilization. The third column is the requestresponse (RR) results, and the fourth is its CPU utilization (Note that the CPU utilization is not normalized). Both throughput and RR results are the sum of all the parallel flows. /uni00000013/uni00000014/uni00000013/uni00000015/uni00000013/uni00000016/uni00000013/uni00000017/uni00000013/uni00000018/uni00000013/uni00000019/uni00000013 /uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c/uni00000013/uni00000014/uni00000013/uni00000015/uni00000013/uni00000016/uni00000013/uni00000017/uni00000013/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni0000002a/uni00000045/uni00000053/uni00000056/uni0000000c /uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni00000036/uni0000004f/uni0000004c/uni00000050 /uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000026/uni00000052/uni00000051/uni00000051/uni00000048/uni00000046/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000036/uni00000048/uni00000057/uni00000058/uni00000053/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni00000013/uni00000015/uni00000013/uni00000013/uni00000017/uni00000013/uni00000013/uni00000019/uni00000013/uni00000013/uni00000037/uni0000004c/uni00000050/uni00000048/uni00000003/uni0000000b/uni00000058/uni00000056/uni0000000c Figure 8: (a) A bar graph of the throughput of an XMasq container with rate limit and access control policy update to the container. We enforce 20Gb, 10Gb and 5Gb rate limit policy at 11s, 21s, and 32s. Then a deny access control policy is enforced at 54s. All the policies take effect immediately. (b) The connection setup time experiment results. Error bars denote stan dard deviations. Slim runs in the nonsecure mode in this experiment. 5.2 Applications We evaluate XMasq with three realworld applications: in memory keyvalue store Memcached [ 15], database Post greSQL [24] and web server Nginx [19]. Memcached. We deploy a pair of XMasq containers on two hosts, one of which runs the Memcached [ 15] server (v1.6), and the other runs a standard Memcached benchmark /uni00000013/uni00000011/uni00000013 /uni00000013/uni00000011/uni00000018 /uni00000014/uni00000011/uni00000013 /uni00000014/uni00000011/uni00000018 /uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000030/uni00000048/uni00000050/uni00000046/uni00000044/uni00000046/uni0000004b/uni00000048/uni00000047/uni00000003/uni0000002f/uni00000044/uni00000057/uni00000048/uni00000051/uni00000046/uni0000005c/uni00000003/uni0000000b/uni00000050/uni00000056/uni0000000c/uni00000013/uni00000015/uni00000013/uni00000017/uni00000013/uni00000019/uni00000013/uni0000001b/uni00000013/uni00000014/uni00000013/uni00000013/uni00000026/uni00000027/uni00000029/uni00000003/uni0000000b/uni00000053/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni0000000c/uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000026/uni00000033/uni00000038/uni00000003/uni00000058/uni00000057/uni0000004c/uni0000004f/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000013/uni00000015/uni00000017/uni00000019/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056/uni00000056/uni00000052/uni00000049/uni00000057/uni0000004c/uni00000055/uni00000054 /uni00000056/uni0000005c/uni00000056 /uni00000058/uni00000056/uni00000055Figure 9: (a) is the Memcached GET latency CDF graph. (b) show the CPU utilization of the Memcached server during the load test. To make the comparation fair, we normalize the CPU utilization by the requests per sec ond of Memcached. tool memtier_benchmark [16] (v1.4.0) as a client. Upon the start of the experiments, the client spawns 4 threads, and each thread starts 50 connections. The ratio of SET and GET requests is 1:10. Memtier runs as fast as possible. The results include latency and requests per second. Figure 9(a) is the CDF graph of the latency of GET requests. The latency of SET and GET in all container networks is very close. XMasq achieves much lower latency than Antrea, with mean latency reduced by 29%, from 0.73 ms to 0.52 ms and 99.9 percentile latency reduced by 45%, from 1.98 ms to 1.09 10XMasq: LowOverhead Container Overlay Network Based on eBPF SIGCOMM’23, September 1014, 2023, New York City, US /uni00000013 /uni00000018 /uni00000014/uni00000013 /uni00000014/uni00000018 /uni00000015/uni00000013 /uni0000000b/uni00000044/uni0000000c/uni00000003/uni00000033/uni00000052/uni00000056/uni00000057/uni0000004a/uni00000055/uni00000048/uni00000036/uni00000034/uni0000002f/uni00000003/uni0000002f/uni00000044/uni00000057/uni00000048/uni00000051/uni00000046/uni0000005c/uni00000003/uni0000000b/uni00000050/uni00000056/uni0000000c/uni00000013/uni00000011/uni00000013/uni00000013/uni00000011/uni00000015/uni00000013/uni00000011/uni00000017/uni00000013/uni00000011/uni00000019/uni00000013/uni00000011/uni0000001b/uni00000014/uni00000011/uni00000013/uni00000026/uni00000027/uni00000029/uni00000003/uni0000000b/uni00000053/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni0000000c/uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000000b/uni00000045/uni0000000c/uni00000003/uni00000031/uni00000052/uni00000055/uni00000050/uni00000048/uni00000047/uni00000003/uni00000026/uni00000033/uni00000038/uni00000003/uni00000038/uni00000057/uni0000004c/uni0000004f/uni00000013/uni00000015/uni00000017/uni00000019/uni0000001b/uni00000014/uni00000013/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056/uni00000056/uni00000052/uni00000049/uni00000057/uni0000004c/uni00000055/uni00000054 /uni00000056/uni0000005c/uni00000056 /uni00000058/uni00000056/uni00000055 Figure 10: (a) shows the CDF graph of PostgreSQL re quest latency in different network. (b) show the CPU utilization of the PostgreSQL server during the load test. The CPU utilization is also normalized as the re sult of Memcached. ms. Note that the latency performance of XMasq is very close to that of the host networks. We also record the average CPU utilization captured by mpstat on the server host during the load test. Note that memtier may run at different rates in different networks. To ensure fair comparison, we normalize the CPU utilization based on requests per second (rps) and plot the normalized CPU utilization in Figure 9(b). The CPU utilization of XMasq is 38.4% lower than that of Antrea. After decomposing the utilization data, we find that XMasq’s softwareinterrupt overhead is 60.2% lower. Note that the CPU utilization of XMasq is still very close to that of the host network. Postgresql. We deploy a database, PostgreSQL [ 24] in one container and use its default benchmark tool, pgbench [ 22], to test its performance on another container on a different host. Pgbench implements the TPCB benchmark. It creates a database with 5 million banking accounts and executes 100 clients simultaneously. Pgbench runs as fast as possible, and the results include latency and transactions per second. Figure 10(a) shows the latency of pgbench experiments. Compare to Antrea, XMasq reduces the mean transaction latency by 26%, from 7.811 ms to 5.768 ms. As a reference, the average latency with the host network is 5.468 ms. Figure 10(b) plots the CPU utilization normalized by the transaction rate. Compare to Antrea, XMasq reduces the total CPU utilization by 15.6% and the softirq part of CPU utilization by 43.8%. Again, the CPU utilization of XMasq is similar to that of the host network. Nginx. To evaluate the performance of the HTTP servers, we perform load tests on HTTP/1.1 and HTTP/3 (QUIC) [ 25], which represent the HTTP protocols that uses TCP and UDP, respectively. In the experiments, SSL is disabled in HTTP/1.1 and enabled in HTTP/3. We use Nginxquic [ 20], which is a branch of Nginx with QUIC support, as an HTTP server. We use h2load [ 11] to benchmark the HTTP server. H2load runs /uni00000013 /uni00000018 /uni00000014/uni00000013 /uni0000000b/uni00000044/uni0000000c/uni00000003/uni0000002b/uni00000037/uni00000037/uni00000033/uni00000012/uni00000014/uni00000011/uni00000014/uni00000003/uni0000002f/uni00000044/uni00000057/uni00000048/uni00000051/uni00000046/uni0000005c/uni00000003/uni0000000b/uni00000050/uni00000056/uni0000000c/uni00000013/uni00000011/uni00000013/uni00000013/uni00000011/uni00000015/uni00000013/uni00000011/uni00000017/uni00000013/uni00000011/uni00000019/uni00000013/uni00000011/uni0000001b/uni00000014/uni00000011/uni00000013/uni00000026/uni00000027/uni00000029/uni00000003/uni0000000b/uni00000053/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni0000000c/uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000000b/uni00000045/uni0000000c/uni00000003/uni0000002b/uni00000037/uni00000037/uni00000033/uni00000012/uni00000014/uni00000011/uni00000014/uni00000003/uni00000026/uni00000033/uni00000038/uni00000003/uni00000038/uni00000057/uni0000004c/uni0000004f/uni00000013/uni00000011/uni00000013/uni00000013/uni00000011/uni00000018/uni00000014/uni00000011/uni00000013/uni00000014/uni00000011/uni00000018/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056/uni00000056/uni00000052/uni00000049/uni00000057/uni0000004c/uni00000055/uni00000054 /uni00000056/uni0000005c/uni00000056 /uni00000058/uni00000056/uni00000055 /uni00000015/uni00000015 /uni00000015/uni00000017 /uni00000015/uni00000019 /uni00000015/uni0000001b /uni0000000b/uni00000046/uni0000000c/uni00000003/uni0000002b/uni00000037/uni00000037/uni00000033/uni00000012/uni00000016/uni00000003/uni0000002f/uni00000044/uni00000057/uni00000048/uni00000051/uni00000046/uni0000005c/uni00000003/uni0000000b/uni00000050/uni00000056/uni0000000c/uni00000013/uni00000011/uni00000013/uni00000013/uni00000011/uni00000015/uni00000013/uni00000011/uni00000017/uni00000013/uni00000011/uni00000019/uni00000013/uni00000011/uni0000001b/uni00000014/uni00000011/uni00000013/uni00000026/uni00000027/uni00000029/uni00000003/uni0000000b/uni00000053/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni0000000c/uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000002b/uni00000052/uni00000056/uni00000057 /uni0000003b/uni00000030/uni00000044/uni00000056/uni00000054 /uni00000024/uni00000051/uni00000057/uni00000055/uni00000048/uni00000044 /uni0000000b/uni00000047/uni0000000c/uni00000003/uni0000002b/uni00000037/uni00000037/uni00000033/uni00000012/uni00000016/uni00000003/uni00000026/uni00000033/uni00000038/uni00000003/uni00000038/uni00000057/uni0000004c/uni0000004f/uni00000013/uni00000011/uni00000013/uni00000013/uni00000011/uni00000015/uni00000013/uni00000011/uni00000017/uni00000013/uni00000011/uni00000019/uni00000039/uni0000004c/uni00000055/uni00000057/uni00000058/uni00000044/uni0000004f/uni00000003/uni00000026/uni00000052/uni00000055/uni00000048/uni00000056/uni00000056/uni00000052/uni00000049/uni00000057/uni0000004c/uni00000055/uni00000054 /uni00000056/uni0000005c/uni00000056 /uni00000058/uni00000056/uni00000055Figure 11: (a)(c) show the CDF graph of Nginx request latency in different networks when using HTTP/1.1 and HTTP/3 (QUIC). (b)(d) show the CPU utilization of the Nginx server during their load tests. The CPU utilization is also normalized as described before. 100 concurrent clients, and each client issues 2 concurrent streams in the experiment. This experiment setup is close to the limit that an Nginxquic server can handle, because the QUIC support of Nginx is experimental. H2load runs as fast as possible and reports the request rate and latency results. Figure 11(a) & (c) show the latency results. For HTTP/1.1, compared to Antrea, XMasq reduces the mean request la tency by 29%, from 6.14 ms to 4.39 ms. For comparison, the mean request latency in host network is xx ms, and there is still a clear gap between XMasq and host networks. For HTTP/3, XMasq, Antrea and Host achieve similar latency performance. Although the root cause requires further in vestigation, the HTTP/3 test verifies that Antrea supports UDP. In contrast, Slim does not support UDP or HTTP/3. Figure 11(b) & (d) plot the CPU utilization normalized by request rate. Compared to the host network, XMasq’s normalized CPU utilizations are slightly higher. Compared to Antrea, XMasq reduces the normalized CPU utilization by 58.4% for HTTP/1.1 server and 44.7% for HTTP/3 server. The significant improvement mainly comes from the reduction of softirq. XMasq reduces the CPU usage of softirq by 98.4% for HTTP/1.1 server and 96.5% for HTTP/3 server. 11SIGCOMM’23, September 1014, 2023, New York City, US Shengkai .et al. 6 DISCUSSION First packet issue. In some underlay networks, firewalls may track the TCP connection states and filter the TCP pack ets with incorrect states. This could affect XMasq. XMasq use the first packet between two containers as the initialization packet. If a TCP SYN/SYNACK packet happens to be the first packet between two containers, this packet will be encapsu lated and the firewall cannot record the new TCP connection. Then, the followup TCP packets of this connection will be dropped by the firewall. To solve this problem, we let XMasq resend the TCP SYN/SYNACK packets as masqueraded pack ets after initializing the cache. Then the firewall can correctly record the TCP state and let the subsequent packets pass. Why use restore key? XMasq requires a restore key to rewrite/restore the header of each container packet, which is not strictly necessary but has the lowest overhead. Gen erating a restore key incurs overhead for the first packet between two containers. One may eliminate the usage of the restore key by encapsulating each container packet with an outer header, just like IPinIP or VXLAN, in Masqprog and Restoreprog. However, the encapsulation based approach incurs overhead for every packet. Why use TC hook? There are two types of hooks that can be used for networking, XDP and TC. Compared to XDP, TC BPF programs do not require driver support, can redirect packets with lower overhead, is compatible with TC tools and can be hooked on both ingress and egress directions. Therefore, TC is a better choice for XMasq. Support for stateful‡and packetlevel policies. XMasq realizes network policies using eBPF programs. Users can add appropriate filters easily to XMasq’s eBPF programs to enable support for these policies. Container live migration. XMasq supports container live migration [ 40]. Before restarting the migrated container on a new host, XMasq just need to delete the original cache entries related to this container. In contrast, Slim does not support live migration [ 47]. All the TCP connections need to be reestablished after migration. Checksum issues. As XMasq modifies packet headers on the sender/receiver side, packet checksums should be prop erly updated (supported by eBPF helper functions) to avoid being dropped by NICs, switches or kernels. There exists an exception on the sender side. If TX checksum offload [ 4] is enabled, masqprog does not need to update checksums after masquerading each packet. In contrast, checksum update is always needed on the receiver side. About GSO/GRO. The hooking points of masqprog and restoreprog are both TC in XMasq. On the sender side, GSO happens after TC; while on the receiver side, GRO happens before TC. Therefore, XMasq is compatible with GSO/SRO. ‡Policies that match the connection state, e.g., new, established, etc.Support for common debug tools. The PathInfo struct of XMasq does not contain layer4 fields. This design allows XMasq to support layer3 protocols like ICMP. Hence, ping is supported by XMasq. In contrast, slim does not support ping. Security issues of XMasq. On the host side, applications in containers do not have the permission to modify eBPF programs/maps on the hosts. Hence, we believe that there is no obvious security issue. However, on the network side, the traceroute in containers will expose the underlay net work information. Whether there is a security issue requires additional investigation. 7 RELATED WORKS ON EBPF "
18,Efficient Micro-Mobility using Intra-domain Multicast-based Mechanisms (M&M).txt,"One of the most important metrics in the design of IP mobility protocols is
the handover performance. The current Mobile IP (MIP) standard has been shown
to exhibit poor handover performance. Most other work attempts to modify MIP to
slightly improve its efficiency, while others propose complex techniques to
replace MIP. Rather than taking these approaches, we instead propose a new
architecture for providing efficient and smooth handover, while being able to
co-exist and inter-operate with other technologies. Specifically, we propose an
intra-domain multicast-based mobility architecture, where a visiting mobile is
assigned a multicast address to use while moving within a domain. Efficient
handover is achieved using standard multicast join/prune mechanisms. Two
approaches are proposed and contrasted. The first introduces the concept
proxy-based mobility, while the other uses algorithmic mapping to obtain the
multicast address of visiting mobiles. We show that the algorithmic mapping
approach has several advantages over the proxy approach, and provide mechanisms
to support it. Network simulation (using NS-2) is used to evaluate our scheme
and compare it to other routing-based micro-mobility schemes - CIP and HAWAII.
The proactive handover results show that both M&M and CIP shows low handoff
delay and packet reordering depth as compared to HAWAII. The reason for M&M's
comparable performance with CIP is that both use bi-cast in proactive handover.
The M&M, however, handles multiple border routers in a domain, where CIP fails.
We also provide a handover algorithm leveraging the proactive path setup
capability of M&M, which is expected to outperform CIP in case of reactive
handover.","The growth of mobile communications necessitates efficient support for IP mobility. IP mobility addresses the problem of changing the network pointofattachment transparently during movement. When the mobile node moves away from its current network pointofattachment, handover  is invoked to choose another suitable pointofattachment. In such an environment, handover latency and mobility dynamics pose a challenge for the provision of efficient handover. Several studies [1] [8] show that Mobile IP (MIP)[3], the proposed standard, has several drawbacks ranging from triangle routing and its effect on network overhead and endtoend delays, to poor performance during handover due to communication overhead with the home agent. Several micromobility approaches attempt to modify some mechanisms in Mobile IP to improve its performance [4][5]. However, as we will show, such approaches suffer from added complexity and, in general do not achieve the best handover performance. We follow a different approach to IP mobility using multicastbased mobility (M&M) . In such architecture, each mobile node is assigned a multicast address to which it joins through the access routers it visits during its movement. Handover is performed through standard IPmulticast join/prune mechanisms. Such approach, however, is not suitable for interdomain IP mobility, for several reasons. First, the architecture requires ubiquitous multicast deployment , which is only partially supported in today’s Internet. M&M should be designed for incremental deployment,  and to allow coexistence with other IP mobility protocols. Second, the multicast state kept in the routers grows as the number of mobile nodes becomes larger. This problem may be alleviated using state aggregation  techniques [38]. Third, allocating a globally unique multicast address for every mobile node requires a global multicast address allocation  scheme, and wastes multicast resources. Furthermore, mobile nodes incur security  delay with every handover, which may overshadow architectural mechanisms that attempt to reduce handover delays. To alleviate these problems, we propose new schemes for intradomain  multicastbased micro mobility that allow for incremental deployment. In this architecture, a mobile node is assigned a multicast2address within a domain for use with micro mobility . The allocated multicast address is locally scoped  (i.e., unique only domainwide). This allows for domain wide address allocation schemes. Packets are multicast tunneled to the mobile node within the domain. The multicast address of a mobile does not change throughout its movement within the domain. This allows for lighterweight security during handover,  as it is used for micromobility (i.e., intradomain). In this paper we present two different approaches to multicastbased micro mobility, one approach is based on mobility proxies  and the other based on a novel scheme for algorithmic mapping . We compare such approaches and show that algorithmic mapping provides a more scalable and robust approach, and we develop efficient, yet simple, mechanisms to realize it. Furthermore, we conduct extensive simulations to compare the handover performance of our approach to other routingbased micromobility schemes. The proactive handover performance results show that our scheme performs as well as CIP and much better than HAWAII. Furthermore, it handles multiple border routers in a domain where CIP fails. The rest of the document is outlined as follows. Section II introduces multicastbased mobility. Section III provides overview of the intradomain architecture, and discusses the proxybased approach. Section IV describes the algorithmic mapping approach in detail. Section V gives evaluation and comparison results. Section VI discusses related work. We conclude in Section VII. II. Multicastbased Mobility (M&M) Performance during handover is a significant factor in evaluating performance of wireless networks. IP multicast [25][2] provides efficient locationindependent packet delivery. The receiverinitiated approach for IP multicast enables receivers to join to a nearby branch of an already established multicast tree. Multicastbased mobility (M&M) [1][8] uses this concept to reduce latency and packet loss during handover. In multicastbased mobility, each mobile node (MN) is assigned a multicast address. The MN, throughout its movement, joins this multicast address through locations it visits. Correspondent nodes (CN) wishing to send to the MN send their packets to its multicast address, instead of unicast. Because the movement will be to a geographical vicinity, it is highly likely that the join from the new location, to which the mobile recently moved, will traverse a small number of hops to reach the alreadyestablished multicastdistribution tree. Hence, performance during handover improves considerably. An overview of this architecture is given in Figure 1. As the MN moves, it joins to the assigned multicast address through the new access router (AR). Once the MN starts receiving packets through the new location, it sends a prune message to the old AR to stop the flow of the packets down that path. Thus completing the smooth handover process. In spite of its promise, we believe that many issues need to be addressed to realize multicastbased mobility in today’s Internet. These issues include scalability, multicast address allocation, multicast deployment and security. Scalability of Multicast State : The state created in the routers enroute from the MN to the CN is source group (S, G) state. With the growth in number of mobile nodes, and subsequently, number of groups ( G), the number of states kept in the routers increases. In general, if there are ‘ x’ MNs, each communicating with ‘y’ CNs on average, with an average path length of ‘ l’ hops, then number of states kept in the routers is ‘ x*y*l’ states. Clearly, this does not scale . CNJoin Prune   CN   CN (a) (b) (c) Figure 1: Multicastbased mobility. As the MN moves, as in (b) and (c), the MN joins the distribution tree through the new location and prunes through the old location. Multicast Address Allocation : Interdomain M&M requires each MN to be assigned a globally unique multicast address. Using a global multicast address for each MN may be wasteful and requiring uniqueness may not be practical1. Ubiquitous Multicast Deployment : Interdomain M&M assumes the existence of interdomain multicast routing. We believe, however, that incremental deployment and interoperability should be an integral part of any architecture for IP mobility.      Security Overhead : Security is critical for mobility support, where continuous movement of mobiles is part of the normal operation. Such setting is prone to remote redirection  attacks, where a malicious node redirects to itself packets that were originally destined to the                                                        1 Multicast address allocation is an active area of research [15]. We envision the number of MNs to grow tremendously.3mobile. The problem is even more complex with multicast, where any node may join the multicast address as per the IPmulticast host model. These security measures are complex and may incur a lot of overhead. If such measures are invoked with every handover, however, it may overshadow the benefits of efficient handover mechanisms2.      To address the above issues, we propose a new approach for intradomain multicastbased mobility. III. Intradomain Architectural Overview In our intradomain architecture, a mobile node is assigned a multicast address to which it joins while moving. The multicast address, however, is assigned only within a domain and is used for micro mobility. While moving between domains, an interdomain mobility (e.g., Mobile IP) protocol is invoked. In Mobile IP (MIP) [3], every mobile node (MN) is assigned a home address and home agent (HA) in its home subnet. When the MN moves to a foreign subnet, it acquires a careofaddress (COA) through a foreign agent (FA). The MN informs the HA of its COA through a registration  process. Packets destined to the MN’s home address are intercepted by the HA in the home subnet, then it tunnels them to the MN’s COA. This is known as triangle routing . We will use the Mobile IP model to discuss interdomain routing in the following sections.  Several mechanistic building blocks are needed to realize our proposed architecture. First, when the mobile moves into a new domain it is assigned a multicast address. What is the address allocation scheme? Second, packets destined to the mobile are multicasttunneled by an encapsulator  to the mobile node. How are the encapsulator(s)  selected and where are they placed? To answer these questions, we investigate and compare two different approaches: (1) A proxybased architecture, and (2) Algorithmic mapping architecture. A. Reference Architecture  We consider an IP network for a single domain, as shown in Figure 2. The network is connected to the Internet through Border Routers (BRs). An Access Point (AP) is the radio point of contact for a mobile                                                        2 Providing a comprehensive security solution for IP mobility is beyond the scope of this work. We believe, however, that our schemes relaxes security requirements during handover.node. A number of APs are connected to an Access Router (AR). From the access router's point of view, each AP is a node on a separate subnet. When a mobile moves from one AP to another without changing AR is an intraAR handover case that can be specific to AR implementation and is not considered in this paper. When a mobile moves into a new domain it is assigned a multicast care of address (MCOA).  It is also assigned a unicast address that is unique within the domain, called regional care of address (RCOA). Since MCOA is used for routing packets within the domain, there is no need to assign COA at every subnet. The RCOA is a unique unicast address on the msubnet . The msubnet is a unique subnet that is characterized by the mobility where mobile nodes can use their RCOA to establish communication through any AR at the edge of the network. Hence, the msubnet can be viewed as a logical subnet formed by all APs at the edge of the network. All ARs include the prefix for msubnet in their router advertisements [37]. Address allocation and management is discussed later in this paper. When a mobile moves from one AR to another, it is said to handover from old AR (AR old) to new AR (AR new). We use this terminology throughout the rest of the paper. First, we shall describe the proxybased approach and discuss the problems associated with it. AR1 AR2BRInternet AP Figure 2: Reference Mobility Domain Network B. Proxybased Architecture When a mobile node moves into a new domain, it contacts its access router (AR). The AR performs the necessary perdomain authentication and security measures, and then assigns RCOA for the mobile node (MN). As shown in Figure 3, the AR then sends a request message to the mobility proxy (MP) to obtain a multicast address for the visiting MN. The request message includes the home address of the mobile node and its home agent’s address. Upon receiving the request the MP performs two tasks. The first is to register on behalf of the mobile node its own address as4COA with the MN’s home agent. The second task is to assign a multicast address for the visiting MN, send a reply message to the AR and keeps record of this mapping. The mapping is used for packet encapsulation later on. In this scheme, the MP remains transparent to the MN, which makes the placement of MPs within the domain flexible without notifying every MN. 2 .3.bMP MNAR 13.a (1) Mobile contacts access router (AR) (2) AR sends request to mobility proxy (MP) (3.a) MP performs interdomain mobility handoff (3.b) MP sends reply to AR with the assigned multicast address Figure 3: Event sequence as the mobile node moves into a domain. Once this step is complete, the visiting MN joins the assigned multicast address ( G). The joins are sent to the proxygroup pair ( MP, G) and are processed as per the underlying multicast routing. The MN continues to move within the domain using the same multicast address. The scope of the assigned multicast address is local to the domain. Handover is performed using standard join/prune mechanisms and only lightweight intradomain security is required in this case. The HA tunnels the packets that are sent to the MN’s home address to the MP using interdomain mobility. The packets are then encapsulated by the MP, based on the mapping, and sent down the multicast tree to the MN. The MN uses the unicast RCOA for sending packets. To avoid singlepointoffailure scenarios multiple MPs are used. These MPs are typically placed at the border of the domain or at the center of the network3. An algorithm similar to [24] may be used for dynamic MP liveness and election mechanisms. Several issues need to be addressed in the above architecture. First, the MPs need to maintain unicastto multicast address mapping for all visiting MNs. The scalability of such a scheme is of question. Second, complex robustness algorithms are needed to maintain MP liveness information, requiring initial configuration and setup. Third, the service disruption effect of MP failure is not clear. Since the MP registers its own address with the home agent and is used to encapsulate incoming packets, this introduces a thirdparty dependence  problem that is undesirable. In addition,                                                        3 Network center are nodes with min(max distance) to any other node [26].MPs should run a multicast address allocation scheme to ensure collisionfree address assignment. To address these problems we propose a novel approach based on algorithmic mapping  that obviates the need for explicit unicasttomulticast mapping, and eliminates the need for complex address allocation. IV. Algorithmic Mapping Architecture We provide mechanisms for address management and duplicate address detection, and interAR handover. A. Overview In this scheme we assume there is a onetoone mapping between an RCOA and MCOA. When a mobile moves into a new domain it is assigned RCOA by the AR and the mobile performs interdomain handover i.e., it registers the RCOA with its home agent. The AR automatically infers  the multicast address ( MCOA) for the mobile node from the assigned unicast address (RCOA) through a straight forward algorithmic mapping , described later in this section. The AR then triggers a Join message for MCOA to establish the multicast tree. Packets destined to the MN’s home address are tunneled to its RCOA by the HA. These packets when arrive in the foreign domain are identified by the border router (BR) as being destined to a node on the msubnet. As shown in Figure 4, the BR maps the destination unicast address to the multicast address  and transmits the packets to the MN down the multicast tree.  The serving AR changes the destination address from multicast to the unicast address. Since the destination address is modified twice within the network and restored to the RCOA by the AR, the packet does not cause security association violation at the mobile node. AR1 AR2BRInternet APRCOA MCOA RCOA MCOA Algorithmic mappingunicast multicast Mobile Node Figure 4: High level architectural view: Data packet is unicast over the Internet destined to the RCOA and arrives at the border router (BR) for the mobile node. The BR intercepts the packet and5performs algorithmic mapping from the RCOA to MCOA. The packet is then multicast within the domain. This architecture provides several advantages over the proxybased approach. It avoids the third party dependence on the MP. Moreover, since algorithmic mapping is used, no explicit RCOAMCOA mapping is kept or maintained by the encapsulator, which solves the mapping scalability problem and provides a more robust mechanism. B. Address Management The number of multicast addresses required is proportional to the number of mobile nodes in the domain. The scope of an MCOA is local to the domain where it is used. The IPv6 multicast addressing provides facility to define scope within the address [32]. Hence, in the rest of the paper we consider IPv6 address for both RCOA and MCOA. FlagsScope Group ID 11111111(a) IPv6 unicast address (b) IPv6 multicast addressFPTLA ID RsvdNLA SLA Interface ID FP TLA ID RsvdNLA SLA Interface ID 00000110 Interface ID Reserved (c) RCOA to MCOA mapping11111111 Figure 5:  Algorithmic mapping The standard IPv6 unicast and multicast address architectures [32] are shown in Figure 4 (a) and (b). We modify the group bits to include interface ID as the group ID. The remaining bits of the group ID is reserved that is ignored by multicast routing. The 64bit interface ID address space is large enough for all the mobiles within a domain. We also define a new scope: micromobility scope with value 0x6. The SLA is a 16 bit long field, used to create local hierarchy and identify subnets[33]. A single subnet ID, identifying msubnet, is defined for assigning RCOA. When a mobile moves into a foreign domain it is assigned an RCOA.  The AR forms the MCOA by replacing the <FP, TLA ID> bits of the RCOA with the multicast <FP, flag (0000), scope (0110)> values. Thisprovides a simple, yet very efficient and unique algorithmic mapping . The mobile acquires RCOA on the msubnet through either autoconfiguration or DHCP[34]. The autoconfiguration requires duplicate address detection (DAD) [35] on every subnet. In our scheme the mobile obtains RCOA and MCOA once it is connected to the network. We propose a scheme in [39] that detects address duplication within the msubnet, which is performed once at the AR during initial address assignment. The mobile afterward is able to move freely without running DAD at any other AR. When a mobile first connects to the network it performs a high latency interdomain handover, hence duplicate address resolution latency is overshadowed by this handover latency. C. Intradomain Handover  When a mobile moves from one AR to another, a handover event takes place between the two routers. The handover involves route repair  that is path setup inside the network to redirect the incoming traffic flow to the new AR.  In proactive handover  the link between the MN and new AR is established prior to its disconnection with the old AR. Hence a smooth handover, i.e. handover with low packet loss, can take place by exploiting the fact that the new AR is known a priori and bicasting packets to both access routers.  In reactive handover  an abrupt disconnection may cause the MN to switch over to the new AR. The route repair in this case can only be initiated from the new AR, hence bicasting cannot reduce packet loss. Multicasting allows proactive path setup  to the new access router before the mobile is actually connected to it. This can minimize packet losses in reactive handover where bicasting fails. Moreover, bicasting being a special case of multicasting, multicastingbased solution, e.g. M&M, performs equally well for achieving proactive handover. In this section we describe one handover scheme where proactive path setup is used to achieve smooth handover. We define a set of adjacent access routers as the Coverage Access Router Set (CARset). The adjacency can be established based on the adjacency of the radio coverage area of the serving AR in case of cellular wireless network. The serving AR is called the Head of the CARset. Thus, there is a unique CARset defined for every AR. For example, in Figure 6 AR1 to AR7 constitute a CARset for AR1, which is the serving AR for the mobile. The mobile can move to any of the ARs in the CARset without interruption in the packet flow.6A sitelocal multicast group address is assigned to each CARset, called CARset group address (CGA). Every AR that is a member of a CARset must join the corresponding CGA, which serves as a control channel for the members to exchange the control signals. For example, in Figure 6, all the access routers surrounding AR1 join CGA1 to become members of AR1’s CARset (CGA1). Similarly, AR1 must also join six other CAR sets corresponding to adjacent routers AR2 to AR7. AR2 AR7AR1AR3 AR6AR5AR4 AR7AR8AR9 Figure 6: Handover across CARS We define three new control signals as follows: 1. Jmessage  causes the receiving router to join the multicast group identified in the message. 2. Lmessage  causes the receiving router to leave the multicast group identified in the message. 3. HO message exchanged between the two routers involved in handover . Its parameter includes the mobile's RCOA and MCOA. We explain the handover algorithm by using the example depicted in Figure 6. Consider the MN moving from AR1 to AR5. When connectivity is established between the MN and AR5, the AR5 multicasts a J message <MCOA> to the members of its CARset (CGA5) requesting them to join the mobile's MCOA. It then sends HO <RCOA, MCOA> message to AR1 to initiate the prune process. When AR1 receives HO message it multicasts an Lmessage <MCOA> to members of its CARset (CGA1) requesting them to leave the MCOA. Although the ordering of (J => HO => L) messages ensures that Lmessage is initiated after J. The order of message reception, however, is not guaranteed to both CARsets. Depending on the order of arrival of J and L messages at an AR that is a member of both CARsets, it may leave the MCOA whereas it is supposed to have remained joined to that group. To ensure consistency between Join and Leave messages we introduce thefollowing mechanism. Each AR keeps its membership status in a 4tuple <MCOA, Serving Access Router (SR), CGA, State> table. The table contains an entry corresponding to every mobile roaming in a CARset of which the access router is a member. There are two states defined: Joined and Left. The rules for updating the table specify that an AR only accept Lmessage for a MCOA, if the source of the Lmessage matches the SR in the MCOA’s entry (i.e., the AR has joined the MCOA on the request of the same SR)4. Otherwise, the Lmessage is discarded. The AR accepts all Jmessages and creates/updates the related MCOA entry to include the source of the Jmessage (as the SR), CGA to the SR’s CGA (as the entry’s CGA), and the state to Joined. Consider the example shown in Figure 6. Assume that the mobile's MCOA is MG and after power up in the domain it connects to AR1, which then multicasts a Jmessage to its CARset (CGA1). When AR4 receives the Jmessage, it joins MG and creates an entry corresponding to the MCOA in Joined state as shown in Figure 7 (a). Later when the MN moves to AR5 it becomes the new serving router. Then AR5 sends a multicast Jmessage to its CARset (CGA5) followed by a HO message to the old serving router AR1. Since AR4 is a member of both CGA1 and CGA5, it receives both Jmessage from AR5 and Lmessage from AR1. After receiving the Jmessage the table entry is updated as shown in Figure 7 (b). If received after the J message, the Lmessage is discarded. Thus, AR4 remains joined to MG. If received before the Jmessage, however, the Lmessage may cause AR4 to leave the MG, which interrupts packet flow to AR4 until it receives the Jmessage and joins the MG group. The interruption may be minimized by delaying the leave operation. In most cases the HO message delay is sufficient to minimize the interruption. A simple scheme can be employed that periodically checks the table to purge all the entries that are in the Left state and consequently prune the corresponding multicast trees.                                                        4 To account for lost Lmessage, or crash of the SR, a softstate mechanism is used. SR sends periodic Jmessages containing table changes (if any) and providing liveness.7       MCOA   (a) Serving  Router  CGA  Joined  State  AR1 CGA1 MG  Serving  Router  CGA  Joined  State  AR5 CGA5 MG  (b) MCOA  MCOA   Figure 7: Table state at AR4 (a): when MN1 is connected to AR1 (b): after MN1 moved to AR5 V. Evaluation and Comparison       In order to evaluate the performance of M&M and compare it with other known schemes, we simulated M&M, Hawaii [21] and CIP [20] – the three routing based mobility solutions5. We modified the network simulator, ns2 [17] to incorporate M&M. We changed the implementation of mobile node and access router to add mobility detection, handover algorithm and multicast routing. A. Performance metrics       We used the following performance metrics to evaluate the performance of M&M and compare it to CIP and HAWAII. • Handoff delay  is defined as the difference between the time at which the MN received the last packet from the old access router and the first packet from the new access router. • Depth of packet reordering  is measured as the maximum difference in the sequence numbers of adjacent packets. This is a rough indicator of the size of the buffer needed to resequence the out of order packets. • Packet duplication  is the total number of packets duplicated in a single handoff. This is measured as the duration for which reordering occurs. Since CBR traffic is used, reordering duration gives an estimate of how many packets                                                        5 We have also compared our scheme to hierarchical MIP [27] and seamless handoff [31] schemes using routebased analysis. Please refer to [39] for details. As was shown in [39] M&M achieved the min handoff delay and min overhead among the three classes.can be duplicated irrespective of the packet rate at the source. • Routing efficiency  is defined as the ratio of the number of hops between the root of the tree and the MN to the number of hops on the shortest path between the two. This gives a qualitative comparison of routing efficiency.       We did not consider packet loss as a metric for this work as it is also sensitive to factors other than handoff delay such as packet arrival rate and mobility pattern. Mobility detection need not necessarily be a part of the micromobility protocol as this can be better achieved with additional information from lower layers. B. Simulation Scenarios       To study the factors affecting the performance of the micromobility protocols we simulated a rich set of scenarios including both tree topologies of varying depth ranging from 3 to 6. The link bandwidths were fixed at 10Mbps for wired links with delays varied from 10ms to 5ms to 2ms for all links. Detailed 802.11 models in ns2 were used for the wireless part with cell overlap of 30m. Beacons spacing 200ms apart are used for mobility. Prune timeout of 1s is set for the multicast protocol. The handoff mechanism for M&M, CIP and HAWAII are bicast, semisoft handoff and Multi Stream Forwarding (MSF) [21] respectively. Both M&M and CIP use bicast technique whereby packets are bicast to both old and new ARs from a crossover point within the network. In contrast, HAWAII uses buffer and forward technique where the old AR buffers the packets and forwards them during route repair. Random mobility at 30m/s was the mobility pattern used for the MN. CBR traffic with packet size of 512 bytes and 10ms/packet was used. To avoid the side effects of mechanisms of other protocols (like congestion control mechanism of TCP) affecting the handoff delay and packet delivery performance, we chose CBR over UDP as opposed to FTP over TCP. C. Simulation results       We conducted simulations over different topologies, varying parameters like beacon timer, and link delays. Since mobility detection mechanism is not a part of the protocol, simulations were setup such that mobility detection always happened when the MN moved from one access router to another. This was to prevent loss of packets due to failure of mobility detection.8      Graphs for different topologies show the same trend; hence we selected simpler graphs for the tree topology with depth 3. Figure 8 shows the topology used in the simulation. All the graphs follow a common format. Each graph shows data for M&M, CIP and HAWAII (in that order from left to right). The xaxis shows three sets of data corresponding to link delays of 10ms, 5ms and 2ms (again from left to right) for each protocol. Path lengths from fork router to old and new access routers vary along yaxis. For example, ‘3,2’ means path length of 3 hops from the fork router to the old access routers and 2 hops from the fork router to the new access router. The zaxis shows the performance parameters under evaluation. Figure 8 : Simple tree topology       Figure 9 illustrates the handoff delays incurred by M&M, CIP and HAWAII with link delays 10, 5 and 2ms.  From the graphs, we observe that the handoff delay for M&M and CIP is small as compared to that of HAWAII. Both CIP and M&M use bicast, which causes smooth handover with negligible handover delay. Whereas, the HAWAII using the MSF, a buffer and forward scheme consistently incurs long handoff delays.       Figures 10 shows the depth of reordered packets. We measured depth of reordering instead of the number of packets reordered because it indicates the size of buffer needed to resequence the out of order packets. It is obvious from the graph that the depth of reordering is small for M&M and CIP, whereas it is large for HAWAII. The out of sequence packets in M&M and CIP is dependent on the difference in the link delays from fork router to old and new access routers. The greater the difference, the greater will be the depth of reordering. In case of HAWAII the depth is large because the old access router buffers packets and thenforwards it to the new access router via the crossover router. The crossover router also forwards the incoming packets to the new access router at the same time. This results in packets reaching the new access router out of order. The depth of reordering is dependent on the buffering duration and the link delays from the cross over router to the old access router. Its also important to observe the duration for which reordering of packets occur. In M&M and CIP, the reordering occurs as long as bi casting is done. However, in HAWAII, reordering duration depends on the number of packets buffered at the old access router and the link delay from the old access router to the crossover point. M&M  HAWAII M&M  HAWAII M&M  HAWAII3,21,30102030405060708090100Handoff Delay (ms)  3,22,33,11,32,4 Figure 9 : Handoff Delay     It is also important to observe the duration for which reordering of packets occur, because it indicates an estimate of the amount of packet duplication caused by a scheme. Figures 11 illustrate the duration for which reordering caused by the three schemes. In case of M&M and CIP, the reordering occurs as long as bi casting lasts causing large number of packet duplication as shown in the figure. Whereas, for HAWAII reordering duration depends on the number of packets buffered at the old access router and the link delay from the old access router to the crossover point, which shows relatively low number of duplications.9Figure 10 : Maximum difference in sequence numbers of consecutive packets.       In case of border router (BR) acting as the root of the multicast tree the M&M uses the shortest path to route packets to the MN. This is unlike CIP, which uses the shortest path along the reverse path from the MN to the BR to route packets from the BR to the MN. Hence, it does not guarantee shortest path. However, in most cases the routing in M&M is as efficient as CIP. In case of HAWAII routing is a function of topology and node mobility, which is generally less efficient than that of M&M and CIP.Figure 11 : Reordering duration         Both HAWAII and CIP do not handle well the case where a domain contains multiple border routers. In particular, if packets enter the domain through one border router and leave through another border router, routing in CIP fails. The M&M relies on the underlying multicast protocol to handle multiple border routers in a domain, which is often the case. For example, mechanisms exist in PIMSM to deliver packets to the RP irrespective of the location of the sender (BR at which the packet enters the domain). The flexibility comes at the expense of decreasing routing efficiency, because packets are first tunneled to the RP and then delivered to the MN through the multicast tree. To alleviate this situation only the BRs can be configured as candidate RP, thus ensuring that one of the BRs becomes the RP. VI. Related Work "
69,Embedding and generation of indoor climbing routes with variational autoencoder.txt,"Recent increase in popularity of indoor climbing allows possible applications
of deep learning algorthms to classify and generate climbing routes. In this
work, we employ a variational autoencoder to climbing routes in a standardized
training apparatus MoonBoard, a well-known training tool within the climbing
community. By sampling the encoded latent space, it is observed that the
algorithm can generate high quality climbing routes. 22 generated problems are
uploaded to the Moonboard app for user review. This algorithm could serve as a
first step to facilitate indoor climbing route setting.","Given increasing popularity of indoor climbing, we created a deep autoencoder to generate climbing routes (route setting) with a worldwide training apparatus Moonboard. One of the mottos of the apparatus is to set the standard for indoor training and over the years it has become globally recognised as one of the most effective strength training tools for rock climbing. Unlike many indoor climbing gyms, its standardized setup and welldeveloped user platform provide an unique opportunity for prototyping and testing various supervised machine learning algorithms for route setting. Route setting is an important area in indoor climbing, and very often it challenges route settings' imaginations. Although fulfilling, route setting could be tedious at times. This work serves as a first step for wide applications of machine learning (ML) to facilitate or speed up the route setting. Existing works for indoor climbing focus primarily on classification of route difficulties [1,2,11,13], with or without using deep learning algorithms. Inspired by techniques from natural languauge processing [6], just as words constitute sentences, indoor climbing problems are composed of holds, route setting has been recently investigated with long shortterm memory (LSTM) with sequential predictions based on previous climbing holds [3]. Here we adopted a different approach of embedding each climbing problem into a latent space to allow maximal freedom for the algorithm to learn correlations between each climbing hold. The paper is organized as follows. Section 3 gives an overview of the algorthm. Section 4 describes the results obtained from the training of the algorithm. 2 Moonboard The Moonboard website hosts a database of Moonboard climbing routes for each Moonboard configuration. Routes are represented graphically by a Moonboard image with holds selected by circles. Various Moonboard setups are shown in Figure 1. We consider the 2017 configuration, which consists of 198 holds. 1/6arXiv:2009.13271v1  [cs.LG]  16 Sep 2020Figure 1. Moonboard setup 2016 (left), Moonboard setup 2017 (right). 3 Method "
462,Load Balancing and Mutisource Routing in Information-Centric-Networking.txt,"Information-Centric Networking is still an incomplete paradigm which
introduces a large variety of new topics and approaches over the traditional
networking. Since it is a relatively new concept which promises for easier and
faster data access many aspects of it have been studied intensely in recent
years. Nonetheless, load balancing is one of the least focused but high
potency, open-ended areas. The aim of this project is to present an alternative
technique to load balancing in the domain of pre-suggested routing method LSCR
(Link State Content Routing). We suggested multi-path interest and multi-source
data packet routing on the bases of Forwarding and Routing Tables of LSCR and
packet routing protocol of Source Routing. We have developed a simulator
software to implement and test the multi-path routing algorithm. Multi-path
routing and LSCR are compared with regard to the load of the links, package
loss, package delay and overall network performance.",1.1 Our Motivation to Work on ICN . . . . . . . . . . . . . . . . . . . . . . . . 3 1.2 General Knowledge About ICN . . . . . . . . . . . . . . . . . . . . . . . . 4 1.3 Overview of Routing in the ICN . . . . . . . . . . . . . . . . . . . . . . . . 5 2 State of The Art 6 2.1 Summary of Research Papers . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.2 Shortcomings of ICN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3 Methods 9 
211,Improving Route Choice Models by Incorporating Contextual Factors via Knowledge Distillation.txt,"Route Choice Models predict the route choices of travelers traversing an
urban area. Most of the route choice models link route characteristics of
alternative routes to those chosen by the drivers. The models play an important
role in prediction of traffic levels on different routes and thus assist in
development of efficient traffic management strategies that result in
minimizing traffic delay and maximizing effective utilization of transport
system. High fidelity route choice models are required to predict traffic
levels with higher accuracy. Existing route choice models do not take into
account dynamic contextual conditions such as the occurrence of an accident,
the socio-cultural and economic background of drivers, other human behaviors,
the dynamic personal risk level, etc. As a result, they can only make
predictions at an aggregate level and for a fixed set of contextual factors.
For higher fidelity, it is highly desirable to use a model that captures
significance of subjective or contextual factors in route choice. This paper
presents a novel approach for developing high-fidelity route choice models with
increased predictive power by augmenting existing aggregate level baseline
models with information on drivers' responses to contextual factors obtained
from Stated Choice Experiments carried out in an Immersive Virtual Environment
through the use of knowledge distillation.","It is widely known that trafﬁc congestion has signiﬁcant environmental, economic, and public health consequences. The total cost and time loss associated with trafﬁc congestion in the US has been reported to be more than $121 billion per year and 38 hours per person, respectively [1]. In the US, people mostly prefer to use freeways and highways. However in case of trafﬁc congestions, alternative routes are also taken to avoid travel delay [2]–[4]. Mainstream research shows growing interest and need for better understanding drivers route choice behavior [5]–[9]. Route Choice Models [5], [10]–[14] predict the route choices of travelers traversing an urban area. Most of the route choice models link route characteristics of alternative routes to those chosen by the drivers. The models play an important role in prediction of trafﬁc levels on different routes and thus assist in development of efﬁcient trafﬁc management strategies that result in minimizing trafﬁc delay and maximizing effective utilization of transport system. High ﬁdelity route choice models are required to predict trafﬁc levels with higher accuracy. Existing route choice mod els use revealed preference behavior to model route choice. 0.050.150.250.350.450.55 1234Probability (%)ExitBasic ModelRe al DataFig. 1. Comparison of Predictions Made by an Aggregate Route Choice Model with Ground Truth. The use of revealed choice data limits the accuracy of the prediction as it fails to capture subjective factors of drivers at individual level and allows prediction only at an aggregate level. Fig.1 shows the route choice predictions made by a basic aggregate level route choice model (blue line) compared with real data collected from the ﬁeld (red line). More precisely, Fig.1 shows the probability of drivers exiting a freeway segment through one of the four available exits as predicted by a baseline aggregate route choice model (blue line); the red line in Fig.1 shows the ground truth. It can be seen from Fig.1 that the predictions made by the basic model deviate widely from the ground truth. Existing route choice models do not take into account dynamic contextual conditions such as the occurrence of an accident, the sociocultural and economic background of drivers, other human behaviors, the dynamic personal risk level, etc. As a result, they can only make predictions at an aggregate level and for a ﬁxed set of contextual factors. Therefore, for higher ﬁdelity, it is highly desirable to use a methodology that captures signiﬁcance of subjective or contextual factors in route choice. Adding subjective or contextual requires availability of the data at individual or disaggregate level. Stated Choice Ex periments (SCEs) are a scientiﬁc methodology to capture the effect of context sensitive factors in route choice. The current advancements in virtual reality technology can enhance stated choice experiments by allowing researchers to present them in a realistic manner that enhances the realism of the experiments and allows one to elicit information about route choice madearXiv:1903.11253v1  [cs.LG]  27 Mar 2019Loss VR DataClassiﬁcation Cross Entropy Loss TeacherStudentSoftmaxFeature Extraction NetworkDistillationShared WeightsLoss FeedforwardBackpropagationSoftmax Basic DataClassiﬁcation Soft LabelFeature Extraction NetworkFig. 2. Overview of our framework architecture. by a driver. Integrated Virtual Environments (IVEs) [15], [16] provide a good platform to conduct SCE and elicit responses to route choice experiments as realistically as possible. The promise of IVE applications in collecting data includes, but is not limited to, providing a safe and userfriendly experimental platform, being inexpensive and highly portable, as well as generating contextaware and highﬁdelity data. This paper presents a novel approach for developing high ﬁdelity route choice models with increased predictive power by augmenting existing aggregate level baseline models with information on drivers’ responses to contextual factors ob tained from SCE carried out in an IVE through the use of knowledge distillation. Our approach uses the prior knowledge acquired by a teacher neural network pretrained on data about drivers’ responses to contextual factors to augment a student neural network (a baseline model) in a guided fashion. We demonstrate experimentally that the predictions of the augmented model are much closer to reality than that of the baseline. Contributions: The paper makes the following contribu tions. It presents a novel approach using knowledge distillation for developing highﬁdelity route choice models by aug menting existing baseline models with information about drivers’ reaction to contextual factors acquired from SCEs in IVEs. We present a general endtoend knowledge distillation framework that uses a multilayer perceptron as a feature extraction network to provide a feature learning architec ture for teacher and student networks and then transfers knowledge from the former to the latter by optimizing distillation loss. II. R ELATED WORK "
304,Trust Aware Privacy Preserving Routing Protocol for Wireless Adhoc Network.txt,"Wireless Ad-Hoc Networks are especially helpful and quite well for essential
circumstances such as defense, public safety, and disaster recovery. MANETs
require communication privacy and security, notably in core routing protocols,
when functioning in hostile or suspicious environments. The Trust Aware
Privacy-Preserving Protocol (TAP3) is a mechanism for supporting the origin in
proactively selecting a trust-able target and doing privacy-preserving route
verification. We suggest TAP3 using the fellow recommendation model for MANETs
in this work. Nodes use their features to discover their fellow node and use
the trust to create strong connections with the random node via a multi-hop
trusting chain by identifying the secure location. The verification duties are
then spread among the nodes and validate the log updates without exposing the
nodes' details. Unlike previous models that uncover node vulnerabilities or
misconduct after an attack, TAP3 may guarantee the origin node to prevent data
from being transferred through malicious nodes from the beginning and do
verification without needing a third party. Our results show that this approach
can locate problematic nodes with minimal overhead than the conventional
routing protocol.","To improve communication mobility, fourth generation  (4G) wireless communication combines mobile ad hoc  networks (MANET) with other connections such as cell  technology, wireless personal area networks, and third  generation (3G) networks. T he primary purpose of the 4G  network is to enable mobile nodes to migrate around the  world without even being constrained by enabling  infrastructure [1 3]. The 4G systems provide one of the  newer wireless networks known as MANETs. MANET is a  mobile node ne twork that uses  multi hop wireless  transmitting and can operate without centralized  infrastructure. Because wireless ad hoc lacks a stable  infrastructure, nodes increasingly depend on fellow nodes  for interaction [4]. The nodes can configure individually a nd  construct an ad hoc architecture on the move.     Moreover, many MANET implementation situations  include functioning in dangerous conditions, implying that  assaults are either anticipated or  possible at the very  minimum  [5].  Whereas most previous work in protected  MANET route discovery concentrated on security problems,  less attention to privacy. Note that privacy doesn't mean  confidentiality of interaction (i.e., data) between many  MANET endpoints; that's also a fundamental aspect of protected MANET opera tion. Cryptography quickly acquires  suitable access control remedies to establish or maintain the  network.     Integrating MANETs to the unsecured network for web  access, on the other hand, poses significant risks and  obstacles [10,11]. Ad hoc networking technologies typically  have different compatibility than traditional internet routing  algorithms. In ad hoc netw orks, routing protocols help with  route training and management, whereas the web handles  these activities by specialized routers executing routing  algorithms. The communication between web nodes and  mobile ad hoc networks is managed by customized mobile  gates (MG) positioned at the MANET's border and linked to   the communication infrastructure and the MANET. The MG  must execute the infrastructural network's routing  mechanism and the MANET's ad hoc routing algorithm to  offer an interconnection between the two  or more networks.     Nevertheless, these previous mechanism s cannot be  employed  in the decentralized and simultaneous secure  route finding process. Initially, the dynamic routing  protocol's connection overhead typically increases as the  network size grows. In contrast, reactive routing approaches  without a safe technique will result in some transmission B. Murugeshwari et al. / IJETT, 70(9), 362370, 2022    363 errors when malicious nodes are present. Furthermore, many  routes, including AODV, DSR, and Multicast, use source  based navigation. After sending the RREQ, t he origin does  not influence data transmission until a path to the target. As  a result, various assaults, such as the black hole attack [6]  and the wormhole attack [7], might occur during the route  discovery process. Most significantly, they fail miserably  to  validate the behavior of nodes anywhere along the system's  chosen path. The source has no way of knowing whether the  subsequent routes have securely delivered the necessary  communications and performed as intended without the  participation of vicious a ttackers. The major problem for  multi path algorithms is choosing the path that decreases  node failure probability while  extending the network's  lifespan [8]. During the routing discovery step, selecting a  friendly approach and performing the verification are  required.     This study offers TAP3 confirmation in MANETs, a  dynamic direction finding exploration, and an automatic  authentication process to address the issues above.  For  starters, using active learning, TAP3 can assist the source in  discovering the  actual destination.  The method then verifies  independently  throughout the route to determine whether the  intermediary routers are fraudulent. Our dynamic training  describes a systematic selection theory [9] determining  the  multivariate vector length betw een the targeted host's  present and typical states. Apart from that can be performed  in a disseminated manner without assembling the entire  node's data. Throughout authentication, the decentralized  nodes work together to extract evidence from the route log   using preset reasoning principles. Nodes may identify  suspicious nodes upon that path from source to destination  and their actual location using the obtained proof. Finally,  TAP3 does not jeopardize the objective of saving every  node's privacy  [21]. Joini ng log tables from multiple routers  is unnecessary to browse through several network log  entries . Instead of relying on log proof acquired during the  execution stage, TAP3 uses a combination of analysis and  verification to fight attackers .  2. Related Work   "
266,Atom: Horizontally Scaling Strong Anonymity.txt,"Atom is an anonymous messaging system that protects against traffic-analysis
attacks. Unlike many prior systems, each Atom server touches only a small
fraction of the total messages routed through the network. As a result, the
system's capacity scales near-linearly with the number of servers. At the same
time, each Atom user benefits from ""best possible"" anonymity: a user is
anonymous among all honest users of the system, against an active adversary who
controls the entire network, a portion of the system's servers, and any number
of malicious users. The architectural ideas behind Atom have been known in
theory, but putting them into practice requires new techniques for (1) avoiding
the reliance on heavy general-purpose multi-party computation protocols, (2)
defeating active attacks by malicious servers at minimal performance cost, and
(3) handling server failure and churn.
  Atom is most suitable for sending a large number of short messages, as in a
microblogging application or a high-security communication bootstrapping
(""dialing"") for private messaging systems. We show that, on a heterogeneous
network of 1,024 servers, Atom can transit a million Tweet-length messages in
28 minutes. This is over 23x faster than prior systems with similar privacy
guarantees.","In response to the widespread electronic surveillance of pri vate communications [69], many Internet users have turned to endtoend encrypted messaging applications, such as Signal and OTR [2]. These encrypted messaging tools provide an ef fective way to hide the content of users’ communications from a network eavesdropper. These systems do little, however, to protect users’ anonymity . In the context of whistleblow ing [38, 76], anonymous microblogging [22], or anonymous surveys [43], users want to protect their identities in addition to the content of their communications. Unfortunately, anonymity systems that protect against pow erful global adversaries typically cannot accommodate large numbers of users. This is primarily due to the fact that tradi tional anonymity systems only scale vertically . These systems consist of a handful of infrastructure servers that act collec tively as an anonymity provider; the system can only scale by increasing the power of each participating server. Sys tems based both on classical mixnets [18, 48, 72] and on DCnets [22, 76] suffer from this scalability challenge. The Tor network [29], in contrast, is an example of an anonymity system that scales horizontally . Tor consists of a network of volunteer relays, and increasing the number of these relays increases the overall capacity of the network.This scalability property has enabled Tor to grow to handle hundreds of thousands to millions of users [3]. However, the fact that Tor provides lowlatency anonymity also makes the system vulnerable to a variety of deanonymization attacks [9, 17, 31, 44, 56, 74, 75]. In this paper, we present Atom, an anonymous messag ing system that takes important steps towards marrying the best aspects of these two architectural strategies. Like Tor, Atom scales horizontally: adding more servers to the network increases the system’s overall capacity. Like mixnet and DC netbased systems, Atom provides clear security properties under precise assumptions. Atom implements an anonymous broadcast primitive for short, latencytolerant messages. In doing so, Atom offers a strong notion of anonymity: an adversary who monitors the entire network, a constant fraction of servers, and any number of users only has a negligible advantage at guessing which honest user sent which message. We target two applications in particular in this paper. The ﬁrst is an anonymous microblogging application. With Atom, users can broadcast short messages anonymously to orga nize protests, whistleblow, or send other sensitive messages. The second is a “ dialing ” application: many existing private messaging systems [8, 50, 72] require pairs of users to ﬁrst establish shared secrets using some outofband means. Atom can implement this sort of dialing system while providing strictly stronger security properties than prior schemes can. An Atom deployment consists of hundreds or thousands of volunteer servers, organized into small groups. To use the system, each user submits its encrypted message to a randomly chosen entry group. Once each server group has collected ciphertexts from a number of users, the group shuf ﬂes its batch of ciphertexts, and forwards a part of each batch to neighboring server groups. After the servers repeat this shufﬂeandforward process for a certain number of itera tions, our analysis guarantees that no coalition of adversarial servers can learn which user submitted which ciphertext. At this point, each group decrypts the ciphertexts it holds to reveal the anonymized plaintext messages. Atom’s scalability comes from the fact that each group of servers works locally , and only needs to handle a small fraction of the total messages routed through the network. In an Atom deployment routing Mmessages using Nservers, each Atom server processes a number of ciphertexts that grows as ˜O(M=N). In contrast, traditional veriﬁableshufﬂe based or DCnetbased anonymity systems require each server to doW(M2)work, irrespective of the number of servers in the system [22, 48, 76]. 1arXiv:1612.07841v3  [cs.CR]  2 Oct 2017The design of Atom required overcoming three technical hurdles. First, in a conventional mixnet, each user produces an onionstyle ciphertext, in which her message is encrypted to each of the mix servers. In Atom, the user does not know the set of servers its message will travel through a priori, so she does not know which servers’ keys to use to encrypt her message. Prior designs for distributed mix systems [55,63,78] circumvented this problem with generalpurpose multiparty computation (MPC) protocols [11,35], but these general meth ods are currently too inefﬁcient to implement. We instead use a new rerandomizable variant of ElGamal [32] encryp tion, which allows groups of servers in the network to col laboratively and securely decrypt and reencrypt a batch of ciphertexts to a subsequent group. Second, Atom must maintain its security properties against actively malicious servers. To protect against active attacks, we group the servers in such a way that every group contains at least one honest server with overwhelming probability. We then rely on the honest server to ensure that certain invariants hold throughout the system’s execution using two different cryptographic techniques. The ﬁrst method relies on veriﬁable shufﬂes [33,39,59], which can proactively identify bad actors but is computationally expensive. The second method is a novel “trap”based scheme, inspired by prior work on robust mixing [46]. This scheme avoids using expensive veriﬁable shufﬂes, but provides a slightly weaker notion of security: a malicious server can remove khonest users from the system (without deanonymizing them) with probability 2"
67,APVAS: Reducing Memory Size of AS\_PATH Validation by Using Aggregate Signatures.txt,"The \textit{BGPsec} protocol, which is an extension of the border gateway
protocol (BGP), uses digital signatures to guarantee the validity of routing
information. However, BGPsec's use of digital signatures in routing information
causes a lack of memory in BGP routers and therefore creates a gaping security
hole in today's Internet. This problem hinders the practical realization and
implementation of BGPsec. In this paper, we present APVAS (AS path validation
based on aggregate signatures), a new validation method that reduces memory
consumption of BGPsec when validating paths in routing information. To do this,
APVAS relies on a novel aggregate signature scheme that compresses individually
generated signatures into a single signature in two ways, i.e., in sequential
and interactive fashions. Furthermore, we implement a prototype of APVAS on
\textit{BIRD Internet Routing Daemon} and demonstrate its efficiency on actual
BGP connections. Our results show that APVAS can reduce memory consumption by
80\% in comparison with the conventional BGPsec.","A. Backgrounds TheBorder Gateway Protocol (BGP) [1] enables networks, such as an Internet service provider (ISP), to exchange rout ing information in the level of autonomous system (AS) by as signing a unique number to each AS. BGP is also the primary routing protocol used in the backbone of the Internet. Howev er, BGP does not verify the validity of routing information bein g exchanged, and thus an AS always registers routing informa tion received from other ASes as valid even if an adversary manipulates the routing information. This fundamental ﬂaw in BGP has caused many incidents that resulted in heavy and serious damages, e.g., Youtube hijacking [2] and Ethereum hijacking [3]. According to some measurement results [4], such a hijack happens about four times a day on average. Therefore, guaranteeing the validity of routing informati on in BGP is an urgent and signiﬁcant issue. To tackle the aforementioned issue, technologies that guar  antee the security of BGP in a cryptographic fashion have attracted attention. Loosely speaking, these technologie s aim to verify the validity of routing information via generatio n and veriﬁcation of digital signatures in the routing informati on. Speciﬁcally, signatures can be used in two ways, namely, route origin validation that only allows advertisements for an IP preﬁx by the legitimate AS as a preﬁx owner and path Ouyang Junjie, Naoto Yanai, Tatsuya Takemura and Jason Paul Cruz are with Osaka University. Masayuki Okada is with JPNIC. Shingo Okamura is with National Institute of Technology, Na ra College.validation that guarantees all members of an AS path which is a connection of ASes from a source to a destination. Route origin validation is almost consummative by virtue of the practical realizations of RPKI [5] and ROA [6], [7] as relate d protocols. In contrast, path validation has no clear practi cal realization even though it is instantiated by BGPsec [8] because its use of digital signatures signiﬁcantly increas es the memory consumption of BGP routers. For instance, according to a current estimation [22], a BGPsec is required to have memory size of several tens of gigabytes. The issue related to the memory size is known as the memory size problem . Moreover, BGPsec lacks experimental evaluations and thus a precise evaluation of the memory size problem remains incomplete. BGP hijacking has also given rise to hijacking of cryptocur rencies [9], [10], such as Bitcoin, as a new aspect of cyber crime. A recent ﬁnding has shown that BGP hijacking [11] can only be prevented by the use of BGPsec. Therefore, an essential issue in BGP security can be solved by making BGPsec practical, i.e., by reducing memory consumption and solving the memory size problem . B. Contribution In this paper, we present a new path validation protocol named APVAS (AS path validation based on aggregate sig natures) , which utilizes aggregate signatures [12] to combine individual signatures into a single short signature and sol ve the memory size problem. Moreover, we implement a prototype of APV AS on a router daemon software. This is a ﬁrst attempt to measure memory size by the use of stateoftheart cryp tography in actual devices. In our experimental environmen t, APV AS can reduce memory consumption by 80% compared to the conventional BGPsec. We believe that APV AS will become an innovative solution to BGPsec. This paper presents two technical contributions. The ﬁrst contribution is the proposal of a novel aggregate signature scheme named bimodal aggregate signatures . Aggregate sig natures are expected be applicable to BGPsec in cryptograph ic theory, but the algebraic structures of aggregate signatur es in early literature are unsuitable for the current speciﬁcati ons of BGPsec. More precisely, when the original aggregate signatures [12], [23] are trivially deployed in BGPsec, eit her the capability for signature aggregation or security will b e lost . In contrast, APV AS can decrease the memory consumption as well as keep the security of BGPsec by the use of bimodal aggregate signatures (See Section IV for details).The second contribution is the implementation of a proto type of APV AS by extending BIRD Internet Routing Daemon (BIRD)1, which is a software that virtualizes a BGP router. The lack of experimental evaluation described in the previo us subsection is caused by the lack of evaluation tools for BG Psec. In contrast, we succeeded in measuring the performance of APVAS in an actual environment by leveraging BIRD. Although our experiment was conducted on a linear network in a simple fashion, as far as we aware this is the ﬁrst time tha t aggregate signatures are evaluated in an actual environmen t. Moreover, by extending our prototype, we can potentially evaluate protocols in future works (See Section VI for detai ls). We plan to release the prototype of APV AS to encourage development of BGPsec and future works. II. R ELATED WORKS "
434,A Trust Based Cross Layer Security Protocol for Mobile Ad hoc Networks.txt,"In this paper, we develop a trust based security protocol based on a cross
layer approach which attains confidentiality and authentication of packets in
both routing and link layers of MANETs. In the first phase of the protocol, we
design a trust based packet forwarding scheme for detecting and isolating the
malicious nodes using the routing layer information. It uses trust values to
favor packet forwarding by maintaining a trust counter for each node. A node is
punished or rewarded by decreasing or increasing the trust counter. If the
trust counter value falls below a trust threshold, the corresponding
intermediate node is marked as malicious. In the next phase of the protocol, we
provide link layer security using the CBCX mode of authentication and
encryption. By simulation results, we show that the proposed cross layer
security protocol achieves high packet delivery ratio while attaining low delay
and overhead.","A. Mobile Adhoc Networks  A mobile adhoc network (MANET) is a temporary  infrastructure less multihop wireless network in which the  nodes can move arbitrarily.  Such networks extend the limited  wireless transmission range of each node by multihop packet  forwarding, thus, well suited for the scenarios in which pre  deployed infrastructure support is not available. In an ad hoc  network, there is no fixed infrastructure such as base stations  or mobile switching centers. Mobile nodes that are within each  other’s radio range communicate directly via wireless links,  while those that are far apart rely on other nodes to relay  messages as routers. Node mobility in an ad hoc network  causes frequent changes of the network topology. Mobile ad  hoc networks are finding ever increasing applications in both  military and civilian scenarios due to their selforganizing,  selfconfiguring capabilities.   B. Security Threats in MANETS  An adhoc network can be attacked from any direction at  any node which is different from the fixed hardwired networks  with physical protection at firewall and gateways. Altogether  it denotes that every node should be equipped to meet an  attacker directly or indirectly.  Malicious attack can be initiated from both inside and  outside of the network. Tracking a specific node is difficult in large adhoc networks and hence, it is more dangerous and  much difficult to detect the attacks from an affected node.  Altogether it denotes that every node should be prepared to  work in a way that it should not trust on any node  immediately.    Distributed architecture should be applied in order to  achieve high availability. This is because if the central entity is  used in the security solution, it causes serious attack on the  entire network when the centralized entity gets affected.   The following are the types of active attacks and its  relevant solutions :  A. Black hole attack   Let H be a malicious node. When H receives a Route  Request, it sends back a Route Reply immediately, which  constructs the data and can be transmitted by itself with the  shortest path.  So S receives Route Reply and it is replaced by  H > S. Then H receives all the data from S.  B. Neighbor attack  The neighbor attack and the black hole attack prevent the  data from being delivered to the destination. But the neighbor  attacker does not catch and capture the data packets from the  source node. It leaves the settings as soon as sending the false  messages.   C. Wormhole attack  Two malicious nodes share a private communication link  between them. One node captures the traffic information of the  network and sends them directly to other node. Warm hole can  eavesdrop the traffic, maliciously drop the packets, and  perform manin themiddle attacks against the network  protocols. [6].        D. DoS (Denial of Service) attack  When the network bandwidth is hacked by a malicious  node [5], then it results to the DoS attack. In order to utilize  precious network resources like bandwidth, or to utilize node  resources like memory or computation power, the attacker  inserts packets into the network. The specific instances of the  DoS attack are the routing table overflow attack and energy  consumption attack.  E. Information Disclosure attack   The information disclosure attack aims at the privacy  requirements of network. The confidential information’s like  (IJCSIS) International Journal of Computer Science and Information Security,  Vol. 6, No. 1, 2009 165 http://sites.google.com/site/ijcsis/  ISSN 19475500routing location, node status or secret keys and password are  leaked out by the malicious node to the unauthorized nodes.   F. Rushing attack  The rushing attack aims against ondemand routing   protocols which uses identical suppression at each node. In  order to find routed to the destinations, the source nodes sends  out the RREQ. Each intermediate node processes only the first  nonduplicate packet and discards any duplicate packet which  arrives at a later time. Rushing attackers can forward these  packets quickly by skipping some of the routing processes.  They are also able gain access to the forwarding group [7].       G. Jellyfish attack  A malicious node receives and sends RREQ and RREP  normally. But before forwarding it delays the data packets  without any reason for some time [7]. Since the node has to  intrude the forwarding group first, it is difficult to implement  this type of attack. If the number of malicious node is few,  then the influence to the network is also less.  H. Byzantine attack  It is also called as impersonation attack because the  malicious node might imitate another normal node. It also  sends false routing information for creating an anomaly update  in the routing table. In addition to this, an attacker may get  unauthorized admission to resource and sensitive information.  I. Blackmail attack  This attack is applicable against routing protocols which  uses mechanisms for the recognition of malicious nodes and  broadcast the messages which try to blacklist the offender [8].  By adding other legitimate nodes to their blacklists, an  attacker might blackmail a legitimate node. Thus the nodes  can be avoided in those routes.  II. RELATED WORK  "
84,Throughput Analysis of IEEE 802.11 Multi-hop Wireless Networks with Routing Consideration: A General Framework.txt,"The end-to-end throughput of multi-hop communication in wireless ad hoc
networks is affected by the conflict between forwarding nodes. It has been
shown that sending more packets than maximum achievable end-to-end throughput
not only fails to increase throughput, but also decreases throughput owing to
high contention and collision. Accordingly, it is of crucial importance for a
source node to know the maximum end-to-end throughput. The end-to-end
throughput depends on multiple factors, such as physical layer limitations, MAC
protocol properties, routing policy and nodes distribution. There have been
many studies on analytical modeling of end-to-end throughput but none of them
has taken routing policy and nodes distribution as well as MAC layer altogether
into account. In this paper, the end-to-end throughput with perfect MAC layer
is obtained based on routing policy and nodes distribution in one and two
dimensional networks. Then, imperfections of IEEE 802:11 protocol is added to
the model to obtain precise value. An exhaustive simulation is also made to
validate the proposed models using NS2 simulator. Results show that if the
distribution to the next hop for a particular routing policy is known, our
methodology can obtain the maximum end-to-end throughput precisely.","Wireless ad hoc networks allow several nodes located outside of the transmission range of one another to communicate through intermediate nodes. Using a routing protocol, a source node can ﬁnd a path toward the destination. Nodes selected by the routing protocol are responsible for forwarding the source’s packets until they reach the destination. In a case that source and destination are in the transmission range of each other, no routing is required and consequently, maximum endtoend throughput is obtained by analyzing physical and Medium Access Control (MAC) layer properties. In multihop wireless communications, achievable throughput is signiﬁcantly lower than single hop communication due to the inevitable transmission overlap of consecutive forwarding nodes. Additionally, sending more packets than maximum achievable throughput degrades the endto end throughput even further. Hence, the knowledge about the maximum achievable throughput, which can be exploited by source nodes, considerably improves multihop communications. In the previous research [1]–[8], the analytical expression for maximum throughput was obtained for different scenarios. Nevertheless, all of these papers have assumed that all nodes placed equidistance apart in a straight line. In practice, wireless nodes are distributed randomly and it is highly unlikely to end up with this assumption. Additionally, even if all nodes do follow such a restriction, the routing protocol may choose nodes in a way that the assumption fails. Thus, it would not be a precise analysis if the endtoend throughput of multihop communication is obtained without the routing policy and node distribution. In this paper, node distribution and routing policy as well as MAC layer limitations are taken into consideration to obtain the precise value of endtoend throughput in multihop communication when there is a single ﬂow in the network. The geometry of randomly deployed wireless nodes is commonly modeled by a Poisson Point Process (PPP), since it is equivalent to placing each node uniformly in an ndimensional space. [9], [10]. Given a 1dimensional (1D) PPP, ﬁrst, we obtain the maximum endtoend throughput with perfect MAC and physical layer for two different routing policies including random neighbor routing and furthest neighbor routing. In perfect MAC and physical layer, it is assumed that a node has no negative effect on communications happening outside its interference range. Regardless of the existence of such physical layer and MAC protocol, this assumption avails us to capture the effect of node distribution and routing policy alone on the maximum endtoend throughput.THIS WORK HAS BEEN SUBMITTED TO THE IEEE TRANSACTIONS ON COMMUNICATIONS (TCOM) FOR POSSIBLE PUBLICATION.3 Second, we analyze the effect of routing policy and node distribution on IEEE 802:11MAC protocol and extend our analysis to capture the effects of MAC layer limitations. Although the formulas we obtained here are conﬁrmed by simulation and are useful for theoretical analysis, they are too complicated to be used in wireless nodes. Therefore, we provide a simple way to approximate these formulas so that a source node can use them for ﬂow and admission control. Third, we obtain some promising approximation formulas for maximum endtoend throughput in2D networks which is validated by simulations. Our methodology can be used for any routing policy and node distribution as long as the ﬁrst and second moments of the distribution of distance between two consecutive nodes in a path is known. To the best of our knowledge, it is the ﬁrst analytical results about maximum throughput in 2D multihop wireless networks when IEEE 802.11 is used alongside furthest and random neighbor routing. One direct application of our results resides within the domain of protocol design. For instance, protocols, such as TCP, have inherent ﬂow and congestion control. However, their performance is not near optimum as a result of increasing window size more than optimum value [14]. Knowing the maximum achievable throughput can be directly used in protocol design. It can also be used for layer 2 protocol design. Given that the maximum throughput of multihop communication is less than singlehop communication, the maximum multihop throughput can be used to design layer 2 protocols that avoid greedily sending at the rate of singlehop throughput which contributes to congestion and consequently degrade multihop communication throughput. The remainder of this paper is organized as follows. In section II, we brieﬂy present related works in this area. Section III obtains endtoend throughput with perfect MAC and physical layer in 1D networks. Section IV considers the limitation of lower layers and obtains end toend throughput for IEEE 802.11. Section V obtains an approximate formula for endtoend throughput which is simple enough to be used in wireless nodes. While it seems impossible to obtain an exact formula for maximum throughput in 2D networks, some approximations are given in Section VI. A comprehensive performance evaluation is carried out in Section VII. Finally, Section VIII concludes our work. II. R ELATED WORK "
390,Impact of Mobility on the Performance of Multicast Routing Protocols in MANET.txt,"The advent of ubiquitous computing and the proliferation of portable
computing devices have raised the importance of mobile ad-hoc network. A major
challenge lies in adapting multicast communication into such environments where
mobility and link failures are inevitable. The purpose of this paper is to
study impact of mobility models in performance of multicast routing protocols
in MANET. In this work, three widely used mobility models such as Random Way
Point, Reference Point Group and Manhattan mobility models and three popular
multicast routing protocols such as On-Demand Multicast Routing Protocol,
Multicast Ad hoc On-demand Distance Vector Routing protocol and Adaptive Demand
driven Multicast Routing protocol have been chosen and implemented in NS2.
Several experiments have been carried out to study the relative strengths,
weakness and applicability of multicast protocols to these mobility models.","Mobile ad hoc networks (MANETs) are selforganizing networks that do not require a fixed  infrastructure. Two nodes communicate directly if they are in the transmission range of each other.  Otherwise, they reach via a multihop route. Each MANET node must therefore be able to func tion as a router to forward data packets on behalf of other nodes [1]. Because of their unique  benefits and versatilities, MANETs have a wide range of applications such as collaborative,  distributed mobile computing (e.g., sensors, conferences), disaster relief (e.g., flood, earthquake),  war front activities and communication between automobiles on highways. Most of these applications  demand multicast or group communication.   Each of these applications can potentially involve in different scenarios with different mobility  patterns, traffic rates dependent on the environment and the nature of the interactions among the  participants. In order to thoroughly study the protocols for these applications, it is imperative to  use the mobility models that accurately represent the mobile nodes which utilize the protocols.  In this paper, it is proposed to analyze the performances of widely used multicast routing  protocols namely Multicast Ad hoc Ondemand Distance Vector (MAODV) routing protocol [2,  3], OnDemand Multicast Routing Protocol (ODMRP) [4, 5] and Adaptive Demand driven  Multicast Routing protocol (ADMR) [6] against three different mobility model that characterize  the realistic behaviours such as Random Waypoint, Reference Point Group and Manhattan  mobility models.   Rest of the paper is organized as follows: Section 2 reviews the related work. Section 3  summarizes the Mobility Models that are considered in this paper. Section 4 explains the  multicast protocols while Section 5 explains the experimental scenarios and methodology.  Section 6 deals with experimental results. Finally, concluding remarks are given in section 7.   	 	  	  	   	     111   2. RELATED WORK  "
21,Automated Analysis of AODV using UPPAAL.txt,"This paper describes an automated, formal and rigorous analysis of the Ad hoc
On-Demand Distance Vector (AODV) routing protocol, a popular protocol used in
wireless mesh networks.
  We give a brief overview of a model of AODV implemented in the UPPAAL model
checker. It is derived from a process-algebraic model which reflects precisely
the intention of AODV and accurately captures the protocol specification.
Furthermore, we describe experiments carried out to explore AODV's behaviour in
all network topologies up to 5 nodes. We were able to automatically locate
problematic and undesirable behaviours. This is in particular useful to
discover protocol limitations and to develop improved variants. This use of
model checking as a diagnostic tool complements other formal-methods-based
protocol modelling and verification techniques, such as process algebra.","Route nding and maintenance are critical for the performance of networked sys tems, particularly when mobility can lead to highly dynamic and unpredictable environments; such operating contexts are typical in wireless mesh networks (WMNs). Hence correctness and good performance are strong requirements of routing algorithms. The Ad hoc OnDemand Distance Vector (AODV) routing protocol [12] is a widely used routing protocol designed for WMNs and mobile ad hoc networks (MANETs). It is one of the four protocols dened in an RFC (Request for Comments) document by the IETF MANET working group. AODV also forms the basis of new WMN routing protocols, like the upcoming IEEE 802.11s wireless mesh network standard [8]. Usually, routing protocols are optimised to achieve key objectives such as providing selforganising capability, overall reliability and performance in typical network scenarios. Additionally, it is important to guarantee protocol properties such as loop freedom for allscenarios, including nontypical, unanticipated ones. This is particularly relevant for highly dynamic MANETs and WMNs. The traditional approaches for the analysis of MANET and WMN routing protocols are simulation and testbed experiments. While these are important ?First steps towards this analysis appeared in [6].2 Fehnker, van Glabbeek, H ofner, McIver, Portmann & Tan and valid methods for protocol evaluation, there are limitations: they are re source intensive and timeconsuming. The challenges of extensive experimental evaluation are illustrated by recent discoveries of limitations of protocols that have been under intense scrutiny over many years. An example is [10]. We believe that formal methods in general and model checking in particular can help in this regard. Model checking is a powerful method that can be used to validate key correctness properties in nite representations of a formal system model. In the case that a property is found not to hold, the model checker produces evidence for the fault in the form of a \counterexample"" summarising the circumstances leading to it. Such diagnostic information provides important insights into the cause and correction of these failures. In [5], we specied the AODV routing protocol in the process algebra AWN. The specication follows wellknown programming constructs and lends itself well for comparison with the original specication of the protocol in English. Based on such a comparison we believe that the AWN model provides a com plete and accurate formal specication of the core functionality of AODV. In developing the formal specication, we discovered a number of ambiguities in the IETF RFC [12]. Our process algebraic formalisation captures these by sev eral interpretations, each with slightly dierent AWN code. In this paper we follow an interpretation of the RFC, which we believe to be the closest to the spirit of the AODV routing protocol. We show how to obtain executable versions of this AWN specication, in the language of the UPPAAL model checker [1,9]. By deriving the UPPAAL model from the AWN model, the accuracy of the AWN model is transferred to the UPPAAL model. The executable UPPAAL model is used to conrm and discover the presence of undesirable behaviour. We check important properties against all topologies of up to 5 nodes, which also includes dynamic topologies with one link going up or down. This exhaustive search conrmed known and revealed new problems of AODV, and let us quantify in how many topologies a particular error can occur. Subsequently, the same experiments for modications of AODV showed the pro posed modications can all but eliminate certain problems for static topologies, and signicantly reduce them for dynamic topologies. The automated analysis of routing protocols presented in this paper combined with formal reasoning in AWN provides a powerful tool for the development and rigorous evaluation of new protocols and variations, and improvements of existing ones. 2 Ad hoc OnDemand Distance Vector Routing Protocol 2.1 The Basic routine AODV [12] is a widely used routing protocol designed for WMNs and MANETs. It is a reactive routing protocol, where the route between a source and a desti nation node is established on an ondemand basis. A route discovery process is initiated when a source node shas data to send to a destination node d, but has no valid corresponding routing table entry. In this case, node sbroadcasts a routeAutomated Analysis of AODV using UPPAAL 3 (a) d bsa (b) d bsa RREQ RREQRREQ RREQ RREQ RREQ (c) d bsa RREP RREP Fig. 1. Example network topology request (RREQ) message in the network. The RREQ message is rebroadcast and forwarded by other intermediate nodes in the network, until it reaches the destination node d(or an intermediate node that has a valid route to node d). Every node that receives the RREQ message will create a routing table entry to establish a reverse route back to node s. In response to the RREQ message, the destination node d(or an intermediate node that has a valid route to node d) unicasts a route reply (RREP) message back along the previously established reverse route. At the end of this route discovery process, an endtoend route between the source node sand destination node dis established. Usually, all nodes on this route have a routing table entry to both the source node sand destination node d. An example topology, indicating which nodes are in trans mission range of each other, as well as the  ow of RREQ and RREP messages, is given in Figure 1. In the event of link and route breaks, AODV uses route error (RERR) messages to inform aected nodes. Sequence numbers are another important aspect of AODV, and are used to indicate the freshness of routing table entries for the purpose of preventing routing loops. 2.2 Process Algebraic Model of AODV The process algebra AWN [4,5] has been developed specically for modelling WMN routing protocols. It is designed in a way to be easily readable and treats three necessary features of WMNs protocols: data structures ,local broadcast , and conditional unicast . Data structures are used to model routing tables etc.; local broadcast models message sending to alldirectly connected nodes; and condi tional unicast models the message sending to one particular node and chooses a continuation process dependent on whether the message is successfully delivered. In AWN, delivery of broadcast messages is \guaranteed"", i.e., they are re ceived by any neighbour that is directly connected. The abstraction to a guar anteed broadcast enables us to interpret a failure of message delivery (under assumptions on the network topology) as an imperfection in the protocol, rather than as a consequence of unreliable communication. Section 4.3, for example, describes a simple network topology and a scenario for which AODV fails to discover a route, even if broadcast is guaranteed. The failure is a shortcoming of the protocol itself, and cannot be excused by unreliable communication. Conditional unicast models an abstraction of an acknowledgmentofreceipt mechanism that is typical for unicast communication but absent in broadcast communication, as implemented by the link layer of relevant wireless standards4 Fehnker, van Glabbeek, H ofner, McIver, Portmann & Tan such as IEEE 802.11. The AWN model captures the bifurcation depending on the success of the unicast, while abstracting from all implementation details. In [5], we used AWN to model AODV according to the IETF RFC [12]. The model captures all core functionalities as well as the interface to higher protocol layers via the injection and delivery of application layer data, and the forwarding of data packets at intermediate nodes. Although the latter is not part of the AODV protocol specication, it is necessary for a practical model of any reactive routing protocol where protocol activity is triggered via the sending and forwarding of data packets. In addition, our model contains neither ambiguities nor contradictions, both of which are often present in specications written in natural languages, such as in the RFC3561 (see e.g. [5]). The AWN model of AODV contains a main process, called AODV , for every node of the network, which handles messages received and calls the appropriate process to handle them. The process also handles the forwarding of any queued data packet if a valid route to its destination is known. Four other processes handle one particular message type each, like RREQ. The network as a whole is modelled as a parallel composition of these processes. Special primitives allow us to express whether two nodes are connected. Full details of the process algebra description on which our UPPAAL model is based can be found in [5]. 3 Modelling AODV in UPPAAL UPPAAL [1,9] is an established model checker for networks of timed automata , used in particular for protocol verication. We use UPPAAL for the following reasons: (1) UPPAAL provides two synchronisation mechanisms|binary and broadcast synchronisation, which translate to uni and broadcast communica tion; (2) it provides common data structures, such as arrays and structs, and a Clike programming language to dene updates on these data structures; (3) in the future, AWN (and therefore also our models) will be extended with time and probability|UPPAAL provides mechanisms and tools for both. Our processalgebraic model of AODV has been used to prove essential prop erties, such as loop freedom for popular interpretations of [12]|independent of a particular topology. The UPPAAL model is derived from the AWN specication that comes closest to the spirit of the AODV routing protocol. Section 3.2 explains the translation and the simplifying assumptions in detail. 3.1 UPPAAL Automata Since our models do not yet use time (or probabilities) they are simply networks of automata with guards. The state of the system is determined, in part, by the values of data variables that can be either shared between automata, or local. We assume a data structure with several types, variables ranging over these types, operators and predicates. Common Boolean and arithmetic expressions are used to denote data values and statements about them.Automated Analysis of AODV using UPPAAL 5 Each automaton is a graph, with locations, and edges between locations. Every edge has a guard, optionally a synchronisation label, and an update. Syn chronisation occurs via socalled channels; for each channel athere is one label a! to denote the sender, and a? to denote the receiver. Transitions without labels are internal; all other transitions use one of two types of synchronisation. Inbinary handshake synchronisation, one automaton having an edge with a label that has the sux ! synchronises with another automaton with an edge having the same label that has a ?sux. These two transitions synchronise when both guards are true in the current state, and only then. When the transition is taken both locations change, and the updates will be applied to the state vari ables; rst the updates on the !edge, then the updates on the ?edge. If there is more than one possible pair, then the transition is selected nondeterministically. Inbroadcast synchronisation, one automaton with a !labelled edge synchro nises with a set of other automata that all have an edge with a matching ?label. The initiating automaton can change its location, and apply its update, if the guard on its edge evaluates to true. It does not require a second synchronising automaton. Automata with a matching ?labelled edge have to synchronise if their guard is currently true. They change their location and update the state. The automaton with the !edge will update the state rst, followed by the other automata in some lexicographic order. If more than one automaton can initiate a transition on an !edge, the choice will be made nondeterministically. 3.2 From AWN to UPPAAL Every node in the network is modelled as a single automaton, each having its own data structures such as a routing table and message buer. The implementation of the data structure dened in AWN is straightforward, since both AWN and UPPAAL allow Cstyle data structures. A routing table rtfor example is an array of entries, one entry for every node. An entry is given by the data type typedef struct { SQN dsn; //destination sequence number bool flag; //validity of a routing table entry int hops; //distance (hop count) to the destination IP nhop; //next hop (is 0 if no route) } rtentry; where SQNdenotes a data type for sequence numbers and IPdenotes one for all IP address. In our model, these types are mapped to integers. The local message buer is modelled as an array msglocal . UPPAAL will warn if during model checking an outofbounds error occurs, i.e., if the array was too small. Each message is a struct with elds msgtype which can take values PKT,RREQ ,RREP , or RERR , integer hops for the distance from the orig inator of the message, sequence number rreqid to identify a route request, a destination IP dip, a destination sequence number dsn, an originator IP oip, an originator sequence number osn, and a sender IP sip. The model contains functions addmsg ,deletemsg andnextmsg , to add a message, delete a message, or to return the type of the next message in the buer.6 Fehnker, van Glabbeek, H ofner, McIver, Portmann & Tan Table 1 Excerpt of AWN spec for AODV. A few cases for RREQ handling. AODV(ip,sn,rt,rreqs ,store )def= 1./*depending on the message on top of the message queue, the node calls dierent processes*/ 2.: : : 3.[msg=rreq(hops ;rreqid ;dip;dsn;oip;osn;sip)^(oip;rreqid )2rreqs ] 4. /*silently ignore RREQ, i.e. do nothing, except update the entry for the sender*/ 5. [ [rt:=update (rt;(sip;0;val;1;sip))] ]. /*update the route to sip*/ 6. AODV(ip,sn,rt,rreqs ,store ) 7.+[msg=rreq(hops ;rreqid ;dip;dsn;oip;osn;sip)^(oip;rreqid )62rreqs )^dip=ip] 8. /*answer the RREQ with a RREP*/ 9. [ [rt:=update (rt;(oip;osn;val;hops+ 1;sip))] ]/*update the routing table*/ 10. [ [rreqs :=rreqs[ f(oip;rreqid )g] ]/*update the array of already seen RREQ*/ 11. [ [sn:= max( sn;dsn)] ]/*update the sqn of ip*/ 12. [ [rt:=update (rt;(sip;0;val;1;sip))] ]/*update the route to sip*/ 13. unicast (nhop(rt,oip),rrep(0,dip,sn,oip,ip)) . 14. AODV(ip,sn,rt,rreqs ,store ) 15.+[msg=rreq(hops ;rreqid ;dip;dsn;oip;osn;sip)^(oip;rreqid )62rreqs )^dip6=ip^ (dip62vD(rt)_sqn(rt;dip)<dsn_sqnf(rt;dip) =unk)] 16. /*forward RREQ*/ 17. [ [rt:=update (rt;(oip;osn;val;hops+ 1;sip))] ]/*update routing table*/ 18. [ [rreqs :=rreqs[ f(oip;rreqid )g] ]/*update the array of already seen RREQ*/ 19. [ [rt:=update (rt;(sip;0;val;1;sip))] ]/*update the route to the sender*/ 20. broadcast (rreq(hops+ 1, rreqid ,dip,max( sqn(rt;dip);dsn),oip,osn,ip)) . 21. AODV(ip,sn,rt,rreqs ,store ) 22.+[rreq(hops ;rreqid ;dip;dsn;oip;osn;sip)^: : :] 23. : : : Connections between nodes are determined by a connectivity graph , which is specied by a Booleanvalued function isconnected . This graph presents one particular topology and is not derived from our AWN specication, since the specication is valid for alltopologies. Communication is modelled as an atomic synchronised transition between a sender, on an !edge, with a receiver, on a matching ?edge. The guard of the sender depends on local data, e.g. buer and routing table, while the guard of the receiver is isconnected . This means that in broadcast communication the sender will take the transition regardless of isconnected , while disconnected nodes will not synchronise. In unicast commu nication the transition is blocked if the intended recipient is not connected, but there is a matching broadcast transition that sends an error message in this case. When the transition is taken, the sender copies its message to a global variable msgglobal , and the receiver copies it subsequently to its local buer msglocal . AODV uses unicast for RREP and PKT messages, and broadcast for RERR and RREQ messages. To model unicast, the UPPAAL model has one binary handshake channel for every pair of nodes. For example, rrep[i][j] is used for transitions modelling the sending of a route reply from node itoj. To model broadcast, we use one broadcast channel for every node. For example, rreq[i] is used for the route requests of node i. To model new packets from itoj, generated by the user layer, the model contains a channel newpkt[i][j] . The AWN model of Table 1 is an excerpt of the AODV specication presented in [5]|the full specication and a detailed explanation can be found there. The excerpt presented here diers slightly from the original model:1(1) we abstract 1It can be shown that the model presented here behaves identical to the AWN model in [4]; in other words, they are behavioural equivalent.Automated Analysis of AODV using UPPAAL 7 Table 2 Excerpt of UPPAAL model. A few cases for RREQ handling. 1.: : : 2.aodv > aodv { 3.guard nextmsg()==RREQ && rreqs[msglocal[0].oip][msglocal[0].rreqid]; 4.sync tau[ip]?; 5.assign sipupdate(), deletemsg(); }, 6.aodv > aodv { 7.guard nextmsg()==RREQ&&!rreqs[msglocal[0].oip][msglocal[0].rreqid]&&msglocal[0].dip==ip; 8.sync rrep[ip][oipnhop()]!; 9.assign updatert(msglocal[0].oip,msglocal[0].osn,1,msglocal[0].hops+1,msglocal[0].sip), 10. rreqs[msglocal[0].oip][msglocal[0].rreqid]=1, 11. sn=max(sn,msglocal[0].dsn), 12. sipupdate(), 13. msgglobal=createrep(0,msglocal[0].dip,sn,msglocal[0].oip,ip), deletemsg(); }, 14.aodv > aodv { 15.guard nextmsg()==RREQ&&!rreqs[msglocal[0].oip][msglocal[0].rreqid]&&msglocal[0].dip!=ip && (!rt[msglocal[0].dip].flag || msglocal[0].dsn>rt[msglocal[0].dip].dsn || rt[msglocal[0].dip].dsn==0); 16.sync rreq[ip]!; 17.assign updatert(msglocal[0].oip,msglocal[0].osn,1,msglocal[0].hops+1,msglocal[0].sip), 18. rreqs[msglocal[0].oip][msglocal[0].rreqid]=1, 19. sipupdate(), 20. msgglobal=createreq(msglocal[0].hops+1,msglocal[0].rreqid,msglocal[0].dip, max(msglocal[0].dsn, rt[msglocal[0].dip].dsn),msglocal[0].oip,msglocal[0].osn,ip), 21. deletemsg(); }, 22.: : : from precursors , an additional data structure that is maintained by AODV (2) the model in [5] uses 6 dierent processes; here processes are inlined into the body of the main AODV process. This reduces the number of processes to one and yields an automaton with one control location; (3) the model in [5] uses nesting of conditions and updates, while this model has been  attened to correspond more closely with the limitations of the UPPAAL syntax|in UPPAAL the guards are evaluated before any update, AWN has no such restriction. Table 1 depicts three of the cases in the AWN model for handling route re quests. In each, a condition is checked, the routing tables and local data are up dated, and it returns to the main AODV process AODV (ip;sn;rt;rreqs;store ). Table 2 shows the corresponding edges from the UPPAAL model, one edge for every case. Like the AWN model, which goes from the process AODV toAODV , the UPPAAL model will go from control location aodv to itself (Lines 2, 6 and 14). Each edge evaluates a guard in Lines 3, 7 and 15 in Table 2. These line num bers, and the line numbers mentioned in the remainder of this section correspond to the same line number in Table 1. Whenever the AWN specication uses set membership (( oip;rreqid )2rreqs ), the UPPAAL model uses a 2dimensional Boolean array rreqs to encode membership; whenever the AWN model uses a  ag to denote a known sequence number ( sqnf (rt;dip)=unk), the UPPAAL model compares with a distinguished value ( rt[msglocal[0].dip].dsn==0 ). Depending on whether a case requires no transmission, unicast, or broadcast, the UPPAAL model synchronises on a tau, a binary, or a broadcast channel (Lines 4, 8 and 16). The tauchannel for internal transitions allows for optimi sations; it could have been left empty. We discuss this later in this section. After synchronisation the state is updated. For all route request messages we update the routing table for the sender sip(Lines 5, 12 and 19). The fact that8 Fehnker, van Glabbeek, H ofner, McIver, Portmann & Tan the message was received means that sender sipis one hop away. Except for the rst case (Lines 4) the routing table is updated (Lines 9 and 17), and the route request is added to the set of processed route requests (Lines 10 and 18). In case that a node receives a request, and it is the destination, it increments its sequence number, if necessary (Line 11), before it sends a route reply. The last two steps in the UPPAAL model that complete a transmission rst create a new message and copy it to the global variable msgglobal (Lines 13 and 20), and then delete the rst element of the local message buer. In the AWN model, these steps are part of the communication primitives. The full UPPAAL models a node by an automaton with one control location and 26 edges: 19 cases for processing the dierent routing messages, four cases for receiving routing messages|one case for each type|two cases for sending data packets, and one case for handling new data packets. The case distinction is complete, i.e at least one transition is enabled and process messages if the buers and queues are not empty. Both the UPPAAL and the AWN model maintain a FIFO buer for incoming messages. Any newly generated message only depends on the content of messages previously received. This implies that the timing of internal transitions that discard incoming messages is not relevant for route discovery. The UPPAAL model exploits this fact and assigns a higher priority to internal transitions. To implement priorities we labelled those transitions tau. This is is an eective measure to reduce the state space, at the expense that UPPAAL is now unable to check liveness properties; for this paper this is not a limitation, as all properties can be expressed as safety properties. 4 Experiments Our automated analysis of AODV considers 3 properties that relate to \route discovery"" for all topologies up to 5 nodes, with up to one topology change, and scenarios with two new data packets. 4.1 Scenarios and Topologies The experiments consider scenarios with two initial data packets in networks with up to 5 nodes. Initially all routing tables and buers are empty. The origi nator and the destination of the data packets are identied as nodes A,B, orC. The new data packets may arrive as depicted in Figure 2. In the rst scenario a packet from AtoBis followed by a packet from AtoC; in the second a packet from BtoAby a packet from CtoA; in the third a packet from A toBby a packet from BtoC; and in the nal scenario a packet from Bto Cby a packet from AtoB. The originator of the rst new packet initiates a route discovery process rst, the originator of the second nondeterministically after the rst. The dierent scenarios are implemented by a simple automaton, tester . Since the dierent topologies cover all possible permutations, these fourAutomated Analysis of AODV using UPPAAL 9 A B C newpkt[A][B] newpkt[A][C] A B C newpkt[B][A] newpkt[C][A] A B C newpkt[A][B] newpkt[B][C] A B C newpkt[B][C] newpkt[A][B] Fig. 2. Sequence charts illustrating four scenarios for initiating two route requests. scenarios cover all scenarios for injecting two new packets with either dierent originators or dierent destinations. Additional to A,BandC, we add up to two nodes that may relay messages, but do not create data packets themselves. We consider only topologies in which nodesA,BandCare connected, either directly, or indirectly. This ensures that the route discovery is at least theoretically possible. If it fails, then it won't be because the nodes are not connected, but due to failure of the protocol. We consider three classes of topologies. The rst class are static topologies. Given the constraints that node A,BandCare connected, and that there are at most 5 nodes, this gives 444 topologies, after topologies that are identical up to symmetries are removed. The second class considers pairs of topologies from the rst class, in which the second topology can be obtained by adding a new link. This models a dynamic topology in which a link is added. There are 1978 such pairs. The third class considers the same pairs, but now moves from the second topology to the rst. This models a link break. Note that after deletion, nodes A,BandCare still connected. In our UPPAAL model a change of topology is modelled by another automaton. It may add or remove a link exactly once, nondeterministically, after the rst route request arrives at the destination. 4.2 Properties This paper considers three desirable properties of any routing protocol such as AODV. The rst property is that once all routing messages have been processed a route from the originator to the destination has been found. In UPPAAL syntax this safety property can be expressed as: A[ ]((tester.final && emptybuffers()) imply (node(OIP).rt[DIP].nhop!=0))(1) The CTL formula A[]is satised if holds on all states along all paths. The variable node(OIP).rt models the routing table of the originator node OIP, and the eld node(OIP).rt[DIP] .nhop represents the next hop for destination DIP. All initiated requests will have been made, i automaton tester is in location final , the message buers are empty i function emptybuffers returns true, and the originator OIPhas a route to node DIPinode(OIP).rt[DIP].nhop!=0 . The second property is related, namely that once all messages are processed, then no suboptimal route has been found. Here, suboptimal means that the10 Fehnker, van Glabbeek, H ofner, McIver, Portmann & Tan number of hops is greater than the shortest path. In case that the topology changes, we take the greater distance. In UPPAAL this can be expressed as A[ ]((tester.final && emptybuffers()) imply (node(OIP).rt[DIP].hops<=distance[OIP][DIP]))(2) Here, the array distance encodes the distance matrix. Note, that this fails if the route at the end is suboptimal. It does not fail if at the end, either an optimal, or no route has been found. If the rst two properties are satised, it means that it is guaranteed that an optimal route will be found when all messages have been processed. Note that it is known that AODV does not guarantee that optimal routes will be found. Nevertheless, an implementation or modication of AODV can be said to perform better if this property fails for fewer topologies. The third property is even stronger than the second, namely that no sub optimal routes will be found at all. It does not hold if a better optimal route replaces a suboptimal route that was found rst. A[ ](node(OIP).rt[DIP].hops<=distance[OIP][DIP]) (3) If the third property holds, then the second must hold as well. In the experiments we will check all three properties for both originatordestination pairs at once. 4.3 Modications The basic UPPAAL model is based on the process algebraic AWN model, which re ects a common interpretation of the RFC with all ambiguities resolved. It is known that AODV does not guarantee that optimal routes will be found, or even any routes at all [6,10].2Our experiments quantify how many topologies are aected by these problems, and also what impact slight modications of the protocol have. We will refer to the basic model as model 1 , and discuss three proposed variants of AODV. Forwarding all route replies. It is a known problem that nodes drop route reply messages under certain conditions.3During our experiments we found this problem even in the smallest topology, a static linear topology with only three nodes, and only two links: node Ais connected to node BandBto nodeC. Both nodeBandCinitiate a route request to A. For this topology and scenario, UPPAAL nds a counterexample for Property (1), i.e., it is possible that no route will been found when all messages have been processed. Fig. 3 depicts a message sequence chart of the relevant part of the counterex ample. Initially, both BandCinitiate a route request for A. We refer to the rst request as BArequest, and to the second as CArequest. First, node Bsends theBArequest to AandC(Step 1 in Fig. 3), then node CitsCArequest to 2AODV proposes to repeat the route discovery process if the rst discovery process fails. However, this solution does not solve the problems entirely (see [5]). 3This problem has already been raised on the MANET mailing list in Oct 2004 (http://www.ietf.org/mailarchive/web/manet/current/msg05702.html ).Automated Analysis of AODV using UPPAAL 11 A B C 1 2 3 4 5 6 7 8 9 10aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodv aodvrreq[B]BArreq[B]BA rreq[C]CA rreq[B] rreq[B]CA CA rreq[C]BA rrep[A][B]BA rrep[A][B]CA Fig. 3. Message sequence chart illustrating failed route discovery. Wide vertical lines mean that local states do not change in this transition. The superscripts indicate the corresponding originator and destination of the route discovery process. B(Step 2). Node Bforwards the CArequest (Step 3), node CtheBArequest (Step 4). Node Cwill correctly ignore the CArequest that it received from B, since it is the originator (Step 5). Similarly, Bwill ignore the BArequest (Step 6). Node Awill then reply to the BArequest (Step 7), and node Bwill update its routing table (Step 8) to include a route to A. NodeAwill also reply to the CArequest (Step 9), but Bwill ignore this message (Step 10), since it does not contain new information for B. NodeA's reply to the CArequest will not arrive at C. The discarding of the RREP message happens according to the RFC spec ication of AODV [12]. It states that an intermediate node only forwards the RREP message if it is not the originator node andit uses the RREP to update its route entry to the destination. In this case, node Bis not the originator, but it also did not use the route reply to update its route. It already had an optimal route, as a result of the BArequest. This type of problem can arise whenever one node has to relay multiple route requests for the same destination. A possible solution would be to forward every reply received by a node. Our model 2 implements this change. Obviously, this increases the number of control messages generated during route discovery. However, this is compensated by the reduced need to repeat sending the route request in case no route has been found, the solution proposed by AODV.4In the experiment section we will see that this modication eectively addresses the problem. Replying to improving requests. Counterexamples found by UPPAAL show that a source for suboptimal routes is the property of AODV to only reply to the 4Moreover, a repeated route request need not be any more successful than the rst.12 Fehnker, van Glabbeek, H ofner, McIver, Portmann & Tan rst route request. All subsequent requests with the same request ID ( rreqid ) will be ignored (Line 3 of Tables 1 and 2), even if the subsequent requests arrived via a shorter route. Model 3 modies the rule for the handling of route requests. It will not only reply to the rst request, but also to a subsequent request (with the same request ID) with an improved hop count. Recovering from failed replies. Analysis of UPPAAL's counterexamples show that a main reason for failed route discovery is that a node marks a request as having been replied to, even if the node detected the reply failed due to the link being broken in the time between the received request and the sent reply. The node will ignore other requests with the same request ID that may arrive later. Model 4 introduces two changes: it does not mark a request as seen if the reply fails, and it replies to other requests in the same route discovery process. This change should be considered with care, since it changes the rules with respect to sequence numbers. These numbers are an essential part of AODV be ing loop free, and there is currently no guarantee that this change will not violate some essential invariants of the proof [5]. We included the results nevertheless, as they show that there is still signicant potential to improve AODV. 4.4 Experimental Results The experimental results tell for how many topologies UPPAAL could show the absence of counterexamples, and thus allow quantication of the impact of improvements. However, the analysis uses a nondeterministic model, rather than a probabilistic model. For each topology it is reported whether a counterexample exists, but not how likely it is to occur. Neither can we assume that the topologies themselves are randomly distributed. Depending on the application only certain types of topologies might occur in practice. Nevertheless, it is fair to assume that a modication that leads to fewer topologies with counterexamples constitutes an improvement w.r.t. the considered property. Table 3 presents the results of the experiments. Most relevant for all classes of topologies are Property (1), a route is found, Property (2), no suboptimal route is found in the end, and the combination of these, i.e., an optimal route is found. The results demonstrate that the problem of ignoring route replies as de scribed in Figure 3 occurs even for about 50% of all static topologies. Model 1 satises Property (2) only for half of all static topologies. The proposed modi cation solves this problem entirely for static topologies. The other modications further improve the quality of the routes; in 99 :1% of static topologies Prop erty (2) holds, i.e., the route was in the end always optimal. The slight drop in Property (3) is explained by the fact that in a few cases, where no route was found at all for model 1 , a suboptimal route was found in the other models. The results for static topologies are roughly repeated if we consider topologies in which a link is added. There were a few surprising instances though, in which adding a link was instrumental in nding a suboptimal route.Automated Analysis of AODV using UPPAAL 13 Property (1) Property (2) Property (3) Property (1) & (2) all propertiesstaticmodel 1 52.7% 93.2% 50.7% 50.0% 13.5% model 2 100.0% 93.2% 47.5% 93.2% 47.5% model 3 100.0% 99.1% 47.5% 99.1% 47.5% model 4 100.0% 99.1% 47.5% 99.1% 47.5% Property (1) Property (2) Property (3) Property (1) & (2) all propertiesadd linkmodel 1 57.5% 90.8% 49.1% 53.3% 18.1% model 2 100.0% 90.6% 46.2% 90.6% 46.2% model 3 100.0% 97.8% 46.2% 97.8% 46.2% model 4 100.0% 96.3% 46.2% 96.3% 46.2% Property (1) Property (2) Property (3) Property (1) & (2) all propertiesremove linkmodel 1 26.7% 90.5% 59.7% 26.2% 6.0% model 2 53.0% 89.4% 57.1% 51.2% 28.9% model 3 53.0% 93.1% 57.1% 52.8% 28.9% model 4 75.4% 94.0% 54.0% 73.8% 41.0% Table 3. Model checking result for the four models and three classes of topologies. It gives the percentage of topologies for which there exists no counterexample. The results are, as expected, not quite as positive if a link gets removed. For the baseline model it is only guaranteed for one quarter of all topologies that a route will be found. Relaying all route replies, and not marking requests if the reply fails, improves this result. For three quarters of all topologies in which a link was removed it was shown that an optimal route will be found. The main reason of the failures that remain is that a route reply might get lost because of some intermediate link break on the path back to the destination. A possible solution to this problem could be to maintain a set of backup routes, or to implement dierent error responses. However, this requires a signicant change and fundamentally changes the characteristics of AODV. For the experiments we used an Intel Core2 CPU 2.13GHz processor with 2GB internal memory, running Ubuntu 11.04. We used UPPAAL 4.0.13. Of each of the models described in this section, we checked 17600 instances, altogether 70400 instances. As indication of the state space and runtimes, we checked an invariant on all instances of model 4 for a topology in which a link is removed. These instances have larger state spaces than others, since these scenario have also to trigger the transitions for error handling. The models have an average of 9400 states, the largest model has 475000 states, and the median is 2700. Exploring these state spaces took on average 1 :73 seconds user time, at most 81 seconds, and the median was 0 :57. These run times show that an automated, systematic and rigorous analysis of reasonable rich routing protocols is feasible. 5 Related Work "
15,Simple and Fast Distributed Computation of Betweenness Centrality.txt,"Betweenness centrality is a graph parameter that has been successfully
applied to network analysis. In the context of computer networks, it was
considered for various objectives, ranging from routing to service placement.
However, as observed by Maccari et al. [INFOCOM 2018], research on betweenness
centrality for improving protocols was hampered by the lack of a usable, fully
distributed algorithm for computing this parameter. We resolve this issue by
designing an efficient algorithm for computing betweenness centrality, which
can be implemented by minimal modifications to any distance-vector routing
protocol based on Bellman-Ford. The convergence time of our implementation is
shown to be proportional to the diameter of the network","Betweenness centrality [15] is a measure of \importance"" attributed to every node of a graph. Roughly, the betweenness centrality of a node vis the sum, taken over all pairs ( s;t) of source target nodes, of the ratio between the number of shortest paths from stotpassing through v, and the total number of shortest paths from stot. Thus, a node with high betweenness centrality belongs to relatively many shortest paths, while a node with low betweenness centrality belongs to relatively few shortest paths. Betweenness centrality has been successfully applied to network analysis: In social networks, a node with high betweenness centrality is plausibly an in uential node; in computer networks, a node with high betweenness centrality might be eciently used for storing relevant resources, but may also cause severe damage to the communications in case of failure or malfunction. Consequently, betweenness centrality and its variants have been used for optimizing the behavior of communication networks and computer networks [30], whether it is for wireless mesh networks design [29], routing [13], linksensing [36], resource placement [42] and allocation [54], topology control [50], transmission rates optimization [4], or security [35]. For instance, the optimal frequency at which the incident links must be sensed at each node is known to be inversely proportional to the square root of the betweenness centrality of the node [36]. Nevertheless, as observed by Maccari et al. [37], network optimization techniques based on betweenness centrality suer from two main issues. First, even if every node has access to in formation about the whole network, which is the case in linkstate protocols, the computation of the betweenness centrality may require excessive computational resources; hence, various On leave from DiMaI, Universit a degli Studi di Firenze, I50134 Firenze, Italy. ySupported by ANR projects DESCARTES and FREDA and INRIA project GANG. zSupported by the Fondation Sciences Math ematiques de Paris (FSMP). 1arXiv:2001.08108v1  [cs.SI]  22 Jan 2020heuristics and random sampling techniques were proposed in order to reduce the computation time [2,3,10,17,28,34,38{40,47{49]. Second, there are no known ecient algorithms for com puting betweenness centrality in the context of distancevector protocols. Existing distributed algorithms for computing betweenness centrality or allpairs shortest paths are either designed for models that are too weak compared to realworld networks supporting distancevector pro tocols (e.g., congest model) [23], or dedicated to restricted classes of network topology (e.g., DAGs or trees) [51{53], or they exchange an amount of information between nodes that exceed the capacity of distancevector protocols [55]. Actually, even the elegant and practical algorithm by Maccari et al. [37] for computing a related measure called load centrality [9, 19] exchanges slightly more information between nodes than one would expect from a distancevector protocol. 1.1 Our Results We describe a simple and fast distributed algorithm for computing betweenness centrality. Specically, our algorithm enables every node vto compute its own centrality bcv. Our algorithm is simple in the sense that it can be implemented by minimal modications to distancevector protocols based on BellmanFord. Concretely, BellmanFord asks every node v to send to each of its neighbors a pair of values ( t;d) for every targetnode t, wheredis the current distance from vtot, as perceived by v. Our algorithm simply asks every node to send to each neighbor a quadruple of values ( t;d;s;b ) for every targetnode t, wheresis the current estimation at vof the number of shortest paths from vtot, andbis the current contribution oftto the betweenness centrality of v. Our algorithm is fast in the sense that it converges in a number of distancevector phases proportional to the diameter of the network. Moreover, the amount of computations performed at each node vupon reception of a message from a neighbor urelated to a target tis (amortized) constant, i.e., independent of the size of the network. We have performed an extensive set of simulations conrming both the correctness analysis of our algorithm, and its eciency. We have considered dierent scenarios, including weighted and unweighted networks, and various topologies generated by synthetic models (grids, Erd os R enyi, etc.) or extracted from realworld networks. The main outcome of this paper is that betweenness centrality can be eciently computed at every node in a distributed manner, even in the context of distancevector protocols. As a consequence, there is no obstacle for using betweenness centrality for optimizing the func tionality of networks, as far as computing this parameter at runtime by the network itself is concerned. This resolves a question left open in the work of Maccari et al. [37]. 1.2 Related Work "
41,Effective Data Aggregation Scheme for Large-scale Wireless Sensor Networks.txt,"Energy preservation is one of the most important challenges in wireless
sensor networks. In most applications, sensor networks consist of hundreds or
thousands nodes that are dispersed in a wide field. Hierarchical architectures
and data aggregation methods are increasingly gaining more popularity in such
large-scale networks. In this paper, we propose a novel adaptive
Energy-Efficient Multi-layered Architecture (EEMA) protocol for large-scale
sensor networks, wherein both hierarchical architecture and data aggregation
are efficiently utilized. EEMA divides the network into some layers as well as
each layer into some clusters, where the data are gathered in the first layer
and are recursively aggregated in upper layers to reach the base station. Many
criteria are wisely employed to elect head nodes, including the residual
energy, centrality, and proximity to bottom-layer heads. The routing delay is
mathematically analyzed. Performance evaluation is performed via simulations
which confirms the effectiveness of the proposed EEMA protocol in terms of the
network lifetime and reduced routing delay.","Recent advances in miniaturization and wireless communi cations have enabled making the micro sensors with limited processing and communicating capabilities. Largescale WSNs consist of a large number of sensor nodes, thousands or mil lions [1], scattered in a wide ﬁeld and provide different types of applications [2]. WSNs are drastically energyconstrained so that energy preservation is one of the most important challenges in these networks. Accordingly, the long lifetime is usually considered as a desired goal in the design level of such networks. On the other hand, the large number of the nodes imposes some overheads, including increased routing table size and delay; and makes the scalability issue difﬁcult in such large networks. As shown in [3], hierarchical architectures are effective approaches in making large traditional networks scalable by reducing the size of the routing tables. Although WSNs seem different from traditional networks (even Mobile Ad hoc NETworks (MANETs)), hierarchical architectures shown to well match these large networks. At the same time, since WSNs are datacentric [4] and the notable value of the data produced by sensors are the same, data aggregation is an effective approach to reduce the load, and as a result, helps the network to be more energyefﬁcient. In the last decade, although clustering the nodes has been extensively investigated for WSNs, hierarchical multilayered architecture has not been properly explored. Hence, in this M. Mehdi Afsar is with the Young Researchers and Elite Club, Mashhad Branch, Islamic Azad University, Mashhad, Iran. (Email: m.afsar@qiau.ac.ir)paper, we analyze the impact of an adaptive hierarchical multi layered architecture on the energyefﬁciency issue of large scale WSNs. The proposed EnergyEfﬁcient Multilayered Architecture, called EEMA, divides the entire network into some layers, as well as each layer into some clusters. The head of each cluster is selected based upon a hybrid of residual energy, centrality, and the location of node. The data are gathered in the ﬁrst layer, and are hierarchically aggregated in the next layers to reach the base station (BS). Adaptive clustering is employed to achieve load balancing among all the nodes, and consequently, improve the lifetime. We also analyze the routing delay mathematically and show that EEMA signiﬁcantly improves which. Furthermore, we mathematically show that the elected head nodes in the extra layers could participate in data acquisition so that the coverage is conserved as good as clustering approaches. The performance of EEMA is validated through simulation. The rest of this paper is organized as follows. Related work is discussed in section II. Preliminaries about the used system in this paper are discussed in section III. Section IV explains the proposed EEMA protocol in detail. Performance evaluation and experiments are presented in section VI and the paper is concluded in section VII. II. R ELATED WORK "
28,Urban Delay Tolerant Network Simulator (UDTNSim v0.1).txt,"Delay Tolerant Networking (DTN) is an approach to networking which handles
network disruptions and high delays that may occur in many kinds of
communication networks. The major reasons for high delay include partial
connectivity of networks as can be seen in many types of ad hoc wireless
networks with frequent network partitions, long propagation time as experienced
in inter-planetary and deep space networks, and frequent link disruptions due
to the mobility of nodes as observed in terrestrial wireless network
environments. Experimenting network architectures, protocols, and mobility
models in such real-world scenarios is difficult due to the complexities
involved in the network environment. Therefore, in this document, we present
the documentation of an Urban Delay Tolerant Network Simulator (UDTNSim)
version 0.1, capable of simulating urban road network environments with DTN
characteristics including mobility models and routing protocols. The mobility
models included in this version of UDTNSim are (i) Stationary Movement, (ii)
Simple Random Movement, (iii) Path Type Based Movememt, (iv) Path Memory Based
Movement, (v) Path Type with Restricted Movement, and (vi) Path Type with Wait
Movement. In addition to mobility models, we also provide three routing and
data hand-off protocols: (i) Epidemic Routing, (ii) Superior Only Handoff, and
(iii) Superior Peer Handoff. UDTNSim v0.1 is designed using object-oriented
programming approach in order to provide flexibility in addition of new
features to the DTN environment. UDTNSim v0.1 is distributed as an open source
simulator for the use of the research community.",2 UDTNSim Architecture 3 2.1 A Modular View of UDTNSim . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.2 Implementation of Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.3 Simulator Conﬁguration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.3.1 Simulation Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.3.2 Parser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.3.3 Addition of New Simulation Parameters . . . . . . . . . . . . . . . . . . . 7 2.3.4 XML Parser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3 Movement Models 11 3.1 Stationary Movement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 3.2 Simple Random Movement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.3 Path Type Based Movement Model . . . . . . . . . . . . . . . . . . . . . . . . . . 13 3.4 Path Memory Based Movement Model . . . . . . . . . . . . . . . . . . . . . . . . 14 3.5 Path Type with Restricted Movement . . . . . . . . . . . . . . . . . . . . . . . . 14 3.6 Path Type with Wait Movement . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.7 Addition of New Movement Models . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.8 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 4 Routing Protocols 17 4.1 Epidemic Routing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 4.2 Superior Only Handoﬀ Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 4.3 Superior Peer Handoﬀ Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 4.4 Addition of New Routing Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . 20 4.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 5 Supporting Libraries 21 5.1 Graphical User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 5.2 Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 5.2.1 Event . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 5.2.2 Event Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 5.3 Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 5.3.1 Movement Report . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 5.3.2 Event Report . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 5.4 Additional Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 5.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 vCONTENTS 6 Summary 27 6.1 Related Work in UDTNSim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 
207,Discrete Event Simulation of Driver's Routing Behavior Rule at a Road Intersection.txt,"Several factors influence traffic congestion and overall traffic dynamics.
Simulation modeling has been utilized to understand the traffic performance
parameters during traffic congestions. This paper focuses on driver behavior of
route selection by differentiating three distinguishable decisions, which are
shortest distance routing, shortest time routing and less crowded road routing.
This research generated 864 different scenarios to capture various traffic
dynamics under collective driving behavior of route selection. Factors such as
vehicle arrival rate, behaviors at system boundary and traffic light phasing
were considered. The simulation results revealed that shortest time routing
scenario offered the best solution considering all forms of interactions among
the factors. Overall, this routing behavior reduces traffic wait time and total
time (by 69.5% and 65.72%) compared to shortest distance routing.","Traffic congestion at intersections refers t o the delay caused by vehicles or traffic volume in urban  conditions. The key to the sustainability, safety and reliability of surface transportation is to minimize travel  time due to congestion intensity by implementing innovations in transportation manag ement systems  (Litman 2016). Optimization of transportation system operation, especially at signalized intersections, has  been one of the most complex tasks of urban design. Incorrectly/(Poorly) designed intersections result in  traffic congestion and traff ic delay. Previous research has proven that one third of everyday urban traffic  congestion is a consequence of intersection traffic (Yu et al. 2013; Zhang and Batterman 2013). Therefore,  there is a need to study efficient signalized intersections, consider ing not only urban design requirements,  but also human cognitive essentials (Talebpour and Mahmassani 2014) through analysis, modeling, and  simulation.   In recent years, due to technology advancement, modeling and simulation of signalized intersections  have become significantly more useful for studying congestion issues. The most common techniques have  been modeling and analyzing traffic demands and flows by using static parameters (i.e. average of traffic).  Due to the role of intersections, the efficiency of the signalized intersection has been measured differently,  using the delay, length of queue, and number of stops. These measurements can be used to analyze  psychological processes at intersections due to how much time is wasted in traffic, by measuring the  difference between the actual and desired time to traverse the intersection  (Pakdamanian , Feng,  and Kim  2018) . However, questions still remain: 1) how reliable is this analysis without applying parameters  associated with human behind the wheel, and 2) will static parameters be useful w hen fully  and semi  autonomous vehicles be commercialized and entirely frame how people commute? To address these  questions, a more comprehensive model for relieving intersection traffic congestion is needed, one which  considers the interplay between inter section traffic status and driver decision processes.  The current study  proposed an extensive simulation effort to design a more efficient traffic flow by integrating conditionally  changing decisions at intersections.  Benzaman and Pakdamanian      This study developed a novel approa ch to simulating driver decision making behavior at an  intersection. The scenarios were generated based on route selecting behavior, as well as traffic light status  and decisions at the system boundary. The three routing decisions at an intersection which were  conceptualized in the simulation were the shortest distance, the shortest time, and the least crowded. This  study believes that the understanding of driving behavior in route selection can be further expanded into  routing algorithms for autonomous veh icles, with the aim of reducing future traffic congestion.    2 LITERATURE REVIEW   Since the rate of access to motor vehicles in urban areas is higher than infrastructure growth, traffic  congestion has become an increasing problem. (Redman et al. 2013). Roads are overloaded and, as a result,  people spend more time in tr affic than ever. Road intersections have become  bottlenecks in urban traffic  congestion where vehicles wait in queue for hours. In general, the urban traffic system can be seen as a  queuing system in which roads, junctions, and traffic signals serve the tr affic flow. Generally the capacity  of the intersection in urban areas are  much lower than all the entering roads.  In order to produce the most  effective schedules for smooth functioning  of intersections , it is necessary to make an estimate of the  waiting times in the system (Bowman and Miller 2016).  The most common way for this purpose is to  employ traffic simulation.    Simulation assists traffic designers and engineers in building an intersection and evaluating its status  in order to discover the designs with the least amount of traffic load. More importantly, simulation based  methodology has been used to help traffic designers’ study and analyze intersections, and ultimately solve  bottleneck issues (D’Ambrogio et al. 2009). Since more than 10 percent of f uture cars will be fully  autonomous by 2035 (Mosquet et al. 2015), modeling reasonable behaviors of the vehicles or drivers in a  way that it is capable of performing high level and critical decisions would be needed in the future.  The  majority of traffic d esign studies, efforts and simulation based methodologies have been devoted toward  analyzing the various behavioral decisions made by human drivers in various traffic conditions (Hamdar et  al. 2008; Hamdar 2009; Hu et al. 2012). However, despite notable im provements, most of the studies in the  area of traffic signalization, whether they have analyzed field data (Kazama et al. 2007; Amborski et al.  2010) or simulation data (Chin et al. 2011) have not considered the main component of the system, “ the  human dr iver.” In the world of the future, with vehicles equipped to communicate with other vehicles  (vehicle tovehicle) or with the infrastructure systems and to make decisions according to data received by  perception subsystems (Furda and Vlacic 2011), it would  be a remarkable innovation to design a relevant  conceptual model.    If drivers were provided several route options  to get to their desired destination, their final decision  could be affected by external (surrounding environment and road status) or interna l (behavioral  anticipation) information (Cunningham et al. 2015). The internal component of the final decision is  contingent to the quality of external information. Therefore, many studies have focused on the perceived  information. Wang et al. (2014) appli ed the Monte Carlo method and queuing theories to study how wrong  decisions and traffic congestion are caused by external information : time interval between the cars (time  gap), space between the cars (space gap), and waiting time. Future advancement of ve hicle technologies  could resolve these external components through vehicle tovehicle (V2V) technology (Naranjo et al.  2003). This communication method constantly sends and receives information about nearby vehicles’  speed, distance, and location.  For thi s paper, the fundamental effectiveness of V2V technology, which has  the potential to solve vehicle queuing problems at intersections, was modeled by integrating the discrete  dynamic system and the external components which were missing in the previous stud y done by Wang et  al. (2014): shortest distance, shortest time and least crowded road.   Macroscopic models, such as network flow models, do not consider details to the extent that can be  done through microscopic models, (such as simulations), in which the i ndividual behavior of each vehicle  can be considered. In surface transportation, discrete event simulation methodology was used to compare  a proposed signal controller with what currently exists at signalized intersections (Pranevičius and Kraujalis  2012).  The suggested model performed better the fuzzy logic controller in high volume traffic situations. Benzaman and Pakdamanian     In order to prove how ARENA is capable of simulating traffic systems and suggesting improvements for  traffic flow at intersections, Salimifard and Ansari us ed ARENA modules for modeling signalized  intersections (Salimifard and Ansari 2013). Although their model provided an optimal duration for the green  phase signal similar to the majority of routing studies which only considers an optimization problem (Huang   et al. 2014; Yu et al. 2019) to minimize the length of the queue at a signalized intersection, the researchers  did not consider more complex models by which the movements and decisions of individual vehicles might  be controlled at the microscopic level.    One of the few attempts to utilize simulation at the microscopic level, with more complex models, was  done by Backfrieder et al. (2017).  In their study, rerouting was used with the assistance of a predictive  congestion minimization algorithm (PCMA) develo ped with consideration of the current road conditions  and predicted future congestion. Current road conditions assumed utilization  of vehicle toX  communication for transmission of vehicle data from the current position to the desired destination. This  study enables the transmitting  of data for intelligent selection of routes and even to allow rerouting in case  of a congestion.    This study considered how to expand the number of logical decisions for route selection at an  intersection, instead of being limi ted to a user defined threshold, to understand the overall traffic  performance of a semi closed loop system. Our proposed model takes under consideration three main  logical decisions that a driver can take at an intersection to avoid traffic: (1) shortest distance routing, (2)  shortest time routing and (3) least crowded road routing. The goal of this research is to expand  on the  limitations mentioned above and to observe how human behaviors influence the overall system.   3  METHODOLOGY   "
112,Boost Decentralized Federated Learning in Vehicular Networks by Diversifying Data Sources.txt,"Recently, federated learning (FL) has received intensive research because of
its ability in preserving data privacy for scattered clients to collaboratively
train machine learning models. Commonly, a parameter server (PS) is deployed
for aggregating model parameters contributed by different clients.
Decentralized federated learning (DFL) is upgraded from FL which allows clients
to aggregate model parameters with their neighbours directly. DFL is
particularly feasible for vehicular networks as vehicles communicate with each
other in a vehicle-to-vehicle (V2V) manner. However, due to the restrictions of
vehicle routes and communication distances, it is hard for individual vehicles
to sufficiently exchange models with others. Data sources contributing to
models on individual vehicles may not diversified enough resulting in poor
model accuracy. To address this problem, we propose the DFL-DDS (DFL with
diversified Data Sources) algorithm to diversify data sources in DFL.
Specifically, each vehicle maintains a state vector to record the contribution
weight of each data source to its model. The Kullback-Leibler (KL) divergence
is adopted to measure the diversity of a state vector. To boost the convergence
of DFL, a vehicle tunes the aggregation weight of each data source by
minimizing the KL divergence of its state vector, and its effectiveness in
diversifying data sources can be theoretically proved. Finally, the superiority
of DFL-DDS is evaluated by extensive experiments (with MNIST and CIFAR-10
datasets) which demonstrate that DFL-DDS can accelerate the convergence of DFL
and improve the model accuracy significantly compared with state-of-the-art
baselines.","With the proliferation of intelligent vehicles, vehicles h ave accumulated abundant datasets via equipped LiDAR, RIDAR, camera and sensors [1]. Advanced machine learning models can be obtained by exploiting datasets on vehicles to improv e road safety, object recognition accuracy, etc [2]. However , exploiting datasets on vehicles for model training confron ts at least two challenges: First, accessing raw datasets residi ng on vehicles inevitably invades data privacy because these dat asets This work has been partially supported by National Key R&D Pr o gram of China under Grant No.2018YFB1800302, Shenzhen Scie nce and Technology Program under Grant No. RCYX20200714114645048 , and No. JCYJ20190808142207420, and Shenzhen Fundamental Researc h Program under Grant No. 20200814105901001. (Corresponding author: Laizhong Cui)probably contain sensitive and conﬁdential information; S ec ond, the communication cost may be very heavy by extensively collecting raw datasets from vehicles. Thanks to the recent advances of federated learning (FL), these challenges can b e potentially solved. To mitigate the rising concerns on data privacy leakage, FL conducts model training without touching original data samples stored on scattered clients [3]. In each round of FL global iteration (a.k.a epoch), a parameter server (PS) is responsible for aggregating model parameters collected from participating clients who conduct local iterations wi th local datasets and then disclose their model parameters to t he PS. Global iterations will be conducted for multiple times by involving different clients until the trained model ﬁnal ly converges [3]. To avoid the single point failure and alleviate the com munication bottleneck of the PS in FL [4], decentralized FL (DFL) is devised which allows each client to aggregate model parameters gathered from its neighbours directly. Accordi ng to [5], [6], clients weigh models from neighbours based on thei r connection degrees or sample sizes for model aggregation. T he convergence of DFL has been proved in [7], [8] assuming that the network topology formed by clients is connected. DFL is particularly feasible for vehicular networks provided t hat vehicles as learning clients communicate with each other in a vehicletovehicle (V2V) manner [9]. Despite the feasibility of DFL, it is highly possible that individual vehicles1fail to attain satisfactory model accuracy due to restrictions of their routes and communication dista nces [10]. To illustrate this point, we show a concrete example in Fig. 1 by using real traces extracted from DiDi [11]. In Fig. 1 , there are four vehicles, namely A, B, C and D. The route of vehicle A has no overlap with the route of vehicle B though their information can be exchanged via intermediate vehicl e C. In other words, data sources contributing to model aggregat ion on vehicle A are not sufﬁciently diversiﬁed given that vehic le A cannot directly communicate with vehicle B. The problem is even worse in a real largescale vehicular network when vehicles need to exchange model parameters via multiple 1We use vehicles exchangeably with clients in our paper. 9781665482349/22/$31.00 ©2022 IEEEAB CD Fig. 1: A simple example to show the model exchange via an intermediate vehicle in DFL. hops through intermediate vehicles. As a consequence, the convergence of DFL in vehicular networks could be very slow. Diversifying data sources in FL has been explored by existing works. It has been regarded as an important data related factor affecting model performance in [12], which proposed a diversitydriven client selection strategy. Ho wever, a central server is needed to collect the noisy data sketch of each client to compute the data similarity between two clien ts. In [13], a joint sampling and data ofﬂoading algorithm is proposed to improve model performance, where the sampling method is based on the utility of device data distributions. A D2D (devicetodevice) ofﬂoading scheme is used to diversi fy sampled devices, though D2D ofﬂoading between neighboring devices is unsuitable in many privacypreserving tasks. In [14], training workers are assumed to be connected with all data sources, which can ensure that the dataset collected by each training worker is of large diversity. Unfortunately, these methods cannot be leveraged to support DFL in vehicular networks in that they failed to consider the fully decentral ized V2V communication manner in vehicular networks. To boost DFL by diversifying data sources in vehicular networks, we propose the DFL with diversiﬁed data sources (DFLDDS) algorithm. First of all, we implement the dis tributed learning algorithm designed in [5] without consid ering data source diversity to conduct a simulation study. Our stu dy unveils that unlucky vehicles will encounter difﬁculties t o diversify their data sources for model aggregation. Conse quently, their model accuracy is much lower than that of othe r vehicles. Inspired by our simulation study, we design DFL DDS as below. Each vehicle in DFLDDS maintains a state vector to record the contribution weight of each vehicle in t he system to its model, which will be exchanged between vehicle s along with the exchange of model parameters. Formally, we employ the KL divergence to measure the diversity of a state vector, which not only quantiﬁes data source diversity but a lso accommodates heterogeneous dataset sizes from different v e hicles. Prior to aggregating models, each vehicle generate s the aggregation weight for each data source by minimizing the KL divergence of its aggregated state vector, and its effectiv eness in diversifying data sources can be theoretically illustra ted. Tovalidate that higher model accuracy can be attained with mor e diversiﬁed data sources, we conduct extensive experiments to evaluate our algorithm by using standard MNIST and CIFAR 10 datasets. Experimental results demonstrate superb perf or mance achieved by DFLDDS in comparison with competitive baselines. The rest of the paper is organized as follows. Relevant works and our contribution compared to these works are discussed in Sec. II. Preliminary knowledge of the FedAvg and Decentralized FedAvg algorithms are introduced in Sec. III. The simulation study showing the deﬁciency of existing algorithms is presented in Sec. IV. The DFLDDS algorithm and its analysis are elaborated in Sec. V. Experiments are conducted and results are reported in Sec. VI. Lastly, we conclude our work and envision our future work in Sec. VII. II. R ELATED WORK "
219,Systematic Testing of Multicast Routing Protocols: Analysis of Forward and Backward Search Techniques.txt,"In this paper, we present a new methodology for developing systematic and
automatic test generation algorithms for multipoint protocols. These algorithms
attempt to synthesize network topologies and sequences of events that stress
the protocol's correctness or performance. This problem can be viewed as a
domain-specific search problem that suffers from the state space explosion
problem. One goal of this work is to circumvent the state space explosion
problem utilizing knowledge of network and fault modeling, and multipoint
protocols. The two approaches investigated in this study are based on forward
and backward search techniques. We use an extended finite state machine (FSM)
model of the protocol. The first algorithm uses forward search to perform
reduced reachability analysis. Using domain-specific information for multicast
routing over LANs, the algorithm complexity is reduced from exponential to
polynomial in the number of routers. This approach, however, does not fully
automate topology synthesis. The second algorithm, the fault-oriented test
generation, uses backward search for topology synthesis and uses backtracking
to generate event sequences instead of searching forward from initial states.
Using these algorithms, we have conducted studies for correctness of the
multicast routing protocol PIM. We propose to extend these algorithms to study
end-to-end multipoint protocols using a virtual LAN that represents delays of
the underlying multicast distribution tree.","Network protocols are becoming more complex with the exponential growth of the Internet, and the introduction of new services at the network, transport and application lev els. In particular, the advent of IP multicast and the MBone enabled applications ranging from multiplayer games to di s tance learning and teleconferencing, among others. To date , little eﬀort has been exerted to formulate systematic meth ods and tools that aid in the design and characterization of these protocols. In addition, researchers are observing newand obscure, yet all too frequent, failure modes over the internets [1] [2]. S uch failures are becoming more frequent, mainly due to the in creased heterogeneity of technologies, interconnects and con ﬁguration of various network components. Due to the syn ergy and interaction between diﬀerent network protocols an d components, errors at one layer may lead to failures at otherlayers of the protocol stack. Furthermore, degraded perfor  mance of low level network protocols may have ripple eﬀects on endtoend protocols and applications. Network protocol errors are often detected by application failure or performance degradation. Such errors are hardes t to diagnose when the behavior is unexpected or unfamiliar. Even if a protocol is proven to be correct in isolation, its behavior may be unpredictable in an operational network, where interaction with other protocols and the presence of failures may aﬀect its operation. Protocol errors may be very costly to repair if discovered after deployment. Hence , endeavors should be made to capture protocol ﬂaws early in the design cycle before deployment. To provide an eﬀective solution to the above problems, we present a framework for the systematic design and testing of multicast protocols. T he framework integrates test generation algorithms with simu  lation and implementation. We propose a suite of practical methods and tools for automatic test generation for network protocols. Many researchers [3] [4] have developed protocol veriﬁca tion methods to ensure certain properties of protocols, lik e freedom from deadlocks or unspeciﬁed receptions. Much of this work, however, was based on assumptions about the net work conditions, that may not always hold in today’s Inter net, and hence may become invalid. Other approaches, such as reachability analysis, attempt to check the protocol sta te space, andgenerally suﬀerfrom the‘stateexplosion’ probl em. This problem is exacerbated with the increased complexity o f the protocol. Much of the previous work on protocol veriﬁca tion targets correctness. We target protocol performance a nd robustness in the presence of network failures. In addition , we provide newmethods for studyingmulticast protocols and topology synthesis that previous works do not provide. We investigate two approaches for test generation. The ﬁrst approach, called the faultindependent test generati on, uses a forward search algorithm to explore a subset of the protocol statespace togeneratethetesteventsautomatica lly. Stateandfaultequivalencerelations areusedinthisappro ach to reduce the state space. The second approach is called the faultoriented test generation, and uses a mix of forwar d and backward search techniques to synthesize test events an d topologies automatically. We have applied these methods to multicast routing. Our case studies revealed several design errors, for which we ha ve formulated solutions with the aid of this systematic proces s. We further suggest an extension of the model to include endtoend delays using the notion of virtual LAN. Such ex tension, in conjunction with the faultoriented test gener a tion, can be used for performance evaluation of endtoend multipoint protocols. The rest of this document is organized as follows. Sec2 tion VI presents related work in protocol veriﬁcation, con formance testing and VLSI chip testing. Section II intro duces the proposed framework, and system deﬁnition. Sec tions III, IV, V present the search based approaches and problem complexity, the faultindependent test generatio n and the faultoriented test generation, respectively. Sec  tion VII concludes1. •Multicast Routing Overview Multicast protocols are the class of protocols that support group communication. Multicast routing protocols include , DVMRP [5], MOSPF [6], PIMDM [7], CBT [8], and PIM SM [9]. Multicast routing aims to deliver packets eﬃciently togroupmembers byestablishing distributiontrees. Figur e 1 shows a very simple example of a source Ssending to a group of receivers Ri. S R1 R2 R3 R4 R5 S: sender to the group Ri: receiver i of the group Fig. 1 Establishing multicast delivery tree Multicast distribution trees may be established by either broadcastandpruneor explicit join protocols. Inthe for mer, such as DVMRP or PIMDM, a multicast packet is broadcast to all leaf subnetworks. Subnetworks with no local members for the group send prunemessages towards the source(s) of the packets to stop further broadcasts. Link state protocol s, such as MOSPF, broadcast membership information to all nodes. In contrast, in explicit join protocols, such as CBT or PIMSM, routers send hopbyhop joinmessages for the groups and sources for which they have local members. We conductrobustness case studies for PIMDM. Weare par ticularly interested in multicast routing protocols, beca use they are vulnerable to failure modes, such as selective loss , that have not been traditionally studied in the area of pro tocol design. For most multicast protocols, when routers are connected vi a a multiaccess network (or LAN)2, hopbyhop messages are multicast on the LAN, and may experience selective loss; i.e . may be received by some nodes but not others. The likeli hood of selective loss is increased by the fact that LANs ofte n 1We include appendices for completeness. 2We use the term LAN to designate a connected network with resp ect to IPmulticast. This includes shared media (such as Ethernet , or FDDI), hubs, switches, etc.contain hubs, bridges, switches, and other network devices . Selective loss may aﬀect protocol robustness. Similarly, endtoend multicast protocols and applicatio ns must deal with situations of selective loss. This diﬀerenti ates these applications most clearly from their unicast counter  parts, and raises interesting robustness questions. Our case studies illustrate why selective loss should be con  sidered when evaluating protocol robustness. This lesson i s likely to extend to the design of higher layer protocols that operate on top of multicast and can have similar selective loss. II. Framework Overview Protocols maybeevaluated for correctness or performance. We refer to correctness studies that are conducted in the ab sence of network failures as veriﬁcation. In contrast, robu st ness studies consider the presence of network failures (suc h as packet loss or crashes). In general, the robustness of a protocol is its ability to respond correctly in the face of ne t work component failures and packet loss. This work presents a methodology for studying and evaluating multicast proto cols, speciﬁcally addressing robustness and performance i s sues. We propose a framework that integrates automatic test generation as a basic component for protocol design, along with protocol modeling, simulation and implementation tes t ing. The major contribution of this work lies in developing new methods for generating stress test scenarios that targe t robustness and correctness violation, or worst case perfor  mance. Instead of studying protocol behavior in isolation, we in corporate the protocol model with network dynamics and failures in order to reveal more realistic behavior of proto cols in operation. This section presents an overview of the framework and its constituent components. The model used to represent the protocol and the system is presented along with deﬁnitions of the terms used. Our framework integrates test generation with simulation and implementation code. It is used for Systematic Testing ofRobustness by Evaluation of Synthesized Scenarios (STRESS) . As the name implies, systematic methods for sce nario synthesis are a core part of the framework. We use the term scenarios to denote the testsuite consisting of th e topology and events. The input to this framework is the speciﬁcation of a pro tocol, and a deﬁnition of its design requirements, in terms o f correctness or performance. Usually robustness is deﬁned i n terms of network dynamics or fault models. A fault model represents various component faults; such as packet loss, c or ruption, reordering, or machine crashes. The desired outp ut is a set of testsuites that stress the protocol mechanisms according to the robustness criteria. As shown in Figure 2, the STRESS framework includes test generation, detailed simulation driven bythe synthes ized tests, and protocol implementation driven through an emu lation interface to the simulator. In this work we focus on the test generation (TG) component.3 Automatic Test Generation (ATG) Protocol Analysis through SimulationTest Patterns and Scenarios Emulation InterfaceDesign reﬁnement Protocol ImplementationTest Signals TestingAnalysis and reﬁnement Establish a protocol model (e.g. FSM)  Obtain test sequences to stress certain (e.g. robustness to message loss, or crashes)aspects of the model  Develop detailed protocol simulation  Study the behavior under the stress testsuites  Implement the protocol  Debug and study behavior using the simulator output test signals  Evaluate the test quality (e.g. using code coverage) Fig. 2 The STRESS framework A. Test Generation The core contribution of our work lies in the development of systematic test generation algorithms for protocol robu st ness. We investigate two such algorithms, each using a dif ferent approach. In general test generation may be random or deterministic. Generation of random tests is simple but a large set of tests is needed to achieve a high measure of error coverage. Deter ministic test generation (TG), on the other hand, produces tests based on a model of the protocol. The knowledge built into the protocol model enables the production of shorter and higherquality test sequences. Deterministic TG can be : a) faultindependent, or b) faultoriented. Faultindepe ndent TG works without targeting individual faults as deﬁned by the fault model. Such an approach may employ a forward search technique to inspect the protocol state space (or an equivalent subset thereof), after integrating the fault in to the protocol model. In this sense, it may be considered a variant of reachability analysis. We use the notion of equivalence to reduce the search complexity. Section IV describes our faultindependent approach. In contrast, faultoriented tests are generated for speciﬁ ed faults. Faultoriented test generation starts from the fau lt (e.g. a lost message) and synthesizes the necessary topolog y and sequence of events that trigger the error. This algorith m uses a mix of forward and backward searches. We present our faultoriented algorithm in Section V. We conduct case studies for the multicast routing proto col PIMDM to illustrate diﬀerences between the approaches , and provide a basis for comparison. In the remainder of this section, we describe the system model and deﬁnition.B. The system model We deﬁne our target system in terms of network and topol ogy elements and a fault model. B.1 Elements of the network Elements of the network consist of multicast capable nodes and bidirectional symmetric links. Nodes run same multi cast routing, but not necessarily the same unicast routing. The topology is an Nrouter LAN modeled at the network level; we do not model the MAC layer. For endtoend performance evaluation, the multicast dis tributiontreeisabstractedoutasdelaysbetweenendsyste ms and patterns of loss for the multicast messages. Cascade of LANs or uniform topologies are addressed in future research . B.2 The fault model Wedistinguish betweentheterms errorandfault. Anerror is a failure of the protocol as deﬁned in the protocol design requirement and speciﬁcation. For example, duplication in packet delivery is an error for multicast routing. A faultis a low level (e.g. physical layer) anomalous behavior, that may aﬀect the behavior of the protocol under test. Note that a fault may not necessarily be an error for the low level protocol. The fault model may include: (a) Loss of packets, such as packet loss due to congestion or link failures. We take into consideration selective packet loss, where a multicas t packet may be received by some members of the group but not others, (b)Loss of state, such as multicast and/or unica st routing tables, due to machine crashes or insuﬃcient mem ory resources, (c) The delay model, such as transmission, propagation, or queuing delays. For endtoend multicast protocols, the delays are those of the multicast distributi on tree and depend upon the multicast routing protocol, and (d) Unicast routing anomalies, such as route inconsistenci es, oscillations or ﬂapping. Usually, a fault model is deﬁned in conjunction with the robustness criteria for the protocol under study. For our robustness studies we study PIM. The designing robustness goal for PIM is to be able to recover gracefully (i.e. with out going into erroneous stable states) from single protoco l message loss. That is, being robust to a single message loss implies that transitions cause the protocol to move from one correct stable state to another, even in the presence of se lective message loss. In addition, we study PIM protocol behavior in presence of crashes and route inconsistencies. C. Test Sequence Deﬁnition A fault model may include a single fault or multiple faults. For our robustness studies we adopt a singlefault model, where only a single fault may occur during a scenario or a test sequence. Wedeﬁnetwosequences, T=< e1,e2,...,e n>andT′=< e1,e2,...,e j,f,ek,...,e n>, whereeiis an event and fis a fault. Let P(q,T) be the sequence of states and stimuli of protocol Punder test Tstarting from the initial state q. T′is a test sequence if ﬁnal P(q,T′) is incorrect; i.e. the stable state reached after the occurrence of the fault does not satisfy the protocol correctness conditions (see Secti on II E) irrespective of P(q,T). In case of a faultfree sequence,4 whereT=T′, the error is attributed to a protocol design error. Whereas when T/ne}ationslash=T′, and ﬁnal P(q,T) is correct, the error is manifested by the fault. This deﬁnition ignores transient protocol behavior. We are only concerned with the stable (i.e. nontransient) behavior of a protocol. D. Test Scenario A test scenario is deﬁned by a sequence of (host) events, a topology, and a fault model, as shown in Figure 3. Topology Events Faultstriggered timedinterleavedLANregular topologiesrandom packet loss crashes routinganomalies Fig. 3 Test pattern dimensions The events are actions performed by the host and act as input to the system; for example, join, leave, or send packet . The topology is the routed topology of set of nodes and links. The nodes run the set of protocols under test or other sup porting protocols. The links can be either pointtopoint links or LANs. This model may be extended later to repre sent various delays and bandwidths between pairs of nodes, by using a virtual LAN matrix (see [10]). The fault model used to inject the fault into the test. According to our singl e message loss model, for example, a fault may denote the ‘loss ofthesecond message oftype prunetraversingacertain link’. Knowing the location and the triggering action of the fault is important in analyzing the protocol behavior. E. Brief description of PIMDM For our robustness studies, we apply our automatic test generation algorithms to a version of the Protocol Indepen dent MulticastDense Mode, or PIMDM. The description given here is useful for Sections III through V. PIMDM uses broadcastandprune to establish the multi cast distribution trees. In this mode of operation, a multic ast packetisbroadcasttoall leafsubnetworks. Subnetworkswi th no local members send prunemessages towards the source(s) of the packets to stop further broadcasts. Routers with new members joining the group trigger Graft messages towards previously pruned sources to reestablis h the branches of the delivery tree. Graftmessages are ac knowledged explicitly at each hop using the GraftAck mes sage. PIMDM uses the underlying unicast routing tables to get the nexthop information needed for the RPF (reversepath forwarding) checks. This may lead to situations where there are multiple forwarders for a LAN. The Assertmechanism prevents these situations and ensures there is at most one forwarder for a LAN.The correct function of amulticast routing protocol in gen eral, is to deliver data from senders to group members (only those that have joined the group) without any data loss. For our methods, we only assume that a correctness deﬁnition is given by the protocol designer or speciﬁcation. For illus  tration, we discuss the protocol errors and the correctness conditions. E.1 PIM Protocol Errors In this study we target protocol design and speciﬁcation errors. We are interested mainly in erroneous stable (i.e. nontransient) states. In general, the protocol errors may be deﬁned in terms of the endtoend behavior as functional correctness requirements. In our case, for PIMDM, an error may manifest itself in one of the following ways: 1)black holes : consecutive packet loss between periods of packet delivery, 2) packet looping : the same packet traverses the same set of links multiple times, 3) packet duplication : multiple copies of the same packet are received by the same receiver(s), 4) join latency : lack of packet delivery after a receiver joins the group, 5) leave latency : unnecessary packet delivery after a receiver leaves the group3, and 6) wasted bandwidth : unnecessary packet delivery to network links that do not lead to group members. E.2 Correctness Conditions We assume that correctness conditions are provided by the protocol designer or the protocol speciﬁcation. These cond i tions are necessary to avoid the above protocol errors in a LAN environment, and include4: 1. Ifone (or more) ofthe routers is expecting toreceive pack  ets from the LAN, then one other router must be a forwarder for the LAN. Violation of this condition may lead to data loss (e.g. join latency or black holes). 2. The LAN must have at most one forwarder at a time. Vi olation of this condition may lead to data packet duplicatio n. 3. The delivery tree must be loopfree: (a) Anyrouter should accept packets from one incoming in terface only for each routing entry. This condition is enfor ced by the RPF (Reverse Path Forwarding) check. (b) The underlying unicast topology should be loopfree5. Violation of this condition may lead to data packet looping. 4. If one of the routers is a forwarder for the LAN, then there must be at least one router expecting packets from the LANs. Violation of this condition may lead to leave latency. III. Searchbased Approaches The problem of test synthesis can be viewed as a search problem. By searching the possible sequences of events and 3Join and leave latencies may be considered in other contexts as perfor mance issues. However, in our study we treat them as errors. 4These are the correctness conditions for stable states; i.e . not during transients, and are deﬁned in terms of protocol states (as op posed to end point behavior). The mapping from functional correctness requirements for m ulticast rout ing to the deﬁnition in terms of the protocol model is current ly done by the designer. The automation of this process is part of future re search. 5Some esoteric scenarios of route ﬂapping may lead to multica st loops, in spite of RPF checks. Currently, our study does not address th is issue, as it does not pertain to a localized behavior.5 faults over network topologies and checking for design re quirements (either correctness or performance), we can con  struct the test scenarios that stress the protocol. However , due to the state space explosion, techniques must be used to reduce the complexity of the space to be searched. We attempt to use these techniques to achieve high test quality and protocol coverage. Following we present the GFSM model for the case study protocol (PIMDM), and use it as an illustrative example to analyze the complexity of the state space and the search problem, as well as illustrate thealgorithmic details and p rin ciples involved in FITG and FOTG. A. The Protocol Model We represent the protocol as a ﬁnite state machine (FSM) and the overall LAN system by a global FSM (GFSM). I. FSM model: Every instance of the protocol, running on a single router, is modeled by a deterministic FSM consist ing of: (i) a set of states, (ii) a set of stimuli causing state transitions, and (iii) a state transition function (or tabl e) de scribing the state transition rules. For a system i, this is represented by the machine Mi= (S,τi,δi), whereSis a ﬁnite set of state symbols, τiis the set of stimuli, and δiis the state transition function S×τi→S. II. Global FSM model: The global state is deﬁned as the composition of individual router states. The output mes sages from one router may become input messages to other routers. Such interaction is captured by the GFSM model in the global transition table. The behavior of a system with n routers may be described by MG= (SG,τG,δG), whereSG: S1×S2×···×S nis the global state space, τG:n/uniontext i=1τiis the set of stimuli, and δGis the global state transition function SG×τG→SG. The fault model is integrated into the GFSM model. For message loss, the transition caused by the message is either nulliﬁed or modiﬁed, depending on the selective loss patter n. Crashes maybetreatedasstimulicausingtheroutersaﬀecte d by the crash to transit into a crashed state6. Network de lays are modeled (when needed) through the delay matrix presented in Section VII. B. PIMDM Model Following is the model of a simpliﬁed version of PIMDM. B.1 FSM modelMi= (Si,τi,δi) For a given group and a given source (i.e., for a speciﬁc sourcegroup pair), we deﬁne the states w.r.t. a speciﬁc LAN to which the router Riis attached. For example, a state may indicate that a router is a forwarder for (or a receiver expecting packets from) the LAN. 6Thecrashed state maybe one of the states already deﬁned for the pro tocol, like the empty state, or may be a new state that was not deﬁned previously for the protocol.B.1.a System States ( S). Possible states in which a router may exist are: State Symbol Meaning Fi Router iis a forwarder for the LAN FiTimer iforwarder with Timer Timer running NFi Upstream router ia nonforwarder NHi Router ihas the LAN as its nexthop NHiTimer same as NHiwith Timer Timer running NCi Router ihas a negativecache entry EUi Upstream router iis empty EDi Downstream router iis empty Mi Downstream router with attached member NMi Downstream router with no members The possible states for upstream anddownstream routers are as follows: Si=  {Fi,FiTimer,NFi,EUi}, if the router is upstream; {NHi,NHiTimer,NCi,Mi,NMi,EDi}, if the router is downstream . B.1.b Stimuli ( τ). The stimuli considered here include transmitting and receiving protocol messages, timer event s, and external host events. Only stimuli leading to change of state are considered. For example, transmitting message s per se (vs. receiving messages) does not cause any change of state, except for the Graft, in which case the Rtxtimer is set. Following are the stimuli considered in our study: 1. Transmitting messages: Graft transmission ( Graft Tx). 2. Receiving messages: Graft reception ( Graft Rcv), Join reception ( Join), Prune reception ( Prune), Graft Acknowl edgement reception ( GAck), Assert reception ( Assert), and forwarded packets reception ( FPkt). 3. Timerevents: theseeventsoccurduetotimerexpiration (Exp) and include the Graft retransmission timer ( Rtx), the event of its expiration ( RtxExp), the forwarderdeletion timer (Del), and the event of its expiration ( DelExp). We refer to the event of timer expiration as ( TimerImplication ). 4. External host events ( Ext): include host sending pack ets (SPkt), host joining a group ( HJoinorHJ), and host leaving a group ( LeaveorL). τ={Join,Prune,Graft Tx,Graft Rcv,GAck,Assert, FPkt,Rtx,Del,SPkt,HJ,L }. B.2 Global FSM model Subscripts are added to distinguish diﬀerent routers. These subscripts are used to describe router semantics and how routers interact on a LAN. An example global state for a topology of 4 routers connected to a LAN, with router 1 as a forwarder, router 2 expecting packets from the LAN, and routers 3 and 4 have negative caches, is given by {F1,NH2,NC3,NC4}. For the global stimuli τG, subscripts are added to stimuli to denote their originators and recipi ents (if any). The global transition rules δGare extended to encompass the router and stimuli subscripts7. 7Semantics of the global stimuli and global transitions will be described as needed (see Section V).6 C. Deﬁning stable states We are concerned with stable state (i.e. nontransient) be havior, deﬁned in this section. To obtain erroneous stable states, we need to deﬁne the transition mechanisms between such states. We introduce the concept of transition classiﬁ  cation and completion to distinguish between transient and stable states. C.1 Classiﬁcation of Transitions We identify two types of transitions; externally triggered (ET)andinternally triggered (IT) transitions. The former is stimulated by events external to the system (e.g., HJoinor Leave), whereas the latter is stimulated by events internal to the system (e.g., FPktorGraft). We note that some transitions may be triggered due to ei ther internal and external events, depending on the scenari o. For example, a Prunemay be triggered due to forwarding packets by an upstream router FPkt(which is an internal event), or a Leave(which is an external event). A global state is checked for correctness at the end of an externally triggered transition after completing its depe ndent internally triggered transitions. Following is a table of host events, their dependentET and IT events: Host Events SPkt HJoin Leave ET events FPkt Graft Prune IT events Assert ,Prune,GAck Join Join C.2 Transition Completion To check for the global system correctness, all stimulated internal transitions should be completed, to bring the syst em into a stable state. Intermediate (transient) states shoul d not be checked for correctness (since they may temporarily seem to violate the correctness conditions set forth for sta  ble states, and hence may give false error indication). The process of identifying complete transitions depends on the nature of the protocol. But, in general, we may identify a complete transition sequence, as the sequence of (all) tran si tions triggered due to a single external stimulus (e.g., HJoin orLeave). Therefore, we should be able to identify a tran sition based upon its stimuli (either external or internal) . At the end of each complete transition sequence the system exists in either a correct or erroneous stable state. Event triggered timers (e.g., Del,Rtx) ﬁre at the end of a complete transition. D. Problem Complexity The problem of ﬁnding test scenarios leading to proto col error can be viewed as a search problem of the protocol state space. Conventional reachability analysis [11] atte mpts to investigate this space exhaustively and incurs the ’stat e space explosion’ problem. To circumvent this problem weuse search reduction techniques using domainspeciﬁc info r mation of multicast routing. Inthissection, wegive thecomplexityofexhaustivesearch , then discuss the reduction techniques we employ based on notion of equivalence, and give the complexity of the state space. D.1 Complexity of exhaustive search Exhaustivesearch attemptstogenerate all states reachabl e from initial system states. For a system of nrouters where each router may exist in any state si∈S, and|S|=sstates, the number of reachable states in the system is bounded by (s)n. Withlpossible transitions we need l·(s)nstate visits to investigate all transitions. Faults, such as message los s and crashes, increase the branching factor l, and may intro duce new states increasing S. For our case study |S|= 10, while selective loss and crashes8increase branching almost by factor of 9. D.2 State reduction through equivalence Exhaustive search has exponential complexity. To reduce this complexity we use the notion of equivalence. Intuitive ly, in multicast routing the order in which the states are consid  ered is irrelevant (e.g., if router R1orR4is a forwarder is insigniﬁcant, so long as there is only one forwarder). Hence , we can treat the global state as an unordered set of state symbols. This concept is called ‘counting equivalence’9. By deﬁnition, the notion of equivalence implies that by invest i gating the equivalent subspace we can test for protocol cor rectness. That is, if the equivalent subspace is veriﬁed to b e correct then the protocol is correct, and if there is an error in the protocol then it must exist in the equivalent subspace10. D.2.aSymbolic representation. We use a symbolic rep resentation as a convenient form of representing the global state to illustrate the notion of equivalence and to help in deﬁning the error and correct states in a succinct manner. In the symbolic representation, rrouters in state qare rep resented by qr. The global state for a system of nrouters 8Crashes force any state to the empty state. 9Two system states ( q1,q2,...,q n) and ( p1,p2,...,p n) are strictly equivalent iﬀ qi=pi, where qi,pi∈ S,∀1≤i≤n. However, all routers use the same deterministic FSM model, hence all n! permutations of (q1,q2,...,q n) are equivalent. A global state for a system with nrouters may be represented as/producttext|S| i=1ski i, where kiis the number of routers in state si∈Sand Σ|S| i=1ki=n. Formally, Counting Equivalence states that two system states/producttext|S| i=1ski iand/producttext|S| i=1sli iare equivalent if ki=li∀i. 10The notion of counting equivalence also applies to transiti ons and faults. Those transitions or faults leading to equivalent states ar e considered equiv alent.7 is represented by G= (qr1 1,qr2 2,...,qrmm), where m=|S|, Σri=n. For symbolic representation of topologies where n is unknown ri∈[0,1,2,1+,∗] (‘1+’ is 1 or more, and ‘*’ is 0 or more). To satisfy the correctness conditions for PIMDM, the correct stable global states are those containing no for warders and no routers expecting packets, or those con taining one forwarder and one or more routers expecting packets from the link; symbolically this may be given by: G1=/parenleftbig F0,NH0,NC∗/parenrightbig , andG2=/parenleftbig F1,NH1+,NC∗/parenrightbig .11 We useXto denote anystatesi∈S. For example,{X− F}∗denotes 0 or more states si∈S−{F}. This symbolic representation is used to estimate the size of the reduced state space. D.2.bComplexity of the state space with equiva lence reduction. Considering counting equivalence, ﬁnd ing the number of equivalent states becomes a problem of combinatorics. The number of equivalent states becomes C(n+s−1,n) =(n+s−1)! n!·(s−1)!, where, nis the number of routers, sis the number of state symbols, and C(x,y) =x! y!·(x−y)!, is the number of ycombination of xset [12]. D.3 Representation of error and correct states Depending on the correctness deﬁnition we may get diﬀer ent counts for the numberof correct or error states. To get an idea about the size of the correct or error state space for our case study, we take two deﬁnitions of correctness and com pute the number of correct states. For the correct states of PIMDM, we either have: (1) no forwarders with no routers expectingpacketsfrom theLAN,or (2) exactly one forwarder with routers expecting packets from the LAN12. The correct space and the erroneous space must be disjoint and they must be complete (i.e. add up to the complete space), otherwise the speciﬁcation is incorrect. See Appen dix IA for details. We present two correctness deﬁnitions that are used in our case. •The ﬁrst deﬁnition considers the forwarder states as Fand the routers expecting packets from the LAN as NH. Hence, the symbolic representation of the correct states becomes: ({X−NH−F}∗), or (NH,F,{X−F}∗), 11For convenience, we may represent these two states as G1=/parenleftbig NC∗/parenrightbig , andG2=/parenleftBig F,NH1+,NC∗/parenrightBig . 12These conditions we have found to be reasonably suﬃcient to m eet the functional correctness requirements. However, they may no t be necessary, hence the search may generate false errors. Proving necessi ty is part of future work.and the number of correct states is: C(n+s−3,n)+C(n+ s−4,n−2). •The second deﬁnition considers the forwarder states as {Fi,FiDel}or simply FX, and the states expecting packets from the LAN as {NHi,NHiRtx}or simply NHX. Hence, the symbolic representation of the correct states becomes: ({X−NHX−FX}∗), or (NHX,FX,{X−FX}∗), and the number of correct states is: C(n+s−5,n)+4·C(n+s−5,n−2)−2·C(n+s−6,n−3). Refer to Appendix IB for more details on deriving the number of correct states. In general, we ﬁnd that the size of the error state space, ac cording to both deﬁnitions, constitutes the major portion o f the whole state space. This means that search techniques explicitly exploring the error states are likely to be more complex than others. We take this in consideration when designing our methods. IV. Faultindependent Test Generation Faultindependenttestgeneration (FITG)usestheforward search technique to investigate parts of the state space. As in reachability analysis, forward search starts from initial states and applies the stimuli repeatedly to produce the reachable state space (or part thereof). Conventionally, an exhaus tive search is conducted to explore the state space. In the exhaustive approach all reachable states are expanded unti l the reachable state space is exhausted. We use several man ifestations of the notion of counting equivalence introduc ed earlier to reduce the complexity of the exhaustive algorith m and expand only equivalent subspaces. To examine robust ness of the protocol, we incorporate selective loss scenari os into the search. A. Reduction Using Equivalences The search procedure starts from the initial states13and keeps a list of states visited to prevent looping. Each state is expanded by applying the stimuli and advancing the state machine forward by implementing the transition rules and returning a new stable state each time14. We use the count ing equivalence notion to reduce the complexity of the searc h in three stages of the search: 1. The ﬁrst reduction we use is to investigate only the equiv alent initial states. To achieve this we simply treat the set of states constituting the global state as unordered set 13For our case study the routers start as either a nonmember ( NM) or empty upstream routers ( EU), that is, the initial states I.S.={NM,EU}. 14For details of the above procedures, see Appendix IIA.8 instead of ordered set. For example, the output of such procedure for I.S.={NM,EU}andn= 2 would be: {NM,NM},{NM,EU},{EU,EU}. One procedure that produces such equivalent initial state space given in Appendix IIB. The complexity of the this algorithm is given by C(n+i.s.−1,n) as was shown in Sec tion IIID.2 and veriﬁed through simulation. 2. The second reduction we use is during comparison of vis ited states. Instead of comparing the actual states, we com pare and store equivalent states. Hence, for example, the states{NF1,NH2}and{NH1,NF2}are equivalent. 3. A third reduction is made based on the observation that applying identical stimuli to diﬀerent routers in identica l states leads to equivalent global states. Hence, we can elim i nate some redundant transitions. For example, for the globa l state{NH1,NH2,F3}aLeaveapplied to R1orR2would produce the equivalent state {NH1,NC1,F1}. To achieve this reduction we add ﬂag check before advancing the state machine forward. We call the algorithm after the third re duction the reduced algorithm. In all the above algorithms, a forward step advances the GFSM to the next stable state. This is done by applying all the internally dependent stimuli (elicited due to the appli ed external stimulus) in addition to any timer implications, i f any exists. Only stable states are checked for correctness. B. Applying the Method In this section we discuss how the faultindependent test generation can be applied to the model of PIMDM. We ap ply forward search techniques to study correctness of PIM DM. We ﬁrst study the complexity of the algorithms without faults. Thenwe applyselective message loss tostudythepro  tocol behavior and analyze the protocol errors. B.1 Method input "
70,Multi-Metric Energy Efficient Routing in Mobile Ad-Hoc Networks.txt,"Increasing network lifetime by reducing energy consumption across the network
is one of the major concerns while designing routing protocols for Mobile
Ad-Hoc Networks. In this paper, we investigate the main reasons that lead to
energy depletion and we introduce appropriate routing metrics in the routing
decision scheme to mitigate their effect and increase the network lifetime. For
our routing scheme, we take into consideration multiple layer parameters, such
as MAC queue utilization, node degree and residual energy. We integrate our
multi-metric routing scheme into OLSR, a standard MANET proactive routing
protocol. We evaluate via simulations in NS3 the protocol modifications under a
range of different static and mobile scenarios. The main observations are that
in static and low mobility scenarios our modified routing protocol leads to a
significant increase (5\%-20\%) in network lifetime compared to standard OLSR
and slightly better performance in terms of Packet Delivery Ratio (PDR).","Mobile communication systems without central manage ment have been gaining popularity in the form of Mobile Ad Hoc Networks (MANETs). MANETs have widespread appli cations ranging from military scenarios, handling emergencies and natural disasters to distributed processing of data. This type of mobile networks do not rely on any preestablished infrastructure and all nodes should be able to communicate with other nodes directly or indirectly through intermediate nodes. Hence, routing is a key operation in MANET and the appropriate selection of routing scheme affects its per formance. For this reason designing efﬁcient routing schemes has been an extensive research area in the last decade. Many proactive (e.g. OLSR [1]) and reactive routing protocols (e.g. AODV [2]) for MANET have been developed. Limited battery life of mobile nodes impose an important limitation in the performance of this type of networks. Power depletion of a mobile node affects its ability to forward packets on behalf of other nodes and may lead to partitioning of the network. Therefore, efﬁcient battery utilization and increase of network lifetime should be important design criteria for developing routing schemes in MANET. While many energyefﬁcient routing protocols have been presented ([3], [4], [5]) to optimize energy consumption across the network, these protocols are mostly based on a single routing metric, which is derived from energy measurements. For example, some of the current techniques use the reciprocalvalue of the residual energy to do minimum energy consump tion routing ([6], [7]) or they use Minimum Drain Rate (MDR) mechanism ([6], [8]). These approaches, based on a single metric, are myopic and do not consider all the possible causes of energy depletion in the network. Thus, the investigation of a combination of network parameters (multiple metrics), which are not strictly derived by residual energy but still indicate energy depletion levels in parts of the network, will contribute to designing more efﬁcient routing schemes. Our insight for this work is to determine a wider set of crosslayer parameters, not solely based on energy measure ments, that enable effective prediction of low energy paths, while encouraging uniform utilization of network resources. First, we identify the reasons that cause energy depletion in different parts of the network and then choose our metrics to mitigate their effect. We take into consideration three metrics in our routing scheme: MAC queue utilization ,residual energy andnode degree .MAC queue utilization is introduced to help our routing scheme to predict and avoid congested parts of the network, which are subject to high energy consumption due to the number of packet transmissions. Residual energy is crucial, because we want to choose paths, which include less depleted nodes. Finally, node degree contributes to reducing the energy consumption due to overhearing in the neighbor nodes of a possible intermediate node of the selected path. In this work, we focus on designing a novel multiple metric routing scheme for MANET, based on the described metrics, and integrate it to standard OLSR to examine its effectiveness. We combine the multiple metrics to compute a weight for each node. These weights are efﬁciently propagated to the rest of the network. Then, we propose a weightbased routing scheme, which will use a greedy approach to choose the path with the lower cost, computed from the weights the nodes received. In this way, the routing scheme takes into account the multiple metrics introduced and switches paths in order to avoid energy depleted, highly congested and dense areas of the network. The contributions of this work are:  introduction of a combination of routing metrics from multiple layers, which has not been examined in any previous work related to energy efﬁcient routing;  proposal of a novel multimetric routing scheme, which takes into account the above metrics, and in tegrate it to standard OLSR;  experimentation with the modiﬁed OLSR usingarXiv:1603.09386v1  [cs.NI]  30 Mar 2016NS3 [9] and examination of its energy behavior and its performance (in terms of Network Lifetime and PDR) compared to the standard OLSR The rest of the paper is organized as follows. In section II we shortly describe the prior work for energy efﬁcient routing. In section III we brieﬂy introduce OLSR. We describe our multimetric routing scheme in section IV. We verify our claims by extensive simulations in section V. II. R ELATED WORK "
38,Identifying OSPF Anomalies Using Recurrence Quantification Analysis.txt,"Open Shortest Path First (OSPF) is one of the most widely used routing
protocol to manage intra-domain routing. OSPF has been identified with many
serious security issues. LSA falsification is one of the most critical
vulnerability that can cause route loop and black hole. Network operators need
to rapidly identity such anomalies. Network operators need also to identify
hardware failure. In this paper, we investigate the capability of Recurrence
Quantification Analysis (RQA), an advanced nonlinear statistical analysis
technique, to identify OSPF anomalies. We evaluate the capability of RQA to
identify OSPF anomalies using a controlled testbed where we introduced
different types of LSA falsifications as well as hardware failures. Our
evaluation shows that RQA can rapidly detect OSPF anomalies.","Open Shortest Path First (OSPF) has been designed to be deployed within a single an Autonomous System (AS) where an AS represents a large organisation or an Internet Service Provider (ISP). OSPF is one of the most widely used interior gateway protocols [1], [2]. It is a linkstate routing protocol where each router maintains a database that describes the AS’s topology [3]. The main responsibility of OSPF routing protocol is to allow all routers within an AS to construct their routing tables and updates them when a change in the AS’s topology occurs. OSPF supports authentication where each link between OSPF routers is associated with a shared key. However, OSPF has been identiﬁed with a serious security issues [4]. Link State Advertisement (LSA) falsiﬁcation is the most wellknown security issue. LSA falsiﬁcation occurs when an attacker sends a false LSA on behalf of the victim router which can cause a serious impacts such as routing loop and black hole. Although OSPF provides “ﬁghtback” mechanism by instantly sending LSA when OSPF routers receive a false information in the LSAs which originated by them, different types of LSA falsiﬁcation overcome this mechanism [5], [1], [6]. Monitoring such serious attacks and hardware failures is a highly demanding for effective management and operation of IP routing protocol [2]. This paper introduces a new approach to detecting OSPF attacks and hardware failures which we deﬁne them as OSPF anomalies. Our approach is based on using Recurrence Quantiﬁcation Analysis (RQA) method. RQA is a nonlinear statistical anal ysis method uses the concepts of phase plane trajectory [7].RQA is a tool to extract hidden information from statistics of dynamic nonlinear systems [7]. To evaluate the ability of RQA to detect OSPF anomalies, we use OSPF trafﬁc obtained from a controlled testbed where we introduced different types of OSPF anomalies. Our evaluation shows the ability of RQA to instantly identify different types of OSPF anomalies. The rest of this paper is organised as follows. Section II introduces a brief background of OSPF and different types of LSA updates. Section III outlines our approach using RQA. In Section IV, we introduce our testbed and discuss the selection of monitoring point to capture OSPF trafﬁc. We evaluate our approach to detecting OSPF attacks in Section V and ﬁnally conclude our work in Section VI. II. OSPF B ACKGROUND The Internet is a decentralized global network comprised of tens of thousands of AutonomousSystems (ASes). An AS is a set of routers under a single technical administration using an Interior Gateway Protocol (IGP) such as Open Shortest Path First (OSPF) to communicate with other routers within the AS and an Exterior Gateway Protocol (EGP) such as Border Gateway Protocol (BGP) to communicatewith other ASes [8]. OSPF is one of the most widely used IGP. OSPF was ﬁrstly described in RFC1131 and revised by RFC 2328 [3]. There are two versions of OSPF, OSPF v2 supports IPv4 described in [3] and OSPF v3 that supports IPv6 described in [9]. OSPF is a link state routing protocol where each OSPF routers advertise the state of their links to their neighbor routers. When an OSPF protocol is enabled for a particular link, information associated with that router is added to the local Link State Database (LSDB). Afterward the router sends Hello messages on its operational links to determine whether other link state routers are operating on the interfaces as well. In addition to neighbordiscovery purpose, Hello messages are sent to maintain adjacencies between neighbor routers. After establishing the adjacency between two OSPF routers, these routers exchange a summarised LSDB. Each OSPF router compares the received summary with its local LSDB to ensure it is up to date. If one routers realize that it requires an update, it will request the new information from the adjacency router. OSPF instantly sends Link State Advertisement(LSA) mes sages to reﬂect a change in the topologyand every 30 minutes to refresh their routers database. These LSAs messages aredisseminated throughout the entire OSPF domain. There are ﬁve LSA types which are summarised in Table I. TABLE I ASUMMARY OF LSATYPES LSA type  Description Type1  Router LSAs which describe the states of router’s interfaces Type2  Network LSAs which describe the set of routers attached to the network Type3  Summary LSAs which describe routers to networks Type4  Summary LSAs which describe routers to AS boundary routers Type5  ASexternal LSAs which describes routes to destinations external to the AS OSPF is a hierarchical routing protocol by supporting sub domains or areas. Dividing one domain into areas limits the scope of LSAs ﬂooding within the OSPF domain. OSPF supports authenticationand encryption.It also provides“ ﬁght back” mechanism when a router receives a false LSA that was advertised by another router on its behalf, the router immediately advertises a newer instance of the LSA which cancels out the false one. However, OSPF has several known security issues [1], [4], [6]. LSA falsiﬁcation is the most critical security issue in OSPF . It occurs when an attacker advertises an LSA with false link information.False LSAs can be injected into the networkfrom a subverted router or common network host. If a false LSA is accepted by at least one router, it allows the attacker to poison the routers’ view of the AS topology and hence affecting its routing table [4]. LSA falsiﬁcations are classiﬁed into sel f LSA falsiﬁcation where a malicious router falsiﬁes only its own LSA and other–LSA falsiﬁcation where the malicious routers advertise a false LSA on behalf of other routers [ ?]. Early detection of OSPF attacks enables network operators to protect their network from worst consequences such as denial of service, eavesdropping and network delays. In addition to OSPF attacks, rapidly detection of router and link failure in an OSPF domain is of interest to network administrator. In this paper, we refer to LSA falsiﬁcation and hardware failures as OSPFanomalies.Innextsection,weintroduceourapproachto detect OSPF anomalies using a nonlinear statistical analysis technique. III. A N ONLINEARAPPROACH TO IDENTIFY OSPF ANOMALIES Differentmethodsandmodelsforanalysisoftimeseriesand forecasting are available. The Fourier transform (FT) and the AutoRegressive Integrated Moving Average (ARIMA) model are the most wellknown for analysis and forecasting time series. The FT and the ARIMA have some limitation for analysis of time series. The FT has some limitations such as time and frequency positions, nonstationarity or abrupt changes in a signal can spread out for whole signal as well as resolution. These drawbacks limit the application of the FT in detecting short periods of anomalous OSPF behaviour.The ARIMA model has two signiﬁcant limitations: (1) future values are assumed to be a linear function of past values and (2) a large amount of historical data is required to obtain reliable predictions [10]. Here, we use Recurrence Quantiﬁcation Analysis (RQA), a nonlinear technique based on a phase plane trajectory, to identifyOSPF anomalies.RQA was introducedto quantify the important aspects revealed by Recurrence Plot (RP), a graph ical method to display recurring patterns and nonstationarity in time series. A. Recurrence Plot Recurrence Plot (RP) is a tool to visualise the time dependent behaviour of the dynamics of a system using the conceptsofphaseplanetrajectory,andsimpliﬁesinterpre tation of recurrent data. With enough data, structural patterns in the RP can reveal information about the time evolution of the phase space. RP is not limited to long data sets. It can be used for short, noisy, and nonstationary data sets [11]. RPs can be formally expressed by the matrix , (1) where is an element of the recurrence matrix , N is the number of measure points, is a threshold distance, the Heaviside function and is a normalization operation. To construct an RP, three parameters have to be carefully selected. These are time delay , embedding dimension , and the threshold . Selecting nonoptimal values for RP’s parameters can produce different structures for the same input data. For example, nonoptimal values of embedding parameterscancausemanyinterruptionstotheLineofIdentity (LOI), a black main diagonal line with an angle  in the RP. To estimate time delay, the Autocorrelationfunction (ACF) and Mutual Information (MI) are the most wellknown meth ods to determine time delay. Unlike ACF which measures linear correlation, MI measures both linear and nonlinear correlation.Therefore,wewillusetheMImethodtodetermine "
470,HYMAD: Hybrid DTN-MANET Routing for Dense and Highly Dynamic Wireless Networks.txt,"In this paper we propose HYMAD, a Hybrid DTN-MANET routing protocol which
uses DTN between disjoint groups of nodes while using MANET routing within
these groups. HYMAD is fully decentralized and only makes use of topological
information exchanges between the nodes. We evaluate the scheme in simulation
by replaying real life traces which exhibit this highly dynamic connectivity.
The results show that HYMAD outperforms the multi-copy Spray-and-Wait DTN
routing protocol it extends, both in terms of delivery ratio and delay, for any
number of message copies. Our conclusion is that such a Hybrid DTN-MANET
approach offers a promising venue for the delivery of elastic data in mobile
ad-hoc networks as it retains the resilience of a pure DTN protocol while
significantly improving performance.","Wireless adhoc networking has emerged over the past decades at the inter section of personal computing, cellular telephony, and the Intern et. It is best suited for use in situations where an infrastructure is not available, or too costly to deploy. In a wireless adhoc network, radio equipped devices (lap tops, smart phones, sensors, etc.) cooperate in a distributed manner to prov ide the neces sary network functionality in the absence of a ﬁxed infrastructur e. Applications include for example emergency and rescue operations, conferenc e or campus settings, body area and personal networks, or vehicular networ ks. Node mobility has been acknowledged as one of the key challenges of a d hoc networking with direct impact on protocol performance. Early models, such as Random Walk, Random Direction and Random Waypoint, consid er nodes moving on a freespace planar surface. More reﬁned chara cterization and modeling have been derived for pedestrian applications [3, 4] and for vehicular mobility [5]. The measurements and observations of mobility patterns, ranging from stu dents on a campus to pedestrians or taxicabs in a city, have pushe d the com munity to also consider extremely sparse networks, or very dynam ic mobility conditions, e.g. often observed in the vehicular setting, where end toend paths between any pair of nodes may seldom exist [6, 7]. For such sparse or dynamic cases, the Delay/DisruptionTolerant Network (DTN) [8] paradigm uses node mobility to its advantage while compromis ing on message delivery delays [9]. Message forwarding decisions are mad e on a perencounter basis, for example by using utility functions based on aggregat ing statistics on node meeting probabilities [10, 11, 12]. At any given tim e, a node’s vision of the network topology is limited to its current neighbo rs, whereas conventional Mobile Adhoc Network (MANET) routing sch emes have either complete (in the proactive case) or at least partial (in the re active case) knowledge of the actual network topology. But even in the extreme case of sparse of highly mobile networks the re are situations where the network is suﬃciently dense and well conne cted to temporarily provide endtoend connectivity between a signiﬁcant subset of its nodes. These nodes may even form small islands of stability. Using MANET prin ci ples within such islands can bring great improvements. Indeed, it con siderably increases each node’s information of its local topology, thus leading to better forwarding decisions. When high mobility rates and more generally high link instabilities reduce route lifetimes and threaten networkwide end toend con nectivity, a MANET routing protocol can still succeed locally even if it fails globally. In this paper we propose HYMAD, a Hybrid DTNMANET routing proto  col. HYMAD combines techniques from both traditional adhoc rout ing and DTN approaches. HYMAD periodically scans for network topology ch anges and builds temporary disjoint groups of connected nodes. Intra group delivery is performed by a conventional adhoc routing protocol and inter group delivery 2Node Density Node MobilityHYMAD ADTNMANET DTN Figure 1: Mobility vs Density: when diﬀerent paradigms apply by a DTN protocol. HYMAD constantly adapts to the dynamics of the wireless adhoc ne twork usingonlytopologicalinformation. Asintraditionaladhocrouting, noextrain formationongeographicallocationorsocialcommunitymembership is required. It does not rely on a priori knowledge of connectivity patterns or in termeeting times. This makes HYMAD amenable to implementation in a DTN stack or adhoc routing protocol [13]. In a dense network, HYMAD can fun ction simi larly to a traditional MANET protocol. In the other extreme case of very sparse connectivity (where only two nodes can be in contact at any time) ea ch node is a group on its own and HYMAD behaves like a classical DTN routing prot ocol. In any other intermediate case its hybrid nature takes over. We implemented the HYMAD hybrid approach in the ONE DTN simula tor [2] with a selfstabilizing group service [14, 15] and the multicopy Spray andWait protocol as the DTN routing scheme [16]. We evaluated the scheme by performing simulation runs both on synt hetic Random Waypoint mobility traces and on the reallife Rollernet data se t [17], an example of a highly dynamic adhoc network. In the next section, we further describe how this hybrid approach positions itself compared to existing DTN and MANET approaches. In section 3 , we describe the HYMAD routing protocol principles. We explain how node s can agree on forming disjoint groups and how such groups rather than individual nodes can be used as the basis for DTN routing. We then evaluate th e scheme both on synthetic mobility models and on a real data set, the Rollerne t experi ment, in section 4. The results show that HYMAD outperforms the m ulticopy SprayandWaitDTNroutingprotocolit extends, both in termsof deliveryratio and delay. 2. Routing in a mobile wireless network Mobile wireless adhoc networks were ﬁrst studied under the assum ptions of moderate node mobility and suﬃcient density to ensure endtoend connectiv 3ity. Both conditions are necessary for traditional MANET approac hes, be they proactive or reactive. Recently, there has been an eﬀort to classify the various types of mobile adhoc networks [18]. One can characterize the relevant routing p aradigms in mobile wireless networks along the two main parameters of node density and node mobility . In Fig. 1, which maps the diﬀerent routing approaches on the bi dimensionalmobile wirelessnetworkspace, traditionalMANET routin gappears in the top left corner. When the density of nodes diminishes, endtoend connectivity can disap pear. In such sparse networks, nodes have very few, if any, neig hbors within their transmission ranges. The topology eventually splits into sever al non communicating connected components. This is typically the realm of D elay Tolerant Networking which one can further subdivide in two [19]: the Assisted DTNs (ADTN), in caseof low mobility of nodes, or Unassisted DTNs (U DTN) where mobility is high. The latter corresponds to traditional DTN sce narios. Routing in ADTNs typically involves special mobile nodes, known as mes  sage ferries or data mules, which relay the messages between the s eparate con nected components [20, 21]. The packetswitching method of MANE Ts is replaced with a storeandforward approach. When the mobility in sparse networks increases, mobile nodes begin to meet others. This is the traditional DTN scenario, where nodes forward one or more copies of a given message until it reaches its destination. There are many strategies for optimizing the forwarding decision. The most straigh tforward approaches, such as Epidemic or SprayandWait [16] do not requir e nodes to acquire information on the others’ positions, movements or traje ctories. More elaborate schemes involve a utility function where each node collects direct and indirect knowledge of other nodes’ meeting probabilities. They requ ire a certain learning period to aggregate statistics before making good forwar ding decisions. For example, Lindgren et al. [10] use past encounters to predict t he probability of meeting a node again while Daly et al. [11] use local estimates of bet weeness and similarity. In dense networks, conventional MANET protocols start to brea k down un der high mobility down even if the network is almost always fully connect ed. Indeed the sheer instability of the links would result in a deluge of topo logy updates in the proactive case and route error and new route requests messages in the reactive case. DTNs protocols on the other hand can handle h igh mobil ity regardless of the density of the network. However by narrowly focusing on perencounter events, they ignore a lot of available information. F or example, simply asking nodes to regularly broadcast a list of their neighbors wo uld give each node a picture of its twohop neighborhood even under high mo bility. Re peat this once and everyone knows their three hop neighborhood. A node may therefore have a topology “knowledge horizon” which determines h ow far into the real topology a node can “see”. The more extreme the mobility, the shorter the “horizon”. The Hybrid DTNMANET approach that we advocate in this paper aims at ﬁlling the gap for eﬃcient routing in highly connected and highly mobile 4Table 1: HYMAD groups vs. DTN nodes DTN HYMAD Node Group of nodes A node has mes sagemOne node in the group has message mand all other nodes in the group know that. Two nodes meetTwo disjoint groups become con nected. networks, which have so far, to the best of our knowledge, receiv ed little at tention. Hybrid DTNMANET routing, like the HYMAD protocol that w e describe below, combines the resilience of DTNs with the greater kno wledge of local network topology provided by a MANET protocol. It adapts na turally to the dynamics of the network and its applicability spans a large spectr um of the mobile wireless network space. 3. The HYMAD protocol 3.1. Overview The core idea in HYMAD is to use whole groups of nodes instead of individ  ual nodes as the focus of a DTN protocol. The analogy is detailed in Ta ble 1. Each node uregularly broadcasts, not necessarily with the same frequency, two control messages: 1. An “enhanced distance vector” for all members of its group. 2. A list of the messages held by members of its group, with their resp ective destinations, custodians, and number of copies. The ﬁrst message enables the use of an intragroup distance vect or routing protocol. In this paper’simplementation, the actual transmitted d istancevector is slightly modiﬁed with a node marking mechanism for the distributed ne twork partitioning algorithm (Section 3.2). Furthermore, each node can b e tagged as aborder node (i.e. in contact with other groups). We will refer to this list as theGroup algorithm message . The second message is necessary for the intergroup routing pro tocol. The message list allows a group to agree on what messages it carries, and , for each message, which node (hereafter call the message’s custodian) sp eciﬁcally holds it. The border node tags give every group member an estimation of t he number of outgoing connections to neighboring groups. We will refer to this list as the Messagesingroup list . As in traditional distance vector algorithms, the number of iterativ e broad casts necessary for all members of a group to agree on this inform ation is equal to the diameter of the group. HYMAD then uses a DTN protocol to transfer messages between g roups. The approach is generic and many existing DTN protocols could be emp loyed. 5c dab e1 c dab e1’ c dab e2 c dab e2’ In a’s group or trying to join Not in group Agree that they are not in same group Agree that they are in same group Diﬀer on group composition Figure 2: Selfstabilizing groups: convergence in two iterations In this paper, Sprayandwait [16] is used to forward messages b etween disjoint groups. As in SprayandWait, the source of a message will create a certain number of copies of it. In HYMAD however, this source node is part o f a group and copies of the messagewill be distributed among the adjacent gr oups instead of simply the nodes that the source encounters. If a group has mo re than one copy, it will, in turn, distribute extra copies to its other adjacent gr oups. If a grouphas just one copy it will wait until encounteringthe destinatio n’s groupto transferit. Onceinside the destination’sgroup, the intragroupr outingprotocol delivers the message to the destination. 3.2. Intragroup routing In HYMAD, the intragroup routing is handled by a simple distance vec tor algorithm. Theonlydiﬀerenceisthatifanext hopisnolongeravailable, instead of discarding the message, the node takes custody of it and adds it to its list of held messages in order to advertise the fact to its group members. That stills leaves open the question of how to partition the network in to several disjoint groups of nodes using a simple distributed network partitioning algorithm. In our implementation, we chose to consider diameterconstrained groups. This is a particularly relevant metric because it preserves n ode equality and interchangeability. Indeed, another way of deﬁning groups co uld have in volved considering all the nodes within two hops, for example, of a giv en node. However this would mean that some nodes are somehow more importa nt than others. The diameter parameter on the other hand does not refe r to any par 6ticular node and only makes sense within a connected subset of the n odes. It is therefore a natural candidate for deﬁning disjoint groups of nod es. A groupwill accept new members as longas its diameter is lessthan a pr ede ﬁnednetworkwidemaximumdiameterparameter( Dmax). Ifagroup’sdiameter expands due to internal link failure, then some members are exclude d to sat isfy the diameter constraint. Ducourthial et al. [15] propose a self stabilizing, asynchronous distributed algorithm that achieves this using an r−operator on a slightly modiﬁed distance vector. This algorithm converges in O(Dmax) iter ations. The proof of selfstabilization using asynchronous messag e passing can be found in [14]. The main ideas behind group creation and modiﬁcation are illustrated in Fig. 2 for a maximum diameter Dmax= 2. In the ﬁrst iteration, node abegins by broadcasting the distance vector ( a: 0). Nodes b,candddecide they want to join the group and broadcast ( b: 0,a: 1), (c: 0,a: 1), and ( d: 0,a: 1), respectively. After receiving the broadcast from d, nodeealso decides that it wants to join the group and broadcasts ( e: 0,d: 1,a: 2) (or ( e: 0,d: 1,c: 1,a: 2) ifcspoke before d). In the second iteration, anow broadcasts (a: 0,b: 1,c: 1,d: 1),drealizes that the distance between bandeis greater thanDmaxand therefore chooses to exclude efrom the group and broadcasts (d: 0,a: 1,c: 1,b: 2). Finally eunderstands that it is not part of the group. After two iterations, the group has stabilized on a,b,c,d. Now lets suppose that at a later time the link between aandcgoes down. Node cnow only receives the broadcasted distance vector ( d: 0,a: 1,b: 2) from d. It then understands that it is no longer part of the group. As is obvious from this example, a given topology can result in very diﬀerent groups depending on the order in which the nodes speak. Some looping problems can arise if two nodes simultaneously try to join a group that can only accept one of them. In order to avoid this, Duc ourthial et al. suggestaprioritymechanism, thoughrefrainfromactuallydeta ilingone[15]. In order to work, the priority function has to deﬁne a total order on the nodes. An interesting goal would be to ensure that a stable group cannot b e split up when a new node, which happens to have priority over some group me mbers, comes within range. We achieve this by deﬁning each node’s priority as either the time when it joined its current group or the current time if it is not in a group. We add to this a small value unique to each node that guarant ees that a total ordering is deﬁned at all times. These priority scores are att ached to the Group algorithm message . As in some MANET protocols, this algorithm is used in a proactive fashio n where each node periodically runs the algorithm and broadcasts its m odiﬁed distance vector. Group composition therefore changes in reactio n to topology changes rather than routing needs. Unlike most MANET protocols, this infor mation is never propagated beyond a group and its immediate neighbo rs. The size of the Messagesingroup lists is proportional to the number of nodes in a group, while the convergence time for all group information is in O(Dmax). 73.3. Intergroup routing Border nodes take care of most of the intergroup DTN routing. Indeed, the periodic broadcast protocol described in 3.2 puts them in the unique position of knowing both the composition of two adjacent groups as well as the messages these hold. Border nodes may request a message’s custodian to transfer one or more copies to it. When a border node learns that its group has acquired copies of a message that a neighboring group does not possess, it has the following optio ns: •If the message’s destination is in the neighboring group, request th e mes sage from its custodian and pass it on. •Ifitsgrouphasmorethanonecopyofthemessage,request max/parenleftBig 1,/ceilingleftBig nc nb+1/ceilingrightBig/parenrightBig copies from its custodian and pass them on. ( ncis the number of copies andnbthe current number of border nodes in the group). The idea is to fairly spread a group’s copies among its adjacent groups. •Otherwise do nothing Conversely, when a border node receives copies of a new message from an adjacent group it can either: •If the destination is in its group, forward the message to it using the intergroup routing protocol. •Otherwise, randomly select a group member to be the custodian for the copies. This is done to spread the burden over members of a group. With this in place, when a node wantsto send a message, it simply adds it to its own list of messages. Through the intrarouting protocol, in O(Dmax) time, the group’s border nodes will become aware of the new message and request copies to forward it on to the adjacent groups. In order to achieve this, two types of control messages are need ed: aCopy Request message to ask a node in a group to forward a copy, and a Reduce Number of Copies message to ask a node in a group to reduce the number of copiesitcurrentlyholds. Thelattermessagegeneratesarespons eindicatinghow many copies many the node actually managed to remove. The importa nce of these two control messages is detailed in section 3.5.2 below, but it is im portant to stress that these messages are very small and their overhead is negligible compared to the overhead of the Group algorithm message andMessagesin group list that the nodes periodically broadcast. 3.4. Example Fig. 3 details an example of HYMAD message forwarding. In this case, the HYMAD groups have stabilized into two disjoint groups (of diameter 2 ), a black onecontainingnodesA, B,C,andD,andawhiteonecontainingnodes F,E,and G. Node F creates 5 copies of a message for node C. It then adds th e message to 81 AB CD EF G5 1 22 AB CD EF G4 1 3 4 3 AB CD EF G2 3 5 64 AB CD EF G2 3 Active connection Send copy of message Send control messageNode in black group (i.e. ∈ {A,B,C,D }) Node in white group (i.e. ∈ {E,F,G }) Copy of Message Figure 3: Example of message forwarding between two HYMAD Group s. (Full explanation in section 3.4) 9its list of held messages. Upon receiving F’s broadcasted list, node E b ecomes awareof the new message. Being a border node , E periodically receives node D’s distance vector and therefore knows that the message’s destina tion is a member of the black group. E therefore requests (1) a copy from F, who f orwards it on (2). Before transferring the message on to D, F believes (correc tly) that it is white group’s only border node and thus determines that it must sen d 3 copies to the black group. E then asks F to reduce its number of copies by 2 , to which F answers positively (3). Now that E has its 3 copies, it forwards the m on to D (4). D receives these copies and realizes that they are for C. Thr ough its intragroup routing protocol, D knows that the shortest path to C runs through A. It therefore transmits the message to A (5), which then forwa rds it to C (6) for a successful delivery. Had C not been the ﬁnal destination for the message, steps 14 wo uld still have occurred, because E would have compared the message lists f rom both the black and white groups and determined that the black group did not h ave a copy of the message. Upon receiving the message, node D would hav e chosen a random custodian for the message within its own group and then fo rwarded the 3 copies to it. 3.5. Discussion 3.5.1. Reacting to topology changes In the previous example, the connectivity conditions were idyllic. But what would have happened if the link between D and E had come down during t he message transfer? The white group would then have had two custo dians of the message, with diﬀerent numbers of copies. What if the link between A and D had broken, thus extending black group’s diameter to 3? Either D or C would have been excluded from it. There are a number of situations, such as when two groups merge, where copiesofagivenmessagecanbedistributedamongseveralgroupm embers. This is not a problem because everyone in the group will be aware of this sit uation through the Messagesingroup list broadcasts. When a border node wishes to send some copies to a neighboring group, it will consider the total nu mber of copies in the group, request a copy from one custodian, determine how many copies to send, and then iteratively ask each custodian to provide e nough copies through Reduce Number of Copies messages. Over time, the group will return to the stable situation of a unique custodian with the last remaining co py of the message for the group. An internal link failure may increase a group’s diameter, thus causing it to split into several separate subgroups. In such a situation, ea ch subgroup only has a fraction of the messages of the original group. Fortuna tely this is not reallya problem. Firstly, the intragroupprotocoldetailed in sectio n 3.2ensures that nodes will update their message lists accordingly when removing nodes from their group member lists, thereby preventing a subgroup fr om advertising messages it does not have or any other such incoherences. Secon dly, certain subgroups may still be connected to each other. If either subgr oup has more 10than one copy of some messages, these will be copied over the othe r subgroup. In any case, HYMAD recovers gracefully from group splits. 3.5.2. Managing the number of copies in a group Because a message can have several custodians within a group, th eReduce Number of Copies signals are necessary to avoid unnecessary retransmissions of the message. Indeed, it would be wasteful for a border node to re quest copies from each custodian. It only needs to get one complete copy, but h as to make sure that the extra custodians reduce their number of copies acc ordingly so as not to create extra copies in the network. A subtle situation app ears when severalborder nodes concurrently demand copies of a same message. How many shouldeachget? Wesolvethisissuebydeterminingthenumberofcop iestosend at the last possible moment, right before forwarding the message t o the next group. There are therefore three steps: (i) ﬁrst send a Copy Request message in order to receive a complete copy, (ii) then estimate the number of c opies held by the groupand the number ofbordernodes to calculate the number nofcopiesto forward on to the neighboring group, (iii) and ﬁnally use of the Reduce Number of Copies messages to ask the message’s custodians to collectively reduce th eir number of copies by n. However, the custodians may only be able to reduce their number of copies by m < nif another border node has requested copies in the meantime. In that case, m+1 copies are forwarded on to the neighboring group. This mechanism ensures that the number of copies of a mess age in the network remains constant at all times. 3.5.3. The cost of clustering Group partitioning, or clustering, in a mobile adhoc network is consid ered a costly and diﬃcult problem. In many approaches, the overhead inc reases with the network dynamics, a single change in topology can lead to a co mplete reclustering of the network, and regular routing cannot functio n until the the clusters have stabilized [22]. However none of these problems arise in our approach. Indeed, sin ce the Group algorithm messages arebroadcastwithapredeﬁnednetworkwideperiod, the speed of topology changes has no eﬀect how often these mess ages are broad cast. On the contrary, high dynamics leads to unstable groups, wh ich means many singleton groups, shorter Group algorithm messages , and ultimately lower overhead. For a more thorough discussion of overhead, refer to Section 4.2. Fur thermore, changes in one group’s composition do not propagate to the entire network. If one or more nodes leave a given group, for example whe n a link goes down, they can only join neighboring groups if they do not incre ase those groups’ diameter beyond Dmax. Otherwise they are simply rejected and remain alone. All group composition changes remain local. Finally, HYMAD does not require nodes to agree on group composition. For example, if a mess age is being sent through the intragrouprouting protocol and an intermedia ry node realises that the destination is not in its group, he will simply stop the routing a nd add the message to his own list of held messages. In any case, HYMAD rec overs gracefully from any inconsistencies. 113.5.4. Choosing the diameter parameter Choosing a diameter parameter for the group selfstabilization algo rithm involves a tradeoﬀ. On the one hand, increasing it will expand each n ode’s individual “knowledge horizon” of the actual network topology. Fe wer copies will cover a larger portion of the network, which will naturally lead to f aster delivery. On the other hand, this comesat the cost ofincreasingth e convergence time of the group service. It may also slightly increase the group ser vice’s overhead (Section 4.2). Ideally, the convergence speed should be considerably faster than the speed of topology changes. In a sense, extreme mobility may fundamentally limit a node’s possible knowledge of the network’s topolo gy. If one is willing to incur the extra cost, the diameter can be set to enc ompass the entire network. In such a situation, HYMAD resembles a resilient MANET routing protocol using storeandforwardfor message transf ers. Furthermore, in many mobile wireless scenarios, there are underlying social dynamics at work whichcansometimesdrivenodestogatherintoloosecommunities. Dmaxshould be chosen so as to allow the expected number of members per social group to neatly ﬁt into one selfstabilizing group. 4. Simulation Results 4.1. Methodology "
412,A Driven Backup Routing Table to Find Alternative Dijoint Path in Ad Hoc Wireless.txt,"The performances of the routing protocols are important since they compute
the primary path between source and destination. In addition, routing protocols
need to detect failure within a short period of time when nodes move to start
updating the routing table in order to find a new primary path to the
destination. Meantime, loss of packets and end-to- end delays will increase
thereby reducing throughput and degrading the performance of the network. This
paper proposes a new algorithm, DBRT (Driven Backup Routing Table), to improve
the existing proactive protocols such as DSDV (Destination Sequenced Distance
Vector) protocol by creating a backup routing table to provide multiple
alternative routes. The DBRT algorithm identifies adjacent nodes for each node
in the same range and then selects one of these as a backup next hop according
to the available path to the destination. The results show that loss of data
packets, throughput and end-to-end delay times between source and destination
are improved. The results show that the new protocol does not degrade the
network's performance despite sending extra messages to construct and update
the new backup routing table. Simulations (using an NS2 simulator) are
undertaken to demonstrate the difference between using a DSDV protocol with or
without the proposed schema.","  In Mobile Ad Hoc Networks (MANET) is unlike the wir ed networks, because there is no  central infrastructure between the nodes.  Each nod e can exchange data dynamically without  the need to a fixed base station or a wired back b one.  Some limitations of the MANET  network have been researched, such as, transmission  power limitation and multiple hops.  This  is because MANET  Uses intermediate nodes to exchange information to pass its traffic to its destination. Hence,  route discovery and maintenance in MANET networks i s an essential issue. The nodes in  wireless ad hoc networks can move frequently and in stantaneously from area to area without  notification, which  leads  to various problems, su ch  as, loss  of connectivity and  an  increase   in the  holding time, during which  a new shortest path  between source and destination is International Journal of Computer Networks & Commun ications (IJCNC) Vol.3, No.4, July 2011   47         computed for the routing table[1].  When a loss in connectivity occurs, not all the nodes on the  topology will be informed. This will generate loops  in the network, which degrade its  performance and reduce throughput. IP recovery will  discover a backup path within a short  period to alleviate loss of packets, reduce endto  end delay and avoid loop in the network [3].  In MANET ad hoc networks, there are various kinds o f main routing protocol tables.  In table based proto cols, each node constructs a routing t able that includes all routes to all nodes on  the topology. The routing protocol needs to send pe riodic messages that contain routing  information to keep the routing table for each node  up to date. In on demandprotocols, nodes  compute routes when they are needed. Ad hoc wireles s networks are frequently affected by  failures when nodes move in and out and of radio pr opagation range.  It is, therefore, highly  desirable to develop a recovery mechanism to improv e the quality of service (QoS) of the  network. In the meantime, loss of data packets and endtoend delays will increase. Many  different types of routing protocols have been used  to solve this routing problem, including  DSDV, Dynamic Source Routing (DSR) and Optimized Li nk State Routing (OLSR) protocols  [4]. In wired networks, the routing protocol genera lly uses distance vectors or link state routing  algorithms. Both are proactive mechanisms as they s end extra messages to keep the nodes up todate in case any information on the network chan ges, such as, if a node joins the network or  it fails. When  failure  occurs,  these  protocols  inform  all the nodes  and  they start  to re compute a new  routing table.  More holding time is  then required in order to resend the traffic  along the new route.  In this  paper,  we propose a  new  algorithm called  Driven  Backup   Routing Table (DBRT) to improve the existing  proac tive routing protocols, such  as, DSDV  and  OLSR to construct a backup routing table based   upon its original that consists  of a  backup path  for each node  to its destination on t he topology. When nodes fail or changed their  positions by moving out of range, DSDV and LS (Link  State) protocols demand that a routing  advertisement be broadcast between the nodes on the  network. In DSDV, when the nodes  receive these advertisements, each one knows the ro ute from its neighbor and its distance to all  the other nodes on the network. On the other hand, OLSR protocols compute the shortest path  based on the complete picture for each adjacent nod e on the network. The DBRT mechanism  aims to recover the network from failure in a short er period by precomputing a backup routing  table by considering more than one node that have m oved or change their positions. The backup  routing table has alternative paths along which to pass the traffic when failure occurs.  The pre computed alternative path can be used immediately w ithout waiting for the routing protocol to  recompute a new one. In this paper, we concentrate  on the scenario when more than one node  moves on the primary path.  The main contribution o f this paper is towards the development of  an alternative and fully disjointed pathway, which is computed. By using a backup routing table  and is based upon the number of adjacent nodes and their ranges.  This paper is organized as follows: Section 2 discu sses related work, Section 3 illustrates the  originality and the basic concept for the DBRT algo rithm in detail, Section 4 shows the  performance evaluation via simulation and concludin g remarks are given section 5.  2 R ELATED WORK   "
222,SDN Partitioning: A Centralized Control Plane for Distributed Routing Protocols.txt,"Hybrid IP networks that use both control paradigms - distributed and
centralized - promise the best of two worlds: programmability and agility of
SDN, and reliability and fault tolerance of distributed routing protocols like
OSPF. The common approaches follow a division of labor concept, where SDN
controls prioritized traffic and OSPF assures care-free operation of best
effort traffic. We propose SDN Partitioning, which establishes centralized
control over the distributed routing protocol by partitioning the topology into
sub-domains with SDN-enabled border nodes, such that OSPF's routing updates
have to traverse SDN border nodes to reach neighboring sub-domains. This allows
the central controller to modify how sub-domains view one another, which in
turn allows to steer inter-sub-domain traffic. The degree of dynamic control
against simplicity of OSPF can be trade off by adjusting the size of the
sub-domains. This paper explains the technical requirements, presents a novel
scheme for balanced topology partitioning, and provides the models for common
network management tasks. Our performance evaluation shows that - already in
its minimum configuration with two sub-domains - SDN Partitioning provides
significant improvements in all respects compared to legacy routing protocols,
whereas smaller sub-domains provide network control capabilities comparable to
full SDN deployment.","THE term hybrid control plane refers to an increas ingly important network architecture, where both control plane paradigms – the logically centralized SoftwareDeﬁned Networking (SDN) and a distributed routing protocol like Open Shortest Path First (OSPF) or Intermediate System to Intermediate System (IS IS) – are deployed in the same routing domain [1], [2]. While the discussion on centralized versus distributed network control planes (e.g., [3], [4]) is lively and ongoing in the networking community, the need for a hybrid networking paradigm, which can combine the advantages of both, has been broadly recognized [5]– [10], not least as it provides the only pragmatic migra tion path to SDN without the expensive replacement of all legacy equipment. Moreover, such an architecture M. Caria and A. Jukan are with the Technische Universit ¨at CaroloWilhelmina zu Braunschweig, 38106 Braunschweig, Ger many, email:fm.caria, a.jukang@tubs.de M. Hoffmann is with Nokia Bell Labs, 81541 Munich, Germany, email: marco.hoffmann@nokia.comallows for a smooth and total cost of ownership opti mized migration to SDN. In fact, many new Internet routers are equipped with an interface for OpenFlow (which is the de facto messaging standard between network devices and SDN controllers) and support a hybrid OpenFlow/OSPF mode. Hybrid control plane ar chitectures typically use the distributed legacy routing protocol for best effort packet forwarding, while the SDN controller injects high priority rules on top for advanced routing conﬁgurations. A typical hybrid SDN operation follows a ”ships passinginthenight” strategy, whereby distributed legacy routing and SDN control paradigms are oblivi ous to what the other one conﬁgures. This is known to create a number of challenges in an operational network, including those related to network failures, size of forwarding tables, routing convergence time, thus impeding the chances for SDN to be deployed in carrier networks. In case of network failures, for instance, the uncorrelated control planes may cause forwarding anomalies, like routing loops and black holes [10]. The size of the router’s forwarding infor mation base (FIB) is also an issue, as routers use ternary contentaddressable memory (TCAM) to per form memory lookups in one clock cycle, which has to be dimensioned economically due to cost, power con sumption, and the required silicon space [11]. A hybrid router, in fact, contains both the OSPF and OpenFlow forwarding tables, which increases the required FIB size signiﬁcantly. Finally, hybrid SDN networks re quire optimization of the SDN router location, or else their advantages become limited. To address the challenges of a hybrid SDN control plane, we propose Centrally Partitioned Distributed Routing Domains as the operational mode and new architecture for hybrid networks, or for short SDN Partitioning . In our approach, SDN switches are used as border nodes to partition the original distributed (e.g., OSPF) routing domain into subdomains. With OSPF, for instance, the SDN nodes appear to their legacy neighbors as regular OSPF routers, while they actually act as simple protocol repeaters that forward all OSPF messages to the centralized SDN controller, where protocol messages can be modiﬁed before they are returned to the sending node and then ﬂooded across the subdomain border. This in turn allows to re conﬁgure the routing of trafﬁc between subdomains by determining the exit border node on a perdestination basis. In our scheme, the distributed routing protocolarXiv:1604.04634v1  [cs.NI]  15 Apr 2016PRELIMINARY VERSION / PREPRINT 2 remains stable at all times, while intersubdomain routes (which contribute the majority of trafﬁc) are controlled in a centralized fashion. This paper details the network architecture with SDN Partitioning, and provides the complete mathematical background of the scheme, including the theory and complexity of LSA generation and the optimization models for typical network management tasks (i.e., trafﬁc engineering, capacity planning, and fault recovery) as well as the used network partitioning method that generalizes a prominent model for the vertex separator problem. Our numerical analysis shows that, in all evaluated measurements, the performance of SDN Partitioning ranges from signiﬁcant improvements to regular OSPF (in its minimum conﬁguration with only two sub domains), up to network control capabilities compara ble to full SDN deployment (with a partitioning in into smaller subdomains). The rest of the paper is organized as follows: Sec tion II discusses the related work. Section III presents the technological background and details the assumed network architecture. Section IV provides the network model, the mathematical background for the gener ation of customized routing updates, and the used graph partitioning approach. The required optimiza tion models for common network management tasks are explained in Section V. Our numerical evaluation is presented in Section VI and Section VII concludes the paper. II. R ELATED WORK AND OURCONTRIBUTION "
413,Adaptive Protocols for Interactive Communication.txt,"How much adversarial noise can protocols for interactive communication
tolerate? This question was examined by Braverman and Rao (IEEE Trans. Inf.
Theory, 2014) for the case of ""robust"" protocols, where each party sends
messages only in fixed and predetermined rounds. We consider a new class of
non-robust protocols for Interactive Communication, which we call adaptive
protocols. Such protocols adapt structurally to the noise induced by the
channel in the sense that both the order of speaking, and the length of the
protocol may vary depending on observed noise.
  We define models that capture adaptive protocols and study upper and lower
bounds on the permissible noise rate in these models. When the length of the
protocol may adaptively change according to the noise, we demonstrate a
protocol that tolerates noise rates up to $1/3$. When the order of speaking may
adaptively change as well, we demonstrate a protocol that tolerates noise rates
up to $2/3$. Hence, adaptivity circumvents an impossibility result of $1/4$ on
the fraction of tolerable noise (Braverman and Rao, 2014).","One of the fundamental questions considered by Computer Sci ence is “What is the best way to encode information in order to recover from channel noise”? This question was studied most notably by Shannon, in a pioneering work [ Sha48 ] which laid the foundation of the rich area of information theory. Shannon considered this question in the context of o ne way communication, where one party wants to transmit a message “once and for all” to anothe r. More recently, in a series of beautiful papers, Schulman [ Sch92 ,Sch93 ,Sch96 ] generalized this question to subsume interactive communication , i.e. the scenario where two remote parties perform some dis tributed computation by “conversing” with each another in an interactive manner, so that each subsequent message depends on all messages exchanged thus far. Surprisingly, Schulman showed that, analogous to the case of one way communication, it is indeed possible to embed any int eractive protocol πwithin a larger protocol π′so that π′computes the same function as πbut additionally provides the requisite error correction to tolerate noise introduced by the channel. The noise in the channel may be stochastic, in which error occ urs with some probability, or adversarial, in which the channel may be viewed as a maliciou s party Eve who disrupts commu nication by injecting errors in the worst possible way. In th is work we focus on adversarial noise. Schulman [ Sch93 ,Sch96 ] provided a construction that turns a protocol πwith communication com plexity T, to a noiseresilient π′which communicates at most O(T) symbols, and can recover from an adversarial (bit) noise rate of at most 1 /240. This result was later improved by Braverman and Rao [ BR11 ,BR14 ], who provided a protocol that can recover from a (symbol) no ise rate up to 1/4−εand also communicates at most O(T) symbols. Both the above constructions assume robust protocols . Intuitively speaking, robust protocols are synchronized protocols that have a ﬁxed length and a predete rmined “order of communication” . In this class of protocols, each party knows at every time step w hose turn it is to speak and whether the protocol has terminated, since these properties are ﬁxe d in advance and independent of the noise introduced by the adversary. However, one can imagine more p owerful, general protocols where the end point of the protocol or the order of speaking are not pred etermined but rather depend on the observed transcript, that is, on the observed noise. While B raverman and Rao show that for any robust protocol 1 /4 is an upper bound on the tolerable noise rate, they explicit ly leave open the question of whether non robust protocols admit a larger amou nt of noise. We address this question by considering two types of nonrob ust protocols, that allow for greater adaptivity in the behavior of the participants. First, we al low the length of the protocol to be adap tively speciﬁed during the protocol by its participants. Ne xt, we consider even greater adaptivity and allow the party that speaks next in the protocol to be adap tively chosen by the participants of the protocol. In both these situations, we show that incre asing adaptivity allows for a dramatic increase in the noise resilience of protocols. We draw attention of the reader to the fact that while for robu st protocols, Yao’s [ Yao79 ] model is almost universally accepted as natural and meaningful, i t is far less obvious what is the right way to model nonrobust protocols, or even if there is a uniqu e choice. Deﬁning models to capture adaptivity is subtle, and several choices must be made, for e xample in how adversarial noise is budgeted and in how to model rounds in which there is no consen sus regarding who the speaker is. Diﬀerent modeling choices lead to diﬀerent protocol cap abilities and we believe it is important to explore the domian of this very young area in order to ﬁnd se ttings that are both natural and admit protocols with higher noise resilience. In a recent work, Ghaﬀari, Haeupler, and Sudan [ GHS14 ,GH14 ], proposed one natural set of choices to model adaptivity, and provided eﬃcient protocol s in that model which resist noise rates of up to 2 /7, surpassing the maximal resilience of the nonrobust case . In this paper we make a 1diﬀerent, but arguably just as natural, set of choices, whic h lead to adaptive protocols with even higher noise resilience. We proceed to summarize the most sa lient diﬀerences in our modeling choices and the ones of [ GHS14 ]. First, the model in [ GHS14 ] does not permit adaptive modiﬁcation of the length of the pr otocol, while our model does. To the best of our knowledge, our work is the ﬁrst to consider varying length interactive protocols and their noise resilience. The seco nd main diﬀerence is that in [ GHS14 ] the channel may be used to communicate only in one direction at ea ch round. Speciﬁcally in [ GHS14 ], at each round, each party decides either to only talkor to only listen : if both parties talk at the same round, a collision occurs and no symbol is transferred, and if both listen at the same round, they receive some adversarial symbol not counted towards th e adversary’s budget. In our model, on the other hand, both parties may talk at the same round with out causing any collision (similar to the case of robust protocols [ Sch96 ,BR14 ]). The adaptivity stems from the parties’ ability to individually choose at each round, whether they talk or not. The two diﬀerent modeling choices taken by [ GHS14 ] and by us lead to diﬀerent bounds on the noise an adaptive protocol can handle. For instance, while t he protocols of [ GHS14 ] can handle up to a relative noise of 2 /7, our protocols can resists a higher noise rate of 1 /3 if the length of the protocol may adaptively change, or noise rate of up to 2 /3 when both the length and the order of speaking adaptively vary. We now give more details about our adaptive model and the noise rate our protocols can resist. 1.1 Our Results: Adaptive Length We begin by considering adaptive protocols in which the length of the protocol may vary as a function of the noise, however the order of speaking is still predetermined. Speciﬁcally, each party individually decides whether to continue participating in the protocol, or terminate and give an output. We denote the class of such protocols as Mterm(see formal deﬁnition in Section 2.1). Intuitively, changing the length of the protocol is useful f or two reasons. First, the parties may realize that they still did not complete the computation, an d communicate more information in order to complete the task. On the other hand, the parties may see that the noise level is so high that there is no hope to correctly complete the protocol. In t his case the parties should abort the computation, since for such a high noise level, the protocol is not required to be correct anyway. The diﬃcult part for the parties is, however, to be able to dis tinguish between the ﬁrst case and the second one in a coordinated way and despite the adversari al noise. If the length of the protocol is not ﬁxed (and subsequently, i ts communication complexity), the noise rate must be deﬁned with care. Generalizing the case of ﬁxedlength protocols, we consider the ratio of corrupted symbols out of all the symbols that were co mmunicated in that instance , and call this quantity the relative noise rate. We emphasize that both the numerator and the deno minator of this ratio vary in adaptive protocols. Our main result for this type of adaptivity is a protocol that resists relative noise rates of up to 1/3 (Theorem 1). The protocol works in two steps: in the ﬁrst ste p Alice communicates her input to Bob using some standard error correction code; in th e second step Bob estimates the noise that occurred during the ﬁrst step, and then he communicates his input to Alice using an error correction code with parameters that depend on his noise est imation. In general, the more noise Bob sees during the ﬁrst step, the less redundant his reply to Alice would be—if there was a lot of noise during the ﬁrst part, the adversary has less budget f or the second part, and the code Bob uses can be weaker. The communication complexity of our protocol above is a cons tant factor (where the constant depends on the channel quality) times the input lengths of Al ice and Bob. However, our protocol 2requires the parties to communicate their inputs, even in ca ses where the lengths of the inputs may be very long with respect to the communication complexity of the best noiseless protocol; thus, the rateof this coding strategy (the length of the noiseless protoco l divided by the length of the resilient protocol) can be vanishing when the length of the noiseless p rotocol tends to inﬁnity. Nevertheless, our coding protocol serves as an important proof of concept f or the strength of this model: Indeed, in the nonadaptive setting, the rate of the coding scheme ha s no eﬀect on the noise resilience. E.g., an upper bound of 1 /4 holds for coding schemes even when their rate is vanishing [ BR14 ]. In addition to our schemes, we show an upper (impossibility) bound of 1 /2 on the tolerable noise in that model (Theorem 2). We emphasize that previous i mpossibility proofs (i.e., [ BR14 ]) crucially use the property of robustness: in robust protoco ls there always exists a party that speaks at most half of the symbols, whose identity is known in advanc e, making it a convenient target for adversarial attack. Contrarily, in adaptive protocols the party that speaks less may depend on the noise and vary throughout the protocol. We provide a new i mpossibility bound by devising an attack that corrupts both parties with rate 1 /2, and carefully arguing that at least one of the parties must terminate before it learns the correct output. Model Lower Bound αUpper Bound βRef. (nonadaptive) 1 /4 1 /4 [ BR14 ] Mterm 1/3 1 /2 §2 Table 1: Summary of our bounds for the Mtermmodel, compared to the nonadaptive model. αandβare the lower (existence) and upper (impossibility) bounds on the a llowed noise rate: for any function there exists a protocol that withstands noise rate cifc < α . Yet, there exists a function for which no protocol withstan ds noise rate β. 1.2 Our Results: Adaptive Order of Speaking Next, we deﬁne the Madpmodel in which we allow the order of speaking to depend on the n oise (see formal deﬁnition in Section 3.1). Speciﬁcally, at each roun d each party decides whether it sends the next symbol or it keeps silent; the other side, respectively , either learns the symbol that was sent, or receives “silence” .4We stress that silent rounds, i.e. when no message is deliver ed, are not counted towards the communication, or otherwise the model becomes e quivalent to the Mtermmodel. We note that this type of adaptivity also implies a varying leng th of the protocol, e.g., in order to terminate, a party simply keeps silent and disregards any in coming communication. Similar to the Mterm model, the adversary is allowed to corrupt any transmission , and we measure the noise rate as the ratio of corrupted transmissio ns to the communicated (nonsilent) symbols. It is important to emphasize that the adversary is n ot limited to only corrupting symbols, but it can also create a symbol when a party decides to keep silent, or remove a transmitted symbol leading the receiving side to believe the other side is silen t. This makes a much stronger adversary5 that may induce relative noise rates that exceed 1. Here we construct an adaptive protocol which crucially uses both the ability to remain silent as well as the ability to vary the length of the protocol, to with stand noise rates <2/3 (Theorem 4). The protocol behaves quite similar to the Mtermprotocol that achieves noise rates up to 1 /3 with an additional layer of encoding that takes advantage of bein g able to remain silent, and provides another factor of 2 in resisting noise. We name this new layer of code silence encoding . The idea behind this layer is that using knonsilent transmissions, one can obtain a code with distan ce 2k. 4A similar notion of party keeping silent was used in interact ive protocols over noiseless channels, by [ DFO10 ,IW10 ]. 5It is easy to show that unless we give the adversary the power t o insert and delete symbols, the model is too strong and the question of resisting noise becomes trivial: in that case the protocol can encode a ‘0’ as a silent transmission, and a ‘1’ as a nonsilent transmission, thus p erfectly resisting any possible noise. 3Then, in order to cause a decoding error, the adversary must i nvest1 22k+1 corruptions, or otherwise either the correct symbol can be decoded, or the symbol becom es an erasures (which is easier to handle than an error). Note that for the special case of k= 1, twocorruptions are required to cause decoding of an incorrect symbol (or otherwise, the adversar y only causes an erasure). The main drawback of the above protocol is that its length (i. e., its round complexity) may be very large with respect to the length of the optimal noisel ess protocol; thus it has a vanishing rate. Next, we restrict the discussion only to adaptive prot ocols whose length is linear in the length of the optimal noiseless protocol (thus their rate is a posit ive constant and not vanishing), and show a protocol with nonvanishing rate that tolerates nois e rates of up to 1 /2 (Theorem 5). The protocol is based on the optimal (nonrobust) protocol of [ BR14 ] with an additional layer of of silence encoding which eﬀectively forces the adversary to “ pay twice” for each error it wishes to make. This way the protocol can withstand twice the number of errors than [ BR14 ]. Model Noise Resilience NonVanishing Rate Ref. nonadaptive 1 /4√[BR14 ] Madp 2/3 §3, §B Madp 1/2√§C Madp(shared randomness) 1√§D Madpover erasure channels 1√§3 (§D) Table 2: Summary of the noise resilience of our protocols in the Madpmodel. For any function f, and for any constant cless than the resilience, there exists a protocol that corre ctly computes fover any channel with relative noise rate c. Note that 1 is a trivial impossibility bound for the Madpmodel, as the adversary can delete the entire communication. If we relax the model to permit the parties to share some rando mness unknown to the adversary, then we can construct a protocol that withstands an optimal 1 −εfraction of errors (Theorem 6) and also achieves nonvanishing rate. The key technique here is to adaptively repeat transmissions that were corrupted by the adversary: each symbol is sent multipl e times until the other side indicates that the symbol was received correctly. However, now the adv ersary can corrupt this “feedback” and falsely indicate that a symbol was received correctly by the other side. To prevent such an attack we use the shared randomness to add a layer of errorde tection (via the so called Blueberry code [ FGOS15 ]). The adversary, without knowing the randomness, has a sma ll probability to corrupt a symbol so it passes the errordetection layer, and corrupt s the sensitive “feedback” symbols with only a negligible probability. An interesting observation is that we can apply our methods t o the setting of erasure channels and obtain a protocol with linear round complexity (i.e., wi th a nonvanishing rate) and erasure resilience of 1 −εwithout the need for a shared randomness (Corollary 1). We no te that for non adaptive protocols over erasure channels, 1 /2 is a tight bound on the noise: a noise of 1 /2−ε is achievable via the BravermanRao protocol (see [ FGOS15 ]) or via the simple protocol of Efre menko, Gelles and Haeupler [ EGH15 ]; on the other hand, a noise rate of 1 /2 is enough to erase the entire communication of a single party, thus disallowing an y interaction [ FGOS15 ]. Our protocol for adaptive settings hints that adaptivity can double the r esilience to noise (similar to the eﬀect of possessing preshared private randomness [ FGOS15 ], etc.). Our bounds for the Madpmodel are summarized in Table 2. 1.3 Related Work. "
225,AICP: Augmented Informative Cooperative Perception.txt,"Connected vehicles, whether equipped with advanced driver-assistance systems
or fully autonomous, require human driver supervision and are currently
constrained to visual information in their line-of-sight. A cooperative
perception system among vehicles increases their situational awareness by
extending their perception range. Existing solutions focus on improving
perspective transformation and fast information collection. However, such
solutions fail to filter out large amounts of less relevant data and thus
impose significant network and computation load. Moreover, presenting all this
less relevant data can overwhelm the driver and thus actually hinder them. To
address such issues, we present Augmented Informative Cooperative Perception
(AICP), the first fast-filtering system which optimizes the informativeness of
shared data at vehicles to improve the fused presentation.
  To this end, an informativeness maximization problem is presented for
vehicles to select a subset of data to display to their drivers. Specifically,
we propose (i) a dedicated system design with custom data structure and
lightweight routing protocol for convenient data encapsulation, fast
interpretation and transmission, and (ii) a comprehensive problem formulation
and efficient fitness-based sorting algorithm to select the most valuable data
to display at the application layer.
  We implement a proof-of-concept prototype of AICP with a bandwidth-hungry,
latency-constrained real-life augmented reality application. The prototype adds
only 12.6 milliseconds of latency to a current informativeness-unaware system.
Next, we test the networking performance of AICP at scale and show that ACIP
effectively filters out less relevant packets and decreases the channel busy
time.","Connected and autonomous vehicles are closer than ever to becoming a reality. Speciﬁcally, modern communication technologies such as cellular vehicletoeverything (CV2X) and dedicated shortrange communications (DSRC) facilitate Pengyuan Zhou is with the Research Center for Data to Cyberspace, University of Science and Technology of China. (email: pyzhou@ustc.edu.cn) Pranvera Kortoc ¸i, Benjamin Finley, Sasu Tarkoma and Jussi Kangasharju are with the Department of Computer Science, University of Helsinki, Finland. (email: ﬁrstname.lastname@helsinki.ﬁ) YuiPan Yau, Tristan Braud and Pan Hui are with Hong Kong University of Science and Technology, Hong Kong. Pan Hui is also with University of Helsinki, Finland. (email: arthur.yau@connect.ust.hk, braudt@ust.hk, pan hui@ust.hk) Xiujun Wang is the with School of Computer Science and Technology, Anhui University of Technology, Anhui, China. (email: wxj@mail.ustc.edu.cn) LikHang Lee is with KAIST, S.Korea and University of Oulu, Finland. (email: likhang.lee@kaist.ac.kr) Corresponding author: Pengyuan Zhoulargescale vehicular communication thanks to signiﬁcant im provements in bandwidth, latency, and reliability. Additionally, novel regulations provide a beneﬁcial legal context for the operation of autonomous vehicles on public roads1. This paves the way for the deployment of applications that leverage vehic ular communication to provide more information to human and AI drivers, thus improving road safety. Currently, autonomous vehicles and advanced driverassistance systems (ADAS) rely heavily on onboard sensors to identify and evaluate poten tial dangers and take necessary actions. More speciﬁcally, advanced vehicles employ various sensors to observe the environment, a perception module for sensor data fusion [1], a path planning module for route planning based on previous modules [2], and a control module for maneuver decision [3]. However, most current solutions are limited to a singlevehicle point of view, sensing only the nearby objects within their line ofsight. As such, the vehicle’s sensing capabilities are regu larly obstructed by other vehicles, and thus depriving the driver of potentially useful information. Leveraging current and fu ture communication networks, the vehicle can aggregate the perception of multiple nearby vehicles, i.e., cooperative (col lective) perception [4], [5], and provide a driver (human or AI) with a holistic view of the road situation. This concept has been adopted by the European Telecommunications Standards Institute (ETSI), which is working on Cooperative/Collective Perception Service standardization [6], [7]. Existing works focus on timely and synchronized infor mation distribution, data fusion, or communication overhead while the informativeness2of the shared perception data has been largely overlooked [4], [5], [8]–[11]. Cooperative perception, and more generally safety applications that rely on communication among vehicles, require deployment at scale to provide a holistic vision of the road. Such a pervasive deployment leads to a signiﬁcant strain in terms of network, computation resources, and driver awareness caused by the constant information dissemination across a large number of vehicles. Meanwhile, only part of the disseminated in formation is of interest to the context of each driver [12]. For example, parking space is more important for drivers in parking lots, while pedestrians require more attention for drivers near intersections. 1https://www.theverge.com/2018/2/26/17054000/selfdrivingcar californiadmvregulations 2The timeliness with which we receive given messages as well as the data contained within is strictly related to the capability to identify potential harm causing objects. We incorporate these notions into the term informativeness and use it throughout the rest of the article for the sake of conciseness.arXiv:2101.05508v3  [cs.MM]  25 Feb 2022IEEE TRANSACTIONS ON INTELLIGENT TRANSPORTATION SYSTEMS 2 CARCARCARPPLPPLPPL CARCARCARPPLPPLPPL Fig. 1: Illustration of a na ¨ıve cooperative perception system. Aleading vehicle detects objects shown in orange bounding boxes (top ﬁgure). These objects are displayed to the driver of thefollowing vehicle in green bounding boxes (bottom ﬁgure). AICP ﬁlters such objects to only show critical ones (e.g., the pedestrians in the pink bounding box) to reduce onscreen object overload. Figure 1 shows an example of a following vehicle’s vision in a leadingfollowing vehicle scenario with na ¨ıve cooperative perception with augmented reality (AR). The leading vehicle captures the objects within its lineofsight and broadcasts information about the detected objects. The following vehicle calculates the position transformations and renders all the objects, shown in green boxes, from the received messages. Extending such a system to cityblocklevel perception with no information ﬁltering leads to a massive number of extraneous objects (given the context) being displayed to the drivers. This overwhelms their vision and thus negatively impacts their driving experience. In fact, a driver’s decision time increases logarithmically with the number of stimuli or objects [13]. Additionally, limiting the number of objects to the human cognition capacity of about 7 2 items [14] is essential. As such, cooperative perception requires an efﬁcient ﬁltering system. For instance, such a system might select the pedestrian shown in the pink box in Figure 1 as critical and display their information while safely discarding the remaining objects. The ETSI standards and a few recent works [9], [15] have proposed highlevel descriptions of potential ﬁltering rules and mechanisms. However, there are still many topics of dedicated system design that have not been explored. Such is the case of ﬁnegrained protocols that provide efﬁcient data ﬂow with lightweight operations, as well as fastﬁltering algorithms that optimize the informativeness of objects in realtime. In this paper, we propose AICP, the ﬁrst solution that focuses on optimizing informativeness for pervasive cooperative percep tion systems with efﬁcient ﬁltering at both the network and application layers. AICP identiﬁes, transmits, forwards, and ﬁlters objects at scale and displays the most informative onesto the drivers through AR. Such an ARbased system will be useful even for vehicles with level four automation (which experts estimate could be at least ten years from wide scale deployment3), since with this automation level drivers may still need to take vehicle control in some complex situations (as compared to fully autonomous level ﬁve). Speciﬁcally, we make several key contributions as follows. (1)We propose a system design for AICP. The design includes a dedicated data structure, the vehicular data unit (VDU), designed for informativenessfocused information ﬁltering and transmission. We also describe the fullstack networking pro tocol, Contextual Multihop Routing (CMR), that the system employs to utilize VDU. (2)We formulate the informativeness in cooperative percep tion systems as a multilevel problem, namely the object , message , and vehicle level , and propose a near realtime sorting algorithm based on Mahalanobis distance for fast yet comprehensive ﬁltering. The algorithm provides ﬁltering at the application level to display only the most important information shared by nearby vehicles and thus preventing drivers from information overload. (3)We implement a proofofconcept (POC) prototype using a cooperative perception application on an Augmented Real ity Headup Display (ARHUD). We demonstrate the system performance in different contexts via datadriven tests using the data collected with the prototype from road tests. Next, we evaluate the networking performance of AICP at scale. Due to the limit of the testbed, we conducted simulations using a stateoftheart vehicular network simulator. We note that AICP is networkagnostic and does not depend on any particular feature of the underlying network. The system can be seamlessly integrated into current and future communication systems such as CV2X and DSRC. The rest of the paper is structured as follows. Section II discusses related works and states the key motivations be hind AICP. Section III details the system architecture, data structure, and routing protocol. Section IV models the sys tem and formulates the problem. Section V describes the weighted ﬁtness sorting algorithm to calibrate the assessment of informativeness. Section VI shows the POC implemen tation of AICP and its performance in different contexts. Section VIC presents the simulation setup and results. Fi nally, Section VII discusses system limitations and potential solutions, and Section VIII concludes the work. II. R ELATED WORK "
178,Streaming Zero-Knowledge Proofs.txt,"We initiate the study of zero-knowledge proofs for data streams. Streaming
interactive proofs (SIPs) are well-studied protocols whereby a space-bounded
algorithm with one-pass access to a massive stream of data communicates with a
powerful but untrusted prover to verify a computation that requires large
space.
  We define the notion of zero-knowledge in the streaming setting and construct
zero-knowledge SIPs for the two main building blocks in the streaming
interactive proofs literature: the sumcheck and polynomial evaluation
protocols. To the best of our knowledge all known streaming interactive proofs
are based on either of these tools, and indeed, this allows us to obtain
zero-knowledge SIPs for central streaming problems such as index, frequency
moments, and inner product. Our protocols are efficient in terms of time and
space, as well as communication: the space complexity is $\mathrm{polylog}(n)$
and, after a non-interactive setup that uses a random string of near-linear
length, the remaining parameters are $n^{o(1)}$.
  En route, we develop a toolkit for designing zero-knowledge data stream
protocols, consisting of an algebraic streaming commitment protocol and a
temporal commitment protocol. The analysis of our protocols relies on delicate
algebraic and information-theoretic arguments and reductions from average-case
communication complexity.",1.1 Zeroknowledge in the streaming model . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Main results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2.1 Streaming commitment protocols . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.3 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.4 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 
152,A Mechanism for Detection of Gray Hole Attack in Mobile Ad Hoc Networks.txt,"Protecting the network layer from malicious attacks is an important and
challenging security issue in mobile ad hoc networks (MANETs). In this paper, a
security mechanism is proposed to defend against a cooperative gray hole attack
on the well known AODV routing protocol in MANETs. A gray hole is a node that
selectively drops and forwards data packets after it advertises itself as
having the shortest path to the destination node in response to a route request
message from a source node. The proposed mechanism does not apply any
cryptographic primitives on the routing messages. Instead, it protects the
network by detecting and reacting to malicious activities of any node.
Simulation results show that the scheme has a significantly high detection rate
with moderate network traffic overhead.","A Mobile Ad Hoc Network (MANET) is a group of mobile  nodes that cooperate and forward packets for each other. Such  networks extend the limited wireless transmission range of  each node by multihop packet forwarding, and thus they are  ideally suited for scenarios in which predeployed  infrastructure support is not available. MANETs have some  special characteristic features such as unreliable wireless links  used for communication between hosts, constantly changing  network topologies, limited bandwidth, battery power, low  computation power etc. While these characteristics are essential  for the flexibility of MANETs, they introduce specific security  concerns that are either absent or less severe in wired networks.  MANETs are vulnerable to various types of attacks including  passive eavesdropping, active interfering, impersonation, and  denialofservice. Intrusion prevention measures such as strong  authentication and redundant transmission should be  complemented by detection techniques to monitor security  status of these networks and identify malicious behavior of any  participating node(s). One of the most critical problems in  MANETs is the security vulnerabilities of the routing  protocols. A set of nodes may be compromised in such a way  that it may not be possible to detect their malicious behavior  easily. Such nodes can generate new routing messages to  advertise nonexistent links, provide incorrect link state  information, and flood other nodes with routing traffic, thus  inflicting Byzantine failure in the network. In this paper, we  discuss one such attack known as Gray Hole Attack  on the  widely used AODV (Ad hoc Ondemand Distance Vector)  routing protocol in MANETs. A mechanism is presented to detect and defend the network against such an attack which  may be launched cooperatively by a set of malicious nodes.   The rest of the paper is organized as follows. Section II  discusses some related work on routing security in MANETs.  Section III defines and discusses various types of gray holes  attacks on MANETs. Section IV describes the details of the  proposed mechanism for detection of gray hole nodes. Section  V presents the simulation conducted on the proposed  mechanism and the performance analysis of the scheme.  Section VI concludes the paper while highlighting some future  scope of work.   II. RELATED WORK  "
358,Performance Evaluation of AODV & DSR with Varying Pause Time & Speed Time Over TCP & CBR Connections in VANET.txt,"VANET (Vehicular Ad-hoc Network) is a new technology which has taken enormous
attention in the recent years. Vehicular ad hoc network is formed by cars which
are called nodes; allow them to communicate with one another without using any
fixed road side unit. It has some unique characteristics which make it
different from other ad hoc network as well as difficult to define any exact
mobility model and routing protocols because of their high mobility and
changing mobility pattern. Hence performance of routing protocols can vary with
the various parameters such as speed, pause time, node density and traffic
scenarios. In this research paper, the performance of two on-demand routing
protocols AODV & DSR has been analyzed by means of packet delivery ratio, loss
packet ratio & average end-to-end delay with varying pause time, speed time and
node density under TCP & CBR connection.","VANET (V ehicular adhoc network) is an autonomous & self  organizing wireless communication network. In this network  the cars are called nodes which involve themselves as servers  and/or clients for exchanging & sharing information. This is a  new technology thus government has taken huge attention on  it. There are many research projects around the world which  are related wit h VANET such as COMCAR [1], DRIVE [2],  FleetNet [3] and NoW (Network on Wheels) [4], CarTALK  2000 [5], CarNet [6].     There are several VANET applications such as Vehicle  collision warning, Security distance warning, Driver  assistance, Cooperative driving, C ooperative cruise control,  Dissemination of road information, Internet access, Map  location, Automatic parking, and Driverless vehicles.     In this paper, we have evaluated performance of AODV and  DSR based on TCP and CBR connection with varying pause  time, speed time and also various network parameters and  measured performance metrics such as packet delivery ratio, loss packet ratio and average end toend delay of this two  routing protocol and compared their performance. The  remainder of the paper is  organiz ed as follows: Section 2   describes previous work related to performance evaluati on of  AODV and DSR and section 3  discusses about two unicast  routing protocols AODV and DSR of VANET . Section 4  describes connection types like TCP and CBR. Section 5  presents performance metrics and the network parameters.   Section 6 presents our implementation. Section 7 presents our  decisions. We conclude in Section 8 and at the end add  references.   2.RELATED WORK   "
457,Improving energy efficiency in MANET's for healthcare environments.txt,"Now a day ad hoc mobile networks (MANETs) have lots of routing protocols, but
no one can meet maximum performance. Some are good in a small network; some are
suitable in large networks, and some give better performance in location or
global networks. Today modern and innovative applications for health care
environments based on a wireless network are being developed in the commercial
sectors. The emerging wireless networks are rapidly becoming a fundamental part
of every single field of life. Our proposed DEERP framework gives a better
performance as compared to other routing protocol.","developed for  adhoc networks. The cap ability to enhance health care telemetry with  wearable miniature wireless sensors would have a deep impact on several ways of medical  practice. In terms of efficiency the small portable wireless devices plays an important role in  the health care environmen t and to provide essential support to patients. Wireless health care  monitors/ equipments are available in the market for example, blood  pressure monitors [1, 2],  pulse Oximeters [3, 4], maternal uterine and fetal heart rate monitors [5], Wireless ECG  Syste m [6], and EKGs  (Electrocardiographs) [7, 8, 9]. During disaster recovery or a group  of casualty, the doctor fixes small sensors on each patient and monitor the results using  Laptop and PDAs . In fig 1 (a), (b) and (c) some wireless devices used in the heal th care  environment.                   Fig 1:  (a) Motion capture  and EMG   (b) Pulse Oxi meter            (c) EKG     In the health care environment, a huge importance is placed on data integrity, availability and  security. Now a day private and public key  security  is implemented in the security of data in  adhoc networks [10, 11, 12]. Due to mobility and congestion packet loss may be  compromised.  Multiple doctors or nurses can receive patient data using multicast semantics  support on the network layer. Due to mobi lity of patients, doctors and nurses quickly route         changes, therefore energy efficient and multi hop routing protocols are required in health  care environments.      Ad hoc network building a network without any structure and set of hosts who are agreed to  establish a connection or communication with each other exclusive of any centralized  administration [13]. Each mobile device in an ad  hoc network acts as a router. Wireless  MANET is ideal for every application of our daily life due to its mobility and acce ssibility  everywhere. Now a day Mobile Ad hoc Network (MANET) is a quickly rising technology,  due to its self motivated topology and unique nature of scattered resources. Wireless  MANET is rapidly emerging and trendy topology in almost all fields like medi cal, healthcare,  banking and commerce, etc. Currently, wireless  MANETs are becoming very popular and  many routing protocols have been suggested by researchers. We give a brief introduction to  wireless networks and discuss the issues and challenges regarding  to performance and  efficient use of energy. We are concerned with energy efficiency and select some  wellknown energy efficient routing protocols, and  simulate  these protocols in NS2 and  analyze  energy efficiency in different cases.  MANET has principles du e to which controls  the number of hosts and route all packets between the mobile hosts in their wireless networks.  MANET faces a lot of challenges, but we focus energy efficiency and performance. The  energy efficiency and performance evaluation are two ver y important and critical challenges  for routing protocols. Some routing protocols to have maximum packet delivery ratio and  throughput, some have less end toend delay and minimum routing overhead; some consume  less energy during idle mode; some consume le ss energy during receive mode, and some  consumes less energy during transmit mode. On the other hand, some routing protocols to  perform skillfully in small networks and some perform skillfully in large networks.     A mobile Ad hoc network –MANET consists of m obile devices that are placed without any  predefine pattern and regularly changing their position and connected with each other.  The  main aim of routing protocol is to discover routes from source to destination node and use the  best and most efficient rou te. In case of route error the routing protocol switches to the other  suitable route. During the establishment of and preservation of the route a less overhead and  bandwidth utilization should be made [14]. We discuss in this research article, how  healthca re networks use ICT (Information and Communications Technology) has been  developed, and what sort of impact they have on the present health care system. We consider  the fittings of mobile technologies in healthcare environments. We spotlight on WPAN  (Wirel ess Personal Area Network) technologies, explicitly, IEEE 802.11 standard. Our  research work has based upon the recent results on the energy efficiency and performance of  routing protocols. Our proposed framework is to choose appropriate routing protocols,  which  give good performance the necessary implementation changes required to incorporate  existing routing protocols in our framework. In our framework, we use only proactive and  reactive routing protocols. The proposed framework presents wide assessment, using a very  famous network simulator NS2. On the basis of our results that our proposed framework  improves energy efficiency and performance as compared with other selected routing  protocols.     2. Related work . It is specified in recent research [15] that  each protocol is  "
155,Surveying Solutions to Securing On-Demand Routing Protocols in MANETs.txt,"A Mobile ad hoc Network or MANET is a wireless network of mobile devices that
has the ability to self-configure and self-organise and is characterised by an
absence of centralised administration and network infrastructure. An
appreciable number of routing protocols used in a typical MANET have left the
critical aspect of security out of consideration by assuming that all of its
constituent nodes are trustworthy and non-malicious. In this paper, we discuss
some of the major threats that such networks are vulnerable to, because of
these inherently insecure protocols. The focus is specifically on the
source-initiated and on-demand routing protocols. Further, solutions and
modifications to these protocols that have been proposed over time, enabling
them to mitigate the aforementioned threats to some extent, are also analysed.","A mobile ad hoc network  (MANET) consists of nodes  that communicate with each other via wireless mediums.  These nodes also function as router s and forward packets  to others . MANETs , by their very nature, do not have any  centralised administrati on nor require an y fixed network  infrastructure and t his makes it quite easy to set up the  network quickly.   Routing in such networks is achieved via the use of a  number of specific protocol s that attempt to counter the  challenge posed by dynamic topologies and are widely in  use today. Although numerous  ad hoc network routing  protocols (D ynamic State Routing (DSR) [1], A d hoc on  demand vector (AODV) [2]) have been proposed, they  have generally assumed a n environment where all the  nodes are co operative and trustworthy and no security  mechanism has been c onsidered  [3][23]. We consider  only the on demand routing protocols AODV and DSR in  this paper on account of their dynamic nature , better  performance with lesser overhead  and also their wider  acceptance.    2. VULNERABILITIES IN  MANET s   MANETs suffer from a number of vulnerabilities owing ,  primarily,  to the fact that  they depend on their constituent  nodes to function effectively.  Malici ous nodes may  interfere with the smooth functioning of the network  through quite a few ways, as described below.     2.1  Identity Spoofing   Media Access Control (MAC) and Internet Protocol (IP )  addresses are frequently used in MANETs to verify and  ascertain the identity of its nodes. However, these  addresses may be easily spoofed using tools that are  publicly available , which leads  to a spoofing attack  [5]. In  this attack, the malicious user  attempts to acquire the  identity of a legitimate node  in the network.  Masquerading as a legitimate user allows the malicious  node  to avail of privileged services , that are otherwise  accessible to only genuine nodes,  and become an  authorized entity in the network. This attack aims to   establish a connection that will enable  the attacker to  access the  sensitive data of the other hosts [6] [7].     2.2  Denial of Servic e (DoS)   DoS is one of the most well known attacks on computer  networks largely because of the impact it has on the  smooth functioning of the network. This kind of attack is  especially damaging to MANETs owing to the limited  communication bandwidth and resources of the nodes [8].   In the AODV protocol for instance, a large number of  RREQs (message requests) are sent to a destination node  on the network that is non existent . As there is no reply to  these RREQs, they will flood the entire network leading  to a consumption of  all of the node battery power, along  with network bandwidth and this could lead to denial of service.     2.3  Black Hole Attack   The goal of the malicious node in this attack, is to drop all  packets that are directed to it instead of forward ing them  as intended. It uses its routing protocol in order to  advertise itself as having the shortest route  to the target  node or to any  packet that it wants to intercept.      The malicious node  advertises its availability of new  routes without  checking its routing table [12]. In this way  the malicious node will always have availability  of routes  while  replying to the route request and hence  intercept the  data packet.  As a result of the dropped packets, the  amount of retransmission consequently increases leading  to congestion.   There is a more subtle form of this attack wherein the  attacker selectively forwards packets instead of dropping  all of them altogether. Packets originating from some  particular nodes may be modified or suppressed while  leaving the data from the other nodes unaffected, thus   limiting  the suspicion of its malicious behaviour  by the  other nodes [13].     2.4  Wormhole Attack   A w ormhole [10] is a c ombination  of two or more  malicious nodes belonging to the ad hoc network that are  connected  by a faster, direct connection . In this kind of  attack , an attacker  records information at a source or  origin , tunnels it through this channel to a target  point   and retrans mits the information in the neighbourhood of  the destination. The two nodes are more than one hop  away from each other on the network.   Since a wormhole attack can be launched without  compromising any node or even the integrity and authenticity of the communication and is implemented  with very few resources, it is difficult to detect  [11].    2.5  R outing Table  / Cache  Poisoning   In this kind of attack, hostile nodes  in the networks send  fictitious routing updates or modify genuine route update  packets that are sent to other uncompromised nodes.  Routing table poisoning may result in sub optimal  routing, congestion in portions of the network, or even  make some parts of the network inaccessible  [13]. In the  case of on demand rout ing protocols that we are  considering,  each node maintains a route cache, that  contains information about specific routes that have  become well known or have been frequently used and an  adversa ry may  also poison the route cache to achieve  similar objectives.     2.6  Colluding Attacks   This kind of threat is encountered when two or more  nodes collude in order to disrupt the smooth functioning  of the network by modifying or dropping all packets  addressed to them.   Apart from being difficult to detect, it can also cause a  significant amoun t of damage and poses a more serious  threat th an similar attacks such as the b lack hole attack.  The authors of [14]  discuss this in the OSLR protocol  and show that two colluding nodes can take down a  maximum of 100 percent of data packets.     2.7  R ushing Attacks   In [18], the authors discuss an attack called the “Rushing”  attack  that acts as an effective denial ofservice attack . In  this attack, the route request  (RREQ)  packet sent by the  source node to the malicious node is flooded throughout  the network b y this malicious no de quickly enough to  prevent other nodes from reacting to the same RREQ.  The  other nodes that receive the duplicate RREQ from the  attacker simply ignore them. Hence, any route discovered  by the source node will have the malicious node as  an  intermediate point in the route [13].  Most of the current  ondemand ad hoc routing protocols are vulnerable to this  attack due to the fact that most of them use duplicate  suppression during the route discovery process. None of  the on demand protocols, including SAODV, SRP,  Ariadne, SAR and ARAN  (that were all designed to be  secure ) are affected by rushing attacks since thes e are  extremely d ifficult to detect.     3. METHODS PROPOSED TO SECURE ON    "
32,Sensors Lifetime Enhancement Techniques in Wireless Sensor Networks - A Survey.txt,"Wireless Sensor Networks are basically used for gathering information needed
by smart environments but they are particularly useful in unattended situations
where terrain, climate and other environmental constraints may hinder in the
deployment of wired/conventional networks. Unlike traditional networks, these
sensor networks do not have a continuous power supply at their disposal. Rather
the individual sensors are battery operated and the lifetime of the individual
sensors and thus the overall network depend heavily on duty cycle of these
sensors. Analysis on WSNs shows that communication module is the main part
which consumes most of the sensor energy and that is why energy conservation is
the major optimization goal. Since routing protocols and MAC protocols directly
access the communication module therefore the design of protocols in these two
domains should take into account the energy conservation goal. In this paper,
we discuss different state-of-the-art protocols both in MAC and routing domains
that have been proposed for WSNs to achieve the overall goal of prolonging the
network lifetime. The routing protocols in WSNs are generally categorized into
three groups - data centric, hierarchical and location-based but we focus on
only the first two categories because location-based routing protocols
generally require a prior knowledge about sensors location which most of the
times is not available due to random deployment of the sensors. We then discuss
how schedule-based and contention-based MAC protocols can contribute to achieve
optimal utilization of the limited energy resource by avoiding or reducing the
chances of collisions and thus the need for retransmission.","WIRELESS  Sensor Network (WSN) is a network of large  numbers – up to thousands – of tiny spatially distributed  radioequipped sensors. Each node in a sensor network is composed of a radiotransducer, a small microcontroller  and a long lasting battery for energy source. These sensor  networks are used for gathering information needed by smart environments and are particularly useful in  unattended situations where terrain, climate and other  environmental constraints may hinder in the deployment of wired/conventional networks. An individual node failure is  not an issue because of the large scale deployment of these  nodes and normally the target area is monitored by several nodes. Primarily these sensors are used for data acquisition  and are required to disseminate the acquired parameters to  special nodes called sinks or basestations over the wireless link as shown in figure 1. The basestation or sink collects  data from all the nodes, and then analyzes this data to draw  conclusions about the ongoing activity in the area of interest [1]. Sinks or base stations being powerful data  processors can act as gateways to other existing  communications infrastructure or to the Internet where a user can have access to the reported data.                       In this paper, we first describe what is main optimization  goal of WSNs? We then describe in detail what efforts  have been made with regards to achieve energy conservation in WSNs in section 3, where we essentially  discuss routing and media access protocols for WSNs.  Finally, section 4 concludes our discussion and points out some future innovations in this field.  2 PROBLEM STATEMENT  Analysis on WSNs shows that communication module is the main part which consumes most of the sensor energy  Fig. 1. Sensor Network Architecture JOURNAL OF COMPUTING, VOLUME 2, ISSUE 5, MAY 2010, ISSN 21519617  HTTPS://SITES.GOOGLE.COM/SITE/JOURNALOFCOMPUTING/ WWW.JOURNALOFCOMPUTING.ORG       35 and that is why energy conservation is the major  optimization goal. Keeping in mind the energy constraints combined with a typical deployment of large number of  sensor nodes pose many challenges to the design and  management of WSNs and necessitate energyawareness at all layers of the networking protocol stack [2]. In addition  to routing protocols, the MediumAccessControl (MAC)  protocols directly control the communication module so protocols in these two domains need to be reshaped in such  a way to optimally utilize the energy resource.   3 METHODOLOGY  "
299,Enhanced Minimal Scheduling Function for IEEE802.15.4e TSCH Networks.txt,"MAC layer protocol design in a WSN is crucial due to the limitations on
processing capacities and power of wireless sensors. The latest version of the
IEEE 802.15.4, referenced to as IEEE 802.15.4e, was released by IEEE and
outlines the mechanism of the Time Slotted Channel Hopping (TSCH). Hence,
6TiSCH working group has released a distributed algorithm for neighbour nodes
to agree on a communication pattern driven by a minimal scheduling function. A
slotframe contains a specific number of time slots, which are scheduled based
on the application requirements and the routing topology. Sensors nodes use the
schedule to determine when to transmit or to receive data. However, IEEE
802.15.4e TSCH does not address the specifics on planning time slot scheduling.
In this paper, we propose a distributed Enhanced Minimal Scheduling Function
(EMSF) based on the minimal scheduling function, which is compliant with
802.15.4e TSCH. In this vein, we introduce a distributed algorithm based on a
Poisson process to predict the following schedule requirements. Consequently,
the negotiation operations between pairs of nodes to agree about the schedule
will be reduced. As a result, EMSF decreases the exchanged overhead, the
end-to-end latency and the packet queue length significantly. Preliminary
simulation results have confirmed that EMSF outperforms the 802.15.4e TSCH MSF
scheduling algorithm.","The next industrial revolution is announced to be Industry 4.0, which will reduce cost and maximize ﬂexibility with the use of digital automation [1]. The Industrial Internet of Things (IIoT) plans to connect to the Internet a large number of industrial objects. In this regard, it is mandatory for realtime infrastructure to be highly reliable for wireless transmissions. So far, the efforts undertaken in IoT were for besteffort solutions, but industrial applications demand a higher level of control in terms of reliability and delay [2]. For that reason, speciﬁc MAC protocols are needed to add strict guarantees. Deterministic approaches, especially, can be used to allocate a ﬁxed bandwidth to every device or ﬂow. In addition, these approaches can isolate ﬂows, where each type of ﬂow gets a speciﬁc transmission bandwidth. In IEEE 802.15.4e TSCHmode, channel hopping mechanism is used to reduce exter nal interference and fading. TSCH deploys a deterministic approach to avoid collisions by careful scheduling, which involves allocating a group of cells for interfering transmitters to avoid collisions while reducing contention. A number of centralized and distributed scheduling algorithms have been introduced as of date for TSCH [3]. Overprovisioning is a method used to cope with unreliable links in the schedule by reserving a few cells to allow a packet to be retransmitted. However, extra cells leads to an increase in delays and jitter [4]. Network capacity is also reduced if there is too much trafﬁc and/or lack of reliability due to external interference. In order to handle the issues concerning scheduling, routing and internet integration, the IETF IPv6 through the TSCH mode of IEEE802.15.4e was established for an improved integration of the IPv6enabled protocols such as RPL, 6LoWPAN and CoAP [5]. In this paper, we propose an Enhanced Minimal Scheduling Function (EMSF) in order to improve reliability and latency when pairs of nodes are dynamically determining their bandwidth requirements. The proposed algorithm is based on the minimal scheduling function (MSF) schemed for the 6TiSCH networks. Our proposal is designed to meet the following goals: 1) A dynamic scheduling: The proposed scheme allocates and deallocates cells without considering the threshold based mechanism. 2) A reduction of the transmitted data during the scheduling negotiation phase: The EMSF is designed to meet this target by introducing a prediction system model which anticipates the data to be transmitted for each pair of nodes in the next slotframe. 3) A reduced latency: This design is introduced by minimiz ing the overhead control packets in order to diminish the endtoend data transmission delay and the queued data. The remainder of this paper is organized as follows. In section II, we provide an outlook to the 6TiSCH WG over the 802.15.4e TSCH mode. We discuss some background informa tion and related work in section III. The design of the systemarXiv:1901.10591v1  [cs.NI]  29 Jan 2019is described in section IV and V . We illustrate, in section VI, the results of simulations that show the performance of our approach, and we conclude the paper in section VII. II. IEEE 802.15.4 ETSCH A. Concept of IEEE 802.15.4e TSCH The nodes in IEEE 802.15.4e TSCH network communicate using a timeslotted mechanism over multiple frequencies, which follows a Time Division Multiple Access (TDMA) schedule. It partitions the wireless spectrum into time and frequency, which is scheduled over a set period of time. This scheduling is also called a superframe or a slotframe. A node transmits/receives data to/from its neighbours on a predeﬁned timeslot and channel in the schedule. A cell, which is usually 10ms in length, is a basic unit of bandwidth scheduled. The transmitter in a cell sends a data packet to the receiver. Once successfully received, an acknowledgement is sent back by the receiver. Channelhopping improves communication by making it more reliable through diversiﬁcation of frequencies. This statistical mitigation reduces narrowband interference and multipath fading. Cells can contain multiple communi cation links as long as they are not conﬂict links nor links interfering amongst each other. Conﬂict links are those that have the same receiver and/or transmitter. The communication links bounce over a series of available channels in a quasi random way between the superframes. Both the sender and the receiver for each scheduled cell will use Eq.(1) to calculate communication frequency, i.e., f[6]: f=Ff(choset + ASN) mod Nchg: (1) whereFis the mapping function for channel frequency, choffset is the channel offset, ASN is the total number of timeslots, and ﬁnally mod Nchis the modular division of Nch, which refers to the number of available physical channels. ASN is calculated as follows: ASN = KS+T: (2) whereKis the slotframe cycle, Sis the size of the slotframe, andTare the allocated timeslots. B. Scheduling in 6TiSCH networks Recently, 6TiSCH Wireless Group was working to deﬁne a preconﬁgured or learned minimal schedule of a node that joins a network with static scheduling conﬁguration [7]. Vari ous kinds of frame are transmitted and received through cells within a schedule determined by slotted ALOHA protocol. Note that static scheduling within 6TiSCH is used only for speciﬁc situations like during the bootstrapping stage or as a fallback during network failures. For other situations, a scheduling function is used in order to allocate or deallocate cells between neighboring nodes. 6TiSCH uses MSF as a default scheduling function presented in the IETF draft [8]. The allocation policy and the bandwidth estimation algorithm are used by MSF to determine when cells in neighbouring nodes should be added or deleted [9]. In addition, MSF uses a thresholdbased mechanism to mitigate against suddenﬂuctuations and increases in bandwidth by adding or deleting operations. Both add and delete negotiations are similar, however. Despite that, given two nodes A and B in a network, node B contains all slotOffsets of node A candidate cells of the remove CellList requests. Since candidate cells are randomly selected, there is a high likelihood of negotiation errors at node A. This is due to the fact that node B contains fewer cells in CellList with available slotOffsets than NumCells. In addition, other pairs of nodes may use allocated cells that are also used by nodes A and B. This may cause network collisions, which are mitigated by the scheduling function. The minimal scheduling function uses 6top Housekeeping function to track cell usage and performance and to relocate cells that have collided [10]. III. R ELATED WORKS "
342,End-to-End Learning of Driving Models with Surround-View Cameras and Route Planners.txt,"For human drivers, having rear and side-view mirrors is vital for safe
driving. They deliver a more complete view of what is happening around the car.
Human drivers also heavily exploit their mental map for navigation.
Nonetheless, several methods have been published that learn driving models with
only a front-facing camera and without a route planner. This lack of
information renders the self-driving task quite intractable. We investigate the
problem in a more realistic setting, which consists of a surround-view camera
system with eight cameras, a route planner, and a CAN bus reader. In
particular, we develop a sensor setup that provides data for a 360-degree view
of the area surrounding the vehicle, the driving route to the destination, and
low-level driving maneuvers (e.g. steering angle and speed) by human drivers.
With such a sensor setup we collect a new driving dataset, covering diverse
driving scenarios and varying weather/illumination conditions. Finally, we
learn a novel driving model by integrating information from the surround-view
cameras and the route planner. Two route planners are exploited: 1) by
representing the planned routes on OpenStreetMap as a stack of GPS coordinates,
and 2) by rendering the planned routes on TomTom Go Mobile and recording the
progression into a video. Our experiments show that: 1) 360-degree
surround-view cameras help avoid failures made with a single front-view camera,
in particular for city driving and intersection scenarios; and 2) route
planners help the driving task significantly, especially for steering angle
prediction.","Autonomous driving has seen dramatic advances in recent years, for instance for road scene parsing [23,67,79,24], lane following [46,37,17], path planning [12,18,62,63], and endtoend driving models [77,22,21,56]. By now, autonomous vehicles have driven many thousands of miles and companies aspire to sell such vehicles in a few years. Yet, signiﬁcant technical obstacles, such as the necessary robustness of driving models to adverse weather/illumination conditions [67,79,24] or the capability to anticipate potential risks in advance [58,35], must be overcome before assisted driving can be turned into fullﬂetched automated driving. At the same time, research on the next stepsarXiv:1803.10158v2  [cs.CV]  6 Aug 20182 S. Hecker, D. Dai and L. Van Gool Fig. 1: An illustration of our driving system. Cameras provide a 360degree view of the area surrounding the vehicle. The driving maps or GPS coordinates generated by the route planner and the videos from our cameras are synchronized. They are used as inputs to train the driving model. The driving model consists of CNN networks for feature encoding, LSTM networks to integrate the outputs of the CNNs over time; and fullyconnected networks (FN) to integrate information from multiple sensors to predict the driving maneuvers. towards ‘complete’ driving systems is becoming less and less accessible to the academic community. We argue that this is mainly due to the lack of large, shared driving datasets delivering more complete sensor inputs. Surroundview cameras and route planners . Driving is inarguably a highly visual and intellectual task. Information from all around the vehicle needs to be gathered and integrated to make safe decisions. As a virtual extension to the limited ﬁeld of view of our eyes, sideview mirrors and a rearview mirror are used since 1906 [1] and in the meantime have become obligatory. Human drivers also use their internal maps [74,54] or a digital map to select a route to their destination. Similarly, for automated vehicles, a decisionmaking system must select a route through the road network from its current position to the requested destination [76,47,50]. As said, a single frontview camera is inadequate to learn a safe driving model. It has already been observed in [64] that upon reaching a fork  and without a clearcut idea of where to head for  the model may output multiple widely discrepant travel directions, one for each choice. This would result in unsafe driving decisions, like oscillations in the selected travel direction. Nevertheless, current research often focuses on this setting because it still allows to look into plenty of challenges [37,9,77]. This is partly due to the simplicity of training models with a single camera, both in terms of available datasets and the complexity an effective model needs to have. Our work includes a surround view camera system, a route planner, and a data reader for the vehicle’s CAN bus. The setting provides a 360degree view of the area surrounding the vehicle, a planned driving route, and the ‘groundtruth’ maneuvers by human drivers. Hence, we obtainDriving Models with SurroundView Cameras and Route Planners 3 a learning task similar to that of a human apprentice, where a (cognitive/digital) map gives an overall sense of direction, and the actual steering and speed controls need to be set based on the observation of the local road situation. Driving Models. In order to keep the task tractable, we chose to learn the driving model in an endtoend manner, i.e. to map inputs from our surroundview cameras and the route planner directly to lowlevel maneuvers of the car. The incorporation of detection and tracking modules for trafﬁc agents (e.g. cars and pedestrians) and trafﬁc control devices (e.g. trafﬁc lights and signs) is future work. We designed a specialized deep network architecture which integrates all information from our surroundview cameras and the route planner, and then maps these sensor inputs directly to lowlevel car ma neuvers. See Figure 1 and the supplemental material for the network’s architecture. The route planner is exploited in two ways: 1) by representing planned routes as a stack of GPS coordinates, and 2) by rendering the planned routes on a map and recording the progression as a video. Our main contributions are twofold: 1) a new driving dataset of 60 hours, featuring videos from eight surroundview cameras, two forms of data representation for a route planner, lowlevel driving maneuvers, and GPSIMU data of the vehicle’s odometry; 2) a learning algorithm to integrate information from the surroundview cameras and planned routes to predict future driving maneuvers. Our experiments show that: a) 360 degree views help avoid failures made with a single frontview camera; and b) a route planner also improves the driving signiﬁcantly. 2 Related Work "
133,Cryptanalysis of two recently proposed ultralightweight authentication protocol for IoT.txt,"By expanding the connection of objects to the Internet and their entry to
human life, the issue of security and privacy has become important. In order to
enhance security and privacy on the Internet, many security protocols have been
developed. Unfortunately, the security analyzes that have been carried out on
these protocols show that they are vulnerable to one or few attacks, which
eliminates the use of these protocols. Therefore, the need for a security
protocol on the Internet of Things (IoT) has not yet been resolved.
  Recently, Khor and Sidorov cryptanalyzed the Wang et al. protocol and
presented an improved version of it. In this paper, at first, we show that this
protocol also does not have sufficient security and so it is not recommended to
be used in any application. More precisely, we present a full secret disclosure
attack against this protocol, which extracted the whole secrets of the protocol
by two communication with the target tag.
  In addition, Sidorv et al. recently proposed an ultralightweight mutual
authentication RFID protocol for blockchain enabled supply chains, supported by
formal and informal security proofs. However, we present a full secret
disclosure attack against this protocol as well.","Internet of Things (IoT) can be used to control all devices throu gh an Internet connection. IoT covers a wide range of applications at large and sma ll scale. One of the solutions for implementing the IoT is the use of Radio Frequ ency Identiﬁcation (RFID) which allows the connection of various object s via the Internet. Internet technology uses objects in a variety of contexts and, g iven the avail ability of security and privacy, has the ability to make things easy for humans. One of the most fascinating things about the IoT is its ability to smart homes, smart cities, use it in wearable gadgets and also use it in cars. Wearab le gadgetsinclude a series of sensors and use special software to collect their users’ data; these gadgets ultimately analyze aggregateddata such as health, ﬁtness, and the like, and report the results to the user. The IoT can also make cars , with the help of special sensors and of course the Internet, both increas e their safety and the optimal performance of internal components and passenger s’ safety. One of the main issues that has always been raised about the IoT is its secu rity issue. Since this technology connects a lot of devices through t he Internet, hacking them can have irreparable losses, such as losing sensitive pe rsonal and economic information. One reason for this is that either security pr otocols have not been used to secure IoT or that protocols have not been adeq uately se cured. Therefore, a researchers’ challenge in this ﬁeld is to ensur e users’ privacy and the conﬁdentially of their information by developing suitable soft ware and hardware, to be used in Internetbased products. On the other hand, the use of security mechanisms is one of the main prerequisites for protecting the privacy and conﬁdentiality of a variety of applications, and IoT is not an exce ption. 1.1 Related Work and Motivation "
251,Orion Routing Protocol for Delay-Tolerant Networks.txt,"In this paper, we address the problem of efficient routing in delay tolerant
network. We propose a new routing protocol dubbed as ORION. In ORION, only a
single copy of a data packet is kept in the network and transmitted, contact by
contact, towards the destination. The aim of the ORION routing protocol is
twofold: on one hand, it enhances the delivery ratio in networks where an
end-to-end path does not necessarily exist, and on the other hand, it minimizes
the routing delay and the network overhead to achieve better performance. In
ORION, nodes are aware of their neighborhood by the mean of actual and
statistical estimation of new contacts. ORION makes use of autoregressive
moving average (ARMA) stochastic processes for best contact prediction and
geographical coordinates for optimal greedy data packet forwarding. Simulation
results have demonstrated that ORION outperforms other existing DTN routing
protocols such as PRoPHET in terms of end-to-end delay, packet delivery ratio,
hop count and first packet arrival.","Delay/Disruption Tolerant Network (DTN) may often refer  to sparse mobile ad hoc network, where an endtoend routing  path does not necessarily exist. In DTNs, both nodes and links  may be inherently unreliable. Due to these constraints, these  networks are referred to as “challenged networks”  [1]. Many  other emerging communication networks fall into this  paradigm. Vehicular ad hoc networks (VANETs), mobile  sensor networks, and nomadic community networks are few  examples.  An interesting DTN example is the city bus network, in  which nodes consist of buses (cars, taxis, trams…) and  communicate using shortrange radios. With this type of  networks, we can envision a lot of new applications: urban  sensing, information dissemination (advertisement, traffic  information, buses software update…) or even Internet access.  The proper functioning of such applications relies essentially  on the efficiency of the routing task. However many  challenges affect the routing in DTNs such as the changing  network topology due to intermittent connectivity which is  inherent to mobile networks as well as to static networks (in  the case of low duty cycle of the nodes), and it results in low  delivery ratio and high endtoend delay. The problem of  intermittent connectivity can be mitigated if the exact  schedule or the dynamics of the network is known in advance.  However, this is not often the case in DTNs as building this  knowledge is an important issue. Thus, the efficiency of a  DTN routing protocol relies essentially on the amount of  network knowledge or “oracles”  (information about contacts,  queues or even data traffic) available to perform routing  decisions. In this paper, we propose ORION, a routing protocol for  mobile DTNs that capitalizes on the localization information  of the nodes (geocoordinates) and the nature of contacts  between this type of nodes (buses, cars, taxis, trams) in an  urban area. The contribution presented in this paper is  twofold. First, we have investigated the internodes encounter  behavior. Second, based on this behavior analysis, we  proposed ORION, a novel routing protocol that relies on  predicting future contacts between nodes and greedy  geographic forwarding of data packets. Thus, with ORION  protocol, a communicating node will incrementally build  knowledge about its network regarding the internodes  encounters behavior and nodes positions. Thereby, it should  be able to predict when it will be in contact with other nodes  and for how long (duration).  The remainder of this paper is organized as follows.  Section II presents the state of the art for DTN protocols and  the use of stochastic processes and time series analysis in  network communication modeling. Section III presents the  ORION protocol. Section IV provides the simulation results  and related discussion. Finally, section V concludes the paper.   II.  RELATED WORK   "
436,A Distributed Protocol for Detection of Packet Dropping Attack in Mobile Ad Hoc Networks.txt,"In multi-hop mobile ad hoc networks (MANETs),mobile nodes cooperate with each
other without using any infrastructure such as access points or base stations.
Security remains a major challenge for these networks due to their features of
open medium, dynamically changing topologies, reliance on cooperative
algorithms, absence of centralized monitoring points, and lack of clear lines
of defense. Among the various attacks to which MANETs are vulnerable, malicious
packet dropping attack is very common where a malicious node can partially
degrade or completely disrupt communication in the network by consistently
dropping packets. In this paper, a mechanism for detection of packet dropping
attack is presented based on cooperative participation of the nodes in a MANET.
The redundancy of routing information in an ad hoc network is utilized to make
the scheme robust so that it works effectively even in presence of transient
network partitioning and Byzantine failure of nodes. The proposed scheme is
fully cooperative and thus more secure as the vulnerabilities of any election
algorithm used for choosing a subset of nodes for cooperation are absent.
Simulation results show the effectiveness of the protocol.","In a wireless adhoc network, a collection of mobile devices  (referred to as ‘nodes’) with wireless network interf aces form  a temporary network without the aid of any fixed  infrastructure or centralized administration. MANETs h ave  some special characteristic features such as: (i) unreli able  wireless links used for communication, (ii) constantly  changing network topologies and memberships of nodes, (iii)  limited bandwidth of the links, (iv) Low battery lif etime, (V)  Limited computation power of the nodes that prohibit  the  deployment of complex routing protocols and encrypti on  algorithms for security. While these features are essen tial for  flexibility and adaptability of various operations i n MANETs,  they introduce specific security concerns like vulnera bilities to  link attacks including passive eavesdropping, active  interfering, leakage of secret information, data tam pering,  impersonation, messagereplay, message distortion and de nial ofservice. An additional problem in MANETs is the se curity     vulnerability of the routing protocols.  A set of nod es in a  MANET may be compromised in such a way that it may no t  be possible to detect their malicious behavior easily. Such  nodes can generate new routing messages to advertise no n existent links, provide incorrect link state informati on, and  flood other nodes with routing traffic thus inflictin g Byzantine  failure in the network. Another common routing disru ption  attack in MANETs has been packetdropping attack by a   group of malicious nodes. A group of nodes acting in  collaboration may drop packets in the network at such  a rate  that the message communication in the network may be  severely degraded and sometimes even completely disrupt ed.  The detection of these malicious nodes may not be easy as  they work in a group. Although there has been lot of  research  on detection and prevention of such an attack in MAN ETs,  most of these schemes have either low detection rate, h igh  complexity of detection algorithms, security vulnerab ilities in  the schemes themselves or high rate of false positives (S ection  II). In this paper, a mechanism for detection of mali cious  packet dropping attack in MANETs has been presented. T he  scheme involves a collaborative distributed protocol t hat  utilizes complementary relationship between cryptogra phic  key distribution and intrusion detection activity fo r detection  of malicious packet dropping attack. The scheme has be en  evaluated for its performance by implementing it on the  network simulator ns2. The effectiveness and efficiency of  the proposed mechanism has been compared with one of the  currently available schemes and is found to have pro duced  better results.  The rest of the paper is organized as follows. Section II  presents some related work on defense against packet d ropping  attack in MANETs. Section III discusses the details of  the  proposed security mechanism. Section IV presents the  simulations conducted on the mechanism and analyses th e  results. Section V concludes the paper.   II.  RELATED WORK   "
301,Coefficient of Restitution based Cross Layer Interference Aware Routing Protocol in Wireless Mesh Networks.txt,"In Multi-Radio Multi-Channel (MRMC) Wireless Mesh Networks (WMN), Partially
Overlapped Channels (POC) has been used to increase the parallel transmission.
But adjacent channel interference is very severe in MRMC environment; it
decreases the network throughput very badly. In this paper, we propose a
Coefficient of Restitution based Cross layer Interference aware Routing
protocol (CoRCiaR) to improve TCP performance in Wireless Mesh Networks. This
approach comprises of two-steps: Initially, the interference detection
algorithm is developed at MAC layer by enhancing the RTS/CTS method. Based on
the channel interference, congestion is identified by Round Trip Time (RTT)
measurements, and subsequently the route discovery module selects the
alternative path to send the data packet. The packets are transmitted to the
congestion free path seamlessly by the source. The performance of the proposed
CoRCiaR protocol is measured by Coefficient of Restitution (COR) parameter. The
impact of the rerouting is experienced on the network throughput performance.
The simulation results show that the proposed cross layer interference aware
dynamic routing enhances the TCP performance on WMN.
  Keywords: Coefficient of Restitution, Wireless Mesh Networks, Partially
Overlapped Channels, Round Trip Time, Multi-Radio, Multi-Channel.","Ever since the evolution of communication began, qu ality of  service (QoS) has become imperative to be considere d in  computer networks. Nowadays, multimedia communicati on  on the Internet has been dominant communication. Wh en the  number of users on the multimedia communication cha nnel is  increased or more traffic on the Internet, there ma y be packet  loss and quality degradation. The emerging interact ive  applications like multimedia streaming and multipla yer  games demand less round trip time, so RTT plays an  important role in increasing the throughput. Our pr imary aim  is to reduce the RTT, loss rate and collision, caus ed by  interference, for refining TCP performance in WMN.  The IEEE 802.11 b/g network operates in the 2.4GHz ISM  frequency and the frequency spectrum is divided int o 11  channels, in which, three of the channels are nono verlapping  or orthogonal channels such as channel 1, 6 and 11.  Since,  the number of orthogonal channels is limited; it is  not  possible to allocate channels for all the neighbori ng nodes.  Moreover, if the same channel is assigned to more t han one  neighboring node, that will lead to cochannel inte rference in simultaneous transmission and finally, it results i n throughput  degradation. In the event of, one channel overlappi ng with  another channel, for instance, Channel 1 overlaps w ith  channel 3, they are called partially overlapping ch annels.  Most of the existing system design considers POC as  a  danger because it severely affects the transmission  between  the nodes. An efficient channel assignment techniqu e with  POC [13] solves the interference problem and also p roduces  significant improvement in parallel transmission an d  throughput.  Recently, Wireless Mesh Network has been an attract ive  technology platform for Internet service and it cat ers to  diversified segments like academic, Industry and co mmunity  networks [3]. The WMN provides seamless reliability ,  excellent coverage and high performance compared to  the  single hop networks. By exploiting the MRMC in WMN,   greater network throughput can be achieved than the  single  radio single channel, due to the advantage of paral lel  transmissions. In multiradio setup, each node is e quipped  with multiple radios and each radio is assigned to different  channels for simultaneous transmission. Most of the  research  in WMN with IEEE802.11b/g standard, orthogonal chan nels  is used. In this work, we primarily focus on POC, w hich  increases the number of users accessing the Interne t. But the  major problem with POC is that the interference bet ween the  adjacent channels and its effect, as it reduces the  network  throughput badly.   1.1 Congestion in WMN  The densely deployed nodes in IEEE 802.11 WMN can  cause network congestion that leads to a packet dro p, delay  in delivery and frequent disconnection. Generally, the data  from the source is reached in the Internet through the  gateway with multi hop access, so congestion occurs  more  near the gateway, but random at other network desti nations.  Most of the congestion control algorithms in the wi red  networks try to estimate the available capacity, i. e.  bandwidth, queue size in the router, to fix the con gestion  window on the sender side.  These congestion contro l  algorithms do not apparently find the real congesti on status  of the wireless networks because of various reasons , such as  channel interference, mobility and congestion. The various  algorithms [16, 15, 1] have been developed for wire less  networks for refining the ability of TCP to judge t he 2    congestion status more efficiently. These solutions  are  categorized into two kinds:   • EndtoEnd congestion control method:  It reacts  very slowly in wireless networks because of the  waiting time for acknowledgement (ACK) is more.   • HopbyHop congestion control method:  It reacts  quickly to detect the status of the link and  intermediate nodes, and it can make decision  effective.   The hopbyhop delay is accumulated into the endto end  delay, so controlling the single hop delay ensures that the less  amount of end to end delay. Based on the channel ac cess at  each hop, the per hop delay would significantly ch ange.  In this work, the RTS/CTS scheme at the MAC layer i s used  to estimate the congestion status of the link and w e propose a  contention mechanism algorithm at the MAC layer, an d then  hopbyhop RTT is estimated for dynamic routing. Th e  performance of the algorithm is evaluated using the  COR.  The channel busy time and throughput is considered to  measure the network, whether it is highly congested  or not.  Our simulation results show that the proposed metho d can  yield less delay, good throughput and less packet l oss to the  interference situation. It can also provide QoS and  minimize  RTT along the path.  This paper is organized as follows: Section II desc ribes the  existing congestion control and routing algorithms in wireless  networks. In Section III, the system model is expla ined, in  which, contention algorithm in MAC layer is modifie d and  the resultant RTT calculation is presented. The rou ting  algorithm is explained in section IV. The simulatio n settings,  graphs and performance evaluation using COR are ana lyzed  in section V. The paper is concluded and the scope is  discussed in section VI.  2.  Related Work  "
371,Tiramisu: Fast and General Network Verification.txt,"Today's distributed network control planes support multiple routing
protocols, filtering mechanisms, and route selection policies. These protocols
operate at different layers, e.g. BGP operates at the EGP layer, OSPF at the
IGP layer, and VLANs at layer 2. The behavior of a network's control plane
depends on how these protocols interact with each other. This makes network
configurations highly complex and error-prone. State-of-the-art control plane
verifiers are either too slow, or do not model certain features of the network.
In this paper, we propose a new multilayer hedge graph abstraction, Tiramisu,
that supports fast verification of the control plane. Tiramisu uses a
combination of graph traversal algorithms and ILPs (Integer Linear Programs) to
check different network policies. We use Tiramisu to verify policies of various
real-world and synthetic configurations. Our experiments show that Tiramisu can
verify any policy in < 0.08 s in small networks (~35 devices) and < 0.12 s in
large networks (~160 devices), and it is 10-600X faster than state-of-the-art
without losing generality.","Many networks, including university, enterprise, ISP and data center networks, employ complex distributed control planes running atop rich underlying network structures. The control planes run a variety of routing protocols, such as RIP, OSPF, and BGP, which are conﬁgured in intricate ways to exchange routing information both within and across protocols. In some cases, the protocols are assisted byother protocols (e.g., iBGP assisting in distributing BGP information throughout a network). Networks also employ techniques to virtualize the control plane, such as virtual routing and forwarding (VRF), as well as tech niques to virtualize multiple network links into different broadcast domains (VLANs). Bugs can easily creep into such networks, e.g., through errors in the detailed conﬁgurations that many of the protocols need. Often, bugs may not be immediately apparent, and the network may be running “just ﬁne” un til a failure causes a latent bug to be triggered. When bugs do manifest, a variety of catastrophic outcomes can arise: the network may suffer from blackholes; services with restricted access may be rendered wide open; crit ical applications can no longer be isolated from other services/applications, and so on. Veriﬁcation tools and their tradeoffs. A variety oftools attempt to verify if networks are violating, or could potentially violate, policies of the above kind. Data plane veriﬁers [ 13,10,11] analyze the current forwarding ta bles and check for blackholes, loops, or broken path iso lation. Unfortunately, these tools don’t have the means to analyze if the network’s new data plane that materialized upon reacting to a failure, can satisfy relevant policies or not. To overcome this issue, a variety of control plane ana lyzers were developed [ 5,2,16,4,6]. These proactively analyze the network against various environments, e.g., failures or external advertisements. While a signiﬁcant step forward in network veriﬁcation, control plane tools today make tradeoffs between performance and general ity. On the one hand are “graphbased” tools such as ARC [ 6]. ARC encodes all paths that may manifest in a network under various failures into a series of weighted digraphs. This abstraction enables analyzing the network under many potential environments at once by running very fast polynomial time graph algorithms; e.g., check ing if two hosts are always blocked amounts to check ing if they are in different graph connected components. Unfortunately, ARC ignores many network design con structs, including modeling the intricacies of BGP and iBGP, and the existence of VLANs, and VRFs. On the other hand are “SMTbased” tools such as Bag pipe [ 16] and Minesweeper [ 2]. These tools create a detailed model of the control plane by symbolically en coding routing information exchange, route selection logic, and the environment (e.g., failures) using logical constraints/variables. By asking for a satisfying assign ment for a SMT formula that encodes the network and the property of interest, they can identify a concrete en vironment that leads to property violation. These tools offer much better coverage of control plane protocols than graphbased ones, but their veriﬁcation performance is very poor, especially when exploring failures ( §6), despite many internal SMTspeciﬁc optimizations. Decoupling encoding and properties. We ask if it is possible to design a veriﬁcation tool that marries the speed of graphs with the generality of an SMTbased encoding. We start by noting that today the tradeoff between per formance and generality in tools, arises from a coupling between the control plane encoding used in the tools and how properties are veriﬁed. In graphbased tools, thearXiv:1906.02043v1  [cs.NI]  5 Jun 2019weighted graph control plane model requires graph al gorithms to verify properties. In SMTbased tools, the detailed constraintbased control plane encoding requires a general constraint solver to be used for all properties. Our framework, Tiramisu, decouples the encoding from the property: it uses a sufﬁciently rich encoding for the network that models various control plane features and network design constructs. But then, it permits the use of custom algorithms that offer the best performance to verify a property of interest. Richer graphs. Our framework starts with graphs as the basis for modeling networks, because graphbased control plane analysis has been shown to be fast [ 6]. We then embellish the graph model with richer graph constructs, such as hierarchical layering, the notion of hedges [ 7] (edges that fail together), and rich, multi attribute edge and node labels. Our resulting graph can model all aspects we observe used in real world networks and conﬁgurations. Given the graph structure, we then develop a suite of custom techniques that help verify various properties of interest. Avoiding path enumeration. First, we note that some properties of interest do not require the computation of the actual path that the network would induce on a certain failure; they care mostly about whether paths exist or not. An example is whether two hosts are always blocked from each other. For such properties, we develop two techniques that avoid path enumeration altogether: a modiﬁed depth ﬁrst search graph traversal algorithm, and a simple integer linear program (ILP) formulation that computes graph cuts. Importantly, graph traversal runs in polynomial time. And, for a given property, the sim pliﬁed propertyspeciﬁc ILP can be solved much faster than a general SMTencoding in SMTbased tools. This is because the former explores symbolically only the variables that are relevant to the property being veri ﬁed, whereas the SMT solver for the general encoding searches through a much larger search space. Domainspeciﬁc path computation. For the remain ing properties that require computation of paths, we run a modiﬁed path vector protocol atop our richer graph ab straction. Here, we leverage foundational work by Grifﬁn et. al which showed that various routing protocols can be modeled as instances of the stable paths problem [ 8] (this insight was used in Minesweeper), and that a “simple path vector protocol” (SPVP) [ 8] emulates the compu tation of a solution to this problem. In our version of SPVP, each node consumes the multidimensional at tributes of incoming edges and neighboring vertices, and uses simple arithmetic operations that encode existingprotocols’ logic to select among multiple paths available at the moment. Importantly, in simple networks (e.g., those that use a single routing protocol) our protocol naturally devolves to being similar to distance vector protocol, which runs in polynomial time (being based on the BellmanFord algorithm). For more general net works, we empirically ﬁnd that our protocol can quickly compute the paths that are relevant to verifying speciﬁc properties. The performance is faster than SMTbased tools, because our approach essentially uses a highly domainspeciﬁc approach to ﬁnding paths, compared to a SMTbased general search strategy; for instance, even for simple networks, a SMTbased strategy would invoke the solver to ﬁnd a satisfying assignment. Prototype and evaluation. We implemented Tiramisu in Java (7K LOC) and evaluated it with many real data center and university networks, as well as networks from the topology zoo [ 12]. We ﬁnd that Tiramisu’s rich multilayered graphs can be computed from conﬁgurations in a few ms per trafﬁc class. Using Tiramisu’s custom algorithms, various properties can be checked for complex networks in 380ms per trafﬁc class. Compared to Minesweeper that uses a general encod ing with an SMT solver, Tiramisu offers speed of up to 600X for reachability policy veriﬁcation and 1050X for boundedlength and path preference policies (both under failures). Tiramisu’s algorithmic approach renders it sub stantially faster even when verifying properties under no failures. Finally, Tiramisu scales well, providing veriﬁ cation results in100ms per trafﬁc class for networks with160 routers. 2 Motivation Given the signiﬁcant performance beneﬁts of graph ab stractions [ 6], we use graphs as the basis to encode con trol plane computation in Tiramisu. However, the ab straction we use is signiﬁcantly different from ARC [ 6]. In what follows, we provide an overview of ARC’s graph based approach for veriﬁcation. We then identify its key drawbacks which motivate Tiramisu’s graph design. 2.1 ARC ARC (Abstract representation for control plane [ 6]) is a stateoftheart control plane veriﬁer. It models a net work’s control plane using a collection of directed graphs. There is one directed graph per trafﬁc class which models the forwarding behavior of packets belonging to that traf ﬁc class. In ARC, nodes represent routing processes, and directed edges represent possible ﬂow of trafﬁc enabled by exchange of route advertisements between routing processes. Using a single attribute edgeweight, ARC can model OSPF costs and AS path length. Finally, ARC 2Policy class Graph characteristics P1: srcanddstare always blocksrcanddstare in separate compo nents P2:All paths from srctodst traverses a waypointafter removing the waypoint, src anddstare in separate components P3:srccan reach dstwhen there are <K link failuresmincut of src"
276,Secure Routing in IoT: Evaluation of RPL Secure Mode under Attacks.txt,"As the Routing Protocol for Low Power and Lossy Networks (RPL) became the
standard for routing in the Internet of Things (IoT) networks, many researchers
had investigated the security aspects of this protocol. However, no work (to
the best of our knowledge) has investigated the use of the security mechanisms
included in the protocol standard, due to the fact that there was no
implementation for these features in any IoT operating system yet. A partial
implementation of RPL security mechanisms was presented recently for Contiki
operating system (by Perazzo et al.), which provided us with the opportunity to
examine RPL security mechanisms. In this paper, we investigate the effects and
challenges of using RPL security mechanisms under common routing attacks.
First, a comparison of RPL performance, with and without its security
mechanisms, under three routing attacks (Blackhole, Selective- Forward, and
Neighbor attacks) is conducted using several metrics (e.g., average data packet
delivery rate, average data packet delay, average power consumption... etc.)
Based on the observations from this comparison, we came with few suggestions
that could reduce the effects of such attacks, without having added security
mechanisms for RPL.","Routing is one of the most researched ﬁelds in the world of Internet of Things (IoT), due to the constraint nature of these devices. Introduced by Internet Engineering Task For ce (IETF), the Routing Protocol for Low Power and Lossy Net works (RPL) [1] had become the standard for routing in many IoT networks as it was designed to efﬁciently use the constra int resources of IoT devices while providing effective routing service. Routing security was an integral part of RPL’s desi gn with several, but optional, security mechanisms available [1]. Since it became a standard in 2012, RPL gained a lot of research interest, with many of the literature focusing on t he security aspects of routing using the protocol, such as: typ es of routing attacks, new mitigation methods and Intrusion Dete c tion Systems (IDSs), and securityminded Objective Functi ons (OFs) [2]–[6]. Interestingly, there was no research discus sing the effects of using RPL’s security mechanisms, speciﬁcall y under routing attacks. This is most probably due to the lack o f implementation of RPL’s security mechanisms in any of the available IoT Operating System (OS), such as Contiki OS [7] and TinyOS [8]. However, recently Perazzo et al. in [9] provided a partial implementation of RPL’s security mechanisms for Contiki OS , which added the Preinstalled secure mode and the optionalreplay protection mechanism. This implementation provide d us with the basis upon which the work in this paper is built on. In this paper, we have experimentally investigated RPL’ s performance under three common routing attacks using sever al metrics to analyze and compare the performance between having RPL’s security mechanisms enabled or disabled. Our contributions can be summarized in the following points: (1)We provided a performance comparison for RPL between the unsecure mode and the Preinstalled secure mode; the latter case is examined with and without the optional replay protection. We discovered that running RPL in the Preinstalled secure mode (without replay protection) does not use more resources than the unsecure mode, even under attack . (2)We veriﬁed that the Preinstalled secure mode is able to stop external adversaries from joining the IoT network for the investigated attacks. Further, We showed that the optio nal replay protection also provides an excellent mitigation ag ainst the Neighbor attack; however, it needs further optimizatio n to reduce its effect on energy consumption. and (3)We observed and analyzed the effect of the investigated attack s on the routing topology and proposed a few simple techniques that could help reduce the effects of the investigated attac ks, without using external security measures such as IDSs or added security mechanisms. The rest of this paper goes as follows: Section II looks into the related works. In section III an overview of RPL and its security mechanisms is presented. Section IV discusses our evaluation methodology, setup, assumptions, adversary mo del, and attack scenarios. Results from the evaluation are shown in section V. Section VI discuses our observations from the results and few suggestions we are proposing to be used when designing RPLbased IoT networks. II. R ELATED WORKS "
138,GRB: Greedy Routing Protocol with Backtracking for Mobile Ad Hoc Network (Extended Version).txt,"Routing protocols for Mobile Ad Hoc Networks (MANETs) have been extensively
studied for more than fifteen years. Position-based routing protocols route
packets towards the destination using greedy forwarding (i.e., an intermediate
node forwards packets to a neighbor that is closer to the destination than
itself). Different position-based protocols use different strategies to pick
the neighbor to forward the packet. If a node has no neighbor that is closer to
the destination than itself, greedy forwarding fails. In this case, we say
there is void (no neighboring nodes) in the direction of the destination.
Different position-based routing protocols use different methods for dealing
with voids. In this paper, we use a simple backtracking technique to deal with
voids and design a position-based routing protocol called ""Greedy Routing
Protocol with Backtracking (GRB)"". We compare the performance of our protocol
with the well known Greedy Perimeter Stateless Routing (GPSR) routing and the
Ad-Hoc On-demand Distance Vector (AODV) routing protocol as well as the Dynamic
Source Routing (DSR) protocol. Our protocol needs much less routing-control
packets than those needed by DSR, AODV, and GPSR. Simulation results also show
that our protocol has a higher packet-delivery ratio, lower end-to-end delay,
and less hop count on average than AODV.","A Mobile Adhoc Network (MANET) consists of a set of nodes each of which is capable of being both a host and a router. The nodes form a network among themselves without the use of any ﬁxed infrastructure, and communicate with each other by cooperatively forwarding packets on behalf of others. Mobile adhoc networks have applications in areas such as military, disaster rescue operations, monitoring animal habitats, etc. where establishing communication infrastructure is not feasible [1, 2, 3, 4, 5]. Routing protocols designed for mobile ad hoc networks need to be scalable, robust, and have low routing overhead. Routing protocols designed for MANETs can be broadly classiﬁed as geographic routing protocols (or positionbased routing protocols) and topologybased routing protocols. In geographic routing protocols, nodes do not maintain information related to network topology (i.e., they are topology independent). They only depend on the location information of nodes to make forwarding decisions. Generally [6], nodes need their own location, their neighbors’ location, and the location of the destination node to which the packet needs to be forwarded. Using this location information, routing is accomplished by forwarding packets hopbyhop until the destination node is reached [7]. Greedy forwarding (GPSR [8]), is one of the main strategies used in geographic routing protocols. Under Greedy forwarding, an intermediate node on the route forwards packets to the next neighbor node that is closer to the destination than itself. Topologybased routing protocols depend on current topology of the network. Topologybased routing is also known as tablebased routing. Topologybased routing can be classiﬁed in to proactive routing protocols, reactive routing (ondemand) protocols, and hybrid routing protocols [1, 9, 10]. In proactive protocols, like DSDV [11], nodes use preestablished tablebased routes [12]. Therefore, routes are deemed reliable and nodes do not wait for route discovery which cuts off latency. However, overhead incurred for route construction and maintenance can degrade performance, limit scalability, and the routing table will consume lot of memory as the network size grows. Reactive Routing Protocols are also called ondemand routing protocols wherein senders ﬁnd and maintain route to a destination only when they need it. Reactive routing needs less memory and storage capacity than proactive protocols. However, 1arXiv:1804.01133v1  [cs.NI]  3 Apr 2018Figure 1: Example Illustrating Dead End (void) in Greedy Forwarding. in network areas where nodes can move more unpredictably and frequently, path discovery may fail since the path can be long and links may break due to node mobility or when facing other obstacles [1]. The delay caused by route discovery for each data trafﬁc can increase latency. On the other hand, geographic routing protocols require only the location information of nodes for routing. They do not require a node to establish a route to the destination before transmitting packets. Unlike ondemand routing protocols, they do not depend on ﬂooding route request messages to discover routes. This feature helps geographic routing protocols to reduce the extra overhead imposed by topology constraints for route discovery [13, 7]. A node only needs to know the position of its neighbors and the position of the destination to forward packets. Therefore, geographic routing protocols generally are more scalable than topology based routing protocols [14, 15, 16]. In spite of the beneﬁts mentioned above, geographic routing protocols have the following limitations: Greedy forwarding, the primary packet forwarding strategy used by geographic routing protocols, may fail in low density networks, networks with nonuniformly distributed nodes, and/or networks where obstacles can be present. Moreover, Location Service is required to obtain location information of destination nodes which may result in high overhead. The nonhierarchical address structure used in adhoc networks requires more control overhead to update node location [14]. Paper Objective Many geographic routing protocols construct the planarized version of the local network graph to route a packet around voids; constructing planarized graph of the local network requires exchanging neighborhood information of nodes at least two hops away and then planarizing the graph, which can cause large overhead, especially in a sparse network wherein several voids may exist on a route. In addition to that, planarization may fail to generate bidirectional, connected, and/or cross link free local graphs as observed by Kim et al. and Frey et al. [17, 18]. In this paper, we address this issue and propose a simple geographic routing protocol that uses backtracking to route packets around voids. Organization of the Paper The rest of the paper is organized as follows. In Sect. 2, we discuss the related work and paper objectives. In Sect. 3, we present our protocol. In Sect. 4, we present the performance evaluation results of our protocol. In Sect. 5 we give a brief discussion of our protocol. Sect. 6 concludes the paper. 2 Related Work "
459,Comparison of Proposed Data Dissemination Protocols for Sensor Networks Using J-Sim.txt,"A distinguishing characteristic of wireless sensor networks is the
opportunity to exploit characteristics of the application at lower layers. This
paper reports on the results of a simulation comparison of proposed data
dissemination protocols using the J-Sim simulator for the WSN protocols:
Forwarding Diffusion Data Dissemination(FDDDP), Decentralized Data
Dissemination(DDDP), Credit Broadcast Data Dissemination (CBDDP), Energy Aware
& Geographical Data Dissemination (EAGDDP) .Our performance provides useful
insights for the network designer such as which protocols (and design choices)
scale control traffic well, improve data delivery or reduce overall energy
consumption,improves routing overhead and maximizes the bandwidth utilization.
The static pre configuration of the cell size in DDDP, is one of the reasons
why DDDP exhibits larger routing overhead than FDDDP by 74.2% on average.
Although CBDDP produces approximately 94.6% smaller overhead than DDDP and
90.7% smaller than FDDDP, because of statically configured amount credit CBDDP
delivers on average 7.5 times more of the redundant data packets than DDDP and
FDDDP.EAGDDP improves the delivery by 80% on average and makes a balance of
energy consumption .We suggest that making these protocols truly self-learning
can significantly improve their performance.","  The rapid advances in wireless communication and Micro  Electro Mechanical System (MEMS) have made Wireless  Sensor Networks (WSNs) possible. Such environments are  typically comprised of a large number of sensors being  rando mly and densely deployed for detecting and monitoring  tasks. These sensors, developed at a low cost and in small size  (mm scale for smart dust motes [1]), are responsible for object  sensing, data processing, storing, and routing activities.  Applications of  such networks range from battlefield  communication systems (e.g. intrusion detections and target  surveillance) to environmental monitoring networks such as  habitat monitoring, chemical sensing, infrastructure security,  inventory and traffic control etc. F or example, sensors are   distributed across a forest in order to report the origin of a fire  event when there is a significant increase in the average  monitoring temperature. Referen ce [2] provides a more  thorough discussion on s ome potential WSN applicati ons.  Unlike the conventional adhoc communication networks, energy resources in WSNs are usually scarce due to the cost  and size constraints of sensor nodes. In addition, it is  impractical to replenish energy by replacing batteries on these  nodes. Conservin g energy is thus the key to the design of an  efficient WSN. WSNs may deploy several hundreds to  thousands of sensor nodes. Protocols in such networks must  therefore be scalable. Furthermore, since nodes are dynamic   and their geographic positions are not pr edetermined, these  nodes may also need to possess some self organizing  capabilities. Network dynamics that result from both node  movement and unpredictable energy depletion also bring new  challenges to the design of an efficient WSN. Since nodes can  only carry limited battery resources, they usually get  disconnected from the network easily. Such frequent node  disconnections suggest that the design must accommodate  topology changes. Communication in wireless sensor  networks is data centric and must minimize  the energy  consumed by unattended battery powered sensor nodes   [3][4][5][7 ] . Our key observation is that despite their design  intentions to make these protocols self configuring, they in  fact rely on a significant number of statically configured  paramete rs. We suggest which parameters for each protocol  should be dynamically configured in response to measured   network state, using passive measurement techniques such as  Bayesian inference to reduce the measurement overhead.  Making these protocols truly self learning techniques could  significantly improve their performance .  Section II describes propos ed data dissemination protocols,  Section III gives the  methodology of simulation ,  Section IV  describes  overview of various metrics used for comparison ,  Section  V shows the result of comparison and section V I gives  the summary and suggestions  for future work.     II. PROPOSED  DATA DISSEMINATION  PROTOCOLS :INTRODUCTION     A.. Forwarding Diffusion Data Dissemination  Protocol(FDDDP)     FDDDP (Fig. 1) is the first proposed d ata centric   communication protocol for wireless sensor scenarios. The  data generated by the source node is named using attribute  value  pairs. The consumer node requests the data by  periodically  broadcasting an request for the specific data. Each node  in th e network will establish a link towards its  neighboring nodes from which  it receives the request. The link  specifies both the data rate and the direction towards which  the data should be sent. Once the source node detects an  interest it will send explorato ry packets towards the consumer,  possibly along multiple paths. As soon as the consumer begins  receiving exploratory packets from the source it will select  one particular neighbor from whom it chooses to receive the  rest of the data. The data will then flo w back towards the  consumer along the selected  path. The selected  path  packets  are also used for local path repairs in case of the failure of  some nodes during the data delivery phase.                                                                        Fig. 1 FDDDP   B.  Decentralized Data Dissemination protocol(DDDP)     DDDP (Fig.  2) is based on decentralized architecture. It uses a  cell like structure to divide the entire topology into small cells.  Only sensors located at a cell boundary need to forward  the  data. The consumer actively builds this cell structure through  the network and sets up forwarding points in the sensors  closest to the cell boundary called centralized nodes  (CN).  One level is the cell at the consumer’s current location and the  other  one is the CN at cells boundaries. The consumer only  floods the query within its own cell. When the nearest CN that  hears the query, it forwards it to its adjacent  CNs(of the same  cell or the next cell ). This process continues until the query  reaches th e producer or one of the CNs that have the  corresponding data. During the query propagation period the  network establishes the reverse path towards the consumer for  the reply, so that it can enable the data path to be the same as  that of the query propagat ion.                                                                                                                    Fig. 2 DDDP     C. Credit Broadcast Data Dissemination Protocol (CBDDP)     In CBDDP (F ig. 3) a node on deployment sets its cost to  reach  the consumer at infinity. As soon as the consumer node starts  up it broadcasts the advertisement message containing its  initial cost. Each intermediate node that hears the  advertisement will calculate the receiving cost of the message.  At the end of  the cost field setup period each working node  will have calculated the minimum cost for it to reach the  consumer. Each message carries a ”credit” in its header in  addition to its optimal shortest path cost for transmission.  Depending on the ”credit” amoun t data packets can flow along  multiple paths rather than a single optimal shortest path .The  packet will eventually arrive at the sink node through at least  one of the working paths even if some intermediate nodes  malfunction or if channel gets corrupted .  If the ”credit ” is set  to be higher that the minimum cost. Each intermediate node  will make its own decision regarding the forwarding of a  packet based on the amount of credit in the data message, its  own minimum cost value and the remaining ratio. CBDDP   assumes a static network so node movement will require  excessive updates of cost field. Each data packet will carry in  its header the minimum cost of the source node to reach to the  consumer (Cost source) , some consta nt (β), the current energy  used (E current) and the sender’s minimum energy (E min) . The  Remaining Ratio is calculated as follows.     Let .            RR   Remaining Ratio               Th    Threshold Value               If RR is bigger than Th then a node will rebroadcast the  message.      (A) Request Propagation  Source  event   Sink  (B) Link  Establishment  event   Source  Sink   Source  Sink   c) Data delivery  event   Source  C N C N C N Sink                                            Fig. 3 CBDDP       D. Energy Aware &Geographica l Data Dissemination  Protocol (EAGDDP)     In EAGDDP (F ig.4) takes residual energy into consideration  and is designed to efficiently disseminate queries to a  destination. As queries are often geographical (i.e. they have a  target area), packets are directly f orwarded to the particular  destination rather than flooded everywhere. EAGDDP  assumes that nodes are aware of their own geographic  positions, and uses energy aware neighbor selection to  aggressively route the queries toward the specific target region   [8][9 ]. In addition to the distance to destination, neighbor’s  residual energy is also considered in the cost function so that  energy load among any neighborhood can be balanced. The  tradeoff, however, is the increased path length used to transmit  the queries s ince energy efficient paths are not necessarily the  shortest. Restricted forwarding immediately follows to  disseminate packets inside the area once the queries have  arrived at the border of the region. In this protocol we assume  that the node N is forwardi ng packet P whose target region is  R . The centroid of the target region is D. Upon receiving the  packet P, the  node N routes P progressively towards the target  region and at  the same time tries to balance the energy  consumption across all the neighbors. Node N achieves this  trade off by minimizing the learned cost l(Ni,R) value to its  neighbor Ni. Each node N maintains l(N,R) which we term as  learned cost to the region R. A node frequently updates its  l(N,R) value to its neighbors. If the node does not hav e l(Ni,R)  state for a neighbor Ni, it computes estimated cost e(Ni,R) as  the default cost for l(N,R).                                                                                       Fig. 4 EAGDDP      Estimated cost e(Ni,R) of N i is calculated as                             e(Ni,R) = µd(Ni,R)+(1 µ)e c(Ni)                            (1)            µ              tunable weight          d(Ni,R)     distance from Ni to centroid d to region R          ec               consumed energy     as soon as nodes picks up a next node hop neighbor it sets its  own l(N,R) to l(Nmin,R) + C(N,Nmin) which is known as cost  of transmission from N to Nmin .     III. METHODOLOGY   "
354,Z-SEP: Zonal-Stable Election Protocol for Wireless Sensor Networks.txt,"Wireless Sensor Networks (WSNs) are comprised of thousands of sensor nodes,
with restricted energy, that co-operate to accomplish a sensing task. Various
routing Protocols are designed for transmission in WSNs. In this paper, we
proposed a hybrid routing protocol: Zonal-Stable Election Protocol (Z-SEP) for
heterogeneous WSNs. In this protocol, some nodes transmit data directly to base
station while some use clustering technique to send data to base station as in
SEP. We implemented Z-SEP and compared it with traditional Low Energy adaptive
clustering hierarchy (LEACH) and SEP. Simulation results showed that Z-SEP
enhanced the stability period and throughput than existing protocols like LEACH
and SEP.","WSNs consist of a large number of sensor nodes that are deployed randomly to monitor physical or  environmental conditions, such as temperature, sound, vibration,  pressure, motion or pollutants  at different  locations. Advancement in wireless communications, electronics and technological evolution has enabled the development  in the field of WSNs  due to their low cost and variety of applications such as health, home and military  etc. Research is going on to solve different technical issues in various application areas. Sensor  nodes consist of   components capable of : sensing data, processing data and also communication components to further transmit or  receive data. The protocols and algorithms of such networks must possess self organizing capabilities to ensure  accurate and efficient working of the network.   Communication in WSNs occurs in different ways which totally depends on the application. Generally,  there are three main types of communication:   • Clock Driven: Sensors sense and gather data at constantly and periodically communicate.   • Event Driven:  Communication is triggered by a particular event.   • Query Driven:  Communication occurs in response to a query.   In all three types of communication, efficient use of energy is of concern while studying, designing or  deploying such networks to prolong the sensing time and  overall lifetime of the network.   Hierarchical routing protocols have been proved more energy efficient routing protocols. Several protocols  are designed for homogeneo us networks. LEACH  [1] is one of the first clustered based routing  protocol  for  homogeneous network.  LEACH assigns same probability for all nodes to become cluster head.  However , LEACH   does not perform well in heterogeneous environment. Heterogeneity of nodes with respect to their energy level has also proved extra lifespan for WSNs.  To improve efficien cy of WSNs , SEP [2] was proposed.  SEP is a two level  heterogeneous protocol. SEP assigns different probability (to become cluster head) for nodes on the basis of their  energy level.  However , SEP does not use extra energy of higher level nodes efficiently.   To send  messages from nodes to base station we require minimum dissipation of energy. For such purpose  a need of better routing protocol arises which should efficiently utilize energy. Classical approaches were  insufficient to fulfill this demand. In this paper we have proposed a hybrid approach for transmitting data to  base  station. Some nodes send their data directly to  base station and some uses clustering algorithm for transmitting data 2   to base station. Our hybrid approach enhanced the stability period,  network lifetime and also throughput of the  network.   2. RELATED WORK AND MOTIVATION   "
11,BlockJack: Towards Improved Prevention of IP Prefix Hijacking Attacks in Inter-Domain Routing Via Blockchain.txt,"We propose BlockJack, a system based on a distributed and tamper-proof
consortium Blockchain that aims at blocking IP prefix hijacking in the Border
Gateway Protocol (BGP). In essence, BlockJack provides synchronization among
BlockChain and BGP network through interfaces ensuring operational independence
and this approach preserving the legacy system and accommodates the impact of a
race condition if the Blockchain process exceeds the BGP update interval.
BlockJack is also resilient to dynamic routing path changes during the
occurrence of the IP prefix hijacking in the routing tables. We implement
BlockJack using Hyperledger Fabric Blockchain and Quagga software package and
we perform initial sets of experiments to evaluate its efficacy. We evaluate
the performance and resilience of BlockJack in various attack scenarios
including single path attacks, multiple path attacks, and attacks from random
sources in the random network topology. The Evaluation results show that
BlockJack is able to handle multiple attacks caused by AS paths changes during
a BGP prefix hijacking. In experiment settings with 50 random routers,
BlockJack takes on average 0.08 seconds (with a standard deviation of 0.04
seconds) to block BGP prefix hijacking attacks. The test result showing that
BlockJack conservative approach feasible to handle the IP Prefix hijacking in
the Border Gateway Protocol.","Border Gateway Protocol (BGP) –also known as  Interdomain routing protocol –is a path vector  protocol that regulates the connectivity and  information exchange among Autonomous Systems  (AS).1 Based on data presented in APNIC Research  and Development (AS 65000) , there are currently  almost 70,000 unique ASN seen in their BGP routing  table (BGP Potaroo, 2020). Each AS maintains a  number of IP Prefixes (in short Prefixes) and domains  assigned by the Internet Assigned Number Authority  through Regional Internet Regis tries (RIR).   To hijack IP prefix of a benign router, an adversary  router (or AS) advertises a ( fake ) IP prefix that belong  to another router (or AS). When the adversary AS  conducts prefix advertisement, BGP sends the prefix  to all neighbours on the Interne t. As a result, the  traffic that supposed to reach the original AS,   is then redirected to the adversary AS which results  in unavailabil ity of crucial Internet services. Besides                                                                    1 AS is an independent network that comprises the  Internet and each AS assigned a 16 bit or 32 bit unique  number known as Autonomous System Number (ASN).  adversarial attempts, a number of cases are also  caused by the unintentional mistake of network  administrator during the routing setup (Hope, 2020).   Most recent researches involving machine  learning have been condu cted to detect prefix  hijacking such as in (Qingye Ding et al., 2016), (Wu  and Feng, 2009) and (Li et al., 2014). The first step in  these techniques involving training of machine  learning algorithms using the data acquired from  dumped BGP control or data p lane during the normal  and hijacking condition. Then the machine learning  algorithms monitor the current BGP update message  and decide whether the condition is normal or not.  Detection approach suffers to imbalance and  resemblance data. Only a small number  of hijacked  BGP update message available currently compared  to the total number of data produced by routers  involved in the Internet. Moreover, to differentiate  the traffic during normal and in hijacking condition is  very challenging to conduct, even for research that  involving deep learning (McGlynn et al., 2019).  To tackled the drawback of machine  learningbased detection, several techniques propose  blacklist based approaches (Alshamrani and Ghita,  2016), (Alshamrani and Ghita, 2016), (Testart et al.,  2019). These techniques essetnially create profiles of  ASes to blacklist malicious ASes (or router) to prevent  them from routing advertisements. However, these  approaches are generalized where certain router  involved in malicious activities as a burden of the   whole AS, whereas an AS can consist of hundreds of  routers and can advertise hundreds of prefixes.  Moreover, defining the threshold of secure and  insecure ASes would be very challenging to conduct  because almost all ASes may potentially involved in  malici ous activities. In order to secure BGP from  prefix hijacking, the drawbacks exhibited by  detection based research makes prevention or  mitigation approach are worth to explore.   In this paper, we propose BlockJack, a Blockchain  based model, to tackle the dra wback of hierarchical  RPKI model (Iamartino et al., 2015). In BlockJack, the  pair IP prefix ASN data and credential of each  consortium member is stored in each Blockchain  node to eliminate the need to resort to centralised or  hierarchical, public key infra structurebased schemes  (Iamartino et al., 2015). BlockJack does not require to  change the original BGP protocol; instead BlockJack  provides a Dispatcher (see § 3.3 and Figure 1 for  details) to automatically send filter commands to the  router reducing softw are and hardware updates.  Moreover, our proposed scheme is portable allowing  nonBlockJack routers to communicate with  BlockJack routers. The main contribution of this  paper can be sumarized as follow:   • We present “BlockJack”, a Consortium  Blockchain based model to verify prefixes and AS  origin and also to neutralize the Prefix hijacking  in BGP.   • We also propose a mechanism to increase the  resiliency against AS Path changing and BGP  routing Divergence during the Prefix Hijacking  Neutralization.   • To foster further research, we release the source  code of BlockJack and our experiments to the  research community at: https://github.com/  budisentana/prefixHijackingPrevention.git  2 BACKGROUND AND OVERVIEW   In this Section, we briefly present the several  shortcoming of RPKI, reviews key basics of  Blockchain, and highlight requirements of BlockJack  system.   2.1 Resource Public Key Infrastructure   Internet Engineering Task Force (IETF) provides  Resource Public Key In frastructure (RPKI) to secure  BGP against IP prefix hijacking. To prevent BGP  hijacking, IETF releases RFC 6482 for Route Origin  Authorization (ROA) and RFC 6483 for Route Origin  Verification (ROV). ROA is a process where an AS  authorizes a number of prefi xes to be advertised  under its jurisdiction, and stores it a tuple of IP prefix,  AS (owner), the maximum length of AS and expiry  date of each IP block (Iamartino et al., 2015). To  prevent prefix hijacking, the tuple can be utilized  during ROV process to ve rify whether or not an AS  advertise the authorized prefix. Despite the crucial  role, only 6.5% of total prefix announced in BGP are  covered by ROA(Gilad et al., 2017) and there is no  exact number of ROV coverage because of the invalid  prefix in ROA is unde fined(Hlavacek et al., 2018). 71%  of the Internet Service Providers (ISPs) avoid to add  more cost on the RPKI implementation and rely on its  security using best practice mitigation by route  filtering (Sermpezis et al., 2018). Moreover, RPKI  hierarchical se curing model potentially deteriorates  of downstream Resource Certificate (RC) error during  upstream RC overwrite or miss configuration(Cooper  et al., 2013).   RPKI architecture gradually delegates the RC from  IANA as the global regulator to Regional Internet   Registrar (RIR), ISP and private network company (Liu  et al., 2016). Each of these institutions is allowed to  publish a certificate of authority to its downstream  and keep the RC in its storage. As suggested in  (Cooper et al., 2013), any attack or misscon figuration  on upstream network results to failure in prefix  announcement for the downstream network.   2.2 Blockchain   Blockchain is a distributed data structure containing  transactions of records forming a chain or blocks  which are controlled by multiple Blockch ain nodes.  To provide data integrity, each block of transactions  on a Blockchain has an individual digital signature  created using a combination of the latest block’s digital signature and a new digital signature, known  as a digital footprint. Blockchain i s also known as a  distributed ledger that is completely open to any and  everyone on the network. Blockchain allows all the  network participants to reach an agreement (or  consensus) during its operation.   The rapid development of Blockchain technology  impact ed the rise of various new versions of  Blockchain models (Casino et al., 2019):   • Public Blockchain : A common feature of the  public Blockchain is the need for miners to add  new blocks to the existing block chain. Since the  ownership is public, the identity o f the accessing  party can be anonymous (pseudo anonymous), it  does not require permission (permissionless) to  access the Blockchain system.   • Private Blockchain : This model is usually used by  organizations with a centralized structure where  each user is iden tified (permission) thus creating  a trusted system or environment. The process of  adding blocks to the existing Blockchain is carried  out by the assigned leader node . Consensus  mechanisms are widely used to prevent collisions  from transactions running in p arallel.   • Federated or Consortium Blockchain : This  Blockchain model is semi centralized, where the  decision to approve each transaction is decided  by the consortium members. Each consortium  member needs permission to access the  Blockchain. The process of ad ding blocks to the  Blockchain is carried out by a leader who is  chosen by the consortium members based on a  consensus algorithm.   2.3 Requirements of BlockJack   We are using conservative approach in the BlockJack  by keep the Blockchain and the BGP running in  independent environment. This aproach preserve  the BGP protocol so none of upgrade need by the  router. For the data stored in the Blockchain,  BlockJack only save the Prefix and its AS origin to  create a resilient system against dynamic AS path  changes and rou te divergence in the BGP network. In  the following, we highlight two main requirements  for BlockJack system:   Independent Environment: Instead of residing  the node of Blockchain node in the router machine  as in (Liu et al., 2019), we keep the Blockchain and  routing environment running independently. As a bridge for those two environment, Profiler was  created to serve the HTTP(S) request f rom  Dispatcher that run a number of routine task to  monitor BGP routing table. We have two  consideration why we choose to create inter  operable module between Blockchain and Router,  that are:   • Respecting legacy system: Residing Blockchain  node inside of rou ter machine can change the  role of dedicated router into multi purpose  machine. Some update to the BGP protocol also  needed to accommodate the Blockchain system.   This approach will be so challenging to adopt in  current condition relying on the result showi ng  by(Sermpezis et al., 2018). Residing Blockchain  inside the router machine can also raise a  compatibility issue for the existing system.   • Avoiding race condition between Blockchain  access and BGP message interval: BGP uses  message signal –consists of tuple : OPEN, UPDATE,  NOTIFICATION, and KEEP ALIVE –to periodically  update the routing tables of routers. So if we  reside the Blockchain node inside of the BGP  protocol loop, we need to use one of those  message to trigger our Blockchain system. This  condition for ce all the process that accessing the  Blockchain, including prefix authorization or  verification, should be completed before the  next interval of the BGP message. The race  condition occur when the Blockchain process  exceed the BGP message interval. Related  to  Prefix advertisement, BGP uses UPDATE message  to find a new prefix advertised, withdrew or  updated from its Peer or neighbors. In default,  the Minimum Advertisement Route Interval  (MARI)(Liu et al., 2020) is set every 30 seconds. It  implies that all th e prefix authorization, which is  adding a prefix to the Blockchain, should be  completed within 30 seconds. This could be  challenging due to complex process of consensus  mechanism in Blockchain.   Resiliency Against AS Path Changing: For routing  operations, B GP protocol uses three tables: i) BGP  Neighbor Table : containing information about BGP  neighbors, ii) BGP Table (BGP RIB or BGP topology  table): contains the list of prefix (network) and its  routes (several routes are directed to the same  network with diff erent attributes), and iii) BGP  Routing Table : contains selected valid best routes  from BGP Table. BGP table learns the route to the  source of the prefix from its neighbors. Each route in BGP table list consists of several attributes including  local pref, AS path, MED (Multi Exit Discriminator),  and next hop (Attarde and Dhamal, 2009).   BGP uses the values in these attributes to decide  the best and valid path to get to the source of the IP  prefix. The chosen route is then stored to the BGP  routing table whic h is then announced to the  immediate neighbors. The best valid path can  dynamically change as the value of those parameters  change. If there is a change in the best valid status of  a route in a router, the router will send an BGP  message UPDATE to its peer s. This change is  potentially affecting the routing table on neighboring  routers. If the AS path changing is oscillating then it  is known as BGP routing divergence. Routing  divergence can be caused by load balancing policies  and also BGP routing policies(A hmed and Sarac,  2014).   Saad et al., (Saad et al., 2019), leverage AS paths,  stored in blockchain module, as the main parameter  to detect prefix hijacking. Most of the data is used  only by the router itself to verify if the same AS has  more than one routes.  The study assumes that the  path to reach the prefix source is fixed and captured  in convergence routing conditions. However, this  approach is not valid if there is traffic redirection  caused by a malfunctioned AS as a result of network  failure. As its nat ure, the router will look for  alternative paths in case of network failure so that  data exchange can continue. If there is a change in  the path, the valid best status on the previous path  is likely to change. As a result, the AS path in the  latest conditio n with valid and best status will be  different from the AS path stored on the Blockchain  so that all prefixes announced by the AS experiencing  valid traffic redirections.   To accommodate AS route path changing and  divergence, BlockJack stores only prefix an d its AS  source (origin) in the Blockchain. BlockJack uses AS  path only to retrieve the prefix source and discharge  the rest of it. As a complement, BlockJack uses next  hop information to identify the peers that contribute  to the addition of prefix in the routing table, in order  to create the Inbound filter when the hijacking occur.  Inbound filter is a function use to create a filter for  the incoming Prefixes or AS from a certain AS through  the immediate neighbors. This approach reduce the  number of verific ation and authorization process to  the Blockchain caused by dynamic change of AS path.                                                                    2 The Hyperledger Fabric is a consortium based  Blockchain that only allows identified entities BlockJack only triggered if there is any changes in  valid and best path status and change of the next  hop. To accommodate this approach, BlockJack  prepares two main feat ures, namely prefix  authorization, which is used by AS prefix owners to  claim or authorize prefixes, and prefix verification  which is used by the whole AS to verify prefixes  received from its neighbors. We provide more details  about these two feature in § 4.1 and § 4.2   3 SYSTEM ARCHITECTURE   Figure 1 depicts the three modules of BlockJack :  Blockchain, Profiler and Dispatcher. The Blockchain  module handling the Smart Contract, Certificate of  Authorization (CA) provider, data storage (Ledger),  and a consensus me chanism while the Profiler  creates routers’ profiles and facilitates a gateway to  the Blockchain ledger. It also also provides wallets to   store all router credentials under a certain AS  authority. The Dispatcher module conducts routine  tasks to monitor the  routing tables and dispatches  filtering commands if there is any update on BGP  routing tables.   3.1 Hyperledger Fabric Blockchain   We leverage Hyperledger Fabric 2 platform to build  the Blockchain module. Unlike public based  (permissionless) Blockchain, Hyperle dger fabric  eliminates the role of miners in tethering the new  blocks to the existing blocks. The consensus  mechanism assures only trusted and known  consortium member parties can be involved in  Blockchain transactions. Hence, this Blockchain  model is appro priate to regulate the interaction  among Autonomous Systems that demand a highly  trusted environment.   Replacing the role of miners and other public  based consensus, Hyperledger Fabric handled its  consensus mechanism by adding several  components including O rderer, Endorser, Chaincode  and the Ledger itself(Linux Foundation, 2020b). For  this research we modify the Chaincode and align the  Ledger structure as needed by the BlockJack.  Chaincode is a code of a program that handles the  business logic of the transac tion among consortium  (permissioned) to access the network(Linux Foundation,  2020b).  members. Chaincode acts as a smart contract and  used by Endorser as a matrix to approve or  disapprove a transaction. While, Ledger is a database  that stores all the transactions approved by  consensus mechanism and provides the query a ccess  for an authorized entity.   In the Hyperledger Fabric, ledger consists of two  different but related parts, that is World State and  Blockchain(Linux Foundation, 2020b). World State is  a database that stores current values of a set of  ledger states. It is allowed a transaction request to  access the current value directly without need to  traverse the value in the whole transaction log. The  world state may change dynamically when a  transaction states created, updated or deleted.  While, Blockchain records all the changes appears in  the cur rent world state and stored in transaction log.  Every time the commit order occurs, the transactions  in the world state are collected inside the block and  then appended to the Blockchain. Hence, the  Blockchain consists of changing history resulting in  the current world state that cannot be modified.   For this research purpose, we prepare the ledger to  correspond to the Chaincode plus transaction key  that is taken from the corresponding prefix so the  retrieval process becomes faster due to indexing  process. W e are creating four columns of table that consist of PRE FIX, ASN, DOCUMENT TYPE and ACTIVE  STATUS of the prefix. Active status is needed if the  temporary withdrawal occurs in the BGP table,  hence the re announcement of the prefix does not  create a new transaction and only change the status  of the prefix     3.2 Profiler   Profiler is used as an i nterface between the  Dispatcher and the Blockchain. Figure 2 shows  Profiler module consist of three parts that are Admin  function, router profiler function and Rest API  function. Admin function used to create a credential  for the administrator before the a dmin can create a  router profile, by invoking the Fabric CA module in  the Blockchain.   Router Profiler is a function that can be used by  administrators to create profiles of each router from  its internal AS. The profile consists of router id and  the AS numb er. The router id is then used as a  username for the router to be sent to fabric CA to  create the router certificate of credential. All the  credentials of admin and routers are stored in the  wallet. And the last function of this module is a Rest   Figure 1: An overview of the three modules of BlockJack . Blockchain module is handling data storage and data query while  Profiler is used as a bridge between Blockchain and Dispatcher as well as to store the Credential of each router. Dispatcher  monitors routers and dispatches filter commands if Prefix Hijacki ng occurs.     API server  that can be used as a gateway from router  dispatcher to the Blockchain.   Rest API Server provides functions to add prefix  into the Blockchain and query prefix from the  Blockchain. Respectively, those functions are useful  for the prefix authorization and ve rification pro     Figure 2: Overview of rest API and router profiler module.  Admin and router profiler function is used to create  credentials of administrator and router. The credentials  are then stored in the wallet and used by the rest API  server to equip the request from Dispatcher to access the  Blockchain module.   cess.T his function also provides an authentication  routine for each http request from the router and  equips the request with the corresponding router  credential before it is sent to the Blockchain.   3.3 Router Dispatcher   Router Dispatcher (Dispatcher) is used to inte ract  with router machines. Although it works in the  router, the routine inside Dispatcher is independent  of BGP routing signals. This approach allowed regular  routers to connect to routers that equip with  BlockJack, hence minimizing the update for the  rout er software. Dispatcher consists of three  routines which are monitor, sender and verifier, as  shown in Figure 3. There are also two local caches  that are Local ROA , used to store temporary prefixes  announced by router in internal BGP mode and Local  ROV that use to store temporary prefixes announced  by neighboring ASes.   Monitor routine observes the BGP routing table  while Monitor routine consists of shell script which  sends Secure Socket Layer (SSL) command to query  BGP routing table. The command returns the  value of  network (pefixes), next hop, metric, local preference, weight, and AS path for each route available to get  to the source of the prefixes. From these return  values, BlockJack takes the network, next hope and  ASpath . Monitor then split the ASpath  to find the  origin AS of each prefix, discharge the rest of AS in  the ASpath , and then combine it with prefix and next  hope . If the prefixes originate from internal AS then  the combination value is assigned to ROA variable ,  otherwise it is assigned to ROV variable . As explained  in § 2.3, Monitor only captures the route with status  valid and best to reduce the authorization and  verification process to the Blockchain.   Sender routine assists the Prefix Authorization  process in § 4.1. Sender consists of funct ions to  compare ROA variable generated by Monitor routine  with local ROA cache to seek any announcement or  withdrawal of prefixes from internal AS origin. If a  new prefix announcement is found, Sender then  sends HTTP(S) requests to the Profiler to add a ne w  prefix and its origin to the Blockchain. When a prefix  withdrawal occurs, Sender sends a request to update  the prefix status in the Blockchain.   The Verifier routine supports the Prefix  Verification as in detailed in § 4.2. The main function  of the Verifi er routine is to send the new prefixes  announced by the router’s neighbors for verification  against the data stored in the Blockchain. Verifier  uses the ROV variable provided by Monitor and  compares it with the Local ROV cache to find new  prefixes announce d by the neighbors. Verifier also  consists of a function to send Inbound filter  commands to the router to restrict an incoming  prefix from certain neighbors when the prefix is  identified to become a source of collision in the  routing table.     Figure 3: Overview of Dispatcher module where Monitor  routine observes the BGP routing table and finds the  prefixes announced by internal and external ASes. Internal  prefix list will be stored in the Blockchain using Sender  routine while external prefixes will be verified to the  Blockchain using Verifier.   4 PROCESS AND MECHANISM   BlockJack consists of a supporting mechanism which  includes Blockchain initialization, register admin and  router, and main mechanism which includes prefix  authorization and prefix ver ification. Supporting  mechanism is the process used to operate the  Blockchain network and to create credentials for  admins and routers who will interact with the  Blockchain. In the following, we provide more details  about the main mechanisms in BlockJack:   4.1 Prefix Authorization   By leveraging Blockchain, ASes uses Prefix  Authorization to prove the ownership of their  prefixes. Prefix Authorization starts when the  Dispatcher module reads the BGP routing table.  Monitor routine in the Dispatcher, reads and defines   the prefixes route announcements by the internal AS  router, and saves it in a variable. Monitor captures  the routes that appear with the status of valid and  best to reduce the number of prefixes list. The  Sender routine then compares the values resulting  from Monitor to the local ROA cache to find a new  prefixes announcement. If a new prefix is found, the Sender routine will send a https request to the  Profiler asking for prefix addition to the Blockchain.  In the Profiler, the Rest API server receives the  request and authenticates the request to the router  profile. Once it authenticates, the Profiler adds the  router credential to the request and sends it to the  Blockchain.   In the Blockchain, Endorser verifies the request  based on the contract written in the Chaincode. The  smart contract checks whether the new prefix is  violating the same prefix previously stored in the  Blockchain. Once the request complies with the  smart con tract, the Endorser sends the prefix to the  Orderer and then the consensus mechanism in the  Blockchain is started. The Orderer distributes the  request to all consortium members to have approval  from at least 50% of the consortium members. When  the consensu s is achieved, the Orderer signaling the  committer to seal the transaction and the Orderer  will add a new block into the ledger (Blockchain). At  the end of the Blockchain transaction, the Orderer  creates a new World State (see § 3.1) and distributes  it to the consortium members to update the ledger  state.   As prefix addition and modification processes  invoke a consensus mechanism in Hyperledger to  add a new block into the chain, they both are costly  to be conducted by the BlockJack model. As shown in  (1), th e cost to authorize prefixes x in CA(x) is equal  to the latency ( delay ) of requesting it through Profiler  in LR(x) plus the total latency to have Endorsement  approval from at least 50% of each consortium  member ( i) in LE(x) and also the latency to create a   new block and distribute it among N consortium  member in LD(x). We omit the delay used by  Committer to seal the transaction since it is only a  simple process in the Blockchain. Although the Prefix  Authorization process is costly, the total cost of  adding prefixes into Blockchain can be spread among  the prefixes owner, since each AS only needs to  authorize their own prefixes.   CA    i=1 i=1  4.2 Prefix Verification   Prefix Verification aims to check whether the  announcement received by the router from its  neighbors contains the authorized prefix. For this  purpose, BlockJack compares the prefixes found in  the routing table with the prefixes stored in the  Blockchain. Pr efix Verification mechanism started in  the Dispatcher Module. The monitor routine  captures the prefixes route with status valid best and  assigns the prefixes announced by the neighbors into  ROV variable . The verifier routine then compares this  variable wit h the prefixes stored in the Local ROV  cache to find a new prefixes announcement. If a new  prefix is announced, the Verifier requests for  verification to the Blockchain through Profiler. In the  Profiler Module, the request is accepted by the Rest  API serve r, and after authenticating against the  router credential, the request is then sent to the  Blockchain.   In the Blockchain module, the Chaincode verifies  the compliance of the request to the Smart Contract  and then query the Ledger. The query result then  verifies by Smart Contract and publishes three kinds  of signals, which are valid, invalid, or unknown. The  valid signal indicates that the prefix sending to the  Blockchain is available and corresponds to the right  AS Number. While, an invalid signal denotes t hat the  prefix exists in the Ledger but corresponds to the  different AS Number. This invalid signal can indicate  the BGP prefix hijacking occurs in the network. The  last unknown signal indicates neither the prefix and  the AS Number available in the Ledger.  For this  research, the unknown signal is to return a valid  signal for Dispatcher to allow non BlockJack routers  to announce their prefixes and to reduce the false  positive number of verification. When the Verifier  accepts the invalid signal, then it produ ces Inbound  filter commands to block the announcement from  the AS that indicated as a source of prefix hijacking.  The Inbound filter needs a parameter of next hop  that can be found in the ROV variable as it is assigned  by the Monitor routine before the ver ification.   Compared to the authorization mechanism,  prefix verification is straightforward: after the router  complies with the credential and smart contract,  data retrieval can be conducted in the ledger without  any approval of other consortium members.  Moreover, the ledger retrieved for verification is  resided in the correspondence Blockchain node and  more specifically in the current World State ledger  (see § 3.1). Hence the verification process can be  much faster than authorization.                                                                     3 Experiments were performed on a workstation with  Ubuntu 18.04, CPU 2.7GHZ, and RAM 16GB.  5 TESTBED SETUP AND  EVAL UATION   This section presents, our experiment testbed and  analysis.   5.1 Experiment Testbed   Blockchain module of BlockJack is implemented  using Hyperledger Fabric (Linux Foundation, 2020a).  Each Blockchain node, including Orderer, Fabric CA,  and Chaincode are ru nning in a separated Docker  container (Docker Inc, 2020). For the Profiler  module, we tailor Node js to create the admin  function, router registration, and Rest API server. We  built the Dispatcher module based on Python and  combined it with shell script . B GP network  environment developed using Quagga router  software, and for this research, we are using  Dockerized Quagga image produced by (Chiodi,  2020). Each router running in a separate detach  mode Docker container connected by a customized  virtual network.  We use the testbed and conduct  several sets of experiments to evaluate the  performance and resiliency of BlockJack against BGP  hijacking attacks. We provide further details in the  following:   Performance Evaluation: We aim to evaluate the  performance of ou r BlockJack in terms of the time  processing for handling prefix authorization and  prefix verification requests. To this end, we conduct  two sets of experiments 3 and record the processing  time of the authorization and verification mechanism  of BlockJack. I n particular, we generate sets of  random prefixes from a BlockJack router and query  the Blockchain ledger to determine the authorization  and verification times required by our proposed  systems.   For the prefix authorization setup, we create a  function in th e Dispatcher module to send a various  number of prefixes into the Blockchain to measure  BlockJack performance in handling prefix  authorization. Each prefix authorization process  followed by commit order so each prefix addition will  be adding a block in the  Blockchain. At the end of the  experiment there will be a thousand blocks in the  chain. To measure the prefix verification time, we  create a script so the Dispatcher can send a various number of prefixes to be verified by Blockchain with  1000 blocks. Resil iency Evaluation: Resiliency  evaluation aims to observe BlockJack resilience in  neutralizing prefix hijacking attacks with various  scenarios. For that purpose, we leverage Quagga and  Docker in the higher computing environment4 and  create several network to pologies with various  number of routers of 20 to 60. We measure the prefix  hijacking neutralization in two stages including Prefix  Prepending and Neutralization. Prefix Prepending is  the process of adding an ASN to the AS path  parameter in the BGP table fo r each AS passed by a  prefix. In this experiment, the prepending time is  equal to the time needed by the adversarial prefix to  arrive at the router where the Dispatcher resides  (BlockJack router) and disrupts the original prefix as  the route with the valid best status. While,  Neutralization is the stage where BlockJack detects,  verifies, and sends filter commands to the router to  neutralize hijacking. By measuring the prepending  (BGP hijacking attack) time and neutralization  (blocking) time, we determine th e duration of BGP  hijacking attacks and the efficiency of BlockJack to  neutralize the attacks, respectively.   For this experiment, we create three different  scenarios as describes bellow.   • Single Path Attack Scenario. This first scenario  aims to evaluate BlockJack resilience in  neutralizing attacks originating from a single  path. We create a binary tree like network  topology and reside the dispatcher on the router  which is located at the root. We prepared five  adversari al prefixes that would be used by  routers located in the farthest branch to hijack  the prefixes announced by routers in the leaf of  the tree. These attacks create single paths when  they reach the BlockJack router   (root).   We prepared five experimental sets in various  router numbers of 20 to 60, with five  experiments in each set and recorded the  Prepending and Neutralization times for each  trial. To give a fair treatment to each experiment  set, we restart the Blockchain network for each  experiment setup. This  will make the Blockchain  ledger only consist of the genesis block in each  time the experiment is started.                                                                     4 Experim ent conduct in Cluster server with 4 core CPU  units, 128 GB of memory, 500 GB hard drive and leveraging  Ubuntu 18.04 LTS.  • Multiple Path Attack Scenario. This scenario is  designed to examine BlockJack’s resilience in  anticipating routing path changes that occur  during BGP  prefix hijacking as explained in 2.3. In  this scenario we modify the binary tree network  topology in the first scenario by setting up BGP  peering for each branch at the same level. This  will cause each announced prefix to have more  than one path when it c omes to the BlockJack  router that is at the root of the tree.   Similar to the first scenario, we also created a  script to bypass the prefix authorization and  prepared a total of 25 experiments on various  setups with the number of routers varying from  20 to 60. We also restarted the blockchain  network to get fresh gene sis blocks for each  experiment set.   • Random Attack Scenario. This scenario is set up  to examine the BlockJack resilience in a very  random BGP environment. We made several  random network topologies with various  numbers of routers (20 to 60). The connectivity   level in each experiment was set to 25%  indicating that a node has a probability to be  connected to 25% of the total nodes on the  network, except for the experiment with the  number of routers of 20 which we set at 50% to  avoid the occurrence of unconnecte d node in the  network. We also created a script to place the  Dispatcher on a random node (router) and  prepared 5 random adversarial prefixes which  are used to hijack the prefix announced by the  original router in each set of experiments.   We ran BlockJack f or 10 minutes for each  experiment and tried to get 5 sets of  experimental results on a different number of  routers. Since the dispatcher and adversarial  prefixes are randomly assigned, it is possible that  the hijacking process will not affect the router  where the dispatcher is placed. In that case, we  will discard the experiment results and run it  again until we find that at least one prefix in the  routing table is affected by hijacking. We also  assume that if within the specified time period  the adversaria l prefix does not appear in the  routing table, then we assume that the hijacking process does not affect the routing table where  the dispatcher is located.   Limitation: Although we managed to run 70  routers on the docker container, we failed to  configure th e router running on top of the container  using the telnet command. Problems with  overloaded networks give rise to a network request  timeout error message. Docker network shares the  same Linux kernel to handle all virtual networks  running on top of the Dock er container. This will  cause an overload on the virtual network.This  condition also causes the Hyperledger failed to install  the Chaincode (smart contract) on the Blockchain  node through the corresponding port.   5.2 Analysis   Performance Analysis: The measureme nt results of  the average and total time required to perform Prefix  Authorization and Prefix Verification are presented  in Table 1. The number of prefixes in the table is  proportional to the number of blocks in the  Blockchain, considering that each prefix addition is  always followed by a commit command which means  adding a new block to the blockchain. More details  about the results of the prefix authorization analysis  and prefix verification are presented as follows:   Table 1: Time recorded by BlockJack to authorize and verify  prefixes. Each prefix addition followed by commit process  and create a new block.     # of Pref.  (Block)  Authorization  Verification   Avg. (s)  Total (s)  Avg. (s)  Total (s)   100 2.16 216.21  0.1 10.27   500 2.15 1,076.61  0.09 47.38   1,000  2.15 2,154.32  0.09 92.12     Prefix Authorization Analysis: Table 1 shows  prefix authorization time increase gradually  according to the number of prefixes sent to the  Blockchain. BlockJack needs 2,154.32 seconds to  authorize 1,000 prefixes with an average  authorization time of 2.16 seconds, which is quite  heavy eve n for a small two node Blockchain  environment. This expensive process is caused by a  complex consensus mechanism during the block  addition to the chain as described in § 4.1.   Regarding BGP messages set up by Cisco router  (Vinit and Brad, 2018), if the BGP UPDATE interval is  30 seconds, the maximum prefixes that can be authorized in that interval is 13 prefixes. These 13  prefixes per interval are higher than 12 prefixes  average announcement per AS origin as shown in  (Tony Bates, 2020). Hence, in this case, B lockJack can  handle the average prefixes announcement in real  world condition in one BGP UPDATE message interval  simultaneously without the assistant of the Local  ROA cache, disregarding the network traffic delay.   Since we adopted a conservative approach f or the  BlockJack, we calculate the prefix authorization time  for the case of the highest number of prefix  ownership by an AS. According to (Tony Bates, 2020),  the highest number of prefixes announced by an AS  is recorded by AS8151 (Uninet S.A. de C.V., MX)  with  8125 prefixes. In this case, BlockJack needs 625 BGP  UPDATE interval or 17,550 seconds to authorize the  whole prefixes when it runs for the first time. That  result is clearly created race condition between   BGP UPDATE interval and prefix authorization  if the  Blockchain node resides in the router machine and  depends on BGP message signal. The time taken to  access Blockchain during the authorization process  far exceeds the BGP UPDATE message interval.  Hence, Blocjack approach by keeping the Blockchain  and routing environment running independently is  reasonable considering the real world condition.   Prefix Verification Analysis: The experiment result  in Table 1 shows that the prefix verification process  is much lighter compared to prefix authorization.  Bloc kJack needs 92.12 seconds to verify 1000  prefixes or on average of 0.09 second per prefix.  Given the worst scenario that the growth projection  of 150 prefixes per day(Geoff, 2020) appear in the  concurrent time, and assume that the same amount  of prefix wit hdrew in the same time, then BlockJack  only need 27 seconds to verify the 300 updated  prefixes. This is below the 30 seconds BGP UPDATE  message interval. As an addition, none of the  consortium members growth will affect the  verification time because the pr ocess only need to  query the internal ledger without consortium  members’ approval. Moreover, Hyperledger Fabric  provides a World State so that the BlockJack does not  need to trace all log transactions to perform data  retrieval. Hence, in this case BlockJack can handle  Prefix verification without Local ROV cache  assistance.   However, verifying the global BGP routing table  would be so challe nging to conduct in one BGP  update message interval. Expect that the number of  the global routing table is 850,000(BGP Potaroo, 2020) and assume that the verification time per  prefix is 0.09 seconds, then the total time needed by  BlockJack to verify those prefixes on the first time  running is 76,500 seconds. That result is equal to  2,550 of the BGP UPDATE message interval. Hence,  the existence of a local ROV cache is crucial to reduce  the verification request during the BlockJack  operation. The Dispatcher c an compare the entry of  BGP routing table and the local ROV cache to find a  new prefix announcement or withdrawal  occurrences, and then verify those prefixes.  Moreover, any verification that exceeds the BGP  message interval is not impacting the BlockJack  because the Dispatcher is not dependent on any BGP  message signal as described in § 2.3.   Resiliency Analysis: BlockJack is able to neutralize  all adversarial prefixes that disrupt the BGP routing  table. BlockJack ignores the adversarial prefix under  the fol lowing conditions; first, an adversarial prefix  which does not take over the original prefix to be the  valid best path. This is possible when the position of  the original prefix is closer to the adversarial prefix or  the accumulation of all attribute value s of the  original prefix in the BGP table is better than the  adversarial prefix; second, when the position of the  AS path adversarial prefix overlaps with the other  adversarial prefixes. This will cause the adversarial  prefix with the longer AS path to be automatically  neutralized when the adversarial with the shorter AS  path is neutralized.   The results of BlockJack’s resilience evaluation  are depicted in Figure 4. We observe that the average  prepending time increases gradually in accordance  with the router addition in single path and multiple  path attack scenarios, while the average prependin g  time for random attacks seems to fluctuate. The  lowest prepending times for each single path,  multiple path and random attack scenario were  28.068, 41.855, and 52.101 seconds, which are  recorded during the experiment with 20 routers. The  average prependi ng time for all experimental sets on  single path, multiple paths and random attack  scenarios, respectively, is 74.527, 80.9088, and  54.9572 seconds.   Neutralization time looks constant in all scenarios  with an average of 0.1516 seconds in single path  scenar ios and 0.2362 seconds in multiple path  scenarios, except for random attack scenarios which  record an average neutralization time of 1.0484  seconds. The amount of neutralization time in  random attack scenarios is up to 5 times compared  to multiple path sce narios. This is because the number of neighbors in the random attack scenario  is greater than multiple path scenarios. From the five  adversarial prefixes sent, the average number of  attacks on the random scenario reaches 10.08  attacks, compared to 4.52 att acks received by  BlockJack routers in multiple path attack scenarios. If  we take a sample of random attack scenario with 50  routers, on average BlockJack needs 0.957 seconds  to neutralize 12.04 attacks of five experiment  attempts. That record is equal to 0 .08 seconds to  neutralize a single attack.   The standard deviation of prepending and  neutralization time is also seen constant in single  path and multiple path scenarios with an average  range of 8.2488 seconds to 11.6154 seconds for  prepending time and 0.01 62 seconds to 0.0188  seconds for neutralization time. While the average  standard deviation of prepending and neutralization  time in the random attack scenario was recorded at  20.3712 seconds and 0.8998 seconds, respectively.   6 Related Work   "
423,Effect of Packet Delay Variation on Video-Voice over DiffServ-MPLS in IPv4-IPv6 Networks.txt,"Over the last years, we have witnessed a rapid deployment of real-time
applications on the Internet as well as many research works about Quality of
Service (QoS), in particular IPv4 (Internet Protocol version 4). The inevitable
exhaustion of the remaining IPv4 address pool has become progressively evident.
As the evolution of Internet Protocol (IP) continues, the deployment of IPv6
QoS is underway. Today, there is limited experience in the deployment of QoS
for IPv6 traffic in MPLS backbone networks in conjunction with DiffServ
(Differentiated Services) support. DiffServ itself does not have the ability to
control the traffic which has been taken for end-to-end path while a number of
links of the path are congested. In contrast, MPLS Traffic Engineering (TE) is
accomplished to control the traffic and can set up end-to-end routing path
before data has been forwarded. From the evolution of IPv4 QoS solutions, we
know that the integration of DiffServ and MPLS TE satisfies the guaranteed QoS
requirement for real-time applications. This paper presents a QoS performance
study of real-time applications such as voice and video conferencing in terms
of Packet Delay Variation (PDV) over DiffServ with or without MPLS TE in
IPv4/IPv6 networks using Optimized Network Engineering Tool (OPNET). We also
study the interaction of Expedited Forwarding (EF), Assured Forwarding (AF)
traffic aggregation, link congestion, as well as the effect of performance
metric such as PDV. The effectiveness of DiffServ and MPLS TE integration in
IPv4/IPv6 network is illustrated and analyzed. This paper shows that IPv6
experiences more PDV than their IPv4 counterparts.","This Internet Protocol version 4 (IPv4) is one of t he key foundations of the Internet, which is  currently serving up to four billion hosts over div erse networks. Despite this, IPv4 has still been  successfully functioning well since 1981. Over the last couple of years, the massive growth of  the Internet has been evident requiring an evolutio n of the whole architecture of the Internet  Protocol. Therefore, in order to strengthen the exi sting architecture of Internet Protocol, IETF  has developed Internet Protocol version 6 (IPv6) [1 ]. IPv6 offers a significant improvement over  IPv4 when it comes to the unlimited address space, the builtin mobility and the security  support, easy configuration of end systems, and enh anced multicast features, etc [2]. On the  other hand, due to the fascination of end users of the World Wide Web (WWW) and the International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.1, January 2012  28       popularity of realtime applications, we can now ob serve new increasing demands on realtime  multimedia services over the Internet. As the name implies, these services have timing  constraints due to their realtime nature. For inst ance, video and voice applications typically  have bandwidth, delay and loss requirements when th e data does not arrive in time turning the  play out process paused, which is annoying to the e nd users [3].  In such a new environment, as the expansion of the Internet continues, QoS is a basic  requirement in terms of provisioning the multimedia  services where deployment of IPv6 QoS is  underway. Today, there is limited experience in the  deployment of QoS for IPv6 traffic in  MPLS backbone networks in conjunction with DiffServ  support. Many organizations and  groups are still working in order to ensure a guara nteed service for the realtime applications as  a framework to the Internet. In that case, the IETF  has introduced several service models,  mechanisms, policies and schemes for satisfying QoS  demands. DiffServ [4] and MPLS [5] are  known as notable mechanisms to provide QoS guarante e [6]. The DiffServ architecture model  provides the most extended and attractive solution for QoS support in IPv4/IPv6 networks.  Scalability and traffic classification are main con cerns for DiffServ as it can handle large  number of data networks very efficiently.   This is accomplished through the combination of tra ffic conditioning and PerHop Behaviour  based (PHB) forwarding by using the field DSCP (Dif ferentiated Service Code Point) [7]. This  field exists in both IPv4 and IPv6 packet headers. MPLS is a network protocol technology that  helps to improve scalability and routing flexibilit y in IP networks. The conventional IP network  creates hot spots (Hyperaggregation) on the shorte st distance path between two points while  other alternative paths remain underutilized. For t his circumstance, IP network can experience  some problems such as longer delay, degradation in the throughput and packet losses. In such a  situation, MPLS TE is best suited for minimizing th e effects of congestion by bandwidth  optimization [8].  Combination of two QoS mechanisms (DiffServ and MPL S) has already been evaluated and  experimented on IPv4 environment whereas the deploy ment of IPv6 in MPLS networks, one of  the approaches called IPv6 MPLS over IPv4based cor e (6PE) has been undertaken in a greater  extent. In terms of IPv6 deployment in MPLS network s, there are four approaches including  IPv6 over a circuit transport over MPLS, IPv6 over IPv4 tunnels over MPLS, IPv6 MPLS with  IPv4based core (6PE), and IPv6 MPLS with IPv6base d core [9]. In such a case performance  evaluation of IPv6 MPLS with IPv6based core in con junction with DiffServ has not yet been  elaborately evaluated and experimented so far. Ther efore, in this paper, a comparative study has  been done on the performance evaluation of video an d voice over DiffServMPLS in IPv4/IPv6  networks. The research question to be examined in t his paper is formulated as follows: to what  extent does the performance of PDV for AF and EF PH Bs vary from DiffServMPLS/IPv4  network to DiffServMPLS/IPv6 network?  2.  RELATED WORK   "
73,Evaluation of energy consumption of reactive and proactive routing protocols in MANET.txt,"Mobile Ad hoc Network (MANET) is a distributed, infrastructure-less and
decentralized network. A routing protocol in MANET is used to find routes
between mobile nodes to facilitate communication within the network. Numerous
routing protocols have been proposed for MANET. Those routing protocols are
designed to adaptively accommodate for dynamic unpredictable changes in
network's topology. The mobile nodes in MANET are often powered by limited
batteries and network lifetime relies heavily on the energy consumption of
nodes. In consequence, the lack of a mobile node can lead to network
partitioning. In this paper we analyse, evaluate and measure the energy
efficiency of three prominent MANET routing protocols namely DSR, AODV and OLSR
in addition to modified protocols. These routing protocols follow the reactive
and the proactive routing schemes. A discussion and comparison highlighting
their particular merits and drawbacks are also presented. Evaluation study and
simulations are performed using NS-2 and its accompanying tools for analysis
and investigation of results.","  The advent of wireless mobile adhoc networks (MANE Ts) has offered an efficient and most  importantly cost effective technique to make use of  the availability of mobile hosts when no fixed  infrastructure is provided. In MANET, the mobile no des can easily communicate with each other  while they are freely moving around in different di rections. An adhoc network relies entirely on  nodes cooperation for forwarding information from d ata sources to intended destination nodes.  Some examples of mobile nodes in an adhoc network are laptop computers, smart phones and  personal digital assistants that interact directly with each other [1][16].There are many advantages  of such an adhoc network which include fast deploy ment, robustness, efficiency, and inherent  support for mobility.     The mobile nodes in MANET can be arbitrarily positi oned and are free to travel randomly at any  particular time, thus allowing network topology and  connections between mobile nodes to change  rapidly. This makes routing in MANET a challenge. R outing protocols helps MANET to perform  its function of routing of the data packets from th e source to the intended destination in the  network. Because of the occurrence of mobility, the  routing information will have to be changed  to reflect changes in link connectivity [1][2].    Researchers have become more interested on how to s ecure MANETs. They have suggested  several  methods  to prevent or  reduce the risk of  attacks on the mobile adhoc networks by using  International Journal of Computer Networks & Commun ications (IJCNC) Vol.9, No.2, March 2017   30   access control key management and trust models mech anisms [1][2].Energy consumption is a  very critical issue in MANET since mobile nodes are  often powered by limited battery resources.  Thus, network lifetime relies heavily on the energy  consumption of nodes. Saving energy is,  therefore, critical in order to prolong the lifetim e of the network. Figure 1 illustrates the  architecture of the Mobile Adhoc Network (MANET).    The paper is organized as follows. Section 2 review s the related work. Section 3 briefly describes  the studied routing protocols. Section 4 gives the details of simulation environment and energy  model. It also describes the implementation of the routing protocols and the simulation setup used  in this research. The Simulation results are shown in section 5. Finally section 6 describes our  conclusion and future scope.        Figure 1. MANET architecture    2.  RELATED WORK   "
453,Optimal Hub Placement and Deadlock-Free Routing for Payment Channel Network Scalability.txt,"As a promising implementation model of payment channel network (PCN), payment
channel hub (PCH) could achieve high throughput by providing stable off-chain
transactions through powerful hubs. However, existing PCH schemes assume hubs
preplaced in advance, not considering payment requests' distribution and may
affect network scalability, especially network load balancing. In addition,
current source routing protocols with PCH allow each sender to make routing
decision on his/her own request, which may have a bad effect on performance
scalability (e.g., deadlock) for not considering other senders' requests. This
paper proposes a novel multi-PCHs solution with high scalability. First, we are
the first to study the PCH placement problem and propose optimal/approximation
solutions with load balancing for small-scale and large-scale scenarios, by
trading off communication costs among participants and turning the original
NP-hard problem into a mixed-integer linear programming (MILP) problem solving
by supermodular techniques. Then, on global network states and local directly
connected clients' requests, a routing protocol is designed for each PCH with a
dynamic adjustment strategy on request processing rates, enabling
high-performance deadlock-free routing. Extensive experiments show that our
work can effectively balance the network load, and improve the performance on
throughput by 29.3% on average compared with state-of-the-arts.","Cryptocurrencies are gaining popularity in the financial ecosystem. However, the scalability issues of their underlying blockchain technology are still challenging. Since each trans action needs to be confirmed by the consensus mechanism, this can take several minutes to hours. Instead of continually improving the design of the consensus mechanism, a leading layer2 proposal for addressing the scalability challenge relies on offchain payment channels [1], [2]. The core idea is to move mass transactions submitted onchain to offchain and "
250,An Energy Efficient Routing Protocol for Wireless Internet-of-Things Sensor Networks.txt,"Internet of Things (IoT) are increasingly being adopted into practical
applications such as security systems, smart infrastructure, traffic
management, weather systems, among others. While the scale of these
applications is enormous, device capabilities, particularly in terms of battery
life and energy efficiency are limited. Despite research being done to
ameliorate these shortcomings, wireless IoT networks still cannot guarantee
satisfactory network lifetimes and prolonged sensing coverage. Moreover,
proposed schemes in literature are convoluted and cannot be easily implemented
in real-world scenarios. This necessitates the development of a simple yet
energy efficient routing scheme for wireless IoT sensor networks. This paper
models the energy constraint problem of devices in IoT applications as an
optimization problem. To conserve the energy of device nodes, the routing
protocol first aggregates devices into clusters based on a number of different
features such as distance from base station, data/message length and data
sensed from the environment in the current epoch. Then, a cluster head is
elected for each cluster and a directed acyclic graph (DAG) is generated with
all the cluster heads as nodes. Edges represent communication intent from
transmitter to receiver and the edge weights are computed using a formulated
equation. The minimum cost path to the base station is computed to allow for
efficient real-time routing. Sleep scheduling is also optionally used to
further boost network energy efficiency. The proposed routing protocol has been
simulated and outperforms existing routing protocols in terms of metrics such
as number of active nodes, energy dynamics and network coverage.","INTERNET of Things (IoT) [8] constitute a network of heterogeneous devices communicating and exchanging data * Corresponding Authoramongst themselves to provide smarter services to users. The ﬁeld of IoT has been witnessing increased research and development in several application areas. Smart home appliances and infrastructure, smart security and surveillance, smart road trafﬁc management and medical emergency re sponse systems are a few examples of IoT network’s use cases. IoT networks are enormous in scale and complexity, and comprise objects like Radio Frequency Identiﬁcation (RFID) tags, mobile phones and sensing devices to obtain data from the environment. Such devices, also referred to as sensor nodes, have low compute capability and limited battery life. The existing routing protocols for Wireless Sensor Networks (WSNs) [2] are complex in nature and demand a considerable use of processing power and memory which are scarce resources in the devices comprising an IoT network. There is hence, a need for simpler protocols that are able to efﬁcaciously conserve the energy of the devices. For an energy efﬁcient network, and especially one that involves cooperative devices, it becomes important to distribute the processing load of routing evenly amongst all devices in the network. This ensures that a larger number of devices will remain operational for extended periods of time. On the contrary, if this processing load attributed to routing, is subjected to only a subset of the devices in the network, then this subset of devices would consume their energies at a faster rate and hence run out of battery sooner than the rest of the network. The proposed routing protocol in this paper aims to solve this problem by distributing the routing effort which in turn guarantees increased operational time of the network. The working of the protocol is detailed in later sections. Moreover, it must be noted that the term node and device both refer to the sensor nodes in the IoT network and have been interchangeably used in the text.arXiv:1808.01039v2  [cs.NI]  8 Mar 20192 Apart from the sensor nodes, IoT networks also utilize base stations which are centers for data processing and storage. Base stations are more powerful as compared to the sensor nodes and hence come at a higher price. These are used in order to access network data and analyze it. There can be several models of IoT networks depending on the number of base stations used. For simulation of the proposed protocol, only a single base station is used as an end destination for the network data. The aim of the proposed protocol thus translates into ﬁnding an optimal energyefﬁcient path from the sensor nodes to the base station. Moreover, the protocol has to effectively minimize the energy expenditure of devices in the network and increase the network’s operational lifetime. There exist several mechanisms which can supplement the routing protocol in a network and help conserve energy [3]. One such popular approach is sleep scheduling. Sleep scheduling is widely employed in WSNs in order to avoid energy wastage which is caused by idle devices. Devices are chosen according to a predeﬁned metric and are put to sleep (powered off) for ﬁxed intervals of time through this mecha nism. There exist several sleep scheduling algorithms [14] that can be employed in an IoTbased WSN. Of these, approaches based on evolutionary algorithms have given promising results, and in particular [28], which introduces a Particle Swarm Optimization inspired sleep scheduling technique for WSNs, has been very successful. In this paper we utilize an amal gamation of two well known evolutionary techniques for the purpose of sleep scheduling: Genetic Algorithm (GA) [30] and Particle Swarm Optimization (PSO) [29] algorithm. This sleep scheduling mechanism is referred to as Genetic Swarm Optimization (GSO) in this paper. The working of GSO is explained in later sections. To summarize, the contributions of this paper are as follows: Formulation of green routing in IoT as an energy opti mization problem Devising a minimum energy (MINEN) routing protocol as a solution to the aforementioned optimization problem Supplementing the minimum energy routing protocol with a sleep scheduling mechanism, GSO, to enhance the energy conservation effort Performance comparison of the proposed protocol with two widely employed routing protocols as well as multi ple sleep scheduling techniques The rest of the paper is organized as follows. The problem statement is deﬁned in Section II. Section III describes related work in green routing and deployment protocols for IoTbased WSNs. Section IV details the working of the proposed routing protocol. Section V presents the simulation performed and the results obtained. The scope for future work and the conclusion are present in Section VI. II. P ROBLEM STATEMENT Sensor nodes in an IoT network generate data at a high and rapid rate. They communicate this data to the base station for processing purposes. They can also communicate with other sensor nodes for the purpose of eventually sending their data to the base station. Energy is spent both in transmissionand reception of this message. The amount of energy used in one successful message transmission depends on several variables, such as the distance of the node from the base station, length of the message to be delivered, cost of power ampliﬁcation before message transmission, and operational energy cost incurred by the transmitter and receiver hardware. Network communication links should be modeled in a manner which combines these variable costs to give a minimized additive output. The aim of a green routing protocol should be to compute a path among nodes from the sender to the base station, which minimizes this cost. Moreover, not every node is actively involved in the process of message generation and transmission at all times. Devices experiencing periods of such inactivity, wastefully consume energy waiting for interrupts and events to occur. Such waste ful usage of energy should be mitigated to contribute to energy cost optimization. This can be achieved by putting these devices to sleep . Nodes can also be clustered into groups and elected cluster ‘heads’ can aggregate messages for all the nodes in their group/cluster and collectively transmit them to the base station. This has been shown to reduce energy consumption in the network. A solution to the aforementioned problem(s) must meet the following objectives: The energy spent in transmission and reception of mes sages amongst the sensor nodes should be minimized Sensor nodes should be clustered together in an efﬁcient manner so that their messages are transmitted jointly and the network lifetime is increased Effective sleep scheduling measures may be incorporated into the algorithm to further augment the energy conser vation process We detail our proposed approach based on the above objec tives in Section IV . III. R ELATED WORKS "
325,Towards A Learning-Based Framework for Self-Driving Design of Networking Protocols.txt,"Networking protocols are designed through long-time and hard-work human
efforts. Machine Learning (ML)-based solutions have been developed for
communication protocol design to avoid manual efforts to tune individual
protocol parameters. While other proposed ML-based methods mainly focus on
tuning individual protocol parameters (e.g., adjusting contention window), our
main contribution is to propose a novel Deep Reinforcement Learning (DRL)-based
framework to systematically design and evaluate networking protocols. We
decouple a protocol into a set of parametric modules, each representing a main
protocol functionality that is used as DRL input to better understand the
generated protocols design optimization and analyze them in a systematic
fashion. As a case study, we introduce and evaluate DeepMAC a framework in
which a MAC protocol is decoupled into a set of blocks across popular flavors
of 802.11 WLANs (e.g., 802.11 b/a/g/n/ac). We are interested to see what blocks
are selected by DeepMAC across different networking scenarios and whether
DeepMAC is able to adapt to network dynamics.","The proliferation of the current Internet and mobile commu nications networked devices, systems, and applications has contributed to increasingly largescale, heterogeneous, dy namic, and systematically complex networks. A very recent forecast from International Data Corporation (IDC) estimates that there will be 41.6 billion connected wireless devices in 2025 [ 11]. This signi￿cant growth and penetration of vari ous devices come along with a tremendous increase in the number of applications supporting various domains and ser vices. The increasing availability and performance demands of these applications suggest that ""generalpurpose"" proto col stacks are not always adequate and need to be replaced by application tailored protocols. Ideally, protocols (e.g., for routing, congestion control, video streaming, etc.) will per form well across the entire range of environments in whichthey might operate. Unfortunately, this is typically not the case; a protocol might fail to achieve good performance when network conditions deviate from assumptions implicitly or explicitly underlying its design, or due to speci￿c imple mentation choices by domain experts. However, while this approach is increasingly becoming di￿cult to repeat, these designed protocols are deeply rooted in in￿exible, cradleto grave designs, and thus unable to address the demands of di￿erent network characteristics and scenarios [ 5,9]. We believe that MAC protocols have the potential to outperform their humandesigned process in certain scenarios as shown in [4]. Protocols designed using ML are not limited to human intuitions and may be able to optimize controlplane tra￿c and channel access in yet unseen ways. Unlike others, we focus on decoupling protocol features /functionalities in di￿erent technologies and scenarios. To accommodate our idea, we use control parameters. Taking physical layer as an example, no single physicallayer design can work well under all scenarios, hence the natural response of the standards bodies has been to specify designs with a large number of control parameters ranging from modula tion order and coding rate, to OFDM subcarrier spacing and cyclic pre￿x length, to transmit power, etc., such that a medium can be tuned to the speci￿c deployment scenario in the ￿eld. Each of these parameters has numerous set tings leading to a large number of choices, and it becomes extremely di￿cult for domain experts to design a control algorithm that chooses the right algorithm depending on the scenario and the varying network conditions. Therefore, due to heterogeneity and dynamically changing characteristics of networks (e.g., IoT), network protocol design requires a new approach in which control rule optimizations are not only based on closedform analysis of isolated protocols, but are based on highlevel policy objectives and a comprehensive view of the underlying components. Thus, it has now be come crucial to reengineer protocol designing process and shift toward a vision of an intelligent designing process that adapts and optimizes network protocols under various envi ronment contexts such as device characteristics, application requirements, user objectives, and network conditions. Given that networking ￿eld often deals with complex problems that require e￿cient solutions, exploiting Machine Learning (ML) techniques for solving these problems lookspromising. The value that such techniques can bring to the protocol design process comes from the ￿exibility of the pro tocol design process to construct protocols that can learn from their past experiences, and the ability to respond to network dynamics and environment conditions in realtime. Among ML techniques, Reinforcement Learning (RL) is suit able for the unknown environments where decisionmaking ability is crucial. Recently, Deep learning (DL) and Deep Reinforcement Learning (DRL) [ 35] techniques have been applied to various protocol and radio optimization tasks in cluding routing [ 24], congestion control [ 80], MAC [ 55][82] and frequency estimation in PHY layer [ 90], just to name a few. To the best of our knowledge, the current e￿orts in ap plying DL to enhance protocol performance focus only on tuning orcontrolling protocol parameters. Applying such DL based techniques can reduce manual humanbased e￿orts to tune protocol parameters. However, the blackbox nature of DLbased techniques leave us little insight about how they work. Joseph et al. [ 32] show how to design a DLbased control algorithm to jointly control two parameters namely modulation order and transmit power scaling. In their work, they show that applying DL technique may work well to control the two aforementioned parameters, but depending on the context (di￿erent devices, throughput targets, etc.,) it becomes extremely complicated to get enough insights about how blackbox DL technique works, even only for tuning two parameters from a large set of available control parame ters. We believe that optimizing a protocol performance goes beyond individual protocol parameter tuning . In this paper, we propose a novel DRLbased framework that is not only capable of tuning protocol parameters, but also optimizing the main functionalities for each protocol. In the proposed framework, a protocol is decoupled into a set of parametric modules as DRL inputs, each representing a main protocol functionality referred as Building Blocks (BBs). This modularization technique helps to better understand the generated protocols, optimize the protocol design, and analyze them in a systematic fashion. These BBs and a set of other parameters are fed into the DRL agent as the input. The DRL agent then is able to learn what protocol blocks (components) are important to be included or to be excluded from the protocol design. Note that our proposed framework is generic for designing networking and communication protocols in all layers of network stack. As a case study in this paper, we narrow down our focus to propose a DRLbased framework for designing wireless MAC protocols hereafter DeepMAC as a version of the proposed framework. InDeepMAC framework, MAC protocols are decoupled into a set of parametric modules, each representing a main functionality across popular ￿avors of 802.11 WLANs (IEEE 802.11 b/a/g/n/ac amendments). As we showcase in Section 6,the DRL agent learns that when the load of the network is very low, it could eliminate control and sensing mechanisms (ACK and Carrier Sensing blocks, respectively) to increase the throughput of the channel by reducing the bandwidth overhead and waiting time introduced in these mechanisms. Therefore, this framework could serve as a tool for protocol designers to rethink the blocks used in a designed proto col. In addition, our framework could be utilized as a multi variant optimization tool that helps in alleviating the current protocol design process. By using this framework, domain experts provide the required speci￿cations (objective) for a speci￿c scenario as DRL input and could identify/capture the role that each protocol component (block) plays in varying scenarios for di￿erent objectives. It could also help domain experts to get insights about the relation between di￿erent protocol components for di￿erent objectives, although such components may not have a direct dependency/relation to each other if considered alone. Contributions The main contributions of this paper are summarized as follows. i) We motivate a novel learningbased protocol design approach that not only tunes the protocol parameters but also optimizes the protocol design by leveraging the concept of demodulating a protocol into its set of main functionalities referred as building blocks. ii) To show the feasibility of our framework, we propose DeepMAC , a novel deep reinforcement learningbased frame work that targets the design of 802.11 MAC protocols based on the given networking scenario. Evaluation results shows that DeepMAC can intelligently selects the optimum proto col design for a given objective (higher throughput) under di￿erent scenarios and outperforms conventional conven tional protocols e.g., CSMA/CA. By using the demodulating concept, we are able to interpret DeepMAC behavior under di￿erent scenarios. 2 BACKGROUND Reinforcement learning is a machine learning technique where the agent interacts with a timevariant environment that can be modeled as a Markov Decision Process (MDP), a Partially Observable MDP (POMDP), a game, etc. The core components of RL technique are the environment ,reward (A),possible set of actions ( A)andstates ( S). The state is the agent’s perception of the environment and is de￿ned based on the agent’s sensory information. The agent selects anaction in a given state and receives a reward . Actions are the agent’s methods which allow it to interact and change its environment, and thus transfer between states. The policy c prescribes actions to take in a given state. We can then value a given state Band a policy cin terms of expected future rewards. 2Every RL algorithm must follow policy cin order to de cide which actions to perform at each state. RL algorithms are mainly categorized into onpolicy and o￿policy rein forcement learning. Algorithms which concern about the policy which yielded past stateaction decisions are referred to as onpolicy algorithms, while those ignoring it are known as o￿policy. In other words, there are two main methods to solve RL problems: calculating the value functions or Q values of each state and choosing actions according to those, or directly compute a policy which de￿nes the probabilities each action should be taken depending on the current state, and act according to it. A well known o￿policy algorithm is Qlearning [ 76], as its update rule uses the action which will yield the highest Qvalue, while the actual policy used might restrict that action or choose another. The onpolicy variation of QLearning is known as SARSA, where the up date rule uses the action chosen by the followed policy. For a more thorough review of reinforcement learning please see [43,66]. There are many di￿erent variations and assump tions that change the methods in a RL problem; here we focus on QLearning. QLearning (QL) is one of the most popular o￿policy algorithms in RL. It is also regarded as temporal di￿erence learning that learns an actionvalue function to ￿nd a Qvalue for each stateaction pair. QL agent learns its optimal policy by exploring and exploiting the environment. At each time instant C, the agent observes the current state BCand chooses a proper available action 0Cfrom this state to maximize the cumulative reward in time instant C+1. More formally, the Qvalue of (BC,0C)from the policy cwhich is denoted as &c(BC,0C)is the sum of discounted reward received at time C+1when action 0Cis taken in state BC, and it follows the optimal policy c⇤, thereafter. The Qvalues are updated using the following rule known as one of the Bellman equation forms: &(BC,0C) &(BC,0C)+U[AC+1+Wmax0C+1&(BC+1,0C+1)"
215,EAGP: An Energy-Aware Gossip Protocol for Wireless Sensor Networks.txt,"In Wireless Sensor Networks (WSN), typically composed of nodes with resource
constraints, leveraging efficient processes is crucial to enhance the network
lifetime and, consequently, the sustainability in ultra-dense and heterogeneous
environments, such as smart cities. Particularly, balancing the energy required
to transport data efficiently across such dynamic environments poses
significant challenges to routing protocol design and operation, being the
trade-off of reducing data redundancy while achieving an acceptable delivery
rate a fundamental research topic. In this way, this work proposes a new
energy-aware epidemic protocol that uses the current state of the network
energy to create a dynamic distribution topology by self-adjusting each node
forwarding behavior as eager or lazy according to the local residual battery.
Simulated evaluations demonstrate its efficiency in energy consumption,
delivery rate, and reduced computational burden when compared with classical
gossip protocols as well as with a directional protocol.","Wireless Sensor Networks (WSN) are composed of several nodes with a spe cic purpose of monitoring diverse types of systems and physical phenomena. Typically, these nodes are small and lowcost devices designed to run on lim ited energy resources. Depending on the deployment scenario, they should not receive maintenance intervention for years, making it imperative to design opti mal strategies towards lowering the required power to sense, process, store, and mainly to forward data, as the communication subsystem is predominantly the most demanding [1] [2]. The way data is transmitted through a WSN is directly related to the un derlying application requirements. When it demands ecient dissemination of the acquired data to all nodes, usually, it is employed some form of epidemic distribution, being the gossip protocol family the most common [3]. In thesearXiv:2007.12906v1  [cs.NI]  25 Jul 20202 B. Chianca et al. protocols, a node immediately forwards messages to all or a subset4of its neigh bors, assuring high delivery eciency and network coverage, though, with the disadvantage of wasting energy with excessive message redundancy. For appli cations requiring data delivery to a central entity, e.g., a base station or a sink, directional routing protocols prevail, as they are ecient in terms of delivery with reduced redundancy. However, they provide lower network coverage, and might lead to battery depletion of nodes in the best path faster, creating energy unbalance, and in extreme cases, completely isolating part of the network. In this context, this work proposes an EnergyAware Gossip Protocol (EAGP) able to reduce data redundancy while providing high delivery rate and broad network coverage. The aim is to extend the network lifetime by dynamically op timizing the energy consumed in data dissemination according to the remaining battery level of nodes into the same range. The rationale is to selfadjust which nodes will forward a received message, and the time they wait to do so. In this way, nodes with higher level of residual battery assume an eager behavior, whilst nodes with lower levels wait and only forward the message in case of failure, i.e., lazybehavior. Simulated results evince that, for diverse scenarios, the proposed protocol achieves better performance regarding network longevity and delivery eciency when compared to classic gossip protocols, including a fanout version. Moreover, the evaluation also demonstrates promising enhancements compared to a direct routing protocol due to its ability to promptly adapt the distribution topology in case of node mobility or failure. An additional contribution from this work is a publicly available framework designed for easy and modular deployment of dierent protocols, test scenarios, and performance evaluation5. Built over a wellestablished simulation engine (see Section 4), this framework might shorten development and optimizations required by specic applications. This paper is organized as follows: related work is discussed in Section 2; the proposed protocol design goals and rationale are presented in Section 3; the methodology of tests is presented in Section 4; the proofofconcept and the corresponding evaluation results are discussed in Section 5; and the conclusions are summarized in Section 6. 2 Related Work "
258,The Engineering of a Scalable Multi-Site Communications System Utilizing Quantum Key Distribution (QKD).txt,"Quantum Key Distribution (QKD) is a means of generating keys between a pair
of computing hosts that is theoretically secure against cryptanalysis, even by
a quantum computer. Although there is much active research into improving the
QKD technology itself, there is still significant work to be done to apply
engineering methodology and determine how it can be practically built to scale
within an enterprise IT environment. Significant challenges exist in building a
practical key management service for use in a metropolitan network. QKD is
generally a point-to-point technique only and is subject to steep performance
constraints. The integration of QKD into enterprise-level computing has been
researched, to enable quantum-safe communication. A novel method for
constructing a key management service is presented that allows arbitrary
computing hosts on one site to establish multiple secure communication sessions
with the hosts of another site. A key exchange protocol is proposed where
symmetric private keys are granted to hosts while satisfying the scalability
needs of an enterprise population of users. The key management service operates
within a layered architectural style that is able to interoperate with various
underlying QKD implementations. Variable levels of security for the host
population are enforced through a policy engine. A network layer provides key
generation across a network of nodes connected by quantum links. Scheduling and
routing functionality allows quantum key material to be relayed across trusted
nodes. Optimizations are performed to match the real-time host demand for key
material with the capacity afforded by the infrastructure. The result is a
flexible and scalable architecture that is suitable for enterprise use and
independent of any specific QKD technology.","1.1. Background Secure network communication is a principal function of IT infrastructure. In particular, secure interdomain communication is important to larger organizations that are distributed across multiple geographical sites. Computing hosts on a local site will regularly establish communication sessions with arbitrary computing hosts of a remote site. The key management service of an IT security system will typically provide a data encryption service on top of a standard network protocol. Although there are many commercially available cryptosystems in use today, the majority of them rely upon key exchange under publickey cryptography where the computational problem is infeasible to break using today's computing technology. However, rapid advances are occurring in the eld of quantum computing. Once a quantum computer is built to solve problems of a practical scale, currentlydeployed conventional public key cryptography will become completely vulnerable to attack, and a new way of protecting transactions over a network will be needed. New quantumresistant publickey cryptography, also known as postquantum publickey cryptography, is being researched and experimented on, and there is growing eort toward its global standardization. While promising, and an important part of the future cryptographic landscape, postquantum cryptography is still potentially vulnerable to future (quantum and classical) algorithmic advances. In particular, there has been limited scrutiny against novel quantum cryptanalysis, especially considering the lack of a largescale quantum computer to facilitate the design and testing of new quantum algorithms and heuristics. Furthermore, post quantum key establishment is susceptible to being recorded and cracked at a future date. To mitigate the risk of successful attack, Quantum Key Distribution (QKD) has been devised, which is based on the laws of quantum physics and is a theoretically secure form of generating keys that is resistant to attacks by both conventional and quantum computers. There has been signicant research activity over recent years relating to the theory and implementation of QKD techniques. QKD is already in operation today in largescale experiments using commerciallyavailable equipment, and promising research has been presented on how trusted nodes can be utilized to build a larger system. However, there is still work to be done to determine how QKD key management can be practically utilized within an enterprise environment to  exibly serve a large host population, from a practical engineering perspective. QKD must evolve from pointtopoint links to network designs that can support high user populations over wide geographical coverage [1]. 1.2. Our Contributions and Impact The overall goal of our work has been to show the feasibility of integrating QKD technology with classical networks, to uncover unique design challenges and propose  exible solutions, and to provide a holistic view of a system as a viable target for migration. We viewed the problem primarily from an engineering lens. Our aim has been to apply best practices in contemporary security, network, and software engineering, including leading industry practices, in the application of QKD to practical realworld systems.3 Our main contribution is the design of a scalable QKDbased system that enables secure multisite communication, and is compatible with various QKD technologies. We provide a scalable service to support enterpriselevel secure trac between arbitrary hosts in a large metropolitan network comprising sites that may be indirectly connected. The architecture consists of a full protocol stack, including an enterprise level key management layer that manages and issues keys to hosts from a key pool, and a quantum network layer that performs quantum key generation via trusted nodes. To maximize eciency, the key generation system dynamically adapts to changes in demand and network infrastructure based on realtime monitoring and prediction from history. Hosts are issued session keys to securely communicate over a conventional network, while quantum key generation occurs over quantum links that may form an independent topology. Integrations with standards such as TLS, IPSec, and Kerberos have also been studied. The results of the research included design artifacts to lay the groundwork for the implementation of a research test bed or a pilot system for industry use. Our work has numerous impacts: it informs QKD practitioners and equipment designers of the operating requirements of such an enterprise system; it informs architects of key design choices and tradeos to make when incorporating QKD technology into a communications system; and, it demonstrates to software engineers how client applications can be built to make use of secure QKD key material in transparent fashion. These insights aim to tackle what sometimes appear to be insurmountable obstacles in standards acceptance and widespread use of QKD, despite its compelling intrinsic security benets. Our research shows how the integration of QKD has implications on the entire systems design, and we suggest new avenues for study in the areas of security and network engineering to make QKD practical for widespread use. We concur with the ultimate goal cited in [2]: to realize a quantum safe infrastructure in which postquantum cryptography, QKD, and physicallayer cryptography will be integrated. This article presents a highlevel architecture and design of a QKDenabled communications system, to show how enabling quantumsafe communication security poses unique challenges to traditional network engineering; furthermore, it demonstrates how a feasible solution requires signicant interplay between the various networking domains, from security protocols at the user level to network management at the infrastructure level. In the rest of this Section 1, related literature on practical deployment of QKD through protocol and network design is discussed, followed by a model which describes the typical enterprise network where quantum safe communications security is desired. In Section 2, the overall design is presented, consisting of a layered protocol stack; the functionality and responsibility of the various layers that make up the protocol stack are described in turn from toptobottom. In Section 3, the main procedures that run in the system within the various layers of the stack and spanning them are described, including: the issuance of keys to hosts, demand management, and synchronization of the quantum key pool in the service layer, and the various key generation, routing, scheduling, and relaying functions of the control and data planes of the network layer. In Section 4, the trust and security models are described, and as well as options for integration with postquantum algorithms to attain further security robustness. Finally, in Section 5, the key lessons learned throughout the design process are summarized, and recommendations given for further work in this area.4 1.3. Related Work "
92,Learning to Solve Vehicle Routing Problems with Time Windows through Joint Attention.txt,"Many real-world vehicle routing problems involve rich sets of constraints
with respect to the capacities of the vehicles, time windows for customers etc.
While in recent years first machine learning models have been developed to
solve basic vehicle routing problems faster than optimization heuristics,
complex constraints rarely are taken into consideration. Due to their general
procedure to construct solutions sequentially route by route, these methods
generalize unfavorably to such problems. In this paper, we develop a policy
model that is able to start and extend multiple routes concurrently by using
attention on the joint action space of several tours. In that way the model is
able to select routes and customers and thus learns to make difficult
trade-offs between routes. In comprehensive experiments on three variants of
the vehicle routing problem with time windows we show that our model called
JAMPR works well for different problem sizes and outperforms the existing
state-of-the-art constructive model. For two of the three variants it also
creates significantly better solutions than a comparable meta-heuristic solver.","The standard CVRP is a NPhard combinatorial optimization problem which consists of ﬁnding the optimal set of tours for a ﬂeet of capacitated vehicles which have to serve the varying demand of multiple customers. However, for many practical scenarios the problem model of the CVRP is oversimpliﬁed and leads to highly suboptimal solutions since it only takes distances into account. Therefore an important extension introduces an additional time dimension with respective time windows. The CVRPTW consequently has a high relevance for many practical applications and has been a subject of study for several decades in the Operations Research community [26, 4, 27]. Since the seminal work of Vinyals et al. [30] showing that deep learning methods are a valid approach to solve combinatorial optimization problems, the ﬁeld has evolved in recent years. Apart from general graph related problems like maximum cut [ 15] or link prediction and graph partitioning [ 31], the Traveling Salesman Problem (TSP) was most extensively covered [ 1,15,6,7,33]. Meanwhile however, there exist also several approaches to solve VRPs [20, 17, 5, 18]. In the same way as traditional heuristics for routing problems can be categorized as construction or improvement heuristics [ 27], respective learned methods exhibit some similar characteristics. While the ﬁrst approaches of Nazari et al. [20] and Kool et al. [17] construct a solution to the CVRP sequentially one node at a time, other work [ 5,18] focuses on iteratively improving an existing solution. In general improvement approaches assume an existing start solution which they can iteratively improve. While such an initial solution might be easily found for simple problems like the TSP or CVRP, this is increasingly difﬁcult for more constrained problems. In fact just ﬁnding a ﬁrst feasible solution for the CVRPTW given a ﬁxed number of vehicles is a NPhard problem all by Preprint. Under review.arXiv:2006.09100v1  [cs.LG]  16 Jun 2020itself [ 22]. Another shortcoming of improvement approaches lies in their expensive iterative nature. Compared to construction methods which can produce a useful solution in one forward pass within seconds, iterative improvement requires a not negligible number of iterations to achieve a suitable performance. This number grows relative to the problem complexity, number of customers Nand the quality of the initial solution while constructive approaches always require only Nsteps for greedy decoding. Finally an improvement method can always be used on top of the solution produced by constructive approaches. One drawback of existing sequential construction approaches in case of the CVRPTW is the very limited information on which the next decision of the agent is based. While our results show that this is of minor concern for the CVRP, the highly restricted solution space of the CVRPTW leads to large inefﬁciencies when tours are created sequentially without any information about the other tours at a given time. Most importantly this problem is not resolved by search and sampling methods often employed for constructive methods, since they represent a very inefﬁcient way of exploring the space of sequentially constructed solutions. Contributions: 1.We show that existing constructive machine learning methods for other, less constrained dis crete optimization problems cannot easily be generalized to the CVRPTW and hypothesize that this is due to consecutively constructing single tours. 2.We propose a more expressive policy model JAMPR, that operates on several tours in parallel. To do so, we designed (i) a more comprehensive state and action space than existing methods, providing sufﬁcient information about other tours based on an enhanced feature embedding for nodes, tours and vehicles, and (ii) a policy decoder model that jointly selects both, the next location to visit and the tour to which this location should be added. 3.In experiments on three variants of the CVRPTW ( hard,partlysoft ,soft) we show that our method provides vastly better solutions than existing discrete optimization methods as well as stateoftheart ML methods adapted to cope with time windows for two of these settings, while being on par with the discrete optimization methods for the third setting, still outperforming the adapted machine learning methods there. 2 Related Work "
410,A Theory of Composing Protocols.txt,"In programming, protocols are everywhere. Protocols describe the pattern of
interaction (or communication) between software systems, for example, between a
user-space program and the kernel or between a local application and an online
service. Ensuring conformance to protocols avoids a significant class of
software errors. Subsequently, there has been a lot of work on verifying code
against formal protocol specifications. The pervading approaches focus on
distributed settings involving parallel composition of processes within a
single monolithic protocol description. However we observe that, at the level
of a single thread/process, modern software must often implement a number of
clearly delineated protocols at the same time which become dependent on each
other, e.g., a banking API and one or more authentication protocols. Rather
than plugging together modular protocol-following components, the code must
re-integrate multiple protocols into a single component.
  We address this concern of combining protocols via a novel notion of
'interleaving' composition for protocols described via a process algebra.
User-specified, domain-specific constraints can be inserted into the individual
protocols to serve as 'contact points' to guide this composition procedure,
which outputs a single combined protocol that can be programmed against. Our
approach allows an engineer to then program against a number of protocols that
have been composed (re-integrated), reflecting the true nature of applications
that must handle multiple protocols at once.
  We prove various desirable properties of the composition, including behaviour
preservation: that the composed protocol implements the behaviour of both
component protocols. We demonstrate our approach in the practical setting of
Erlang, with a tool implementing protocol composition that both generates
Erlang code from a protocol and generates a protocol from Erlang code. This
tool shows that, for a range of sample protocols (including real-world
examples), a modest set of constraints can be inserted to produce a small
number of candidate compositions to choose from.
  As we increasingly build software interacting with many programs and
subsystems, this new perspective gives a foundation for improving software
quality via protocol conformance in a multi-protocol setting.","Protocols are everywhere. Whenever two entities need to communicate (perhaps via function calls, or messages sent over a channel), a protocol can be used to ensure that both parties effectively exchange information. Protocols can be seen as a specification of communication, and as such have been leveraged for the purposes of verification in programming languages, e.g., session types [9, 25, 26, 27], choreographies [13, 14, 39], typestate [42], behavioural types in general [21, 30], and more. There may be many protocols that a program has to conform to, capturing different interactions between different parts of a system. Here we use the term protocol to denoteaspecificationoftheinteractionpatternsbetweendifferentsystemcomponents. For example, when considering distributed systems, a protocol may describe the causalities and dependencies of the communication between processes. To give a moreconcreteintuition,aninformalspecificationofaprotocolforanebankingsystem may be as follows: The banking server repeatedly offers a menu with three options: (1) request a banking statement, which is sent back by the server , (2) request a payment, after which the client will send payment data, or (3) terminate the session. We elaborate on this example later, using it as a motivating example. Much of the work on systematising the process of programming against a specifica tion assumes a monolithic view of protocols: a protocol is often given for the entire system, explaining the communication between all parties involved. This upfront, single point of definition runs contrary to the human aspects of realworld program ming, in which a programmer gradually pieces together their code, perhaps heavily leveraging libraries, to reach their intended goal; programs are gradual compositions . A view that is globally defined once does not reflect the real process of software composition. In contrast, a view that defines lots of local protocols or subprotocols places the burden of configuring their interaction on the programmer: programmers must themselves work in a situation where they have to consider many smaller protocols and work out how they want dependencies between them to be resolved. Instead, we propose that a flexible, nonmonolithic notion of protocol composition (and possibly recomposition, when a piece of code is refactored and rewritten, or reused) is needed to support the engineering of protocoldependent code. Ideally, such a notion should support wellfounded semiautomated protocol composition and support implementation with formal guarantees. This work lays a foundation for compositional protocol engineering based on a notion of interleaving composition of protocols. An interleaving composition of two protocols ‘weaves’ them together into a single unified protocol. This differs from sequential composition, in which one protocol follows the other or one’s inputs are coupled to the other’s outputs. It differs from parallel composition, which traditionally (e.g., in CCS or CSP) describes a semantic interleaving of programs; our approach calculates a single syntactic protocol specification. We address, in general terms, the question of what a correct protocol composition is, and introduce a syntactic definition of composition that characterises finite sets ofcorrectinterleaving compositions, each representing a ‘good way’ to interleave the component protocols with respect to domainspecific userspecified constraints. 6 :2Laura Bocchi, Dominic Orchard, and A. Laura Voinea The resulting approach gives a theoretical basis for protocol (re)engineering based on a process calculus with constraint annotations. Interleaving composition has the purpose of enhancing the awareness of what a protocol means, and facilitating reasoning about its properties. We give an algorithmic implementation of interleaving compositionsupportingtheprocessofdefiningprotocolsandinspectingthegenerated compositions,andcodegenerationofskeletonsofprocessesfollowingagivenprotocol (composite or not). Code generation is based on Erlang/OTP gen_statem behaviour [1] allowingcodetobemigratedinsubsequentcompositionsandreused.Correspondence of our protocol language with Finite State Machines (FSM) via directed graphs yields straightforward links between protocols and FSMstructured code. Arelatedlineofworkdefinescompositionas runtime weaving ,forexampleapplying principles of aspectoriented programming to protocol composition [43]. Unlike [43], we statically derive protocol compositions that enable (human/automated) reason ing and verification of their properties. Another related line of work is automata composition [7, 20, 23]. Team Automata [7, 20] provide several means of composing machines via synchronization on their common actions, and give a formal frame work for composition. Unlike Team Automata, we express composition constraints orthogonally to communication: instead of synchronization on common actions, we use ‘asserts’/‘requires’ as contact points for composition, and reason about the prop erties of a composite protocol from the perspective of the application logic. The resulting composition relation given in this work is not characterizable as one of the synchronizations of Team Automata (discussed further in Section 6). Unlike in aforementioned works, our protocols are monothreaded. This is not unusual in literature, e.g., session types are essentially monothreaded [9, 25, 26]. Also realworld protocols, such as POP2, POP3, and SMTP, are described in their RFCs as single state machines and have been modelled, without parallel composition, as session types [11, 22, 29]. Still, one could use parallel composition as a basis for defining protocol compositions (as in Team Automata), and this would yield general and syntactically concise concurrent specifications. These concurrent specifications, with all their interleavings, would be harder for a human to understand than a well specified interleaving composition. We explore an unusual approach to composition, with the purpose of supporting a process of human understanding of what protocol compositionshouldbe.Ournovelapproachisalsoreflectedinthetool.Thecodeforthe composition of two protocols is not the composition of the existing implementations (plus some adaptor code) – as one would expect. The tool generates new code via: (1) automated generation of a stubs of the new composite protocol, and (2) migration of relevant parts of the old code – besides the stub infrastructures – into the new code. This yields simple monothread code that are still close to the protocol’s structure. 1.1 Motivating Example Thebankingprotocoldiscussedearlierinthissectioncanbeformallyspecifiedas SBin Figure 1 using a process calculus notation. SBrepeatedly (via a fixed point µt) offers (denoted &) three options: option statement is followed by a send action (denoted !) of a message with the bank statement, option payment is followed by a receive action 6 :3A Theory of Composing Protocols SB:=µt.&  statement : !statement .t payment : ?details .t logout :end   SA:=?pin.⊕  ok:µr.!id.?tan.⊕/braceleftbig5 ok:r fail:r/bracerightbig5 fail:end   Figure 1 Banking ( SB) and PIN/TAN authentication ( SA) protocols. The arrows show the desired dependencies: entering the loop in SBrequires correct PIN authentication (i.e., at ok, first occurrence in SA) and each payment iteration in SBrequires TAN authentication. (i.e., at ok, second occurrence in SA). (denoted ?) with details of the payment, and option logoutis followed by termination of the protocol (denoted end). After each of the first two options, the control flow goes back to the initial state (via t). Assume now that we want to extend SBwith twolevel authentication: one level for accessingtheserviceandoneadditionallevelforeachpaymenttransaction.Concretely, wewishtocompose SBwiththePIN/TAN(PersonalIdentificationNumber/Transaction Authentication Number) protocol modelled in Figure 1 as SAwhich offers twostage authentication. The first stage is pin authentication: the server receives a pinand decides (⊕) whether to continue (i.e., ok) or terminate (i.e., fail). If okis chosen, the protocol enters a loop (i.e., µr) that manages multiple TAN authentications, supporting multiple transactions requiring an additional level of security. In the loop, the server sends an identifier idfor which the client must send back a tan. The server notifies the client about the correctness of the tanwith either okorfail. We want to compose the banking and authentication protocols into a single proto col where their actions follow a specific interleaving: access to the banking service requires a PIN authentication, and each payment instance/iteration requires an extra TAN authentication (see dotted arrows in Figure 1). This specific interleaving entails an authorization property, which we later express and ensure by using assertion anno tations.Moreover,wewanttoolsthatfacilitateengineeringofprogramsimplementing interleaving compositions. For example, we want to obtain a skeleton implementation for the banking and PIN/TAN protocol, and in a second stage we want to reuse the code when composing banking with a different multifactor authentication protocol, e.g., offering other options besides TAN, such as keycard authentication. 1.2 Contributions InSection2,wedefineaprocesscalculusbasednotationforprotocolswith‘assertions’. Assertions specify contact points and constraints between component protocols, to be checked statically. In Section 3, we give a definition of interleaving composition that is relational, as there may be many valid interleaved protocols (or even none). In Sec 6 :4Laura Bocchi, Dominic Orchard, and A. Laura Voinea tion3.1.1weprovidetwolessrestrictivedefinitionsofinterleavingcompositionviatwo additionalrules, weak branching and correlating branching thatcapturemorescenarios but enjoy a weaker fairness properties. In Section 4, we prove that our composition relation returns correctinterleaving compositions, namely: ( behaviour preservation ) interleaving compositions only perform sequences of actions that may be performed by either of the component protocols; ( fairness) interleaving compositions eventually execute the next available action of each protocol; ( wellassertedness ) interleaving compositions always satisfy requirements prescribed by the assertions in the protocols being composed. Thus, we establish that the composition relation produces sets of protocolcompositionsthatarecorrectbyconstruction.Ourdefinitionissoundbutnot complete, as discussed in Section 4.4. In Section 5, we introduce a tool for protocol engineering in Erlang, which implements interleaving composition, generation and protocolextractionto/fromErlang gen_statem code.Section6discussesrelatedwork. 2Asserted Protocols We introduce a language of protocol specifications to abstractly capture essential features of sequential computation: sequencing, choice, and looping. Our protocol language somewhat resembles Milner’s CCS [38] or the πcalculus [41], but without parallelcompositionornamerestriction,andhassomerelationtoKleenealgebras[34] but we provide more general patterns of recursion via recursive binders rather than a single closure operator. Generally, two protocols can be composed in several ways, each reflecting a possible interleaving of the actions of the two protocols. Not all such interleavings are meaningful depending on the scenario or domain. The protocol language therefore includes a notion of ‘assertions’ which can be used to capture the behaviouralconstraintsofaprotocoltoguideinterleavingcompositioninameaningful way; they act as a specification of minimal ‘contact points’ between protocols akin to preandpostconditions.Followinganexplanationofthesyntaxandvariousexamples, we give an operational model to the protocol language which serves to explain both the program semantics which it abstracts, and the meaning of the assertion actions. Definition 1 (Asserted protocols) Asserted protocols, or just protocols for short, are ranged over by Sand are defined as the following syntax rules: S::=p.S action prefix |+{li:Si}i∈I branching |µt.S fixedpoint | t recursive variable | end end | assert(n).S assert (produce)/bracerightbig5 assertion fragment | require(n).S require | consume(n).S consume where p∈/Pcal ranges over prefixing actions, l∈/Lcal ranges over labels used to label each branch of the nary branching construct, tranges over protocol variables for recursive 6 :5A Theory of Composing Protocols protocol definitions, and n∈/Ncal ranges over names of logical atoms used by assertions. The sets of actions/Pcal, labels/Lcal, and names/Ncal are parameters to the language and thus can be freely chosen. Furthermore +ranges over a set of operators /Ocalused to represent branching choice and thus can also be instantiated. Theprefixingactionprovidessequentialcomposition(inthestyleofprocesscalculi). Branching is nary, taking the form of a set of protocol choices with a label lifor each choice. Looping behaviour is captured via the recursive protocol variable binding µt, which respects the usual rules of binders, and recursion variables t. Protocols can be annotated with assertions to introduce guarantees assert(n), requirements require(n), and linear requirements consume(n):assert(n)introduces a true logical atom ninto the scope of the following protocol, require(n)allows the protocol to proceed only ifnis in the scope (basically consume(n)presupposes require(n)), and consume(n) removes the truth of logical atom nfrom the scope of the following protocol. We assume variables to be guarded in the standard way (they only occur under actions or branching). To simplify the theory, we assume that: (1) nested recursions are guarded, ruling out protocols of the form µt.µt′.S, with no loss of generality sinceµt.µt′.Sis behaviourally equivalent to µt.S[t/t′], and (2) inµt.Svariable t occurs free at least once in S, with no loss of generality since e.g., µt.?pay.endis behaviourally equivalent to ?pay.end. Unless otherwise stated, we consider protocols to be closed with respect to these recursion variables. Remark 1 (Language instantiation) In the examples we often instantiate the prefixing actions/Pcal to sends !Tand receives ?Tcapturing interaction with some other concurrent program, i.e., p∈{!T, ?T}where Tis a type ( e.g., integers, strings), and instantiate choice+to a pair of polarised choice operators:+∈{⊕ , &}, either offering of a choice ⊕ or selecting from amongst some choices &. This yields a session typeslike syntax similar to the one used by Dardha, Giachino and Sangiorgi. [18]. Examples often colour assertions greenand labels purplefor readability. 2.1 Assertion Examples Consider a payment process ?pay.endthat receives a payment and terminates, and a dispatchprocess !item .endthatsendsaproductlinkandterminates.Wecaninterleave these two protocols in two ways: ?pay.!item .end(payment first) or !item .?pay.end (dispatch first). By using assertions, we can require that payment happens before dispatch: below, I1asserts the logical atom paidas a postcondition to receiving payment while in I2the sending action depends on the logical atom paidas a pre condition, and in doing so consumes it. I1=?pay.assert(paid).end I2= consume(paid).!item .end The only interleaving composition of I1andI2that satisfies the constraints posed by the assertions is: ?pay.assert(paid).consume(paid).!item .end. 6 :6Laura Bocchi, Dominic Orchard, and A. Laura Voinea Linear constraint consume(n)models a guarantee that can be used once, whereas nonlinear constraint require(n)does not consume n. Using a mix of linear and non linear constraints, we can model a prepaid buffet scenario where a payment remains valid ( hungry) for several iterations until the meal ends ( end): µt.&{hungry :require(paid).!food .t,end:consume(paid).end} Example 1 (Asserted banking and PIN/TAN) The informal requirement on the bank ing and PIN/T AN example discussed in the introduction can be modelled using assertions. An asserted version of the banking protocol, given below as S′ B, uses require(pin)to ensure a successful PIN authentication before accessing the banking menu; consume(tan)to require one successful T AN authentication for each iteration involving a payment; and consume(pin)to remove the PIN guarantee when logging out. Assertions assert(pay)and consume(pay)ensure T AN authentication only happens in case of payment. S′ B= require(pin).µt.&  statement : !statement .t payment : assert(pay).consume(tan).?details .t logout : consume(pin).end   In the asserted authentication protocol S′ Abelow, assert(pin)and assert(tan)provide guarantees of successful PIN and T AN authentication, respectively: S′ A=?pin.⊕  ok: assert(pin).µr.consume(pay).!id.?tan.⊕/braceleftbig5 ok: assert(tan).r fail:r/bracerightbig5 fail:end   2.2 Protocol Semantics The semantics of a protocol is given in Definition 2 in terms of an environment that keeps track of guarantees, and lets protocols progress only if stated guarantees can be met by the environment. The semantics is up to the structural equivalence rules given below, where S[µt.S/t]is the onetime unfolding of µt.S. µt.S≡S(where t/\e}at〉o\slas〈∈fv(S))µt.S≡S[µt.S/t] Definition 2 (Operational semantics) The semantics of protocols is defined by a la belled transition system (LTS) over configurations of the form (A,S)where Aranges over environments A⊆/Ncal ( sets of logical atoms), with transition labels ℓ::=p|+l| assert(n)|require(n)|consume(n)and the transition rules below: (A,p.S)p− →(A,S) 〈Inter〉 (A,+{li:Si}i∈I)+lj−→(A,Sj) ( j∈I)〈Branch〉 (A,assert(n).S)assert(n)−−−−→(A∪{n},S) 〈Assert〉 (A,require(n).S)require(n)−−−−−→(A,S) ( n∈A)〈Require〉 (A,consume(n).S)consume(n)−−−−−−→(A\{n},S) ( n∈A)〈Consume〉 (A,S)ℓ− →(A′,S′) (A,µt.S)ℓ− →(A′,S′[µt.S/t])〈Rec〉 6 :7A Theory of Composing Protocols Rules〈Inter〉and〈Branch〉always allow a protocol to proceed with some action, resulting in the appropriate continuation, without any effect to the environment. Rule〈Assert〉adds atom nto the environment. Rules 〈Require〉and〈Consume〉both require the presence of atom nin the environment for the protocol to continue. Although〈Require〉leaves the environment unchanged, 〈Consume〉consumes the atom nfrom the environment. In 〈Rec〉,S′[µt.S/t]means that the recursive protocol is unfolded by substituting µt.SfortinS′. We write:(A,S)/\e}at〉o\slas〈→if(A,S)ℓ− →(A′,S′)for noℓ,A′,S′;(A,S)/vectorℓ− →(A′,S′)for a vector /vectorℓ=ℓ1, . . . ,ℓnif(A,S)ℓ1−→. . .ℓn−→(A′,S′). We say that(A′,S′)isreachable from(A,S)if (A,S)=( A′,S′)or(A,S)/vectorℓ− →(A′,S′)for a vector/vectorℓ. We omit labels and target states where immaterial. Definition 3 (Stuck state & progress) State(A,S)isstuck ifS/\e}at〉o\slas〈≡end and(A,S)/\e}at〉o\slas〈→. A protocol Senjoysprogress if every state(A′,S′)reachable from(/emptysetstress,S)is not stuck. Aprotocolmayreachastuckstatewhenitdoesnothavesufficientpreconditionsin its environment A. In Example 1, S′ Bdoes not enjoy progress because the precondition expressed by require(pin)cannot be met; similarly, S′ Adoes not enjoy progress because of unmet precondition consume(pay). 2.3 WellAssertedness Assertions are key to generating meaningful compositions of protocols. Following the labelled transitions semantics, we define a judgement which captures the pre and postconditions of a protocol implied by its assertions. We use the notation A{S}A′ reminiscent of a Hoare triple where AandA′are pre and postconditions of S. Definition 4 (Wellassertedness) LetAbe a set of names. Wellassertedness of a protocol Swith respect to Ais defined below, as an inference system on judgements of the form A{S}A′, where A′is the set of names (logical atoms) resulting after the execution ofSgiven the set of names A. A{S}A′ A{p.S}A′[act]∀i∈I.A{Si}Ai A{+{li:Si}i∈I}/intersectiontext i∈IAi[bra]A∪{n}{S}A′ A{assert(n).S}A′[assert] A∪{n}{S}A′ A∪{n}{require(n).S}A′[require]A\{n}{S}A′n∈A A{consume(n).S}A′[consume] A{S}A∪A′ A{µt.S}A∪A′[rec]− A{end}A[end]− A{t}A[call] We write A{S}when A{S}A′for some A′(i.e., when the postcondition is not of interest). We say that Sisverywellasserted if/emptysetstress{S}. We say that a state (A,S)is wellasserted if Sis wellasserted with respect to A. Protocols S′ AandS′ Bin Example 1 are not verywellasserted but they are wellasserted with respect to{pin,tan}and{pay}, respectively. 6 :8Laura Bocchi, Dominic Orchard, and A. Laura Voinea We now consider some properties of wellasserted protocols. Proofs are in Ap pendix D. Firstly, protocols that do not contain assertions are verywellasserted: Proposition 1 (Verywellassertedness) IfSis generated by the grammar in Defini tion 1 without the assertion fragment then it is verywellasserted. Next, wellasserted protocols can have their environment weakened, akin to pre condition weakening in Hoare logic: Proposition 2 (Environment weakening) IfA{S}and A⊆A′then A′{S}. Hence, /emptysetstress{S}implies A{S}for all A. Next, Lemma 1 states that the redux of a wellasserted state is wellasserted, more over the postconditions are not weakened by reduction: Lemma 1 (Reduction preserves wellassertedness) IfA{S}A′and there is a reduc tion(A,S)ℓ− →(A′′,S′)then∃A′′′⊇A′.A′′{S′}A′′′. Lemma 2 (Wellasserted protocols are not stuck) IfA{S}andSis closed with re spect to recursion variables (fv(S)=/emptysetstress)then(A,S)is not stuck. Next, Lemma 3 shows that if a protocol “gets stuck”, this is because it does not have enough preconditions to proceed. Thus, the protocol needs assumptions that may be provided by other protocols it could be composed with. Lemma 3 follows by induction on the length of a protocol’s execution, combined with Lemmas 1 and 2. Lemma 3 (Progress of verywellasserted protocols) IfSis verywellasserted (i.e., /emptysetstress{S}) and closed then it exhibits progress . We next introduce protocol composition, which produces protocols that are mean ingful with respect to their assertions (i.e., that exhibit progress). 3Interleaving Compositions Wecomposeprotocolsbycomputingsyntacticinterleavings.Wederivethe‘interleaving composition’ (IC) of two protocols S1andS2via a relation with judgements of the form: TL;TR;A⊢S1◦S2⊲Swhere Sis the resulting composed protocol, and A is the set of names (i.e., assertions) provided by the environment to S. We let T range over recursion environments, defined as possibly empty lists of distinctprotocol variables t. Lists are concatenated via the ,(comma) operator, which is overloaded to extend a list with a single element, e.g., written T,t. In the judgements, we use two recursion environments TLandTRto keep track of the free protocol variables in S1 andS2respectively in order to handle composition of recursive protocols. We use an underlining annotation tto denote variables that were used to merge two recursive protocols into one recursive IC, and predicate unused(T)that is true if all variables in Tare not used (i.e., not underlined), and false otherwise. The ‘used’ annotation tis instrumental in handling composition of nested recursions, as explained later. 6 :9A Theory of Composing Protocols TL;TR;A⊢S1◦S2⊲S TL;TR;A⊢p.S1◦S2⊲p.STR;TL;A⊢S2◦S1⊲S TL;TR;A⊢S1◦S2⊲S[act/sym] TL;TR;A∪{n}⊢S1◦S2⊲S TL;TR;A∪{n}⊢require(n).S1◦S2⊲require(n).S[require] TL;TR;A\{n}⊢S1◦S2⊲S n∈A TL;TR;A⊢consume(n).S1◦S2⊲consume(n).S[consume] TL;TR;A∪{n}⊢S1◦S2⊲S TL;TR;A⊢assert(n).S1◦S2⊲assert(n).S[assert] ∀i∈ITL;TR;A⊢Si◦S2⊲S′ i TL;TR;A⊢+{li:Si}i∈I◦S2⊲+{li:S′ i}i∈I[bra] TL,t1;TR;A⊢S1◦µt2.S2⊲SA{µt1.S} TL;TR;A⊢µt1.S1◦µt2.S2⊲µt1.SA{µt.S}fv(µt.S)=/emptysetstress TL;TR;A⊢µt.S◦end⊲µt.S[rec1/rec3] TL;T1,t,T2;A⊢S1[t/t1]◦S2⊲Sunused(T2) TL;T1,t,T2;A⊢µt1.S1◦S2⊲S[rec2] t∈TL∨t∈TR TL;TR;A⊢t◦t⊲t− TL;TR;A⊢end◦end⊲end[call/end] Figure 2 Rules for iterleaving composition of protocols Definition 5 (Interleaving composition) IC is defined by the judgements in Figure 2. In Figure 2, rule [act] is for prefixes, [sym] is the commutativity rule, and [end] handles a terminated protocol. By combining [act] and [sym] one can obtain all interleavings of two sequences of actions. Rule [require] includes the continuation of a protocol only if a required assertion nis provided by the environment. Rule [consume] is similar except the assertion is removed in the precondition’s environment. Conversely, [assert] adds assertion n to the environment of the precondition. Rules [require], [assume], and [consume] may enforce a particular order in actions of an interleaving. For example, the reader can verify that the composition of ?pay.assert(p).endand consume(p).!item .endpro duces (only) one interleaving ?pay.assert(p).consume(p).!item .endthat is obtained by applying [act], [assert], [sym], [consume], [act], and [end]. Rule [bra] is similar to [act] but the continuations are composed with each branch. For example the composition +{l1:end,l2:end}◦!Int.endwith initially empty environment produces the following two interleavings: +{l1:!Int.end,l2:!Int.end}(applying [bra], [sym], [act], [end]) !Int.+{l1:end,l2:end}(applying [sym], [act], [act], [sym], [bra], [end]) Rules [rec1] and [rec2] allow two recursive protocols to be composed. The compo sition of two recursive protocols, say µt1.S1andµt2.S2, yields a recursive protocol 6 :10Laura Bocchi, Dominic Orchard, and A. Laura Voinea where the recursion body is the composition of the two recursion bodies, and only one of the two protocol variables is used, either t1ort2. For example, the composition of µt1.!p1.t1andµt2.!p2.t2yields e.g., µt1.!p1.!p2.t1(applying [rec1], [act], [sym], [rec2], [act], [call]) µt2.!p2.!p1.t2(applying [sym], and proceeding as above) Rule [rec1] picks t1as name for the interleaving composition, records t1as the end of the TLlist and continues with the composition of the recursion body S1with µt2.S2. The premise A{µt1.S}ensures wellassertedness of the arbitrary repetition ofS, that isµt1.S(the composition rules only check that Sis wellasserted). Rule [rec2] completes the merge of two recursions, with calls to t2in this instance being redirected to t1(via a substitution). Variable t1is in the right recursion environment T1,t1,T2, namely a list of protocol variables, followed by unused t1, followed by a list of unused protocol variables T2, yielding a protocol with just one recursion. In the premise of [rec2], t1in this instance becomes used. In [rec2], condition unused(T2)prevents erroneous ‘flattening’ of nested recursions. For instance, in the composition of S1=µt.p.tandS2=µt1.q.µt2.+{l1:t1,l2:t2}, merging twithboth t1andt2wouldyieldtheundesirablederivation S=µt.p.q.+{l1: t,l2.t}where Sdoes not preserve the behaviour of S2. Behaviour preservation is formally defined later on; for now, observe that S2permits successive choices of the label l2without any intervening actions, whereas Srequires an intervening qaction (and paction)betweenanysuccessivechoicesoflabel l2.SeeExample7inAppendixA for some derivations of interleaving compositions of S1andS2. The requirement that tprecedes only unused variables T2(captured by predicate unused(T2)) also prevents ‘crisscross’ substitutions when composing two protocols with nested recursions which can also violate behaviour preservation in similar ways to the case observed above. Consider now the composition of a recursive protocol with a nonrecursive one e.g., S1=µt.p1.twith S2=p2.end. We do notwant to derive the following protocol: S=µt.p1.p2.tThe problem with Sis that it allows execution p1,p2,p1,p2, . . .where action p2is repeatedly executed, while S2only prescribes one instance of p2. Such a derivation would not preserve the behaviour of S2. Our rules do not allow derivation ofSabove because rule [call] checks that the component protocols share protocol variable t(i.e., they are both recursive and correctly merged). Another undesirable composition of S1=µt.p1.tandS2=p2.endis one where S1 ‘comes first’ yielding S′=µt.p1.twhich, morally, behaves as S2after an infinite loop. Ifthiswereacomposition,itwouldviolateasecondpropertywediscussformallylater, fairness, requiring each component protocol to be able to proceed until it terminates. S′is not derivable thanks to [rec3], which only allows a recursive protocol to be introduced in an interleaving composition when the nonrecursive component has already been all merged (i.e., it is end). We can, e.g., derive the following composition ofS1andS2,where the terminatingprotocol S2comesfirst (hencesatisfying fairness): p2.µt.p1.t(applying [act], [sym], [rec3]) . The premise fv(µt.S)=/emptysetstressof [rec3] prevents it being used inappropriately in case of nested recursion, e.g., to prevent composition of µt1.p1.µt2.p2.t1and q.endto 6 :11A Theory of Composing Protocols produce (via [rec1], [act], [sym], [rec3]) µt1.p1.q.µt2.p2.t1, which violates behaviour preservation (discussed later) by repeating an action qfrom a nonrecursive context. 3.1 Variations on the Branching Rule The branching rule of interleaving composition can be viewed as a distributivity property: sequential composition after a controlflow branch can be distributed inside the branches. Algebraically, we can informally describe this distributivity as follows, for a 2way branch ( sanslabelling):(S1+S2)◦T≡(S1◦T)+(S2◦T). Such a property is familiar in Kleene algebra models of programs and program reasoning [34] and monotone dataflow frameworks in static analysis [32]. Since interleaving composition generatesasetofpossibleprotocolsitwouldbemoreaccuratetoexpressthisproperty in terms of set membership rather than equality (for simplicity of the analogy, this elides the fact that each composition ◦is itself a set): (S1+S2)◦T∋(S1◦T)+(S2◦T) (distributivity) In this section we consider two variants of this distributive behaviour for composition called (1) ‘weak branching’ and (2) ‘interchange branching’ which can be summarised via the algebraic analogy as variants of distributivity, respectively: (S1+S2)◦T∋(S1◦T)+S2∧(S1+S2)◦T∋S1+(S2◦T) (weak) (S1+S2)◦(T1+T2)∋(S1◦T1)+(S2◦T2) (interchange) In (weak), composition distributes inside one branch but not the other. In (inter change), composing branches with branches has a ‘merging’ effect on the branches rather than distributing within. (The ‘interchange’ terminology comes from similar properties in category theory [33]). We motivate and discuss each variation from the protocol perspective. In the rest of thissectionweintroducetwoadditionalcompositionrules:[wbra]forweakbranching, and[cbra]forinterchangebranching(whichwewillrefertoas correlating branching as itbetterreflectstheeffectsoftheruleontheprotocols).Notethatthesetwovariations grow the set of possible interleavings, rather than shrinking it: they provide more general composition behaviours but do not exclude the more specialised behaviours. For generality of the theory, the derivation of interleaving composition can apply any branching ([bra], [wbra], [cbra]). For practicality, our tool allows engineers to choose the kind of branching to use in any specific scenario (as shown in Section 5). 3.1.1 Weak Branching for “Asymmetric” Guarantees Weak branching allows partial execution of some protocols being composed even if there are not sufficient assertions to continue, as long as all protocols are completely executed in some execution path. For example, protocol SBbelow needs assertion n to proceed. Assume we want to compose SBwith a protocol SA, which can provide n in only one of its branches ok. Protocol SAmay be an authentication server, granting or blocking access to SBdepending on a password pwd. That is, for some S′: SA::=?pwd.⊕{ok:assert(n).end,ko:end} SB::= require(n).S′ 6 :12Laura Bocchi, Dominic Orchard, and A. Laura Voinea Since we want the actions of SBnot to be executed after selection of label ko, we want interleaving composition to generate the following protocol: SAB=?pwd.⊕{ok:assert(n).require(n).S′,ko:end} Protocol SABis not attainable usingthe rulesof Definition 5: the derivation blockscom posing require(n).S′with the second branch’s endin the empty environment.1Instead, we introduce a ‘weak branching’ composition rule to allow asymmetric guarantees: Definition 6 (Weak branching) Weak branching composition of protocols is derived using the judgements in Definition 5 and the additional rule [wbra]: I=IA∪IB IA∩IB=/emptysetstress IA/\e}at〉o\slas〈=/emptysetstress ∀i∈IA.TL;TR;A⊢Si◦S⊲S′ i∀i∈IB.TL;TR;A⊢Si◦S/\e}at〉o\slas〈⊲∧A{Si} TL;TR;A⊢+{li:Si}i∈I◦S⊲+{li:S′ i}i∈IA∪{li:Si}i∈IB Precondition IA/\e}at〉o\slas〈=/emptysetstressensures that each protocol’s actions are executed in at least one execution path, and is key to the fairness property introduced in Definition 9. Hereafterwedenotewith ⊲sderivationsobtainedusingthejudgementsinDefinition5 only and⊲wfor derivations with the additional rule [wbra]. Example 2 (Weak IC of banking and PIN/TAN) Consider the banking and PIN/T AN protocols in Example 1 (p. 7). Interleaving composition of S′ AandS′ Busing⊲sreturns an empty set. When using ⊲winstead, we can derive the following interleaving composition modelling a banking/authentication protocol that satisfies the requirements specified in Section 1.1. SBA=?pin.⊕  ok:assert(pin).require(pin).µr.&  payment :STAN, statement : !statement .r, logout :consume(pin).end   fail:end   STAN= assert(pay).consume(pay).!id.?tan.⊕  ok:assert(tan).consume(tan). ?details .r, fail:r   3.1.2 Correlating Branching Correlating branching allows two protocols to be composed by ‘correlating’ each branch of one with at least one branch of the other. Considertwobranchingprotocols: S1offeringtwoservices s1ands2,and S2offering two kinds of payment p1andp2. When composing S1andS2, we can correlate s1 with p1, and s2with p2, using assertions: S1=⊕{s1:assert(one).end,s2:assert(two).end} S2=⊕{p1:consume(one).end,p2:consume(two).end} 1If we start from a nonempty environment {n}we can derive ?pwd.⊕{ok: assert(n).require(n).S′,ko:require(n).S′}.However,initialassumption {n}meansthataccess toSBis granted regardless of the authentication outcome. 6 :13A Theory of Composing Protocols We would like to obtain the following composition: S12=⊕/braceleftbig5 s1:⊕{p1:assert(one).consume(one).end}, s2:⊕{p2:assert(two).consume(two).end}/bracerightbig5 Composition rule [bra] is too strict and returns an empty set for S1andS2. Weak branching [wbra] is also not useful in this case, producing the interleaving below, which does not capture the intended correlation: ⊕/braceleftbig5 p1:⊕/braceleftbig1 s1:assert(one).consume(one).end,s2:assert(two).end/bracerightbig1 , p2:⊕/braceleftbig1 s1:assert(one).end,s2:assert(two).consume(two).end/bracerightbig1/bracerightbig5 Definition 7 introduces a further rule [cbra], to allow for correlating compositions. Definition 7 (Correlating branching) Correlating branching composition is derived using the judgement in Definition 5 with the addition of rule [cbra] below: ∀i∈I.Ji/\e}at〉o\slas〈=/emptysetstress∧/uniontext i∈IJi=J ∀j∈JiTL;TR;A⊢Si◦S′ j⊲Si j∀j∈J\JiTL;TR;A⊢Si◦S′ j/\e}at〉o\slas〈⊲ TL;TR;A⊢+{li:Si}i∈I◦+′{l′ j:S′ j}j∈J⊲+{li:+′{l′ j:Si j}j∈Ji}i∈I The first premise requires that: (1) each branch of the first protocol can be correlated with at least one branch of the second protocol ( Ji/\e}at〉o\slas〈=/emptysetstress), and (2) each branch of the second protocol can be correlated with at least one branch of the first protocol (/uniontext i∈IJi=J). This precondition is critical to ensure the fairness property we introduce in Section 4 (Definition 9). Rule [cbra] allows us to obtain S12as the interleaving composition of S1andS2above, modelling the intended correlation. ⊲w ⊂⊂ ⊲s⊲wc ⊂⊂ ⊲cHereafter we denote with ⊲c(resp.⊲wc) derivations ob tained using the judgements in Definition 7 with the addition of rule [cbra] (resp. [cbra] and [wbra]). The inclusion relation betweenthedifferentkindsofjudgementisshownontheright (with⊲sand⊲wcbeing the most and least strict, respectively). 4Properties of Interleaving Composition In this section, we give the main properties of interleaving compositions. First, we give some general properties of wellassertedness and algebraic/scoping properties (i.e., sanity checks). Then, we give behaviour preservation and fairness, both formulated using a semantics of ‘protocol ensembles’ (a semantic counterpart of syntactic compo sition). Hereafter, we will denote with ⊲any kind of judgement in {⊲s,⊲w,⊲c,⊲wc}. 4.1 WellAssertedness of Compositions Critical for the validity of our approach is that interleaving compositions preserve the constraints of assertions: 6 :14Laura Bocchi, Dominic Orchard, and A. Laura Voinea Proposition 3 (Validity) IfTL;TR;/emptysetstress⊢S1◦S2⊲Sthen Sis verywellasserted. Appendix E details the proof. A corollary of Proposition 3 and Lemma 3 (progress of verywellasserted protocols) is that interleaving compositions enjoy progress: Corollary 1 (Progress) IfTL;TR;/emptysetstress⊢S1◦S2⊲Sthen Senjoys progress. 4.2 Algebraic and Scoping Properties We consider algebraic properties and notions of open and closed protocol with respect to recursion variables. Appendix F details the proofs of these results. Composing closed recursive protocols yields closed protocols. This property is a corollary of a more general property, that free variables are preserved by composition: Proposition 4 IfTL;TR;A⊢S1◦S2⊲Sthen fv(S1)∪fv(S2)=fv(S). That is, the free variables of a composed protocol are exactly the union of the free variables of the protocols being composed. Corollary 2 (Composition preserves closedness) For all A,Sand closed protocols S1,S2, ifTL;TR;A⊢S1◦S2⊲Sthen Sis a closed protocol. A useful algebraic property is that composition has endprotocols as units: Proposition 5 (Interleaving composition has left and rightunits) For a protocol Swhere A{S}∧fv(S)=/emptysetstressthen TL;TR;A⊢S◦end⊲SandTL;TR;A⊢end◦S⊲S. 4.3 Behaviour Preservation and Fairness of Protocol Ensembles In Section 3, we gave a syntactic definition of interleaving composition , which enacts the dependencies implied by assertions in protocols, and provides a blueprint of an implementation. In this section, we consider ‘protocol ensembles’, which can be understood as the semantic compositions of two asserted protocols. Semantic compositions have a behaviour that is similar to parallel composition (e.g., as in CCS), but unlike parallel composition the two asserted protocols cannot communicate with each other, i.e., there are no internal τactions. All interactions in a semantic composition are directed towards other endpoints. Semantic composition provides a more general and somewhat familiar notion of composition, which we will use as a reference to analyse the properties of interleaving compositions. Protocol ensembles, ranged over by C, are defined as follows: C::=S|S||S By defining Cas either asserted protocols S(which may be interleaving composi tions) or semantic compositions S||S, we obtain a common LTS for comparing the behaviourofinterleavingandsemanticcompositions.Forsimplicitywelimitthetheory to the composition of two protocols. The extension to nprotocols is straightforward e.g., based on labelling each protocol and its actions with a unique identifier. 6 :15A Theory of Composing Protocols The LTS for protocol ensembles extends the LTS for asserted protocols: it is defined over states of the form (A,C), transition labels ℓ(as for asserted protocols), and by the rules in Definition 2 plus the following two rules: (A,S1)ℓ− →(A′,S′ 1) (A,S1||S2)ℓ− →(A′,S′ 1||S2)〈Com1〉(A,S2)ℓ− →(A′,S′ 2) (A,S1||S2)ℓ− →(A′,S1||S′ 2)〈Com2〉 We write(A,C)→if(A,C)ℓ− →(A′,C′)for someℓ,A′,C′. Protocols in Cdo not commu nicate internally, but may affect each other by changing or checking A. Behaviour preservation Fix an LTS for protocol ensembles (Q,L,− →)defined on the setQof states sof the form(A,C)and labels L. We use the standard notion of simulation [41] to compare protocols of interleaving compositions and protocol en sembles, using protocol ensembles as a correct general model to which interleaving compositions need to adhere. Definition 8 (Simulation) A ( strong) simulation is a relation/Rcal⊆ Q×Qsuch that, whenever s1/Rcals2:∀ℓ∈L,s′ 1:s1ℓ− →s′ 1implies∃s′ 2:s2ℓ− →s′ 2ands′ 1/Rcals′ 2. We call ‘similarity’ the largest simulation relation. We write s1/lessorsimilars2when there exists a simulation/Rcalsuch that s1/Rcals2. We say that C1preserves the behaviour of C2with respect to Aif(A,C1)/lessorsimilar(A,C2). Theorem 1 (Behaviour preservation of compositions  closed) /emptysetstress;/emptysetstress;A⊢S1◦S2⊲S⇒(A,S)/lessorsimilar(A,S1||S2) Therefore, interleaving compositions will only show behaviour that would be allowed by a protocol ensemble. Clearly, protocol ensembles allow more possible executions than an interleaving composition, which is only one of the possible interleavings. The proof of Theorem 1 is by induction on the derivation of Sand, although the statement assumes closed protocols, some inductive hypotheses in the proof (e.g., premises of [rec1] or [rec2]) require reasoning about open protocols. The proof hence relies on a property(LemmaG.7–AppendixG)onopenprotocols:(roughly)giventwoprotocols and one of their interleaving compositions, any action of the interleaving composition is matched by an action of the ensemble of the two protocols, and this property is preservedupontransition.Notethat,whileenvironments TLandTRaretriviallyempty in Theorem 1 (closed protocols), they have a key role in proving Lemma G.7 (open protocols): they include the variables of each component protocol that have been bound in a derivation, and give critical information of the scope and structure of the original component protocols in that derivation. Appendix G details the proof. Fairness Fix an ensemble of two protocols S0||S1and any of their interleaving compositions S. By fairness, each action of S0(resp. S1) can be observed in at least one execution of S, possibly after a finite sequence of other actions by S1(resp. S0). In the following, we write (_,S)to denote(A,S)when Ais immaterial. 6 :16Laura Bocchi, Dominic Orchard, and A. Laura Voinea Definition 9 (Fairness) Sisfair w.r .t. S0andS1onA, if∀i∈{0,1}and any transition (_,Si)ℓ− →(_,S′ i)there exists/vectorrsuch that: 1)(A,S|1−i|)/vectorr− →(_,S′ |1−i|),2)(A,S)/vectorrℓ−→(A′,S′), and 3)S′is fair with respect to S′ iandS′ |1−i|onA′. Theorem 2 (Fairness of compositions) If/emptysetstress;/emptysetstress;A⊢S0◦S1⊲Sthen Sisfair w.r .t. S0 andS1onA. A key aspect of fairness (Definition 9) is that it fixes ℓand then requires at least one execution in which ℓis eventually executed by S. This implies that although not all possible future branches include all parts of the protocols being composed, some will. Definition 10 (Strong fairness) Sisstronglyfair w.r .t. S0andS1onA, if any i∈{0,1} and all transitions (_,Si)ℓ− →(_,S′ i)and(A,S|1−i|)/vectorr− →, there exist/vectorr′,/vectorr′′with(A,S|1−i|)/vectorr′ − → (_,S′ |1−i|)and either: 1)/vectorr′/vectorr′′=/vectorr(i.e.,/vectorr′is a prefix of/vectorr), or 2)/vectorr′=/vectorr/vectorr′′(i.e.,/vectorris an ex prefix of /vectorr′) such that(A,S)/vectorr′ℓ−→(A′,S′)andS′is strongly fair w.r .t. S′ iandS′ |1−i|onA′. By Definition 10, any action of a composition can be matched by an action of the protocols being composed, and this property is preserved by transition. Vectors /vectorr, /vectorr′, and/vectorr′′are used to universally quantify on /vectorrand yet allow for the cases where ℓ comes before (1) or after (2) /vectorrin the composition. It follows a stronger fairness result for compositions using only [bra] that only holds for ⊲sjudgements. Theorem 3 (Strong fairness of compositions with ⊲s)If/emptysetstress;/emptysetstress;A⊢S0◦S1⊲sSthen Sisstrongly fair with respect to S0andS1onA. Appendix H details the proofs. Example 3 (Fairness and weak branching) Consider a simpler variant of the proto cols in Section 3.1.1 ( omitting password exchange and continuation): SA=⊕{ok:assert(n).end,ko:end} SB= require(n).end SAB=⊕{ok:assert(n).require(n).end,ko:end} Observe/emptysetstress;/emptysetstress;/emptysetstress⊢SA◦SB/\e}at〉o\slas〈⊲sSABand/emptysetstress;/emptysetstress;/emptysetstress⊢SA◦SB⊲wSAB. We show that SABis a fair composition w.r .t. SAandSBon/emptysetstress, but it is not a strongly fair one. First focus on fairness. SAcan move with either label ⊕ok or⊕ko. In either case(/emptysetstress,SAB) can immediately make a corresponding step with /vectorrempty. If SBmoves, that is by label require(n), then for some environment {n}: ({n},SB)require(n)−−−−−→(/emptysetstress,end) (1) There exists a sequence of transitions with labels /vectorr=⊕ok,assert(n)such that (/emptysetstress,SB)⊕ok,assert(n)−−−−−−−→({n},end) (/emptysetstress,S)⊕ok,assert(n)−−−−−−−→({n},require(n).end)require(n)−−−−−→(/emptysetstress,end) 6 :17A Theory of Composing Protocols and/emptysetstress;/emptysetstress;/emptysetstress⊢end◦end⊲wend . In the case above, we could select a ‘good’ path of SA andSABthat allows the transition with label require(n)to happen. Focus now on strong fairness and again, consider the step in Equation (1) bySB. Now we can pick an arbitrary /vectorr, say,⊕ok, such that(/emptysetstress,SB)⊕ko−−→(/emptysetstress,end). Looking at SAB, there is no prefix nor extension of /vectorr=⊕ok that allows a require(n)step by SABonce the branch ko is taken. Therefore, SABis not strongly fair with respect to SAandSBon/emptysetstress. 4.4 Completeness We discuss completeness of our composition rules: for every ‘good’ execution of S1||S2 (i.e., nonterminating or reaching state end||end), can we obtain an interleaving composition of S1andS2that yields that execution? At present the answer is negative. For example, SaandSbbelow produce no interleavings (not even with ⊲w) Sa=?pwd.assert(login).?quit .assert(n).consume(login).end Sb=µt.&{balance :require(login).!bal.t,finish :consume(n).end} while it may be desirable to obtain: ?pwd.assert(login).µt.&/braceleftbig6 balance :require(login).!bal.t, finish :?quit .assert(n).consume(n).consume(login).end The IC above cannot be derived because [rec1] prevents composition of recursive with nonrecursive protocols. A simplistic modification of [rec1] to allow composition of t1.S1and S2(with Top(S2)=/emptysetstress) would produce µt.?pwd.assert(login).&{. . .}which is not behaviour preserving (the password request is repeated). Similar tweaks to [rec2] have the same problem. With more complex rules, we may possibly allow weak compositionof Sawith Sbonlyforsyntacticsubtermsof Sbthatterminate(e.g,afterthe finishbranch). Extending our rules in this direction, and investigating completeness, is future work. At present using ⊲cwe can still compose Sbwith a modified Sa, e.g. ?pwd.assert(login).µta.&{void :ta,quit:?quit .assert(n).consume(login).end} 5Implementation To illustrate the proposed approach, we have implemented a tool for Erlang that offers interleaving composition of protocols ,code generation , and protocol extraction . Interleaving composition is defined as a function producing zero or more protocol compositions, giving an algorithmic implementation of the relation in Definition 5. Followingthevariationsonthebranchingrule,thetooloffersstrong,weak,correlating, and weak/correlating (denoted All in the table) composition. The user can select the kind of branching they wish to use. Looking at Example 1, the strong composition of banking and authentication protocols returns an empty set as expected. When opting for weak composition instead, the tool outputs one IC, equivalent to Example 2: 6 :18Laura Bocchi, Dominic Orchard, and A. Laura Voinea Table 1 Number of compositions for branching rule variations; running example in grey. Protocols Strong Weak Correlating All 1) service(),login() 0 1 0 1 2) s1(),s2()(Section 3.1.2) 0 1 2 3 3) i1(),i2()(Section 2.1) 1 1 1 1 4) http(),aws_auth() (from [28]) 0 6 0 6 5) login(),booking() 0 1 0 1 6) pin(),tan() 0 1 0 1 7) pintan(),bank() 0 1 0 1 8) resource() ,server() 1 1 1 2 9) userAgent() ,agentInstrument() 0 0 2 2 10) bankauthsimple() ,keycard() 0 1 0 1 11) auth_two_step() ,email() 0 9 0 9 12) sa(),sb()(Section 4.4) 0 12 2 14 Listing 1 PIN/TAN Banking Protocol rendered in our Erlang AST for protocols 1 bank_pintan() > 2 {act ,r _pin, {branch ,[{ok ,{assert , pin, {require , pin, {rec ,""r"" , 3 {branch ,[{payment, {assert , pay, {consume , pay, {act ,s_id, {act ,r _tan, 4 {branch ,[{ok ,{assert , tan, {consume , tan, {act , r _details, {rvar ,""r""}}}}} , 5 {fail, {rvar , r}}]}}}}}} , 6 {statement, {act , s_statement, {rvar ,""r""}}} , 7 {logout, {consume , pin, endP}}]}}}}} , 8 {fail, endP}]}} Offering all four composition options (corresponding to ⊲s,⊲w,⊲c,⊲wcin the theory) instead of offering only the less restrictive weak/correlating branching ⊲wc, may improve the relevance of compositions returned. As observed in Section 3.1.2, using [wbra] in a context where we need to correlate branches likely returns irrelevant compositions (e.g. row 12). One way to reduce the number of irrelevant compositions, is to introduce more assertions. In fact, one of the aims of the tool is to support step wise understanding of the protocol via progressive use of assertions. An alternative would be to annotate branching instances with the different options, which would further increase relevance of the returned results. This is left for future work. Table 1 shows the number of interleaving compositions obtained for each variation of the branchingruleforasuiteofexamples.Thesuiteincludes:adhocexamplestovalidate the theory (rows 1  3, 7, 12), examples from literature, such as the HTTP example from [28] (row 4), and other examples inspired from realworld applications such as Gmail’s twosteps authentication (row 11). By appropriately selecting composition options and assertions, the tool returns a small number of interleaving compositions. The number of compositions increases in examples with recursions, especially nested recursionsascanbeseeninrows4,11,whichwouldrequiresomeadditionalassertions to choose among the interleavings. Code generation takes a protocol definition and produces an Erlang stub. Protocol structures (action, sequence, choice) can be represented as a directed graph and then as finite state machines that transition based on the messages received. The finite state machines are used to generate a stub that uses the Erlang/OTP gen_statem [1], 6 :19A Theory of Composing Protocols a generic abstraction which supports the implementation of finite state machine modules. Not only is it convenient to represent the protocol as a state machine, but gen_statem offers some useful features. Internal events from the state machine to itself are a good way to represent branches that make a selection among some choices. ‘Postponing events’ and timeouts provide functionality for further implementation of the generated code stubs. Actionsand branches are represented as events that trigger a state transition. We use function declarations to represent incoming events, and function applications to represent outgoing events. Each state has its own handler function used to send an event to the state machine. When the event is received the corresponding state function is called and the transition to the next state is made. The default generated event is an asynchronous communication (called a ‘cast’ in Erlang/OTP parlance). For sending actions and selecting branches, the event type is internal, an event from your state machine to itself. Endis represented by the terminate function of a gen_statem module, whilst the fixedpoint and the recursive variables dictatethecontrolflowofthestatemachine.Statevariablesmustbedeclared byincludingtheminarecord definition— Data.FollowingFramaC[17],werepresent assertions as specially formatted comments. For example: {assert, pay }is represented as an Erlang comment %assert pay . These comments are positioned before code that implements the state to which this assertion acts as a precondition in the protocol. Listing 2 shows an excerpt of the code generated for the PIN/TAN Banking protocol, bank_pintan() , containing the states generated for the first action and branch. Listing 2 PIN/TAN Banking State Machine 1 state1(cast, Pin, Data) > { next_state, state2, Data }. 2 %assert pin 3 %require pin 4 state2(cast, ok, Data) > { next_state, state3, Data }; 5 state2(cast, fail, Data) > { stop, normal, Data }. 6 %assert pay 7 %consume pay 8 state3(cast, payment, Data) > { next_state, state4, Data }; 9 state3(cast, statement,Data) >{ next_state, state10,Data }; 10 %consume pin 11 state3(cast, logout, Data) > { stop, normal, Data }. Protocol extraction and migration. Protocol extraction generates protocols from code via a static analysis of Erlang modules implementing state machines using either gen_statem , or gen_fsmbehaviour. When assertions are expressed using the comments illustratedabove,theyarealsoextracted.Theobtainedprotocolcanbeannotatedwith extra assertions as necessary and composed with another to obtain a more complex protocol. The extraction option preserves local code that can be migrated when generating a new stub. For example, starting out from an existing implementation of banking, we can use the tool to extract the protocol SB, obtain a composition with SA, and generate a new module where preexisting code for banking can be migrated. Reengineering. To extend the banking/authentication server with a keycard authen tication option, we can compose the PIN/TAN Banking Protocol with e.g., the keycard protocol below. Assertions ensure that the branching for TAN or keycard authenti cation is plugged in (using assertion keyp) to the payment option of the PIN/TAN protocol, and that TAN authentication in PIN/TAN protocol is plugged only in the tan branch of the keycard protocol (using assertion otp): 6 :20Laura Bocchi, Dominic Orchard, and A. Laura Voinea Listing 3 Keycard Option Protocol 1 keycard() > {rec ,""y"" ,{require , keyp, {branch ,[{tan, {assert , otp, {rvar ,""y"" }}} , 2 {keycard, {rvar ,""y"" }}]}}} . By adding an assertion of keypand a consume of otpat the beginning of the branch paymentof the PIN/TAN Protocol one would obtain the desired extension using the weakcompositionoption.Ourtoolcanthenbeusedtogenerateastubfortheextended protocol and migrate reusable code from the implementation of the PIN/TAN Banking Protocol to the new implementation. These features satisfy the requirements laid out in Section 1.1: supporting reengineering driven by the composition of protocols. The tool generates stubs from ICs, extracts protocols, and reuse code upon composition with different protocols. See our artifact for the complete benchmark [12]. 6Related Work and Conclusion "
469,Learn-n-Route: Learning implicit preferences for vehicle routing.txt,"We investigate a learning decision support system for vehicle routing, where
the routing engine learns implicit preferences that human planners have when
manually creating route plans (or routings). The goal is to use these learned
subjective preferences on top of the distance-based objective criterion in
vehicle routing systems. This is an alternative to the practice of
distinctively formulating a custom VRP for every company with its own routing
requirements. Instead, we assume the presence of past vehicle routing solutions
over similar sets of customers, and learn to make similar choices. The learning
approach is based on the concept of learning a Markov model, which corresponds
to a probabilistic transition matrix, rather than a deterministic distance
matrix. This nevertheless allows us to use existing arc routing VRP software in
creating the actual routings, and to optimize over both distances and
preferences at the same time. For the learning, we explore different schemes to
construct the probabilistic transition matrix that can co-evolve with changing
preferences over time. Our results on a use-case with a small transportation
company show that our method is able to generate results that are close to the
manually created solutions, without needing to characterize all constraints and
sub-objectives explicitly. Even in the case of changes in the customer sets,
our method is able to find solutions that are closer to the actual routings
than when using only distances, and hence, solutions that require fewer manual
changes when transformed into practical routings.","Vehicle routing problems (VRP) at small or mediumsized enterprises (SME) is constrained by the limited number of vehicles, the capacity of each delivery vehicle, and the scheduling horizon within which all deliveries have to be made. The objective, often implicitly, can include a wide range of company goals including reducing operational costs, minimizing fuel consumption and carbon emissions, as well as optimizing driver familiarity with the routes and maximizing fairness by assigning tours of similar length and/or time duration to the drivers. Daily plans are often created in a route optimization software that is capable of producing plans that are optimal in terms of route length and travel time. We have observed, however, that in practice, route planners usually modify the result given by the software, or simply pull out, modify, and reuse an old plan that has been used and known to work in the past. The planners, by performing these modiﬁcations, are essentially optimizing with their own set of objectives and personal preferences. These preferences are often subjective and sometimes delicate to formalize in constraints. Some examples are: where the best places for lunch breaks are, which stops are best served earlier or later, and which drivers (tours) are more ﬂexible in receiving more stops. Failure to capture such human aspects is often a source of frustration for both drivers and planners, and a cause for reluctance to use the optimisation software. Furthermore, planners may ﬁnd it easier or more eﬀective to manually change a previous solution than to provide or update the detailed information in the system. Being able to automatically capture such preferences without the need to formalize them can hence lead to a wider acceptance and better use of optimisation systems. 1arXiv:2101.03936v1  [cs.AI]  11 Jan 2021The goal of this research is to learn the preferences of the planners (and implicitly the drivers) when choosing one option over another. Hence, the goal is to build an ‘intelligent’ system that can eﬀectively reuse all of the knowledge and eﬀort that have been put into creating previous routings; much like how human planners use prior experience. We focus on techniques from the domain of artiﬁcial intelligence that can learn from historical data, and that can be used to manage and recommend similar routes as used in the past. This is in contrast to the current practice of optimizing a separate VRP instance each day. To learn from historical data, we take inspiration from various machine learning papers on route prediction for a single vehicle: Markov models developed from historical data have been applied to driver turn prediction [Krumm 2008], prediction of the remainder of the route by looking at the previous road segments taken by the driver [Ashbrook and Starner 2003], and predicting individual road choices given the origin and destination [Simmons et al. 2006]. These studies have produced positive and encouraging results for their respective tasks. Hence, in this work, we investigate the use of Markov models for predicting the route choices for an entire ﬂeet, and how to use these choices to create preferenceaware solutions to the VRP. With a Markov model, route optimization can be done by maximizing the product of the probabilities of the sequential actions taken by the vehicles, which corresponds to maximizing the sum of log likelihoods over the arcs. In the case of a ﬁrst order Markov model, a key property of our approach is that it can reuseany existing VRP solution method to ﬁnd the maximum likelihood solution, as it corresponds to the sum of log likelihoods over the individual arcs. This is a promising novel approach to the vehicle routing problem. Our proposed ﬁrst order Markov model approach has been published in a conference proceeding [Canoy and Guns 2019] and in this article, we extend this methodology by developing the following new contributions: •We provide a more general formalization of the methods for learning and optimizing the preferences, and detail both a ﬁrst order and a second order Markov model. •We introduce a new and superior weighing technique called the exponential weighing scheme and examine how it handles data drift, i.e., when there is either a large reduction or a sudden increase in the number of stops. •We present an extended study on distancebased, preferencebased, and combined optimisation. This manuscript is organized as follows: in Section 2, we provide the relevant work related to this article. We discuss in Section 3 routing models that maximize the probability of the learned preferences. Later in the section, we introduce the algorithms to learn the transition matrix from historical data. The comparison of the diﬀerent construction schemes and the experimental results on actual company data are shown in Section 4. Finally, our conclusions and future research directions are presented in Section 5. 2 Related Work "
443,On Search Friction of Route Discovery in Offchain Networks.txt,"Offchain networks provide a promising solution to overcome the scalability
challenges of cryptocurrencies. However, design tradeoffs of offchain networks
are still not well-understood today. In particular, offchain networks typically
rely on fees-based incentives and hence require mechanisms for the efficient
discovery of ``good routes'': routes with low fees (cost efficiency) and a high
success rate of the transaction routing (effectiveness). Furthermore, the route
discovery should be confidential (privacy), and e.g., not reveal information
about who transacts with whom or about the transaction value. This paper
provides an analysis of the ``search friction'' of route discovery, i.e., the
costs and tradeoffs of route discovery in large-scale offchain networks in
which nodes behave strategically. As a case study, we consider the Lighning
network and the route discovery service provided by the trampoline nodes,
evaluating the tradeoff in different scenarios also empirically. Finally, we
initiate the discussion of alternative charging schemes for offchain networks.","Despite the high popularity of cryptocurrencies, it re mains a challenge to make fast payments at scale. This is mainly due to the ineciency of the underlying consen sus protocol: it can take several minutes until a transac tion went through a full consensus and can be conrmed. A promising solution are emerging payment channel net works such as the Lightning network, which allow to per form transactions ochain and in a peertopeer fashion: without requiring consensus on the blockchain. In a nut shell, a payment channel is a cryptocurrency transaction which escrows or dedicates money on the blockchain for exchange with a given user and duration. Users can also interact if they do not share a direct payment channel: they can route transactions through intermediaries . However, the design of secure and scalable ochain networks is challenging and still not wellunderstood. In particular, these networks must not only be scalable butalso account for strategic (i.e., selsh) user behavior; it must further be ensured that these networks do not in troduce new security issues. A common approach to incentivize network nodes (the intermediaries) to con tribute to the transaction routing is to use a feebased mechanism: intermediaries can charge nodes which route through them a nominal fee. This is also the approach taken in the Lightning network which serves us as a case study in this paper. This raises the question of how nodes can discover routes through intermediaries. One aspect here is cost eciency: since dierent routes come at dierent fees, nodes require scalable mechanisms to nd \short"" (i.e., lowcost) routes. However, routes do not only have to be cheap but also provide sucient liquidity to route the transaction: the route discovery mechanism should ensure a high success rate of the transaction routing; this property is known as eectiveness in the literature. Ef fectiveness is not only a performance concern: a lengthy discovery process may also jeopardize privacy, poten tially leaking information about who aims to transact (i.e., nd a route) with whom. Last but not least, the route discovery should be incentivecompatible, e.g., ac count that nodes are only willing to distribute routes from which they can benet (e.g., which go through themselves). Providing an eective and scalable route discovery is particularly challenging as largescale ochain networks are expected to be highly dynamic, e.g., due to the fre quent changes of channels and fees. This renders solu tions requiring wallets to keep uptodate state informa tion about the networks infeasible. An interesting recent solution to reduce the burden on wallets, is the deploy ment of route discovery servers, such as the trampoline nodes in Lightning: these servers maintain routes so that a wallet just needs to know how to reach the route server nodes in its neighborhood and can then request the de sired route. This paper provides an analysis of the eciency privacy tradeo of ochain route discovery, considering the Lightning network as a case study. In particular, we investigate to which extent route discovery can be ecient and eective, incentive compatible and con dential. Here, condentiality is about more than justarXiv:2005.14676v1  [cs.NI]  29 May 2020Figure 1: Paper organization the actual data that is communicated in the discovery process, e.g., the source, the destination, or the transac tion size; it is also about the possible metadata that is communicated implicitly, e.g., about the rate or time at which transactions occur. In fact, existing cryptographic techniques such as (9) can be used to provide data con dentiality, however, as we will show in this paper, nodes may still leak information about the frequency of trans actions, i.e., about their transaction rate , to other nodes which are not on the transaction route. We quantify the \search friction"", i.e., the cost of the route discovery process, both analytically, deriving cost lower bounds, as well as empirically, considering real payment channel networks. Our results motivate re search into alternative economic models to provide rout ing incentives which come at lower search friction costs, which we also start to discuss in this paper. The remainder of this paper is organized as follows, see also Figure 1. We introduce a model for route dis covery and provide a formal analysis in Section 2, and then report on our empirical results in Section 3. Af ter discussing related work in Section 4, we conclude our contribution in Section 5. 2 Tradeo Analysis of Route Discovery In order to analyze the search friction and tradeos of route discovery, we consider the following simplied model. We model the ochain network as a graph of channels : two nodes can create (and may later delete) a payment channel between each other, to perform of fchain transactions. This channel may also be used by other nodes for routing their transactions indirectly, i.e., using multihop routing. In this paper, we are primarily interested in two properties of a channel: the fee other nodes are charged to use this channel, and the channel capacity (resp. liquidity), which determines the size of the transactions it can support. This is a simplication of actual systems such as Lightning, but captures theiressence.1 Denition 1 (Ochain Network) .The ochain network is a weighted, directed graph G(V; E), where Vare the nodes in the network and Eare the channels. A channel e2Eis characterized by a weight we2R+and by a capacity wcap. The weight weis kept general here but typically is a function of the fee that the source node pays for an inter mediate channel, the channels' age (older channels may be assumed to be more reliable), or previous knowledge (e.g., channels which failed in the past), among other. The network is dynamic, i.e., channels may be added and removed over time, fees updated, etc., and hence nodes require mechanisms to discover the topology and learn about updates to be able to route their transactions through the ochain network, either explicitly or implic itly. For example, Lightning includes gossiping and ac tive probing mechanisms to allow nodes to learn about routing fees. It is however more challenging to learn about the capacity wcap; such information is typically not distributed for privacy reasons and hence, nding a path with sucient capacity may require trial and error (20). More formally, a route on a topology G(V; E) from s2Vtot2Vis a list of channels e1:; en2Esuch that the source node of e1iss, and the target node of en istand for every i, the target of eiis the source of ei+1. A transaction in the network is a payment from a source to a target along a \valid route"": A route can serve a transaction of size lif every channel ealong the route has enough capacity, i.e. ecapl. We assume that the weight of a route is simply the sum of the weights of its channels. Inspired by existing ochain networks such as Light ning, we distinguish between two types of nodes: wallets and \regular nodes"", henceforth called trampoline nodes (TNs). Wallets are simple nodes and do not have the re sources to store (and maintain!) information about the entire network. Rather, they need to rely on the tram poline nodes which know the network and which may inform wallets about routes upon request. We are in terested in exactly this discovery process, where wallets interact with one or multiple trampoline nodes to nd routes for their later transactions. This route discovery process however introduces the following challenges: Strategic behavior and eciency: Trampoline nodes may act selshly and may only have an incentive to share routes which include themselves, such that they can charge the fee. As a consequence, a wallet may not learn about the most ecient (i.e., lowest cost) route. Eectiveness: Also related to the above, wallets may have to invest more resources into the discov 1E.g., nodes can set min/max values for channels, create nonpublic channels which cannot be used for multihop rout ing, etc.ery of ecient routes, exploring additional alter native trampoline nodes. The eectiveness of this route discovery process is further aected by the fact that not all the discovered routes may provide su cient liquidity (i.e., capacity) for a large transaction which needs to be routed. Privacy: Through the repeated interactions with multiple trampoline nodes, querying for specic routes, a wallet may reveal condential information about its transactions. We are interested in the following family of route dis covery algorithms: Denition 2 (Routing Discovery Algorithm (RDA)) .A qroute discovery algorithm (RDA) is an algorithm that given a pair s; t2V, performs at most qqueries, issued toqtrampoline nodes, and either returns a valid route or decides that this is not possible. We measure the quality, i.e., the eciency, of a route found by the RDA, by comparing it to the optimal route with respect to the weight function on the topology. Denition 3 (Eciency) .The eciency of a route R from stotis dened by the stretch, i.e.,w(Rsrc;dst ) w(Osrc;dst ), where w()is the weight of the route, and Osrc;dst is the route with the minimal weight between stot. The weight of a route is the sum of its link weights. As discussed above, some routes in ochain networks may be temporarily unavailable (e.g., due to oine nodes or lack of liquidity) and thus invalidate the result of the RDA. Another important metric to evaluate RDA hence concerns the number of queries it needs to issue until a valid route is discovered. For example, in the Lightning network, an available route is searched as part of the route initialization procedure. This process locks the channels along the route (a designated amount) and the channel commits to participate in the transaction. Denition 4 (Eectiveness) .The eectiveness of an RDA is the number of queries which have to be issued to successfully execute a given transaction. Furthermore, as transactions are privacy critical, the RDA should not leak any condential information. Nat urally, a rst concern regards the information provided by the query directly, including e.g., source and destina tion nodes, potentially the transaction size, the resulting routes, etc. As discussed above, today we understand fairly well how to protect such information, e.g., using homomorphic encryption schemes and private informa tion retrieval (14; 7; 5; 9). However, there is another con cern, related to the metadata revealed from the query, e.g., the timestamp or even the existence of the route dis covery query itself. While there also exist solutions to metadata private messaging systems, e.g., (11; 12; 19)), we will show in the following that there is an inherent limitation what can be achieved in terms of an ecient and condential route discovery. To this end, we intro duce the notion of leak rate : to what extent can a node learn about the number of transactions in the network Figure 2: An attacker can learn about a transaction al though the request itself does not hold any information. in a given time unit? That is, the leak rate is dened as the number of transactions in a single time unit that a node can learn about for a given set of transactions T under a given route discovery algorithm A. Denition 5 (Leak Rate) .An RDA Aleaks at rate kif in order to route a transaction, ktimes more nodes will learn about the existence of this transaction compared to a scenario where the transaction is simply routed along the shortest path (e.g., using source routing). To clarify and motivate this notion, we give an exam ple in Figure 2. In this simple network, a node learns about a transaction it should in principle have no idea about. Eciency. With these concepts in mind, we now rst analyze the eciency achievable by route discovery al gorithms. The following lemma shows an inherent cost of the route discovery process in the ochain model Lemma 1. For every qRDA and every M2Rthere exists a topology in which an RDA will return a route with weight Mtimes higher than the optimal route, or it will not return a route at all. Proof. Consider the topology in Figure 3. Given a q RDA A, we build a topology in which Awill return a route with weight larger than Malthough there exists a route with weight 1. In our topology, the source node, s, is in the center, and is connected to q+ 1 TNs with channel weight 0. Each TN is connected to one unique node with a channel of weight 1, and all these nodes form a clique (i.e., are connected to one another) by channels of weight M. We will choose the target from one of these nodes. The RDA Aqueries qTNs in an order that is independent on target node (because sdoes not know the topology). But there are q+ 1 possibilities to the target, therefore there exists a node in the outer circle, t, that Adoes not query its direct TN neighbor. Choose this t to be our target. As the TNs are selsh, therefore they will tell Aonly about routes that go through themselves, and all of them are not directly connected to t; thus all the weights that Asees are at least of weight M+ 1. Finally, Awill return either a route with weight M+ 1 or no route at all, although the actual shortest route is of weight 1.Figure 3: Example with high cost: If there are q+ 1 direct neighbors, then any qRDA struggles to nd an ecient route. In general, the eciency will depend on the specic topology. To give an example, consider the complete network. Example 1. In a clique where all the weights are equal, the eciency, in terms of the stretch, is upper bounded by 2. To see this, assume ris the weight of each channel. The optimal route is the direct channel, which weighs r. On the other hand, the route to each TN and the route from the TN to each target are also r(this is clique, so there exists a direct channel), which is 2 rin total. Eectiveness. We next consider the eectiveness a route discovery algorithm can achieve. Also here, we rst derive a negative result for the general scenario. Lemma 2. For every qRDA and every M2R, there exists a topology in which the rst Mroutes from the algorithm will be unsuccessful. Proof. As in Lemma 1, we will build a topology in which the eectiveness of the RDA Awill be as needed. The topology is composed from M+2 nodes: Mnodes form a clique, one of the nodes in the clique is a TN, to which the source is connected, and the target is connected to other node from the clique. There arePM"
140,Hyper-Specific Prefixes: Gotta Enjoy the Little Things in Interdomain Routing.txt,"Autonomous Systems (ASes) exchange reachability information between each
other using BGP -- the de-facto standard inter-AS routing protocol. While IPv4
(IPv6) routes more specific than /24 (/48) are commonly filtered (and hence not
propagated), route collectors still observe many of them. In this work, we take
a closer look at those ""hyper-specific"" prefixes (HSPs). In particular, we
analyze their prevalence, use cases, and whether operators use them
intentionally or accidentally. While their total number increases over time,
most HSPs can only be seen by route collector peers. Nonetheless, some HSPs can
be seen constantly throughout an entire year and propagate widely. We find that
most HSPs represent (internal) routes to peering infrastructure or are related
to address block relocations or blackholing. While hundreds of operators
intentionally add HSPs to well-known routing databases, we observe that many
HSPs are possibly accidentally leaked routes.","Autonomous Systems (ASes) use the Border Gateway Pro tocol (BGP) to announce prefixes to their peers [ 39]. Each BGPspeaking router of an AS can decide to accept or reject incoming announcements based on the prefix itself, the AS path, or other attributes that are attached to a route (e.g., BGP community values). Due to this concept, every single AS (and, in fact, also all its routers) may have a unique viewpoint into the Internet’s routing ecosystem [45]. Many popular BGP guidelines recommend the rigorous fil tering of prefixes that encompass only a few addresses [ 11,12, 29,33,34,49,50] and, hence, those prefixes have been shown to propagate neither far nor reliably [ 51]. While the possible reasons for announcing these types of prefixes are broad and range from traffic engineering over multihoming configu rations to prefixhijack prevention [ 7,17], the boundary for announcements which are deemed “widely acceptable” areusually considered to be a /24 prefix in IPv4 and a /48 prefix in IPv6. In this paper, we perform an indepth analysis of pre fixes that are more specific than those boundaries, i.e., /25 to /32 IPv4 prefixes and /49 to /128 IPv6 prefixes. We refer to those prefixes as hyperspecific prefixes (HSPs, see Ap pendix A for more details) and analyze their prominence in the global routing ecosystem, the functions that they serve, and whether they represent intentional or accidental an nouncements. More specifically, we make the following main contributions: Observability. We perform a decade long analysis of HSPs as seen by 67 route collectors (see §2). We find that the number of HSPs has increased substantially since 2010 and peaked in 2018 at around 115K IPv4 and 18K IPv6 prefixes. While we observe that especially HSPs which are announced consistently for an entire year are visible by hundreds of col lector peers, the average HSP can only be seen by a handful of them. Use Cases & Functions. We analyze potential use cases of HSPs by combining insights from different analyses of CIDR sizes, BGP communities, and service hit rates across multi ple years (see §3). We find that IPv4 HSPs mostly represent (internal) routes towards peering subnets and blackholing, whereas IPv6 HSPs are mainly used for address block relo cations and, in substantially fewer cases, blackholing. We further find that HSPs are unlikely to contain many end hosts and that they are rarely used for traffic engineering. Intended or Accidental Use. We compare the HSPs visible in BGP with those that were explicitly entered into routing databases—in particular, the Internet Routing Registries (IRR) and Resource PKI (RPKI)—to investigate intended or acci dental use of HSPs (see §4). We find that while thousands of ASes explicitly specify their intent to use HSPs, many HSPs likely represent accidentally leaked routes. The Future of HSPs. We discuss how the research and operator communities could make use of HSPs in the future. Finally, we publish a dashboard providing uptodate HSP statistics to help AS operators in detecting leaked internal routes at https://hyperspecifics.io. ACM SIGCOMM Computer Communication Review Volume 52 Issue 2, April 2022arXiv:2206.13876v1  [cs.NI]  28 Jun 2022TypeIPv4IPv6025K50K75K100K 01K2.2K3.4K4.6K 2010 2015 2021 Time (quarterly)# HSPs (line)# Origin ASes (bar)All Feeds 05K10K15K 06501.3K2K 2010 2015 2021 Time (quarterly)# HSPs (line)# Origin ASes (bar)Consistent FeedsFigure 1: Growth of HSPs and HSP origin ASes as visible in all feeder ASes (left) and a consistent set of feeder ASes (right). 0 50 100 150 0.000.250.500.751.00 Consistency Over 1 YearIPv4 Visibility (Max # ASes) 110010KLog # HSPs 050100150200250 0.000.250.500.751.00 Consistency Over 1 YearIPv6 Visibility (Max # ASes) 110010KLog # HSPsFigure 2: Heatmap showing HSP visibility and consis tency for IPv4 (left) and IPv6 (right). 2 OBSERVABILITY We begin our exploration of hyperspecific prefixes by an alyzing their current and past presence in the Internet’s routing ecosystem. In particular, we examine the routing information from hundreds of globally distributed ASes—called “feeder ASes” or “route collector peers”—collected by the Isolario [ 20], RIPE RIS [ 44], and Routeviews [ 46] projects. Starting from Janu ary 2010, we generate snapshots consisting of a week of RIB and update files every three months until October 2021. We provide further details about the choice of this window size in Appendix B. We employ various filtering steps to sanitize the data from, e.g., announcements of unallocated Internet resources, certain noisy origin ASes1, or temporarily mis configured feeder ASes. We also reached out to operators of noisy origin ASes. Two of these operators were not aware of this problem, but addressed it quickly upon our notification. A comprehensive list with justifications for the individual steps can be found in Appendix E. First, we investigate the evolution of HSPs from January 2010 to October 2021. Figure 1 shows the number of hyper specific prefixes (lines) and ASes that originate them (bars) over time. Looking at the left subplot, we observe that the number of seen HSPs (despite being noisy) consistently in creases throughout the eleven years. We see more than 10k IPv6 and 100k IPv4 HSPs by the end of 2021, i.e., approx imately onetenth of all visible prefixes are hyperspecific (see Appendix C for further details). Relative to the increase in HSPs, we also observe an increase of ASes that originate them, with 584 and 2.5K ASes announcing hyperspecific prefixes via IPv6 and IPv4 by the end of 2021, respectively. 1These ASes announced either (1) an extraordinary high number of HSPs (i.e., 100 or more times higher than in other snapshots) or (2) HSPs in an extraordinary high number of anchor prefixes for a limited time.Given that the route collector projects acquired feeder ASes within our observation period, the increasing trend could simply be a sampling error. To test this hypothesis, we replicate the analysis using only data from the 105 IPv4 and 45 IPv6 feeder ASes that are consistently peering with route collectors throughout all snapshots. While our obser vations remain similar for IPv6, there are two changes for IPv4: (1) the number of hyperspecific prefixes that can be seen by a consistent set of ASes appears more stable (if any trend exists, it remains hidden behind the massive fluctua tions); and (2) despite an initial increase, the number of ASes originating HSPs stagnates after 2016. Therefore, the number of IPv4 HSPs does not show a constant increase over time, but rather we observe more IPv4 HSPs due to an increase in feeder ASes at route collector projects. This hypothesis check leads to another observation: When shrinking the set of feeder ASes, the number of HSPs and their respective origin ASes drops substantially (note the different yaxes for the left and right subplot of Figure 1). To improve our understanding of this insight, we analyze the visibility of HSPs, i.e., by how many peers each HSPs is seen. At the same time, we want to understand what causes the substantial fluctuations in the number of HSPs; hence, we also analyze their consistency, i.e., the fraction of time for which the prefix was seen by at least one feeder AS. Given that a oneweek observation period would not provide much insight into consistency patterns, we conduct this analysis using data from the entirety of 2020. We first read the RIB snapshots from January 1, 2020 and then apply all updates for the whole year sequentially. By tracking the state of each routing table on a perupdate basis, we can extract consistency in seconds granularity. Figure 2 reports the visibility of an HSP on the yaxis against its consistency on the xaxis. For both heatmaps— IPv4 (left) and IPv6 (right)—each cell represents groups of ACM SIGCOMM Computer Communication Review Volume 52 Issue 2, April 20220 40K 80K 120K 2010 2015 2021 Time (quarterly)# HSPs (IPv4, stacked)CIDR /[31−32] /[29−30] /[27−28] /[25−26] 0 6K 12K 18K 2010 2015 2021 Time (quarterly)# HSPs (IPv6, stacked)CIDR /[113−128] /[97−112] /[81−96] /[65−80] /[49−64]Figure 3: HSPs per CIDR size over time. 500%400%300%200%100%0%−100%SMTP BGP HTTPS HTTP SSH CWMP Top Protocols% hitrate difference                    (HSP vs. IPv4−wide)Year 2019 2020 2021 Figure 4: Hit rate comparison of HSPs vs. IPv4wide. ten feeder ASes on the yaxis and two weeks of time on the xaxis. We first observe that there is no particular con sistency trend: While some HSPs can only be observed for less than two weeks, others can be observed throughout the entire year. Our second observation is that the vast majority of hyperspecific prefixes can only be observed by a small number of collector peers, although we do also observe HSPs being visible during the entire year by hundreds of peers. This observation aligns with the restricted propagation char acteristics of HSPs reported by previous blog posts [ 1,2,51] and observed by our own active experiments (an indepth de scription of the experiments, their analysis, and subsequent results can be found in Appendix D). We hypothesize that the substantial fluctuations in the number of totally observed HSPs is a result of these two observations; the restricted propagation of HSPs might inflate the importance of the individual placement of feeder ASes and HSP origin ASes, and the tens of thousand of shortlived HSPs might cluster around certain realworld events, such as DDoS attacks or data center outages. In summary, we observe that the presence of hyper specific prefixes in the Internet’s routing ecosystem has in creased through the last decade and HSPs make up about onetenth of all the prefixes that are observed by route collec tors. In IPv4 the increase in HSPs is driven by an increment in feeder ASes, whereas in IPv6 we see an increase also for a constant set of feeder ASes. While most HSPs only prop agate locally, some of them are globally visible and can be consistently observed throughout an entire year. 3 USE CASES & FUNCTIONS Given their past and current presence in the global rout ing system, we want to get a deeper understanding of the functions that hyperspecific prefixes potentially serve. As a first step in this direction, we use the fact that specific CIDRsizes often hint towards certain use cases. Consider the fol lowing example: If an AS wants to defend one of its servers against an ongoing DDoS attack, it may use blackholing an nouncements. Up to 98 % of these announcements are /32 (/128) IPv4 (IPv6) prefixes, i.e., they only cover the specific addresses of the attacked servers [ 9,10,15]. Larger CIDR sizes are rarely used for blackholing, as they would impair the services running on nonattacked servers as well, i.e., they would introduce unnecessary collateral damage [ 32]. Using similar lines of reasoning, we rely on the following associations between CIDR sizes and intended use cases: We associate (1) /25 and /26 IPv4 prefixes with traffic engineer ing (e.g., selective announcements [ 4,37]), (2) /29 and /30 IPv4 prefixes with (PointtoPoint) peering subnets (i.e., the subnets needed to form interAS connections) [ 40], (3) /31 and /32 IPv4 prefixes with blackholing [ 9,10,15], (4) /49 to /64 IPv6 prefixes with address block reassignments [ 35], and (5) /113 to /128 IPv6 prefixes again with blackholing2. Figure 3 shows the number of IPv4 (left) and IPv6 (right) HSPs over time colored by their respective CIDR size groups. We first observe that the overall trends are stable over time. In IPv4, we observe that the most common CIDR size is /31–/32, i.e., the most prominent use case seems to be blackholing. Yet, we also observe that /29–/30 HSPs are comparably common; hence, many HSPs may actually represent peering subnets. Given that only about 10 % of HSPs have a CIDR size of /25 or /26, we believe that traffic engineering is a rare use case. For IPv6, we mainly observe the /49–/64 CIDR size range that we associate with address block relocations. In some ASes we also observe instances of /64s being used by hypergiants for offnets [ 14]. We further observe a small fraction of /113–/128 CIDR sizes that we associate with blackholing. The share of blackholing HSPs is smaller in IPv6 compared to IPv4, which is in line with reports that blackholing in IPv6 makes up 2In private conversations a large European IXP confirmed that around 90 % of all blackholed IPv6 prefixes fall into the /113 to /128 prefix range. ACM SIGCOMM Computer Communication Review Volume 52 Issue 2, April 2022less than 2 % compared to IPv4 [ 15,32]. Those observations also explain some of the fluctuations that we observed in the previous section—blackholing events, and their subse quently announced prefixes, are often shortlived [ 32] and subsequently can cause substantial changes in the number of unique HSPs seen throughout a week. As our CIDRbased analysis only provides us with hints on the actual usage, we now also analyze the services hosted in hyperspecific prefixes. For this analysis, we leverage archived scanning data from Rapid7’s Open Data platform [ 38] for 2019, 2020, and 2021. Rapid7 frequently scans the entire routed IPv4 address space3for more than 100 wellknown TCP and UDP ports. To compare regular with hyperspecific prefixes, we rely on the difference in protocol hit rate, i.e., we compare the fraction of responding hosts and total tested hosts4on a perprotocol basis. We observe that four out of the top five protocols with the highest hit rate for regular and HSP prefixes overlap; BGP is only present in the HSP top five while CWMP is only present in the IPv4wide top five. For those six protocols, Figure 4 shows a the relative difference of hit rates between regular and hyperspecific prefixes, where a positive value indicates an increase of hit rate in hyper specific prefixes. While HTTP and HTTPS overall only see an increase of +100 %, we observe strong differences when drilling down on a perCIDR level: When considering only /32 prefixes, HTTP’s hit rate increases by more than +500 % compared to its hit rate for IPv4wide scans—which substan tiates the association of the /32 CIDR size for blackholing. Even more pronounced than HTTP(S), SMTP and BGP see increases of up to +500%. When digging deeper we further observe that BGP is mainly prevalent in /30 and /29 prefixes, which underlines that these sizes might be dedicated to rout ing infrastructure. In contrast, we observe the only hit rate decrease (of more than 90%) for CWMP—a protocol used to remotely manage customerpremises equipment (CPE) devices such as home routers [52]. Finally, we investigate BGP communities attached to HSP announcements. BGP communities are used for many dif ferent reasons, such as information tagging, blackholing, or route redistribution. The most common BGP communi ties attached to hyperspecific prefixes are route steering or prepending instructions. In our analysis we look for BGP communities which are specifically used for blackholing 3Except for prefixes on their blocklist which were explicitly requested by network operators. 4Given that Rapid7 does not publish the state of their blocklist, we assume that all (at the time of the scan) routed IP addresses were tested. Additionally, we focus on analyzing what services are prominent in HSPs. We can not ensure that Rapid7 (or its upstream) does in fact receive the HSP announce ments, as information about their probing vantage points and routing is not available. IPv6 HSPs 73.5 % 6.8 % 0.0 % 0.0 % 0.0 % 6.8 % 0.0 % 6.5 % 1.3 % 0.1 %Any Comm. Any RES/BH Any RES NO_ADV. NO_EXP. Any BH BH IANA X:666 X:999 X:9999IPv4 HSPs 60.0 % 13.1 % 0.5 % 0.1 % 0.5 % 13.1 % 3.2 % 11.2 % 2.8 % 3.3 %Figure 5: BGP communities distribution for HSPs. (BH) [ 23] or restrict route propagation (RES)5. Figure 5 shows the use of BGP communities among HSPs from snapshots between 2019 and 2021. The bars indicate the median share of HSPs with the respective community, the whiskers de note the standard deviation over time. The “Any” keyword is used to specify groups of community targets, e.g., “Any RES” describes all prefixes that have any restriction community at tached (i.e., it refers to the union of prefixes with “NO_ADV” community and prefixes with “NO_EXP” communities); sim ilarly, the “Any Comm.” bar refers to the highest aggregation, i.e., prefixes for which we saw any community attached. As we can see, 60% of all IPv4 HSPs and almost three quarters of IPv6 HSPs come with some form of BGP communities. The vast majority of these communities is, however, not related to blackholing or restricting propagation. Only about 13% and 7% of prefixes can be associated with blackholing for IPv4 and IPv6, respectively. The by far most popular blackholing community is X:666 . Moreover, we see no propagation re striction communities (“no advertise” or “no export”) in IPv6 and only about 0.5% in IPv4. Furthermore, we see that RES communities are a subset of BH communities, hinting that operators do not want their blackholing prefixes to propa gate. Blackholing is therefore one contributor of HSPs, but blackholing communities are not present on the majority of HSP announcements. We note that the blackholing commu nities that we see at route collector peers is a lower bound: Blackholing communities—similar to other communities— could be cleaned along the path but the prefix itself could continue to propagate [24]. 5We also test for communities such as NOPEER or NO_EXPORT_SUBCONFED, but these are not prevalent among HSPs. ACM SIGCOMM Computer Communication Review Volume 52 Issue 2, April 2022Dataset IRRRPKI Multiple BGP0 2.5K 5K 7.5K 2010 2015 2021  Time (quarterly)# IPv4 Origin ASes 0 500 1K 1.5K 2010 2015 2021  Time (quarterly)# IPv6 Origin ASesFigure 6: Visibility of origin ASes across data sets. ROV stateInvalid (Both) Invalid (Origin)Invalid (Length) Valid0255075100 2015 2018 2021 Time (quarterly)Fraction of IPv4    (HSP−Origin−Pairs) 0255075100 2015 2018 2021 Time (quarterly)Fraction of IPv6      (HSP−Origin−Pairs) Figure 7: ROV status for HSPs In summary , we observe that for IPv4 many and for IPv6 some HSPs are likely related to blackholing activities due to the used HSP prefix size. We find concrete evidence for 7–13% of HSPs explicitly tagged with blackholing communi ties. While we also observe many HSPs dedicated to routing infrastructure (e.g., peering subnets or address relocations), we observe that hyperspecific prefixes rarely contain any CPE devices. 4 INTENDED OR ACCIDENTAL USE? Now that we have a basic understanding of the use cases of HSPs, we want to analyze whether HSPs are used intention ally or accidentally by ASes and their operators. If operators take the time and effort to explicitly enter hyperspecific prefixes into voluntarilymaintained databases, then it is likely that they plan to use them. Hence, we look at the Re source Public Key Infrastructure (RPKI) and Internet Routing Registry (IRR) operator databases. We use private, threemonthly IRR snapshots [ 19] between January 1, 2017, and October 7, 2021, which contain infor mation about routing policies. The RPKI database contains legally binding mappings between Internet resources and ASes. We use daily snapshots of the RPKI database [ 43] from April 1, 2015, until October 7, 2021, generated by Chung et al. [5] to verify the validity of HSP announcements by ASes. While we extract HSPs directly from the route(6) objects contained in the IRR databases, the Route Origin Authoriza tion (ROA) objects in the RPKI snapshots describe CIDR size ranges [ 18]. Hence, a ROA can explicitly describe an HSP when both the minimum and maximum prefix length are hyperspecific, or implicitly when only the maximum prefix length is hyperspecific. When extracting HSPs and their origins from the RPKI database, we rely solely on ex plicit definitions as these clearly represent the desire to use HSPs (as all covered prefixes are hyperspecific). As implicit definitions might describe the future—but not necessarilycurrent—use of HSPs (e.g., an AS might currently announce a /24 but has already entered a currently unused maxlength of /25), we decide to ignore them. We compare the HSPs on those two databases against the HSPs visible via BGP route collectors. Figure 6 shows the number of unique origin ASes for both IPv4 and IPv6 within each dataset over time. We classify those origin ASes available in more than one dataset into the “Multiple” category. Our first observation is that for both IPv4 and IPv6, the IRR dataset contains the largest fraction of HSP origin ASes. While this might imply that network operators tend to actually use HSPs, it is wellknown that route objects can become stale given that the database is only maintained on a voluntary basis [ 48]. Yet, some entities, e.g. certain IXP Route Servers [ 8], require route objects in the IRR database to redistribute prefixes (i.e., HSPs). Even for the RPKI database we observe hundreds of explicitly defined HSPs6. Notably, for the last snapshot in October 2021, implicit HSPs would have increased the number of RPKI origin ASes from 294 to 990 for IPv4 and from 172 to 794 for IPv6, respectively. Beyond these intentional HSPs, we also observe that many of the HSPs from Route Collectors have no entries in operator databases, hence, they could potentially represent accidental announcements or misconfigured route collector sessions that leak internal routes. While it is hard to link malicious intent to a morespecific announcement (since it could be, e.g., an address leasing agreement [ 36] or traffic engineering of sibling ASes [ 13]), we want to understand if the visible HSPs in the BGP are legitimate prefix advertisements by valid origin ASes or as sociated with possible prefix hijacks. Therefore, we perform route origin validation (ROV) of HSPs and its origin AS by checking them against the ROA records from the RPKI dataset. If a ROA covers the address space described by the 6Most of these HSPs are also in the BGP data set and hence end up up in the multiple class. ACM SIGCOMM Computer Communication Review Volume 52 Issue 2, April 2022prefix, then this prefix can violate the ROA in two ways: it can be too specific—which we mark as “Invalid (Length)”— and it can be announced by a different origin—which we mark as “Invalid (Origin).” If both of these conditions are met at the same time, we mark a prefix as “Invalid (Both).” If none of these conditions are met, we consider the prefix as “Valid.” Notably, we observe that 22 % of IPv4 and 19 % of IPv6 HSPs have a covering ROA entry (median percentages across snapshots in 2020 and 2021). Figure 7 shows that legitimate ASes, i.e., the valid and invalid length categories together, advertise around 75 % of all HSPs. With an average of 25 % and peaking to around 50 % in 2016, 2017, and 2019, IPv6 has a higher percentage of valid HSPs than IPv4. The HSPs with invalid length form the largest group in IPv4, and mostly the second largest group in IPv6. The third largest group of HSPs has the “Invalid (Both)” ROV state, while the invalid origin category forms a minor fraction of HSPs’ ROV state. Legitimate ASes advertise around 75 % of HSPs, which indicates that HSPs are not ma jorly associated with BGP prefix hijacks. Beyond malicious ASes, the “Invalid (Origin)” and “Invalid (Both)” status could also be caused by not properly entered sibling ASes [ 13] or from a DDoS Protection Service (DPS) [ 21]. We analyze how many hyperspecific prefixes are originated from a DPS as identified by Jin et al. [ 21] and find that only around 1 % of HSPs in IPv4 and IPv6 are related to DPS companies. In summary, we observe that for both IPv4 and IPv6, hun dreds of ASes intentionally entered hyperspecific prefixes into operator databases. Yet we also see that many of the HSPs that are visible from route collectors have no respective entries and are likely related to the accidental announcement or disclosure of internal routes. This is further substantiated by the observation that most HSPs are actually ROV invalid since they are more specific then intended by their covering ROA entry. 5 DISCUSSION Research Community. While many HSPs seem to be in tentional, we also observe a large number that potentially represent leaked internal routes. While the task of reconfig uring a leaking router ultimately belongs to the feeder AS’ operators, we believe that the maintainers of route collector projects play a vital role when it comes to raising aware ness for the existing problems. To support and guide this process, we publish and maintain a dashboard that provides uptodate HSP statistics as well as a rankings of the top HSP contributors at https://hyperspecifics.io. Beyond fixing potential leakage errors, we believe that studying the poten tial correlations between hyperspecific prefixes and their lessspecific counter parts may lead to new insights into the routing optimizations used by ASes.Operator Community. Even though various guides [ 11, 12,29,33,34] recommend strict filtering of HSPs, we find that many hyperspecific prefixes propagate to 100 or more collector peers. After discussing our results with thirteen operators from different types of networks, we believe that the limited filtering is often a result of popular customer re quests. The operator of a major transit network told us that their network recently (throughout Summer 2020) changed from the filtering of all IPv4 HSPs to only filtering prefixes more specific than /28; this shift enabled (especially new and small) customer networks to perform basic traffic engineer ing despite a limited address allocation7. This opens up the question whether operators should filter HSPs in the first place. We believe that for IPv6 the answer is a resounding “yes”. Given that there is no shortage of IPv6 addresses and obtaining new blocks is virtually free (compared to the high costs of obtaining IPv4 addresses), we do not see any reason to loosen the current filtering guidelines. For IPv4, we think that the answer should be more nuanced. While loosening the filtering guidelines allows even small ASes to perform traffic engineering, it would also further increase the routing table size. Hence, we believe that shifting the acceptable boundaries by a few CIDR sizes (e.g., /26 or /28) might be an agreeable compromise. 6 RELATED WORK "
107,Defining and Computing Alternative Routes in Road Networks.txt,"Every human likes choices. But today's fast route planning algorithms usually
compute just a single route between source and target. There are beginnings to
compute alternative routes, but this topic has not been studied thoroughly.
Often, the aspect of meaningful alternative routes is neglected from a human
point of view. We fill in this gap by suggesting mathematical definitions for
such routes. As a second contribution we propose heuristics to compute them, as
this is NP-hard in general.","The problem of ﬁnding the shortest path between two nodes in a dire cted graph has been intensively studied and there exist several methods to solve it, e.g. Dijkstra’s algorithm [Dij59]. In this work, we focus on graphs of road networks and are intere sted not only in ﬁnding oneroute from start to end but to ﬁnd severalgood alternatives. Often, there exist several noticeably diﬀerent paths from start to end w hich are almost optimal with respect to length (travel time). For a human, it can have adva ntages to be able to choose the route for his tour himself among a set of good alternativ es. A person may have personal preferences or knowledge for some routes which a re unknown or diﬃcult to obtain, e.g. a lot of potholes. Also, routes can vary in diﬀerent attr ibutes beside travel time, for example in toll pricing, scenic value, fuel consumption or ris k of traﬃc jams. The tradeoﬀ between those attributes depends on the person a nd the persons situation and is diﬃcult to determine. By computing a set of good alternatives, the person himself can choose the route which is best for his needs. 1There are many ways to compute alternative routes, but often wit h a very diﬀerent quality. In this work, we propose new ways to measure the quality of a solution of alternative routes by mathematical deﬁnitions based on the graph structure. Also, we present several diﬀerent heuristics for computing alternative ro utes as determining an optimal solution is NPhard in general. 1.1 Related Work "
94,Delay-Optimal Data Forwarding in Vehicular Sensor Networks.txt,"Vehicular Sensor Network (VSN) is emerging as a new solution for monitoring
urban environments such as Intelligent Transportation Systems and air
pollution. One of the crucial factors that determine the service quality of
urban monitoring applications is the delivery delay of sensing data packets in
the VSN. In this paper, we study the problem of routing data packets with
minimum delay in the VSN, by exploiting i) vehicle traffic statistics, ii)
anycast routing and iii) knowledge of future trajectories of vehicles such as
buses. We first introduce a novel road network graph model that incorporates
the three factors into the routing metric. We then characterize the packet
delay on each edge as a function of the vehicle density, speed and the length
of the edge. Based on the network model and delay function, we formulate the
packet routing problem as a Markov Decision Process (MDP) and develop an
optimal routing policy by solving the MDP. Evaluations using real vehicle
traces in a city show that our routing policy significantly improves the delay
performance compared to existing routing protocols.","Recently, Vehicular Sensor Networks (VSNs) have received a great amount of attention as a new solution for monitoring the physical world [10]. In VSNs, vehicles equipped with sensing devices move around an urban area and sense the urban environment periodically. The vehicles use vehicle to vehicle (V2V) or vehicle to infra (V2I) wireless communications to deliver the sensing data to an urban monitoring center. Hence, unlike the traditional sensing system with ﬁxed sensors that experiences limited coverage, the vehicular sensing system can monitor any area where vehicles can reach. Moreover, the vehicular sensor network can be deployed and maintained with relatively low cost since it does not heavily rely on the network infrastructure for sensing data delivery. Many of the VSN applications such as Intelligent Trans portation System (ITS) require frequent updates of sensing information from all over the urban area, and hence it is important to guarantee timely delivery of sensing data from every area of interest to the urban monitoring center. Such a coverage guarantee is rather challenging in VSNs where the links (and thus the routes to destinations) can come and go depending on the mobility of vehicles. For instance, in such a network with intermittent connectivity, a vehicle sometimes has to carry the data while it moves away from the destination. In fact, DelayTolerant Networks (DTNs) similarly experience intermittent routes to destinations, and there has been a large body of work that addresses the problem of routing data packets with minimum delay in DTNs [2], [7], [9], [12], [21]. Due to AP1  AP2 S A1 Low density  High density   A2 Carry  Forward  (a) Vehicle density on the road High delivery probability  Low delivery probability   AP1 AP2  AP4 AP3  S B1 B2  fail fail fail  (b) Anycast routing S C1  Guaranteed path  C2  Predictable vehicle  Nonguaranteed path  AP  (c) Knowledge of future trajectories Fig. 1. Important factors on the delay performance in Vehicular Sensor Networks: APs are destinations in anycast routing the similarity, the packet routing policies for DTNs could be used for VSNs as well. However, the VSN is distinguished from general DTNs in several aspects. First, vehicles in VSNs only move along the road, whereas mobile nodes in general DTNs are typically assumed to be able to move arbitrarily. Sec ond, VSNs generally adopt anycast with multiple destinations, whereas most of the works in general DTNs assume unicast. Third, there are vehicles with predetermined future trajectories, such as buses, whereas in general DTNs, it is hard to predict the movement of mobile nodes. Therefore, the packet routing policies for DTNs may not be directly applicable to VSNs, or may not be able to fully exploit the characteristics of VSNs. In this paper, we study the packet routing problem in the VSN with anycast. In particular, we focus on minimizing the packet delivery delay from every area of interest to the urban monitoring center. It is obvious that a packet routing algorithm with minimum delay must take into account the aforementioned characteristics of VSNs. First, since the vehicles can move only along the road, the vehicle density can be different from road to road. Clearly, the road with high density can provide more opportunities ofarXiv:1209.4527v1  [cs.NI]  20 Sep 20122 wireless multihop transfers, and thus reduce the delivery delay on the road. Consider a source vehicle Sin Fig. 1(a), which tries to select a better relay out of vehicles A1andA2. Even thoughA1is closer to a destination (or AP in Fig. 1(a)), forwarding to A2may be more beneﬁcial since the delay of multihop transfer over high density road is much smaller than carrying delay. Second, in anycast routing, a data packet just needs to be delivered to any one of the multiple destinations. Hence, the effect of multiple APs can be exploited to reduce the packet delay. As shown in Fig. 1(b), forwarding to B1can fail to deliver packets to the targeted AP ( i.e.,AP1) due to the uncertainty in B1’s movement. However, since there exist many alternative APs on the direction of B2(i.e.,AP2,AP3and AP4), forwarding to B2may be a better option for reducing the delay. Third, the vehicles with known trajectories such as buses can help further reduce the delay. In Fig. 1(c) where Sis far from the destination, such a predictable vehicle C2 guarantees to carry packets to the AP, which can signiﬁcantly improve the routing performance compared to the delivery along a nonguaranteed path. Note that the effect of known future trajectories is greatly appreciated in the scenario where the vehicle density is relatively low. Our goal in this paper is to develop a delayoptimal packet routing algorithm in VSNs, by taking into account the above ideas. We ﬁrst develop a novel road network graph model that incorporates the effect of predetermined vehicle trajectories as well as unpredictable trajectories. This network model is used to characterize the delay on a road segment as a function of the average vehicle density and speed, and the length of the road segment. Based on the network model and delay function, we formulate the routing problem as a Markov Decision Process (MDP) that seeks to minimize the expected delay of a packet from each area to one of the destinations. We develop an optimal packet routing algorithm by solving the MDP. We examine our algorithm using Shanghai vehicle traces [1], [15], and show that the packet delay from each area is signiﬁcantly improved compared to existing routing algorithms in [8], [16]. The rest of this paper is organized as follows: In Section II, we discuss related work. In Section III, we present the road network graph model of the VSN. In Section IV, we formulate the packet routing problem as an MDP, and develop an optimal routing policy that solves the MDP. In Section V, we evaluate the performance of our routing algorithm using real vehicle traces. II. R ELATED WORK "
329,Contact-Aware Opportunistic Data Forwarding in Disconnected LoRaWAN Mobile Networks.txt,"LoRaWAN is one of the leading Low Power Wide Area Network (LPWAN)
architectures. It was originally designed for systems consisting of static
sensor or Internet of Things (IoT) devices and static gateways. It was recently
updated to introduce new features such as nano-second timestamps which open up
applications to enable LoRaWAN to be adopted for mobile device tracking and
localisation. In such mobile scenarios, devices could temporarily lose
communication with the gateways because of interference from obstacles or deep
fading, causing throughput reduction and delays in data transmission. To
overcome this problem, we propose a new data forwarding scheme. Instead of
holding the data until the next contact with gateways, devices can forward
their data to nearby devices that have a higher probability of being in contact
with gateways. We propose a new network metric called Real-Time Contact-Aware
Expected Transmission Count (RCA-ETX) to model this contact probability in
real-time. Without making any assumption on mobility models, this metric
exploits data transmission delays to model complex device mobility. We also
extend RCA-ETX with a throughput-optimal stochastic backpressure routing scheme
and propose Real-Time Opportunistic Backpressure Collection (ROBC), a protocol
to counter the stochastic behaviours resulting from the dynamics associated
with mobility. To apply our approaches seamlessly to LoRaWAN-enabled devices,
we further propose two new LaRaWAN classes, namely Modified Class-C and
Queue-based Class-A. Both of them are compatible with LoRaWAN Class-A devices.
Our data-driven experiments, based on the London bus network, show that our
approaches can reduce data transmission delays up to $25\%$ and provide a
$53\%$ throughput improvement in data transfer performance.","Low Power Wide Area Networks (LPWAN) are a relatively new class of wireless communication systems designed for longrange and lowpower performance. There are several LPWAN protocols like SigFox, DASH7, NBIoT and Lo RaWAN [1], [2]. Of these protocols, LoRaWAN is gaining much traction from industrial and academic communities due to its low deployment costs and ﬂexible networklayer protocols. LoRaWAN realises relatively longrange wireless communications (e.g. 2 km in urban and 15 km in rural) via subGHz frequencies (e.g. 868 MHz in EU and 915 MHz in North America). However, nodes operating in the EU need to adhere to low duty cycle operation ( <1%or<10%) [3] and practical mobile communications scheme must adhere to this. Much work has been done to improve throughput and reduce delays in LoRaWAN networks generally. Most of these works,however, assume that nodes and gateways are static and do not consider mobility. There is a rising class of applications that require lowpower mobile solutions to provide new services, e.g. asset tracking. Semtech, the company that proposed LoRa technology, has also been designing new gateways to support nanosecond precision timestamps for acquiring geolocation information from LoRaenabled devices for tracking scenarios. Under mobility, radio channel states vary as locations and envi ronments change over time. Radio channels can be unreliable due to obstacles or deep fading, which can further depend on weather conditions, lineofsight to base stations being blocked, or the speed of the vehicle hosting the data source. The low duty cycling (i.e., 1% for general data channels) regulated by LoRaWAN speciﬁcation makes this situation more challenging still. If a device misses its allocated time slot for communication, it needs to wait minutes if not hours before it can upload its data in the next round, thus causing signiﬁcant delays to data delivery. Consequently, new and/or improved protocols are required to ensure ondemand delivery of information during movement. Here, instead of trying to send data via unreliable radio channels to gateways or awaiting for next gateway contact, LoRaWAN devices can send their data to gateways via other nearby devices that have better quality contact with gateways. As the capability of communicating through longrange LoRa is typically more signiﬁcant than actual device mobility, it is easier to ﬁnd reliable neighbours for data forwarding than re tain unsent data awaiting a good connection with a gateway. By exploiting this observation, we propose two new opportunistic data forwarding approaches which can effectively reduce data delivery delays and improve network throughput. In the ﬁrst approach, we introduce a new network metric to drives decision making in terms of the helper devices chosen to forward data through  namely, Realtime Contact Aware Ex pected Transmission Count (RCAETX). This new metric can seamlessly illustrate device mobility with packet transmission delay, which is widely accepted in many objectivefunction based data forwarding protocols. Furthermore, we extend RCAETX by combining it with a throughputoptimal stochas tic backpressure scheme, and propose Realtime Opportunistic Backpressure Collection (ROBC). ROBC can cope better with uncertain links in mobile scenarios, and delivers improved performance compared to RPL with RCAETX. Importantly, RCAETX and ROBC can operate without prior knowledgearXiv:2004.06614v1  [cs.NI]  14 Apr 2020of device mobility. Finally, to ensure our approaches are compatible with other LoRaWAN enabled devices, we propose two new LaRaWAN classes, namely Modiﬁed ClassC and Queuebased ClassA, to support device without and with en ergy constrains, respectively. Both of the proposed classes are compatible with LoRaWAN ClassA, which must be supported by all LoRaWAN enabled devices. To demonstrate the effectiveness of RCAETX and ROBC, we evaluate the performance of RCAETX and ROBC with extensive datadriven experiments using the London Bus net work [4]. Our experimental results show that the solution can effectively reduce delays by up to 25% in both urban and rural areas, while giving a throughput improvement up to 53% with an overhead of up to 2.2 times the number of messages. The rest of this paper is organised as follows. Section II discusses related work. Section III introduces the background to this work. Our main contributions, RCAETX and ROBC, are explained and proposed in Sections IV and V, respectively. A discussion on practical implementations and performance evaluation is given in Sections VI and VII, and we conclude the paper in Section VIII. II. R ELATED WORK "
200,Giant magnetocaloric effect driven by first-order magneto-structural transition in cosubstituted Ni-Mn-Sb Heusler compounds: predictions from \textit{Ab initio} and Monte Carlo calculations.txt,"Using Density Functional Theory and a thermodynamic model [Physical Review B
86, 134418 (2012)], in this paper, we provide an approach to systematically
screen compounds of a given Heusler family to predict ones that can yield giant
magnetocaloric effect driven by a first-order magneto-structural transition. We
apply this approach to two Heusler series
Ni$_{2-x}$Fe$_{x}$Mn$_{1+z-y}$Cu$_{y}$Sb$_{1-z}$ and
Ni$_{2-x}$Co$_{x}$Mn$_{1+z-y}$Cu$_{y}$Sb$_{1-z}$, obtained by cosubstitution at
Ni and Mn sites. We predict four new compounds with potentials to achieve the
target properties. Our computations of the thermodynamic parameters, relevant
for magnetocaloric applications, show that the improvement in the parameters in
the predicted cosubstituted compounds can be as large as four times in
comparison to the off-stoichiometric Ni-Mn-Sb and a compound derived by single
substitution at the Ni site, where magnetocaloric effects have been observed
experimentally. This work establishes a protocol to select new compounds that
can exhibit large magnetocaloric effects and demonstrate cosubstitution as a
route for more flexible tuneability to achieve outcomes, better than the
existing ones.","The development of magnetic refrigeration, a new solidstate refrigeration technology, based on the magnetocaloric eﬀect (MCE), continues to attract considerable attention worldwide due to its environ mentally friendly nature, higher energy eﬃciency, lower mechanical noise, and simple mechanical construction, in comparison with conventional technology based on gas compression/expansion1–3. The underlying magne tocaloriceﬀect (MCE) is measuredinterms ofisothermal magnetic entropy change (∆S mag) and/or adiabatic tem perature change (∆T ad) that require large variations in the material’s magnetization with temperatures. In the magnetic refrigerators, Gd has been considered as a benchmark material due to the discovery of signiﬁcant magnetocaloric eﬀect in it, an outcome of a secondorder ferromagnetic to paramagnetic transition close to room temperature4. However giant eﬀect is generally observed in materials which undergo a ﬁrstorder magneto structural transition i.e. a structural phase transition, coupled with a magnetic one5–19. Magnetic refrigeration near room temperature is of special interest because of its social and economic beneﬁts. From this point of view, the continuous search of new solidstate magnetic refrigerantsthat could exhibit a giant MCE, in an appro priate temperature range, as well as the improvement of the existing ones, havebeen focus ofresearchin this area. Among MCE materials, shape memory Heusler com pounds are of great interest as they exhibit large MCE, and their transition temperatures can be eas ily tuned. The origin of their large MCE is the ﬁrst order martensitic phase transition (MPT) from a high temperature cubic austenite phase to a low tempera ture low symmetry phase, a large magnetization change occurring simultaneously. One of the compounds in the Heusler family which recently showed promisingMCE is the oﬀstoichiometric Mnexcess Sbdeﬁcient Ni MnSb where magnetostructural transition and signif icant magnetocaloric eﬀect were observed near room temperature20–22. With an aim to improve the MCE in this family of compounds, some recent investigations have also been carried out, by substituting the Fe and Co atoms at Mn and Ni sites, respectively, resulting in large positive val ues of ∆S mag22–25. Though the transition metal sub stituted NiMnSb Heusler compounds turn out to be useful materials exhibiting giant MCE, one major disad vantage is that upon substitution, the working temper ature, i.e., the martensitic transformation temperature (TM) falls below the room temperature. This is not de sirable for operational purposes. In some recent studies, the strategyofsubstitution of at least two 3 delements si multaneously (cosubstitution) has been found to be use ful in achieving the important magnetic and structural properties with better tuning and adaptability26–28. In a recent work29, we explored potential roomtemperature magnetocaloric materials in two cosubstituted fami lies, Ni 2−xFexMn1+z−yCuySb1−z(Fe@NiCu@Mn) and Ni2−xCoxMn1+z−yCuySb1−z(Co@NiCu@Mn). We found that foracertainrangeofcompositions, there isno structural transformation down to the low temperature indicating that the MCE is purely due to secondorder magneticphasetransition. Wealsofoundthatlargemag netic moments and T c, the Curie temperature, close to room temperatures can be easily achieved by tuning the compositions, along with a signiﬁcant MCE. These indi cated a delicate balance of the concentrations of diﬀerent constituentsandeasytunability ofpropertiesin thisfam ily. Armed with this information, in the present work, we focused on the composition ranges that were not covered in Ref 29. A martensitic phase transformation (MPT) occurs in cosubstituted NiMnSb compounds with those compositions. We aimedtoexplorewhetheragiantMCE due to magnetostructural coupling can be predicted in2 these compositions along with near room temperature TM. Using a thermodynamic model in conjunction with ﬁrstprinciples electronic structure calculations, we made comparisons with the systems already explored experi mentally and provided predictions of new compounds, yet to be realized experimentally, that can exhibit signif icantly large MCE. This study established a systematic way to use the information on structural and magnetic properties obtained from ﬁrstprinciples calculations to screen the materials that are potential ones with target properties and the robustness of the formalism to accu rate predictions of new compounds. II. METHOD OF CALCULATION AND "
473,Reliability of Mobile Agents for Reliable Service Discovery Protocol in MANET.txt,"Recently mobile agents are used to discover services in mobile ad-hoc network
(MANET) where agents travel through the network, collecting and sometimes
spreading the dynamically changing service information. But it is important to
investigate how reliable the agents are for this application as the
dependability issues(reliability and availability) of MANET are highly affected
by its dynamic nature.The complexity of underlying MANET makes it hard to
obtain the route reliability of the mobile agent systems (MAS); instead we
estimate it using Monte Carlo simulation. Thus an algorithm for estimating the
task route reliability of MAS (deployed for discovering services) is proposed,
that takes into account the effect of node mobility in MANET. That mobility
pattern of the nodes affects the MAS performance is also shown by considering
different mobility models. Multipath propagation effect of radio signal is
considered to decide link existence. Transient link errors are also considered.
Finally we propose a metric to calculate the reliability of service discovery
protocol and see how MAS performance affects the protocol reliability. The
experimental results show the robustness of the proposed algorithm. Here the
optimum value of network bandwidth (needed to support the agents) is calculated
for our application. However the reliability of MAS is highly dependent on link
failure probability.","A mobile agent is a combination of software program  and data which migrates from a site to  another site to perform tasks assigned by a user ac cording to a static or dynamic route [1]. It can  be viewed as a distributed abstraction layer that p rovides the concepts and mechanisms for  mobility and communication [2]. An agent consists o f three components: the program which  implements it, the execution state of the program a nd the data. An agent may migrate in two  ways, namely, weak migration and strong migration [ 3]. The platform is the environment of  execution. The platform makes it possible to create  mobile agents; it offers the necessary  elements required by them to perform their tasks su ch as execution, migration towards other  platforms and so on.  International Journal of Wireless & Mobile Networks  (IJWMN) V ol. 3, No. 5, October 2011  230         Typical benefits of using mobile agents include [4]    • Bandwidth conservation: sending a complex query to the database server for  processing.  • Reduced latency: a lightweight server can move clos er to its clients  • Load balancing: loads may move from one machine to the other within a network etc.  The route of the mobile agent can be decided by its  owner or it can decide its next hop  destination on the fly. Here, we assume the underly ing network to be a Mobile Ad Hoc Network  (MANET) that typically undergoes constant topology changes, which disrupt the flow of  information over the existing paths. Mobile agents are nowadays used in MANETs for various  purposes like service discovery [5], network discov ery, automatic network reconfiguration etc.  But before mobile agent based applications become c ommercially available for MANET,  reliability estimation of them is very essential. B ecause of motion and location independence  [1], this environment itself introduces new aspects  to reliability (in terms of continuity of  correct service).   In [1] [6] we tried to address this issue. In [7] r eliability estimation of service discovery [5]  agents is considered along with few modifications t o the basic mechanism [5] in order to reflect  the dynamism of the underlying environment. But nod e mobility is not considered explicitly,  the link connectivity is assumed to follow Non Homo genous Poisson (NHPP) distribution. Thus  we did not consider parameters like pattern of node  mobility, transient failure of the links etc.   In this paper node mobility is represented by mobil ity models. Three kinds of mobility are  considered. Random movement of nodes is proposed in  Random Waypoint Mobility Model  [8](RWMM), node movement based on temporal dependen cy in Smooth Random Mobility  Model [9] (SRMM) and node movement based on spatial  dependency in Reference Point Group  Mobility Model [10] (RPGM). Also multipath propagat ion of radio signals is considered  according to two ray propagation model [11] as it i s simple and widely used in literature. In  reality, even when an agent finds a node to be conn ected to where it is now residing, an attempt  to migrate to that node (host site) may fail becaus e of transient link errors like frequency  selective fading, heavy rainfall etc. This effect c an be modelled as a Poisson process. Reliability  estimation algorithm of [7] is modified to incorpor ate these changes. Also a metric is proposed  to measure the performance of the service discovery  protocol. This enables us to thoroughly  study the effect of MAS reliability on service disc overy. Our MAS reliability estimation model  is not tightly coupled to the application (service discovery) but with minor modifications it can  be applied to agents  deployed by other MANET appli cations as well.  In the following section we discuss about the servi ce discovery process using mobile agents in  MANET. Then in section 3 state of art regarding thi s topic is mentioned. In section 4 our model  is introduced that is designed to estimate reliabil ity of the mobile agent based system (MAS).  The next section (5) gives the experimental results  followed by concluding remarks in section  6.  2.  THE PROCESS OF SERVICE DISCOVERY   A service can be regarded as any hard or software resource, which can be used by other clients.  Service discovery is the process of locating servic es in a network. The following methods are  used to discover and maintain service data [12]:  • service providers flood the network with service ad vertisements;  • clients flood the network with discovery messages; International Journal of Wireless & Mobile Networks  (IJWMN) V ol. 3, No. 5, October 2011  231         • nodes cache the service advertisements;  • nodes overhear in the network traffic and cache the  interesting data.  The first one corresponds to passive discovery (pus h model) whereas the next one describes  active discovery (pull model). The other two method s mentioned above are the consequences of  the first two. While the push mechanism is quite ex pensive in terms of network bandwidth (in  the context of MANET), the pull mechanism suffers f rom poor performance (longer response  times). Moreover there are other factors to be take n into account such as the size of the network  (no. of nodes), availability of a service (how freq uently services appear and disappear in the  network), and the rate of service requests. Traditi onally static service brokers are used for  sharing service information which is not suitable f or MANET due to its inherent dynamic  nature. So as in [5] mobile agents can be deployed for this purpose (looking for services  offered) as the agents can migrate independently [1 3], behave intelligently [14] and can  negotiate with other agents according to a well def ined asynchronous protocol [15].  The service discovery protocol presented in [5] is taken to be the basis here. We first estimate  the reliability of MAS where the agents are roaming  around the underlying MANET,  discovering various services provided by the nodes in MANET. To do this the algorithm [5]  uses two types of agents – a static Stationery Agen t (SA) and mobile Travel Agent (TA). The  SAs are deployed on per node basis. On the contrary  the TAs are deployed dynamically to  collect and spread service information among the no des in MANET. A TA prefers those nodes  on its route which it has not yet visited but which  are reachable via nodes it already knows. In  order to enforce this TA Route algorithm is propose d in [5] that determines the next target  migration site of a TA. The SAs are responsible for  controlling the no. of TAs roaming around  the network. Thus depending on the incoming agent f requency (that is, no. of agents TA visiting  a node is said to be incoming agent frequency) of T A, an SA can either create or terminate a TA  depending on network bandwidth. Larger the bandwidt h more agents can be supported leading  to better performance and probably improved reliabi lity.  3.  RELATED WORKS   "
89,PlaceRAN: Optimal Placement of Virtualized Network Functions in the Next-generation Radio Access Networks.txt,"The fifth-generation mobile evolution enables several transformations on Next
Generation Radio Access Networks (NG-RAN). The RAN protocol stack is splitting
into eight possible disaggregated options combined into three network units,
i.e., Central, Distributed, and Radio. Besides that, further advances allow the
RAN software to be virtualized on top of general-purpose vendor-neutral
hardware, dealing with the concept of virtualized RAN (vRAN). The disaggregated
network units initiatives reach full interoperability based on the Open RAN
(O-RAN). The combination of NG-RAN and vRAN results in vNG-RAN, enabling the
management of disaggregated units and protocols as a set of radio functions.
The placement of these functions is challenging since the best decision can be
based on multiple constraints, such as the RAN protocol stack split, routing
paths of transport networks with restricted bandwidth and latency requirements,
different topologies and link capabilities, asymmetric computational resources,
etc. This article proposes the first exact model for the placement optimization
of radio functions for vNG-RAN planning, named PlaceRAN. The main objective is
to minimize the computing resources and maximize the aggregation of radio
functions. The PlaceRAN evaluation considered two realistic network topologies.
Our results reveal that the PlaceRAN model achieves an optimized
high-performance aggregation level, it is flexible for RAN deployment
overcoming the network restrictions, and it is up to date with the most
advanced vNG-RAN design and development.","THEﬁfthgeneration mobile evolution is based on stan dards [1]–[3], enabling the functional radio protocol stack disaggregation and the virtualization of the Radio Access Network (vRAN). The instantiation of virtualized parts of such radio stack on generalpurpose vendorneutral hardware. These standards specify the Next Generation RAN (NGRAN) architecture to meet the new service de mands, e.g., ultralow latency and highbandwidth appli cations. Furthermore, the industry is leveraging on NG RAN promoting open solutions, being Open RAN (ORAN) * Fernando Zanferrari Morais, Rodrigo da Rosa Righi, and Cristiano Bonato Both are with the University of Vale do Rio dos Sinos (UNISINOS). Gabriel Matheus, Leizer Pinto, Kleber Vieira Cardoso are with the Uni versidade Federal de Goi´ as (UFG). Luis M. Contreras is with the Transport & IP Networks  Systems and Network Global Direction, Telef´ onica CTIO Unit. *https://www.oran.org/the most promising one, focused on interoperability among vendors’ implementations of the disaggregated radio pro tocol stack [4]. The proposed NGRAN architecture enables the base station for splitting the radio protocol stack into eight potential options combined in up to three network elements: (i) Central Unit (CU), (ii) Distributed Unit (DU), and (iii) Radio Unit (RU) [2], [5]. These split options intend to enable sophisticated radio features and improve cost efﬁciency compared with previous mobile generations [5], [6]. The softwarization process in NGRAN is guided by the virtualization of nodes and radio functions enabled by the Network Function Virtualization (NFV) concept [7], [8]. For example, the NGRAN architecture functional split combined with vRAN provides ﬂexibility in deploying mo bile access networks. This ﬂexibility allows mobile network operators to place the radio functions taking into account available network resources and existing user demand. The dynamic placement of radio functions following a ﬁne grained network management approach is vital for ﬁfth generation networks to achieve societal digital transforma tion expectations. However, the development of the virtual ized NGRAN architecture (vNGRAN) is an unprecedented challenging problem since crosshaul transport networks (i.e., integrated backhaul, midhaul, and fronthaul networks) have stringent bandwidth and latency requirements, differ ent diverse topologies and link capabilities, differently sized Computing Resources (CR), and unbalanced user demand [2], [9]. vNGRAN represents the latest advancement in ﬁfth generation research. However, no decisionmaking meth ods are yet available for the design and speciﬁcation of the placement of virtualized radio network functions. The placement is deﬁned as an optimization problem [10], [11] based on the best joint decision between the split of the RAN protocol stack, the routing paths of the crosshaul network, and the CRs strategies of the CU, DU, and RU nodes [11]. Therefore, the ideal placement leads to an analysis compris ing the bandwidth and latency requirements for each split option between CUDU and DURU. Moreover, each split option results in a computing cost (in terms of processing, memory, and storage) to be evaluated. The placement needsarXiv:2102.13192v4  [cs.NI]  29 Mar 2021IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. XX, NO. Y , MONTH YEAR 2 to be aware of the load occupation and the networking and computing resources allocation to ensure proper network scalability. In the literature, several works address the placement optimization of radio functions. The main strategies devel oped so far are to maximize the number of Virtual Network Functions (VNFs) running in a single CU, DUs ﬁxes, and close to RUs [12], [13]. Moreover, CU is colocated with the core of the network [14]. The stateoftheart is restricted in considering the number of protocol disaggregation options, with a maximum of ﬁve [15], or the overall efﬁciency obtained under crosshaul constraints (mainly, the fronthaul network) [12], [16], [17], and computing resources [18], [19]. Therefore, to the best of our knowledge, there is no work yet in the literature fully considering CUs, DUs, and RUs on realistic operational networks, making the problem more general with higher functional split options and protocol stack analysis. Contributions . In this article, we introduce PlaceRAN, a problem formulation for the optimal placement of vNG RAN functions. The problem is formulated as the best trade off between maximizing the aggregation level of virtual ized NGRAN functions and minimizing the number of computing resources necessary for running these functions. PlaceRAN innovates by considering in the formulation all the disaggregated RAN elements (CU, DU, and RU), the segments between those elements (fronthaul, midhaul, and backhaul), and also all possible functional splits according to the standards. Our contributions can be summarized as follows: New problem formulation – PlaceRAN is the most general problem formulation in the context of vNG RAN, and it was designed with a comprehensive set of realworld NGRANs considerations in mind. New approach – we introduced some concepts to properly formulate PlaceRAN, such as Disaggre gated RAN Combination (DRC) and multistage problem formulation, turning the problem formula tion simple despite its generality. Efﬁcient exact solution – we solve PlaceRAN using a conventional solver (i.e., IBM CPLEX) for realworld RAN instances despite the problem complexity. Evaluation and new insights – our evaluation used examples of present and future RANs. We show how PlaceRAN can contribute to the virtualization of present RANs, but it is also ready to deal with the optimal placement of forthcoming vNGRANs. Article organization. Section 2 introduces the back ground for vNGRAN placement. The PlaceRAN system model and problem statement are described in Section 3. Next, Section 4 presents the PlaceRAN evaluation method ology and results. The related work is discussed in Section 5, and ﬁnally, Section 6 presents the ﬁnal remarks. 2 V IRTUALIZED NGRAN P LACEMENT The fundamental idea of a disaggregated NGRAN is to decompose the RAN functions into virtualized components that can be distributed to run into different computing de vices, i.e., following a nonmonolithic approach in contrastto traditional solutions. Therefore, it is necessary to identify how this decomposition can be performed and which con ditions must be satisﬁed to have the disaggregated version running correctly. The disaggregated NGRAN is deﬁned by the concept of functional splits that speciﬁes all the possible partitions for the radio network functions, stating clear interface points between them, and the requirements for each of those radio network functions [4], [20]. TABLE 1 3GPP Latency and bitrate requirements for each split [3]. Split Functional Oneway Bitrate (Gbps) Option Split latency DL UL O1 RRCPDCP 10 ms 4 3 O2 PDCP  High RLC 10 ms 4 3 O3 High RLC  Low RLC 10 ms 4 3 O4 Low RLC  High MAC 1 ms 4 3 O5 High MAC  Low MAC <1 ms 4 3 O6 Low MAC  High PHY 250s 4.13 5.64 O7 High PHY  Low PHY 250s 86.186.1 O8 Low PHY  RF 250s 157.3 157.3 O7 split maximum value. The number of functional splits and the partitions of the radio stack proposed are determined by speciﬁcations from standardization bodies, such as Release 14 from 3GPP [3] and IMT2020/5G from ITUT [2]. Table 1 shows the speciﬁcations of the disaggregated protocol stack considered in this work. The (maximum) latency and (minimum) bitrate values must be satisﬁed in the communication among the RAN nodes (CU, DU, and RU) even if they are running on different computing devices. The latency and bitrate must be assured according to the functional split speciﬁed. The (maximum) latency and (minimum) bitrate values pre sented in the table correspond to an RU with the following conﬁguration: 100 MHz bandwidth of spectrum, 32 antenna ports, 8 MIMO layers, and 256 QAM modulation [3]. Each RAN node (CU, DU, and RU) is considered a virtualized network function as part of a disaggregated NG RAN (3 independents nodes). Each of them runs different parts of a given functional split. Therefore, each RAN node may be identiﬁed by the set of the protocols running into it, as shown in Fig 1. A conﬁguration with less than three nodes may be named DU and RU integration (DU and RU), CRAN (CU and DU), or DRAN (CU, DU, and RU) [2]. In a disaggregated NGRAN, the paths along the network connecting the core to vCU, vCU to vDU, and vDU to RU are deﬁned as backhaul, midhaul, and fronthaul, respec tively. This terminology is useful since each physical link of the access network acts as a crosshaul, meaning that it can transport any combination of the previous paths. The crosshaul needs to ensure the latency and bitrate required according to the variety of functional splits [9], [20]. As illustrated in Fig. 1, each functional split and the corresponding placement of VNFs in a speciﬁc RAN node characterize a Disaggregated RAN Combination (DRC). The concept of DRC, introduced in this article, represents the preservation of the protocol stack order during the process ing of VNFs. Nineteen DRCs are mapped considering seven split options. The O8 option cannot be virtualized since the RF protocol is hardwarebased, making virtualization not feasible. Certain DRCs are not used in practice because theyIEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. XX, NO. Y , MONTH YEAR 3 DRC1 CU   +   DU   + RUCU RC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFO1 O2 O3 O4 O5 O6 O7RC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFO1 O2 O3 O4 O5RC PD HR LR HM LM HP LP RFO6RC PD HR LR HM LM HP LP RFO7RC PD HR LR HM LM HP LP RFCU RUDURC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFRC PD HR LR HM LM HP LP RFO1 O2 O3 O4 O5 O6CU RUDU DU   + RUCU   + DU RU3 Independent Nodes  ORAN Low Split 3 Independent Nodes  SCF Low Split CRAN  RU and DU  integration  DRAN  RC  RRC  PD  PDCP  HR  High RLC  3GPP Functional Split  NGRAN Node  DRC   Disaggregated RAN  Combination RAN Protocol CU  Central Unit  DU  Distributed Unit  RU  Radio Unit Industry DRCs DRC2 DRC3 DRC4 DRC5 DRC6 DRC7 DRC8 DRC9 DRC10 DRC11 DRC12 DRC13 DRC14 DRC15 DRC16 DRC17 DRC18 DRC19  ODRC LR  Low RLC  HM  High MAC  LM  Low MAC HP  High PHY  LP  Low MAC  RF  Radio Frequency  Fig. 1. Functional split and computing devices for a disaggregated NGRAN. are restrictive in the limitations of crosshaul networks, e.g., midhaul with less than 1 ms. We highlighted the nine DRCs effectively adopted in vRAN deployments, whose choice is based on standardiza tion bodies and industry alliances [1]–[3]. In both architec tures of three independent nodes (ORAN and SCF), the focus is on O1 and O2 (Fig. 1  DRC1, DRC2, DRC7, and DRC8). The split O1 makes possible the decentralized data plane. Split O2 is consolidated by 3GPP and ITUT via the F1 interface and is an industry reference for ORAN and SCF initiatives [2], [21], [22]. Two industry DRCs were chosen for the DU and RU integration (Fig. 1  DRC12 and DRC13), besides the two CRAN options (Fig. 1  DRC17 and DRC18). These splits align with ITUT (mainly due to crosshaul constraints) and following ORAN and SCF initiatives [4], [21]. Naturally, the traditional DRAN architecture is also supported to provide scenarios where the crosshaul is very limited [2] (Fig. 1  DRC19). In summary, the disaggregated NGRAN can be imple mented as a virtualized network service, i.e., a collection of VNFs with a particular set of characteristics. First, the service consists of the process of the full protocol stack per RF device in NGRAN. This processing implies respecting an appropriate order of the ﬂowthrough VNFs, i.e., Service Function Chain (SFC). VNFs are instantiated in RAN nodes, which are also virtual elements that can run in different computing devices in NGRAN. The choice of where to position RAN nodes and their VNFs affects the resources ap plied, including computing and networking. For each NG RAN topology and set of resources, there may be multiple options for positioning VNFs and RAN nodes. In general, the objective is to consume the minimum resources and group the maximum of VNFs related to the same protocol or layer. However, each positioning option implies differ ent computing and networking demands, which must not exceed the overall available resources. Therefore, the func tion’s placement becomes a complex optimization problem that we will formally present in the next section.3 M ODEL AND PROBLEM STATEMENT Initially, Subsection 3.1 presents the system model of a formally virtualized and disaggregated NGRAN, in which different functional splits are possible. Moreover, the place ment of the virtual functions is also introduced considering multiple options. After, Subsection 3.2 formulates the op timization problem to minimize the number of necessary computing resources, select the functional splits, and place the virtual functions. 3.1 System Model According to the 3GPP standards (Release 15 [1] and Release 16 [23]), we consider the RAN domain of a mobile network and its connection to the core network, as illustrated by Fig. 2. The RAN domain is composed of: A setB=fb1;b2;:::;bjBjgof RUs, i.e., nodes hosting the Low PHY sublayer and the RF processing based on a lower layer functional split. A setC=fc1;c2;:::;cjCjgof CRs that may process the virtual functions. Each CR cmhas a processing capacitycProc m (given as some reference number of cores). Moreover, each CR has other characteristics, such as memory and storage capacity, but they are not commonly exhausted before the processing ca pacity in the context of disaggregated RAN. A CR may connect directly to an RU. A setT=ft1;t2;:::;tjTjgof transport nodes, which may connect to RUs, CRs, core, or each other. To represent RAN and core, we deﬁne the graph G= (V;E), withV=fv0g[B[C[T being the set of nodes andE=feij;vi;vj2Vg; vi;vj2 Vg representing the set of network links connecting the nodes. v0represents the core and it is the source/destination for all DRCs. Each link eij2E has a transmitting capacity eCap ij (given in multiples of bps) and a latency eLat ij(given in fractions of a second). Paths and routing  we consider that all network trafﬁc has the core as its source (downlink) or destination (uplink).IEEE TRANSACTIONS ON MOBILE COMPUTING, VOL. XX, NO. Y , MONTH YEAR 4 T ransport  node CR RU Core  5 6  4  1 2 3  Fig. 2. RAN considered as a reference to the system model. However, without loss of generality, we represent only the downlink case in this work. We deﬁne Plas the set of k shortest paths from the core to each RU bl2B. Each path p2 P lis composed of three subpaths: pBH (backhaul), pMH (midhaul), and pFH(fronthaul), in which at least one of these subpaths is not empty. Virtualized RAN functions  we consider that a VNF runs parts of the RAN protocol stack (except the RF protocol, as detailed previously). Moreover, VNFs are labeled in increas ing order, starting from PHY Low with f1and ending at RRC withf8. We deﬁneF=ff1;f2;f3;f4;f5;f6;f7;f8gas the set of disaggregated RAN VNFs, where the distribution must follow one of the industry DRCs [2], [22] of the set D=fD1;D2;:::;DjDjg(as illustrated in Fig. 1). 3.2 PlaceRAN Problem Formulation Our problem formulation has two objectives: (i) maximize the aggregation level of RAN VNFs and (ii) minimize the number of CRs used for this aggregation. Since the com puting and network capacities are limited, decreasing the number of CRs may not imply an increase in the aggregation level, which creates conﬂicting objectives. However, there is a relationship between the number of CRs and the aggre gation level. Additionally, the functional splits’ aggregation level is not measured only by the number of VNFs and CRs. The aggregation level is also affected by two other metrics: the number of DRCs employed and the priority or preference of each DRC. Since three incompatible metrics measure the aggregation level, we designed our formulation into three stages. The optimal solution can be eventually obtained in the ﬁrst or second stage, but certainty is only obtained at the third stage, after resolving all potential draws. First Stage In the ﬁrst stage, the objective is to jointly maximize the number of grouped RAN VNFs and minimize the number of CRs used for running those VNFs. We deﬁne xp;r l2f0;1g as the decision variable representing which pair of pathp2Pland DRCDr2D is selected to serve RU bl2B. From the input data, we determine up m2f0;1gto indicate ifcm2 C is part of the p2 P l. Additionally, we deﬁne the mapping function M(cm;fs;bl;Dr)2f0;1gover the input data, which indicates if the CR cm2C runs the VNF fs2F from the RU bl2B, according to the DRC Dr2D. Therefore, we deﬁne the following objective function: minimize 1"
308,Equivalence of Models of Cake-Cutting Protocols.txt,"The cake-cutting problem involves dividing a heterogeneous, divisible
resource fairly between $n$ agents. Br\^{a}nzei et al. [6] introduced {\em
generalised cut and choose} (GCC) protocols, a formal model for representing
cake-cutting protocols as trees with ""cut"" and ""choose"" nodes corresponding to
the agents' actions, and if-else statements.
  In this paper, we identify an alternative and simpler extensive-form game
model for cake-cutting protocols, that we call {\em branch choice} (BC)
protocols. We show that the class of protocols we can represent using this
model is invariant under certain modifications to its definition. We further
prove that any such protocol can be converted to a restricted form in which the
agents first cut the cake and then get to choose between various branches
leading to different allocations. Finally, we show that this model has the same
expressive power as GCC protocols, i.e. they represent the same class of
protocols up to a notion of equivalence involving the bounds on envy that each
agent can guarantee for themselves. For this purpose, we introduce a new notion
of envy-equivalence of protocols.","The cakecutting problem is a fair division problem which involves dividing a heterogeneous, divisible resource (the metaphorical “cake”) between several ag ents, who have diﬀerent pref erences over diﬀerent parts of the cake. In practice, this frame work can be used to divide various types of resources, such as land or time. The modern stud y of this problem dates back to Steinhaus [12] and a description of its history can be found in the books by Brams & Taylor [2] or Robertson & Webb [11]. ∗This paper is based on the second author’s ﬁnal year project. †Paul.Goldberg@cs.ox.ac.uk ‡iaruioana@gmail.com 1To be able to tackle this problem, we need to establish what it means fo r a division to be fair. There are two common criteria for fairness, proportionality , in which each of the nagents receives a piece that they consider to be worth at least1 nof the entire cake, and envyfreeness , which means no agent prefers the piece another agent received o ver their own. If the entire cake is allocated, envyfreeness implies proportionalit y. In the literature, wellknown cakecutting protocolsare often de scribed in plain language, but to be able to reason about protocols more generally or implement them on a computer, we require some formal model of computation. There are several such models, the most wellknown ones being the RobertsonWebb model [11], which involves two types of queries: Evalqueries, which ask an agent how much they value a given piece of cake , andCutqueries, in which an agent speciﬁes where a piece of cake should be cut to be wo rth a certain value, and the movingknives model (see, for example, Dubins & Spanier [8]) , in which a referee continuously moves one or more knives across the cake until one of the agents calls “stop”. More recently, Brˆ anzei et al.[5, 6] introduced a new model for cakecutting protocols, generalised cut and choose (GCC) protocols, in which rather than reporting their preference s to a referee, the agents divide the cake amongst themselves. In t he GCC model, a protocol is represented as a tree with cutnodes, in which an agent makes a cut inside one of a set of preexisting pieces of cake, choosenodes, in which an agent chooses from a set of existing pieces and is allocated that piece, and ifelse statements depending on the execution history of the protocol. In this paper, we propose an alternative model for representing c akecutting protocols as trees, branch choice (BC) protocols: at cutnodes, an agent makes a cut inside a given piece of cake, similarly to GCC protocols, but at choosenodes, an agent instead gets to choose which branch of the tree to proceed to. The resulting piece s are allocated to various agents at leaf nodes. Having such a simple, restrictive model is an ad vantage when it comes to automation, since making the diﬀerent possible choices and their o utcomes more explicit would make it easier for AI agents to participate in a protocol. We deﬁne various notions of equivalence between cakecutting pro tocols, based on the bounds on value/envy that an agent can guarantee for themselve s in the two protocols. We show that making various tweaks to the deﬁnition of BC protocols (such as considering protocols that can be represented as directed acyclic graphs rat her than trees, or allowing agents to make a cut within a sequence of pieces rather than a single piece), results in the same class of protocols, up to what we call strong envyequivalence . (Informally, an agent can guarantee the same bounds on their envy against the other ag ents in both protocols.) We then prove that any BC protocol can be put into a special form in which all the cut nodes come before the choose nodes, making it easier to reason ab out the structure of the protocol. Finally, we show that in fact BC protocols have the same ex pressive power as GCC protocols, and we look into how some classic cakecutting protocols can be represented as BC protocols. 1.1 Related Work "
394,Cloud-Based Approximate Constrained Shortest Distance Queries Over Encrypted Graphs With Privacy Protection.txt,"Constrained shortest distance (CSD) querying is one of the fundamental graph
query primitives, which finds the shortest distance from an origin to a
destination in a graph with a constraint that the total cost does not exceed a
given threshold. CSD querying has a wide range of applications, such as routing
in telecommunications and transportation. With an increasing prevalence of
cloud computing paradigm, graph owners desire to outsource their graphs to
cloud servers. In order to protect sensitive information, these graphs are
usually encrypted before being outsourced to the cloud. This, however, imposes
a great challenge to CSD querying over encrypted graphs. Since performing
constraint filtering is an intractable task, existing work mainly focuses on
unconstrained shortest distance queries. CSD querying over encrypted graphs
remains an open research problem. In this paper, we propose Connor, a novel
graph encryption scheme that enables approximate CSD querying. Connor is built
based on an efficient, tree-based ciphertext comparison protocol, and makes use
of symmetric-key primitives and the somewhat homomorphic encryption, making it
computationally efficient. Using Connor, a graph owner can first encrypt
privacy-sensitive graphs and then outsource them to the cloud server, achieving
the necessary privacy without losing the ability of querying. Extensive
experiments with real-world datasets demonstrate the effectiveness and
efficiency of the proposed graph encryption scheme.","REcent years have witnessed the prosperity of applications based on graphstructured data [1, 2], such as online social networks, road networks, web graphs [3], biological networks, and communication networks [4, 5]. Consequently, many systems for managing, querying, and analyzing massive graphs have been proposed in both academia (e.g., GraphLab This work was supported in part by the National Science Foundation of China under Grant 61602039, in part by the Beijing Natural Science Foundation under Grant 4164098, and in part by the China National Key Research and Development Program under Grant 2016YFB0800301. M. Shen, B. Ma, and L. Zhu are with Beijing Engineering Research Center of High V olume Language Information Processing and Cloud Computing Applications, School of Computer Science, Beijing Institute of Technology, Beijing, China. Email: fshenmeng, baolimasmile, liehuangz g@bit.edu.cn. Prof. Liehuang Zhu is the corresponding author. R. Mijumbi is with the Bell Labs CTO, Nokia, Dublin, Ireland. Email: rashid.mijumbi@nokia.com. X. Du is with the Department of Computer and Information Sciences, Temple University, Philadelphia, USA. Email: dxj@ieee.org. J. Hu is with the School of Engineering and IT, University of New South Wales (UNSW), Canberra, Australia. Email: J.Hu@adfa.edu.au.[6], Pregel [7] and TurboGraph [8]) and industry (e.g., Titan, DEX and GraphBase). With the prevalence of cloud comput ing, graph owners (e.g., enterprises and startups for graph based services) desire to outsource their graph databases to a cloud server, which raises a great concern regarding privacy. An intuitive way to enhance data privacy is encrypting graphs before outsourcing them to the cloud. This, however, usually comes at the price of inefﬁciency, because it is quite difﬁcult to perform operations over encrypted graphs. Shortest distance querying is one of the most fundamental graph operations, which ﬁnds the shortest distance, according to a speciﬁc criterion, for a given pair of source and destination in a graph. In practice, however, users may consider multiple criteria when performing shortest distance queries [2]. Taking the road network as an example, a user may want to know the shortest distance, in terms of travelling time, between two cities within a budget for total toll payment. This problem can be represented by a constrained shortest distance (CSD) query, which ﬁnds the shortest distance based on one criterion with one or more constraints on other criteria. In this paper, we focus on singleconstraint CSD queries. This is because most practical problems can be represented as a singleconstraint CSD query. For instance, such a query on a communication network could return the minimum cost from a starting node to a terminus node, with a threshold on routing delay. In addition, multiconstraint CSD queries can usually be decomposed into a group of subqueries, each of which can be abstracted as a singleconstraint CSD query. Formally, a CSD query1is such that: given an origin s, a destination t, and a cost constraint , ﬁnding the shortest distance between sand twhose total cost cdoes not exceed . Existing studies in this area can be roughly classiﬁed into two categories. The ﬁrst category mainly focuses on the CSD query problem over unencrypted graphs [2, 9–12]. However, these methods cannot be easily applied in the encrypted graph environment, because many operations on plain graphs required in these methods (e.g., addition, multiplication, and comparison) cannot be carried out successfully without a special design for encrypted graphs. The second category aims at enabling the shortest distance (or shortest path) queries over encrypted graphs [1, 13]. They usually adopt distance oracles such that the approximate distance between any two vertices 1For simplicity, we refer to singleconstraint CSD queries as CSD queries hereafter.arXiv:1809.07912v1  [cs.CR]  21 Sep 20182 can be efﬁciently computed, e.g., in a sublinear way. The main limitation of these approaches is that they are incapable of performing constraint ﬁltering over the cloudbased encrypted graphs. Therefore, they cannot be directly applied to answering CSD queries. Motivated by the limitations of existing schemes, our goal in this paper is to design a practical graph encryption scheme that enables CSD queries over encrypted graphs. As the CSD problem over plain graphs has been proved to be NPhard [10], existing studies (e.g., [2]) usually resort to approximate solutions, which guarantee that the resulting distance is no longer than times of the shortest distance (where is an approximation ratio predeﬁned by graph owners), subject to the cost constraint . The encryption of graphs would make the CSD problem even more complicated. Hence, we also focus on devising an approximate solution. Speciﬁcally, this paper presents Connor , a novel graph encryption scheme targeting the approximate CSD querying over encrypted graphs. Connor is built on a secure 2hop cover labeling index (2HCLI), which is a type of distance oracle such that the approximate distance between any two vertices in a graph can be efﬁciently computed [1, 2]. The vertices of the graph in the secure 2HCLI are encrypted by particular pseudorandom functions (PRFs). In order to protect real values of graph attributes while allowing for cost ﬁltering, we encrypt costs and distances (between pairs of vertices) by the orderrevealing encryption (ORE) [14, 15] and the somewhat homomorphic encryption (SWHE) [16], respectively. Based on the ORE, we design a simple but efﬁcient treebased ciphertexts comparison protocol, which can accelerate the constraint ﬁltering process on the cloud side. The main contributions of this paper are as follows. 1) We propose a novel graph encryption scheme, Connor , which enables the approximate CSD querying. It can answer an CSD query in milliseconds and thereby achieves computational efﬁciency. 2) We design a treebased ciphertexts comparison protocol, which helps us to determine the relationship of the sum of two integers and another integer over their ciphertexts with controlled disclosure. This protocol can also serve as a building block in other relevant application scenarios. 3) We present a thorough security analysis of Connor and demonstrate that it achieves the latest security deﬁnition named CQA2security [17]. We also implement a pro totype and conduct extensive experiments on realworld datasets. The evaluation results show the effectiveness and efﬁciency of the proposed scheme. To the best of our knowledge, this is the ﬁrst work that enables the approximate CSD querying over encrypted graphs. The rest of this paper is organized as follows. We summarize the related work in Section II and describe the background of the approximate CSD querying in Section III. We formally deﬁne the privacypreserving approximate CSD querying prob lem in Section IV. After that, the construction of Connor is presented in Section V, with a detailed description of the treebased ciphertexts comparison protocol in Section VI. We exhibit the complexity and security analyses in Section VII,evaluate the proposed scheme through extensive experiments in Section VIII, and conclude this paper in Section IX. II. R ELATED WORK "
353,Leaky Wires: Information Leakage and Covert Communication Between FPGA Long Wires.txt,"Field-Programmable Gate Arrays (FPGAs) are integrated circuits that implement
reconfigurable hardware. They are used in modern systems, creating specialized,
highly-optimized integrated circuits without the need to design and manufacture
dedicated chips. As the capacity of FPGAs grows, it is increasingly common for
designers to incorporate implementations of algorithms and protocols from a
range of third-party sources. The monolithic nature of FPGAs means that all
on-chip circuits, including third party black-box designs, must share common
on-chip infrastructure, such as routing resources. In this paper, we observe
that a ""long"" routing wire carrying a logical 1 reduces the propagation delay
of other adjacent but unconnected long wires in the FPGA interconnect, thereby
leaking information about its state. We exploit this effect and propose a
communication channel that can be used for both covert transmissions between
circuits, and for exfiltration of secrets from the chip. We show that the
effect is measurable for both static and dynamic signals, and that it can be
detected using very small on-board circuits. In our prototype, we are able to
correctly infer the logical state of an adjacent long wire over 99% of the
time, even without error correction, and for signals that are maintained for as
little as 82us. Using a Manchester encoding scheme, our channel bandwidth is as
high as 6kbps. We characterize the channel in detail and show that it is
measurable even when multiple competing circuits are present and can be
replicated on different generations and families of Xilinx devices (Virtex 5,
Virtex 6, and Artix 7). Finally, we propose countermeasures that can be
deployed by systems and tools designers to reduce the impact of this
information leakage.","The everincreasing size and sophistication of FPGAs make them an ideal platform for SystemonChip integration. FPGAs are often used in highbandwidth, lowlatency applications, providing func tionality such as network card replacement, or massively parallel computation. Besides permeating distributed systems and critical infrastructure, FPGA chips are also integrated in endproducts, rang ing from consumer electronics to medical and scientific equipment. As a result, protecting their security is a necessary step to ensure that their computations are performed in a trustworthy manner. The high cost of design and development has led to an increase in outsourcing, making it common to have designs from different contractors on the same FPGA chip. Such designs often include protocol and data structure implementations, or more sophisticated circuits, like radio frontends or soft processors. This practice raises concerns about the malicious inclusion of circuits (cores) that haveadditional backdoor functionality. The cores can be functionally validated before being included in the overall design, but such static analysis cannot always detect covert channels [ 10]. It is therefore important to identify and protect against such channels. In this paper, we show that the value driven onto certain types of FPGA routing resources, called “long” wires, influences the delay of nearby wires, even when the driven value remains constant . This distinguishes our approach from prior work which depends on fastchanging signals [ 8,12,35], and thus local voltage drops or inductive crosstalk. Specifically, we find that if a long wire carries a logical 1, the delay of nearby long lines will be slightly lower than when it carries a logical 0. This difference in delay allows cores sharing the same reconfigurable FPGA fabric to communicate, even when they are not directly connected. We demonstrate the phenomenon by building a transmitter and receiver, which are unconnected, and only use adjacent long wires to communicate. The receiver is a threestage Ring Oscillator (RO), whose routing uses a long wire between two of its stages. The transmitter drives a long wire adjacent to that of the RO. When the transmitting wire carries a logical 1, the routing delay of the RO long wire decreases, thereby increasing the RO frequency. We detect these minor frequency changes by counting the number of the RO signal transitions during a fixed time interval. This mechanism can be used either for covert communication, or for the exfiltration of fastchanging dynamic signals. We conduct extensive experiments on three Xilinx FPGA families and show that the phenomenon is independent of the device used, the location and orientation of the transmitter and receiver, and the pattern of transmission. We perform all tests on stock prototyping boards without modifications, and show that the phenomenon can be detected even in the presence of environmental noise and with only small circuits internal to the FPGA. Finally, we propose new defense mechanisms which can be implemented by systems and tools designers to reduce the impact of this information leakage. 2 BACKGROUND FieldProgrammable Gate Arrays (FPGAs) are integrated circuits that implement reconfigurable hardware. At a basic level, they consist of blocks of configurable lookup tables (LUTs), which can be used to represent the truth table of combinatorial functions. They also include registers to store data, as well as programmable routing, which determines how the LUTs and registers are interconnected. FPGAs can thus be used to represent all computable functions, including emulating sophisticated circuits such as entire CPUs. The Xilinx FPGAs used in our experiments internally have a grid layout, whose fundamental building block is called a Configurable Logic Block (CLB). It is composed of two slices , each of which con tains four LUTs and registers. Each CLB has an associated switchInformation Leakage and Covert Communication Between FPGA Long Wires ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea matrix , which contains resources to connect elements within a CLB, and enables CLBs to communicate with each other. There are multiple types of such communication wires, which have different orientations and lengths. In this paper we focus on a specific type of routing resource, called a long. Longs are a wire type used to efficiently communicate between CLBs that are far apart, and can bevertical (connecting elements with the same xcoordinate), or horizontal (same ycoordinate). We have observed the phenomenon in both types of wires, but for brevity we limit our discussion to vertical longs, or VLONG s. Due to the FPGA’s routing topology, ad ditional shorter wires are often needed to connect certain elements via long wires. We will refer to these wires as “local routing”. Usually, the details of how logic elements are placed and signals are routed are transparent to the circuit designers. Designers define their desired logic, but the conversion to a physical implementation is handled by the manufacturer tools. Compiler directives for the manual routing of signals are available, but these are often only used if the exact routing impacts functionality. In the absence of manual directives, the tools may elect to use any wire, including longs, to carry a given signal in the circuit, without alerting designers. That said, userdesigned circuits often share the FPGA with third party implementations of various protocols, data structures, and algorithms. These licensed designs, called Intellectual Property (IP) cores or blocks, often come in a prerouted blackbox format, to eliminate the variability of onthefly routing and attain a known clock frequency. As a result, the routing of these blocks is opaque to circuit designers, and blocks created by different parties can use routing resources in the same channel of long wires. As our paper shows, this use of nearby long wires can enable malicious circuits to communicate covertly, or extract information from other cores. Ring Oscillators (ROs) are a type of circuit which consists of an odd number of NOT gates, chained together in a ring formation (i.e., the output of the last gate is fed back as input to the first gate). ROs form a bistable loop, whose output oscillates between 1 and 0 (true and false). The frequency of oscillation depends on the number of stages in the RO, the delay between the stages, as well as voltage, temperature, and small variations in the manufacturing process [ 9]. ROs in FPGAs are used as temperature monitors [ 36], True Random Number Generators (TRNGs) [ 33], and Physically Unclonable Functions (PUFs)s [ 20], while in this paper we present a way to use them to detect the logic state of nearby wires. 3 SYSTEM AND ADVERSARY MODEL FPGA designs contain IP cores sourced from thirdparties, and some of these cores may contain unwanted functionality, as shown in Figure 1. These thirdparty IP cores can be distributed as fully specified, preplaced and prerouted elements (“macros”) to meet timing constraints (e.g., DDR controllers) and reduce compilation time, with the macro repositioned at specific intervals where the logic and routing fabric is selfsimilar [13, 15–17]. As FPGAs often process highlysensitive information (e.g., cryp tographic keys), it is essential to ensure that data does not leak to unauthorized thirdparties. In this paper, we focus on malicious IP cores which aim to infer information about the state of nearby (but physicallyunconnected) logic. The adversary can thus insert one or more IP cores into the design, but these cores are not directly Figure 1: System model. Different IP cores share common FPGA routing resources. The cores can be supplied by differ ent contractors and may contain malicious functionality. connected. The adversary can also define the internal placement and routing of his own blocks and force his cores to use specific routing resources that can compromise the integrity of a reverse engineered target IP block. Note that directly connecting to the target IP block would result in a logical error in the compilation flow, but merely using adjacent wires does not raise such errors. We discuss how the adversary can accomplish his goals in Section 3.2. The adversary does not have physical access to the board, and can thus not alter the environmental conditions or physically modify the FPGA board in any way. There is also no temperature control beyond the standard heatsink and fan already mounted on the FPGA, and we do not add any special voltage regulation, or shielding to the chip or the connected wires. Such modifications reduce noise and improve the stability of measurements [ 18,23,31,36], and would thus make it easier for the adversary to achieve his goals. In this paper, we show that by using long wires, an adversary can infer the nearby state of blocks he does not control, or establish covert communication between two cooperating IP cores under his control, even in the presence of power and temperature fluctuations. We provide further motivation and applications of the capabilities offered by this new source of information leakage in Section 3.1. 3.1 Motivation With increased outsourcing, Hardware Trojans (HTs) have become a commonplace security threat for FPGAs [ 7,32]. Adversarial IP cores can thus eavesdrop on nearby cores and attempt to extract information about their state. As designs are often tested to detect HTs and other security threats [ 12,18,35], we thus assume that the IP cores provide legitimate functionality that is needed by the user, and that they do not contain additional logic which would make them easy to detect. Indeed, the transmitter and receiver we present have dual use, hiding their malicious functionality in their routing, not their actual combinatorial and sequential logic. As a result, unlike conventional backdoors, our IP cores would pass timing/netlist/bitfile verification, since they do not require additional gates, presenting a bigger challenge to designers. Multiuser setups present further threats beyond a malicious core eavesdropping on signals not under the adversary’s control. Intel Xeon and other CPUs with integrated FPGAs bring FPGAs closer to a traditional server model, while FPGAs in cloud environments (e.g., Amazon EC2 F1 instances) are also becoming increasingly available.ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Ilias Giechaskiel, Kasper B. Rasmussen, and Ken Eguro Although these are currently allocated on a peruser basis, we can expect that they will eventually become sharable commodity resources, since FPGAs already allow for partial reconfiguration, and designs exist where different processors have access to and can reconfigure the same FPGA chip [29]. An additional threat arises when IP cores of different security guarantees are integrated on the same design [ 10,11,28]. For exam ple, an adversary implementing the FM radio core on a phone SoC would want to eavesdrop on the Trusted Platform Module’s (TPM) AES encryption operations to recover its key. As sensitive cores are highly scrutinized, an adversary who has also implemented the TPM would want to establish a covert channel to transfer the key using an inconspicuous transmitter. Finally, the same phenomenon can be exploited to watermark circuits [ 5,27], or introduce a nocontact debugging mechanism, for instance to detect stuck signals, without altering routing. 3.2 Influencing Placement and Routing A potential issue with preplaced and prerouted IP cores is that they are specific to an FPGA generation (but can be used in dif ferent devices within the same family). As we show in Section 7.2, however, the phenomenon we present persists across 3 generations of Xilinx chips. As a result, an adversary can provide an IP gener ation wizard that provides different routing for different families, and dynamically choose the placement of the IP cores. In fact, as we show in Section 8, the location of the actual logic and wires is not important, so the adversary merely needs to ensure that the transmitter and the receiver use long wires which are adjacent. If the adversary only preroutes but does not preplace his cores, he can still succeed, even if he leaves the absolute placement of his cores to the routing tools. Assume the FPGA has Nlong wires, the transmitted signal can be recovered from wnearby wires, the receiver uses Rlongs, and the transmitter uses Tlongs. Then, the probability that at least one segment of the transmitter is adjacent to a segment of the receiver is (R+T−1)·w/N, assuming the tools place the two cores at random. For the FPGA boards we have used, N≈8,500(equal to the number of CLBs) and w=4, so with R=T=5, an adversary has a 0.42% chance of success. Since tools do not pick locations at random or spread the logic, the probability of success is higher in practice. The adversary can also increase this probability by accessing relatively unique elements such as Block RAM (BRAM), DSP blocks, or embedded processors on the FPGA fabric. For example, the devices we used have less than 150 DSP slices and 300 BRAM blocks, so accessing them reduces the number of possible placements for the attacker’s cores. A more powerful adversary can instead subvert the compilation tools themselves, which is a common threat model for FPGAs [ 10, 14]. Note that, as before, since the final netlist itself is often veri fied postsynthesis and routing, the adversary still does not desire to include additional logic in the design, but just affect the rout ing/placement of his malicious cores. Finally, in colocated multi user instances, the adversary isthe user, so he can always choose the location of his own cores, without the need to rely on the above. 0 500 1000 1500 2000 Samplei2,208,2502,208,7502,209,2502,209,7502,210,2502,210,7502,211,250Ring Oscillator Count ci ∆µ= 1,279.84Transmitted Value 1 0Figure 2: Ring oscillator counts and 99% confidence intervals for a setup where transmitter and receiver use 5 longs each. The receiver is able to distinguish between signals using a simple threshold, despite noise from the environment. 4 CHANNEL OVERVIEW Our channel exploits the fact that the delay of long wires depends on the logical state of nearby wires, even when the signals they are carrying are static . We find that when the transmitting wire carries a 1, the delay of the nearby receiving wire is lower, which results in a higher number of ring oscillator (RO) counts. This is a distinct mechanism from prior research, which depends on the switching activity of nearby circuits, which decreases RO frequency [ 12,35], as we also independently verify in Section 6.3. This dependence on the logical state of the transmitter is shown in Figure 2. The red dots and blue x’s are RO counts when the transmitter wire carries a logical 1 or 0 respectively. The difference between the counts when transmitting 1s and 0s is clear, even under local fluctuations due to environmental and other conditions: even when the absolute frequencies of the ring oscillator change, the difference between the two frequencies remains the same. In order to characterize the efficacy and quality of the communi cation channel in detail, we perform a number of experiments, the setup of which is detailed in Section 5. We first show in Section 6 that the strength of the effect does not depend on the transmission pattern, by measuring the effect of an alternating sequence of 0s and 1s, as well as that of long runs of 0s and 1s, and of pseudorandom bits. We illustrate that even for fastchanging dynamic signals, an eavesdropping attacker can obtain the fraction of 1s and 0s, i.e., the Hamming weight on the transmitting wire. We then show that longer measurement periods and overlaps make it easier to distinguish between different bits in Section 7. The strength of the effect changes based on the receiver and transmitter lengths, and this dependence exists across generations of devices, but with a different magnitude. We also demonstrate that the abso lute location and orientation of the transmitter and receiver do not change the magnitude of the effect in Section 8. Finally, we show in Section 9 that the channel remains strong, even if significant computation is happening elsewhere on the de vice simultaneously, showing that the channel can be used in a realistic environment. We demonstrate that for the transmittedInformation Leakage and Covert Communication Between FPGA Long Wires ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea X Figure 3: Experimental setup. Transmitter and receiver use long wires to communicate, while the measurement setup generates signals and measures their effects. information to be detectable, the transmitter and receiver wires need to be adjacent, but where exactly and in what direction the overlap occurs is not significant. This indicates that it may be dif ficult for designers to protect themselves from eavesdropping, or detect intentional malicious transmissions. Overall, we show that the channel is stable across FPGA gen erations, devices, and locations within a device. It is also high bandwidth, and can be used to implement both covert communi cations and eavesdropping attacks, without tapping into existing signals, and with minimal resources, as we explain in Section 10. 5 EXPERIMENTAL SETUP In order to test the properties identified in Section 4, we need to determine the factors we wish to vary, keeping the rest of the setup fixed. This distinction naturally divides our experimental setup into two parts, as shown in Figure 3. The communication channel circuit contains just the transmitter and the Ring Oscillator receiver. The measurement half works independently of any specific channel implementation, generating the transmitted signal, sampling the RO counter, and transferring the data to a PC for analysis. The bulk of our experiments are conducted on three Virtex 5 XUPV5LX110T (ML509) evaluations boards. The boards include a heatsink and a fan, but we do not otherwise control for temperature, and we also do not modify the board in any way (e.g., by bypassing the voltage regulator) in accordance with our threat model. Each experiment is run on every device 5 times, collecting 2048 data points per run, and results are reported at the 99% confidence level. 5.1 Transmitter and Receiver To illustrate the information leakage, our setup employs a minimal transmitting circuit: the transmitter consists of a buffer LUT that drives one or more longwire segments connected endtoend. We use the term transmitter for brevity and because in the controlled experiments we choose the value on the long wire, but the conclu sions we draw are valid whether transmissions are intentional or not. The receiving circuit also uses long wires that are adjacent to the transmitter’s wire segments. To measure the delay of the re ceiver’s long wire segment(s), we include it as part of a threestage ring oscillator. As in [ 31], the oscillator contains one inverter (NOT gate) and two buffer stages. The wire’s delay directly influences thefrequency of oscillation, which we estimate by feeding the output of one of the RO stages to a counter in our measurement setup. The receiver and the transmitter are initially on fixed locations of the device, but we change the location in Section 8 to show that it does not influence our measurements. We also change their lengths in Section 7.2 to show that the effect becomes more pronounced the longer the overlap is. 5.2 Measurement Setup The measurement component generates the signals to be transmit ted and measures the RO frequency. A new trigger event is produced every N=2nclock ticks. At every trigger, the RO counter is read and reset, and a new value is presented to the transmitter. For most experiments, the signal generator simply alternates between 0s and 1s, but we change the pattern in Section 6 to show the general ity of the channel. The 100MHz system clock is driven by a Digital Clock Manager (DCM) to ensure clock quality. For the majority of our experiments, we fix n=21(corresponding to 221clock ticks, or 21ms), but vary nin Section 7.1 to explore the accuracy vs. time tradeoffs. The sampled data is transferred to a PC for analysis through Xilinx’s ChipScope Integrated Logic Analyzer (ILA) core. Unlike the circuit described above, the measurement logic is not handplaced or handrouted, due to the large number of experi ments performed. Although the measurement logic could influence the RO frequency [ 22], we repeat our experiments on multiple locations, control for other patterns, and average over relatively lengthy periods of time. Thus, we believe that any effects of the measurement circuitry would influence the transmission of both zeros and ones equally, a hypothesis we confirm in Section 9 by observing that the channel is only affected by adjacent wires. 5.3 Relative Count Difference When a clock of frequency fCLK is sampled every mticks and a ring oscillator of frequency fROdriving a counter measures cticks, then fRO/fCLK≈c/m, with an appropriate quantization error due to the unsynchronized nature of the RO and the system clock. Thus, f1 RO−f0 RO f1 RO≈C1−C0 C1(1) where Ciand firepresent the count and respective frequency when the transmitter has value i. As a result, the relative change of frequency can be approximated just by the measured counts, irrespective of the measurement and clock periods. In the basic setup, the transmitter alternates between sending zeros and ones. We denote the ith sampled count as ci, so the pair pi=(ci,ci−1)always corresponds to different transmitted values. For the sake of notation clarity, we will assume that c2i+1 corresponds to a transmitted 1and we will be using the quantity ∆RCi=c2i+1−c2i c2i+1 to indicate the relative frequency change between a transmitted one and zero. ∆RCwill denote the average of ∆RCiover all measure ment pairs i. We discuss different transmission patterns in Section 6 and how to exploit the measurements in Section 10.ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Ilias Giechaskiel, Kasper B. Rasmussen, and Ken Eguro d0 d1 d2 d3 d4 d5 Clock Alternating Long Runs Random Dynamic Figure 4: Timing diagram for the various transmission patterns used in the experiments. We test patterns which remain constant within a measurement period ( Alternatin д,LonдRuns,Random ), and fastchanging patterns ( Dynamic ). 0 250 500 0 250 500 0 250 500 Samplei3,339,0003,339,5003,340,0003,340,5003,341,0003,341,5003,342,0003,342,500Ring Oscillator Count ci ∆µ= 1,202.19∆µ= 1,278.85 ∆µ= 1,233.50Alternating Long Runs Random Transmitted Value 1 0 (a) Example run Device 0 Device 1 Device 202004006008001,0001,200Absolute Count Diﬀerence ∆CTransmission Pattern Alternating Long Runs Random (b) Comparison across devices Figure 5: Effect of different static transmission patterns: (a) is a visualization of three different patterns: Alternatin д(left), LonдRuns (middle), and Random (right). (b) is a comparison across devices, with 99% confidence intervals. The magnitude of the effect does not depend on the pattern used. 6 TRANSMITTER PATTERNS In this section we show that the phenomenon observed does not fundamentally depend upon the pattern of transmissions, i.e., that only the values carried by the wire during the period of measure ment matter, and not the values that precede or follow it. We first show this for relatively constant signals (Section 6.1), and then for highly dynamic ones (Section 6.2). Finally, we compare our re sults to those produced by switching activity, which is traditionally discussed in the context of Hardware Trojan detection (Section 6.3). 6.1 Constant Signals In the default setup, we use a slowly alternating signal, where the transmitted value changes every sampling period. This pattern is denoted by Alternatin дin Figure 4. In this experiment, the trans mitted value still remains constant within a given measurement period, and we sample the ring oscillator at the same default rate (every 21ms), but change how the signal generator chooses the next value to be transmitted. The first additional pattern we test greatly slows down the alternation speed of the transmitted signal. This LonдRuns pattern maintains the same value for 128 consecutive triggers—in essence, testing the effects of long sequences of zeros and ones. The second setup employs a Linear Feedback Shift Reg ister, which produces a pseudorandom pattern of zeros and ones, and is denoted by Random in Figure 4. The results of this test are shown in Figure 5, with a sample of the data in Figure 5a, and a comparison across devices in Figure 5b.The RO counts remain significantly higher when transmitting a 1 versus a 0, and the average count difference remains identical, with almost no variability among the patterns. We deduce that the pattern of transmission has no persistent effect on the delay of nearby wires, allowing the channel to be used without having to ensure a balanced distribution of transmitted values. 6.2 Dynamic Patterns To show that the dominating factor in the observed phenomenon is the duration for which the transmitter remains at a logical 1, and notthe switching activity of the circuit, we try various dynamic patterns. As a result, even if a signal is not sufficiently longlived, the attacker can still deduce the signal’s Hamming Weight (HW), and thus eavesdrop on signals he does not control. We explain in Section 10.2 how to use this property to recover cryptographic keys through repeated measurements. The dynamic patterns used are denoted by Dynamic in the timing diagram of Figure 4. During each sampling period, we loop the transmitter quickly through a 4bit pattern at 100MHz. We test six different 4bit patterns, only updating the looped pattern at each new sampling period. For example, for the pattern 1100 ( d2in Figure 4), the transmitter would stay high for two 100 MHz clock ticks, then low for two clock ticks, then back to high for 2 ticks, etc., until the end of the sampling period. The six 4bit patterns used are:d0=0000 ,d1=1000 ,d2=1100 ,d3=1010 ,d4=1110 , and d5=1111. These patterns respectively have a HW of 0,25,50,50,Information Leakage and Covert Communication Between FPGA Long Wires ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Dynamic Patterns (Long Wire Transmitter)3,397,8003,398,0003,398,2003,398,4003,398,6003,398,800Absolute Ring Oscillator CountHamming Weight, Switching Frequency d0(0%,0) d1(25%,f) d2(50%,f) d3(50%,2f) d4(75%,f) d5(100%,0) Figure 6: Effect of dynamic switching activity using a long wire transmitter. RO counts increase with the Hamming Weight, but not with the switching frequency. 75, and 100%, while their switching frequencies are 0,f=fCLK/8, f,2f,f, and 0respectively. Figure 6 shows the average count Ciof the ring oscillator for each of pattern di. We see that the RO frequency increases with the Hamming Weight, so that C0<C1<C2≈C3<C4<C5. However, the frequency is otherwise unaffected by the switching transmission activity: the KolmogorovSmirnov test suggests that there is no statistically significant difference between the two distributions ford2andd3. Note that the receiver would not able to distinguish between patterns d2andd3as a result (or more generally, any patterns with the same Hamming Weight), but we explain how to overcome this limitation in Section 10.2. 6.3 Local Routing In this section, we show that when the two circuits do not have overlapping long wires, switching activity decreases the oscillation frequency of the RO. This reproduces the results reported by prior research on Hardware Trojan detection [ 12,35] and also allows us to sanitycheck our measurement setup. To test this dependence on the long wire overlap, we remove the transmitter using long wires, and replace it with a buffer of 312consecutive LUTs packed into 39CLBs, using only local intra and interCLB routing. We then drive the same 6 dynamic patterns from Section 6.2 through the buffer, and measure the results in Figure 7. We can clearly see that the ordering of the patterns exactly mirrors their relative switching activity, with the RO counts Cicorresponding to didecreasing with increased switching activity: C3<C1≈C2≈C4<C0<C5. The difference between the patterns with the same switching activity d1,d2,d4is not significant according to the KolmogorovSmirnov test, but the count is slightly higher for d5compared to d0, which have no switching activity. This suggests that the phenomenon we have identified and which reduces delay may be present for shorter wires as well, but is considerably weaker, and requires much bigger circuits. Overall, we can conclude that when the transmitter does not use longs which overlap with the receiver and generates a lot of switching activity through multiple redundant buffers, then the observed RO frequency is indeed reduced, reproducing the results of prior work. Dynamic Patterns (Local Routing)3,402,9003,403,0003,403,1003,403,2003,403,300Absolute Ring Oscillator CountHamming Weight, Switching Frequency d0(0%,0) d1(25%,f) d2(50%,f) d3(50%,2f) d4(75%,f) d5(100%,0)Figure 7: Effect of dynamic switching activity without long wire overlaps. RO counts decrease with switching frequency, and are almost unaffected by the Hamming Weight. 81.9µs 327.7µs 1.3ms 5.2ms 21.0ms 83.9ms Measurement Time101102103∆C 81.9µs 327.7µs 1.3ms 5.2ms 21.0ms 83.9ms Measurement Time3.23.43.6∆RC×10−4 Figure 8: Absolute and relative count differences and 99% confidence intervals for various measurement times. For a given transmitter and receiver overlap, the absolute magni tude of the effect increases linearly with time. 7 MEASUREMENT PARAMETERS In this section, we discuss the tradeoffs between the quality of the channel and the measurement time (Section 7.1), and length of overlap between receiver and transmitter (Section 7.2). 7.1 Measurement Time In this experiment, we return to the alternating pattern shown in Figure 4, and vary the measurement time by repeatedly quadru pling it. Both the absolute and the relative count difference for the various times are shown in Figure 8. In the top of the figure, we see that the absolute count difference ∆Cgrows linearly with increasing measurement time. Hence, the RO count differences can be amplified, proportionally to the duration of the measurement. The relative differences ∆RC(shown in the bottom of Figure 8) remain approximately constant for measurement periods above 1ms, in accordance with our theoretical prediction of Equation (1). The values for shorter measurement periods are still close, but are far noisier: for short measurement periods, the absolute differ ence is small (≈4fort=82µs), increasing quantization errors, andASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Ilias Giechaskiel, Kasper B. Rasmussen, and Ken Eguro 0 1 2 3 4 5 Number of Transmitter Longs vt0123456Relative Count Difference ∆RC×10−4 # Receiver Longs vr 1 3 2 3 1 23 4 5 (a) Virtex 5 0 1 2 3 4 Number of Transmitter Longs vt0123456789Relative Count Difference ∆RC×10−5 # Receiver Longs vr 1 2 1 2 3 4 (b) Virtex 6 0 1 2 3 4 5 6 7 8 9 10 Number of Transmitter Longs vt0.00.51.01.52.02.5Relative Count Difference ∆RC×10−4 # Receiver Longs vr 1 2 3 45 6 7 8 9 10 (c) Artix 7 Figure 9: Relative frequency changes ∆RCwith 99% confidence intervals as a function of the transmitter and receiver lengths for different FPGA generations. The count difference is proportional to the overlap between the transmitter and the receiver. making it harder to distinguish between signal and noise. These results indicate that for a given receiver/transmitter placement, the absolute magnitude of the effect depends solely on measurement time, with longer measurement periods making it easier to distin guish between signals and noise. An adversary can thus choose the measurement time, trading throughput for lower bit error rate. 7.2 Wire Length We also characterize the effect of varying the length (number) of transmitter and receiver wires vtandvrin three generations of devices. Besides the Virtex 5 device we have been using so far, we also measure the effect on a Virtex 6 ML605 and on an Artix 7 Nexys 4. The relative change in frequency ∆RCis shown for different combinations of vtandvrin Figure 9, for one device per generation. We notice the same common pattern for all 3 generations of devices. For a given number of long wires vrused by the ring oscillator, there are 3 distinct segments for ∆RCas the number of transmitter longs vtincreases. The first segment occurs for transmitters which use only parts of a long. Using partial wires is possible because even though VLONG s can only be driven from the top or the bottom, they have additional intermediate “taps” which can be used to read the values of the signal they carry. In practice, using partial wires does not have an effect on the strength of the phenomenon: ∆RC remains constant for all fractions of a long. This result is to be expected since, electrically, the entire long wire is driven even if the output tap does not take full advantage of its length. The second segment is the region where vt≤vr. Here, ∆RC increases linearly with vt, suggesting that the phenomenon affects the delay of each long wire equally. The final region consists of vt>vr, where ∆RCremains constant. The reason for this pattern is that there is no additional overlap between the newly added segments of the transmitter and the receiver. We also identify the effect of a given number of transmitter wires vton receivers using a different number of longs vr. Among receivers with vr≥vt, a smaller vrresults in a larger effect. As an example, for vt=3, the effect for vr=5is smaller than it is for vr=3. This behavior is due to the transmitter affecting only the first vtout of vrlong wire segments of the ring oscillator.For smaller ring oscillators, these vtsegments represent a larger portion of the number of wires used, and hence of overall delay. The opposite is true when vr≤vt: the larger the RO, the bigger the resulting effect. For instance, for vt=4, the effect for vr=3 is larger than the effect for vr=1. This difference exists because even though the delay of the routing scales linearly, the delay associated with the inverter and buffer LUT stages remains constant. Thus, the routing delay represents a larger fraction of the overall delay (routing delay plus stage delay) for larger ROs. Since this phenomenon only acts on routing delay, larger ROs are affected more than shorter ones. 8 LOCATION INDEPENDENCE In order to validate the location independence of the channel, we test three different aspects of the placement of the receiver and transmitter on: the absolute location on the device, the relative offset of the receiver and transmitter, as well as the direction of signal propagation. Figure 10 shows the results for all three experiments on the Virtex 5 devices, with 99% confidence intervals. At a high level, the effect remains approximately constant for each device regardless of the choice of parameters. Across devices, the absolute magnitude of the effect varies slightly, but is otherwise almost the same. Any variability across devices is to be expected, since manufacturing variations are known to affect ring oscillator frequencies [9]. Figure 10a shows the results when an identical circuit is placed on different locations of the device: the four corners (bottom/top left/right) and the center. Both transmitter and receiver use 2 longs each, and they are adjacent: when the receiver’s location is (xr,yr), the transmitter’s location is (xt,yt)=(xr,yr−1). Within a device, the values are close, and there is no pattern in how the values change between devices. Manufacturing variations within and between devices can thus explain any variability. The second experiment investigates the effect of the placement of the receiver and the transmitter relative to each other. When the receiver and transmitter have different lengths, it is possible for the two circuits to have the same overlap, but a different starting offset. This relative offset or(visually shown in Figure 11) also has minimal effect on the channel. To test this hypothesis, we place a transmitter made up of 5 longs at a fixed location on the device. TheInformation Leakage and Covert Communication Between FPGA Long Wires ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Device 0 Device 1 Device 20123Relative Count Diﬀerence ∆RC×10−4Absolute Locations on Device BL BR C TL TR (a) Absolute Location Device 0 Device 1 Device 20123Relative Count Diﬀerence ∆RC×10−4Receiver/Transmitter Oﬀset or(# Longs) 0 1 2 3 (b) Relative Offset or Device 0 Device 1 Device 20123Relative Count Diﬀerence ∆RC×10−4Receiver/Transmitter Orientations ↓↓↓↑↑↓↑↑ (c) Direction of Propagation Figure 10: Effect of location on the relative frequency of oscillation, with 99% confidence intervals for different placements of the circuit on the device. Absolute location, offset, and signal orientation have little influence on the magnitude of the effect. Figure 11: Relative placement of longs for transmitter and receiver, with respect to distance dand receiver offset or. receiver, which uses 2 longs, is placed adjacent to the transmitter, but at an offset of orfull long wires, allowing for four different offset placements. This offset needs to correspond to full long wire lengths due to constraints imposed by the routing architecture of the device. Any other offset would increase the distance dbetween the transmitter and receiver, which we investigate separately in Section 9. Figure 10b presents the results of this experiment, which show approximately the same consistency both within and between devices as those of the previous experiment. Note that the relative effect of placing the receiver at various offsets forms a consistent pattern across devices. As an example, the effect for an offset or=3is consistently stronger than it is for or=1. This pattern can be explained by the FPGA routing layout: as mentioned in Section 2, the local routing used to get to the various long wire segments is different between each test. Because the local routing resources differ, the ratio between the delay incurred by the long wire segments and the local routing resources changes. As will be discussed in Section 9, while the delay of the long wire segments is affected by the transmitter, the local routing is not. Using the same setup, and with an offset of or=2full long wires, we change the direction of signal propagation for the transmitter and receiver. In the previous experiments, both signals travelled from the bottom of the device to the top. However, in the Virtex 5 architecture, VLONG wires are bidirectional, and can thus propa gate signals upwards or downwards. Figure 10c shows the results for the 4 different orientations (receiver and transmitter down, re ceiver down/transmitter up, etc.). The relative count difference is Device 0 Device 1 Device 20123Relative Count Diﬀerence ∆RC×10−4Distance between Transmitter and Receiver 1 2 3 4 5Figure 12: Effect of the transmitterreceiver distance. Long wires leak information up to two wires away. Distance is de fined as in Figure 11. approximately the same for all configurations, although as with the previous experiment, we notice a consistent ordering for the four transmission directions across devices. Similar to the earlier experiment, this pattern can also be explained by the routing layout. The results of this section illustrate that only the long wires need to be manually specified, while the registers, LUTs, and local routing can be autoplaced/routed, further reducing the attack complexity. 9 RESILIENCE TO COUNTERMEASURES Although we discuss defense mechanisms in more depth in Sec tion 11, in this section we evaluate how close to the transmitter a receiver would have to be in order to decode a message. We do this by varying the distance d(depicted in Figure 11) between the transmitter and the receiver. The results are shown in Figure 12. We see that the phenomenon is still measurable when separating the wires by a distance of d=2, but the effect is 20times weaker. When the wires are farther apart ( d≥3), there is no correlation between the transmitted and received values, i.e., the data comes from the same distribution according to the KolmogorovSmirnov test ( p>0.75). In other words, any defensive monitoring must be routed within a distance of two to detect a transmission throughASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Ilias Giechaskiel, Kasper B. Rasmussen, and Ken Eguro Device 3 (Artix 7) Device 4 (Artix 7)0.00.51.01.52.0Relative Count Diﬀerence ∆RC×10−4LFSR/Adder Clock Frequency None 5Hz95Hz 3kHz781kHz 50MHz Figure 13: Effect of activity induced by adders and LFSRs at different clock frequencies. The additional activity has very little impact on channel quality. the channel, and occupy all 4 wires adjacent to a signal in order to prevent a channel from operating successfully. To test whether an active protection mechanism can disrupt the channel through additional dynamic activity on the device, we measure the strength of the channel in the presence of large, competing circuits which are both in and outofsync with respect to the transmissions. We synthesize 2 large 4096bit adders, adding different parts of a bitstream produced by a Linear Feedback Shift Register (LFSR). As a result, both the addends and the sums change every time the LFSR produces a new bit. The bits of each sum are then XORed together and drive 2 LEDs for additional current draw. We run the experiment on two Artix 7 Nexys 4 boards, for a transmitter and receiver using 10 longs each. In order to test transmission and reception under surrounding activity of different switching frequencies, we vary how often the LFSR produces new values by dividing the clock driving it by 2m, form∈{1,7,15,20,24}, giving us frequencies of 5Hz – 50MHz. The results for the two devices, including the base case of no adders and LFSRs, are summarized in Figure 13, showing that additional activity cannot disrupt the transmissions. However, we note some correlation between the frequency of the activity and the corre sponding count difference. The resulting change is not sufficient to hinder transmission, but can be used by the adversary to detect the level of activity on the device, a technique already used by Hardware Trojan detectors [12, 35]. 10 EXPLOITING THE LEAKAGE In this section we discuss exploiting the information leakage from a theoretical perspective. In some cases (such as that of Figure 2), a threshold is sufficient for distinguishing between 0s and 1s, but in other setups (such as that of Figure 5), this separation might not be as clear: the RO frequency may drift due to changes in environ mental conditions, such as temperature and voltage variation. We first detail an encoding scheme that enables highbandwidth covert transmissions (Section 10.1), and then explain how to eavesdrop on dynamic signals through repeated measurements (Section 10.2).10.1 Covert Transmissions To overcome the hurdle posed by local fluctuations, we propose a Manchester encoding scheme, where 0s are transmitted as the pair(0,1), and 1s as the pair (1,0). Since every pair contains each bit once, one can decode the received pair (c0,c1)as a 0 if c0<c1 and as a 1 otherwise. Using this scheme, transmissions lasting 82µs using 2 longs as well as transmissions lasting 21msusing1 3of a long are both recovered with accuracies of 99.0 – 99.9%, without employing any error correction algorithms. Under this encoding scheme, the bandwidth of the channel is 1/(2·82·10−6)=6.1kbps . To further distinguish between noise and legitimate transmis sions, we can introduce Nbit start and endofframe patterns. Assuming that the probability that c0<c1when no transmission is taking place is 1/2(i.e., each measurement is equally likely to be in terpreted as a 0 or a 1), then the probability that noise is interpreted as a startofframe when no transmission is taking place is 2−N. As the channel is resilient to noise (also see Section 9), noise will not accidentally end a transmission early or introduce additional errors while a transmission is taking place. Ncan thus be chosen based on the desired application guarantees, which can include additional checksums for error detection and correction. In partic ular, line codes such as 8b/10b provide singlebit errordetection capabilities, and aid in clock recovery, making them ideal for such an application. The bandwidth of the channel is then reduced to 6.1×8/10≈4.9kbps . 10.2 Signal Exfiltration If an adversary is merely eavesdropping on nearby signals, it is unlikely that they will remain constant throughout the period of measurement. However, as shown in Section 6.2 (Figure 6), the delay of the long wire depends only on the proportion of time for which the nearby wire is carrying a 1, and notits switching frequency. This fact reveals the Hamming Weight of the transmission during the measurement period. By repeating measurements with a slid ing window, an eavesdropping adversary can fully recover nearby dynamic signals such as cryptographic keys with high probability. Suppose the adversary wishes to recover an Nbit key K, and assume that in one period of measurement, the long wire carries wconsecutive bits of the key. We assume initially that N=nwis an integer multiple of the measuring window w, and explain how to remove this assumption in Appendix A. By making repeated measurements of different but overlapping windows, as shown in Figure 14, the adversary can recover the key with high probability. Specifically, assume the Hamming weight (measured by the RO count) of the first wkey bits K0toKw−1(window W0) isc0, and that the Hamming weight of bits K1through Kw(window W1) is c1. Then, if c0≈c1(within some devicedependent tolerance), we can conclude that K0=Kw. Ifc0>c1then K0=1andKw=0, while if c0<c1then K0=0andKw=1. By comparing the next count c2toc1, one can determine the values of K1andKw+1, and, more generally, by repeating this process, one can determine the relationship between KiandKi+w. Assuming a randomly generated key, the probability that Ki= Kjfori,jis1/2. The probability that all of Sr=(Kr,Kw+r, ..., K(n−1)w+r)are equal is 1/2n−1, since there are n−1such pairs. The probability that at least one of the bits in Sris different than theInformation Leakage and Covert Communication Between FPGA Long Wires ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Figure 14: A sliding window of width wcan determine the relationship between key bits KiandKi+w. ●●●●●● ● ● ● ● ● ● ● ● ● ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● 0.000.250.500.751.00 0 10 20 30 40 50 Window size (w)ProbabilityKey Size (N) ●N64 N128 N264 Figure 15: Probability of recovering all Nbits of a key based on the window size w. Smaller window sizes and longer keys yield a better chance to fully recover the key. rest is thus 1−1/2n−1. If at least one is different, we can recover all of these bits. Repeating this argument for all possible remainders 0≤r<w, the probability of recovering the entire key is P= 1−1 2n−1w ≥1−w 2n−1(2) by Bernoulli’s inequality. Even if it might appear counter intuitive, the expression shows that longer keys are easier to recover than short keys. A larger window size wrelative to the key length makes recovering the key harder as there are fewer measurements over the length of the key. For the same reason, a longer key will increase the recovery probability. This means that asymmetric keys, e.g., those used for signature verification are relatively easy to recover, as they are typically much longer than symmetric keys. Figure 15 shows the probability of successfully recovering allN bits of a key as a function of the window size w. A window of 10 bits can fully recover a key of size 64 with 78% probability, while a 30bit window can recover a 264bit key with 87% probability. Figure 15 only shows the probability for full recovery, i.e., if all but one bit is recovered we still consider it a failure. However, the above procedure can still reveal a lot about the key, even when it does not recover it fully: in the worst case (if the entire key consists of a repetition of its first wbits), our approach reduces the guessing space from 2Nto2wpossibilities. Extending the procedure to use multiple window lengths, we can recover any key pattern with probability 1, except for when all key bits are the same (i.e., all ones or all zeroes). This full recovery can be achieved using a total of just 2w+1full passes over the key. Appendix A gives an expression for the exact probability of full key recovery for both single and multiple window sizes.11 DISCUSSION We structure our discussion in three parts: the channel itself (Sec tion 11.1), the cause of the information leakage (Section 11.2), and potential defenses (Section 11.3). 11.1 The Channel The channel characterized in the previous sections does not require any modifications to the device or special tooling, allowing an adversary to distribute it as IP blocks. The only routing that needs to be specified is the use of the long wires, and the only placement constraint is that the receiver and transmitter longs are adjacent. The channel requires very little logic: the entire setup including the signal generation and measurement portions uses just 71 lookup tables (LUTs) and 66 registers, excluding resources taken up by ChipScope to transfer the measurements to a PC for analysis. As an example, our channel would only use 0.2% of the 33,000 LUTs used in the opensource N200/N210 Universal Software Radio Peripheral (USRP) softwaredefined radio project [25]. The USRP source codebase [ 26] illustrates how IP from different organizations makes it into a project: USRP uses code from Ettus Research, Xilinx, Easics NV, and OpenCores (written by different authors). Since thirdparty code is a necessity, and as modern IP blocks can be quite large, the potential for unintended interaction between different cores increases. An adversary can exploit the routing algorithms, which are forced to route through otherwise monolithic blackbox IPs due to resource constraints, enabling his blocks to communicate covertly or eavesdrop on nearby signals. As ring oscillators have legitimate uses, from thermal and de vice health monitors [ 6,36] to Hardware Trojan detectors [ 12,35], TRNGs [ 33], and PUFs [ 20], the adversary can make dualuse trans mitters and receivers. The channel we identify exists whether trans missions are intentional or not, and is a threat when an adversary controls one or more IP cores. Unintentional transmissions pose new risks for multiuser scenarios, including FPGA/CPU hybrids and cloud infrastructures offering FPGA solutions. In these setups, an adversarial receiver can be placed next to long wires used by other thirdparty vendors and eavesdrop on the signals carried by them. The same mechanism can also be used for legitimate purposes such as watermarks and nocontact debugging taps. 11.2 Leakage Cause So far, we have focused on the novelty and applicability of the phenomenon presented, rather than its cause. In Section 6.3, we showed that the phenomenon depends on the use of the long wires, and not the switching activity of circuits, which decreases rather than increases ring oscillator frequency. The only other work which deals with long wires delays is [ 8], where a RO with a long wire was placed next to other long wires carrying signals which where either equal to the RO signal or opposing it. It was shown that when a nearby long wire has the same value as the RO wire, the frequency of the RO is higher compared to the RO frequency when the nearby long wire has the opposite value (i.e., if the current value on the RO long wire is a 1, the value on the nearby wire is 0 and vice versa). The work in [ 8] necessitates that the signal of the RO and the nearby wire be in sync, so the wires were directly connected, and static patterns which are independent of the RO signal were notASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea Ilias Giechaskiel, Kasper B. Rasmussen, and Ken Eguro tested. By contrast, in our work, we showed that nearby wires are influenced even when there is no connection between the transmit ter and the receiver, and even when the transmitted value remains constant during the measurement period. These two properties can be exploited in constructing a communication channel. Although [ 8] broadly categorized their observations as “capaci tive crosstalk”, it made no attempt to precisely determine the phys ical cause behind it. This would indeed be difficult without design information such as physical layout and processspecific parame ters. This “lack of electrical detail” on FPGAs is, in fact, wellknown and has been identified by multiple authors [1, 2, 24, 30, 34]. As a result, whether the effect we have found exists due to drive strength issues, electromagnetic emissions, or some other property of FPGAs remains an open question. It is even possible that the wires themselves might not be the cause of the issue, but that the buffers driving them share local connections to the power network. However, without more specialized equipment to xray the chips to further narrow down the potential causes, we cannot determine the precise cause, or even whether ASICs would be affected. Overall, the characterization of the channel is valuable even without access to these details, since we have shown it to always be present and easily measurable on offtheshelf devices without spe cial modifications. FPGA users cannot alter the electrical behavior of the device, but can only influence how circuits are mapped onto the FPGA. As a result, FPGA circuit designers cannot change the ex istence of the channel, and need to be aware of the communication and exfiltration capabilities that this channel introduces. 11.3 Defense Mechanisms Section 9 showed that one cannot detect transmissions from a distance d≥2, and that spurious activity (in the form of adders and additional current draw) does not eliminate the transmission channel. Hence, defense mechanisms need to protect a design before it is loaded onto the FPGA. Since long wires are an integral part of the reconfigurable FPGA fabric, detecting the transmitter is not easy: the long can be used as part of the connections within an IP block, carrying sensitive information. Routing algorithms thus need to be modified to account for this information leakage, by introducing directives which mark signals, or even entire blocks as sensitive. The tools then need to add “guard wires”, by either leaving the four nearby long wires unoccupied, or by occupying them with compilergenerated random signals. We note that even though this approach will prevent the leakage from occurring, it is particularly taxing for dense designs, and can make placement and routing more timeconsuming, or even lead to timing violations. Designers using unpatched tools need to be aware of this source of leakage, and must either manually look for longwires post routing, explicitly add guard wires, or, more generally, specify place ment and routing constraints for both highlysensitive signals, and untrusted thirdparty blocks. Overall, better defense mechanisms for future FPGA generations are needed at the architectural level, and require a deeper understanding of the cause of this phenome non.12 RELATED WORK "
254,Towards a Methodology for the Development of Routing Algorithms in Opportunistic Networks.txt,"This paper introduces a methodology for the development of routing algorithms
that takes into consideration opportunistic networking. The proposal focus on
the rationale behind the methodology, and highlights its most important stages
and components. It also discusses the importance of two core elements in the
process of protocol designing: the scenario selection, based on essential
characteristics, and the choice of standard evaluation metrics. As of now,
there has been no common methodology for developing new routing algorithms, and
this has led to proposals difficult to compare, to evaluate, and lacking a
rigorous objectivity ensuring fairness. Thus, there is the urgent need to
propose, agree, and use a common methodology for the development of routing
algorithms.","The efﬁciency and performance of a network depends completely on the routing algorithm. Nodes can be sparsely or densely distributed, there can be few or many messages, node buffers can be small or large, but at the end of the day, the responsibility of forwarding all messages from the source to the destination in the best way possible lies with the routing algorithm. Thus, the development of such protocols is of paramount importance for the sake of networks in general, and specially critical in challenged networks like opportunistic ones. In these last type of networks, nodes are irregularly distributed, not always accessible and message forwarding is only possible when there is a transient contact opportunity. In these conditions, the store, carry and forward strategy of Delay Tolerant Networking helps connecting the unconnected parts of the net. Unfortunately, the process of developing new routing algo rithms has not been in the focus of research, and this has led to disputable quality proposals, difﬁcult to compare between them, and almost impossible to determine if they suit best for a given scenario. Although many proposals include simulated experiments repeated in several conditions, with different datasets, and even including very detailed network conﬁgurations, such as radio protocols, and interference models, they still lack the basic scientiﬁc approach allowing repeatability and comparison. It is true that many of these papers introduce the confrontation to other routing algorithms, but even in this case, the scenario selection and particular conﬁguration is not guaranteed to observe, intentionally or not, a rigorous objectivity ensuring fairness. Moreover, few of these proposals present a ﬁnal implementation showing its feasibility and allowing a realistic performance evaluation under real world conditions. Traditional networks have an endtoend path available to transmit messages between nodes, but in Opportunistic Networks, this endtoend path may never exist, delays and disruptions are part of the behaviour; therefore, opportunistic strategies makes communication possible. In the development of a routing algorithm, evaluation and testing are done by some assumptions (e.g., unlimited resources, limited resources, a limited number of messages, unlimited creation of messages, among others). These assumptions seek to recreate a real world OppNet, but complexity and variability increases within each characteristic studied. Having seen this, there is the urgent need to propose, agree, and use a common methodology for the development of routing algorithms that also takes into consideration extreme scenarios, such as opportunistic networking. The process has to go from the basic idea for the routing strategy, to the mathematical analysis, model, simulation, software implemen tation of the algorithm, emulation, and ﬁnally the application of the routing strategy, testing real code in real scenarios. In this paper, we get grips with the problem, and introduce the basic rationale for such a methodology, highlighting its most important stages and components, and discussing the importance of two core elements in the process of protocol de signing: scenario selection, based on essential characteristics, and standard evaluation metrics. We expect this methodologyarXiv:2009.01532v1  [cs.NI]  3 Sep 2020to faster the adoption of a common scientiﬁc approach to the development of new routing algorithms, and to give ﬁrm leverage in the production of high quality routing algorithms for OppNet. The rest of the paper is structured as follows. Section II introduces the state of the art on opportunistic networks, evaluation strategies and development methodologies. Section III presents the methodology in our proposal. Then, scenarios and metrics are shown in Section IV. Finally, Section V discusses our contributions and implications. II. R ELATED WORK "
114,Analysis of the shortest relay queue policy in a cooperative random access network with collisions.txt,"The scope of this work is twofold: On the one hand, strongly motivated by
emerging engineering issues in multiple access communication systems, we
investigate the performance of a slotted-time relay-assisted cooperative random
access wireless network with collisions and with join the shortest queue
relay-routing protocol. For this model, we investigate the stability condition,
and apply different methods to derive the joint equilibrium distribution of the
queue lengths. On the other hand, using the cooperative communication system as
a vehicle for illustration, we investigate and compare three different
approaches for this type of multi-dimensional stochastic processes, namely the
compensation approach, the power series algorithm (PSA), and the probability
generating function (PGF) approach. We present an extensive numerical
comparison of the compensation approach and PSA, and discuss which method
performs better in terms of accuracy and computation time. We also provide
details on how to compute the PGF in terms of a solution of a Riemann-Hilbert
boundary value problem.","Cooperative communication is a new communication paradigm in which different terminals (i.e., nodes, devices) in a wireless network share their antennas and resources for distributed transmission and pro cessing. Recent studies have shown that cooperative communications yield signiﬁcant performance im provements for 5G networks, which need massive uncoordinated access, low latency, energy efﬁciency and ultrareliability [45]. The unprecedented growth of wireless networking, and the ever growing demand for higher data rates and capacity over the last decades, have already pushed the limits of current cellular systems [57]. By exploiting the spatial diversity inherent to wireless channels, which is an important tool to overcome the effects of fading (decrease in signal power due to path loss), shadowing and attenuation (decrease in signal strength), relaybased cooperative communications have been proposed as the appropriate solution to achieve the requirements of future needs; see e.g., [31, 37]. m.mayank@tue.nl yidimit@math.upatras.gr zs.kapodistria@tue.nl 1arXiv:1810.00754v1  [math.PR]  1 Oct 2018A typical relaybased cooperative wireless network operates as follows: There exists a network of a ﬁnite number of source users, a ﬁnite number of relay nodes and a common destination node. The source users transmit packets to the destination node with the cooperation of the relays. If a direct transmission of a user’s packet to the destination fails, a cooperation strategy among sources and relays is employed to specify the relays that will store the blocked packet in their buffer. Relays are responsible for the transmission of the blocked packets to the destination, e.g., [46]. In a wireless network, transmission failures occur either due to packet collisions, or due to channel fading/noise and attenuation. In both cases the packet has to be retransmitted at a later slot. The former case occurs when more than one node transmit simultaneously, while the latter one refers to the probabilistic nature of transmissions, see e.g., [46, 50, 51]. In this work, we consider a simple relaybased cooperative wireless network with a single source, two inﬁnite capacity relay nodes, and a common destination with collisions under a load balancing relay scheme. We assume that due to deep fading and bad channel quality it is impossible for the source to communicate with the destination through a direct link, and thus, cooperation within the relays is imperative. Furthermore, we assume that the relays and the source user are sufﬁciently close such that the packets transmitted over the channel are always correctly received by the relays. The employed cooperation strategy among source and relays is queuebased, with as ultimate goal to minimise the total transmission time, i.e., the time that is needed to transmit a packet from the source to the destination. To this end, we consider join the shortest queue policy as it seems to be the most appropriate for such a wireless network [39, 40, 60, 63]. 1.1 Related work "
185,Uncertainty in marine weather routing.txt,"Weather routing methods are essential for planning routes for commercial
shipping and recreational craft. This paper provides a methodology for
quantifying the significance of numerical error and performance model
uncertainty on the predictions returned from a weather routing algorithm. The
numerical error of the routing algorithm is estimated by solving the optimum
path over different discretizations of the environment. The uncertainty
associated with the performance model is linearly varied in order to quantify
its significance. The methodology is applied to a sailing craft routing
problem: the prediction of the voyaging time for an ethnographic voyaging canoe
across long distance voyages in Polynesia. We find that the average numerical
error is $0.396\%$, corresponding to $1.05$ hours for an average voyage length
of $266.40$ hours. An uncertainty level of $2.5 \%$ in the performance model is
seen to correspond to a standard deviation of $\pm 2.41-3.08\%$ of the voyaging
time. These results illustrate the significance of considering the influence of
numerical error and performance uncertainty when performing a weather routing
study.","Abstract Weather routing methods are essential for planning routes for commer cial shipping and recreational craft. This paper provides a methodology for quantifying the signicance of numerical error and performance model uncertainty on the predictions returned from a weather routing algorithm. The numerical error of the routing algorithm is estimated by solving the optimum path over dierent discretizations of the environment. The un certainty associated with the performance model is linearly varied in order to quantify its signicance. The methodology is applied to a sailing craft routing problem: the prediction of the voyaging time for an ethnographic voyaging canoe across long distance voyages in Polynesia. We nd that the average numerical error is 0 :396%, corresponding to 1 :05 hours for an average voyage length of 266 :40 hours. An uncertainty level of 2 :5% in the performance model is seen to correspond to a standard deviation of2:41"
101,Improved Quality of Service Protocol for Real Time Traffic in MANET.txt,"The technologies like Wi-Fi, Blue tooth, WiMax etc. have made Mobile Ad hoc
Networks common in our Real life. Multi-media applications need to be supported
on MANET. A certain level of QoS (Quality of Service) support is essential for
Real time data. Our proposed protocol provides the required QoS without having
negative impact on Best Effort data traffic. An efficient rout discovery
mechanism for AODV routing protocol as well as transmission technique for real
time data are proposed. This technique gives more transmission opportunities to
real time data traffic results in decreasing transmission delay and increasing
throughput. A modified version of the popular AODV routing protocol to provide
QoS guarantee for real time traffic in MANETs is proposed. The simulation shows
better performance results for proposed protocol over the basic AODV.","A mobile ad hoc network (MANET) [1] is a wireless network of autonomous mobile nodes, the network having no infrastructure and runs on batteries. Communication occurs between nodes without a central entity like a base station or an access point. This allows the mobile nodes to setup cost effective networks quickly and without any fixed topology. MANET is originally designed for use in military applications, but can also play an important role in relief and rescue operations. Most recently, the application of MANETs in innovative paradigms such as Vehicle  ToVehiclecommunication and wireless sensor networks has also been explored. These networks are primarily made to transmit quick information exchange between the participating nodes; the existing routing protocols supports best effort type of traffic. The MANET prot ocols cannot guarantee reliability and QoS because they contain self configured nodes with a dynamic network topology. The dynamic nature of the network topology is mainly attributed to the mobility of the nodes. Maintaining accurate information about the status of a network for routing purposes becomes difficult because of the constraints of the Mobile Ad hoc Network. MANETs employ two basic types of routing protocols, namely table driven protocols and on  demand routing protocols. The table driven protoco ls are proactive protocols that consumeInternational Journal of Computer Networks & Communications (IJCNC) Vol.5, No.4, July 2013 76network bandwidth but have less routing overhead. On the other hand, the on demand routing protocols are reactive protocols that exchange routing information only when needed. The on demand protocols are often prefer red in bandwidth constrained environments. Among the available on demand protocols, the Ad hoc Ondemand Distance Vector (AODV) is most widely used because of its simplicity, scalability, low computational complexity and low overhead. AODV routes IP packet s to the destination node by discovering the shortest path without giving due consideration to network reliability and QoS [2]. This fundamental drawback limits the scope of AODV as it cannot perform well for real time applications, which require certain Q oS guarantees like fixed bandwidth, low latency and jitter, less link failures, etc. As mentioned earlier, these guarantees cannot be accommodated in the conventional AODV due to the inherently dynamic nature of MANETs. The conventional basic AODV discove rs the route by broadcasting route request (RREQ) messages throughout the network. Based on the responses received from the participating nodes, the route with least number of hops to destination is selected for data transmission. Modified versions of AODV also consider factors like traffic load on a route, link quality among nodes, energy consumption, traffic flow type etc. This route discovery process is initiated when a new node joins the network or when a link between the neighboring nodes breaks down. A node first stores an incoming packet in its buffer and executes a queuing mechanism to place the stored data packets on the transmission channel. The delay in a network increases with the size of the queue in a buffer. If the length of a queue exceeds a certain threshold, packets are dropped. Traffic congestion occurs when the rate of packet arrival in the buffer exceeds the rate of transmission. Queuing delay, packet loss and traffic congestion should be controlled in order to support the real time appli cations. This paper is extended version of QoS AODV routing protocol in to provide QoSbased routing in MANETs. A mechanism is proposed to provide QoS guarantee to support real time applications. More scheduling priority is given to the data packets origi nating from real time applications. The rest of this paper is organized as follows. Related work and problem definition is presented in Section II. Best Effort Traffic aware rout discovery and packet forwarding mechanism is covered in Section III, follow ed by implementation results and performance evaluation in Section IV. This paper is concluded in Section V while the references are given towards the end of paper. 2.RELATED WORK "
360,Client-side Vulnerabilities in Commercial VPNs.txt,"Internet users increasingly rely on commercial virtual private network (VPN)
services to protect their security and privacy. The VPN services route the
client's traffic over an encrypted tunnel to a VPN gateway in the cloud. Thus,
they hide the client's real IP address from online services, and they also
shield the user's connections from perceived threats in the access networks. In
this paper, we study the security of such commercial VPN services. The focus is
on how the client applications set up VPN tunnels, and how the service
providers instruct users to configure generic client software. We analyze
common VPN protocols and implementations on Windows, macOS and Ubuntu. We find
that the VPN clients have various configuration flaws, which an attacker can
exploit to strip off traffic encryption or to bypass authentication of the VPN
gateway. In some cases, the attacker can also steal the VPN user's username and
password. We suggest ways to mitigate each of the discovered vulnerabilities.","Virtual private networks (VPN) [ 67] were originally developed for connecting geographically distributed corporate networks to each other with encrypted tunnels, so that they would form a single secure logical network. Their functionality was also extended for connecting remote workers to the employer’s intranet. However, one of the most common uses of VPN today is to protect regular Internet users who seek improved security and privacy. Such users perceive a need for a VPN in many different situations, such as when accessing the Internet over public WiFi (e.g. at a cafe, hotel, or airport), to hide their online activities from an oppressive entity (e.g. government, employer or Internet service provider), or to access geoblocked media content. Because of the increased demand, a large number of commercial VPN services have appeared in the market [41]. Commercial VPNs typically function by tunneling the user’s In ternet traffic through a trusted remote server before it is forwarded to its final destination. This achieves two goals: first, the traffic is protected by an encrypted VPN tunnel against dangers in the accessnetwork and, second, the destination server does not learn the real IP address of the client. There are quite a few VPN protocols that can be used to establish the tunnel (e.g. PPTP, SSTP, OpenVPN), and the commercial VPN providers usually support several of them. The commercial VPN providers also provide native client applications with graphical user interfaces, which allow the user to select the protocol and server and set up the VPN connection accordingly. For more technically savvy users who prefer not to install the provided application, the VPN service providers usually give instructions for configuring the builtin VPN client in the user’s operating system (OS) to work with their servers. The commercial VPN services have undergone severe scrutiny [ 3, 20,21,26,27,57,60], which has exposed various malpractices and vulnerabilities in the services. A handful of researchers have taken a closer look at the client configuration in the commercial VPNs [ 26, 27,57]. These studies revealed a number of misconfigurations of popular VPN services that lead to user deanonymization and traffic leakage. Our work extends this theme in the literature with the focus on the security of the VPN tunnels, namely whether they are encrypted and authenticated properly. Motivation. Our work was primarily motivated by the observa tion that many commercial VPN providers configure L2TP/IPsec, a popular VPN protocol, in an insecure way. Specifically, the proto col relies on IPsec [ 29] to provide the secure transport, but many VPN providers use one preshared key for all users to authenticate the IPsec tunnels. These servicespecific keys are either publicly available online or can be discovered by examining the client config uration. An example of such a preshared key is “12345678”. When an attacker knows the preshared key, it can perform a manin themiddle (MitM) attack on the VPN connection and, as the result, obtain all the network traffic to and from the victim’s computer. This problem was already discussed on public forums in 2016 [ 18]. When we reanalyzed the 14 insecure commercial VPN services mentioned in the discussion, we found that only four of them had fixed the problem or stopped supporting the L2TP/IPsec protocol, while 10 were still using the insecure configuration. Whatever the reason is, this security issue remains opaque to most endusers. Thus, we feel that it is important to scrutinize systematically the client configurations of commercial VPN services, considering both L2TP/IPsec and other protocols, for flaws that could undermine the user’s security and privacy. Contributions. In this paper, we study how popular commercial VPN providers set up, or how they instruct users to set up, desktop 1arXiv:1912.04669v1  [cs.CR]  10 Dec 2019*Arefined version of this draft, with the same title, has been published in the 24th Nordic Conference on Secure IT Systems. PPTP SSTP L2TP/IPSec Cisco IPSec IKEv2 OpenVPN SoftEther VPN Windows Builtin Builtin Builtin Shrew Soft Builtin OpenVPN SoftEther macOS – EasySSTP Builtin Builtin Builtin OpenVPN SoftEther Ubuntu Builtin sstpclient xl2tpd Shrew Soft StrongSwan OpenVPN SoftEther Table 1: VPN clients that are used or recommended by commercial VPN providers. VPN clients for common VPN protocols. Our study covers three common desktop operating systems: Windows, macOS and Ubuntu. The study reveals various vulnerabilities in the configurations of VPN clients, which allow attackers to strip off traffic encryption or to bypass server authentication. By exploiting these vulnerabili ties, attackers can intercept network traffic to and from the victim. Some of the vulnerabilities also allow the attacker to steal user credentials for to authenticating the VPN gateway. To the best of our knowledge, the vulnerabilities that we present in this paper have not been discussed before in research literature. While each of the vulnerabilities alone might seem like a trivial mistake, to gether they indicate a serious lack of securityawareness across the commercial VPN industry, and we feel that it is the responsibility of the research community to raise the issue. We have disclosed all of the vulnerabilities to the responsible parties, and we include the responses that we received so far in the paper. We also provide guidelines on fixing the vulnerabilities. Through this work, we hope to raise awareness among the com mercial VPN providers about common configuration mistakes and how they can be avoided. Paper organization. Section 2 provides background information on commercial VPN services. Section 3 gives an overview of our study, and Section 4 covers the vulnerabilities that were found in the client configurations of popular commercial VPN services. Mitigation solutions are covered in Section 5. Section 7 discusses the results. Finally, Section 8 summarizes related work, and Section 9 concludes the paper. 2 BACKGROUND This section gives an overview of commercial VPN services and their client software. 2.1 Overview of commercial VPN services The focus of this paper is on commercial VPNs, whose usage differs from that of corporate VPNs. The corporate VPNs (also known as enterprise or business VPNs) are set up by organizations to allow their employees to remotely access resources, such as web and file servers, on the corporate intranet. In such networks, system administrators usually preconfigure employee devices with the required client software. The commercial VPNs (also known as personal or consumer VPNs), on the other hand, are subscriptionbased services available to regular Internet users. They allow users to tunnel their Inter net traffic via the service provider’s gateway server somewhere in the cloud. The commercial VPNs are typically used for personal purposes, such as accessing geoblocked or countryspecific media contents and for securing sensitive online activities while on pub lic WiFi networks. They are also used to avoid censorship andsurveillance by local governments and accessnetwork operators. However, the users of commercial VPNs route their network traffic through the VPN provider’s gateway, which means that they have to trust the VPN provider as well as the country where the gateway server is located. To overcome this trust issue, the commercial VPN providers often promise to keep no logs of the customer activities and allow users to choose VPN servers in countries with strong personal privacy laws (e.g. Switzerland and Iceland). 2.2 Commercial VPN client software Most commercial VPN providers have a native client application , which sets up the VPN connection for the user. These client applica tions are usually available for the Windows and macOS operating systems. To use a native client application, users must first enter their VPN userlogin credentials into the client application. The application pulls configuration data, such as VPN server addresses, roots of trust for the authentication, and VPNclient credentials (which are not necessarily the same as the userlogin credentials), from the VPN provider’s server. The client application then config ures the VPN tunnel for later use. The client application typically allows the user to choose from many different VPN protocols for the tunnel implementation, either to circumvent firewalls or to match user preferences. The native client applications rely on the operating system’s built in VPN client functionality whenever it exists. They usually use the routing and remote access service (RRAS) [ 9] on Windows and NEVPNManager APIs [ 4] on macOS to programmatically create and manage VPN connections. Windows is bundled with imple mentations of the PPTP, L2TP/IPsec, SSTP and IKEv2 protocols, while macOS comes with L2TP/IPsec, IKEv2 and Cisco IPsec client functionality. For the protocols that have no builtin support in the OS, the commercial VPN providers include thirdparty client binaries in their native applications. Table 1 shows the preferred or recommended VPN clients for each of the studied VPN protocols on the three OSs we consider in this study. The process of opening a VPN connection is similar regardless of the protocol and the choice between a builtin and thirdparty client. First, the client establishes a connection to the specified server with the selected protocol. The client and the server then authenticate each other in the selected protocol with the previously configured credentials and roots of trust. After successful authentication, the client and server negotiate various parameters for the VPN connec tion, such as the encryption scheme and the DNS servers. When the negotiation is completed, the client computer’s routing table or firewall rules are configured to tunnel all network traffic through the VPN connection. The VPN providers do not always have native client applications for all operating systems, such as Linux. Some users may also prefer not to install the provided application. For these users, the VPN 2Clientside Vulnerabilities in Commercial VPNs providers give instructions on their websites for configuring the OS’s builtin VPN client. They may also give advice on installing and configuring thirdparty clients to use with their service. 3 STUDY OF COMMERCIAL VPN SERVICES This section gives an overview of our study of commercial VPN services. We first describe the adversary model. We then explain the methodology for systematically finding vulnerabilities in VPN client configuration, covering a large part of the consumer VPN market. The discovered vulnerabilities will be described in detail in the next section. 3.1 Adversary model The object of our study is the way commercial VPN services make use of the common VPN protocols and tunnels. We consider two types of attackers: network attacker andlocal attacker . The former is the standard model for network security, while the latter extends the attacker model to nonprivileged processes running on the same computer as the VPN client software. Network attacker. We consider an active network attacker who can intercept and modify network traffic originating from and destined to the user’s machine. The attacker could, for example, be a rogue hotspot operator at a hotel or airport, or a compromised corenetwork operator. Local attacker. The VPN client software on the user’s computer often comprises multiple components that are connected to each other with interprocess communication (IPC). For example, the GUI component may use an IPC channel to sent the VPN configura tion to a thirdparty client binary. It has been recently shown that misconfigured IPC may be vulnerable to attacks by nonprivileged processes of other users, including guest users, who have access to the same computer (socalled ManintheMachine attacks [ 32]). These unprivileged attackers could exploit the IPC channels of VPN client applications to steal sensitive information or to modify the VPN connection settings. We included this new type of attackers to the study because the vulnerability of VPN clients to it is currently not well understood and the attacks are different from those on the network. (Note that we do not consider malware that is running with the victim user’s privileges or as administrator. While these threats can be serious, the current desktop OSs are not expected to offer protection against them.) In both the network and local attacks, the ultimate goal of the attackers is to bypass the protection mechanisms of the VPN con nection so that they can steal sensitive data sent or received through it. 3.2 Methodology "
454,Fast Inference in Capsule Networks Using Accumulated Routing Coefficients.txt,"We present a method for fast inference in Capsule Networks (CapsNets) by
taking advantage of a key insight regarding the routing coefficients that link
capsules between adjacent network layers. Since the routing coefficients are
responsible for assigning object parts to wholes, and an object whole generally
contains similar intra-class and dissimilar inter-class parts, the routing
coefficients tend to form a unique signature for each object class. For fast
inference, a network is first trained in the usual manner using examples from
the training dataset. Afterward, the routing coefficients associated with the
training examples are accumulated offline and used to create a set of ""master""
routing coefficients. During inference, these master routing coefficients are
used in place of the dynamically calculated routing coefficients. Our method
effectively replaces the for-loop iterations in the dynamic routing procedure
with a single matrix multiply operation, providing a significant boost in
inference speed. Compared with the dynamic routing procedure, fast inference
decreases the test accuracy for the MNIST, Background MNIST, Fashion MNIST, and
Rotated MNIST datasets by less than 0.5% and by approximately 5% for CIFAR10.","For object recognition to be done correctly, a model must preserve the hierarchical relationships between object parts and their corresponding wholes. It is not sufﬁcient that all the pieces of an object are present in an image, they must also be oriented correctly with respect to one another. Convolutional Neural Networks (CNNs) are limited in their ability to model the spatial hierarchy between objects. Even if subsampling operations (e.g., maxpooling) are removed, the representation of data in CNNs do not take into account the relationships between object parts and wholes. Capsule Networks [ 7], [2] learn such hierarchies by grouping feature map channels together to form a vector of features (i.e., a capsule) that captures the instantiation parameters of objects and by learning transformation matrices that encode viewpoint invariant information. These networks generalize to novel viewpoints by incorporating the viewpoint changes directly into the activities of the capsules. The capsules can represent various properties of an object ranging from its size and shape to more subtle features such as texture and orientation. Since their introduction, CapsNets have produced stateoftheart accuracies on datasets such as MNIST [ 9] and smallNORB using a network with far fewer parameters compared with their CNN counterparts [7]. At their core, CapsNets [ 7] make use of a dynamic routing algorithm to ensure that the output of a lowerlevel capsule is routed to the most appropriate higherlevel capsule. This is done by multiplying the lowerlevel capsules with learned viewpoint invariant transformation matrices to produce prediction vectors. These matrices make sense of the spatial relationships between object 1arXiv:1904.07304v1  [cs.CV]  15 Apr 2019features. The scalar product between the prediction vectors and each of the higherlevel capsules governs the agreement between a part and a whole. Large values imply that a part has a high likelihood of belonging to a whole and vice versa. The combination of the scalar products and the transformation matrices ultimately decides which whole is most suited for each part. This “routingbyagreement” is a more effective way of sending spatial information between layers in a network than the routing implemented by maxpooling, since the former maintains the exact spatial relationships between neurons in each layer of the network, regardless of the network depth. Although CapsNets have shown promising results, there are some key limitations that make them unsuitable for real world use. One such issue is inference using CapsNets is signiﬁcantly slower compared with CNNs. This is primarily due to the dynamic routing procedure which requires several iterations to produce the output vectors of a capsule layer. This limitation prevents deeper CapsNet architectures from being used in practice. We present a method for speeding up inference for CapsNets, with potential applications for training. This is accomplished by making use of the accumulated information in the dynamically calculated routing coefﬁcients computed using the training dataset. Analyses of intraclass routing coefﬁcients show that they form a unique signature for each class. Intuitively, this is because parts of the same object should generally be similar and, more importantly, distinct from the parts of a different object. In practice, the network is trained to produce prediction vectors (using the lowerlevel capsules and learned transformation matrices) that closely correlate with the higherlevel capsule associated with its own class. This observation allows creation of a set of master routing coefﬁcients using the individual routing coefﬁcients associated with each training example. At inference time, the master routing coefﬁcients are used instead of dynamically computing the routing coefﬁcients for each input to the network. Our method for fast routing at inference effectively replaces the riterations in the routing procedure with a single matrixmultiply operation, allowing the network to be parallelized at runtime. On the MNIST dataset and its variants, fast inference decreases the test time accuracies by less than 0:5%and by approximately 5%for CIFAR10. Section 2 describes the threelayer network architecture that was used. Section 3 compares the differences in the routing procedure at inference between the dynamic routing algorithm and the fast routing procedure. Section 4 analyses the dynamic routing coefﬁcients from the MNIST and CIFAR10 training datasets. In Section 5, we detail the procedure for creating a set of master routing coefﬁcients and compare the master set of routing coefﬁcients with the dynamically calculated ones in Section 6. Section 7 compares the test accuracies between the dynamic and fast routing procedures for the ﬁve datasets. Discussions on the use and applicability of master routing coefﬁcients are given in Section 8. The general procedure for creating master routing coefﬁcients is detailed in Appendix A. 2 Capsule Network Architecture The CapsNet architecture shown in Fig. 1 follows the three layer network from [ 7]. For the MNIST [ 4], Background MNIST (bMNIST) and Rotated MNIST (rMNIST) [ 5], and Fashion MNIST (fMNIST) [ 8] datasets, the input to the network is a 2828grayscale image that is operated on by a convolutional layer to produce a 2020256 feature map tensor (for CIFAR10, the 32323 image is randomly cropped so that its spatial dimensions are 2424). The second convolutional layer outputs a 66256 feature map tensor. Each group of 8neurons ( 4for CIFAR10) in this feature map tensor is then grouped channelwise and forms a single lowerlevel capsule, i, for a total of66(2568) = 1152 lowerlevel capsules ( 1024 for CIFAR10). The lowerlevel capsules are fed to the routing layer, where the dynamic routing procedure converts these capsules to the 1016DigitCaps matrix, where 10is the number of higherlevel capsules (also the number of object classes) and 16is the dimensionality of the capsules. Here, we use MaxMin normalization [ 9] as opposed to Softmax to convert the raw logits into routing coefﬁcients. Details on the dynamic routing procedure are given in Section 3. Each row in the DigitCaps matrix represents the instantiation parameters of a single object class and the length of the row vector represents the probability of the existence of that class. During training, nongroundtruth rows in the DigitCaps matrix are set to zero and the matrix is passed to a reconstruction network composed of two fullyconnected layers of dimensions 512 and1024 with ReLU activations, and a ﬁnal fullyconnected layer of dimension 28281 = 784 2(24243 = 1728 for CIFAR10) with a sigmoid activation. During inference, the reconstruction network is not used. Instead, the row in the DigitCaps matrix with the largest L2norm is taken as the predicted object class for the input. Our implementation uses TensorFlow [ 1] with training conducted using the Adam optimizer [ 3] with TensorFlow’s default parameters and an exponentially decaying learning rate. Unless otherwise noted, the same network hyperparameters in [ 9] were used here for training as well. Original code is adapted from [6]. Figure 1: (Left) Threelayer CapsNet architecture adapted from Sabour et al. [7]. The PrimaryCaps layer consists of 6632 = 1152 8 D vector capsules for the MNIST dataset and its variants (1024 4 D vector capsules for CIFAR10). The routing procedure produces the 1016DigitCaps layer, which is used to calculate the margin loss. The DigitCaps output is also passed to the reconstruction network where the nongroundtruth rows are masked with zeros. The network takes the masked 1016DigitCaps matrix as input and learns to reproduce the original image. Margin and reconstruction loss functions follow those from [7]. 3 Comparison Between Dynamic and Fast Routing Procedures The dynamic routing procedure for CapsNets using MaxMin normalization is given by MaxMin Routing Procedure below. This algorithm is used during normal training and inference. The prediction vectors to the routing layer, ^ujji, are created by multiplying each of the lowerlevel capsules, ui, in PrimaryCaps by their respective transformation weight matrix, Wij. The higherlevel capsules sj are computed as a sum over all the prediction vectors, weighted by the routing coefﬁcients, cij. The routing coefﬁcients are initialized with a value of 1:0and can be viewed as independent probabilities representing the likelihood of a lowerlevel capsule being assigned to a higherlevel capsule [ 9]. For a given input to the routing layer, its routing coefﬁcient matrix has shape NiNj, where Niand Njare the number of lower and higherlevel capsules, respectively. The higherlevel capsules, sj, are then squashed using a nonlinear function so that the vector length of the resulting capsule, vj, is between 0and1. These operations are shown in Eq. 1. ^ujji=Wijui; s j=X icij^ujji; v j=jjsjjj2 1 +jjsjjj2sj jjsjjj(1) During the procedure, the update to the routing coefﬁcients, bij, is computed as the dot product between the prediction vectors and the current state of the higherlevel capsules, vj. The update to the routing coefﬁcients is then normalized via MaxMin normalization over the object classes as given by Eq. 2, where p/qare the lower/upper bounds of the normalization. For the ﬁrst iteration, the routing coefﬁcients are initialized to 1:0outside of the main routing forloop. 3cij=p+bij"
43,"PSNR and Jitter Analysis of Routing Protocols for Video Streaming in Sparse MANET Networks, using NS2 and the Evalvid Framework.txt","Advances in multimedia and ad-hoc networking have urged a wealth of research
in multimedia delivery over ad-hoc networks. This comes as no surprise, as
those networks are versatile and beneficial to a plethora of applications where
the use of fully wired network has proved intricate if not impossible, such as
prompt formation of networks during conferences, disaster relief in case of
flood and earthquake, and also in war activities. It this paper, we aim to
investigate the combined impact of network sparsity and network node density on
the Peak Signal Noise to Ratio (PSNR) and jitter performance of proactive and
reactive routing protocols in ad-hoc networks. We also shed light onto the
combined effect of mobility and sparsity on the performance of these protocols.
We validate our results through the use of an integrated Simulator-Evaluator
environment consisting of the Network Simulator NS2, and the Video Evaluation
Framework Evalvid.","The transmission of multimedia objects over Mobile Ad hoc Networks (MANET) network has become the need of the  day due to critical applications that rely on such networks such  as the transmission of important images and videos in  emergency situations. However, this task presents two main  complexities. The first aspect of intricacy lies in the nature of  MANET: their mobile and distributed, interference and multi hop communication [1], [2]. Since MANETs do not rely on  preexisting infrastructure, data is transmitted through multi hop routing [3]. This collective effort in data transmission  requires that each node acts as a router too. Thus, it comes as  no surprise that the provision of QoS over such networks can  prove extremely difficult. The second aspect of intricacy lies  within the nature of multimedia objects, specifically video files  which are not only bandwidthhungry but also highly demanding in terms of Quality of Service (QoS). Effective  multimedia transmission dictates minimal delay and inorder  receipt of packets [1]. Therefore, it has become imperative to determine routing protocols that can not only fulfil those QoS  criteria but are also able to maintain such performance while  varying the network topology in terms of sparsity and mobility.  Multimedia transmission may prove particularly challenging in  sparse MANETs whereby disconnections become more and  more frequent due to low network node density [3].  It this paper, we investigate the PSNR performance of  proactive and reactive routing protocols for video streaming of  bandwidthhungry multimedia video files over sparse MANET  networks. We also explore the combined effect of mobility and  sparsity on the PSNR performance. To this end, we use the  NS2 Network Simulator and the Evalvid Framework tool in  order to test a renowned protocol of each family, namely  AODV (reactive), and DSDV (proactive).  The remainder of the paper is organized as follows: Section  2 explores the previous work performed in this field. A brief  description of the System Model adopted in our work is  presented in Section 3 . Section 4 justifies our choice of the  simulation and evaluation tools used. Next, a detailed work  approach is described along with simulation configuration in  Section 5. Results are presented and analyzed in Section 6.  Finally, conclusions and future work recommendations are  provided in Section 7.  II. RELATED WORK  "
265,Mobility and Energy Conscious Clustering Protocol for Wireless Networks.txt,"In this paper we present a distributed clustering protocol for mobile
wireless sensor networks. A large majority of research in clustering and
routing algorithms for WSNs assume a static network and hence are rendered
inefficient in cases of highly mobile sensor networks, which is an aspect
addressed here. MECP is an energy efficient, mobility aware protocol and
utilizes information about movement of sensor nodes and residual energy as
attributes in network formation. It also provides a mechanism for fault
tolerance to decrease packet data loss in case of cluster head failures.","Wireless sensor networks (WSNs) consist of a large number of sensor nodes that are densely deployed in a region of interest and connected through wireless links to collect data about a target or event, and cater a variety of sensing and monitoring applications [1]. In many applications that belong to marine environments, wildlife tracking and protection, and various other such activities, the mobile sensors are more effective as compared to their static counterparts. However, the sensors being energy constrained  nodes,  the  mobile  sensors  are  more  prone  to  crash  due  to  battery exhaustion  as  mobility  incurs  more  computation  overhead  and  thus  it  is  energy intensive. Hence, the traditional WSN protocols [2, 3] are not suitable for deployment in the environment where sensors are mobile. Therefore, the mobility aware protocols are more preferred option.  In the literature, a number of approaches have been proposed to handle mobility in wireless scenario [8, 9]. Clustering is a popular approach to handle mobility and improve  scalability  in  distributed  computing  systems  [10,  11].  In  clustering,  the network is partitioned into non overlapped regions   and activities of nodes belonging to each cluster is coordinated by a distinct node called a Cluster Head(CH).Though, CH is responsible for efficient communication and data dissemination, its failure may lead to discontinuity of application. Therefore, for long running applications, fault tolerance is an utmost desirable feature. Secondly, the movement of cluster head may also impact the application in a similar way. Therefore, in this paper, we propose an energy efficient distributed clustering protocol that is fault tolerant and also handles mobility in WSNs. 2System Model The WSN consists of a set of N nodes connected with wireless links. The nodes in the communication range of a node  Ni are called neighbours of N i. The nodes are assumed to be mobile and hence trigger the topological changes. It is also assumed that each sensor node is capable of sensing its velocity, e.g. via an accelerometer or any other sensing hardware embedded in it. 3Related Work "
166,Cloudburst: Stateful Functions-as-a-Service.txt,"Function-as-a-Service (FaaS) platforms and ""serverless"" cloud computing are
becoming increasingly popular. Current FaaS offerings are targeted at stateless
functions that do minimal I/O and communication. We argue that the benefits of
serverless computing can be extended to a broader range of applications and
algorithms. We present the design and implementation of Cloudburst, a stateful
FaaS platform that provides familiar Python programming with low-latency
mutable state and communication, while maintaining the autoscaling benefits of
serverless computing. Cloudburst accomplishes this by leveraging Anna, an
autoscaling key-value store, for state sharing and overlay routing combined
with mutable caches co-located with function executors for data locality.
Performant cache consistency emerges as a key challenge in this architecture.
To this end, Cloudburst provides a combination of lattice-encapsulated state
and new definitions and protocols for distributed session consistency.
Empirical results on benchmarks and diverse applications show that Cloudburst
makes stateful functions practical, reducing the state-management overheads of
current FaaS platforms by orders of magnitude while also improving the state of
the art in serverless consistency.","Serverless computing has become increasingly popular in recent years, with a focus on autoscaling FunctionasaService (FaaS) systems. FaaS platforms allow developers to write func tions in standard languages and deploy their code to the cloud with reduced administrative burden. The platform is responsible for transparently autoscaling resources from zero to peak load and back in response to workload shifts. Consumptionbased pricing ensures that developers’ cost is proportional to usage This work is licensed under the Creative Commons Attribution NonCommercialNoDerivatives 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/byncnd/4.0/. For any use beyond those covered by this license, obtain permission by emailing info@vldb.org. Copyright is held by the owner/author(s). Publication rights licensed to the VLDB Endowment. Proceedings of the VLDB Endowment, Vol. 13, No. 11 ISSN 21508097. DOI: https://doi.org/10.14778/3407790.3407836 CloudburstDask SANDλ λ+Dynamoλ+S3 StepFnsCB (Single) λ (Sing le)10102103Latency  (ms)Figure 1: Median (bar) and 99th percentile (whisker) latency forsquare(increment(x: int)) . Cloudburst matches the best distributed Python systems and outperforms other FaaS systems by over an order of magnitude ( x6.1). of their code: there is no need to overprovision to match peak load, and there are no compute costs during idle periods. These bene/f_its have made FaaS platforms an attractive target for both research [26, 44, 4, 43, 37, 47, 10, 81, 28, 25] and industry applications [7]. The hallmark autoscaling feature of serverless platforms is en abled by an increasingly popular design principle: the disaggrega tion of storage and compute services [32]. Disaggregation allows the compute layer to quickly adapt computational resource allo cation to shifting workload requirements, packing functions into VMs while reducing data movement. Similarly, object or keyvalue stores can pack multiple users’ data storage and access workloads into shared resources with high volume and often at low cost. Dis aggregation also enables allocation at multiple timescales: long term storage can be allocated separately from shortterm compute leases. Together, these advantages enable eﬃcient autoscaling. User code consumes expensive compute resources as needed and accrues only storage costs during idle periods. Unfortunately, today’s FaaS platforms take disaggregation to an extreme, imposing signi/f_icant constraints on developers. First, the autoscaling storage services provided by cloud vendors—e.g., AWS S3 and DynamoDB—are too highlatency to access with any fre quency [84, 37]. Second, function invocations are isolated from each other: FaaS systems disable pointtopoint network commu nication between functions. Finally, and perhaps most surpris ingly, current FaaS oﬀerings have very slow nested function calls: argument and resultpassing is a form of crossfunction commu nication and exhibits the high latency of current serverless oﬀer ings [4]. We return these points in x2.1, but in short, today’s popu lar FaaS platforms only work well for isolated, stateless functions. As a workaround, many applications—even some that were ex plicitly designed for serverless platforms—are forced to step outarXiv:2001.04592v3  [cs.DC]  24 Jul 2020side the bounds of the serverless paradigm altogether. For exam ple, the ExCamera serverless video encoding system [26] depends upon a single server machine as a coordinator and task assign ment service. Similarly, numpywren [74] enables serverless linear algebra but provisions a static Redis machine for lowlatency ac cess to shared state for coordination. These workarounds might be tenable at small scales, but they architecturally reintroduce the scaling, fault tolerance, and management problems of traditional server deployments. 1.1 Toward Stateful Serverless via LDPC Given the simplicity and economic appeal of FaaS, we are inter ested in exploring designs that preserve the autoscaling and opera tional bene/f_its of current oﬀerings, while adding performant, cost eﬃcient, and consistent shared state and communication. This “stateful” serverless model opens up autoscaling FaaS to a much broader array of applications and algorithms. We aim to demon strate that serverless architectures can support stateful applica tions while maintaining the simplicity and appeal of the serverless programming model. For example, many lowlatency services need to autoscale to handle bursts while dynamically manipulating data based on request parameters. This includes webservers managing user sessions, discussion forums managing threads, ad servers managing ML models, and more. Similarly, many parallel and distributed protocols require /f_inegrained messaging, from quan titative tasks like distributed aggregation [46] to system tasks like membership [20] or leader election [6]. These protocols forms the backbone of parallel and distributed systems. As we see in x6, these scenarios are infeasible on today’s stateless FaaS platforms. To enable stateful serverless computing, we propose a new design principle: logical disaggregation with physical colocation (LDPC). Disaggregation is needed to provision, scale, and bill stor age and compute independently, but we want to deploy resources to diﬀerent services in close physical proximity. In particular, a running function’s “hot” data should be kept physically nearby for lowlatency access. Updates should be allowed at any function invocation site, and crossfunction communication should work at wire speed. Colocation of compute and data is a wellknown method to overcome performance barriers, but it can raise thorny correct ness challenges at the compute layer. For locality, each compute node should be able to independently update its copy of the data. However, given that a single composition of multiple functions may run across multiple nodes, we need to preserve a consistent “session” [80] that is distributed across those nodes. Distributed session consistency is a challenge we must address in this context. 1.2 Cloudburst: A Stateful FaaS Platform In this paper, we present a new FunctionasaService platform called Cloudburst that removes the shortcomings of commercial systems highlighted above, without sacri/f_icing their bene/f_its. Cloudburst is unique in achieving logical disaggregation and physical colocation of computation and state, and in allowing programs written in a traditional language to observe consistent state across function compositions. Cloudburst is designed to be an autoscaling FunctionsasaService system—similar to AWS Lambda or Google Cloud Functions—but with new abstractions that enable performant, stateful programs. Cloudburst achieves this via a combination of an autoscaling keyvalue store (providing state sharing and overlay routing) and mutable caches colocated with function executors (providing data locality). The system is built on top of Anna [85, 86], a low1 from cloudburst import * 2 cloud = CloudburstClient(cloudburst_addr, my_ip) 3 cloud.put('key', 2) 4 reference = CloudburstReference('key') 5 def sqfun(x): return x * x 6 sq = cloud.register(sqfun, name='square') 7 8 print('result: %d' % (sq(reference)) 9 > result: 4 10 11 future = sq(3, store_in_kvs=True) 12 print('result: %d' % (future.get()) 13 > result: 9 Figure 2: A script to create and execute a Cloudburst func tion. latency autoscaling keyvalue store designed to achieve a variety of coordinationfree consistency levels by using mergeable mono tonic lattice data structures [75, 17]. For performant consistency, Cloudburst takes advantage of Anna’s design by transparently encapsulating opaque user state in lattices so that Anna can consistently merge concurrent updates. In addition, we present novel protocols that ensure consistency guarantees (repeatable read and causal consistency) across function invocations that run on separate nodes. We evaluate Cloudburst via microbenchmarks as well as two application scenarios using thirdparty code, demonstrating bene/f_its in performance, predictable latency, and consistency. In sum, this paper’s contributions include: 1. The design and implementation of an autoscaling serverless architecture that combines logical disaggregation with physical colocation of compute and storage (LDPC) ( x4). 2. Identi/f_ication of distributed session consistency concerns and new protocols to achieve two distinct distributed session consis tency guarantees—repeatable read and causal consistency—for compositions of functions ( x5). 3. The ability for programs written in traditional languages to enjoy coordinationfree storage consistency for their native data types via lattice capsules that wrap program state with metadata that enables automatic con/f_lict APIs supported by Anna (x5.2). 4. An evaluation of Cloudburst’s performance and consistency on workloads involving state manipulation, /f_inegrained com munication and dynamic autoscaling ( x6). 2. MOTIVATION AND BACKGROUND Although serverless infrastructure has gained traction recently, there remains signi/f_icant room for improvement in performance and state management. In this section, we discuss common pain points in building applications on today’s serverless infrastructure (x2.1) and explain Cloudburst’s design goals ( x2.2). 2.1 Deploying Serverless Functions Today Current FaaS oﬀerings are poorly suited to managing shared state, making it diﬃcult to build applications, particularly latency sensitive ones. There are three kinds of shared state management that we focus on in this paper: function composition, direct com munication, and shared mutable storage. Function Composition . For developers to embrace serverless as a general programming and runtime environment, it is neces sary that function composition work as expected. Pure functions share state by passing arguments and return values to each other. Figure 1 (discussed in x6.1), shows the performance of a simple composition of sideeﬀectfree arithmetic functions. AWS Lambdaimposes a latency overhead of up to 20ms for a single function invocation, and this overhead compounds when composing func tions. AWS Step Functions, which automatically chains together sequences of operations, imposes an even higher penalty. Since the overheads compound linearly, the overhead of a call stack as shallow as 5 functions saturates tolerable limits for an interac tive service (100ms). Functional programming patterns for state sharing are not an option in current FaaS platforms. Direct Communication . FaaS oﬀerings disable inbound net work connections, requiring functions to communicate through highlatency storage services like S3 or DynamoDB. While pointtopoint communication may seem tricky in a system with dynamic membership, distributed hashtables (DHTs) or lightweight keyvalue stores (KVSs) can provide a lowerlatency solution than deep storage for routing messages between migra tory function instances [67, 78, 72, 71]. Current FaaS vendors do not oﬀer autoscaling, lowlatency DHTs or KVSs. Instead, as discussed inx1, FaaS applications resort to serverbased solutions for lowerlatency storage, like hosted Redis and memcached. LowLatency Access to Shared Mutable State . Recent stud ies [84, 37] have shown that latencies and costs of shared autoscal ing storage for FaaS are orders of magnitude worse than under lying infrastructure like shared memory, networking, or server based shared storage. Worse, the available systems oﬀer weak data consistency guarantees. For example, AWS S3 oﬀers no guarantees across multiple clients (isolation) or for inserts and deletes from a single client (atomicity). This kind of weak consistency can pro duce very confusing behavior. For example, simple expressions likef(x; g(x))may produce nondeterministic results: fandg are diﬀerent “clients”, so there is no guarantee about the versions ofxread by fandg. 2.2 Towards Stateful Serverless Logical Disaggregation with Physical Colocation . As a prin ciple, LDPC leaves signi/f_icant latitude for designing mechanisms and policy that colocate compute and data while preserving correctness. We observe that many of the performance bottle necks described above can be addressed by an architecture with distributed storage and local caching. A lowlatency autoscaling KVS can serve as both global storage and a DHTlike overlay network. To provide better data locality to functions, a KVS cache can be deployed on every machine that hosts function invocations. Cloudburst’s design includes consistent mutable caches in the compute tier ( x4). Consistency . Distributed mutable caches introduce the risk of cache inconsistencies, which can cause signi/f_icant developer con fusion. We could implement strong consistency across caches (e.g., linearizability) via quorum consensus (e.g., Paxos [51]). This of fers appealing semantics but has wellknown issues with latency and availability [14, 15]. In general, consensus protocols are a poor /f_it for the internals of a dynamic autoscaling framework: consensus requires /f_ixed membership, and membership (“view”) change involves highlatency agreement protocols (e.g., [12]). In stead, applications desiring strong consistency can employ a slow changing consensus service adjacent to the serverless infrastruc ture. Coordinationfree approaches to consistency are a better /f_it to the elastic membership of a serverless platform. Bailis, et al.[8] categorized consistency guarantees that can be achieved without coordination. We chose the Anna KVS [85] as Cloudburst’s storage engine because it supports all these guarantees. Like CvRDTs [75], Anna uses lattice data types for coordinationfreeconsistency. That is, Anna values oﬀer a merge operator that is insensitive to batching, ordering and repetition of requests— merge is associative, commutative and idempotent. Anna uses lattice composition [17] to implement consistency; Anna’s lattices are simple and composable as in Bloom [17]; we refer readers to [85] for more details. Anna also provides autoscaling at the storage layer, responding to workload changes by selectively replicating frequentlyaccessed data, growing and shrinking the cluster, and moving data between storage tiers (memory and disk) for cost savings [86]. However, Anna only supports consistency for individual clients, each with a /f_ixed IPport pair. In Cloudburst, a request likef(x; g(x))may involve function invocations on separate physical machines and requires consistency across functions—we term this distributed session consistency . Inx5, we provide protocols for various consistency levels. Programmability . We want to provide consistency without imposing undue burden on programmers, but Anna can only store values that conform to its latticebased type system. To address this, Cloudburst introduces lattice capsules (x5.2), which transparently wrap opaque program state in lattices chosen to support Cloudburst’s consistency protocols. Users gain the bene/f_its of Anna’s con/f_lict resolution and Cloudburst’s distributed session consistency without having to modify their programs. We continue with Cloudburst’s programmer interface. We re turn to Cloudburst’s design in x4 and consistency mechanisms in x5. 3. PROGRAMMING INTERFACE Cloudburst accepts programs written in vanilla Python1. An example client script to execute a function is shown in Figure 2. Cloudburst functions act like regular Python functions but trigger remote computation in the cloud. Results by default are sent di rectly back to the client (line 8), in which case the client blocks syn chronously. Alternately, results can be stored in the KVS, and the response key is wrapped in a CloudburstFuture object, which retrieves the result when requested (line 1112). Function arguments are either regular Python objects (line 11) or KVS references (lines 34). KVS references are transparently retrieved by Cloudburst at runtime and deserialized before invok ing the function. To improve performance, the runtime attempts to execute a function call with KVS references on a machine that might have the data cached. We explain how this is accomplished inx4.3. Functions can also dynamically retrieve data at runtime using the Cloudburst communication API described below. To enable stateful functions, Cloudburst allows programmers to putandgetPython objects via the Anna KVS API. Object serial ization and encapsulation for consistency ( x5.2) is handled trans parently by the runtime. In the common case, putandgetare fast due to the presence of caches at the function executors. For repeated execution, Cloudburst allows users to register arbi trary compositions of functions. We model function compositions as DAGs in the style of systems like Apache Spark [88], Dryad [42], Apache Air/f_low [2], and Tensor/f_low [1]. This model is also similar in spirit to cloud services like AWS Step Functions that automati cally chain together functions in existing serverless systems. Each function in the DAG must be registered with the system (line 4) prior to use in a DAG. Users specify each function in the DAG and how they are composed—results are automatically 1There is nothing fundamental in our choice of Python—we chose it simply because it is a commonly used highlevel language.Table 1: The Cloudburst object API. Users can interact with the key value store and send and receive messages. API Name Functionality get(key) Retrieve a key from the KVS. put(key, value) Insert or update a key in the KVS. delete(key) Delete a key from the KVS. send(recv, msg) Send a message to another executor. recv() Receive outstanding messages for this function. get_id() Get this function’s unique ID passed from one DAG function to the next by the Cloudburst runtime. The result of a function with no successor is either stored in the KVS or returned directly to the user, as above. Cloudburst’s resource management system ( x4.4) is responsible for scaling the number of replicas of each function up and down. Cloudburst System API . Cloudburst provides developers an in terface to system services— Table 1 provides an overview. The API enables KVS interactions via getandput, and it enables message passing between function invocations. Each function invocation is assigned a unique ID, and functions can advertise this ID to well known keys in the KVS. These unique IDs are translated into phys ical addresses and used to support direct messaging. Note that this process is a generalization of the process that is used for function composition, where results of one function are passed directly to the next function. We expose these as sepa rate mechanisms because we aimed to simplify the common case (function composition) by removing the hassle of communicating unique IDs and explicitly sharing results. In practice this works as follows. First, one function writes its unique ID to a preagreed upon key in storage. The second func tion waits for that key to be populated and then retrieves the /f_irst thread’s ID by reading that key. Once the second function has the /f_irst function’s ID, it uses the send API to send a message. When send is invoked, the executor thread uses a deterministic map ping to convert from the thread’s unique ID to an IPport pair. The executor thread opens a TCP connection to that IPport pair and sends a direct message. If a TCP connection cannot be estab lished, the message is written to a key in Anna that serves as the receiving thread’s “inbox”. When recv is invoked by a function, the executor returns any messages that were queued on its local TCP port. On a recv call, if there are no messages on the local TCP port, the executor will read its inbox in storage to see if there are any messages stored there. The inbox is also periodically read and cached locally to ensure that messages are delivered correctly. 4. ARCHITECTURE Cloudburst implements the principle of logical disaggregation with physical colocation (LDPC). To achieve disaggregation, the Cloudburst runtime autoscales independently of the Anna KVS. Colocation is enabled by mutable caches placed in the Cloudburst runtime for low latency access to KVS objects. Figure 3 provides an overview of the Cloudburst architecture. There are four key components: function executors, caches, function schedulers, and a resource management system. User re quests are received by a scheduler, which routes them to function executors. Each scheduler operates independently, and the system relies on a standard stateless cloud load balancer (AWS Elastic Load Balancer). Function executors run in individual processes that are packed into VMs along with a local cache per VM. The cache on each VM intermediates between the local executors and the remote KVS. All Cloudburst components are run in individual Figure 3: An overview of the Cloudburst architecture. Docker [21] containers. Cloudburst uses Kubernetes [49] simply to start containers and redeploy them on failure. Cloudburst system metadata, as well as persistent application state, is stored in Anna which provides autoscaling and fault tolerance. 4.1 Function Executors Each Cloudburst executor is an independent, longrunning Python process. Schedulers ( x4.3) route function invocation requests to executors. Before each invocation, the executor re trieves and deserializes the requested function and transparently resolves all KVS reference function arguments in parallel. DAG execution requests span multiple function invocations, and after each DAG function invocation, the runtime triggers downstream DAG functions. To improve performance for repeated execution (x3), each DAG function is deserialized and cached at one or more executors. Each executor also publishes local metrics to the KVS, including the executor’s cached functions, stats on its recent CPU utilization, and the execution latencies for /f_inished requests. We explain in the following sections how this metadata is used. 4.2 Caches To ensure that frequentlyused data is locally available, every function execution VM has a local cache, which executors con tact via IPC. Executors interface with the cache, not directly with Anna; the cache issues requests to the KVS as needed. When a cache receives an update from an executor, it updates the data lo cally, acknowledges the request, and asynchronously sends the re sult to the KVS to be merged. If a cache receives a request for data that it does not have, it asynchronously retrieves it from the KVS. Cloudburst must ensure the freshness of data in caches. A naive (but correct) scheme is for the Cloudburst caches to poll the KVS for updates, or for the cache to blindly evict data after a timeout. In a typical workload where reads dominate writes, this gener ates unnecessary load on the KVS. Instead, each cache periodically publishes a snapshot of its cached keys to the KVS. We modi/f_ied Anna to accept these cached keysets and incrementally construct an index that maps each key to the caches that store it; Anna uses this index to periodically propagate key updates to caches. Lattice encapsulation enables Anna to correctly merge con/f_licting key up dates (x5.2). The index itself is partitioned across storage nodes following the same scheme Anna uses to partition the key space, so Anna takes the index overhead into consideration when making autoscaling decisions. 4.3 Function Schedulers A key goal of Cloudburst’s architecture is to enable low latency function scheduling. However, policy design is not a main goal of this paper; Cloudburst’s scheduling mechanisms allow pluggable policies to be explored in future work. In this section, we describe Cloudburst’s scheduling mechanisms, illustrating their use withpolicy heuristics that enable us to demonstrate bene/f_its from data locality and load balancing. Scheduling Mechanisms . Schedulers handle requests to register or invoke functions. New functions are registered by storing them in Anna and updating a shared KVS list of registered functions. For new DAGs, the scheduler veri/f_ies that each function in the DAG exists before picking an executor on which to cache it. For single function execution requests, the scheduler picks an executor and forwards the request to it. DAG requests require more work: The scheduler creates a schedule by picking an ex ecutor for each DAG function—which is guaranteed to have the function stored locally—and broadcasts this schedule to all partic ipating executors. The scheduler then triggers the /f_irst function(s) in the DAG and, if the user wants the result stored in the KVS, returns a CloudburstFuture . DAG topologies are the scheduler’s only persistent metadata and are stored in the KVS. Each scheduler tracks how many calls it receives per DAG and per function and stores these statistics in the KVS. Finally, each scheduler constructs a local index that tracks the set of keys stored by each cache; this is used for the scheduling policy described next. Scheduling Policy . Our scheduling policy makes heuristic deci sions using metadata reported by executors, including cached key sets and executor load. We prioritize data locality when schedul ing both single functions and DAGs. If the function’s arguments have KVS references, the scheduler inspects its local cached key index and picks the executor with the most data cached locally—to take advantage of locality, the user must specify KVS references (x3). Otherwise, the scheduler picks an executor at random. Hot data and functions are replicated across many executor nodes via backpressure. The few nodes initially caching hot keys will quickly be saturated with requests and report high utilization (above 70%). The scheduler tracks this utilization and avoids overloaded nodes, picking new nodes instead. The new nodes will then fetch and cache the hot data, eﬀectively increasing the replication factor and hence the number of options the scheduler has for the next request containing a hot key. 4.4 Monitoring and Resource Management An autoscaling system must track system load and performance metrics to make eﬀective decisions. Cloudburst uses Anna as a substrate for metric collection. Each thread independently tracks an extensible set of metrics (described above) and publishes them to the KVS. The monitoring system asynchronously aggregates these metrics from storage and uses them for its policy engine. For each DAG, the monitoring system compares the incoming request rate to the number of requests serviced by executors. If the incoming request rate is signi/f_icantly higher than the request com pletion rate of the system, the monitoring engine will increase the resources allocated to that DAG function by pinning the function onto more executors. If the overall CPU utilization of the execu tors exceeds a threshhold (70%), then the monitoring system will add nodes to the system. Similarly, if executor utilization drops below a threshold (20%), we deallocate resources accordingly. We rely on Kubernetes to manage our clusters and eﬃciently scale the cluster. This simple approach exercises our monitoring mech anisms and provides adequate behavior (see x6.1.4). When a new node is allocated, it reads the relevant data and metadata (e.g., functions, DAG metadata) from the KVS. This al lows Anna to serve as the source of truth for system metadata and removes concerns about eﬃciently scaling the system. The heuristics that we described here are based on the existing dynamics of the system (e.g., node spin up time). We discuss potential advanced autoscaling mechanisms and policies as a part of Future Work (x8), which might draw more heavily on understand ing how workloads interact with our infrastructure. 4.5 Fault Tolerance At the storage layer, Cloudburst relies on Anna’s replication scheme for kfault tolerance. For the compute tier, we adopt the standard approach to fault tolerance taken by many FaaS plat forms. If a machine fails while executing a function, the whole DAG is reexecuted after a con/f_igurable timeout. The program mer is responsible for handling sideeﬀects generated by failed programs if they are not idempotent. In the case of an explicit program error, the error is returned to the client. This approach should be familiar to users of AWS Lambda and other FaaS plat forms, which provides the same guarantees. More advanced guar antees are a subject for future work ( x8). 5. CACHE CONSISTENCY As discussed in Section 3, Cloudburst developers can register compositions of functions as a DAG. This also serves as the scope of consistency for the programmer, sometimes called a “session” [80]. The reads and writes in a session together expe rience the chosen de/f_inition of consistency, even across function boundaries. The simplest way to achieve this is to run the entire DAG in a single thread and let the KVS provide the desired consistency level. However, to allow for autoscaling and /f_lexible scheduling, Cloudburst may choose to run functions within a DAG on diﬀerent executors—in the extreme case, each function could run on a separate executor. This introduces the challenge ofdistributed session consistency : Because a DAG may run across many machines, the executors involved in a single DAG must provide consistency across diﬀerent physical machines. In the rest of this section, we describe distributed session consis tency in Cloudburst. We begin by explaining two diﬀerent guar antees (x5.1), describe how we encapsulate userlevel Python ob jects to interface with Anna’s consistency mechanisms ( x5.2), and present protocols for the guarantees ( x5.3). 5.1 Consistency Guarantees A wide variety of coordinationfree consistency and isolation guarantees have been identi/f_ied in the literature. We focus on two guarantees here; variants are presented in x6.2 to illustrate proto col costs. In our discussion, we will denote keys with lowercase letters like k;kvis a version vof key k. We begin with repeatable read (RR) consistency. RR is adapted from the transactions literature [11], hence it assumes sequences of functions—i.e., linear DAGs. Given a readonly expression f(x; g(x)), RR guarantees that both fandgread the same version xv. More generally: Repeatable Read Invariant : In a linear DAG, when any func tion reads a key k, either it sees the most recent update to kwithin the DAG, or in the absence of preceding updates it sees the /f_irst version kvread by any function in the DAG2. The second guarantee we explore is causal consistency, one of the strongest coordinationfree consistency models [54, 56, 8]. In a nutshell, causal consistency requires reads and writes to respect Lamport’s “happensbefore” relation [50]. One key version kiin /f_luences another version ljif a read of kihappens before a write oflj; we denote this as ki!lj. Within a Cloudburst DAG, this 2Note that RR isolation also prevents reads of uncommitted ver sion from other transactions [11]. Transactional isolation is a topic for future work (x8).means that if a function reads lj, subsequent functions must not see versions of kthat happened before ki: they can only see ki, versions concurrent with ki, or versions newer than ki. Note that causal consistency does not impose restrictions on key versions read by concurrent functions within a DAG. For example, if func tionfcalls two functions, gandh(executed in parallel), and both gandhread key k, the versions of kread by gandhmay diverge. Prior work introduces a variety of causal building blocks that we extend. Systems like Anna [85] track causal histories of individual objects but do not track ordering between objects. Bolton causal consistency [9] developed techniques to achieve multikey causal snapshots at a single physical location. Cloudburst must support multikey causal consistency that spans multiple physical sites. Causal Consistency Invariant : Consider a function fin DAG Gthat reads a version kvof key k. Let Vdenote the set of key versions read previously by for by any of f’s ancestors in G. Denote the dependency set for fat this point as D=fdijdi!lj2Vg. The version kvthat is read by fmust satisfy the invariant kv6! ki2D. That is, kvis concurrent to or newer than any version of k in the dependency set D. 5.2 Lattice Encapsulation Mutable shared state is a key tenet of Cloudburst’s design ( x3), and we rely on Anna’s lattices to resolve con/f_licts from concurrent updates. Typically, Python objects are not lattices, so Cloudburst transparently encapsulates Python objects in lattices. By default, Cloudburst encapsulates each bare program value into an Anna last writer wins (LWW) lattice—a composition of an Annaprovided global timestamp and the value. The global times tamp is generated by each node in a coordinationfree fashion by concatenating the local system clock and the node’s unique ID. Anna merges two LWW versions by keeping the value with the higher timestamp. This allows Cloudburst to achieve eventual consistency: All replicas will agree on the LWW value that corre sponds to the highest timestamp for the key [82]. It also provides timestamps for the RR protocol below. In causal consistency mode, Cloudburst encapsulates each key kin a causal lattice—the composition of an Annaprovided vector clock [68] that identi/f_ies k’s version, a dependency set that tracks key versions that kdepends on, and the value. Each vector clock consists of a set of hid; clockipairs where the idis the unique ID of the function executor thread that updated k, and the clock is a monotonicallygrowing logical clock. Upon merge, Anna keeps the causal consistency lattice whose vector clock dominates. Vec tor clock vc1dominates vc2if it is at least equal in all entries and greater in at least one; otherwise, vc1andvc2are concurrent. If two vector clocks are concurrent, Anna merges the keys by: (1) creating a new vector clock with the pairwise maximum of each entry in the two keys’ vector clock; and (2) merging the depen dency sets and values via set union. In most cases, an object has only one version. However, to deencapsulate a causallywrapped object with multiple concurrent versions, Cloudburst presents the user program with one version chosen via an arbitrary but deter ministic tiebreaking scheme. Regardless of which version is re turned, the user program sees a causally consistent history; the cache layer retains the concurrent versions for the consistency protocol described below. Applications can also choose to retrieve all concurrent versions and resolve updates manually. 5.3 Distributed Session Protocols Distributed Session Repeatable Read . To achieve repeatable read, the Cloudburst cache on each node creates “snapshot” ver sions of each locally cached object upon /f_irst read, and the cacheAlgorithm 1 Repeatable Read Input: k,R 1: //kis the requested key; Ris the set of keys previously read by the DAG 2:ifk2Rthen 3: cache _version =cache:get _metadata (k) 4: ifcache _version ==NULL_cache _version ! = R[k]:version then 5: return cache:fetch _from _upstream (k) 6: else 7: return cache:get (k) 8:else 9: return cache:get _or_fetch (k) Figure 4: An illustration of a scenario in which two func tions executing on separate machines might unwittingly read causally inconsistent data. stores them for the lifetime of the DAG. When invoking a down stream function in the DAG, we propagate a list of cache addresses and version timestamps for all snapshotted keys seen so far. In order to maintain repeatable read consistency, the down stream executor needs to read the same versions of variables as read by the upstream executor. Algorithm 1 shows pseudocode for the process that downstream executors follow to ensure this. When such an executor in a DAG receives a read request for key k, it includes the prior version snapshot metadata in its request to the cache ( Rin Algorithm 1). If khas been previously read and the exact version is not stored locally, the cache queries the upstream cache that stores the correct version (line 5 in Algorithm 1). If the exact version is stored locally (line 7), we return it directly to the user. Finally, if the key has not been read thus far, we return any available version to the client (line 9). If the upstream cache fails, we restart the DAG from scratch. Finally, the last executor in the DAG (the “sink”) noti/f_ies all upstream caches of DAG completion, allowing version snapshots to be evicted. Distributed Session Causal Consistency . To support causal consistency in Cloudburst, we use causal lattice encapsulation and augment the Cloudburst cache to be a causally consistent store, implementing the bolton causal consistency protocol [9]. The protocol ensures that each cache always holds a “causal cut”: For every pair of versions ai; bjin the cache,69ak:ai!ak; ak! bj. Storing a causal cut ensures that key versions read by func tions executed on onenode (accessing a single causal cut) satisfy the causal consistency invariant discussed in Section 5.1. However, maintaining a causal cut within each individual cache is not suﬃcient to achieve distributed session causal consistency. Consider a DAG with two functions f(k)andg(l), which are ex ecuted in sequence on diﬀerent machines—Figure 4 illustrates the following situation. Assume freads kvand there is a dependency lu!kv. If the causalcut cache of the node executing gis unAlgorithm 2 Causal Consistency Input: k,R,dependencies 1: //kis the requested key; Ris the set of keys previously read by the DAG; dependencies is the set of causal dependencies of keys in R 2:ifk2Rthen 3: cache _version =cache:get _metadata (k) 4: // valid returns true if kcache _version 5: ifvalid (cache _version; R [k])then 6: return cache:get (k) 7: else 8: return cache:fetch _from _upstream (k) 9:ifk2dependencies then 10: cache _version =cache:get _metadata (k) 11: ifvalid (cache _version; dependencies [k])then 12: return cache:get (k) 13: else 14: return cache:fetch _from _upstream (k) aware of the constraint on valid versions of l,gcould read an old version lw:lw!lu, thereby violating causality. The follow ing protocol solves this challenge: In addition to shipping readset metadata (as in RR), each executor ships the set of causal depen dencies (pairs of keys and their associated vector clocks) of the read set to downstream executors. Caches upstream store version snapshots of these causal dependencies. For each key krequested, the downstream cache /f_irst checks whether the locallycached key’s vector clock is causally concur rent with or dominates that of the version snapshot stored at the upstream cache (lines 23 of Algorithm 2). If so, the cache re turns the local version (line 5); otherwise, it queries the upstream cache for the correct version snapshot (line 7). We perform the same check if the key being requested is in the set of dependen cies shipped from the upstream cache—if we have a valid version locally, we return it, and otherwise, we fetch a snapshot from the upstream cache (lines 813 of Algorithm 2). This protocol guaran tees that key versions read by functions executed across diﬀerent nodes (i.e., diﬀerent causal cuts) follow the causal consistency in variant, guaranteeing distributed session causal consistency. 6. EVALUATION We now present a detailed evaluation of Cloudburst. We /f_irst study the individual mechanisms implemented in Cloudburst (x6.1), demonstrating orders of magnitude improvement in latency relative to existing serverless infrastructure for a variety of tasks. Next we study the overheads introduced by Cloudburst’s consistency mechanisms ( x6.2), and /f_inally we implement and evaluate two realworld applications on Cloudburst: machine learning prediction serving and a Twitter clone ( x6.3). All experiments were run in the useast1a AWS availability zone. Schedulers were run on AWS c5.large EC2 VMs (2 vCPUs, 4GB RAM), and function executors were run on c5.2xlarge EC2 VMs (8 vCPUs, 16GB RAM); 2 vCPUs comprise one physical core. Function execution VMs used 3 cores for Python execution and 1 for the cache. Clients were run on separate machines in the same AZ. All Redis experiments were run using AWS Elasticache, using a cluster with two shards and three replicas per shard. 6.1 Mechanisms in Cloudburst In this section, we evaluate the primary individual mechanisms that Cloudburst enables—namely, lowlatency function composition (x6.1.1), local cache data accesses ( x6.1.2), direct communica tion (x6.1.3), and responsive autoscaling ( x6.1.4). 6.1.1 Function Composition To begin, we compare Cloudburst’s function composition over heads with other serverless systems, as well as a nonserverless baseline. We chose functions with minimal computation to iso late each system’s overhead. The pipeline was composed of two functions: square(increment(x:int)) . Figure 1 shows median and 99th percentile measured latencies across 1,000 requests run in serial from a single client. First, we compare Cloudburst and Lambda using a “stateless” application, where we invoke one function—both bars are labelled stateless in Figure 1. Cloudburst stored results in Anna, as dis cussed in Section 3. We ran Cloudburst with one function execu tor (3 worker threads). We /f_ind that Cloudburst is about 5 faster than Lambda for this simple baseline. For a composition of two functions—the simplest form of state fulness we support—we /f_ind that Cloudburst’s latency is roughly the same as with a single function and signi/f_icantly faster than all other systems measured. We /f_irst compared against SAND [4], a new serverless platform that achieves lowlatency function com position by using a hierarchical message bus. We could not deploy SAND ourselves because the source code is unavailable, so we used the authors’ hosted oﬀering [73]. As a result, we could not repli cate the setup we used for the other experiments, where the client runs in the same datacenter as the service. To compensate for this discrepancy, we accounted for the added clientserver latency by measuring the latency for an empty HTTP request to the SAND service. We subtracted this number from the endtoend latency for a request to our twofunction pipeline running SAND to esti mate the indatacenter request time for the system. In this setting, SAND is about an order of magnitude slower than Cloudburst both at median and at the 99th percentile. To further validate Cloudburst, we compared against Dask, a “serverful” opensource distributed Python execution framework. We deployed Dask on AWS using the same instances used for Cloudburst and found that performance was comparable to Cloud burst’s. Given Dask’s relative maturity, this gives us con/f_idence that the overheads in Cloudburst are reasonable. We compared against four AWS implementations, three of which used AWS Lambda. Lambda (Direct) returns results directly to the user, while Lambda (S3) and Lambda (Dynamo) store results in the corresponding storage service. All Lambda implementations pass arguments using the userfacing Lambda API. The fastest implementation was Lambda (Direct) as it avoided highlatency storage, while DynamoDB added a 15ms latency penalty and S3 added 40ms. We also compared against AWS Step Functions, which constructs a DAG of operations similar to Cloudburst’s and returns results directly to the user in a synchronous API call. The Step Functions implementation was 10slower than Lambda and 82 slower than Cloudburst. Takeaway : Cloudburst’s function composition matches stateof theart Python runtime latency and outperforms commercial server less infrastructure by 13 orders of magnitude. 6.1.2 Data Locality Next, we study the performance bene/f_it of Cloudburst’s caching techniques. We chose a representative task, with large input data but light computation: our function returns the sum of all ele ments across 10 input arrays. We implemented two versions on AWS Lambda, which retrieved inputs from AWS ElastiCache (us ing Redis) and AWS S3 respectively. ElastiCache is not an au80KB 800KB 8MB 80MB10100100010000Latency (ms)Cloudburst (Hot) Cloudburst (Cold)Lambda (Redis) Lambda (S3)Figure 5: Median and 99th percentile latency to calculate the sum 10 arrays, comparing Cloudburst with caching and without and AWS Lambda over Redis and AWS S3. We vary array lengths from 1,000 to 1,000,000 by multiples of 10 to demonstrate the eﬀects of increasing data retrieval costs. toscaling system, but we include it in our evaluation because it oﬀers bestcase latencies for data retrieval for AWS Lambda. We compare two implementations in Cloudburst. One version, Cloud burst (Hot) passes the same array in to every function execution, guaranteeing that every retrieval after the /f_irst is a cache hit. This achieves optimal latency, as every request after the /f_irst avoids fetching data over the network. The second, Cloudburst (Cold), creates a new set of inputs for each request; every retrieval is a cache miss, and this scenario measures worstcase latencies of fetching data from Anna. All measurements are reported across 12 clients issuing 3,000 requests each. We run Cloudburst with 7 function execution nodes. The Cloudburst (Hot) bars in Figure 5 show that system’s per formance is consistent across the /f_irst two data sizes for cache hits, rises slightly for 8MB of data, and degrades signi/f_icantly for the largest array size as computation costs begin to dominate. Cloud burst performs best at 8MB, improving over Cloudburst (Cold)’s median latency by about 10 , over Lambda on Redis’ by 25 , and over Lambda on S3’s by 79 . While Lambda on S3 is the slowest con/f_iguration for smaller inputs, it is more competitive at 80MB. Here, Lambda on Redis’ latencies rise signi/f_icantly. Cloudburst (Cold)’s median latency is the second fastest, but its 99th percentile latency is comparable with S3’s and Redis’. This validates the common wisdom that S3 is eﬃcient for high bandwidth tasks but imposes a high latency penalty for smaller data objects. However, at this size, Cloudburst (Hot)’s median latency is still 9 faster than Cloudburst (Cold) and 24faster than S3’s. Takeaway : While performance gains vary across con/f_igurations and data sizes, avoiding network roundtrips to storage services en ables Cloudburst to improve performance by 12 orders of magnitude. 6.1.3 LowLatency Communication Another key feature in Cloudburst is lowlatency communica tion, which allows developers to leverage distributed systems pro tocols that are infeasibly slow in other serverless platforms [37]. As an illustration, we consider distributed aggregation, the sim plest form of distributed statistics. Our scenario is to periodically average a /f_loatingpoint performance metric across the set of func tions that are running at any given time. Kempe et al. [46] devel oped a simple gossipbased protocol for approximate aggregation that uses random message passing among the current participants in the protocol. The algorithm is designed to provide correct an swers even as the membership changes. We implemented the al gorithm in 60 lines of Python and ran it over Cloudburst with 4 executors (12 threads). We compute 1,000 rounds of aggregation 02505007501000Latency (ms)Cloudburst (gossip) Cloudburst (gather) Lambda+Redis (gather) Lambda+S3 (gather)Figure 6: Median and 99th percentile latencies for dis tributed aggregation. The Cloudburst implementation uses a distributed, gossipbased aggregation technique, and the Lambda implementations share state via the respective keyvalue stores. Cloudburst outperforms communication through storage, even for a lowlatency KVS. with 10 actors each in sequence and measure the time until the result converges to within 5% error. The gossip algorithm involves repeated small messages, mak ing it highly ineﬃcient on stateless platforms like AWS Lambda. Since AWS Lambda disables direct messaging, the gossip algo rithm would be extremely slow if implemented via reads/writes from slow storage. Instead, we compare against a more natural approach for centralized storage: Each lambda function publishes its metrics to a KVS, and a predetermined leader gathers the pub lished information and returns it to the client. We refer to this algorithm as the “gather” algorithm. Note that this algorithm, un like [46], requires the population to be /f_ixed in advance, and is therefore not a good /f_it to an autoscaling setting. But it requires less communication, so we use it as a workaround to enable the systems that forbid direct communication to compete. We imple ment the centralized gather protocol on Lambda over Redis for similar reasons as in x6.1.2—although serverful, Redis oﬀers best case performance for Lambda. We also implement this algorithm over Cloudburst and Anna for reference. Figure 6 shows our results. Cloudburst’s gossipbased proto col is 3faster than the gather protocol using Lambda and Dy namoDB. Although we expected gather on serverful Redis to out perform Cloudburst’s gossip algorithm, our measurements show that gossip on Cloudburst is actually about 10% faster than the gather algorithm on Redis at median and 40% faster at the 99th percentile. Finally, gather on Cloudburst is 22 faster than gather on Redis and 53faster than gather on DynamoDB. There are two reasons for these discrepancies. First, Lambda has very high func tion invocation costs (see x6.1.1). Second, Redis is singlemastered and forces serialized writes, creating a queuing delay for writes. Takeaway : Cloudburst’s low latency communication mecha nisms enable developers to build fast distributed algorithms with /f_inegrained communication. These algorithms can have notable performance bene/f_its over workarounds involving even relatively fast shared storage. 6.1.4 Autoscaling Finally, we validate Cloudburst’s ability to detect and respond to workload changes. The goal of any serverless system is to smoothly scale program execution in response to changes in request rate. As described in x4.4, Cloudburst uses a heuristic policy that accounts for incoming request rates, request execution times, and executor load. We simulate a relatively computation ally intensive workload with a function that sleeps for 50ms. The function reads in two keys drawn from a Zip/f_ian distribution with coeﬃcient of 1.0 from 1 million 8byte keys stored in Anna, and it writes to a third key drawn from the same distribution.0 2 4 6 8 10 Time (minutes)0246ThroughputThroughput 0100200300Number of Replicas Number of ReplicasFigure 7: Cloudburst’s responsiveness to load changes. We start with 180 executor threads, issue requests from 60 clients, and measure throughput. Cloudburst quickly de tects load spikes and allocate more resources. Plateaus in the /f_igure are the wait times for EC2 instance startup. The system starts with 60 executors (180 threads) and one replica of the function deployed—the remaining threads are all idle. Figure 7 shows our results. At time 0, 400 client threads si multaneously begin issuing requests. The jagged curve measures system throughput (requests per second), and the dotted line tracks the number of threads allocated to the function. Over the /f_irst 20 seconds, Cloudburst takes advantage of the idle resources in the system, and throughput reaches around 3,300 requests per second. At this point, the management system detects that all nodes are saturated and adds 20 EC2 instances, which takes about 2.5 minutes; this is seen in the plateau that lasts until time 2.67. As soon as resources become available, they are allocated to our task, and throughput rises to 4.4K requests a second. This process repeats itself twice more, with the throughput ris ing to 5.6K and 6.7K requests per second with each increase in resources. After 10 minutes, the clients stop issuing requests, and by time 10.33, the system has drained itself of all outstanding re quests. The management system detects the sudden drop in re quest rate and, within 20 seconds, reduces the number of threads allocated to the sleep function from 360 to 2. Within 5 minutes, the number of EC2 instances drops from a max of 120 back to the original 60. Our current implementation is bottlenecked by the la tency of spinning up EC2 instances; we discuss that limitation and potential improvements in Section 8. We also measured the perkey storage overhead of the index in Anna that maps each key to the caches it is stored in. We observe small overheads even for the largest deployment (120 function ex ecution nodes). For keys in our working set, the median index overhead is 24 bytes and the 99th percentile overhead is 1.3KB, cor responding to keys being cached at 1.6% and 93% of the function nodes, respectively. Even if all keys had the maximum overhead, the total index size would be around 1 GB for 1 million keys. Takeaway : Cloudburst’s mechanisms for autoscaling enable policies that can quickly detect and react to workload changes. We are mostly limited by the high cost of spinning up new EC2 instances. The policies and cost of spinning up instances can be improved in future without changing Cloudburstś architecture. 6.2 Consistency Models In this section, we evaluate the overheads of Cloudburst’s consistency models. For comparison, we also implement and measure weaker consistency models to understand the costs involved in distributed session causal consistency. In particular, we evaluated singlekey causality and multikey causality , which are both weaker forms of causal consistency than the distributed session causality supported by Cloudburst. Singlekey causality tracks causal order of updates to individual keys (omitting Median 99th Percentile050100150Latency (ms)LWW DSRR SKMK DSCFigure 8: Median and 99th percentile latencies for Cloud burst’s consistency models, normalized by the depth of the DAG. We measure lastwriter wins (LWW), distributed session repeatable read (DSRR), singlekey causality (SK), multikey causality (MK), and distributed session causal consistency (DSC). Median latency is uniform across modes, but stronger consistency levels have higher tail latencies due to increased data and metadata overheads. the overhead of dependency sets). Multikey causality is an implementation of BoltOn Causal Consistency [9], avoiding the overhead of distributed session consistency. We populate Anna with 1 million keys, each with a payload of 8 bytes, and we generate 250 random DAGs which are 2 to 5 functions long, with an average length of 3. We isolate the la tency overheads of each consistency mode by avoiding expensive computation and use small data to highlight any metadata over heads. Each function takes two string arguments, performs a sim ple string manipulation, and outputs another string. Function ar guments are either KVS references—which are drawn from the set of 1 million keys with a Zip/f_ian coeﬃcient of 1.0—or the result of a previous function execution in the DAG. The sink function of the DAG writes its result to the KVS into a key chosen randomly from the set of keys read by the DAG. We use 8 concurrent benchmark threads, each sequentially issuing 500 requests to Cloudburst. We ran Cloudburst with 5 executor nodes (15 threads). 6.2.1 Latency Comparison Figure 8 shows the latency of each DAG execution under /f_ive consistency models normalized by the longest path in the DAG. Median latency is nearly uniform across all modes, but perfor mance diﬀers signi/f_icantly at the 99th percentile. Lastwriter wins has the lowest overhead, as it only stores the 8byte timestamp associated with each key and requires no re mote version fetches. The 99th percentile latency of distributed session repeatable read is 1.8 higher than lastwriter wins’. This is because repeated reference to a key across functions requires anexact version match; even if the key is cached locally, a version mismatch will force a remote fetch. Singlekey causality does not involve metadata passing or data retrieval, but each key maintains a vector clock that tracks the causal ordering of updates performed across clients. Since the size of the vector clock grows linearly with the number of clients that modi/f_ied the key, hot keys tend to have larger vector clocks, lead ing to higher retrieval latency at the tail. Multikey causality forces each key to track its dependencies in addition to maintaining the vector clock, adding to its worstcase latency. We observe that the median perkey causal metadata (vector clock and dependency set) storage overhead is 624 bytes and the 99th percentile overhead is 7.1KB. Techniques such as vector clock compression [59] and de pendency garbage collection [54] can be used to reduce the meta data overhead, which we plan to explore in future work.Table 2: The number of inconsistencies observed across 4,000 DAG executions under Cloudburst’s consistency levels relative to what is observed under LWW. The causal levels are increasingly strict, so the numbers accrue incrementally left to right. DSRR anomalies are independent. Inconsistencies Observed LWW Causal DSRR SK MK DSC 0 904 939 1043 46 Distributed session causal consistency incurs the cost of pass ing causal metadata along the DAG as well as retrieving version snapshots to satisfy causality. In the worst case, a 5function DAG performs 4 extra network roundtrips for version snapshots. This leads to a 1.7slowdown in 99th percentile latency over single and multikey causality and a 9 slowdown over lastwriter wins. Takeaway : Although Cloudburst’s nontrivial consistency mod els increase tail latencies, median latencies are over an order of mag nitude faster than DynamoDB and S3 for similar tasks, while pro viding stronger consistency. 6.2.2 Inconsistencies Stronger consistency models introduce overheads but also pre vent anomalies that would arise in weaker models. Table 2 shows the number of anomalies observed over the course of 4000 DAG executions run in LWW mode, tracking anomalies for other levels. The causal consistency levels have increasingly strict criteria; anomaly counts accrue with the level. We observe 904 singlekey (SK) causal inconsistencies when the system operates in LWW mode. With singlekey causality, two concurrent updates to the same must both be preserved and returned to the client. LWW simply picks the largest timestamp and drops the other update, leading to a majority of observed anomalies. Multikey (MK) causality /f_lagged 35 additional inconsistencies corresponding to singlecache read sets that were not causal cuts. Distributed session causal consistency (DSC) /f_lagged 104 more inconsisten cies where the causal cut property was violated across caches. Repeatable Read (DSRR) /f_lagged 46 anomalies. Takeaway : A large number of anomalies arose naturally in our experiments and the Cloudburst consistency model was able to detect and prevent these anomalies. 6.3 Case Studies In this section, we discuss the implementation of two realworld applications on top of Cloudburst. We /f_irst consider lowlatency prediction serving for machine learning models and compare Cloudburst to a purposebuilt cloud oﬀering, AWS Sagemaker. We then implement a Twitter clone called Retwis, which takes advantage of our consistency mechanisms, and we report both the eﬀort involved in porting the application to Cloudburst as well as some initial evaluation metrics. 6.3.1 Prediction Serving ML model prediction is a computationally intensive task that can bene/f_it from elastic scaling and eﬃcient sparse access to large amounts of state. For example, the prediction serving infrastruc ture at Facebook [34] needs to access peruser state with each query and respond in real time, with strict latency constraints. Furthermore, many prediction pipelines combine multiple stages 05001000Latency (ms)Python Cloudburst Lambda (Mock) AWS Sagemaker Lambda (Actual)Figure 9: Cloudburst compared to native Python, AWS Sage maker, and AWS Lambda for serving a prediction pipeline. 10204080160 Number of Threads0200400600800Latency (ms) 0 40 80 120 160 Number of Threads50100150Throughput Figure 10: A measure of the Cloudburst’s ability to scale a simple prediction serving pipeline. The blue whiskers rep resent 95th percentile latencies, and the black represent the 99th percentile. of computation—e.g., clean the input, join it with reference data, execute one or more models, and combine the results [18, 52]. We implemented a basic prediction serving pipeline on Cloud burst and compare against a fullymanaged, purposebuilt predic tion serving framework (AWS Sagemaker) as well as AWS Lambda. We also compare against a single Python process to measure seri alization and communication overheads. Lambda does not support GPUs, so all experiments are run on CPUs. We use the MobileNet [41] image classi/f_ication model imple mented in Tensor/f_low [1] and construct a threestage pipeline: resize an input image, execute the model, and combine features to render a prediction. Qualitatively, porting this pipeline to Cloudburst was easier than porting it to other systems. The native Python implementation was 23 lines of code (LOC). Cloudburst required adding 4 LOC to retrieve the model from Anna. AWS SageMaker required adding serialization logic (10 LOC) and a Python webserver to invoke each function (30 LOC). Finally, AWS Lambda required signi/f_icant changes: managing serializa tion (10 LOC) and manually compressing Python dependencies to /f_it into Lambda’s 512MB container limit3. The pipeline does not involve concurrent modi/f_ication to shared state, so we use the default last writer wins for this workload. We run Cloudburst with 3 workers, and all experiments used a single client. Figure 9 reports median and 99th percentile latencies. Cloud burst is only about 15ms slower than the Python baseline at the median (210ms vs. 225ms). AWS Sagemaker, ostensibly a purpose built system, is 1.7slower than the native Python implementa tion and 1.6slower than Cloudburst. We also measure two AWS Lambda implementations. One, AWS Lambda (Actual), computes a full result for the pipeline and takes over 1.1 seconds. To better understand Lambda’s performance, we isolated compute costs by removing all data movement. This result (AWS Lambda (Mock)) 3AWS Lambda limits disk space to 512MB. Tensor/f_low exceeds this limit, so we removed unnecessary components. We do not report LOC changed as it would arti/f_icially in/f_late the estimate.0.02.55.07.510.0Latency (ms)Cloudburst (LWW) Cloudburst (Causal)RedisFigure 11: Median and 99th percentile latencies for Cloud burst in LWW and causal modes and Retwis over Redis. 10 20 40 80160 Number of Threads0510Latency (ms) 0 40 80 120 160 Number of Threads510152025Throughput (K ops/s) Figure 12: Cloudburst’s ability to scale the Retwis workload up to 160 worker threads. is much faster, suggesting that the latency penalty is incurred by the Lambda runtime passing results between functions. Nonethe less, AWS Lambda (Mock)’s median is still 44% slower than Cloud burst’s median latency and only 9% faster than AWS Sagemaker. Figure 10 measures throughput and latency for Cloudburst as we increase the number of worker threads from 10 to 160 by factors of two. The number of clients for each setting is set tobworkers 3cbecause there are three functions executed per client. We see that throughput scales linearly with the number of workers. We see a climb in median and 99th percentile latency from 10 to 20 workers due to increased potential con/f_licts in the scheduling heuristics. From this point on, we do not a signi/f_icant change in either median or tail latency until 160 executors. For the largest deployment, only one or two executors need to be slow to signi/f_icantly raise the 99th percentile latency—to validate this, we also report the 95th percentile latency in Figure 10, and we see that there is a minimal increase between 80 and 160 executors. Takeaway: An ML algorithm deployed on Cloudburst delivers both smooth scaling and low, predictable latency comparable to na tive Python, outperforming a purposebuilt commercial service. 6.3.2 Retwis Web serving workloads are closely aligned with Cloudburst’s features. For example, Twitter provisions server capacity of up to 10x the typical daily peak in order to accommodate unusual events such as elections, sporting events, or natural disasters [33]. Fur thermore, causal consistency is a good model for many consumer internet workloads because it matches enduser expectations for information propagation: e.g., Google has adopted it as part of a universal model for privacy and access control [64]. To this end, we considered an example web serving workload. Retwis [69] is an open source Twitter clone built on Redis and is often used to evaluate distributed systems [77, 40, 91, 19, 87]. Conversational “threads” like those on Twitter naturally exercise causal consistency: It is confusing to read the response to a post (e.g., “lambda!”) before you have read the post it refers to (“whatcomes after kappa?”). We adapted a Python Retwis implementa tion called retwispy [70] to run on Cloudburst and compared its performance to a vanilla “serverful” deployment on Redis. We ported Retwis to our system as a set of six Cloudburst functions. The port was simple: We changed 44 lines, most of which were removing references to a global Redis variable. We created a graph of 1000 users, each following 50 other users (zipf=1.5, a realistic skew for online social networks [60]) and pre populated 5000 tweets, half of which were replies to other tweets. We compare Cloudburst in LWW mode, Cloudburst in causal consistency mode, and Retwis over Redis; all con/f_igurations used 10 executor threads (webservers for Retwis), 1 KVS node, and 10 clients. Each client issues 5000 requests—10% PostTweet (write) requests and 90% GetTimeline (read) requests. Figure 11 shows our results. Median and 99th percentile laten cies for LWW mode are 27% and 2% higher than Redis’, respec tively. This is largely due to diﬀerent code paths; for Retwis over Redis, clients communicate directly with web servers, which inter act with Redis. Each Cloudburst request interacts with a scheduler, a function executor, a cache, and Anna. Cloudburst’s causal mode adds a modest overhead over LWW mode: 4% higher at the median and 20% higher at the tail. However, causality prevents anomalies on over 60% of requests—when a timeline returns a reply without the original tweet—compared to LWW mode. Figure 12 measures throughput and latency for Cloudburst’s causal mode as we increase the number of function executor threads from 10 to 160 by factors of two. For each setting, the number of clients is equal to the number of executors. From 10 threads to 160 threads, median and the 99th percentile latencies increase by about 60%. This is because increased concurrency means a higher volume of new tweets. With more new posts, each GetTimeline request forces the cache to query the KVS for new data with higher probability in order to ensure causality—for 160 threads, 95% of requests incurred cache misses. Nonetheless, these latencies are well within the bounds for interactive web applications [35]. Throughput grows nearly linearly as we increase the executor thread count. However, due to the increased latencies, throughput is about 30% below ideal at the largest scale. Takeaway: It was straightforward to adapt a standard social net work application to run on Cloudburst. Our implementation adds a modest overhead to the serverful Redis baseline and scales smoothly as the workload increases. 7. RELATED WORK "
447,DRUG: An Energy-Efficient Data-Centric Routing Protocol for Wireless Sensor Networks.txt,"In general, sensor nodes are deployed in left unattended area. In such
situation feeding energy to the batteries or replacing the batteries is
difficult or even sometimes impossible too. Therefore, prolonging the network
lifetime is an important optimization goal in this aspect. In this paper, we
propose a new Energy-efficient Datacentric RoUtinG protocol called DRUG. In
this paper, we propose an adaptive Data centric approach to find an optimal
routing path from source to sink when the sensor nodes are deployed randomly
deployed in a restricted service area with single sink. Using the NS-2
Simulator, we compare the performance of DRUG with that of the FLOODING and
SPIN protocol.","In recent times, the increase in the low cost sensor node design and ﬂexibity has led to an increase in the development of and the demand for rich wireless sensor network (WSN) applications[1, 2]. Efﬁcient design and implementation of WSNs has become a hot area of research in recent years. By networking a large numbers of tiny sensor nodes, it is possible to obtain realtime data about any physical phenomena, that were difﬁcult or impossible to obtain in conventional ways of networking. Hence a typical WSNs application is combined different software and hardware module to sense the physical data, processing data and communicates those data to a remote site or base station through multiple hops or nodes. Sometimes, instead of sending the raw data to the nodes responsible for the fusion, they use their processing abilities to locally carry out simple computations and transmit only the required and partially processed data [3]. In WSNs, energy is one of the major issue, which need to be carefully consumed by the sensor nodes to maximize the network lifetime. Hence, most of the current researchers are engaged to devise a way to minimize the energy consumption in the network to maximize the network lifetime. Generally the sensor nodes inorder are powered by small batteries which are incapable to power for a long period. Typically, the sensors nodes are deployed in a left unattended area. So, it is quite difﬁcult to replace the battery frequently and even sometimes not possible. Therefore, prolonging the network lifetime is an important optimization goal in this aspect. The secret to reduce energy consumption lies in power aware designing of each layer of the system and number of messagetransmission for data packet. As a consequence, the reduction of number of message transmission can reﬂects in energy uaseg of the nodes. The WSNs suffer from several constraints and challenges; some of those are: limited onboard memory and limited processing capability of the sensor nodes, limited communication bandwidth, frequent death of sensor nodes, link failure, mobility in sensor, heavy trafﬁc through some particular nodes etc. In a multihop ad hoc sensor network, each node plays the twins role of data originator and data router. The failure of few nodes may lead to topological changes and hence require rerouting of the data packets. To resolve the issue of excess energy consumption, many energyefﬁcient protocols have been proposed to reduce energy consumption such as SMAC [4], LEACH [5], CLEEP [6], SPIN [7] and etc. Many MAC protocols have been focused to avoid the collision between two nodes and minimizing the idle listening; but ignore the route discovery and maintenance issues. Hence, the literal challenging task, do not fulﬁll, which in turn results inefﬁcient energy consumption. This paper introduces a novel adaptive approach to ﬁnd an optimal routing path from source to sink when the sensor nodes are deployed randomly deployed in a restricted ser vice area with single sink. This also aggregate the data in intermediate node to reduce the duplicate data. Data centric protocols more focus on data rather than the address of the destination. Here our approach focus on both data as well as the destination address. The proposed protocol is hierarchical in nature. The work looks at a unique approach for a scalable and energy efﬁcient solution. The proposed protocol has been evaluated by performance analysis with the existing protocol FLOODING and SPIN. The rest of the paper is organized as follows: Section II mentions some related works. Section III, describes the proposed protocol in detail. Section IV presents the simulation results and Section V summarizes the paper with a conclusion of the work. II. R ELATED WORK "
310,Can NDN Perform Better than OLSR in Wireless Ad Hoc Networks?.txt,"The emerging paradigm of Information-Centric Networking is an exciting field
of research, opening opportunities in many areas, such as forwarding
strategies, caching placement policies, applications (e.g. video streaming and
instant messaging), to name a few. In this paper, we address the mobility
aspect of ICN, as well as how it performs in tactical wireless ad hoc
environments. In this paper, we present results from a simulation study that
investigates the performance of Named Data Networking, an instantiation of ICN,
in such environments. We perform a series of simulations based on ndnSIM
studying different mobility scenarios. Our simulations show that even in the
short-term absence of the producer, consumers can still achieve better file
retrieval when caches are used. As an effort to increase the cache diversity
and have a better utilization of the Content Store we study probabilistic LRU.
Furthermore, we compare the performance of our NDN network with a TCP based
approach, using OLSR routing protocol, discussing advantages and disadvantages
of each approach.","The Internetis constantlyevolving, from circuitswitchi ng topacketswitching, tocontentdistribution, whichcopew ith the increasingly amount of content transferred over the In ternet. In recent years, several proposals for a new Interne t architecture have arisen. Among the most successful con cepts is InformationCentric Networking (ICN), which pro motes a profound change by reusing some of TCP/IP’s suc cessful ideas while ﬁxing its shortcomings. One of the most signiﬁcant diﬀerences in ICN is the addressing of content by name instead of an address. This is, e.g., the case in Named Data Networking (NDN) [6] – a speciﬁc architecture design of ICN. Permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided that copies ar e not made or distributed for proﬁt or commercial advantage and that copies bear this n otice and the full cita tion on the ﬁrst page. Copyrights for components of this work owned by others than ACMmustbehonored. Abstractingwithcreditispermitted. T ocopyotherwise,orre publish, to post on servers or to redistribute to lists, requ ires prior speciﬁc permission and/or a fee. Requestpermissionsfrom permissions@acm.or g. c/circlecopyrt2021 ACM.ISBN 9781450321389. DOI:10.1145/1235Initially, content is located on the producer1end, where it is permanently stored. The consumer initiates Interest requests, which are forwarded via NDN routers towards the producer. In contrast to IP routers their NDN equivalents contain a Pending Interest Table (PIT) and a Content Store (CS) in addition tothe Forwarding Information Base. When an NDN router forwards an Interest, it creates an entry in the PIT and forwards the Interest based on the FIB. When the router receives the Data packet, it removes the PIT en try, forwards the Data to the appropriate faces, and store a copy of the Data in the CS. Therefore, whenever a diﬀer ent node requests the same Data, any router that has the content stored can serve the request. This type of pervasive innetwork caching is an interest ing feature for mobile ad hoc networks (MANET), as nodes frequently move in and out of communication range. Any node in possession of the requested content can serve the request without the need of retrieving it from the source. We are interested in a special case of MANETs where the mobile nodes have scarce resources, e.g., battery operated radios with limited transmission power, resulting in a lowe r communication range. Networks with this characteristics are called disconnected, intermittent, lowbandwidth (DI L). In this paper, we compare the performance of NDN with Optimized LinkState Routing(OLSR)[1], a wireless ad hoc routing protocol designed to reduce the ﬂooding of messages in the wireless media by selecting speciﬁc nodes, called mul  tipoint relays (MPRs), to rebroadcast packets. We simulate both protocols in a mesh network using NS3 [10] and ndnSIM [8] for OLSR and NDN, respectively. The main goal of the simulations is to evaluate the strengths and weaknesses of NDN in comparison to OLSR in a MANET scenario. Wespeciﬁcally simulatecases ofnetworkpartiti on ing and random mobility, since both represent important characteristics of MANETs. In the case of network parti tioning, we investigate if the intrinsic caching character istics of NDN will impact overall performance in cases where the consumer can not communicate with the producer. In the random mobility case, we investigate if NDN’s innetwork caching will improve performance compared to an OLSR based approach. WefurtherstudythecachingstrategiesintheNDNrouters, aiming to enhance the data delivery and cache utilization. Wemakeuseofprobabilisticleastrecentused(PLRU)cachin g algorithm. The main contributions of this paper are the following: 1We use the terms producer, custodian, and source inter changeably from now on to refer to the content producer 1•We show that NDN performance in wireless ad hoc networks still needs improvements if we compare to OLSR. •Weevaluateprobabilistic cachingas astrategyinNDN routers. •Broadens the discussion of NDN forwarding strategies for wireless ad hoc networks. The remainder of this paper is organized as follows: Sec tion 2 introduces our research goals, Section 3 discusses re  lated work, Sections 4 present the simulation scenarios. We present an evaluation of our simulation cases in Section 5. Section 6 summarizes and concludes the paper. 2. MOTIVATION In MANETs, nodes are moving and may go in and out of communication range, making it burdensome to establish a endtoend path. TCP/IP based protocols were not initially designed to handle this problem. The existing approaches rely on a rendezvous mechanism to track node mobility [14] inordertomovedatatowards thereceiver. Anotherproblem in wireless ad hoc networks is the shared media. Existing protocols reduce the probability of collisions by scheduli ng transmission, reducing the number of broadcast nodes, or a combination of both, to name a few. The pervasive innetwork caching in NDN, may makes it easier to move content towards the receiver while reducing the probability of collisions in the network. This reductio n is caused by the ”merging”of requests in NDN routers. E.g., when a NDNrouter receives a newInterest, it checks its PIT and if the Interest is already pending, the router does not forward the Interest, reducing traﬃc in the network. Also, NDN routers check if the requested Data is in its Content Store. Cached content will also reduce collisions since it a s not to be sent all the way from the source of the content. Our hypothesis is that because NDN routers suppress broadcasts in the aforementioned cases, it will outperform OLSR in our simulated network. 3. RELATED WORK "
437,An Anonymous Overlay Routing Protocol for Uplink-Intensive Applications.txt,"Sender anonymity in network communication is an important problem, widely
addressed in the literature. Mixnets, combined with onion routing, represent
certainly the most concrete and effective approach achieving the above goal. In
general, the drawback of these approaches is that anonymity has a price in
terms of traffic overhead and latency. On the Internet, to achieve scalability
and not to require relevant infrastructure and network-protocol changes, only
P2P overlay protocols can be adopted. Among these, the most representative
proposal is certainly Tarzan, which is designed to obtain strong anonymity
still preserving low-latency applications. In recent years, we are witnessing a
change in Internet traffic. Due to IoT, cloud storage, WSN, M2M, uplink traffic
is more and more increasing. An interesting question is whether this new
traffic configuration may enable new strategies to improve the effectiveness of
Tarzan-like approaches. In this paper, we investigate this problem, by
proposing \textit{C-Tarzan}, an anonymous overlay P2P routing protocol. Through
a deep experimental analysis, we show that C-Tarzan outperforms Tarzan in the
case of uplink-intensive applications.","Anonymity in network communication is a widely investigated problem [23]. Obviously, it is not sucient to hide the content of exchanged messages, as data related to trac carry out sensitive information per se. Thus, anonymous communication networks (ACNs) aim to oer a certain degree of unobservabil ity of communication in the network, not just message condentiality. The most known and used anonymous protocol is Tor [11]. However, as wellknown, anonymity is easily broken under even weak threat models [14]. A challenging goal is to guarantee robust sender anonymity because it is enough to achieve relationship anonymity [19]. For robust, we mean that both passive sniers and malicious participants cannot distinguish whether a node generates a message or simply relays it. 1arXiv:2208.14920v1  [cs.NI]  31 Aug 2022The most eective approaches existing in the literature achieving the above goal are based on the concept of mixnet [7] including cover trac. Mixnet protocols rely on intermediate servers (called mixnodes ) that mix the messages coming from dierent sources to hide the relationship between the incoming messages to and the outcoming messages from the mixnodes. When cover trac is included in mixnets, serious problems of trac overhead may arise. While a wide literature regarding mixnets exists, a few proposals mixnetbased oriented to a concrete Internet (lowlatency) implementation of the notion of mixnet, including cover trac, are available. Among these, if we refer to P2P approaches (thus not requiring infrastructure changes), the most meaningful proposal is certainly Tarzan [12]. Despite its age, Tarzan is the only eective proposed anonymous routing protocol guaranteeing low latency even in large scale Internet scenarios. In deed, the protocol allows a client to anonymously contact a server through a tunnel whose length is independent of the number of nodes participating in the peertopeer network. As a matter of fact, Tarzan implements a peertopeer overlay network at IP layer, in which peers collaborate with each other to im plement anonymous tunnels through which a client may reach a proxy node (called PNAT) from which the server is reached. Another advantage of Tarzan with respect to recent stateoftheart approaches is that, unlike the emerging mixnets that adopt centralized and explicit shuing nodes ([20]), the peerto peer approach makes the solution more robust against possible attacks on the nodes of the route (or their collusion). Indeed, all the nodes of the network are potentially sender or relay nodes and then there are no few explicit targets for the attacker. The most recent (and representative) approach using a peer topeer overlay network is [22]. However, [22] does not work at IP layer and, moreover, the length of each communication path is log n , wherenis the num ber of nodes of the network. Therefore, unlike Tarzan, the latency is growing with the number of nodes. Hence, the protocol is not suitable for lowlatency applications when the number of users scales at huge values, as may happen in Internet scenarios. The aim of this paper is to understand whether the change of type of Internet trac due to various reasons (emerging applications for IoT, M2M, cloud, etc.), for which uplink trac is more and more increasing [18, 28, 21, 4], might allow us to nd some improvement to the Tarzan approach to make it more suitable to the new scenario. The study conducted in this paper leads to the denition of a new P2P overlay anonymous protocol, called C(yclic)Tarzan , which outperforms Tarzan in the case of uplinkintensive applications. The core idea is that the topology of the overlay network allows us to set in the network just unidirectional cover trac instead of the bidirectional trac required in Tarzan. Our study is based on the wellknown trilemma, called the anonymity trilemma [9], which states the existence of a tradeo between three metrics: the anonymity set size, the latency, and the cover trac level. Specically, we show that for uplinkintensive applications, by xing the same latency and the same cover trac volume, CTarzan oers a greater anonymity set size than Tarzan. 2The paper is organized as follows. In Section 2, we investigate the related literature. In Section 3, we provide the background notions about the Tarzan protocol. Next, in Section 4, we compare Tarzan with a sketched idea of our solution, by highlighting what motivated us to investigate in this direction. The detailed protocol is presented in Section 5. We perform an analytical study of the latency in Tarzan and CTarzan in Section 6 and provide an experimental validation of our approach in Section 7. Finally, in Section 8, we draw our conclusion. 2 Related Work "
153,Stop_times based Routing Protocol for VANET.txt,"Vehicular Ad hoc Network (VANET) is a special class of Mobile Ad hoc Network
(MANET) where vehicles are considered as MANET nodes with wireless links. The
key difference of VANET and MANET is the special mobility pattern and rapidly
changeable topology. There has been significant interest in improving safety
and traffic efficiency using VANET. The design of routing protocols in VANET is
important and necessary issue for support the smart ITS. Existing routing
protocols of MANET are not suitable for VANET. AOMDV is the most important on
demand multipath routing protocol. This paper proposes SSD-AOMDV as VANET
routing protocol. SSD-AOMDV improves AOMDV to suit VANET characteristics.
SSD-AOMDV adds the mobility parameters: Stop_times, Speed and Direction to hop
count as new AOMDV routing metric to select next hop during the route discovery
phase. Stop_times metric is added to simulate buses mobility pattern and
traffic lights at intersections. Simulation results show that SSD-AOMDV
achieves better performance compared to AOMDV.","Nowadays, the safety of motor vehicle has been paid more and  more attention by the whole society. The increasing problem of  accident and traffic jam necessitates the adoption of Intelligent  Transportation Systems (ITS). A Vehicular Ad Hoc network is  a form of Mobile ad hoc Networks MANETs, to provide  communication among nearby vehicles and between vehicles  and nearby fixed equipment i.e. roadside equipment as in Fig.  1. In a VANET, the vehicles are considered as nodes. Vehicle  velocitie s are also restricted according to speed limits, level of  congestion in roads, and traffic control mechanisms (e.g., stop  signs and traffic lights). Future vehicles can be equipped with  devices have longer transmission ranges. Rechargeable source  of energy , extensive on board storage capacities and processing  power are not issues in VANET as they are in MANET. The  main goal of VANET is providing safety and comfort for  passengers. Besides safety applications VANET also provide  comfort applications to the roa d users. For example, weather  information, mobile e commerce, Internet access and other  multimedia applications. The vehicles of a VANET are  equipped with the DSRC (Dedicated Short Range  Communication). Vehicles can move along the same road way  and transmi t information or receive ¬¬¬¬ information. Each  vehicle equipped with VANET device will be a node in the  Adhoc network and can receive & relay other messages  through the wireless network. VANET is one of the influencing  areas for the improvement of ITS in  order to provide safety and comfort to the road users. Collision warning and in place traffic  view will give the driver essential tool to decide the best path  along the way.   MANET and VANET are characterized by the movement and  self organization of nodes.  The key difference of VANET and  MANET is the special mobility pattern and rapidly changeable  topology of VANET.  Also, MANET nodes cannot recharge  their battery power where VANET has no power constraint for  nodes.     Fig. 1: VANET communication   The design of effective vehicular communications poses a  series of technical challenges. Guaranteeing a stable and  reliable routing mechanism over VANETs is an important step  toward the realization of effective vehicular communications.  One of the critical issues con sists of the design of scalable  routing algorithms that are robust to frequent path disruptions  caused by vehicles’ mobility. Existing routing protocols, which  are traditionally designed for MANET, do not make use of the  unique characteristics of VANETs an d are not suitable for  vehicle tovehicle communications over VANETs. Topology  based and position based routing is two strategies of data  forwarding commonly adopted for multi hop wireless networks  [1], [2]. Topology based protocols use the information of  available network links for packet transmission. Every node  has to maintain the routing table. Position based protocols  assume that every node is aware of the location of itself, the  location of neighbouring nodes, and the location of the  destination node.  With the increasing availability of GPS  equipped vehicles, Position based Protocol is getting more  convenient. However, position based protocols developed for  MANETs may not directly be applied to vehicular  environments, due to the unique vehicular networ k  characteristics.   International Journal of Computer Applications (0975 – 8887)   Volume 81 – No 18, November 2013   5 One good way of data forwarding in VANET is to modify  MANET routing protocols and make it suitable for vehicular  environment. There are many routing protocols for ad hoc  networks [3], [4], [5]. One of the most well known is AODV  [6], [7 ], [8], [9]. Ad hoc On demand Multipath Distance  Vector Routing (AOMDV) protocol is an extension to AODV  protocol for computing multiple loop free and link disjoint  paths [10].   This paper proposes SSD AOMDV as VANET routing  protocol. AOMDV is the most imp ortant on demand multipath  routing protocol. SSD AOMDV improves AOMDV to suit  VANET characteristics. SSD AOMDV adds the mobility  parameters: stop_ times, speed and direction to hop count as  new AOMDV routing metric to select next hop during the  route disco very phase.  Simulation results show that SSD  AOMDV achieves better performance compared to AOMDV.   The remainder of this paper is structured as follows. Section II  introduces AOMDV routing protocol. Section III surveys the  related researches conducted in enhancing MANET routing  protocols for V2V communication. Section IV introduces the  proposed scheme SSD AOMDV. Section V presents the  simulation results and discussions. The paper is concluded in  Section VI.   2. RELATED WORKS   "
372,Performance of RPL in Healthcare Wireless Sensor Network.txt,"The new advances of the Internet of Things (IoT) technology can be utilized
to promote service delivery in several real-life applications such as
healthcare systems. The Routing Protocol for Low Power and Loss Network (RPL)
is a routing protocol designed to serve as a proper routing protocol for
packets in Wireless Sensor Networks (WSN). Among the most prominent issues
exist in the RPL protocol are packet loss within the WSN and sensors power
consumption especially in healthcare WSNs. Multiple Objective Functions (OF) in
RPL intended to find the routes from source nodes to a destination node. This
paper presents an evaluation to discover which OF is more efficient for a WSN
in a healthcare scenario where the Packet Delivery Ratio (PDR) of WSN and the
sensors' power consumption are prominent concerns. Expected transmission Count
(ETX) and Objective Function Zero (OF0) of RPL were examined in various network
densities and network topologies such as the grid and random topology. The
simulation outcomes revealed that the OF0 is more efficient regarding the PDR
and power consumption compared to the ETX in random","The expanded use of smart technologies such Big Data, Cloud  computing, and Internet of Things (IoT) that makes users more  dependent on computers and networks. Newly, the IoT has  impacted every aspect of human life and industries such as  healthcare, smart grid, and smart homes which all achieved  through the Wireless Sensor Network (WSN) [1]. The WSN  can be outlined as a set of sensors that are employed in the  sense or monitor particular physical or biochemical aspects  without the involvement of human[2],[3]. The routing in WSN relies on RPL protocol, where RPL protocol is designed to be an interoperable and simple protocol for the interconnected IoT sensors or devices (resourceconstrained) to be exploited in manufacturing,  hospitals, and smart homes [4]. RPL forms a topology  comparable to a tree where each sensor or node in the network  has an been assigned with a rank, in which it grows as  the nodes move faraway from the root node. The RPL  specifies the route based on routing metrics and restrictions  that should be applied to attain specific purposes which can be  achieved by the RPL through the use of OFs. For instance, the  OF may designate with the aim of finding the shortest path  where the constraint is associated with the node power  consumption [5],[ 6]. In RPL OF0 is intended to attain the nearest grounded root  where that could be accomplished only if the node rank is  determined by the degree its adjacency to the root node. This  demand can be estimated with the other needs of having other path options, which can be realized by improving the node rank [7]. Another objective function is the EXT, where this OF  relies on the number of the retransmissions ratio of the packet  to be delivered successfully within WSN. The RPL supports  the application of OF to create route paths that can be  controlled by a routing metric. This designation defined by  ETXOF to reduces the ETX. The computation of the path is  based on ETXOF where it occurs in minimumETX paths to  the DAG roots from the nodes, where such path can lead  to  reducing the packet transmissions times from nodes in the  WSN to the DAG root [8],[9]. The ETX is viewed as a link  measure for predicting the transmissions of the packet to be  delivered to destination through acquiring the most suitable  path and anticipating the retransmissions number for the  packet to be received. To decide which OF is more efficient when implementing the  RPL protocol for the PDR metric, which can be estimated the  number of successfully transmitted packets by the root node  where it is also correlated to the number transmitted packets by  clients. The higher the percentage of PDR means the efficient  routing protocol regarding the delivered packet ratio[10], [11].  Moreover, the power consumption metric must be considered,  where IoT network or WSN devices are resources constrained  devices such as sensors in terms of power or processing.  Therefore, the long lifetime nodes in WSN have directed to  finding out distinct extents for using a specific implementation  of RPL to consider preserving the nodes' consumption of  power[12],[13]. To improve the sensor node's power  endurance, protocols must be efficient in term of energy Performance of RPL in Healthcare Wireless Sensor Network Bassam AlShargabi1, Mohammed Aleswid2 1Department of Computer Science, Middle East University, Amman, Jordan 1bshargabi@meu.edu.jo, bassam20_152@yahoo.com 2mohmad.aliswid@hotmail.comthrough performing prior actions by assessing and foretelling  the  nodes power consumption degree [14],[15].  In a healthcare system where the IoT or WSN is a major  component, choosing which objective function to be used is a  major dilemma. Therefore, this paper presents an experimental  evaluation of ETX and OF0 objective function of RPL to  evaluate their effectiveness regarding power consumption and  PDR in a healthcare scenario under different topologies. The rest of the paper organized as follows: section 2 outlines  the most recent related work. The elaboration of the  performance evaluation is presented in section 3. Results and  discussion are outlined in section 4. Finally, the conclusion  and future work are drawn in Section 5 2. R ELATED WORK "
395,A Testbed Implementation for Securing OLSR in Mobile Ad hoc Networks.txt,"Contemporary personal computing devices are increasingly required to be
portable and mobile enabling user's wireless access, to wired network
infrastructures and services. This approach to mobile computing and
communication is only appropriate in situations where a coherent infrastructure
is available. There are many situations where these requirements are not
fulfilled such as; developing nations, rural areas, natural disasters, and
military conflicts to name but a few. A practical solution is to use mobile
devices interconnected via a wireless medium to form a network, known as a
Mobile Ad-hoc Network (MANET), and provide the services normally found in wired
networks. Security in MANETs is an issue of paramount importance due to the
wireless nature of the communication links. Additionally due to the lack of
central administration security issues are different from conventional
networks. For the purposes of this article we have used the ""WMN test-bed"" to
enable secure routing in MANETs. The use of cryptography is an efficient proven
way of securing data in communications, but some cryptographic algorithms are
not as efficient as others and require more processing power, which is
detrimental to MANETs. In this article we have assessed different cryptographic
approaches to securing the OLSR (Optimised Link State Routing) protocol to
provide a basis for research. We conclude the paper with a series of
performance evaluation results regarding different cryptographic and hashing
schemes. Our findings clearly show that the most efficient combination of
algorithms used for authentication and encryption are SHA-1 and AES
respectively. Using this combination over their counterparts will lead to a
considerable reduction in processing time and delay on the network, creating an
efficient transaction moving towards satisfying resource constraints and
security requirements.","Mobile Adhoc NETworks (MANETs) are a grouping of m obile devices connected wirelessly  in an adhoc fashion to form a coherent network str ucture enabling devices not directly  connected and geographically separated to communica te and share resources using multihop  routing. The applications of MANETs are ideally sui ted to situations where a coherent network  infrastructure is unavailable or nonexistent, such as for military use in the field of operations or  for use by medical staff in third world countries w here the infrastructure does not exist. Another  important application for MANETs is in emergency si tuations [1] such as terrorist attacks where  the infrastructure is unavailable.   Due to the dynamic nature of MANETs with nodes join ing and leaving frequently, routing  protocols are essential to maintain an uptodate p icture of the MANETS topology. The  MANET routing protocols enable nodes to discover ro utes to nodes they wish to communicate  with by maintaining information regarding other nod es in the network. Common protocols used International Journal of  Network Security & Its Ap plications (IJNSA), Vol.2, No.4, October 2010     142   in wired networks are inefficient for MANETs so ded icated protocols have been developed.  Primarily two types of routing protocols are used, proactive  and reactive . Proactive protocols  such as the Optimized Link State Routing (OLSR) [2] , [3] protocol, proactively maintain routes  between nodes and route information by propagating route updates thorough the network. In  contrast, reactive routing protocols only institute  r o u t e s  o n  r e q u e s t ,  a n  e x a m p l e  o f  t h i s   architecture is the Adhoc Ondemand Distance Vecto r (AODV) [4], the Dynamic source  routing (DSR) [4] and the Dynamic MANET Ondemand ( DYMO) [5] protocols.  In this paper taking advantage of the strength of S ecurity Architecture for the Internet Protocol  (IPSec) [7] we have secured the MANET routing proto col using our testbed named WMN. We  have actually used a hybrid version of the IPSec pr otocol, which includes both Authentication  Header (AH) and Encapsulating Security Payload  (ESP) modes, as proposed in [8], to provide  a green solution  in regards to the energy consumption security s olu tion for MANETs. These  two modes of IPSec guarantee integrity, authenticat ion and confidentiality for the MANET  communication links. More precisely, authentication  a n d  i n t e g r i t y  a r e  s a t i s f i e d  b y  t h e  A H   protocol that utilises a hash algorithm along with a symmetric Advanced Encryption Standard  (AES) [11] key to produce a Hash Message Authentica tion Code (HMAC). For the ESP  protocol we have used 128bit symmetric keys becaus e AES is one of the fastest and  cryptographically strongest algorithms. Based on re search published in [9], only the transport  mode of the IPSec protocol has been used in our tes tbed since it has been proven appropriate  for MANETs.  The key objectives of this paper are the following:   • Discussion of the most important issues about secur ity in MANETs.  • Discussion of the most crucial security benefits of  t h e  h y b r i d  m o d e l  o f  I P S e c  i n   MANETs.  • Description of the WMN testbed  s o f t w a r e  a n d  c e r t a i n l y  o f  t h e  s e c u r i t y   implementation for MANETs.  • Evaluation of the WMN testbed  results in terms of overhead that each mechanism  introduces to MANETs.  2. BACKGROUND   2.1. Related Work  "
6,"Optimizing Cost, Delay, Packet Loss and Network Load in AODV Routing Protocol.txt","AODV is Ad-hoc On-Demand Distance Vector.A mobile ad-hoc network is a
self-configuring network of mobile devices connected by wireless. MANET does
not have any fixed infrastructure. The device in a MANET is free to move in any
direction and will form the connection as per the requirement of the network.
Due to changing topology maintenance of factors like Packet loss, End to End
Delay, Number of hops, delivery ratio and controlling the network load is of
great challenge. This paper mainly concentrates on reducing the factors such as
cost, End-to-End Delay, Network Load and Packet loss in AODV routing protocol.
The NS-2 is used for the simulation purpose.","  Mobile AdHoc network mainly concentrates on wirele ss  communication without any fixed infrastructure. Wir eless  communication has wide application in Security zone s .In  past there is only a fixed wireless communication n etwork  exists where communication range is bonded. Now the re  advanced AdHoc network and Mobile AdHoc network  are introduced where all nodes share data among  themselves. The nodes in AODV may connect and leave   the network at any time [10].All AdHoc routing pro tocol  have different routing strategies so factors such a s End to  End Delay, Traffic Overhead and packet delivery rat io and  power consumption gets vary .Routing mainly deals w ith  the route discovery between the source and destinat ion  [4].Nodes in network change the position as per  requirement of system so topology varies time to ti me. The  routing Protocols are mainly divided in to Routing and  Reactive Protocol. Proactive routing protocols (e.g .OLSR)  are tabledriven. Linkstate algorithms maintain a full or  partial copy of the network topology and costs for all  known links. The reactive routing protocols (e.g. A ODV)  create and maintain routes only if these are needed , on    demand. They usually use distancevector routing  algorithms that keep only information about next ho ps to  adjacent neighbors and costs for paths to all known   destinations. Thus, linkstate routing algorithms a re more  reliable, less bandwidthintensive, but also more c omplex  and compute and memoryintensive. AODV routing  protocol is a reactive routing protocol. AODV is a related   to   the BellmanFord distant vector algorithm. In AODV a  route to a destination is determined when a node wa nts to  send a packet to that destination. Routes are maint ained as  long as they are needed by the source. When the pac ket is  transmitted from source to destination there are ma ny  nodes involved between the successful receptions of   packets. ADOV routing protocol uses RouteRequest  (RREQ) RouteReply (RREP) and RouteError (RERR) as a   control signal. When a source node desires to send a  message to some destination node and does not have a  valid route to that destination it looks for a Path  to locate  the other node. Source node sends a RREQ packet to its    neighbors, which then forward the request to their  neighbors, and the process go on until route to the   destination is located [2]. During the process of f orwarding  the RREQ, the entry of intermediate nodes get recor d in to  their routing tables which include the address of t he  neighbors from which the first copy of the broadcas t  packet is received. This will help to find a path. If in case  some additional copies of the same RREQ are receive d  later than these packets are discarded. Once the RR EQ  reaches the destination node, the destination or  intermediate node responds by sending a RREP packet   back to the neighbor from which it first received t he  RREQ. When packet transmission is in progress vario us  factors play measure role .It is observed that pack et may  get drop in between due to bad linkage quality and lack of  proper communication channel between the nodes.  Sometimes communication gets successful but the bac kend  factors such as End to End delay, Power consumption ,  Routing overhead and hop limit really makes the net work  really costly and unreliable one. In AODV the routi ng (IJCSIS) International Journal of Computer Science and Information Security,   Vol. 11, No. 4, April 2013      table plays the important role. The route table inc ludes the  entry at each node with the information regarding t he  sequence number for IP address of destination node.  The  RREQ, RREP and RERR commands are received by node  utilized for the updating of the sequence number. T he  destination node can increment its sequence number when  there is time for source node to start a route sear ch or  when there is time for destination node to generate  the  RREP message against the RREQ response of source  node. In routing table the route gets updated with new  sequence numbers when it is higher than the destina tion  sequence numbers. There are other two possibilities , the  first one is when the new sequence number and  destination sequence numbers are equal but if sum  number of hop plus one additional one hop in new  sequence routing table is smaller than hop count in  the  existing destination sequence number and secondly w hen  the existing sequence number is unknown.  The rest of this paper is ordered as follows. The r elated  works are discussed in Section II, Section III repr esents  working of AODV routing protocol and Section IV giv es  idea regarding the proposed work. Section V gives d etail  of   simulation results and its discussion. Section  VI  provides conclusion   and future work whereas secti on VII  represents References.    II. RELATED WORK  "
148,Hybrid-BCP: A Robust Load Balancing and Routing Protocol for Intra-Car Wired_Wireless Networks.txt,"With the emergence of connected and autonomous vehicles, sensors are
increasingly deployed within cars to support new functionalities. Traffic
generated by these sensors congest traditional intra-car networks, such as CAN
buses. Furthermore, the large amount of wires needed to connect sensors makes
it harder to design cars in a modular way. To alleviate these limitations, we
propose, simulate, and implement a hybrid wired/wireless architecture, in which
each node is connected to either a wired interface or a wireless interface or
both. Specifically, we propose a new protocol, called Hybrid-Backpressure
Collection Protocol (Hybrid-BCP), to efficiently collect data from sensors in
intra-car networks. Hybrid-BCP is backward-compatible with the CAN bus
technology, and builds on the BCP protocol, designed for wireless sensor
networks. Hybrid-BCP achieves high throughput and shows resilience to dynamic
network conditions, including adversarial interferences. Our testbed
implementation, based on CAN and ZigBee transceivers, demonstrates the load
balancing and routing functionalities of Hybrid-BCP and its resilience to DoS
attacks. We further provide simulation results, obtained with the ns-3
simulator and based on real intra-car RSSI traces, that compare between the
performance of Hybrid-BCP and a tree-based collection protocol. Notably, the
simulations show that Hybrid-BCP can achieve the same performance as the
tree-based protocol while reducing the radio transmission power by a factor of
10.","The conventional intracar communication model, in which sensors communicate with Electronic Control Units (ECUs) via CAN buses, faces several limitations. First, the increa sing amount of wires required to connect sensors to the intracar network results in fuel inefﬁciency and complicates car des ign andmaintenance[1].Second,newsensorsgeneratesadditio nal trafﬁc and increases the likelihood of congestion on the CAN bus.Last,sincetheCANprotocolisbasedonmessagepriorit y, it is vulnerable to DenialofService (DoS) attacks genera ted by highpriority messages [2]. To alleviate limitations of intracar wired networks, we pr o pose in this work a hybrid wired/wireless network architect ure for supporting intracar communication. A key goal in this context is to achieve reliable and efﬁcient delivery of pack ets from the sensors to a sink (ECU), a task also known as data collection . The design of such a hybrid network brings up several research issues. The ﬁrst issue is how to implement routing. For instance, in the hybrid network of Fig. 1, packets destin ed from node 2 to the sink can be routed either through node 7 or node 9. Which node should be chosen as the next hop? The second issue is how to implement load balancing. For instance, node 10 can communicate with the sink either on 14  12  13  11  10   0  5  6  4  7  8  3  9  1  2  Fig. 1: A 15node intracar hybrid wired/wireless network. Eachnodeisconnectedtoeitherawiredinterfaceora wirele ss interface or both. The data packets of the sensor nodes (114 ) need to be delivered to the sink (node 0). the wired interface or the wireless interface. Which interf ace should be used? The third issue is how to deal with contention from other nodes and (possibly malicious) interferences. For instanc e, how should node 10 react if node 4 is contending on the wired link? And what happensif an adversaryperformsa DoS attack? In light of these challenges, we deﬁne the following objec tives for designing a collection protocol for hybrid intra car networks: •Load balancing. The protocol should balance packet transmissions over available interfaces. •Routing. In the absence of a direct communication link between a sensor node and the sink, the protocol should deliver the packets of the sensor node in a multihop fashion. •Robustness. The protocol should achieve reliable data collection even when link qualities degrade (e.g., due to contention, interferences, or DoS attacks). •Backwardcompatibility The protocol should not require the replacement of existing technology(e.g., CAN buses) in vehicles. Routing protocols based on the construction and mainte nance of endtoend routes adapt poorly to intracar wirele ss channel conditions that typically experience deep fading a nd high variability [3]. To address these issues, we propose a new data collection protocol for hybrid intracar networks, called HybridBCP . HybridBCP belongs to the class of backpressure algorithms [3], which have theoretically been proven to be throughput optimal.2 HybridBCP does not calculate endtoend routes. Rather it relies on a distributed computation of backpressure weights . Each node maintains a backpressure weight on each interface for each of its neighbors, based on the link quality and the differential of the queue lengths. For each incoming packet , a node selects the interface/neighbor combination with the highest positive backpressure weight as the next hop. If all the backpressure weights are negative, then the node stores the packet in its queue and waits until one of the backpressur e weights becomes positive. We implement HybridBCP on a real testbed, composed of CAN and ZigBee transceivers, and evaluate its performance. Our testbed experiments demonstrate the load balancing and routing functionalities of HybridBCP. The results show th at HybridBCP improves throughput under DoS attacks on the CAN bus by a factor of 10. They also show that HybridBCP is robust to jamming attacks on wireless links. We further implement HybridBCP in ns3 for the purpose of simulating a larger network. We compare HybridBCP with a treebased collection protocol, which we refer to as Hybrid Collection Tree Protocol (HybridCTP) . HybridCTP relies on the computation and update of endtoend routing metrics at each node. For the simulations, we use real RSSI (received signal strength indication) traces collected in an intracar envi ron ment [4]. The simulation results demonstrate that Hybrid BCP achieves higher reliability than HybridCTP if both protocolsusethesamepowertransmission(e.g.,95%vs88%) . Conversely, HybridBCP can reduce the radio transmission power by a factor of 10 and still achieve the same reliability as HybridCTP. We summarize the contributions of this paper as follows: •We design a new protocol, HybridBCP, for data collec tion in intracar hybrid wired/wireless networks. •We build a real testbed for evaluating the performance of HybridBCP. The tests demonstrate the load balanc ing and routing functionalities of HybridBCP and its resilience to DoS attacks. •We implement HybridBCP and HybridCTP in the ns 3 simulator, and compare their performance in terms of reliability for different transmission powers. The rest of the paper is organized as follows. Section II reviews related work on hybrid wired/wireless networks, lo ad balancing algorithms for multiple interfaces, and collect ion protocols. Section III describes the HybridBCP protocol a nd its software implementation. Section IV and V provide per formance evaluation of HybridBCP in testbed experiments and simulations, respectively. Finally, Section VI conclu des the paper and discusses future research directions. II. RELATED WORK "
236,Routing Complexity of Faulty Networks.txt,"One of the fundamental problems in distributed computing is how to
efficiently perform routing in a faulty network in which each link fails with
some probability. This paper investigates how big the failure probability can
be, before the capability to efficiently find a path in the network is lost.
Our main results show tight upper and lower bounds for the failure probability
which permits routing, both for the hypercube and for the $d-$dimensional mesh.
We use tools from percolation theory to show that in the $d-$dimensional mesh,
once a giant component appears -- efficient routing is possible. A different
behavior is observed when the hypercube is considered. In the hypercube there
is a range of failure probabilities in which short paths exist with high
probability, yet finding them must involve querying essentially the entire
network. Thus the routing complexity of the hypercube shows an asymptotic phase
transition. The critical probability with respect to routing complexity lies in
a different location then that of the critical probability with respect to
connectivity. Finally we show that an oracle access to links (as opposed to
local routing) may reduce significantly the complexity of the routing problem.
We demonstrate this fact by providing tight upper and lower bounds for the
complexity of routing in the random graph $G_{n,p}$.","The goal of this paper is to investigate the effectiveness of routing in faulty networks. Suppose that a network is represented by a graph G. Two kinds of fault models are common in the theoretical lite rature: Worst case faults and random faults which are our concern. In the random fault model it is assumed that each component of the network fails with some probability an d independently of all other components. In thispaper weconsider edgefailures soweassumeeachedgein Gfailsindependently withsomeprobability q= 1−p. LetGpbetheresulting graph. Onecanaskwhatistheprobability th at twonodes uandvremain connected in Gp. This had been the focus of much research concerning the exis tence ofgiant components in such graphs, and the critical values of pfor the existence of those, cf. [1, 30, 20, 2, 23]. But in many applications thefact that apathbetween uand vexistsisnot sufﬁcient, onewants tobeable to ﬁndthepath ina distributed manner. It is known that if the topology of a graph has some randomness , then the existence of short paths in a graphdoesnotguaranteetheabilityofefﬁcientlyﬁndingth em. Forinstanceacyclewitharandommatching has alogarithmic diameter [6], yet paths connecting agiven pair of nodes can not be found in less than√n time[21]. Thisphenomenon isespeciallyacutewhenconside ring ‘natural’ networkssuchastheworldwide web, social networks, P2P networks etc, in which typically t he network size is huge, the diameter of the network is small and the challenge is to ﬁnd short paths withi n a time complexity that is comparable to the diameter. Indeed Kleinberg’s model of the small world pheno menon [21, 22], is aimed at explaining the ability to ﬁndshort paths in social networks (and not merely their existen ce). In the context of P2P several randomized topologies were proposed along with routing alg orithms that ﬁnd short paths in the random graph cf. [5,15,26]. Inthecontext of P2Pnetworks, manyrou ting algorithm areable toﬁndpaths between nodes even when nodes or links fail cf. [18, 29, 32]. While our ﬁndings do not apply directly to these networks, weexpect that are main result would hold for them a swell. SeeSection 1.3 for more details. In this paper we analyze the algorithmic complexity of ﬁndin g a path between nodes u,vinGpas a function of the failure probability. In particular weseek t oﬁnd the exact values of pfor which it is possible to perform routing in Gpwithin time complexity that is comparable to the diameter. O ne difﬁculty is that with positive probability u,vare in distinct components of Gp. We therefore restrict our attention to the case where agiant component exists, and condition onthe eve nt thatu,vareconnected. Our ﬁndings present a complex picture. We show that for some g raphs, as the d−dimensional mesh, efﬁcient routing is always possible, i.e. it is easy to ﬁnd wi th high probability short paths between nodes withinthegiant component (whenever itexists). However,f or other graphs, suchasthehypercube, efﬁcient routingispossibleonlyforsomefailureprobabilities. In otherwords,thereisarangeoffailureprobabilities for which with high probability a giant component exists, th e diameter of the giant component is small, yet in order to ﬁnd a path between nodes it is necessary to probe a l arge portion of the graph. We provide tight upper and lower bounds onthe routing complexity, indicatin g the exact location of the transition. 1.1 The Model Deﬁnition1. Givenagraph Gpand twovertices u,v, arouting algorithm isan algorithm that isallowed to probewhether an edge exists in Gp, and outputs a path between u,vif such exists. A routing algorithm is said to be local, if the ﬁrst edge it probes is adjacent to uand subsequently it probes only edges to (an end point of) which it hasalready established a path from u. Local algorithms aimtocapture therealistic constraints o f routing inanetwork. Ifeach nodeisaserver in a network and uwishes to send a message to vthenumust ﬁnd a path to vwhile probing edges it has 1already reached. In Section 5 we show that a local router may r equireexponentially more probes than a non local one, thus the distinction between the two kinds of a lgorithms is necessary. A non local routing algorithm may be referred to as an oraclerouting algorithm. Denote by {u∼v}the event that uis indeed connected to v. Deﬁnition2. Givenagraph G,probability pandaroutingalgorithm A,theroutingcomplexity ofAdenoted bycomp(A), with respect to the nodes u,v, is the random variable that counts the queries Amakes (i.e. edges probed) to ﬁndapath between u,vinGp,conditioned on {u∼v}. The routing complexity measures how many probesare needed to route a message from utovinGp, assuming this routing is possible. We do not consider here an y computations that the algorithm performs. Asindicatedabove,thequestion ismostinteresting when Pr[u∼v]isboundedawayfromzero,andindeed we limit our discussion to this case. A simple upperbound on t he routing complexity could be achieved by performing a BFS search on Gp. In terms of the routing complexity this is tantamount to pro bing the entire graph. However there may exist algorithms which achi eve a much smaller routing complexity. In particular, if the diameter of Gis small, we are interested in ﬁnding a routing algorithm wit h a complexity that iscomparable to the actual distance between the nodes, or show that none exists. We stress that the routing complexity measures the expected complexity of ﬁnding a path between two speciﬁed vertices, and does not necessarily indicate th e difﬁculty of performing a full blown routing scheme. Small routing complexity may be seen as the minimal r equirement of fault tolerance in networks. Naturally such a weak requirement strengthens our lower bou nds and weakens our upper bounds. In this paperwefocusonanalyzingthehypercubeandthe d−dimensionalgrid,whichareprobablythemostwidely investigated topologies in this context. 1.2 Related Work "
252,Scalable Downward Routing for Wireless Sensor Networks and Internet of Things Actuation.txt,"In this paper, we study the downward routing for network control/actuation in
large-scale and heterogeneous wireless sensor networks (WSNs) and Internet of
Things (IoT). We propose the Opportunistic Source Routing (OSR), a scalable and
reliable downward routing protocol for WSNs/IoT. OSR introduces opportunistic
routing into traditional source routing based on the parent set of a node's
upward routing in data collection, significantly addressing the drastic link
dynamics in low-power and lossy WSNs. We devise a novel adaptive Bloom filter
mechanism to effectively and efficiently encode a downward source-route in OSR,
which enables a significant reduction of the length of source-route field in
packet header. OSR is scalable to very large-size WSN/IoT deployments, since
each resource-constrained node in the network only stores the set of its direct
children. The probabilistic nature of the Bloom filter passively explores
opportunistic routing. Upon a delivery failure at any hop along the downward
path, OSR actively performs opportunistic routing to bypass the obsolete/bad
link. We demonstrate the desirable scalability of OSR against the standard RPL
downward routing. We evaluate the performance of OSR via both simulations and
real-world testbed experiments, in comparison with the standard RPL (both
storing mode and non-storing mode), ORPL, and the representative dissemination
protocol Drip. Our results show that OSR significantly outperforms RPL and ORPL
in scalability and reliability. OSR also achieves significantly better energy
efficiency compared to TinyRPL and Drip which are based on the same TinyOS
platform as OSR implementation.","Wireless sensor networks (WSNs) and Internet of Things (IoT) have been increasingly applied to various areas such as environmental monitoring, structure monitoring, smart buildings, smart cities, pre cision agriculture, and ehealth systems. Data collection is the basic application scenario in WSNs, where sensor nodes periodically sam ple and transmit data packets upward to one or multiple network sink(s). On the other hand, delivering control packets downward from the sink to individual sensor/actuator nodes is also essential in many WSN/IoT application scenarios, including actuating target actuator(s), reconfiguring node parameters (e.g., sampling rate), and querying data from specific node(s). However, the WSN downward routing is significantly less studied than WSN upward routing. The major downstream protocols, such as Drip [ 39], Glossy [ 8], andOpportunistic Flooding [ 12], are flooding based and disseminate control packets to the entire network. The lack of ability in address ing individual node(s) in those dissemination protocols makes them inefficient and impractical for network actuation in lowpower and largescale WSN/IoT deployments. The standard RPL, the IPv6 routing protocol for lowpower and lossy networks [ 42], offers the capacity of downward routing, but it has been found that RPL has several significant flaws in its down ward pointtomultipoint communication (e.g.,[ 4,6,13,14,17–21]). RPL essentially suffers from the severe scalability problem for down ward routing [ 4,13,14,21]. In RPL storing mode, a node stores routing entries for all destinations in its subgraph/subtree, poten tially suffering from severe scalability and reliability problem in large WSNs. On the other hand, RPL nonstoring mode uses source routing [ 16] through the sink/root, which suffers from not only increased risk of packet fragmentation and thus increased battery power and network capacity consumption, but also the scalability issue of the possible length of route in a network, given constrained wireless layers, such as IEEE 802.15.4 with a maximum frame size of 127 bytes (including header) [ 34]. Moreover, it seems that RPL (nonstoring mode) might not effectively fix any unreachable fail ure in downward routing due to wireless link dynamics. Although recent approaches such as ORPL [ 7] and CBFR [ 30] attempted to address the scalability issue of downward routing, these improve ments are limited for highly resourceconstrained wireless devices (see [ 14], for example). Indeed, it is increasingly urgent to systemat ically study scalable, reliable and resourceefficient WSN/IoT down ward routing for emerging largescale and resourceconstrained WSN/IoT system. Source routing includes the sourceroute information in the packet header to route packets from the source node to destination without building and maintaining routing tables at intermediate nodes. However, a direct application of source routing (e.g., RPL nonstoring mode) to WSN/IoT downward routing is problematic. First, the dynamic nature of WSNs significantly affects the reliabil ity of the traditional source routing. The specified sourceroute of a control packet may be obsolete and therefore unavailable when the packet arrives at an intermediate node due to wireless link dynamics. Second, the traditional source routing does not scale well in WSNs, because physical layer protocols of WSNs are designed to have a small frame size (e.g., IEEE 802.15.4 [ 34]) for energy efficiency. As the network diameter and hence the path length increases, contain ing the full sourceroute in a packet is inefficient and may even be infeasible. Thus, a desirable and practical source routing protocol in WSNs/IoT must simultaneously satisfy the requirements of reliabil ity under a highly dynamic wireless communication environment and scalability for very large WSN/IoT deployments.arXiv:1802.03898v1  [cs.NI]  12 Feb 2018Figure 1: A conceptual illustration of downward packet de livery with OSR versus RPL/ORPL/CBFR. In this work, we present an Opportunistic Source Routing proto col, referred to as OSR, to achieve desirable scalability and reliability for heterogeneous WSN/IoT actuation. Our approach is leveraged on the recent new WSN capability of the reconstruction of upward routing paths [ 10,24,25], where individual upstream data packet paths from WSN nodes to the sink can be reconstructed at the sink with a minimal overhead of path encoding piggybacking to each data packet and updated in every data collection cycle. Our designed OSR protocol introduces opportunistic routing into the source routing, which is based on the parent set [ 27] of a node’s upward routing, to exploit alternative downward paths to address wireless link dynamics. We devise a novel adaptive Bloom filter mechanism to efficiently encode and compress the sourceroute path. The probabilistic nature of the Bloom filter passively enables opportunistic routing for downward packet forwarding. In addition, when a downward link between a parent node and its child node is broken, active opportunistic routing is activated to find one or more other parent(s) in the child’s parent set to continue the downward forwarding. OSR only requires that each node store its direct child set rather than its entire subgraph of descendants as in RPL (storing mode) or in ORPL (compressed entire subgraph) for making down ward routing decision, and therefore, OSR is extremely scalable for constrained WSN/IoT sensor/actuator nodes. The proposed OSR is general and independent of the underlying link layer. To illustrate, Fig. 1 shows an example of WSN/IoT downward actuation. To deliver a packet to node G, OSR includes the source route encoded using Bloom filter and the destination in the packet header; each node only stores its direct children. In contrast, RPL (nonstoring mode) specifies the raw sourceroute and destination in the packet header, whereas RPL (storing mode)/ORPL/CBFR only specifies the destination in the packet header, with each node stor ing the entire subgraph of its descendants either uncompressed in RPL or compressed using Bloom filter in ORPL/CBFR, thus suffering from scalability problem. The main contributions of this paper are: •We propose OSR, a highly scalable and reliable downward routing approach for constrained heterogeneous WSN/IoT actuation. OSR introduces opportunistic routing into source routing to achieve reliable packet delivery in lowerpower and lossy networks (LLNs). A novel adaptive Bloom filter is devised to significantly reduce the path representationoverhead. OSR enables each node to only store its direct child set as the node’s downward routing table, and therefore scales well to largesize WSN/IoT deployments. •We develop our OSR protocol, working with the popular Collection Tree Protocol (CTP) [ 11]. OSR inspects CTP data packets to build the direct child set of each node. Thus, the energy overhead is negligible for building and maintaining the downward routing table. Downward routing paths are obtained based on network upward routing topology tomog raphy. •We evaluate our OSR protocol through both simulations and realworld testbed experiments. We show that OSR sig nificantly outperforms RPL (both storing and nonstoring modes) and ORPL on scalability and reliability. OSR is also much more energy efficient than TinyRPL and Drip which are based on the same TinyOS platform as OSR implementa tion. The remainder of the paper is organized as follows. Section 2 presents the design of OSR. Section 3 evaluates OSR via both simu lations and testbed experiments. Section 4 discusses our insights and the limitations of the current OSR implementation. Section 5 describes the related work in detail. Finally, Section 6 concludes our work and discusses the future work. 2 OSR DESIGN OSR introduces opportunistic routing into source routing, and cre ates an adaptive Bloom filter mechanism to encode the downward sourceroute path. This section presents the core mechanisms of OSR including path representation, direct child set maintenance, and opportunistic routing. 2.1 Adaptive Bloom Filter for Path Encoding In traditional source routing, the entire raw routing path is included in the packet header. As network grows, this approach consumes too much overhead or may even be infeasible for largescale WSNs. For instance, containing a sourceroute of 20 hops using twobyte short address in IEEE 802.15.4 takes nearly one third of the maximum link layer frame size (i.e., 127 bytes). Thus, path encoding becomes a ne cessity for source routing to scale in resourcerestricted WSNs/IoT. OSR exploits the Bloom filter [ 2,36] to encode the sourceroute path, that is, a Bloom filter representing the sourceroute is included in the packet header instead of the raw path. Bloom filter [ 36] is a space efficient probabilistic data struc ture that supports insertion and membership query. To insert an element into a Bloom filter of mbits, kindependent hash func tions are applied to deterministically generate khash values hi∈ {0,1, ...,m−1}, and the corresponding bits are set to 1. For mem bership query, the element is hashed using the same set of hash functions. If all the kbits are matched in the Bloom filter, the ele ment is considered being included/matched. A membership query may result in false positives, but never in false negatives. The false positive (FP) rate of a Bloom filter can be calculated according the following equation [36]: p= 1− 1−1 mknk , (1)where mis the length of the Bloom filter in bits, kis the number of hash functions, and nis the number of elements that are already encoded in the Bloom filter. As an example of path encoding using Bloom filter, suppose in a largescale WSN a path length n=20, the length of the Bloom filter m=128bits, and k=3hash functions are used. The resulted probability of a false positive match (i.e., false positive rate) is 5.29%. Assuming each node address in the path occupies two bytes, using a 128bit Bloom filter leads to 60% space saving compared to the raw path representation mechanism, indicating the effective use of Bloom filter in source routing in WSNs/IoT. Since multihop WSNs usually need to be scalable in practice, using a fixedlength Bloom filter is inefficient. For instance, a too short Bloom filter would introduce high false positive rate for a long path, whereas a long Bloom filter may have more bits than a short raw path itself. We devise an adaptive path Bloom filter whose length m(bits) is proportional to the hop count Hof the route: m=8H H≤L 8L H >L, (2) where Lis the maximum Bloom filter length of any encoded source route in bytes. Even with a minimum node ID (i.e., address) length of two bytes, the devised Bloom filter (2) for path encoding leads to at least 50% space saving compared to the use of raw source route in RPL (nonstoring mode), indicating the potential merit of our adaptive Bloom filter. Fig. 2 demonstrates the analytical false positive rate based on (1) of the devised adaptive Bloom filter with L=40bytes and its corresponding space saving compared to the raw path. Clearly, our devised Bloom filter mechanism scales well with respect to the raw source route length. The resulting false pos itive rate is lower than 3.6% when hop counts do not exceed 40; the false positive rate actually drops as a path length increases. When a raw source route exceeds 70 hopes, our approach works fine only at a higher FP rate (<13%). In fact, our approach would still work for any long raw path potentially of hundreds (or even thousands) of hops at somewhat degraded performance (i.e., a higher FP rate). In contrast, traditional source routing, such as RPL nonstoring mode, simply does not work for any raw path exceeding the maximum frame size of underlying link layer, which would be less than 64 hops for RPL with IPv6 address compression. If more false positives are tolerable, a shorter Bloom filter can be used to reduce packet overhead even more. In practice, a maximum Bloom filter length L (MAX_BFLT_LEN ) is configurable for given WSN/IoT applications. Due to the resource constraints in sensor/actuator nodes, hash functions employed in a Bloom filter should consume as less re source as possible. We adopt three hash functions, namely Thomas Wang’s hash function [ 41], Bob Jenkins’ hash function [ 15], and FNV hash [ 9] in our Bloom filter structure due to their resource efficiency [ 30]. Note that, k’s value can also be adaptive to the Bloom filter size and path length, as optimal k=m n×ln2[36]. If optimal kis needed, we can further adopt SAX (ShiftandXor) hash to generate multiple hash values [7, 29]. When a downward packet is initialized at the sink, the source route is encoded in a Bloom filter by ORing the Bloom filters of all the (intermediate) node addresses in the sourceroute. Upon reception of a downstream packet, a node checks if there exists any Figure 2: The false positive rate of adaptive Bloom filter and the corresponding space saving. Path length is Hhops; Bloom filter length mis based on (2); the number of hash functions k=3;MAX _BFLT _LEN=40bytes. ALGORITHM 1: Bloom Filter Membership Query Input: path Bloom filter path _bf lt , node’s hash values hi,i∈{1, ..., k}. Output: query result ret. ret=1; fori=1tokdo if(((1≪hi) &path _bf lt )==0) then ret=F ALSE ; break; end end return ret match of its direct child(ren) through the Bloom filter membership query of its each child, which can be done efficiently by an AND operation, as shown in Algorithm 1. If any of its direct child matches the Bloom filter, the packet is forwarded downward to the matched child node(s). 2.2 Direct Child Set WSN/IoT nodes are usually highly resource limited. For example, a MicaZ node platform, only has 4K bytes of RAM. Even a TelosB node that is widely used in realworld WSN deployments only has 10K bytes of RAM. Existing approaches such as RPL [ 42] (storing mode), RBD [ 32], CBFR [ 30], and ORPL [ 7] require each node to store/encode its entire subgraph of descendants for making down ward routing decisions, causing the inherent scalability problem for large WSNs/IoT. In contrast, OSR only requires each node to store its onehop direct children, referred to as the direct child set, for downward routing. Therefore, OSR is scalable on the size of the network with respect to node’s memory. As an illustration, we tested a data collection WSN application based on CTP in Indriya testbed densely deployed across three floors in a school building [ 5], which contained 95 available TelosB nodes at the experiment time. The test lasted for about 6 hours. We analyzed all the (parent, child) pairs and computed the node distribution on the number of direct children they had. The statistics is shown in Fig. 3. As we can see, around 50% of the nodes are leaf nodes, and no node has more than 12 direct children. In contrast, the subtree of an intermediate node can grow up to a size comparable to the entire network size, especially for the nodes near the sink.Figure 3: Node distribution on the number of direct children for the Indriya testbed with 95 nodes available. OSR takes advantage of the underlying data collection routing protocol to establish the direct child set. When a node forwards an upstream packet, it inspects the packet header and adds the link layer sender’s address to its direct child set. Some protocols provide easy access methods. For instance, CTP in TinyOS [ 38] offers an Intercept interface for other applications to check the contents of a forwarded CTP packet. To accommodate wireless link dynamics and hence the coming and leaving of a direct child, each direct child is associated with a time to live ( TTL) flag. The TTL value decreases based on a periodic timer. When a child’s TTL reaches 0, the child is removed from the direct child set. Every time a child is refreshed or added, its TTL value is reset. With TTL, the direct child set should be able to cover all the (parent, child) relationships in the data collection network within the time window of length TTL. If an intermediate node is in the path Bloom filter of a downward packet but none of the node’s direct child, it is highly possible that the node itself is a false positive. 2.3 Opportunistic Routing In data collection WSNs/IoT, a node may have multiple candidate parents that are able to forward its data packets within a time win dow, forming a parent set [ 27] of the node. Moreover, the parent nodes belonging to a same parent set have a high probability being within the transmission range of each other. Based on these obser vations, OSR introduces opportunistic routing into the traditional source routing by exploring alternative routes based on node’s par ent set to improve the reliability of downward routing in dynamic WSNs/IoT. Note that in OSR, nodes are not aware of their parent set explicitly. Instead, a node implicitly joins a child’s parent set when it adds the child into its direct child set. The introduced OSR opportunistic routing acts in two aspects. First, the probabilistic nature of the Bloom filter of the sourceroute would be able to potentially, albeit in a passive way, explore the parent nodes of an inroute node not given in the sourceroute but opportunistically matched by false positives. This in fact provides alternative route(s), beyond the given sourceroute, for downward packet forwarding. During the OSR downward routing process, whenever a node has multiple matched children in the path Bloom filter, OSR transmits the packet to all the matched children by local multicast. In the case that the matched child(ren) due to the false (a) Passive OR  (b) Active OR Figure 4: Illustration of (a) passive opportunistic routing (OR) and (b) active opportunistic routing (OR) in OSR. The sourceroute is marked as circles with double line border. positive(s) is/are also in the parent set of the grandchild in the downward path, the packet is then opportunistically delivered to the grandchild. Therefore OSR, to some extent, turns false posi tives in the Bloom filter into potential opportunities for downward packet forwarding, which can improve the reliability without any false positive recovery scheme. Second, OSR actively performs op portunistic routing by requesting the other parent nodes in the parent set of a child node to assist packet forwarding whenever a normal downstream unicast based on the sourceroute fails. Due to the drastic wireless link dynamics in lowpower WSNs/IoT, a sourceroute may be obsolete when the downstream packet arrives at an intermediate node. Source routing fails if the next hop in the sourceroute becomes unreachable at an intermediate node. In such an event, the intermediate node will broadcast the packet to its neighborhood, hoping that one or more of its neighbors belonging to the parent set of the nexthop child node opportunistically re ceive(s) it. Upon reception of a broadcast packet, the node will check whether any of its direct child is in the sourceroute. If yes, which indicates the node likely belongs to the nexthop child’s parent set, the node would forward the packet to the matched child(ren). Fig. 4 illustrates how opportunistic routing is conducted in OSR. The passive opportunistic routing is shown in Fig. 4a. The source route specifies [···P→C1→T]. Nodes C1,C2, and C3are children of node Pwhich are matched in the path Bloom filter of the down ward packet. In addition to ( C1→T), node C2is also in the parent set of grandchild node T, hence ( C2→T) is an alternative path explored through the passive opportunistic routing. The active op portunistic routing is illustrated in Fig. 4b. Node Tis a child of node Pas specified in the downstream sourceroute. When Pfails to deliver the packet to T, it broadcasts the packet to its neighbors. Three neighbors have received the broadcast; whereas neighbor U is not in the parent set of Tand will ignore the packet, neighbor PAandPBwill forward the packet to Tbecause they are in the parent set of T. Thus, the obsolete link from PtoTis successfully bypassed by the opportunistic routing activated by node P. 2.4 Downward Routing Decision Unicast is the basic MAC layer transmission scheme used in OSR to deliver a downstream actuation packet. If any unicast fails after itsmaximum retransmissions, broadcast is used for active opportunis tic routing. In addition, if a node has multiple direct children that are included in the sourceroute, it uses local multicast to deliver the packet to all the matched children for passive opportunistic routing. OSR includes twobit information in a downstream packet header to distinguish the three transmissions types (i.e., unicast, local multicast, or broadcast) of the packet; nodes process the received packets based on the twobit header information accordingly. While a multicast reception would require each receiving node to check its membership to the received path Bloom filter, broadcast does not require each receiving node to check its membership. In the case of lacking the support of multicast in the MAC layer, multicast can be implemented by broadcast. OSR would benefit from multicast supported MAC layers. Unicast reception indicates the receiver node must be included in the path Bloom filter without the check of the membership. We have devised the OSR algorithm (i.e., Algorithm 2) for the routing decision making process at an intermediate node. If a node receives a multicast packet and passes the membership check, it starts to check the direct child(ren); otherwise the packet is ignored. If a node receives a unicast or broadcast packet, it immediately starts to check the membership of its direct children in the path Bloom filter ( path_bflt ). If a node has multiple children included in the path_bflt , the packet is forwarded using local multicast. If there is only one matched child, the packet is forwarded by uni cast. Any unicast failure would trigger active opportunistic routing through broadcasting. If there is no any matched child, the packet is ignored, since it is of high probability that the node itself is a false positive. In our design, each node keeps a history of recently received downstream packets to avoid duplicates and forwarding loops. Duplicate packets are ignored immediately. A timetolive (TTL) field (e.g., initialized as two times of the path length) is also associated with the packet to avoid infinite forwarding loops. 3 EVALUATION We implemented OSR in TinyOS 2.1.2, integrating CTP as the under lying data collection protocol, and performed a series of simulations and realworld WSN testbed experiments to evaluate and compare it against existing protocols. After a few initial data collection cy cles, the sink starts to issue actuation commands to each individual node. We plan to make our OSR implementation, including all the test applications, publicly available. 3.1 Methodology and Setup "
355,FixRoute: A Unified Logic and Numerical Tool for Provably Safe Internet Traffic Engineering.txt,"The performance of networks that use the Internet Protocol is sensitive to
precise configuration of many low-level parameters on each network device.
These settings govern the action of dynamic routing protocols, which direct the
flow of traffic; in order to ensure that these dynamic protocols all converge
to produce some 'optimal' flow, each parameter must be set correctly. Multiple
conflicting optimization objectives, nondeterminism, and the need to reason
about different failure scenarios make the task particularly complicated.
  We present a fast and flexible approach for the analysis of a number of such
management tasks presented in the context of BGP routing. The idea is to
combine {\em logical} satisfiability criteria with traditional {\em numerical}
optimization, to reach a desired traffic flow outcome subject to given
constraints on the routing process. The method can then be used to probe
parameter sensitivity, trade-offs in the selection of optimization goals,
resilience to failure, and so forth. The theory is underpinned by a rigorous
abstraction of the convergence of distributed asynchronous message-passing
protocols, and is therefore generalizable to other scenarios. Our resulting
hybrid engine is faster than either purely logical or purely numeric
alternatives, making it potentially feasible for interactive production use.","Network management is inherently complex. Operators con tend with a bewildering array of technologies, whose inter actions are difﬁcult to predict, and struggle to express their diverse conﬁguration goals in the setup of a live network. The practice of network management could be improved if operators were equipped with better tools for understanding and resolving tradeoffs in network conﬁguration. We propose a formal approach for managing performance tradeoffs in complex networks. While the use of formal spec iﬁcation is not new, several past efforts have been hampered by excessive devotion to a single algorithm or technique; in contrast, our methodology is centered around a common representation to which different algorithms can be applied. The problem we study is how to enforce network invariants about trafﬁc ﬂow assertions provided by the operator which ought to be true, but might fail due to operational circum stances. These invariants may be logical, concerning the desired outcome of the network routing process and the paths which are selected, or numeric, relating to the aggregate ﬂow of trafﬁc. While there are many existing approaches to the numeric trafﬁc management goals, based on techniques from operational research, and there are tools that tackle the logical combinatorial goal, there is no uniﬁed method. Therefore, key tasks in the practical management of networks are still difﬁcult: operators cannot easily understand their available options for conﬁgura tion, assess tradeoffs between different goals, or perform joint optimization.This paper presents a focused effort at one particular problem within this general space, namely, we look at the problem of reconciling the enforcement of MED values in BGP routing with individual AS policies without hurting trafﬁc engineering optimizations within that AS. Although we present FixRoute in the context of solving MED induced oscillation problems, it can be used in a much more general framework. Namely, the tool accepts a set of logical preferences (MED values in our problem) and numeric, convex, objective functions (TE cost) as its optimization objectives and produces a set of link weights that results in routing decisions that satisfy both objectives. For example, the operator may want all trafﬁc coming in from source sto go through a particular middlebox mfor processing before being forwarded to the destination. FixRoute can translate this rule to a set of logical preferences that favors all paths from sthat include mto all other paths and allocate link weights so as to cause minimum disruption to TE objectives. As an additional example the methods presented in this paper can be used to implement the optimizations proposed by [20] which reroute ﬂows in the network to minimize the aggregate peering and infrastructure cost without exceeding network capacity. While it is true that MED values are mostly ignored in today’s BGP route selection policies, we believe that one of the reasons for this is the complexity of conﬁguring such policies to maintain autonomous level (AS) level objectives while allowing for possible preferences from neighboring ASes to be accommodated as well. Given that the intersection of these two objectives may lead to the occurrence of oscillations and instabilities in the network, the tendency to ignore MED values is understandable. However, we believe that MED values are useful in their own right. Today, many network administrators use alternative means, e.g., AS prepending, to try to enforce certain preferences in BGP route selection. These methods reduce transparency between participating ASes and make it harder for individual ASes to enforce their own ingress routing preferences. In this paper, we use the MED value oscillation problem to illustrate the viability of our approach in solving network policy problems. Our tool FixRoute provides and implements a structure to ensure that logical invariants are enforced and numeric trafﬁc optimality goals are reached as far as possible; section II explains the speciﬁc problem in more detail. FixRoute provides a means for assessing tradeoffs between different objectives in network management. Previous attempts at automating management tasks have sought to incorporate many objectives into a ﬁxed strategy. The problem with thisarXiv:1511.08791v1  [cs.NI]  27 Nov 2015approach is that it does not match the typical modes by which networks are actually managed, where the tradeoffs are contextual, and it may be difﬁcult to express a single strategy that encompasses all needs. It is not feasible to ask a network operator to use a system where the ﬁrst step is to write a complex optimization formula, even if we can then solve it exactly. In contrast, our approach enables operators to experiment with the interplay of these objectives, within a sound conceptual design underpinned by a proven mathematical formalism. II. P ROBLEM STATEMENT Our developed conﬁguration repair tool chain, FixRoute, is for repairing broken invariants within a single AS. We will assume that networkinternal paths are established according to a shortest path rule, as is standard. External paths will be selected according to the process of the Border Gateway Protocol (BGP). Note that desired outcomes for BGP policy can be expressed in terms of given path preferences: assertions about which paths should be preferred as a result of running the distributed decision process. It has been known that BGP routing can fail through per sistent oscillation [33], [19], where the protocol will switch between best paths at high speed, causing increased control plane trafﬁc, router overhead, and degradation of data plane service. Within a single AS, oscillations are typically caused by disrupting interactions with the policies of the neighboring ASes. One important class of convergence failure that FixRoute aims to handle is MEDinduced oscillations [19]. Proposed solutions to persistent oscillations today are non ideal. They range from waiting for misconﬁgurations to go away, adhoc reconﬁgurations, to design guidelines [19] that provide heuristics on reducing particular classes of oscillations, and perhaps most drastic of all, completely ignoring the MED values. For mitigation, techniques such as route ﬂap damping [34] can lessen the effects of oscillations, without actually tackling the root cause. This could be helpful in allowing extra time for adhoc reconﬁgurations, but it is by no means a solution. In the long term, redesigning the protocols involved (as in [7], for example) would be the best option, but that future has not yet arrived. None of the existing solutions take trafﬁc engineering (TE) into consideration. While both convergence and TE relate to the action and outcomes of the routing protocol, they have quite a different ﬂavor. TE is concerned with numeric constraints on the ﬂow of data across network links, and is traditionally approached using the classic numeric techniques of operational research and combinatorial optimization. In contrast, the ques tion of convergence requires reasoning about the action of distributed protocol, and the techniques here are drawn from logical reasoning. These goals are both important, but are in conﬂict because there is no particular reason why a TEoptimal conﬁguration should satisfy BGP convergence goals, nor why the attempt to propitiate BGP should result in a conﬁguration with good trafﬁc ﬂow properties. Ideally, one would want to have a solution concept that would allow the network operator to assign preference as to which constraint should be of greater importance.Our goal is to take a network, and mandated preferences for path selection, and synthesize a sequence of conﬁguration updates that (1) upholds the given preferences, and (2) does not cause severe harm to TE cost. In particular, we address the case where the mandated preferences are chosen to avoid an inter AS BGP oscillation problem. The conﬁguration parameters we target are the link weights of the interior routing protocol. We focus on link weight changes because these are frequently used for TE, including by automated processes, so there is precedent for deciding what the link weights should be in order to meet a network design objective. The fewer actions needed to be taken, the faster the recovery process will be. The computation of the sequence should be efﬁcient and reliable. It must be able to produce results that are at least as good as could be reached manually. These characteristics would make it suitable for handsoff deployment, automatically reconﬁguring link weights as problems arise. A. MED Induced Oscillations Fig. 1: Minimal network conﬁguration with MED oscillation See Figure 1 for the topology. The main AS has ﬁve routers conﬁgured into two routereﬂector clusters: A and B are clients of R, and C is a client of S. The three boarder routers are connected to two external ASes (shown in green). The annotations on the ASinternal links indicate IGP distance values, and those on the external links are MED values. The cause of the oscillation is the multipleexit discriminator (MED) BGP attribute. MED is taken into account when choos ing between routes with the same nexthop AS; for these, routes with lower MED values are better. Ties are broken by further attribute comparisons, principally intraAS path lengths, which are computed by a separate shortestpath protocol. Therefore, for router R here, the route through B is better than the A route (MED) and the A route is better than the C route (shortest paths). Cycles of preferences, as seen in the previous example, can cause oscillations, and changing the weight values can create/destroy a cycle. However, due to the number of paths and complexity of the route computation it is not easy to judge which changes should be made in practice. The general principle is that the IGP path weights should be consistent with the preferences imposed by the MED attribute. In this way, preference cycles like those illustrated above are repressed. Thiscan be achieved by reweighing the IGP links, by suppressing or overwriting MED values, or both. We attempt to change the link weights so that they become consistent with the given MEDs. That having been said, we recognize that it is important to provide operators with insights into how ‘binding’ the MED constraints are, so that they can be better informed about the consequences of accepting these values: we propose that by giving our tool different combinations of the possible incoming MEDs, users could gain insight into the tradeoffs involved. Variations of the unequal split optimization (which we will discuss in section VD) can be used as a lower bound on the minimum TE shift that the operator should expect. B. Link Weight Optimization Instead of an adhoc solution, FixRoute plans to repair an existing oscillation network instance, as a sequence of link weight updates. In a given AS, routers use assigned link weights to run shortest path algorithms to compute path to given desti nations. Adjusting link weights allows the network operator to simultaneously enforce route preferences while meeting trafﬁc engineering costs. III. O VERVIEW Fig. 2: Overview of the component parts of FixRoute. Figure 2 shows a highlevel overview of various compo nents of FixRoute. FixRoute is designed for conﬁguring the link weights within an AS, in order to meet two goals: (1) implementing route preferences speciﬁed by the AS’s network operator, and (2) optimizing for TE based metrics. FixRoute takes as input the following information: Network instance. Includes the topology of the entire AS’s internal network, and existing link weights. Weights may be speciﬁed as unknown, to be set by FixRoute. Trafﬁc demand matrix. For each source sand destination d, speciﬁes the amount of data from stod. Mandated preferences. A listing of which paths are to be made ‘better’ than which other paths. These can also be derived via analysis from the network instance and information about possible incoming routes. In addition the system takes an optimality threshold param eter . This will be the tolerance set by the network operator specifying the allowed deviation of the solution’s TE cost from the original. FixRoute then attempts to generate a sequence of changes to existing/unspeciﬁed link weights. Within FixRoute,we propose the following optimization strategies, proven correct by utilizing the PSPP concept (Section IV). MaxSMT strawman. (Section VB) We express the input network instance as a PSPP, and then utilize a MaxSMT solver to enumerate all possible paths in the network to ﬁnd an optimal solution. This solution requires time complexity that is exponential in the number of nodes. Unequal splitting. (Section VD) Assuming routers permit unequal splitting of trafﬁc among paths of equal lengths, we utilize a two level optimization strategy that generates the set of link weight changes. The solution yields the best possible tradeoff between achieving a TE optimal solution and minimizing the number of weight changes. Equal splitting. (Section VE) If routers require equal splitting of trafﬁc among paths of equal lengths, ﬁnding the optimal solution is NP hard. we propose a modiﬁcation to an existing local search heuristic that comes reasonably close to the TE optimal [9]. IV. P ATH PREFERENCE MODEL Routing policy is known to be approachable in terms of various mathematical formalisms, including algebraic and com binatorial models [15], [14], [30]. In past work, these have been used to study routing protocol convergence, and to explore the expressive power of different policy schemes. However, we will use a policy model to support reasoning about possible outcomes of the routing process: which paths might be selected as a result of procotol execution, given a network conﬁguration. The formalism is based on partially speciﬁed conﬁguration information, whereby ‘gaps’ in the conﬁguration can be ﬁlled in, according to some highlevel goal. The partial stable paths problem (PSPP) is a combinatorial representation of partiallyspeciﬁed routing protocol conver gence [15], [14], [30]. A PSPP instance consists of an enu meration of possible network paths, and the known preferences among them. In our case, it does not include preferences in duced by link weights, but speciﬁcally does include preferences that are mandated by the user. The missing, undecided, prefer ences are the ‘gaps’. An instance can be completed by ﬁlling in these gaps, therefore determining the relative preference of all paths, and the values of the conﬁguration parameters that give rise to those preferences. Any potential oscillation problems can be detected as ‘conﬂicts’ of path preference in this structure; speciﬁcally, the presence of a cycle of preference, where each path is considered to be strictly preferred to the next [16]. Absence of a preference cycle is equivalent to the key properties of safety and robustness of a routing conﬁguration [14], [30], [16]. Safety means that all fair protocol executions, from any given conﬁguration state, will eventually converge to the same unique ﬁxed point. This means that there can be no permanent oscillation in the protocol, and furthermore that the protocol produces the same result regardless of timing. This second feature is held to be important because multiple stable solutions typically occur accidentallythere is some ‘intended’ ﬁnal state, but in some circumstances the protocol could end up wedged in an unusual alternative routing state [13]. Robustness says that the state will remain safe even if some nodes andarcs are removed. This is meant to rule out conﬁgurations with certain latent problems, where an oscillation is being hidden by some other aspect of the routing state, and where the failure of the part of the network will cause the oscillation to reveal itself. Note that these properties hold regardless of the dynamic execution of the protocol. Deﬁnition 1. A partial stable paths problem (PSPP) consists of a directed graph G(V;E); a designated destination node d2V; and for each v2V: 1)A subsetPvof the simple paths from vtod, and 2)A partial ordervonPv. The paths inPvare the permitted paths and the order vgives path preferences. Because the order vis partial rather than total, this def inition allows for some preferences to be undeﬁned. These preferences are given abstractly, but in real protocols they are induced by attributes of the paths and by ﬁxed rules in the routers. Deﬁnition 2. One PSPPPis a reﬁnement of another PSPP Q if they have the same graph, same destination node, and same sets of permitted paths; and for each node vifpvqfor some paths pandqaccording to the order in Q, thenpvq according to the order in Pas well. A special case of reﬁnement is when all path preferences have been set one way or another, and so the orders vare all total. The concept of preference cycle is deﬁned with reference to the path digraph. This data structure contains information about paths and their dependencies. Deﬁnition 3. Given a PSPPP, its path digraph is the directed graph (V0;E0)where the nodes in V0are the paths inP, and (p;q)is an arc in E0if and only if either: 1)pis a sufﬁx of q, or 2)pandqhave the same source node v, andpvqbut :(qvp). For these two cases, we use the notation p!qandpq respectively. A path is said to ‘depend on’ its predecessors in this digraph, because it is the presence/absence of these paths which completely determine whether the path should be part of the routing solution. For a path to be selected, its sufﬁxes must be present (corresponding to the BGP rule that one is only allowed to use routes which have been advertised and not withdrawn by neighbors), and no better path can be present. A preference cycle is simply a cycle in this digraph. The PSPP model is welladapted for reasoning about conﬁg uration repair. We can ensure that certain desired route prefer ences will indeed hold, and then use that information to deduce information about other paths and the underlying conﬁguration. In particular, oscillation can be avoided by requiring that the structure be acyclic, or linearizable: this means that it is possible to ﬁnd a (single, global) ordering of all the paths, which is compatible with both the sufﬁx relation and the preference v relations. A linearization may be witnessed by giving a numeric‘rank’ to each possible path, where each path must have strictly larger rank than any of its predecessors. V. R EPAIR WITHOPTIMIZATION This section describes our method for carrying out invari ant repair, while trying not to harm the TE optimum. We ﬁrst present an inefﬁcient strawman solution that linearizes a PSPP instance, followed by two numericbased techniques that leverage the PSPP model for correctness, as applied to routers that permit unequal and equal trafﬁc splitting respectively for paths of the same length. We assume that preferences for the linearization are those which arise from oscillationavoidance; these can be derived in a straightforward way from the network conﬁguration and information about incoming paths. A. Oscillation Avoidance As discussed above, the oscillation problem arises from non linearizability of route preferences: in short, when the pref erences imposed by MED attributes (or by the administrator) don’t match those induced by the link weights. Therefore, if we take the incoming MEDs as binding, the desired invariant for our link weight is that they should result in the same preferences as the MEDs do; whenever pandqare two paths, where pis preferred to qby reason of MED, then pshould also be of lesser weight than q. It is conceptually straightforward, given an account of the incoming routes, to derive these preferences. The paths in the network can be enumerated, and for each pair, we can determine whether MED will be the decisive attribute in comparison. If so, then this should be one of the mandated preferences. On the network of Figure 3, this can be done in less than a second by a naive algorithm. Fig. 3: AS1239 topology, from Topology Zoo [29], [18]. B. Strawman: Pure Linearization This technique uses MaxSMT, which is the SMT version of MaxSAT. That is, SAT problems are about satisﬁability of Boolean formulae; SMT (satisﬁability modulo theories) adds a richer language, including integer arithmetic; and ‘Max’ means that the goal is to satisfy as many clauses as possible, not just allornothing. Each claus in the MaxSMT program is associated with a numeric cost, and we can then ask a solver for a model which maximizes the total cost of the assertions that are satisﬁed. Practical MaxSMT solvers may fall back toheuristic rather than exact methods, if the number of variables or complexity of the formula are high enough. Assertions that are unweighted are taken to be constraints that must always hold. The Yices solver [6] is one that is capable of operating in MaxSMT mode. We generate a MaxSMT program for the repair problem using the following steps: 1) Enumerate the paths in the network and give each one a numeric ranking variable. 2) Assert the path digraph constraints ( !;) on the rank ings, arising from the network structure and the mandated preferences. 3) Associate each path with its sum of link weights, and assert that if a path has a lower ranking than another, then it must have a lesser sum of weights. 4) Assert (with ﬁnite weight) that each individual link weight should have its original value. Then, a solution to this program will represent a linearization of the path digraph, with associated link weights such that the path preferences are indeed induced by those weights. Moreover, because of the maximization of satisﬁability, as many link weights as possible will be unchanged. This approach fails to achieve the desired TE properties and is rather inefﬁcient. In contrast, the next section presents a full method, also based on the PSPP model, that does achieve all of the problem goals. C. Numeric Optimizations We now present our numeric optimization technique, which incorporates the constraints of the desired invariant, and there fore tries to produce a solution that is optimal subject to those constraints. The ﬁrst solution involves an optimization problem which provides a set of link weights that satisfy the given mandated preferences, without harming TE cost too much. This formulation assumes that when path of equal best cost exist, the trafﬁc ﬂow can be split between them in any desired proportion. Therefore, when the method produces an ‘optimal’ weight assignment, the assessment of its cost (and even its feasibility with respect to bandwidth constraints) may not match the true cost in a system where such splitting is not possible. This is typical for the current IP data plane, where if trafﬁc splitting is allowed, it may only be possible to split in equal ratios (e.g. ECMP [17]). The case where no trafﬁc splitting is permitted can be handled by a small adjustment to the linear programing objectives. For the more interesting case of equal splitting, we show a heuristic local search procedure that takes the linear programming solu tion as its starting point, and adapts it to ﬁnd a ‘nearby’ link weight assignment which meets the reﬁned objectives. In the next sections we will investigate the practical performance of the combined procedure, and show that it is more effective than running the heuristic local search alone1. In the following, we represent the network topology as an undirected graph G(N;E ), whereNis the set of nodes and 1The reason is that the bulk of the effort of ﬁnding the solution still rests with the linear program which ﬁnds the best possible solution, the heuristic then tries to ﬁnd the solution that is as close as possible to the linear optimization conﬁguration.Ethe set of edges. A simple path in this graph is a sequence of connected nodes in which every node in Nappears at most once. The notation [i1;i2;:::;d ]stands for a path that goes through nodes i1;i2;::: and has destination d. An empty path for nodedis denoted as d. The set of all paths to destination dis deﬁned asPd. A set of mandated preferences for paths with destination dis given by the binary relation SdonPd, where (p;q)2Sdmeans that pathpis to be preferred to path q. Per node preferences pvq can be deﬁned as (p;q)2Sd. Recall from Deﬁnition 3 that the path digraph G0for this given instance has the paths in Pdas its nodes (for each destinationd), connected by edges given by the preferences in, derived fromv, and the immeidate sufﬁx relation !on paths. Note that for every destination node dinG, and every path digraph node p= [i;:::;d ]inG0, there is a chain in G0 connectingdtop, consisting of all the sufﬁxes of p. Our problem is to assign link weights to all the links in E, so that the induced path weights will be consistent with the mandated preferences in each Sd. These mandated preferences may be given in order to avoid oscillation, or for other purposes. As previously observed, avoidance of oscillation corresponds to ﬁnding a linearization of G0and a witness to this linearization is an assignment of a numric ‘ranking’ to each path, in a way consistent with the digraph structure (i.e., if path pis reachable fromq, then it should have a strictly larger ranking). This notion can now excercise a double duty: rather than being arbitrary numbers, these rankings (potentials), will now be precisely the sum of the weights for each path. Let pstand for the potential assigned to path p. Ifpis a sufﬁx of qthen it should have a smaller potential, which remails true when the potentials are sums of link weights: qcontains all the links that pdoes, so its potential should be at least as large as that of p2. Similarly (p;q)inSdtells us that path pshould have lower weight than pathq. Of course it is not enough to simply linearize G0, since we need to make sure not only that the potentials are consistent with the digraph structure but also that they are realizable in terms of link weights. In addition to the desired link weights wijfor(i;j)2E, we generate virtual link weights w0 pqfor each mandated preference (q;p)2Sd. This results in the following description of the feasible set of link weights: p"
210,Keyword-aware Optimal Route Search.txt,"Identifying a preferable route is an important problem that finds
applications in map services. When a user plans a trip within a city, the user
may want to find ""a most popular route such that it passes by shopping mall,
restaurant, and pub, and the travel time to and from his hotel is within 4
hours."" However, none of the algorithms in the existing work on route planning
can be used to answer such queries. Motivated by this, we define the problem of
keyword-aware optimal route query, denoted by KOR, which is to find an optimal
route such that it covers a set of user-specified keywords, a specified budget
constraint is satisfied, and an objective score of the route is optimal. The
problem of answering KOR queries is NP-hard. We devise an approximation
algorithm OSScaling with provable approximation bounds. Based on this
algorithm, another more efficient approximation algorithm BucketBound is
proposed. We also design a greedy approximation algorithm. Results of empirical
studies show that all the proposed algorithms are capable of answering KOR
queries efficiently, while the BucketBound and Greedy algorithms run faster.
The empirical studies also offer insight into the accuracy of the proposed
algorithms.","Identifying a preferable route in a road network is an important problem that ﬁnds applications in map services. For example, map applications like Baidu Lvyou1and Yahoo Travel2offer tools for trip planning. However, the routes that they provide are collected from users and are thus predeﬁned. This is a signiﬁcant deﬁciency since there may not exist any predeﬁned route that meets the user needs. The existing solutions (e.g., [16, 17, 22]) for trip planning or route search are often insufﬁcient in offering the ﬂexibility for users to specify their requirements on the route. Consider a user who wants to spend a day exploring a city. She is not familiar with the city and she might pose such a query: “Find the most popular route to and from my hotel such that it passes by shopping mall ,restaurant , and pub, and the time spent on the road in total is within 4hours.” 1http://lvyou.baidu.com/ 2http://travel.yahoo.comThe example query above has two hard constraints: 1) the points of interests preferred by the user, as expressed by a set of key words that should be covered in the route (e.g., “shopping mall”, “restaurant” and “pub”); 2) a budget constraint (e.g., travel time) that should be satisﬁed by the route. The query aims to identify the optimal route under the two hard constraints, such that an objective score is optimized (e.g., route popularity [4]). Note that route pop ularity can be estimated by the number of users traveling a route, obtained from the user traveling histories recorded in sources such as GPS trajectories or Flickr photos [4]. In general, the budget constraint and the objective score can be of various different types, such as travel duration, distance, popularity, travel budget, etc. We consider two different attributes for budget constraint and objective score because users often need to balance the tradeoff of two as pects when planning their trips. For example, a popular route may be quite expensive, or a route with the shortest length is of little in terests. In the example query, it is likely that the most popular route requires traveling time more than 4hours. Hence, a route search ing system should be able to balance such tradeoffs according to users’ different preferences. We refer to the aforementioned type of queries as keywordaware optimal r oute query , denoted as KOR . Formally, a KOR query is deﬁned over a graph G, and the input to the query consists of ﬁve parameters,vs,vt,ψ,∆, andf, wherevsis the source location of the route inG,vtis the target location, ψis a set of keywords, ∆ is a budget limit, and fis a function that calculates the objective score of a route. The query returns a path RinGstarting atvs and ending at vt, such thatRminimizesf(R)under the constraints thatRsatisﬁes the budget limit ∆and passes through locations that cover the query keywords in ψ. To the best of our knowledge, none of the existing work on trip planning or route search (e.g., [16, 17, 22]) is applicable for KOR queries. Furthermore, the problem of solving KOR queries can be shown to be NPhard by a reduction from the weighted constrained shortest path problem [8]. It can also be viewed as a generalized traveling salesman problem [11] with constraints. This leads to an interesting question: is it possible to derive efﬁcient solutions to answering KOR queries? Due to the hardness of answering KOR queries, in this paper, we answer the aforementioned question afﬁrmatively with three ap proximation algorithms. The ﬁrst approximation algorithm has a performance bound and is denoted by OSScaling . InOSScaling , we ﬁrst scale the objective value of every edge to an integer by a parameterǫto obtain a scaled graph denoted by GS. Speciﬁcally, in the scaled graph GS, each partial route is represented by a “label”, which records the query keywords already covered by the partial route, the scaled objective score, the original objective score, and the budget score of the route. At each node, we maintain a list of “useful” labels corresponding to the routes that go to that node. 1136 Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. Articles from this volume were invited to present their results at The 38th International Conference on Very Large Data Bases, August 27th  31st 2012, Istanbul, Turkey. Proceedings of the VLDB Endowment, V ol. 5, No. 11 Copyright 2012 VLDB Endowment 21508097/12/07... $10.00. arXiv:1208.0077v1  [cs.DB]  1 Aug 2012Starting from the source node, we keep creating new partial routes by extending the current “best” partial route to generate new la bels, until all the potentially useful labels on the target node are generated. Finally, the route represented by the label with the best objective score at the target node is returned. We prove that the algorithm returns routes with objective scores no worse than1 1−ǫtimes of that of the optimal route. The worst case complexity of OSScaling is polynomial with1 ǫ, the budget constraint ∆, the number of edges and nodes in G, and it is expo nential in the number of query keywords, which is usually small in our targeted applications, as it is well known that search engine queries are short, and an analysis on a large Map query log [25] shows that nearly all queries contain fewer than 5 words. Our second algorithm improves on the algorithm OSScaling , which is referred to as BucketBound . It also returns approximate solutions to KOR queries with performance guarantees. However, it is more efﬁcient than OSScaling . The algorithm can always re turn a route whose objective score is at most β(β >1is a param eter) times of the one found by OSScaling . The algorithm divides the traversed partial routes into different “buckets” according to the best possible objective scores they can achieve. This enables us to develop a novel way to detect if a feasible route (covering all query keywords and satisfying the budget constraint) is in the same bucket with the one found by OSScaling . When we ﬁnd a feasible route that falls in the same bucket as the route found by OSScaling , we return it as the result. Finally, we also present a greedy approach for the problem. From the starting location, we keep selecting the next location greedily, taking into account all the three constraints in the KOR query. This is repeated until we reach the target location. This algorithm is efﬁcient, although it may generate a route that violates the two hard constraints of KOR : covering all query keywords and satisfying the budget constraint. In summary, our contributions are threefold. First, we propose the keywordaware optimal route ( KOR ) query, and we show that the problem of solving KOR queries is NPhard. Second, we present two novel approximation algorithms both with provable performance bounds for the KOR problem. We also provide a greedy approach. Third, we study the properties of the paper’s proposals empirically on a graph extracted from a large collection of Flickr photos. The results demonstrate that the proposed solutions offer scalability and excellent performance. The rest of the paper is organized as follows: Section 2 formally deﬁnes the problem and establishes the computational complexities of the problem. Section 3 presents the proposed algorithms. We report on the empirical studies in Section 4. Finally, we cover the related work in Section 5 and offer conclusions in Section 6. 2. PROBLEM STATEMENT We deﬁne the problem of the keywordaware optimal route ( KOR ) query, and show the hardness of the problem. Deﬁnition 1: Graph. A graph G= (V,E)consists of a set of nodesVand a set of edges E⊆V×V. Each node v∈Vrepre sents a location associated with a set of keywords denoted by v.ψ; each edge in Erepresents a directed route between two locations inV, and the edge from vitovjis represented by ( vi,vj). ✷ We deﬁne Gas a general graph. It can be a road network graph, or a graph extracted from users’ historical trajectories. Depending on the source of G, each edge in Gis associated with different types of attributes. For example, if Gis a trafﬁc network, the attributes can be travel duration, travel distance, popularity, and travel cost. To keep our discussion simple, we consider directed graphs only inthis paper. However, our discussion can be extended to undirected graphs straightforwardly. Deﬁnition 2: Route. A routeR= (v0,v1,...,v n)is a path such thatRgoes through v0tovnsequentially, following the relevant edges in G. ✷ We deﬁne the optimal route based on two attributes on each edge (vi,vj): 1) one attribute is used as the objective value of this edge, and it is denoted by o(vi,vj)(e.g., the popularity), and 2) the other attribute is used as the budget value of this edge, which is denoted byb(vi,vj)(e.g., the travel time). Note that we can pick up any two attributes to deﬁne the optimal route depending on different applications. Deﬁnition 3: Objective Score and Budget Score. Given a route R=/an}⌊ra⌋ketle{tv0,v1,...,v n/an}⌊ra⌋ketri}ht, the objective score of Ris deﬁned as the sum of the objective values of all the edges in R, i.e., OS(R) =n/summationdisplay i=1o(vi−1,vi), and the budget score is deﬁned as the sum of the budget values of all the edges in R, i.e., BS(R) =n/summationdisplay i=1b(vi−1,vi). ✷ Figure 1: Example of G Figure 1 shows an example of the graph G. We consider only ﬁve keywords (t1–t5), and each keyword is represented by a distinct shape. For simplicity, each node contains a single keyword in the example. On each edge, the score inside a bracket is the budget value, and the other number is the objective value. For example, given the route R=/an}⌊ra⌋ketle{tv0,v3,v5,v7/an}⌊ra⌋ketri}ht, we have OS(R)= 2 + 3 + 4 = 9 and BS(R)= 2 + 2 + 1 = 5. Intuitively, a keywordaware optimal route (KOR ) query is to ﬁnd an optimal route from a source to a target in a graph such that the route covers all the query keywords, its budget score satisﬁes a given constraint, and its objective score is optimized. Formally, we deﬁne the KOR query as follows: Deﬁnition 4: Keywordaware Optimal Route ( KOR ) Query. Given G, the keywordaware optimal route query Q=/an}⌊ra⌋ketle{tvs,vt,ψ,∆/an}⌊ra⌋ketri}ht, wherevsis the source location, vtis the target location, ψis a set of keywords, and ∆speciﬁes the budget limit, aims to ﬁnd the route Rstarting from vsand ending at vt(i.e.,/an}⌊ra⌋ketle{tvs,· · ·,vt/an}⌊ra⌋ketri}ht) such that R= arg min ROS(R) subject toψ⊆/uniontext v∈R(v.ψ) BS(R)≤∆ ✷ 1137In the example graph in Figure 1, given a query Q=/an}⌊ra⌋ketle{tv0,v7,{t1, t2,t3},8/an}⌊ra⌋ketri}ht, the optimal route is Ropt=/an}⌊ra⌋ketle{tv0,v3,v4,v7/an}⌊ra⌋ketri}htwith objec tive score OS(Ropt)= 4 and budget score BS(Ropt)= 7. If we set∆to 6, the optimal route becomes Ropt=/an}⌊ra⌋ketle{tv0,v3,v5,v7/an}⌊ra⌋ketri}htwith OS(Ropt)= 9 and BS(Ropt)= 5. Theorem 1: The problem of solving KOR queries is NPhard. Proof Sketch: This problem can be reduced from the NPhard weightconstrained shortest path problem (WCSPP) [10]. Given a graph in which each edge has a length and a weight, WCSPP ﬁnds a path that has the shortest length with the total weight not exceed ing a speciﬁed value. The problem of answering KOR queries is a generalization of WCSPP. If each node already covers all the query keywords, the problem of solving KOR becomes equivalent to the WCSPP. ✷ Obviously, if we disregard the query keyword constraint, the problem of solving KOR becomes WCSPP. In addition, if we re move the budget constraint, the problem becomes similar to the generalized traveling salesman problem (GTSP) [11], which is also NPhard. In GTSP, the nodes of a graph are clustered into groups, and GTSP ﬁnds a path starting and ending at two speciﬁed nodes such that it goes through each group exactly once and has the small est length. In the problem of solving KOR , we can extract the locations whose keywords overlap with ψ, and the locations that cover the same keyword form a group. Thus, the problem of solv ingKOR without the budget constraint is equivalent to the GTSP. Furthermore, if we disregard the objective score, the problem of ﬁnding a route that covers all the query keywords and satisﬁes the budget constraint is still intractable. It is obvious that the simpli ﬁed problem is also equivalent to GTSP, and thus cannot be solved by polynomialtime algorithms. Many approaches have been pro posed for solving GTSP and WCSPP (e.g., [5, 7, 8, 23]. However, they cannot be applied to answer the KOR queries since one more constraint or objective must be satisﬁed in KOR compared with GSTP and WCSPP. In the KOR problem, we consider two hard constraints, namely, the keyword coverage and the budget limit, and aim to minimize the objective score. The simpliﬁed versions that consider any two aspects are also NPhard as we analyzed. Hence, it is challenging to ﬁnd an efﬁcient solution to answering KOR queries. If a route satisﬁes the two hard constraints, the route is called a feasible solu tionor afeasible route . Furthermore, we can extend the KOR query to the keyword aware topk route (KkR) query. Instead of ﬁnding the optimal route deﬁned in KOR , the KkRquery is to return kroutes starting and ending at the given locations such that they have the smallest objec tive scores, cover the query keywords, and satisfy the given budget constraint. 3. ALGORITHMS We present the preprocessing method in Section 3.1, the pro posed approximation algorithm OSScaling with provable approx imation bound in Section 3.2, the more efﬁcient approximation al gorithm BucketBound also with performance guarantee in Sec tion 3.3, and the greedy algorithm Greedy in Section 3.4. 3.1 Preprocessing We introduce the preprocessing method. We utilize the pre processing results to accelerate the algorithms to be proposed. We use the FloydWarshall algorithm [9], which is a wellknown algorithm for ﬁnding all pairs shortest path, to ﬁnd the following two paths for each pair of nodes (vi,vj):•τi,j: the path with the smallest objective score. The objective score of this path is denoted by OS(τi,j)and the budget score is denoted by BS(τi,j). •σi,j: the path with the smallest budget score. The objective score ofσi,jis denoted by OS(σi,j)and the budget score is denoted by BS(σi,j). For example, after the preprocessing, for the pair of node (v0,v7) in Figure 1, we have τ0,7=/an}⌊ra⌋ketle{tv0,v3,v4,v7/an}⌊ra⌋ketri}htwithOS(τ0,7) =4 and BS(τ0,7) =7 andσ0,7=/an}⌊ra⌋ketle{tv0,v3,v5,v7/an}⌊ra⌋ketri}htwithOS(σ0,7) =9 and BS(σ0,7) =5. Only the objective and budget scores of τi,jandσi,jare used in the proposed algorithms, while the two paths themselves are not. The space cost is O( |V|2), where |V|represents the number of nodes in the graph. In general, the number of points of interests |V|within a city is not large [15,19]. We use an inverted ﬁle to organize the word information of nodes. An inverted ﬁle index has two main components: 1) A vocabulary of all distinct words appearing in the descriptions of nodes (loca tions), and 2) A posting list for each word tthat is a sequence of identiﬁers of the nodes whose descriptions contain t. We use B+ tree for the inverted ﬁle index, which is disk resident. 3.2 Approximation Algorithm OSScaling A bruteforce approach to solving KOR is to do an exhaustive search: We enumerate all candidate paths from the source node. We can use a queue to store the partial paths. In each step, we select one partial path from the queue. Then it is extended to gen erate more candidate partial paths and those paths whose budget scores are smaller than the speciﬁed limit are enqueued. When a path is extended to the target node, we check whether it covers all the query keywords and satisﬁes the budget constraint. We record all the feasible routes, and after all the candidate routes from the source node to the target node have been checked, we select the best one of all the feasible routes as the answer to the query. However, the exhaustive search is computationally prohibitive. Given a query with a speciﬁed budget limit ∆, we know that the number of edges in a route exploited in the search is at most ⌊∆ bmin⌋, wherebminis the smallest budget value of all edges in G. Thus, the complexity of an exhaustive search is O( d⌊∆ bmin⌋), wheredis the maximum outdegree in G(notice that enumerating all the simple paths is not enough for answering KOR queries). To avoid the ex pensive exhaustive search, we devise a novel approximation algo rithm OSScaling . It is challenging to develop such an algorithm. The main problem of the bruteforce approach is that too many partial paths need to be stored on each node. In order to reduce the cost of enumerating the partial paths, in OSScaling , we scale the objective values of edges in Ginto integers utilizing a parame terǫ. The scaling enables us to bound the number of partial paths explored, and further to design a novel algorithm that runs poly nomially in the budget constraint ∆,1 ǫ, the number of nodes and edges in G, and is exponential in the number of query keywords (which is typically small). Furthermore, the objective score scaling guarantees that the algorithm always returns a route whose objec tive score is no more than1 1−ǫtimes of that of the optimal route, if there exists one. This is inspired by the FPTAS (fully polynomial time approximation scheme) for solving the wellknown knapsack problem [24]. Note that the problem of answering KOR queries is different from the NPhard problem knapsack and its solutions cannot be used. We deﬁne a scaling factor θ=ǫominbmin ∆, whereomin and bminrepresent the smallest objective value and the smallest budget value of all edges in G, respectively, and ǫis a parameter in the range (0,1). Next, for each edge (vi,vj), we scale its objective 1138valueo(vi,vj)toˆo(vi,vj) =⌊o(vi,vj) θ⌋. We call the graph with scaled objective values as the scaled graph , denoted by GS. Given a routeR=/an}⌊ra⌋ketle{tv0,v1,...,v n/an}⌊ra⌋ketri}htinGS, we denote its scaled objective score by ˆOS(R) =/summationtextn i=1ˆo(vi−1,vi). On the scaled graph, we still extend from the source node to cre ate new partial paths until we reach the target node. However, if a partial path has both smaller scaled objective score and budget score than another one on the same node, the OSScaling algo rithm ignores it. Before detailing the algorithm, we introduce the following important deﬁnitions. Deﬁnition 5: Node Label. For each node vi, we maintain a list of labels, in which each label corresponds to a path Pk ifrom the source node vsto nodevi. The label is denoted by Lk iand is in format of (λ,ˆOS,OS,BS ), whereLk i.λis the keywords covered byPk i,Lk i.ˆOS,Lk i.OS, andLk i.BS represent the scaled objec tive score, the original objective score, and the budget score of Pk i, respectively. ✷ Example 1: In the example graph shown in Figure 1, assuming ∆= 10 andǫ= 0.5, we can compute the value for θ:θ=0.5∗bmin∗omin 10 =1 20. Therefore, the objective value of each edge is scaled to 20 times of its original value. Given the two paths from v0tov4, i.e., R1=/an}⌊ra⌋ketle{tv0,v2,v3,v4/an}⌊ra⌋ketri}htandR2=/an}⌊ra⌋ketle{tv0,v2,v6,v5,v4/an}⌊ra⌋ketri}ht. The label of R1isL0 4= (/an}⌊ra⌋ketle{tt1,t2,t4/an}⌊ra⌋ketri}ht,100,5,7)and the label of R2isL1 4= (/an}⌊ra⌋ketle{tt1,t2,t4/an}⌊ra⌋ketri}ht,120,6,11). ✷ Each partial route is represented by a node label. At each node, we maintain a list of labels, each of which stores the information of a corresponding partial route from the source node to this node, including the query keywords already covered, the scaled objective score, the original objective score, and the budget score of the par tial route. Many paths between two nodes may exist, and thus each node may be associated with a large number of labels. However, most of the labels are not necessary for answering KOR . Consider ing Example 1, at node v4, the labelL1 4could be ignored since L0 4 has both smaller objective and budget scores. This is because that in the route extended from L1 4, we can always replace the partial route corresponding to L1 4with that corresponding to label L0 4. We say thatL0 4dominatesL1 4: Deﬁnition 6: Label Domination. LetLk iandLl ibe two labels corresponding to two different paths from the source node vsto nodevi. We sayLk idominatesLl iiffLk i.λ⊇Ll i.λ,Lk i.ˆOS≤ Ll i.ˆOS, andLk i.BS≤Ll i.BS. ✷ Notice that in OSScaling we determine if a label dominates an other one with regard to the scaled objective score instead of the original objective score. Therefore, it is likely that the label domi nated has smaller original objective score, and hence the optimal route may be missed in this algorithm. This is the reason that OSScaling can only return approximate results. However, by do ing so, the maximum number of labels on a node is bounded, which further bounds the complexity of OSScaling . We have the follow ing lemma: Lemma 1: On a node there are at most 2m⌊∆ bmin⌋⌊omax∆ ǫominbmin⌋ labels, where mis the number of query keywords, ǫis the scal ing parameter, bmin,omax, andominrepresent the smallest budget value, the largest objective value, and the smallest objective value of all edges in G, respectively. Proof Sketch: First, givenmquery keywords, there are at most 2mkeywords subset. Second, given the budget limit ∆, the num ber of edges in a route checked by our algorithm does not exceed ⌊∆ bmin⌋. Hence, the objective score of a route in GSis boundedby⌊∆ bmin⌋ˆomax =⌊∆ bmin⌋⌊omax θ⌋=⌊∆ bmin⌋⌊omax∆ ǫominbmin⌋.In conclusion, we only need to store at most 2m⌊∆ bmin⌋⌊omax∆ ǫominbmin⌋ labels, because all the rest can be dominated by them. ✷ Note that Lemma 1 gives an upper bound of the label number at a node. In practice, the number of labels maintained at a node is usually much smaller than this upper bound. We denote this upper bound byLmax. Next, we introduce how to do the route extension using labels. This step is called label treatment : Deﬁnition 7: Label Treatment. Given a label Lk iat nodevi, for each outgoing neighbor vjof nodeviinG, we create a new la bel forvj:Lt j= (Lk i.λ/uniontextvj.ψ,Lk i.ˆOS+ ˆo(vi,vj),Lk i.OS + o(vi,vj),Lk i.BS+b(vi,vj)). ✷ The label treatment step extends a partial route at node vifor ward to all the outgoing neighbor nodes of vi, and thus more longer partial routes are generated. Note that the label treatment step is ap plied together with label domination checking. Another important deﬁnition is how we compare the order of two labels: Deﬁnition 8: Label Order. LetLk iandLt jbe two labels cor responding to two paths from source node vsto nodeviandvj (viandvjcan be either the same or different nodes), respectively. We sayLk ihas a lower order than Lt j, denoted by Lk i≺Lt j, iff |Lk i.λ|>|Lt j.λ|or (|Lk i.λ|=|Lt j.λ|andLk i.ˆOS < Lt j.ˆOS) or (|Lk i.λ|=|Lt j.λ|,Lk i.ˆOS=Lt j.ˆOS, andLk i.BS < Lt j.BS); otherwise, breaking the tie by alphabetical order of viandvj.✷ In Example 1, we say that L0 4≺L1 4, because they contain the same number of query keywords, and L0 4has smaller objective and budget scores. This deﬁnition decides which partial route is se lected for extension in each step. Now we are ready to present our algorithms. The basic idea is to keep creating new partial routes from the best one among all ex isting partial routes. From the viewpoint of node labels, we ﬁrst create a label at the source node, and then we keep generating new labels that cannot be dominated by existing ones. We always select the one with the smallest order according to Deﬁnition 8 to gener ate new labels. If newly generated labels cannot be dominated by existing labels, they are used to detect and delete the labels domi nated by them. We repeat this procedure until all the labels on the target node are generated, and ﬁnally the label with the best objec tive score satisfying the budget limit at the target node is returned. Note that this is not an exhaustive search algorithm and we will analyze the complexity after presenting the algorithm. The pseudocode is presented in Algorithm 1. We use a min priority queue Qto organize the labels, which are enqueued into Q according to their orders deﬁned in Deﬁnition 8. We use variable Uto keep track of the upper bound of the objective score, and use LLto store the last label of the current best route. We initialize U as∞, and setLLasNULL . We create a label at the starting node vsand enqueue it into Q(lines 2–4). We keep dequeuing labels from QuntilQbecomes empty (lines 5–20). We terminate the algorithm when Qis empty or when all the labels inQhas objective scores larger than U. In each whileloop, we ﬁrst dequeue a label Lk iwith the minimum label order from Q (line 6). If the objective score of Lk iplus the best objective score OS(τi,t)fromvito the target node vtis larger than the current up per boundU, then the label deﬁnitely cannot contribute to the ﬁnal result (line 7). Next, for each outgoing neighbor vjofvi, we create a new labelLl jfor it according to Deﬁnition 7 (line 9). If Ll jcan be dominated by other labels on the node vjor if it cannot generate a 1139Algorithm 1: OSScaling Algorithm 1Initialize a minpriority queue Q; 2U←∞ ;LL←NULL ; 3At nodevs, create a label: L0 s←(vs.ψ,0,0,0); 4Q.enqueue(L0 s); 5whileQis not empty do 6Lk i←Q.dequeue(); 7 ifLk i.OS+OS(τi,t)>U then continue ; 8 foreach edge (vi,vj)do 9 Create a label Ll jforvj:Ll j←(Lk i.λ/uniontextvj.ψ,Lk i.ˆOS+ ˆo(vi,vj),Lk i.OS+o(vi,vj),Lk i.BS+b(vi,vj)); 10 ifLl jis not dominated by other labels on vjand Ll j.BS+BS(σj,t)<∆andLl j.OS+OS(τj,t)<U then 11 ifLl jdoes not cover all the query keywords then 12 Q.enqueue(Ll j); 13 foreach labelLonvjdo 14 ifLis dominated by Ll jthen 15 removeLfromQ; 16 else 17 ifLl j.BS+BS(τj,t)<∆then 18 U←Ll j.OS+OS(τj,t); 19 LL←Ll j; 20 elseQ.enqueue(Ll j); 21ifUis∞then return “No feasible route exits”; 22elseObtain the route utilizing LLand return it; feasible route (ﬁrst, the budget score of Ll jplusBS(σj,t), the best budget score to vt, is larger than the budget constraint ∆; second, the objective score of Ll jplusOS(τj,t), the best objective score to vt, is larger than the current upper bound U), we ignore the new la bel (line 10); Otherwise, if it does not cover all the query keywords, we enqueue it into Qand use it to detect and delete the labels that are dominated by it on vj(lines 11–15). When we ﬁnd that the current label Ll jalready covers all the query keywords, a feasible solution is found and we update the upper bound U(lines 16–20). First, if the budget score of Ll jplus the budget score of τj,t(the path with the best objective score from vjtovt) is smaller than U, we update the upper bound U, and the last label is also updated (lines 18–19); otherwise, we enqueue this label intoQfor later processing. Finally, if Uis never updated, we know that there exists no feasible route for the given query; otherwise, we can construct the route using the label LL(lines 21– 22). The following example illustrates how this algorithm works. Figure 2: Steps of Example 2Example 2: Consider the example graph in Figure 1, the query Q=/an}⌊ra⌋ketle{tv0,v7,{t1,t2},10/an}⌊ra⌋ketri}ht, andǫis set as 0.5. The steps of the algorithm are shown in Figure 2 and the contents of the labels gen erated are in Table 1. Initially, we create a label L0 0=(∅, 0, 0, 0) at node v0and enqueue it intoQ. After we dequeue it from Q, as shown in step (a), we generate the following three labels on all the outgoing neighbors of v0:L0 1,L0 2, andL0 3. The three labels are also enqueued into Q. In the next loop, L0 2is selected because L0 2≺L0 3≺L0 1. As shown in Step (b), we generate another two labels L1 3andL0 6. Note that the best budget score from v6tov7is 7 (BS(σ6,7)=7), and thus L0 6can be ignored since L0 6.BS+BS(σ6,7)(=11)>∆. According to the preprocessing results, OS(τ3,7)=2 and BS(τ3,7)=5. There fore, in step (c), we get a feasible route R1=/an}⌊ra⌋ketle{tv0,v2,v3,v4,v7/an}⌊ra⌋ketri}ht withOS(R1)=6 and BS(R1)=10. The upper bound Uis updated asOS(R1), i.e.,U=6. Next,L0 3on nodev3is selected. As shown in Step (d), we gen erate another three labels and enqueue them into Q:L1 1,L0 4, and L0 5. Now label L0 5already covers all the query keywords on v5. According to the preprocessing results, from v5tov7, the best ob jective score is 3 ( OS(τ5,7)=3) and the budget score of this path is 4. Utilizing the preprocessing results, as shown in step (e), we can obtain another feasible solution R2=/an}⌊ra⌋ketle{tv0,v3,v5,v4,v7/an}⌊ra⌋ketri}htwith OS(R2)=8 and BS(R2)(=8)<∆(Note that suppose ∆=7 in Q, R2will not be a feasible result. Instead, we enqueue the label L0 5 intoQ, and in the next loop, we include the edge (v5,v7)and get a feasible route /an}⌊ra⌋ketle{tv0,v3,v5,v7/an}⌊ra⌋ketri}ht). The rest labels are treated similarly, and the best route is R1.✷ L0 0L0 1L1 1L0 2L0 3L1 3L0 4L0 5L0 6 λ∅∅t1t2t1t1,t2t1t1,t2t1,t2 ˆOS 0 80 60 20 40 80 60 100 40 OS 0 4 3 1 2 4 3 5 2 BS 0 1 4 3 2 5 4 4 4 Table 1: Labels contents Complexity: In each loop of OSScaling , we dequeue one label fromQ. Thus, in the worst case we need |V|Lmaxloops according to Lemma 1. Within one loop, 1) we generate new labels on a node and check the domination on its outgoing neighbors, taking O(|E|Lmax) time by aggregate analysis; 2) we dequeue one label and the complexity is O( lgLmax). Hence, we can conclude that the worst time complexity is O( |V|LmaxlgLmax+|E|Lmax)). In practice, the number of loop is much smaller than the worst case and the number of keywords of a query is quite small. Therefore, the algorithm OSScaling is able to return the result efﬁciently. By scaling the objective values of edges in G, the algorithm OSScaling is able to guarantee an approximation bound. Approximation Bound: We denote the route found by OSScaling asROS, and the feasible route with the smallest scaled objective score in GSasRGS. We have the following lemma: Lemma 2: OS(RGS)≥OS(ROS). Proof Sketch: In Algorithm 1, if we use the partial route with the smallest scaled objective score to update the upper bound at node vj(line 18), the algorithm returns RGS. We denote the objective score of a route from vptovqasOp,q, and we know Os,j(RGS) = Os,j(ROS). According to the algorithm, Oj,t(RGS)≥τj,t= Oj,t(ROS), and thus OS(RGS) =Os,j(RGS) +Oj,t(RGS)≥ Øs,j(ROS) +Oj,t(ROS) =OS(ROS). ✷ We denote the optimal route as Ropt. We have: Theorem 2: OS(Ropt)≥(1−ǫ)OS(ROS). 1140Proof Sketch: From ˆo=⌊o θ⌋, we know that o−θ≤θˆo≤o. Therefore, OS(Ropt) =/summationtext e∈Roptoe≥/summationtext e∈Roptθˆoe. , then: OS(Ropt)≥/summationdisplay e∈Roptθˆoe≥/summationdisplay e′∈RGSθˆoe′≥/summationdisplay e′∈RGS(oe′−θ) ≥/summationdisplay e′∈RGSoe′− ⌊∆ bmin⌋θ≥/summationdisplay e′∈RGSoe′−ǫomin Because/summationtext e′∈RGSoe′≥omin, we can conclude that OS(Ropt)≥ (1−ǫ)/summationtext e′∈RGSoe′= (1 −ǫ)OS(RGS)≥(1−ǫ)OS(ROS) (according to Lemma 2). ✷ We can see that the parameter ǫaffects not only the running time of this algorithm but also the accuracy. There is a tradeoff between the efﬁciency and accuracy when selecting a value for ǫ. With a larger value of ǫ,OSScaling runs faster but the accuracy would drop; on the contrary, with a smaller value for ǫwe can obtain better routes but that needs longer query time. Optimization: We design the following optimization strategies to further improve Algorithm 1. Optimization Strategy 1: When processing a label Lk iat node vi, in addition to the labels generated by following the outgoing edges ofviin the graph, we also generate a label on a node vjsuch thatBS(σi,j)has the smallest value among all the nodes containing a uncovered query keyword and Lk i.BS+BS(σi,j) +BS(σj,t)≤ ∆. The motivation of this strategy is to ﬁnd a feasible solution as early as possible, and then it is used to update the upper bound and further to prune more labels. Optimization Strategy 2: When the query contains some very infrequent words, we can utilize the nodes that contain them to ﬁnd the result more efﬁciently. In Algorithm 1, when we decide if a labelLk ican be deleted, two speciﬁc conditions are checked: 1) ifLk i.OS+OS(τi,t)is smaller than U; 2) ifLk i.BS +BS(σi,t) is smaller than ∆. We utilize the scores of the two preprocessed routes fromvito the target node vt. But if the path from vito the nodes containing the infrequent words have large objective or bud get scores, we will waste a lot of time on extending the route from vi. The reason is that, although the label Lk icannot be pruned by the two conditions, it cannot generate useful labels, and this is not known until we reach the nodes containing the infrequent words. We ﬁrst obtain all the nodes containing the least infrequent word (which must be below a frequency threshold, such as appearing in less than 1% nodes) utilizing the inverted ﬁle; after we gener ate a labelLk i, if it does not cover the least infrequent word, for each nodel, we check two conditions: 1) Lk i.OS +OS(τi,l) + OS(τl,t)>U; 2)Lk i.BS+BS(σi,l) +BS(σl,t)>∆. If on each node containing infrequent words at least one condition is satisﬁed, this label can be discarded. 3.3 Approximation Algorithm BucketBound In the algorithm OSScaling , after we ﬁnd a feasible solution, we still have to keep searching for a better route until all the fea sible routes are checked. We propose a more efﬁcient approximate method denoted by BucketBound with provable approximation bounds which is also based on scaling the objective scores into in tegers. Before describing the proposed algorithm, we introduce the fol lowing lemma which lays a foundation of this algorithm. Lemma 3: Given a label Lk iat nodevi, the best possible objective score of the feasible routes that could be extended from the partial path represented by Lk iisLk i.OS+OS(τi,t). We denote the score byLOW (Lk i).Proof Sketch: Ifτi,tandLk icover all query keywords collectively, they constitute the best route extending from Lk iand its objective score is equal to Lk i.OS+OS(τi,t). Otherwise, another route from vitovtcovering more keywords must be selected to construct a feasible route. This route has larger objective score than that of τi,t, which results in a larger objective score of the ﬁnal route. ✷ In this algorithm, we divide the traversed partial routes into dif ferent “buckets” according to their best possible objective scores. We deﬁne the buckets as follows: Deﬁnition 9: Label Buckets. The label buckets organize labels. Each bucket is associated with an order number and corresponds to an objective score interval—the rth bucketBrcorresponds to the following interval: [βrOS(τs,t),βr+1OS(τs,t)),where OS(τs,t) is the best objective score from vstovtandβis a speciﬁed param eter. A label Lk iis in the bucket Brif: βrOS(τs,t)≤LOW (Lk i)<βr+1OS(τs,t) ✷With this important deﬁnition, we proceed to present the approx imation algorithm BucketBound . We denote the route found by OSScaling asROS. The basic idea is as follows: We keep select ing labels (partial routes) from the buckets. When selecting a label, we always choose the nonempty bucket with the smallest order number, and then select a label with the lowest label order from it. After a label Lk iis generated, we compute the score LOW (Lk i)and we place this label to the corresponding bucket according to Deﬁ nition 9. Utilizing the label buckets enables us to ﬁnd a novel way to detect if a feasible route found is in the same bucket as ROS. If we ﬁnd such a route during the above procedure, we return it as the result. We denote the route found by BucketBound asRBB. We proceed to explain how to determine if the bucket where we ﬁnd a feasible route contains ROS. This algorithm follows the basic label generation and selection approach in OSScaling . However, the strategies of generating and selecting labels are different. With such changed label generation and selection strategies, we have the following lemma: Lemma 4: If all the buckets Bi(i= 0,...,r )are empty and no feasible solution is found yet, the objective score of ROSsatisﬁes: OS(ROS)≥βr+1OS(τs,t). Proof Sketch: Since any bucket Bi(i≤r)is empty, we know the label corresponding to ROSmust be selected from the subsequent buckets. Therefore, LOW (Ll j)> βr+1OS(τs,t). According to Lemma 3, we know OS(ROS)≥LOW (Ll j)≥βr+1OS(τs,t). ✷ Based on Lemma 4, we have Lemma 5. When the condition in Lemma 5 is satisﬁed, a feasible route and ROSfall into the same bucket, and the algorithm terminates. Lemma 5: When a feasible route RBBis found in the bucket Br+1 and all the buckets B0,B1, ...,Brare empty, the route ROSfound byOSScaling is also contained in Br+1. Proof Sketch: Because any bucket Bi(i≤r)is empty, according to Lemma 4, OS(ROS)≥βr+1OS(τs,t). Since OS(ROS)≤ OS(RBB)(RBBis one feasible solution found in OSScaling ), we knowβr+1OS(τs,t)≤OS(ROS)≤OS(RBB)<βr+2OS(τs,t). According to Deﬁnition 9, ROSalso falls inBr+1. ✷ Figure 3 illustrates the basic process of the proposed approxi mation algorithm BucketBound . As shown in the ﬁgure, we ﬁrst select the label Lk ifrom the bucket B0, and after the label treatment the new label is put into the bucket B3. SinceB0becomes empty now, we proceed to select labels from B1. IfB0,B1, andB2all 1141Figure 3: Process of Algorithm 2 become empty, according to Lemma 4 we can know OS(ROS)≥ β3OS(τs,t). If now we ﬁnd a feasible route RBBin the bucket B3, according to Lemma 5, it is assured that ROSalso falls into B3, and we return RBBas the result. Unlike Algorithm 1, the approximation algorithm terminates im mediately when Lemma 5 is satisﬁed, which means a feasible so lution is found. Note that the feasible solution may be different from the ﬁrst feasible solution found by Algorithm 1. This algo rithm is also capable of determining if a feasible route exists. If all buckets are empty during the label selection step and no feasible route found yet, there exists no result for KOR . This is because that when all buckets are empty, all the labels generated do not sat isfy the budget constraint, which means that all the partial routes generated from the source node exceed the budget limit ∆. Algorithm 2: BucketBound Algorithm 1Initialize a minpriority queue B0; 2LL←NULL ;Found←false; 3At nodevs, create label L0 s←(vs.ψ,0,0,0); 4B0.enqueue(L0 s); 5whileFound is false do 6Br←the queue of the ﬁrst nonempty bucket; 7 ifAll queues are empty then return “No feasible route exist”; 8Lk i←Br.dequeue(); 9 foreach edge (vi,vj)do 10 Create a new label Ll jforvj: Ll j←(Lk i.λ/uniontextvj.ψ,Lk i.ˆOS+ ˆo(vi,vj),Lk i.OS+ o(vi,vj),Lk i.BS+b(vi,vj)); 11 ifLl jis not dominated by other labels on vjand Ll j.BS+BS(σj,t)<∆then 12 FindBsthatLl jfalls into; 13 ifBsdoes not exist then 14 Initialize a priority queue Bs; 15 Bs.enqueue(Ll j); 16 foreach labelLonvjdo 17 ifLis dominated by Ll jthen 18 removeLfrom the corresponding queue; 19 ifLl jcovers all the query keywords then 20 ifBrandBsare the same queue then 21 ifLl j.BS+BS(τj,t)≤∆then 22 Found←true;// Lemma 5 23 LL←Ll j; 24Obtain the route utilizing LLand return the route; The algorithm is detailed in Algorithm 2. It uses a minpriority queue for each bucket to organize the labels in the bucket. We ini tialize the ﬁrst minpriority queue B0(corresponding to the ﬁrst bucket with boundary [ OS(τs,t),βOS(τs,t)));UandLLare ini tialized as in Algorithm 1. We initialize the ﬂag Found as false, which records if a feasible route is found. We create a label at the source node vsand enqueue it into B0(lines 1–4). The algorithmterminates when the ﬂag Found is true. We keep dequeuing labels fromBrwhich represents the nonempty bucket with the smallest order number until we ﬁnd a solution or no result exists(lines 5– 23). If all queues become empty, it is assured that no feasible route exists (line 7). After we select a label Lk ion nodevi, for each out going neighbor vjofvi, we create a new label for it (line 10). When a new labelLl jis generated, we check: 1) if it can be dominated by other labels on vj; 2) if it cannot generate results deﬁnitely. If so, we ignore it (line 11); Otherwise, we use it to delete labels on vjthat can be dominated by it, and we enqueue this label to the corresponding bucket according to its best possible objective score (lines 12–18). When Ll jalready covers all the query keywords and also falls into Br, we still need to test if the path corresponding to LOW (Ll j)satisﬁes the budget constraint. If so, we ﬁnd a solution and exit the loop according to Lemma 5 (lines 19–23). Theorem 3: Algorithm 2 offers the approximation ratioβ 1−ǫ.Proof Sketch: Assume that the solution RBBis found inBk. According to Lemma 5, the route found by OSScalingROSis also contained inBk. Thus, we have OS(ROS)≥βkOS(τst)andOS(RBB)< βk+1OS(τst). According to Theorem 2, we can get:OS(RBB) OS(Ropt)= OS(RBB) OS(ROS)OS(ROS) OS(Ropt)<βk+1OS(τst) βkOS(τst)(1−ǫ)=β 1−ǫ✷Although BucketBound has the same worst case complexity as Algorithm 1, it processes much fewer labels and is more efﬁcient in practice. Note that the two optimization strategies in OSScaling are still applicable in BucketBound . 3.4 Greedy Algorithm We propose an approximation algorithm using the greedy ap proach to solve KOR . It has no performance guarantee. There are three constraints in the KOR problem: a) a set of keywords must be covered; b) the objective score must be mini mized; c) the budget limit ∆must be satisﬁed. As discussed in Section 2, by considering only two of them, the problem is still NPhard. Therefore, a greedy approach normally cannot grantee that two constraints are satisﬁed. Since the keyword and budget constraints are hard constraint, we design a greedy algorithm such that it is able to ﬁnd a route either covering all the query keywords or satisfying the budget constraint, while minimizing the objective score greedily. The idea is that we start from the source node, and keep selecting the next best node according to a certain strategy until we ﬁnally reach the target node. The strategy of selecting the next node affects the results signiﬁcantly. We design a greedy strategy that takes into account all the three constraints simultaneously to ﬁnd the best next node: a) the node contains uncovered query keywords; and b) the best route that can be generated after including this node into the current partial route is expected to have a small objective score and fulﬁll the budget constraint. We use a parameter αto balance the importance of the objective and budget scores when selecting a node: at node vi, when we extend the current partial route Ri ending atvi, we select the node vjthat minimizes the following score: score (vj,Ri) =α(Ri.OS+OS(τi,j) +OS(τj,t)) + (1−α)(Ri.BS+BS(τi,j) +BS(τj,t))(1) Whenα= 0, we select a node only based on the budget score, i.e., selecting the node such that the budget score of the corresponding partial route plus the best budget score from the node to the target nodevtis the smallest. When α= 1, the algorithm ﬁnds a node such that the objective score of the corresponding partial route plus the best objective score from the node to vtis minimized. 1142Algorithm 3: Greedy Algorithm 1nodeSet←∅;wordSet←Q.Ω\vs.ψ; 2vpre←vs;OS←0;BS←0; 3foreach wordwt∈wordSet do 4 Get the location set lSet containingwt; 5nodeSet←nodeSet/uniontextlSet; 6whilewordSet is not empty do 7 minS←argmin vm∈nodeSet score(vm,Rpre); 8OS←OS+OS(τpre,m );BS←BS+BS(τpre,m ); 9vpre←vm; 10wordSet←wordSet\vm.ψ; 11 Remove the locations containing vm.ψfromnodeSet ; 12OS←OS+OS(τpre,t);BS←BS+BS(τpre,t); 13Return the route found with scores OSandBS; The pseudocode is outlined in Algorithm 3. We use wordSet to keep track of the uncovered query keywords and nodeSet to store all the locations containing uncovered query keywords (line 1). vpredenotes the node where the current partial path ends and is initialized as vs.OSandBSare used to store the objective and budget scores and both initialized to 0 (line 2). We utilize inverted ﬁle to ﬁnd locations for nodeSet (lines 3–5). The algorithm termi nates whenwordSet is empty. While it is not empty, we ﬁnd the best node according to Equation 1 (line 7), extend the partial route (line 8–9), and update wordSet andnodeSet (lines 10–11). After we exit the loop, we add the last segment from the partial route’s last node to the target node vtto construct the ﬁnal route and return (lines 12–13). Algorithm 3 may fail to ﬁnd a feasible route even if there ex its a feasible one. In each step, it selects the next best node. If we ﬁnd more nodes at each step, the accuracy will be better while the search space becomes much larger. Hence, it is a tradeoff be tween the accuracy and efﬁciency. In the experiments, we study the performance of Algorithm 3 when the best 2 nodes are selected at each step. We denote the algorithm selecting one node by Greedy  1, and the algorithm selecting two nodes by Greedy 2. The worst time complexity of Greedy 1 is O(mn) and for Greedy 2 it is O(2mn), wheremis the number of query keywords and nis the number of nodes in the graph. Algorithm 3 guarantees that the query keywords are always cov ered while the budget limit may not be satisﬁed. This is desirable when the query keywords are important to users (e.g., the users do not want to miss any type of locations in their plan). However, if the budget score is very important (e.g., the users cannot overrun their money budget), we modify this algorithm slightly to accom modate the need. We return a route with budget score not exceed ing∆while the query keywords may not be totally covered. We break the whileloop when the current partial route cannot be ex tended any more. That is, in line 6 in Algorithm 3, we check if L.BS +BS(σl,t)>∆instead of if wordSet is empty. 3.5 Keywordaware Top kOptimal Route Search We further extend the KOR query to the keywordaware top k route (KkR) query. Instead of ﬁnding the optimal route deﬁned inKOR , the KkRquery is to return the top kroutes starting and ending at the given locations such that they have the best objective scores, cover all the query keywords, and satisfy the given budget constraint. We introduce how to modify the OSScaling algorithm and the BucketBound algorithm for solving KkRapproximately. It is relatively straightforward to extend the two approximation algorithms OSScaling andBucketBound for processing the KkR query. Due to space limitations, we only brieﬂy present the extension. We need to introduce the deﬁnition of “ kdominate”. A label is “kdominated” if at least klabels dominate it. In the pseudocode ofOSScaling algorithm, we need to replace “dominate” by ” k dominate.” Moreover, instead of keeping track of only the current best result, we need to track the current best kresults. The budget score of the kth best route is used as the upper bound Uto prune unnecessary labels. Similarly, in the BucketBound algorithm, we also apply “kdominate”. Moreover, instead of returning immedi ately when we ﬁnd a feasible route in the bucket containing ROS, the algorithm terminates when we ﬁnd kfeasible routes from the nonempty bucket with the smallest order number. Note that we do not extend the greedy algorithm for solving KkR. The greedy approach is not able to guarantee that a feasi ble route can be found. Therefore, it is meaningless to return k routes using such a method. 4. EXPERIMENTAL STUDY 4.1 Experimental Settings Algorithms. We study the performance of the following proposed algorithms: the approximation algorithm OSScaling in Section 3.2, the approximation algorithm BucketBound in Section 3.3, and the greedy algorithms in Section 3.4, denoted by Greedy 1 and Greedy 2 corresponding to selecting the top1 and top2 best loca tions, respectively. Additionally, we also implemented a naive bruteforce approach discussed in Section 3.2. However, it is at least 2 orders of magni tude slower than OSScaling and cannot ﬁnish after 1 day, and thus is omitted. Data and queries. We use ﬁve datasets in our experimental study. The ﬁrst one is a reallife dataset collected from Flickr3using its public API. We collected 1,501,553 geotagged photos taken by 30,664 unique users in the region of the New York city in the United States. Each photo is associated with a set of userannotated tags. The latitude and the longitude of the place where the photo is taken and its taken time are also collected. Following the work [15], we utilize a clustering method to group the photos into locations. We associate each location with tags obtained by aggregating the tags of all photos in that location after removing the noisy tags, such as tags contributed by only one user. Finally, we obtain 5,199 lo cations and 9,785 tags in total. Each location is associated with a number of photos taken in the location. Next, we sort the photos from the same user according to their taken time. If two consecu tive photos are taken at two different places and the taken time gap is less than 1 day, we consider that the user made a trip between the two locations, and we build an edge between them. On each edge, the Euclidean distance between its two vertices (locations) serves as the budget value. We compute a popularity score for each edge following the idea of the work [4]. The pop ularity of an edge ( vi,vj) is estimated as the probability of the edge being visited: Pri,j=Num (vi,vj) TotalTrips, whereNum (vi,vj)is the number of trips between viandvjandTotalTrips is the to tal number of trips. The total popularity score of a route R= (v0,v1,...,v n)is computed as: PS(R) =/producttextn i=1Pri−1,i. How ever, the popularity score should be maximized. To transform the maximization problem to the minimization problem as deﬁned in KOR , we compute the objective score on each edge ( vi,vj) as: o(vi,vj) =log(1 Pri,j). Therefore, if OS(R)is minimized, PS(R) is maximized. 3http://www.ﬂickr.com/ 1143The other 4 datasets are generated from real data, mainly for scalability experiment. By extracting the subgraph of the New York road network4, we obtain 4 datasets containing 5,000, 10,000, 15,000, and 20,000 nodes, respectively. Each node is associated with a set of randomly selected tags from the real Flickr dataset. The travel distance is used as the budget score, and we randomly generate the objective score in the range (0,1) on each edge to cre ate the graphs for the four datasets. We generate 5 query sets for the Flickr dataset, in which the num ber of keywords are 2, 4, 6, 8, and 10, respectively. The starting and ending locations are selected randomly. Each set comprises 50 queries. Similarly, we also generate 5 query sets for each of the 4 other datasets. All algorithms were implemented in VC++ and run on an In tel(R) Xeon(R) CPU X5650 @2.66GHz with 4GB RAM. 4.2 Experimental Results 4.2.1 Efﬁciency of Different Algorithms The objective of this set of experiments is to study the efﬁciency of the proposed algorithms with variation of the number of query keywords and the budget limit ∆(travel distance). We set the value for the scaling parameter ǫinOSScaling andBucketBound at 0.5, the speciﬁed parameter βat 1.2 for BucketBound , and the default value forαinGreedy at 0.5. We conduct the experiment to study the runtime when varying the value of ǫforOSScaling , and the experiment to study the runtime when varying the value of βfor BucketBound (ǫ=0.5). Note that the runtime of Greedy is not affected byα. 110100100010000100000 2 4 6 8 10Runtime (milliseconds) number of query keywordsOSScaling BucketBound Greedy2 Greedy1 Figure 4: Runtime (Flickr)110100100010000100000 3 6 9 12 15Runtime (milliseconds) ∆ (kilometers)OSScaling BucketBound Greedy2 Greedy1 Figure 5: Runtime (Flickr) Varying the number of query keywords. Figure 4 shows the run time of the four algorithms on the Flickr dataset when we vary the number of query keywords. For each number, we report the aver age runtime over ﬁve runs, each using a different ∆, namely 3, 6, 9, 12, and 15 kilometers, respectively. Note that the yaxis is in logarithmic scale. We can see that all the algorithms are reasonably efﬁcient on this dataset. As expected, the algorithm OSScaling runs much slower than the other three algorithms. BucketBound is usually 810 times faster than OSScaling , although OSScaling andBucketBound have the same worst time complexity. This is because BucketBound terminates immediately when a feasi ble route is found in the bucket containing ROS, the route found byOSScaling , and thus it generates much fewer labels than does OSScaling . The worst time complexity of both OSScaling and BucketBound is exponential in the number of query keywords. However, as shown in the experiment, the runtime does not increase dramatically as the number of query keywords is increased. This is due to the two optimization strategies employed in both algo rithms. Without employing the optimization strategies, both algo rithms will be 35 times slower. Due to space limitations, we omit the details. 4http://www.dis.uniroma1.it/ challenge9/download.shtmlGreedy 1 is the fastest since it only selects the best node in each step. However, as to be shown, its accuracy is the worst. Greedy  1 is not affected signiﬁcantly by the number of query keywords. The runtime of Greedy 2 increases dramatically with the increase of query keywords. This is because Greedy 2 selects the best 2 nodes at each step, and its asymptotically tight bound complexity is exponential in the number of query keywords. Varying the budget limit ∆.Figure 5 shows the runtime of the four approaches on the Flickr dataset with the variation of ∆. At each ∆, the average runtime is reported over 5 runs, each with a different number of query keywords from 2 to 10. The runtime ofOSScaling grows when ∆increases from 3 km to 6 km as a smaller ∆can prune more routes. However, as ∆continues to increase, the runtime decreases slightly. This is due to the fact that with a larger ∆,OSScaling ﬁnds a feasible solution earlier (since ∆is more likely to be satisﬁed), and then the feasible solu tion can be used to prune the subsequent search space. The saving dominates the extra cost incurred by using larger ∆(notice that larger ∆deteriorates the worstcase performance rather than the average performance). As for the other approximation algorithms, their runtime is almost not affected by the budget limit as shown in the ﬁgure. 0100020003000 0.1 0.3 0.5 0.7 0.9Runtime (milliseconds) εOSScaling Figure 6: Runtime11.0051.011.0151.02 0.1 0.3 0.5 0.7 0.9Relative Ratio εOSScaling Figure 7: Relative Ratio Varying the parameter ǫforOSScaling .Figure 6 shows the run time of OSScaling when we vary the value of ǫ. We set ∆as 6 km and the number of query keywords as 6. It is observed that OSScaling runs faster as the value of ǫincreases. This is because whenǫbecomes larger, Lmax, the upper bound of the number of labels on a node is decreased, and thus more labels (representing partial routes) can be pruned during the algorithm. This is consis tent with the complexity analysis of OSScaling , which shows that OSScaling runs linearly in1 ǫ. 0306090120 1.2 1.4 1.6 1.8 2.0Runtime (milliseconds) βBucketBound Figure 8: Runtime11.051.101.151.20 1.2 1.4 1.6 1.8 2.0Relative Ratio βBucketBound Figure 9: Relative Ratio Varying the parameter βforBucketBound .Figure 8 shows the runtime of BucketBound when we vary the value of β, the spec iﬁed parameter. In this set of experiments, ∆=6 km,ǫ=0.5, and the number of query keywords is 6. As expected, BucketBound runs faster as the value of βincreases. This is because when β becomes larger, the interval of each bucket becomes larger and each bucket can accommodate more labels. Hence, it is faster for BucketBound to ﬁnd a feasible solution in the bucket containing the best route in G. 11444.2.2 Accuracy of Approximation Algorithms The purpose of this set of experiments is to study the accuracy of the approximation algorithms. The bruteforth method discussed in Section 3.2 failed to ﬁnish for most of settings after more than 1 day. We note that in the very few successful cases (small ∆and keywords), the practical approximation ratios of OSScaling and BucketBound are a lot smaller than their theoretical bounds, com pared with the exact results by the bruteforth method,. To make the experiments tractable, we study the relative approximation ra tio. We use the result of OSScaling withǫ=0.1 (which has the smallest approximation ratio in the proposed methods) as the base and compare the relative performance of the other algorithms with it. We compute the relative ratio of an algorithm over OSScaling withǫ=0.1 as follows: For each query, we compute the ratio of the objective score of the route found by the algorithm to the score of the route found by OSScaling withǫ=0.1, and the average ratio over all queries is ﬁnally reported as the measure. With the measure, we study the effect of the following parame ters on accuracy, namely the number of query keywords, the budget limit ∆, the scaling parameter ǫinOSScaling , the speciﬁed pa rameterβinBucketBound , and the parameter αwhich balances the importance of the objective and budget scores during the node selection, for Greedy . 11.11.21.31.4 2 4 6 8 10Relative Ratio number of query keywordsBucketBound Greedy2 Greedy1 Figure 10: Relative Ratio11.11.21.31.4 3 6 9 12 15Relative Ratio ∆ (kilometer)BucketBound Greedy2 Greedy1 Figure 11: Relative Ratio Varying the number of query keywords or ∆.Figure 10 shows the relative ratio compared with the results of OSScaling with ǫ=0.1 for the experiment in Figure 4, in which we vary the num ber of query keywords. Figure 11 shows the relative ratio for the experiment in Figure 5, in which we vary the value of budget limit ∆, respectively. Note that ǫ=0.5 andβ=1.2 in the two experiments. Since the greedy algorithms fail to ﬁnd a feasible solution on about 10%–20% queries, for greedy algorithms we measure the rel ative ratio only on the queries where Greedy 1 and Greedy 2 are able to ﬁnd feasible routes. For OSScaling andBucketBound , the reported results are based on all queries, which are similar to the re sults if we only use the set of queries for which Greedy returns fea sible solutions. We observe that the relative ratio of BucketBound compared with the results of OSScaling is always below the spec iﬁed parameter β. It can also be observed that BucketBound can achieve much better accuracy than do Greedy 1 and Greedy 2, especially when the number of query keywords or the value of ∆ is large. Varying the parameter ǫforOSScaling .Figure 7 shows the ef fect ofǫon the relative ratio in OSScaling . We set ∆as 6 kilome ters and the number of query keywords at 6. We can observe that the relative ratio becomes worse as we increase ǫ, which is consis tent with the result of Theorem 2, i.e., the performance bound of OSScaling is1 1−ǫ. Varying the parameter βforBucketBound .Figure 9 shows the effect ofβon the relative ratio in BucketBound , while the corre sponding runtime is reported in Figure 8, where we set ǫ=0.5, ∆=6 km, and the number of query keywords as 6. As expected, the rela tive ratio becomes worse as we increase β. Note that relative ratioofBucketBound compared to the results of OSScaling is consis tently smaller than the speciﬁed β. 11.21.41.6 0 0.25 0.50 0.75 1.00Relative Ratio αGreedy1 Greedy2 Figure 12: Relative Ratio05101520 0 0.25 0.50 0.75 1.00Failure Percentage % αGreedy1 Greedy2 Figure 13: Failure Percentage Varying the parameter αforGreedy .Figure 12 shows the rela tive ratio of Greedy 1 and Greedy 2 compared with the results ofOSScaling when we vary α, and Figure 13 shows the per centage of failed queries. In this set of experiments, we set ∆ as 6 kilometers, and the average performance is reported over 5 runs, each with a different number of query keywords from 2 to 10. Note that the relative ratio is computed based on the set of queries where Greedy 1 and Greedy 2 are able to ﬁnd feasible routes over the set of queries with feasible solutions ( OSScaling andBucketBound guarantee to return feasible results if any). We observe that as the value of αincreases the relative ratio becomes worse for both Greedy 1 and Greedy 2, but they succeed in ﬁnd ing feasible routes for more queries. When αis set as 0, which means that the objective score is the only criterion when selecting the node in each step of Greedy , both Greedy 1 and Greedy 2 achieve the best average ratio while the failure percentage is the largest. When α=1, the next best node is selected merely based on the budget score. Hence, Greedy is able to ﬁnd feasible re sults on more queries, but the relative accuracy becomes much worse on the queries for which Greedy is able to return feasible solutions. Greedy 2 outperforms Greedy 1 consistently, because more routes are checked in Greedy and it is likely to ﬁnd more feasible and better routes. 4.2.3 Comparing OSScaling and BucketBound 010100100010000 2 4 6 8 10Runtime (milliseconds) RatioOSScaling BucketBound Figure 14: Runtime1.031.061.091.121.15 2 4 6 8 10Relative Ratio RatioOSScaling BucketBound Figure 15: Relative Ratio The aim of this set of experiment is to compare the performance ofOSScaling andBucketBound when they have the same theo retical approximation ratio. In this set of experiments, ∆=6 km, β=1.2, and the number of query keywords is 6. The values of ǫ are computed according to different performance bounds for both algorithms. Figures 14 and 15 show the runtime and relative ratio ofOSScaling andBucketBound when we vary the performance bound, respectively. We observe that BucketBound runs consis tently faster than OSScaling over all performance bounds while OSScaling always achieves better relative ratio. 4.2.4 Performance of Algorithms for KkR We study the performance of the modiﬁed versions of the two approximation algorithms, i.e., OSScaling andBucketBound for 1145900 600 300 0 5 4 3 2 1Runtime (milliseconds) kOSScaling BucketBound Figure 16: Runtime10000 1000 100 10 1 20k 15k 10k 5kruntime (milliseconds) number of nodesOSScaling BucketBound Greedy2 Greedy1 Figure 17: Scalability processing KkR. We setǫ=0.5,β=1.2, ∆=6 km, and the aver age runtime is reported over 5 runs, each with a different number of query keywords from 2 to 10. The results are shown in Fig ure 16. BucketBound always outperforms OSScaling in terms of runtime. As expected, both algorithms run slower as we increase the value ofk. InOSScaling , more labels need to be generated for largerk, which leads to longer runtime. Algorithm BucketBound terminates only after the top kfeasible routes are found, thus need ing longer query time. 4.2.5 Experiments on More Datasets 10000 1000 100 10 1 10 8 6 4 2Runtime (milliseconds) number of query keywordsOSScaling BucketBound Greedy2 Greedy1 Figure 18: Runtime10000 1000 100 10 1 15 12 9 6 3Runtime (milliseconds) ∆ (kilometer)OSScaling BucketBound Greedy2 Greedy1 Figure 19: Runtime We also conduct experiments on the synthetic dataset containing 5,000 nodes. Figure 18 and 19 show the runtime when we vary the number of query keywords and the value of ∆, respectively. We setǫas 0.5 andβas 1.2. The comparison results are consistent with those on the Flickr dataset. For the relative ratio, we observe qualitatively similar results on this dataset as we do on Flickr. We omit the results due to space limitations. 4.2.6 Scalability Figure 17 shows the runtime of the proposed algorithms (the number of query keywords is 6 and ∆=30 km). They all scale well with the size of the dataset. The relative ratio changes only slightly; we omit the details due to the space limitation. 4.2.7 Example Figure 20: Example Route 1  Figure 21: Example Route 2 We use one example found in the Flickr dataset to show that KOR is able to ﬁnd routes according to users’ various preferences. We set the starting location at the Dewitt Clinton park and the des tination at United Nations Headquarters, and the query keywords are “jazz”, “imax”, “vegetation”, and “Cappuccino”, i.e., a userwould like to ﬁnd a route such that he can listen to jazz music, watch a movie, eat vegetarian food and have a cup of Cappuccino. When we set the distance threshold ∆as 9 km, the route shown in Figure 20 is returned by OSScaling as the most popular route that covers all query keywords and satisﬁes distance threshold. We ﬁnd that according to the historical trips, this route has the most visitors among all routes covering all the query keywords shorter than 9 km. However, when ∆is set as 6 km, the route shown in Figure 21 is returned. This route has the most visitors among all feasible routes given ∆=6 km. In the case, the route in Figure 20 exceeds the limit ∆=6 km and is pruned during the execution of OSScaling algorithm. 5. RELATED WORK "
399,Probing Channel Balances in the Lightning Network.txt,"As Lightning network payments are neither broadcasted nor publicly stored.
Thus LN has been seen not only as scalability but also as privacy solution for
Bitcoin. The protocol guarantees that only the latest channel state can be
confirmed on channel closure. LN nodes gossip about channels available for
routing and their total capacities. To issue a (multi-hop) payment, the sender
creates a route based on its local knowledge of the graph. As local channel
balances are not public, payments often fail due to insufficient balance at an
intermediary hop. In that case, the payment is attempted along multiple routes
until it succeeds. This constitutes a privacy-efficiency tradeoff: hidden
balances improve privacy but hinder routing efficiency. In this work, we show
that an attacker can easily discover channel balances using probing. This takes
under a minute per channel and requires moderate capital commitment and no
expenditures. We describe the algorithm and test our proof-of-concept
implementation on Bitcoin's testnet. We argue that LN's balance between privacy
and routing efficiency is suboptimal: channel balances are neither well
protected nor utilized. We outline two ways for LN to evolve in respect to this
issue. To emphasize privacy, we propose a modification of error handling that
hides details of the erring channel from the sending node. This would break our
probing technique but make routing failures more common, as the sender would
not know which channel from the attempted route has failed. To improve
efficiency, we propose a new API call that would let the sender query balances
of channels that it is not a party of. We argue that combining these approaches
can help LN take the best of both worlds: hide private data when feasible, and
utilize public data for higher routing efficiency.","Bitcoin [15] is the rst digital currency to solve the double spending problem without a trusted third party. The permissionless nature of Bitcoin's con sensus algorithm imposes severe restrictions on trans action throughput, with a theoretical maximum of tens of transactions per second [9]. Addressing this problem in a naive way (such as increasing the block size) would endanger Bitcoin's key properties, such as the ability of participants to validate all trans actions in real time using consumer hardware. An other scaling approach that doesn't aect Bitcoin's properties but builds on top of them is ochain scaling . Ochain, or second layer (L2) protocols allow parties to exchange transactions without broad casting them to the blockchain, but in case of a con  ict the blockchain (called layer one in this context) is used for dispute resolution. We refer the reader to a comprehensive overview of ochain approaches in [11]. The (Lightning Network) LN has gained signif icant traction as a major Bitcoin scaling solution. First introduced in 2016 [20] and launhed on main net in early 2018, it is being implemented by sev eral independent teams based on a common set of specications called BOLTs (for Basics of Lightning Technology). The basic building block of LN is a payment channel . A payment channel is a protocol for o chain transactions based on the initial funding trans action , which locks coins in a 2of2 multisignature address. A channel operates in three stages: open ing (two parties lock the coins), operating (exchang ing ochain transactions), and closing (broadcast ing the most recent channel state to the blockchain). A channel partner may try to cheat by trying to close the channel with an earlier state. In this case, the counterparty is guaranteed to get all funds from the channel if they react within a timeout. LN nodes gossip about newly opened channels that are marked as available for routing. Based on this information, each node maintains a local view of the network, and uses it to calculate routes to the receiver. As total channel capacities are known, the sender only considers channels with the capacity larger than Xfor a payment of amount X. How ever, this is insucient to prevent routing failures, because the distribution of funds in channels is not known. The ability of channel parties to send or forward payments is limited by their local channel balances. Initially, if Alice opens a channel with Bob, all funds are on her side. This means that she can send up to the total capacity, but she can not receive. As the local balances change, the routing capabilities of the channels in both directions are also changing. In case of payment failure, the sender is notiedby an error message which channel has failed, and will presumably relaunch route generation func tion with the failed channel excluded. This pro cedure repeats for a preset number of tries, or un til a payment succeeds. Given the external con straints it is sill not clear that a better approach than systematically probing for paths exist even though active research is being conducted in this area [6,10,16,17,19,21,23,24]. Another aspect of LN relevant for this work is privacy. Bitcoin is pseudonymous: while blockchain addresses are not linked to real world identity, and users are encouraged to not reuse them, the transac tion graph can be extracted and analyzed. In con trast, LN payments are only sent to a short chain of randomly chosen nodes along the route from a sender to a receiver. Due to onion routing, each intermediary node only knows the previous and the next hops, but not the whole route and even not its position in the route. This supports the presump tion that Lightning payments provide more privacy than layerone Bitcoin transactions. However, a probing attack described in [26] showed that it is possible for an attacker to reveal balances of other channels of their channel partner. We see an important tradeo in LN between routing eciency and privacy. On the one hand, hiding balances from everyone but channel parties is an important privacy measure. If an external ob server could probe intermediate channel balances, it would be possible to track payments from the sender to the receiver, thereby breaking relationship anonymity and value privacy (as dened e.g. in [13]). On the other hand, knowing channel balances would allow senders to avoid trying routes that will fail. We argue that LN in the current form takes ""the worst of both worlds"": information about channel balances is neither well protected nor utilized. We support the rst part of this claim by describing a probing algorithm that reveals channel balances by sending fake payments. Contrary to [26], which requires opening channels with both parties of the channel that is being probed, our approach allows to probe the whole network while only establish ing a handful of channels. This greatly reduces the cost of the attack. We test our proofofconcept implementation on Bitcoin testnet and successfully probe a signicant portion of channels with high precision. We also outline potential countermea sures. We leave the formal treatment of the second part of the claim (how utilizing balance information would improve routing) for future work. The rest of the paper is organized as follows. In Section 2, we describe the relevant aspects of LN in more detail. In Section 3, we introduce our prob ing algorithm. In Section 4, we describe the exper imental results. We discuss the results and propose countermeasures in Section 5. Section 6 provides a 2short summary of related work, and Section 7 con cludes. 2 Background In this section, we introduce the basic concepts of the LN and the details relevant for our work. Each LN node is dened by a privatepublic key pair. A node has a permanent identier and connects to other nodes in the LN P2P network. Nodes exchange information about the currently open channels and their fee policies. Nodes com municate with an underlying bitcoin node (such as Bitcoin Core) to receive information on which trans actions are conrmed. To create an LN channel , Alice issues a request to Bob via the P2P protocol. If the parties agree on channel parameters, they cosign a funding trans action that establishes the initial distribution of funds. While in the initial specications it was as sumed that both parties could fund a channel, the current LN channels are singlefunded (i.e., Alice provides all funds and may optionally ""push"" some funds to Bob as a gift). After the funding trans action gets the sucient number of conrmations (usually 3 to 6), the channel is open. AnLN transaction is an atomic update of one or multiple channels. To send a payment to Bob, Alice negotiates a new channel state. Each channel state is re ected in a commitment transaction { a bitcoin transaction that spends the funding trans action and distributes the funds to both parties in some proportion. Outputs of commitment trans actions are called Hash timelocked contracts , or HTLC s. HTLC is dened by a Bitcoin script that gives the funds either to one party, if it provides a preimage of a given hash, or to the other party af ter a timeout. For instance, if Alice wants to send xcoins to Bob, she rst asks him for a payment hash. Bob generates a random number rand send its hash H(r) to Alice in a message called an in voice . Alice then oers Bob an HTLC that would give him xcoins if he provides a preimage of H(r) before time t, or return the coins to Alice otherwise. Bob must claim the payment before time t. If he provides r, the HTLC resolves : the balances in the next commitment transaction outputs will re ect the new distribution of channel funds. The other way for an HTLC to be resolved is timeout. A pay ment channel can keep track of multiple unresolved HTLCs concurrently. LN is source routed. Nodes exchange informa tion about channels, and each node chooses routes based on the local view of the network graph. The graph includes total channel capacities but not lo cal balances of the counterparties. Using HTLCs enables atomicity of channel updates in multipath transactions. For instance, Alice can pay Charlievia Bob by using the same hash value along the route. If Charlie redeems the payment from Bob, then Bob can use the same preimage to claim funds from Alice, otherwise no funds move. The cornerstone of LN security is its revocation mechanism. The party that initiates the channel closure must wait until their portion of the funds becomes available. For instance, if Alice initiates a channel closure, she must wait until her funds be come available. If the closure is a cheating attempt, Bob can dispute it before the timeout and take con trol of all channel funds. Multipath payments use onion routing to en force the order of intermediary nodes. Each HTLC is onionencrypted so that each intermediary node only knows the immediate previous and next nodes, but not the nal sender or receiver. Transaction fees are collected by intermediary nodes as a dier ence between the amount in the HTLC they receive and the HTLC they send as part of the same trans action. Note that if a payment fails, no fees are collected, as all pending balance updates roll back. 3 Probing algorithm We describe our algorithm of channel probing. Let us denote the total capacity of a channel asc. The two parties of a channel are denoted as source (with balance bs) and destination ( bd). As per BOLT specication, the source is dened as the node with an alphanumerically smaller node ID. For concreteness, for each channel, we estimate the bal ance at source ( bs), and refer to it simply as b. First, we establish the list of channels we are go ing to probe. To be suitable for probing, the chan nel must be active (available for routing) and live (responding to requests). As a P2P network, LN has no denitive list of live nodes. Therefore, we need heuristics to choose live channels for probing. Probing dead channels would be wasteful: we would have to wait for timeouts, and the probes would leave our channels with ""hanging"" HTLCs waiting to be redeemed, occupying our capacity. We dene a channel as active if it is marked as active in at least one of the two directions (this in formation is available in gossip data). To determine liveness, we use two heuristics: temporarily con necting to all nodes, and sending a small amount to all active channels (preprobing). After com piling a list of live and active channels, we probe them by sending payments with randomly gener ated payment hashes. We refer to such payments asprobes . For each channel, we keep a lower ( bmin) and an upper ( bmax) bound for its balance b. Ini tially, bmin= 0 and bmax =c. At each probing step, we aim at shrinking this interval by issuing a probe with the amount of 0 :5(bmin+bmax) (binary 3search).1 The two directions of a channel can have dif ferent properties. Each channel partner controls its channel direction: Alice sets the routing pol icy only in the direction to Bob, while Bob sets the policy only in the direction to Alice. It is possible that a channel is only partially active: Alice allows routing to Bob, but Bob does not allow routing to Alice. Therefore, we try probing each channel in both directions, taking advantage of the fact that the two local balances sum up to the channel capac ity:bs+bd=c. This helps us probe partially active channels. It is also helpful for probing large chan nels: if we do not have enough capacity to probe a channel from the ""large"" end, we probe it from the ""small"" end, getting the same information. For clarity, we omit this implementation detail from the algorithm description. We now describe our probing technique more thoroughly. 3.1 Selecting channels for probing We use the following heuristics to determine liveness (Algorithm 1). 3.1.1 Heuristic 1: Connecting to nodes For a channel to be live, both its parties must be live. We extract a list of nodes from gossip data and establish a P2P connection to each.2We consider a channel live, if both its parties are live. 3.1.2 Heuristic 2: Preprobing To further optimize probing, we introduce an addi tional preprobing step. We send a probe of 1000 satoshis to every channel marked as active in the gossip data. If we get an error of one of the two types that we use for probing, we consider the channel live, otherwise we consider it dead an do not consider it it in the main probing step. We start the rst main round of probing with a list of live channels where a chan nel is dened live if either heuristic 1 or heuristic 2 detected it as live. 3.1.3 Heuristic 3: Liveness detected during probing If we issue a probe along the route of channels c1; c2; : : : ; c n and receive an error from channel ci, we conclude that all channels cj; j < =iare live. If any of cj is not on our live channels list, we add it. During the second probing round, we use the updated live channels list. 1If the midpoint between bmin andbmax is larger than the maximum HTLC amount allowed by the specication, we decrease it to that maximum minus a safety margin. 2Establishing a P2P connection is nearly instant and does not require coins, unlike opening a channel.Data: Gossip data Result: Channels selected for probing fornode in gossip data do connect to node; ifconnection established then add node to live nodes; end end forchannel in gossip data do ifsource and destination in live nodes then add channel to channels to probe; end end forchannel in gossip data do send a 1000 sat probe; iferror returned then add channel to channels to probe; end end Algorithm 1: Select channels for probing 3.1.4 Channel order Our method is agnostic to the order in which the channels are probed. However we probe the ""closer"" and ""more important"" channels rst. The rationale behind this is that knowing the balances of channels often used as intermediary hops allows us to avoid sending payments that are known to fail early due to insucient balance at some hop (note that the standard routing does not know about the funds distribution within channels). We refer to the nodes we open channels with as entry nodes . We probe channels in the following order: •the ""rst layer"" { channels adjacent to the entry nodes; •channels between hubs { channels connecting nodes out of 1% of the most connected nodes (if not already probed); •the ""second layer"" { channels adjacent to the ""rst layer"" (if not already probed); •other channels (if not already probed). 3.2 Probing 3.2.1 Probing a single channel The key idea behind our method is that by sending a payment of amount ato a channel, we can use the type or error it returns to infer whether its bal ance is higher or lower than a. We use a randomly generated value as a payment hash, therefore, the payment fails in any case. Let c1; c2; : : : ; c nbe a route we use, and bibe their respective balances. 4Letcjbe the erring channel. After each probe with an amount a, we obtain the following information: •bi> afori < j ; •bj< aif the error is ""insucient capacity"", or bj> aif the error is ""unknown preimage""3. The probing algorithm for a single route is pre sented in Algorithm 2. Data: Route and amount to probe Result: Updated balance estimates for channels in route send payment along route; forchannels before erring channel do bmin=a; end forerring channel do ifinsucient funds then bmax=a; end ifunknown preimage then bmin=a; end end Algorithm 2: Update balance estimates for channels along a route The algorithm for all channels selected for prob ing is presented in Algorithm 3. Data: Gossip data Result: Improved estimates for channels get channels for probing; forchannel in channels for probing do bmin= 0; bmax=c; fornumber of probings per channel do fornumber of attempts per probing do get route to target; probe route; iftarget channel estimates updated then continue; end end ifrequired precision reached then continue; end end end Algorithm 3: Probe all channels 3.2.2 Choosing routes We rely on the builtin functionality of our LN node to calculate routes to target channels. Additionally, 3The latter is only possible if j=n.we prelter suggested routes based on the informa tion we have obtained through probing. If we know that a balance of some channel in a suggested route is insucient, we exclude such channel from con sideration for the current probe and repeat route search (Algorithm 4). Optimizing route length presents a tradeo. Choos ing longer routes allows to collect more information per probe, but we are less likely to reach the target channel, as the probability that some intermediary channel fails is higher. For our purposes, we limit the length of routes to 10 hops (the protocol limit is 20 hops). Data: target channel, amount a Result: Route to target suitable for a forchannels adjacent to destination do ifchannel is not target then add channel to excluded channels; end end forall channels do ifa > c maxthen add channel to excluded channels; end end while route is bad do get route to target without excluded channels; forchannel in route do ifa > b maxthen route is bad; end end route is good; end return route; Algorithm 4: Find a suitable route to target channel and given amount 3.2.3 Second probing pass We discovered that some channels we thought were dead are in fact live, as our payments were suc cessfully routed through them (liveness heuristic 3 described earlier). We mark such channels as live and repeat the probing the second time taking them into consideration. 3.3 Channel information coecient To measure the eectiveness of our technique, we introduce the channel information coecient. For a given channel, it is dened as: i= 1"
79,An Experimental Investigation of Hyperbolic Routing with a Smart Forwarding Plane in NDN.txt,"Routing in NDN networks must scale in terms of forwarding table size and
routing protocol overhead. Hyperbolic routing (HR) presents a potential
solution to address the routing scalability problem, because it does not use
traditional forwarding tables or exchange routing updates upon changes in
network topologies. Although HR has the drawbacks of producing sub-optimal
routes or local minima for some destinations, these issues can be mitigated by
NDN's intelligent data forwarding plane. However, HR's viability still depends
on both the quality of the routes HR provides and the overhead incurred at the
forwarding plane due to HR's sub-optimal behavior. We designed a new forwarding
strategy called Adaptive Smoothed RTT-based Forwarding (ASF) to mitigate HR's
sub-optimal path selection. This paper describes our experimental investigation
into the packet delivery delay and overhead under HR as compared with
Named-Data Link State Routing (NLSR), which calculates shortest paths. We run
emulation experiments using various topologies with different failure
scenarios, probing intervals, and maximum number of next hops for a name
prefix. Our results show that HR's delay stretch has a median close to 1 and a
95th-percentile around or below 2, which does not grow with the network size.
HR's message overhead in dynamic topologies is nearly independent of the
network size, while NLSR's overhead grows polynomially at least. These results
suggest that HR offers a more scalable routing solution with little impact on
the optimality of routing paths.","Named Data Networking (NDN [1]) is a datacentric In ternet architecture that allows users to retrieve data directly by their names. Thus, a native NDN routing scheme needs to support forwarding using data names. Due to the sheer number of content names in today’s Internet, the number of FIB entries in an NDN network could be prohibitively large, and the routing update overhead required to maintain consistent FIBs of this size can also be costly. One of the major challenges in realizing NDN is to bound the size of routing state while supporting an unbounded data namespace. At the same time, the requirements for routing protocols in an NDN network also differ from that in an IP network [2]. NDN’s intelligent forwarding plane can quickly steer packets around failures and discover best paths through active prob ing [3]. Consequently, fast routing convergence is no longera requirement in an NDN network, and the optimality of the paths selected by routing protocols is not as important as in an IP network . However, as shown by Yi et al. [2], a routing protocol is still needed to help ﬁnd working paths faster with lower cost as compared to blindly probing all possible paths. This paper investigates the viability of applying hyperbolic routing (HR) to NDN networks. HR is greedy geometric routing based on hyperbolic coordinates of nodes that encode network geometry ([4], [5]). Assuming each node knows its own and its neighbors’ coordinates and each Interest carries coordinates corresponding to its data name preﬁx, a forwarder simply computes the neighbors’ distance to the coordinates and forwards Interests to the best nexthop(s) as measured by hyperbolic distance. The following explains why we consider HR a potential candidate to scale NDN routing. First, because both the distance calculation and best next hop selection in HR can be done in realtime on a perpacket basis, a node does not need to maintain a full FIB – it can simply keep a small cache of calculated routes to avoid repeated computation. In other words, HR does not need to know the network’s topological connectivity to compute routes and it does not incur the memory overhead of a fullsize FIB. Second, hyperbolic coordinates of a network are expected to be stable for a long time (months or years), eliminating the need for dynamic routing updates caused by shortterm topol ogy changes. In today’s IP network, it has been shown that, upon small to mediumscale changes in network connectivity, HR with backtracking can ﬁnd alternative paths to destinations without nodes changing their coordinates ([4]–[6]). With a good forwarding strategy, NDN’s forwarding plane can also ﬁnd alternative paths quickly in various failure scenarios [3], providing the backtracking capability to support HR. Third, HR seems more suitable for NDN than geometric routing schemes that rely on other network geometries as the name spaces in an NDN network will likely evolve to hierarchical treelike organization. This organization appears to be a ubiquitous and often emergent feature of largescale deployments, presumably because it allows for natural and essentially optimal representation of largescale informationarXiv:1611.00403v1  [cs.NI]  1 Nov 2016spaces [7]. Instead of relying on providerassigned names to facilitate aggregation, the main idea behind HR in NDN is to utilize the name space and network structure to scale routing by employing greedy routing using the underlying treelike geometry. Although the NDN namespace is much bigger than IP’s, we believe that by using hierarchical names, much like the URLs used to name today’s web content, NDN can achieve a similar exponential reduction of space and overhead. We note that the network and namespace geometry does not have to be exactly a tree, or even close to a tree (as measured by the treewidth metric, for example). According to the mathe matical results on coarse hyperbolic geometry [8], even very approximate treelike structures (Gromovhyperbolic [8]) can be mapped to hyperbolic spaces with low distance distortion. The scalability beneﬁts of HR, however, come with a price. First, HR does not guarantee to ﬁnd best paths for all destinations. Second, HR can suffer from local minima where packets get stuck at a node with no neighbor closer to the destination than itself (this can happen with or without topological changes). Both issues can in principle be handled by NDN’s smart forwarding plane, but a thorough investigation is necessary in order to answer the following questions: (a) can HR with adaptive forwarding provide performance that closely approximates that of a shortest path routing protocol as measured by packet delay? and (b) is the cost of using HR, i.e., the forwarding plane overhead due to active probing, much lower than the overhead under conventional routing protocols? To answer these questions, we ﬁrst developed a forwarding strategy called Adaptive Smoothed RTTbased Forwarding (ASF) that handles suboptimal routes and loops under HR. ASF is a relatively simple strategy so as to give us a baseline performance of HR – if such a basic design can lead to good performance, then any further improvement can only strengthen HR’s viability for NDN. We compared HR (in combination with ASF) with link state routing in an NDN network, assuming static hyperbolic coor dinates and smallscale connectivity changes. We measured the delay and loss rate experienced by NDN ping packets, as well as the probing overhead of ASF and update message overhead of linkstate routing, in a 22node NDN testbed topology and four scaleddown Internet topologies with 41, 58, 78 and 99 nodes. We found that HR/ASF can provide paths that are comparable with those of link state routing , achieving a similar packet delay and loss rate, even under frequent failure scenarios. The delay stretch of HR has a median close to 1 and a 95thpercentile below or around 2. More importantly, our experiments show that HR’s pernode message overhead in dynamic topologies grows very lowly as the network size increases , while NLSR’s pernode overhead grows at least polynomially , suggesting that HR can scale to much larger topologies. II. B ACKGROUND We examine hyperbolic routing performance by comparing it with NLSR ([9]). Here we provide some background infor mation on NDN and the two routing approaches.A. NDN NDN enables users and applications to directly fetch data identiﬁed by a given name . A consumer puts the name of a desired piece of data into an Interest packet and sends it to the network. Routers use this name to forward the Interest toward the data producer(s). Once the Interest reaches a node that has the requested data, the node will return a Data packet. This Data packet follows in reverse the path taken by the Interest to get back to the requesting consumer. To forward the Interest and Data packets, each NDN router maintains three data structures: a Forwarding Information Base (FIB) containing precomputed routes (or a Route Cache of recently computed routes in the case of HR), a Pending Interest Table (PIT) containing all the Interests that have been forwarded and are waiting for the returning data, and a Content Store (CS) containing previously received Data. The router also has a Forwarding Strategy module which takes input from the FIB and observes data fetching performance to determine whether and where to forward each Interest packet. In Section III, we explain the NDN forwarding process when hyperbolic routing is employed. B. NLSR NLSR ([9]) is a linkstate routing protocol that uses NDN’s InterestData packet exchanges to propagate reachability to name preﬁxes instead of IP preﬁxes. Its operations are sim ilar to that of OSPF – linkstate advertisements (LSAs) are propagated throughout the entire network so that each router can build a complete network topology. On the other hand, unlike OSPF, NLSR computes multiple (nonequalcost) paths for each name preﬁx as an input to NDN’s forwarding strategy. NLSR propagates two types of LSAs – Adjacency LSA and Preﬁx LSA. The Adjacency LSA is used to advertise all active links connecting one NDN router to its neighbors. The Preﬁx LSA, on the other hand, is used to advertise all the name preﬁxes that have been registered with the router. The LinkState Database (LSDB) contains all the LSAs, and LSA dissemination is viewed as a data synchronization problem of the LSDBs maintained by the routers. ChronoSync [10] is used to synchronize the LSDBs on all the nodes. C. Hyperbolic Embedding The initial motivation for HR comes from the seminal ob servation in [11] that anynetwork topology can be embedded into the hyperbolic plane such that greedy geometric routing using the embedded node coordinates never gets stuck at local minima, i.e. all sources can reach all destinations if a forwarder selects as the next hop its neighbor closest to the destination in the hyperbolic plane. In practical terms this means that a forwarder does not have to keep nexthop routes to all the destinations in the network in its FIB. The only information required for forwarding decisions is the coordinate of the destination in the packet and the coordinates of the forwarder’s neighbors, leading to exponential reduction in FIB space requirements. Unfortunately, upon a topology change, the embedding in [11] must be recomputed from scratch.To deal with this problem, several proposals have been investigated. In [12], reembedding is optimized using back pressure and other techniques. An entirely different embedding strategy is proposed ([5], [13]–[15]) based on the existence of geometric similarities between hyperbolic spaces and large scale Internetlike topologies; both exhibit hierarchical tree like organization ([16], [17]). The main beneﬁt of this em bedding strategy is that it exploits the intrinsic hyperbolic geometry of Internetlike networks [16] to ﬁnd the congruent coordinates of nodes on the hyperbolic plane. One outcome of this strategy, implemented using maximumlikelihood tech niques ([5], [14]), is that the resulting embedding is remark ably robust. Even if network connectivity changes signiﬁcantly but the nodes do not change their coordinates, greedy for warding using these static coordinates can still ﬁnd, with high probability, alternative paths to destinations if they exist ([4], [5]). In other words, even if the network topology is dynamic, the network embedding and node coordinates do not have to be recomputed, so HR does not incur the overhead of traditional routing protocols upon network topology changes. The cost paid for this routing overhead reduction in dynamic networks is some slight increase of path stretch and decrease of success ratio, deﬁned as the percentage of sourcedestination pairs reachable via greedy forwarding ([4], [5]). III. H YPERBOLIC ROUTING IN NDN To provide context for our forwarding strategy and exper iment design, below we describe how NDN forwarding may work under hyperbolic routing and how hyperbolic coordinates may be computed and distributed in NDN. A. Interest Forwarding Process ConsumerCoordinate Database (e.g., NDNS) Request coordinates Coordinates Radius: 12.34 Angle: 1.23 Interest Coordinates ...Content StorePITRoute Cache Data Add incoming interfaceCalculate routeForwarder Forward ✓✓✓ ✗✗ ✗Forwarding Strategy Fig. 1. Interest Forwarding under Hyperbolic Routing Figure 1 shows how an Interest may be forwarded by a router when hyperbolic routing is employed. Suppose the consumer wants to retrieve the data identiﬁed by a particular name, it ﬁrst obtains the hyperbolic coordinates for the name, e.g., from a distributed database such as the NDNS [18] (see Section IIIB). It then puts the data name and the coordinates in an Interest, and sends the Interest to its connected router. When the router receives the Interest, it ﬁrst checks the Content Store for matching data; if a match is found, the router returns the Data packet on the interface from which the Interest came. Otherwise, the router looks up the name in its PIT, and if a matching entry exists, it simply records the incoming interface of this Interest in the PIT entry. In theabsence of a matching PIT entry, the router checks the Route Cache to see whether next hops for the coordinates carried in the Interest have already been calculated; if not, the router calculates the next hops to reach the coordinates using the greedy geometric routing algorithm, and installs them in the Route Cache. Finally, the router uses the forwarding strategy to select one or multiple next hops to forward the Interest. Because a large number of next hops may increase the size of the Route Cache and time for selecting a route, the network operator may specify an upper limit on the number of next hops per name preﬁx, called Multipath Factor in this paper. We show in Section V that this is a key factor in forwarding plane performance when hyperbolic routing is used. Note that HR in NDN is very different from locationbased routing in IP. First, NDN Interests carry both data names and the corresponding coordinates, with the latter simply acting as hints to direct the forwarding. As such an Interest does not necessarily reach the producer; as soon as the Interest hits a router with the named content in its content store (the probability of which likely increases as the Interest gets closer to the producer), the content will be returned by that router. Second, HR in NDN is multipath instead of singlepath, i.e., each router calculates multiple routes to the coordinates carried in an Interest, so that if one greedy next hop fails to bring back the data, other next hops can be explored. B. Assigning and Disseminating Hyperbolic Coordinates The assignment of hyperbolic coordinates for the current Internet topology has been studied extensively ([5], [13]–[15]). However, both the process and algorithm to assign hyperbolic coordinates to NDN names are still open questions and part of our ongoing work. One difﬁculty is that there is currently no largescale NDN deployment, or any reasonable model of it, to experiment with. For our experiments, we adopt the following approach to assign the coordinates. First, since name preﬁxes are asso ciated with their producer sites, to be able to hyperbolically route NDN Interests toward the producers, it is natural to map a name preﬁx to the hyperbolic coordinate of the producer site. In other words, hyperbolic routing to an NDN name preﬁx relies on (but is not equal to!) greedy forwarding toward the hyperbolic coordinate of its producer site. Second, previous simulation work by Aldecoa and Krioukov [6] has shown that hyperbolic coordinates derived from the Internet ASlevel topology using the HyperMap coordinate inference algorithm [14] works reasonably well on the NDN testbed topology – each site is assigned the hyperbolic coordinates of the AS to which it belongs, and even with singlepath greedy forwarding, the success ratio for packet delivery is 82%. Given that the connection between the testbed topology and AS level coordinates is rather indirect, the results are unexpectedly good, encouraging us to test HR using this set of coordinates with multipath forwarding on the real NDN platform. Our rationale for the above strawman approach is as fol lows. If the ASlevel coordinates indeed lead to satisfactory forwarding performance in our experiments under realisticNDN settings, any improvement in the coordinate assignment algorithm will result in even better performance, which justi ﬁes further study of hyperbolic routing in NDN. In addition, we can immediately use this approach on the current NDN testbed to support longerterm evaluation of hyperbolic routing without waiting for a better coordinate assignment algorithm. We expect hyperbolic coordinates to be computed ofﬂine based on local information before a new name preﬁx is added to the network and occasionally thereafter to adapt to long term topological changes. As shown in previous work ([5], [14]), a new node can compute its hyperbolic coordinate using only the coordinates of other nodes in the network. That is, quite surprisingly, the new node does not have to know any thing about network topology other than what existing nodes it connects to. Furthermore, as shown in [15], the accuracy of this coordinate computation is essentially indistinguishable from the same computation but using only the coordinates of few nodes that are hyperbolically closest to the new node. In other words, new nodes can compute their coordinates using only local information about network topology and geometry. No routing information ever needs to be globally ﬂooded through the network at any step of the above process. New coordinates can be disseminated by mechanisms outside rout ing, e.g., using NDNS [18], a distributed database similar to DNS designed for NDN. Upon computing new coordinates, a network operator can inject the name preﬁx and its coordinates into the network’s own NDNS server. The coordinates can be retrieved by any node on demand, similar to how DNS queries work. Other options are possible, but their discussion is out of scope for this paper. IV. A DAPTIVE SRTT BASED FORWARDING Hyperbolic distancebased routing ranking may not reﬂect the actual forwarding delay for two reasons. First, it is possible that a next hop that is hyperbolically closer to the destination may actually lead to a longer path than one that is hyperbolically further from the destination. Second, when there are failures and recoveries in the network, HR does not adapt, thus its ranking may not reﬂect what is the shortest path at the moment. To have forwarding performance similar to that of shortestpath routing, we need a strategy that can ﬁnd a shorter path if available and adapt to network changes. The forwarding strategies implemented in the current NDN prototype focus on being able to retrieve contents, but may not ﬁnd the shortest path in some situations. For example, the BestRoute Strategy simply uses the next hop ranked highest by the routing protocol, which may not be optimal in the case of HR. We compared the delay stretch in HR using the BestRoute Strategy against the delay in LS using the BestRoute strategy and conﬁrmed that using the BestRoute strategy with HR results in both high delay stretch and a high loss rate (Section VB). As such, we developed a new strategy called Adaptive Smoothed RTTbased Forwarding (ASF) that chooses the best next hop based on RTT measurement, and also periodically probes other next hops to learn their RTTs. This strategy is similar in spirit to the RedGreenYellowstrategy proposed by Yi et al. [3]. One important difference is that the latter strategy probes alternative paths only when routing ranking changes, which does not work with HR as HR’s ranking does not adapt to shortterm network changes. Another difference is that Yi’s scheme does not consider measured RTT when choosing the best next hop, which may lead to suboptimal paths under HR. While other proposed forwarding strategies (e.g., [19]–[22]) may be well suited for HR, they require modiﬁcation of the Data packet [19] or use more complex next hop selection processes, with multiple parameters, that can make analysis difﬁcult [20]–[22]. We designed ASF to be easy to analyze, therefore we did not optimize its various parameters, such as probing period and probability, dynamically based on observed performance. However, as we will show in Section V, it performs surprisingly well in our experiments. A. Best SRTTbased Forwarding Every time a Data packet is received, we take a sample of the RTT, i.e., the time between when the Interest was sent and when the Data arrives. To accommodate ﬂuctuations in RTT values, we compute the Smoothed RTT (SRTT), a moving average of the RTT samples, in the same way as TCP. We maintain one SRTT for each next hop in a route entry. Given a route entry, we divide its next hops into three groups. Group 1 contains next hops that have SRTT values, i.e., they are working at the moment and returning Data. Group 2 contains next hops that do not have measurements yet. Group 3 contains next hops that are experiencing Interest timeouts. When an Interest arrives, the strategy picks the next hop with the lowest SRTT in Group 1. If this group is empty, the strategy will choose the next hop with the lowest routing cost from Group 2 or, if Group 2 is empty, from Group 3. Group 2 is preferred over Group 3, because next hops that have never been used may work while next hops that are timingout likely do not work. B. Probabilistic SRTTbased Probing As network conditions change over time, the shortest path may also change. If an alternate next hop becomes better than the current next hop, we will not be able to discover it if we are not sampling its SRTT. To solve this problem, ASF employs a periodic and probabilistic probing scheme to probe next hops not currently in use. The ﬁrst probe is scheduled to occur shortly after an entry is created in the Route Cache. In our experiments, the delay is a random interval between [0,T1] seconds, where T1is 5 by default. This random delay prevents triggering probing at each router along the Interest’s path at the same time. After the ﬁrst probe, the subsequent probes are scheduled to occur every T2seconds, which is set to 60 in our experiments (see Section V). A probing Interest carries the same name as the original Interest but with a different nonce. We use the same name for two reasons: a different name under the same preﬁx may be mapped to different coordinates (e.g., /google/sports and /google/music may have different coordinates); and routersdo not have a way to generate a valid new name – if the generated name does not have associated data, then the router will mistakenly take the lack of Data as an indication that the path does not work. We use a different nonce to ensure that if the probed path works, data will be returned on this path in addition to the primary path so that we can take an RTT sample of the probed path. Note that Interest aggregation and caching may cause some RTT estimates to be inaccurate, but will not negatively affect the SRTT measurements in the long run, because even if one RTT estimate returns an inaccurate RTT, subsequent measurements will cause the SRTT estimate to eventually converge to the correct one. Moreover, even if the strategy switches to an alternative path due to a false RTT measurement, eventually the good path will be probed and the strategy will switch back. To quickly gain information about a next hop that has no measurements, ASF ﬁrst chooses the next hop with the lowest routing cost from Group 2 to probe (see Section IVA about how the next hops are grouped). When Group 2 becomes empty, ASF will probabilistically choose a next hop from Group 1 and Group 3 to probe. The next hops in Group 1 and 3 are ranked by SRTT and HR distance, respectively, while Group 1 has higher ranking than Group 3. The probing probability of the next hop that has rank i= 1;:::;N in the sorted list (1 being the highest ranking) is P(i) = 2N+ 1"
103,SD-Access: Practical Experiences in Designing and Deploying Software Defined Enterprise Networks.txt,"Enterprise Networks, over the years, have become more and more complex trying
to keep up with new requirements that challenge traditional solutions. Just to
mention one out of many possible examples, technologies such as Virtual LANs
(VLANs) struggle to address the scalability and operational requirements
introduced by Internet of Things (IoT) use cases. To keep up with these
challenges we have identified four main requirements that are common across
modern enterprise networks: (i) scalable mobility, (ii) endpoint segmentation,
(iii) simplified administration, and (iv) resource optimization. To address
these challenges we designed SDA (Software Defined Access), a solution for
modern enterprise networks that leverages Software-Defined Networking (SDN) and
other state of the art techniques. In this paper we present the design,
implementation and evaluation of SDA. Specifically, SDA: (i) leverages a
combination of an overlay approach with an event-driven protocol (LISP) to
dynamically adapt to traffic and mobility patterns while preserving resources,
and (ii) enforces dynamic endpoint groups for scalable segmentation with low
operational burden. We present our experience with deploying SDA in two
real-life scenarios: an enterprise campus, and a large warehouse with mobile
robots. Our evaluation shows that SDA, when compared with traditional
enterprise networks, can (i) reduce overall data plane forwarding state up to
70% thanks to a reactive protocol using a centralized routing server, and (ii)
reduce by an order of magnitude the handover delays in scenarios of massive
mobility with respect to other approaches. Finally, we discuss lessons learned
while deploying and operating SDA, and possible optimizations regarding the use
of an event-driven protocol and group-based segmentation.","Current Enterprise Networks (EN) present a high de gree of complexity derived from their organic evolution. Traditional ENs are built in a threetier structure: ac cess, distribution and core, with each layer leveraging ∗Work performed while at Ciscoa distinct set of protocols. The accessdistribution seg ment uses L2 technologies such as Virtual Local Area Networks (VLANs), Spanning Tree Protocol (STP), and VLAN Access Control Lists (ACLs). On the other hand, the distributioncore segment is usually L3 with a combination of Open Shortest Path First (OSPF), Mul tiprotocol Label Switching with Label Distribution Pro tocol (MPLSLDP), and IP ACLs. This design varies from deployment to deployment, but the end result are complex networks that can be running up to tens of dierent protocols across hundreds of switches. This makes it hard to adapt to new requirements, such as isolating IoT devices or stretching L2 domains across distributed locations. Even if some of these challenges might have been addressed by technologies designed for service providers, such as Virtual Routing and Forward ing (VRF), given the high port density required in typ ical campus networks, adopting the same technologies in enterprise solutions is not cost eective. Specically, current ENs lack three key elements. First, scalable endpoint mobility across all the enter prise facilities, to address the everincreasing amount of roaming devices. Usually this is handled via send ing all wireless trac through centralized Wireless LAN (WLAN) controllers, which limits scalability, and re duces bandwidth. Second, simple to operate segmenta tion. The most common forms of segmentation in ENs are VLANs or VRFs, which do not scale well and can be dicult to congure at scale. Another example are IPbased ACLs, that over time can easily become long and dicult to map to the original intent. Third, sim plied operations. Network administrators might con gure each router individually, and, as we mentioned previously, have to deal with a myriad of dierent pro tocols. Although there exist more modern solutions [1, 2] that satisfy some of these requirements, we be lieve that the state of the art does not deal with scale and dynamism in a costeective manner, i.e. without requiring large capital expenditures (CAPEX). CAPEX plays, indeed, a very important role in the context of Enterprise Networks. First, because of browneld deployments: typically, network administra tors do not want to upgrade allof their switches for new features. Since these are usually legacy devices with 1arXiv:2010.15236v2  [cs.NI]  19 Feb 2021limited features, new network designs require a way to add new functionality without a forklift upgrade. Sec ond, because deploying devices with reduced FIB size or CPU power decreases CAPEX but in turn means less powerful devices that require resource optimization. In this paper we present the rationale, implementa tion, evaluation and experience matured in deploying SDA (Software Dened Access). Our objective with SDA was to design a solution that addressed the afore mentioned requirements of modern EN. With this goal in mind, we leveraged a vast spectrum of research ideas, architectures and protocols produced by the community in the last decade [3{8], and integrated them in a prac tical and deployable solution. First, we leveraged net work overlays as discussed in the Fabric architecture [5], in the form of the Locator/ID Separation Proto col (LISP [23]). This oers three benets: (i) we can upgrade existing deployments (brownelds) with mini mal touch, (ii) their layer of indirection makes it easy to support L3 mobility, and (iii) they make segmenta tion with VRFs more scalable. Second, we applied the SoftwareDened Networking (SDN) principle of cen tralized control to track endpoint location, and map endpoints to segmentation policies across the whole net work. Finally, we chose a reactive protocol (LISP) to distribute network state to the data plane. In other words, we populate the switches forwarding tables only if required by the active trac pattern. This reduces the overall switch requirements in terms of FIB size and CPU power which results in reduced CAPEX. We must remark that this paper is not meant to in troduce a novel architecture, but rather an account of our experience and lessons learned in designing, and de ploying modern enterprise networks. We describe how we combine state of the art techniques to realize a prac tical solution, and the lessons that we have learnt when operating SDA. We detail our experience through two reallife deployments. First, a mediumsized enterprise campus network serving around 450 endpoints that in cludes xed hosts, mobile hosts, application servers, IoT devices, etc. We show that in this scenario, our reactive protocol optimizes data plane state with a 70% reduc tion of FIB entries in the data plane compared to solu tions that store all the state in all routers (e.g. BGP). Second, a large warehouse where hundreds of robots are moving at speed to fulll shipping orders, such as those ran by large online retailers. Here we evaluate the handover delay of 16,000 robots triggering 800 mo bility events per second. Our solution achieves 5 times lower handover delay compared to existing approaches. Finally, we present our lessons learned from deploying SDA, such as reducing the initial connection delay due to the reactive protocol, coping with connectivity issues in the underlay or dealing with policy updates at scale. 2 Requirements and Design De cisions This section delves deeper into the requirements of cur rent ENs, explains limitations in the state of the artand discusses design decisions, summarized in table 1. Resource optimization : Routing protocols com monly found in enterprises, such as OSPF, ISIS or BGP make it dicult to reduce the FIB space without losing granularity1. We approached this challenge by leverag ing a reactive protocol (LISP in our implementation), rather than a proactive. Instead of pushing all routing entries beforehand to the routers, we only retrieve the necessary forwarding entries from a centralized server ondemand, and only for the routers that need them [9, 8]. We track endpoints by their IP address, so that routers download routes for the remote endpoints they need to reach, based on incoming trac from local end points. In addition, this reactive approach is helpful with mo bility because we can reduce convergence time. This arises from the fact that a reactive approach reduces the churn generated by the location updates: we only notify the parties aected by a specic mobility event. We must remark that a reactive protocol presents sev eral challenges, such as a potential initial delay for the establishment of  ows (sec. 3.2.2), or detecting con nectivity outages in the underlay (sec. 5 discusses our learnings in this space). Mobility : the current trend of wireless rst makes it critical to support a large amount of wireless endpoints. Traditionally, ENs handle mobility at L2 in a central ized way for both data plane and control plane. A gate way device (WLAN controller) acts as a sink for all traf c from all access points, performs access control, and reinjects it to the L3 network. This approach presents a serious scalability limitation because the gateway de vice becomes a bottleneck2. In addition, it creates triangular routing because all L3 trac is forced to go to the gateway and then back to the actual destination. SDA tackles mobility at layer 3 using network over lays [10, 11], specically with the mobility features of LISP. We keep the wireless control plane centralized for authentication purposes, but we let packets coming from the access point to be directly routed to desti nation. This distributed data plane greatly increases scalability. Segmentation : traditionally, the most common form of segmentation in enterprise networks are Vir tual Local Area Networks (VLANs [12]) and Virtual Routing and Forwarding tables (VRFs [13]). Despite their simplicity, VLANs scope must be kept limited to prevent  ooding of broadcast trac or L2 forwarding loops, hence, they do not scale well. Regarding VRFs, they scale better than VLANs, but since each device has to be individually congured it is hard to implement global polices across the whole network. A direct conse quence is that administration becomes too cumbersome as the number of VRFs increases. In addition, both of these approaches present similar limitations that make it hard to deal with mobility at scale. 1It is usual to leverage BGP prex aggregation or OSPF Areas to reduce the overall number of routes in the network, at the price of less granularity. 2Although this particular concern can be alleviated with hier archical controllers, it comes at the price of increased complexity and number of devices. 2Table 1: Summary of current state of the art, challenges, and design decisions Requirement Current Approach Limitations Our approach Benets Resource eciencyBGP and OSPFGranularityTracdriven Reduced CAPEX, prex aggregation route learning devicelevel granularity MobilityL2 centralized Scalability, L3 centralized control, Increased scalability, control and data plane triangular routing distributed data plane optimized routing Segmentation VLANs and VRFsScalability, Limited L2 stretching, Increased scale networkwide policies 'centralized' VRFs with less resources Simplied VLAN and Errorprone,Groupbased policiesSmaller ACLs, end administration IPbased ACLs no mobility toend enforcement SDA addresses these issues at dierent levels: for L2 segmentation [3, 14], we carefully stretch L2 domains (c.f. sec. 3.5). For L3, we still use VRFs, but map lo cal VRFs to global virtual networks in order to handle L3 segmentation at scale. This way, network adminis trators only have to specify the virtual network for each endpoint [6]. Finally, we add a layer of indirection to ease administration, detailed in the next paragraph. Simplied administration : a direct consequence of using network primitives such as IP addresses or VLANs for segmentation and access control is opera tional complexity [15]. In other words, network admin istrators have to translate business intent into IP ad dresses and ACLs and backwards. In the long run, this approach does not scale, is error prone, and increases complexity. To overcome this problem, we make use of the wellestablished groupbased paradigm [7, 16] to dene ACLs between groups, instead of IP prexes. First, the network operator denes a connectivity matrix among all groups. Then it adds endpoints to each group. On the network level, routers track each endpoint by its IP address and add a 16bit tag representing its group, so they can enforce the connectivity rules in the matrix. The benet is that network administration is radically simplied and common operations, such as IP address planning or ACL congurations can be automated. 3 Design and Implementation In this section, we describe the design and implemen tation details of SDA. First we provide an overview, then we describe the control plane and data plane. Fi nally, we detail how we support endpoint mobility and L2 services. 3.1 Overview On a conceptual level our design presents the usual data/control plane layer separation typical of SDN [17]. Figure 1 presents an overview of the design. We expose a simple declarative interface for network operators to dene: (i) an endpoint's group and the Virtual Network (VN) where they can connect, (ii) the endpoint authen tication data, and (iii) the connectivity matrix across groups of endpoints.We store this information in the control plane in two dierent servers, a routing server and a policy server. The policy server authenticates endpoints, assigns them a group and congures the data plane routers with the required group rules from the connectivity matrix. The routing server keeps track of all endpoints by their IP address and provides routes upon demand by the data plane. On the data plane, the overlay routers  hereafter re ferred to as edge routers  enforce the connectivity ma trix and route packets to the corresponding edge router. A special border router provides access to external net works. Finally, endpoints can roam freely across edge routers. 3.2 Control Plane We based the control plane design on a database focused approach similar to [4], as opposed to more traditional designs [18{20]. The control plane consists of two logically centralized servers: policy server and routing server3. Table 2 presents a summary of all our control plane data. 3.2.1 Control Plane Policy Sever We oer two degrees of segmentation: Virtual Networks (VN) and the group connectivity matrix. These group rules are independent for each VN. On one hand, VNs oer strong isolation at a 'macro' level. An example is a hospital network, where we want to isolate the doctors, guest and medical devices networks, we never expect them to be able to communicate each other. This is especially relevant to isolate legacy devices susceptible to attacks, e.g. an MRI machine running an outdated OS. In addition, it is a way to mitigate lateral spread attacks. On the other hand, the group rules oer a 'micro' segmentation for ner grain control inside a VN. For example, this level of segmentation can separate dier ent types of devices within a VN in Bring Your Own Device scenarios. The policy server stores the connectivity rules from the connectivity matrix, and, for each endpoint: its 3The reason for this separation is that usually the host on boarding process needs both the endpoint credentials and group permissions, while the normal packet  ow only needs the location mappings. 3Underlay Routing ServerPolicyServerPerVN connectivity matrix Endpoints Overlay Border Router  Edge Router Edge Router Edge Router RADIUS, SXPLISPEdge Router InternetSyncVXLANVN XG1G2G3G4G1G2G3G4Endpoint auth. + VN + GroupIdFigure 1: Global design authentication data, and associated GroupId and VN. GroupId and VN are 16bit and 24bit identiers, re spectively. The authentication data is variable since we support dierent RADIUSbased authentication proto cols [21], both with EAP or without. We use a specic protocol, ScalableGroup Tag eXchange Protocol (SXP [22]) to distribute the GroupIds and connectivity rules to edge routers. From the network perspective, VNs are mapped to isolated routingswitching domains, while GroupIds are inputs to groupbased ACLs. 3.2.2 Control Plane Routing Server The routing server stores the endpoint location, i.e. pairs of overlaytounderlay IP addresses plus its asso ciated VN. The overlay IP is the IP used by endpoints, while the underlay IP is the IP of the edge router serv ing this endpoint. The other edge routers encapsulate trac for such endpoint towards the underlay IP. After a successful device onboarding (sec. 3.3.1), or upon de tecting a mobility event, edge routers update the under lay location of an overlay IP address. Edge routers also retrieve this mapping when they receive a connection request to a particular device. We leverage the control plane aspects of the Locator/ID Separation Protocol (LISP, [23]). In a nutshell, the LISP control plane oers two mes sages: Map Request, to retrieve the underlay address of an overlay endpoint, and Map Register, to update the location of an endpoint, i.e. the overlay to under lay mapping. This way, we can store in the data plane the overlaytounderlay mappings that are required by the edge router to serve incoming trac. In addition, the LISP control plane supports mobility, is well suited for SDN architectures [24], and accommodates dier ent overlay address families apart from IP, e.g MAC addresses. This is especially helpful to support L2 ser vices (sec. 3.5). However, a drawback of using a reactive protocol such as LISP is the initial packet loss until the edge router downloads the route for a new destination. We have overcome this issue by installing a default route in all edge routers that points to the border router, and by synchronizing the routing state in the border with the information in the routing server (sync arrow in g.1). This way, edge routers forward packets to the bor der until they nish the resolution process, during this time the border router forwards such packets to the destination. The border router is usually more pow erful than edge routers in order to handle this extra load. Finally, some deployments may have more than one routing server or policy server for redundancy and load balancing. 3.3 Data Plane The data plane presents two distinct routers (g. 1): edge and border. Edge Routers: perform four key functions. First, they encapsulate and decapsulate trac from and to endpoints, respectively. Second, provide interVN iso lation ('macro' segmentation). We implement such seg mentation with VRFs: LISP populates the VRF tables, and each entry has an associated GroupId. Third, they detect roaming endpoints and update their location in the routing server. And fourth, enforce group permis sions from the connectivity matrix ('micro' segmenta tion). Border Routers: perform the same functions as edge routers, with two exceptions. First, their FIB ta ble is synchronized with the routing server. In other words, they don't use a reactive protocol, rather they are subscribed to all route updates from the routing server [25]. And second, they have routes to other net works, e.g. Internet, datacenter. Because of this, bor der routers have more powerful CPU and larger FIB tables. The data plane encapsulation leverages VXLAN with Group Identier extension [26]. We chose this encapsu lation over the native LISP data plane because of the need to encapsulate both L2 and L3 payloads (LISP supports L3 only). Additionally, in this VXLAN vari ant we can add the source GroupId in the group eld (g. 2). Finally, the underlay is a network with plain IP connectivity that routes encapsulated packets between edge routers. The underlay routing is provided by ei ther OSPF or ISIS, we leverage MACsec [27] for packet integrity protection and condentiality, and ECMP for redundancy [28]. The rest of this section describes how 4Table 2: Types of Control Plane Data Name Key Value Updated by Endpoint Data Endpoint authentication info GroupID , VN Network Operator Group Rules Source GroupId + Dest. GroupId Action (allow, deny) Network Operator Endpoint Location VN + Overlay IP addr.Underlay IP addr.Edge Routers(i.e. edge router) Underlay src., dest. IPVNGroupIdOuter IP headerOverlay src., dest. IPPayloadInner IP packetVXLAN header Figure 2: Packet Format Routing Server Edge RouterPolicy Server New Device(1) Access Request(2) Access OK, Device GroupId, VN, IP A,  rules GroupId=dest.(4) Register (VN) IP A > IP BUnderlay IP BUnderlay(3) Assign IP A(1) Access Request Figure 3: Host Onboarding Process the network plugs a device for the rst time (onboard ing) and the standard packet  ow. 3.3.1 Host Onboarding When an endpoint connects to the overlay, the edge router detects it and starts the authentication process with the policy server (step 1 in g. 3). After a suc cessful authentication, the edge router downloads the endpoint's VN, GroupId, and associated connectivity rules from the policy server (step 2). Specically, it downloads the rules where the endpoint's group is the destination (c.f. sec. 5.3), stores locally the GroupId value, and associates it to the switch port where the endpoint is connected. Then it can assign an overlay IP address to the endpoint (step 4), obtained from a DHCP server (step 3). Finally, the edge router stores the location of the endpoint in the control plane, i.e. update the (VN + overlay IP, underlay IP) pair in the database (step 4). 3.3.2 Packet Flow On ingress, packets from endpoints are assigned their corresponding GroupId and VN (g. 4, ingress edge router). The router knows these values from the on boarding process. Then, it does a VN + overlay desti nation IP lookup in the VRF table for that VN. If there is no match, it will query the control plane database. This query returns the underlay IP address of the des tination overlay IP. Finally, the packet is encapsulatedtowards the corresponding edge router, carrying both VN and GroupId. On egress, the destination edge router decapsulates the packet and injects it into a twostage pipeline (g. 4, egress edge router). First, it performs a VN + over lay destination IP lookup in the local VRF table cor responding to the VN in the packet. This query re turns the output port and the associated destination GroupId. Each entry in the VRF has its associated GroupId, that is stored during the onboarding pro cess. After authentication, the edge router creates an (Overlay IP, GroupId tag) association in the VRF table. The second stage is an exact match lookup in an groupbased ACL of (source GroupId, destination GroupId). This ACL enforces the aforementioned group rules. Finally, the router forwards the packet to the destination overlay IP address. We perform the policy enforcement on egress due to increased scalability (sec. 5.3). 3.4 Mobility Support When an endpoint roams and attaches to a new edge router, the latter triggers the authentication process again, and registers the new location (Fig. 5, Step 1). After this registration, the control plane sends a mes sage to the previous edge router instructing it to (i) pull the new location data (2,3), and (ii) forward all trac for that particular endpoint to the new edge router. Hence, handover signaling is linear with the number of roaming endpoints, as opposed to proactive protocols, in which it also depends on the number of routers (sec. 4.3). Additionally, we apply the eventdriven approach to update edge routers storing stale entries. To this pur pose, we use a specic datatriggered control plane mes sage (Fig. 6): when the old edge router receives trac for the roaming endpoint (1) it sends a control message to the source (2), instructing it to retrieve the new lo cation (4). At the same time, the old destination router forwards this trac to the new destination router (3). Regarding signaling scalability, this method depends on trac patterns: if the roaming endpoint is very pop ular, we will have to update a signicant portion of edge routers. On the contrary, endpoints that receive trac from few sources, require less signaling. The advantage of this technique is that it is triggered by trac, in other words, the control plane doesn't need to update alledge routers that have the stale location, but only those that require it. Finally, these control plane messages will be 5Underlay Routing Routing Server Ingress Edge RouterEgress Edge RouterPolicy ServerSource Endpoint Input Port VN+GroupIdGroup Tag ACLUnderlay EncapsulationOutput PortHitLookup (VN+ Overlay Dst. IP)Lookup (Src. GId,  Dst. GId)AllowOverlay Forwarding Tables Underlay DecapsulationOverlay Forwarding TablesDestination EndpointOverlayOverlay Policy or Route RequestVN + Overlay IP àUnderlay IPEndpoint auth. àVN + GroupId(GroupIdA, GroupIdB, Allow)Figure 4: Ingress and egress pipelines Underlay RoutingServer Old Dest. EdgeNew Dest. Edge(1)(2) Source Edge Endpoint 1Overlay IP 1 Endpoint 1Overlay IP 1Mobility event(1)(3) Figure 5: Endpoint mobility Underlay Routing ServerOld Dest. EdgeNew Dest. Edge(2) Source Edge Destination Endpoint 1Overlay IP 1(1)(4)(3) Source Endpoint 2Overlay IP 2 Figure 6: Updating stale entries via data plane mes sages. staggered over time as trac from dierent senders will arrive at dierent times, thus spreading the signaling load in time. 3.5 Support for L2 services In enterprise scenarios, it is common that some devices or users require L2 connectivity. Common usecases are some forms of loadbalancing, certain IoT devices, and basic services such as DHCP or service discovery4. In order to support such services, but avoid send ing broadcast trac to the entire network, our imple mentation leverages four elements: (i) VLANs (limited to the edge router ports), (ii) indexing endpoints by MAC address in the Routing Server (in addition to IP address), (iii) storing overlay IP to MAC pairs in the routing server, and (iv) deployment of L2 gateways in edge routers. 4A signicant amount of applications rely on broadcast do mains, e.g. Apple BonjourTable 3: Deployments used for evaluation Deployment# Border # Edge Number of Routers Routers endpoints Building A 1 7 150 Building B 2 6 450 Warehouse 2 20016,000 (emulated) The combination of these four elements helps us to provide scalable L2 connectivity: rst, VLANs limit broadcast domains; second, MAC address indexing lo cates endpoints of the same VLAN that are in dierent edge routers. Finally, L2 gateways absorb broadcast trac and convert it to unicast: for instance, they cap ture ARP requests and perform a lookup in the routing server to nd the MAC associated to the IP in the ARP request. Then they use this MAC to replace the broad cast MAC in the ARP request, creating a unicast L2 message. This message is injected in the L2 pipeline, which will use the MACtounderlay IP to encapsulate the request to the intended L2 MAC. 4 Evaluation We have implemented SDA in a commercially available line of routers, leveraging the protocols mentioned pre viously: LISP [23], RADIUS [21], and ScalableGroup Tag eXchange Protocol [22] for the control plane, and VXLAN [29] for the data plane. We have deployed our implementation in two dierent reallife scenarios: two campus networks with 150 and 450 endpoints, and a large warehouse (partially emulated) with massive mobility serving 16,000 emulated endpoints. Table 3 presents a summary of their characteristics. We evaluated three key elements of SDA: rst, the re sponse of the routing server under stressful conditions, because it is critical in the process of establishing data  ows. Second, quantifying the state optimization in the data plane due to the edgeborder design. And third, assess the dierence between an proactive and a reac tive protocol in face of massive mobility events. 64.1 Routing Server Scalability The routing server is a critical part of the design, be cause it allows establishing communication between any pair of endpoints. Because of this, we evaluated its performance depending on the number of routes and queries per second. To this end, we setup a routing server implemented in a commercial virtual router with 8 GB RAM, 8 vCPU, on top of a virtualization platform with an 8core 2.1 Ghz processor. We measured the delay to answer route requests and route updates with a script running in a local machine that sent 800 queries per second. We re peated the experiment for dierent number of routes congured in the routing server. Each query requested or updated a dierent route, in order to avoid opti mizations due to intermediate caches. We consider the network delay negligible. Figures 7a and 7b present boxplots of the time required to answer an IPv4 route request and a route update, respectively, for four dier ent number of congured routes in the routing server. The values are relative to the minimum delay of a rout ing server with only one route. We can see that the delay is not dependent on the number of routes. Since this architecture is designed to store network state hierarchically, it makes it easy to implement the routing server with a Patricia Trie. The delay of this data structure depends on the num ber of bits of the keys, not the number of elements [30]. Based on the data collected for this particular test, an equivalent deployment using a similar setup should scale to at least 3k endpoints without noticeable perfor mance degradation. Each endpoint requires registering 3 routes (IPv4, IPv6 and MAC addresses), then 10k / 3 =3k. We chose to send 800 queries/s to the server since it is the peak requirement in the massive mobility scenario (sec. 4.3). We consider this a highly loaded server, how ever, in case we needed to increase such gure, the archi tecture scales horizontally and can deploy more routing servers. Then, we load balance across edge routers by grouping them and pointing each group to a dierent routing server for the route requests, and perform route updates on all servers. Using the same routing server as before, we repeated the previous experiment but for dierent number of queries/s. Figure 7c presents boxplots of the delay to answer IPv4 route requests for four dierent number of queries per second to the routing server. The values are relative to the minimum delay of all samples. Assum ing a mobility pattern similar to the warehouse scenario (sec. 4.3) with 800 moves/s and that each move trig gers 2 queries to the routing server, we conclude that the routing server could support this use case (800*2 = 1600 queries/s). 4.2 State Reduction In order to quantify the state reduction due to the re active protocol, we counted the number of overlayto underlay IPv4 mappings in the FIB of the edge and border routers. We setup a VM that collected this dataTable 4: Details of campus deployments Bldg. A Bldg. B Border Routers 1 2 Edge Routers 7 6 Floors 3 3 AP per  oor 40 40 Total AP 120 120 AP per edge 20 20 hourly from the router CLI. The routers were in two separate buildings (A and B), with three  oors each, and providing network connectivity to between 200 and 500 users. Table 4 provides additional details about each deployment, and Fig. 8 shows the network topol ogy. The control plane of border routers has a 4core 2.4GHz, x86 CPU with 16 GB RAM, and edge routers a 4core 1.8 GHZ, x86 CPU with 8 GB RAM. Both of them use a custom ASIC for the data plane. The bordertoedge links are 10 Gbps and the edgetoAP 1 Gbps. Figure 9 shows the average number of FIB entries for the border and edge routers, for both buildings, and for three dierent weeks. We can see that, on average edge routers store less FIB entries than border routers: in building A edge routers carry only about 30% of the FIB entries on the border routers, while in building B this gure is as low as 6%. Table 5 presents also averages of FIB entries for border and edge routers for a period of 5 weeks. We can also see reductions in FIB entries, even if we calculate separate averages for day and nighttime. We can conclude that the reactive approach helps in optimizing data plane state, while the border router absorbs the convergence delay of the route resolution. It is also worth mentioning that the usage pattern of the FIB table on border routers shows a common daily and weekly pattern: during daytime in working week days routers host more routes than during night time and over weekends. This is due to the fact that the border router is always up to date with the infor mation in the routing server regarding the endpoints in the deployment. Thus, the number of entries in the border router follows closely the presence of authenti cated users in the network (i.e. users in the oce). In contrast, edge routers cache routes learned on demand and may retain them during longer periods, even when users have left the oce. We can clearly see this in building A (Fig. 9, top row), where edge routers seem to keep their routes for most of the time between work days, but eventually clear they caches during weekend. On the other hand, this eect is less noticeable in build ing B, where edge routers follow the daytime/nighttime routine more closely. The reason behind this could be nighttime trac patterns: when some endpoints leave the oce at night, the remaining ones may initiate com munication with those that left, that will trigger a route resolution with a negative result, and thereby deleting that FIB entry. 710 100 1000 10000 Number of routes1.41.61.82.02.2Relative Delay(a) Boxplot (95%) of the delay of 10k route requests for four dierent number of congured routes. Relative values to a routing server with 1 route. 10 100 1000 10000 Number of routes1.01.21.41.61.8Relative Delay(b) Boxplot (95%) of the delay of 10k route updates for four dierent number of congured routes. Relative values to a routing server with 1 route. 500 1000 1500 2000 Queries per second1.001.251.501.752.002.25Relative Delay(c) Boxplot (95%) of the delay of route requests for four dierent number of queries per second. Values are relative to the minimum of all. Figure 7: Routing Server Performance Evaluation. Border Routers Edge Routers Access Points x20 x20 x20 x20 x20 x20 Figure 8: Campus Network Topology (underlay routers not shown for clarity) Table 5: Average number of FIB entries for a 5 week period, for day work hours (9 am to 19 pm), and night time. Router PeriodBuilding A B BorderAll 50 291 Day 85 362 Night 19 227 EdgeAll 42 34 Day 47 42 Night 38 27 Decrease (All) 16% 88% Finally, another relevant aspect of building B is a sub stantial amount of endhosts that are permanently con nected to the network and do not follow the day/night routine. Examples of such endhosts are desktops and IoT devices (VoIP phones, cameras) that do not neces sarily move with the users. 4.3 Massive Mobility Events In this experiment we focus on the handover delay of large mobility events for a reactive and proactive proto col. We recreated in the lab the specications of a real life deployment, a large warehouse with hundreds of robots continuously roaming across WiFi access points. Figure 10 presents the topology: a commercial border router (4core 2 GHz CPU, 8 GB RAM for the con trol plane and custom ASIC in the data plane), twocommercial edge routers (4core 1.8GHz CPU, 8 GB RAM for the control plane and custom ASIC in the data plane) and 198 edge routers emulated with a com mercial trac generator. The border router had an embedded routing server. We congured the trac generator to: (i) create uni directional UDP trac from the 200 edge routers to wards the border router (yellow arrow in g. 10), (ii) send 1500 bytes packets from 16,000 emulated hosts, and (iii) generate 800 mobility events per second by changing the attachment port of the end hosts be tween the two physical edge routers. We selected this amount of mobility events because in the reallife sce nario, around 5% of the endpoints change their attach ment point every second. We measured the convergence time as the handover delay, i.e. the time since the emulated host is detached until trac is restored after it attaches to the new edge router. In order to compare both proactive and on demand approaches, we measured the handover delay in the same topology, but with two dierent control plane congurations: BGP as the proactive, and LISP as the reactive. In the BGP case we used a centralized route re ector in the edge router to distribute route updates. Figure 11 plots the CDF of the handover delay for BGP and LISP. All values are normalized to the min imum convergence time observed during the measure ment process. We can see that the proactive solution takes around 10 times more to converge than the re active one. The reason is that the proactive approach replicates the network update to all 200 edge routers, while the ondemand approach follows trac patterns and only updates edge routers that have active trac to roaming hosts. Another important observation is that the variance of the handover delay is consistently higher in the proac tive approach than the reactive. This is due to the fact that the reactive architecture selectively updates only routers that are actively sending trac to the endhost that moved, while the proactive approach updates edge routers randomly, i.e. not by their need for such update. These results show that SDA's reactive approach can be benecial in stressed environments such as automated 8	0	20	40	60	80	100	120	140	160 MonTueWedThuFriSatSunFIB	entries Dayborder edge 	0	20	40	60	80	100	120	140	160 Mon Tue WedThuFIB	entries Dayborder edge 	0	20	40	60	80	100	120	140	160	180 MonTueWedThuFriSatSunFIB	entries Dayborder edge 	0	100	200	300	400	500	600 MonTueWedThuFriSatSunFIB	entries Dayborder edge 	0	100	200	300	400	500	600 Mon Tue WedThuFIB	entries Dayborder edge 	0	100	200	300	400	500	600 MonTueWedThuFriSatSunFIB	entries Dayborder edgeFigure 9: Number of FIB entries in border vs. edge router for three dierent weeks. Top row corresponds to building A, and building to B. Border Router Edge Routers Traffic Generator198x EmulatedBGP / LISP800 moves/s Figure 10: Warehouse Network Topology 	0	0.1	0.2	0.3	0.4	0.5	0.6	0.7	0.8	0.9	1 	0	5	10	15	20	25	30	35	40	45CDF Handover	delay	relative	to	minimumLISP BGP Figure 11: Handover Delay for Eventdriven (LISP) and Proactive (BGP) Protocols warehouses or large gatherings with highly mobile end hosts.5 Lessons Learnt In this section we summarize several challenges and our learnings from implementing and deploying SDA in en terprise networks. 5.1 Underlay Connectivity Issues In order for the overlay to work, there needs to be un derlay connectivity. However, it is possible that an edge router fails or that an underlay IP changes, interrupting normal trac  ow. It can be challenging for the overlay to know the state of the underlay without explicit prob ing. To cope with these situations, edge routers monitor the address announcements of the underlay routing pro tocol (ISIS or OSPF) to know about their reachability to underlay IP addresses of the other edge routers. This way, when they detect a connectivity outage, they update their local forwarding table deleting such route and falling back to the default route to the border, until a new edge router registers the overlay address in the routing server. 5.2 Edge Routers Rebooting One issue that can happen is a forwarding loop between the edge and border router. Assume the network is forwarding trac, and an edge router reboots. It will start with an empty FIB for the overlay entries. When it receives trac for one of its former endpoints, it will use the default route and forward it back to the border router, since it does not know yet its endpoints. The border router will forward this trac to the rebooted router according to its current information, creating a forwarding loop. Although this loop is transient and disappears once the edge router detects its endpoints, we rely on two mechanisms in such situation. First, since the edge router will not announce its underlay IP address through the underlay routing protocol while rebooting, 9	0	0.02	0.04	0.06	0.08	0.1	0.12	0.14	0.16	0.18	0.2 VPNBranchCampusPermille	DropsFigure 12: Permille hits on drop rules over all hits. the tracking of the connectivity state of the underlay IP address that the other edge routers perform will remove the routes to the rebooting edge router. Second, the re booting router will not recognize the incoming trac, so it will send the data plane message we mentioned in sec. 3.4 to the originating edge router. This will trigger a refresh in the overlay FIB entries of the sending edge router. 5.3 Selecting the Policy Enforcement Point In this section we discuss a bandwidth vs. network state tradeo related to the deployment of group policies. We can save bandwidth by enforcing policies on ingress (because we don't forward trac that will be dropped on egress), or data plane state by enforcing them on egress. On egress we save data plane state because we only need policies for the local destination groups of the endpoints that are attached to a particular edge router, as opposed to ingress, which would need policies for all possible destination groups. Taking this into account, we chose to enforce policies on egress to reduce overall state in the data plane. In order to quantify the wasted bandwidth due to en forcing on egress, we analyzed the packet drops due to groupbased ACLs in a reallife deployment leveraging egressbased policy enforcement. This deployment is a mediumlarge enterprise network with a campus and a few branches. For our analysis, we looked at three dif ferent devices in this deployment, a branch router, an edge device in the campus, and a VPN gateway. Com bined, these three devices were serving around 11,000 endpoints during the period we monitored them. Fig ure 12 presents the permille of dropped trac for the period of 5 days. We can see that in the worst case the drop rate is extremely low: 2 out of each 10k packets. The VPN router has a signicantly larger amount of drops than the other routers due to the fact that it re ceives all the trac from remote users, which present a dierent usage pattern from the users in the oce. Since this deployment performs the policy enforce ment on egress, we expected a signicant percentage of drops. Surprisingly, we discovered that after a new policy is applied, there is a transient period with an increase in drops, but when endpoints (which are usu ally humans) realize they cannot access this particular destination, they stop requesting it. Hence, the oper Underlay IngressEgress Policy server Endpoint 1Overlay IP 1Endpoint 1 GroupIdA >B OverlayIPDest. GIdIP1A(?) Underlay IngressEgress Policy server Endpoint 1Overlay IP 1Endpoint 1 GroupIdA >B OverlayIPDest. GIdIP1A > BReauthenticateFigure 13: Policy Enforcement on Ingress (top) and Egress (bottom) ational experience in the most common enterprise use cases shows that enforcing policies on egress does not impact signicantly the amount of wasted bandwidth . An additional benet of enforcing on egress is a sim plication of signalling. When a group rule is updated, it is necessary to notify all the aected edge routers. However, this is not easy in our design, because requests to the control plane are only triggered by data plane events. For example, consider that the policy check is implemented on ingress and that the edge router has already learned the GroupId associated to a particu lar destination (g. 13, top part). Now suppose that the group associated to this destination endpoint is up dated, the ingress router has no way to know it. Hence, we need a way to signal this change. On the contrary, if the policy is enforced on egress, the (Overlay IP, GroupId) pair in the VRF is auto matically updated, because the modication of end point data automatically triggers the authentication process again. In other words, on egress the (Over lay IP, GroupId) pair is always up to date because it is linked to the endpoints connected to that edge router. This way, we can avoid implementing an extra signaling mechanism, and the associated complexity. 5.4 Updating Policies In our deployment experience, we found an interest ing tradeo when updating policies: it can be more scalable (i.e. less signaling) moving users to dierent groups rather than directly updating the groupbased ACLs. Indeed, this tradeo depends on the distribu tion of endpoints within groups of each particular de ployment, i.e. few groups with large amounts of end points vs. high number of groups with few endpoints each. Thus, it is not always the case that changing the endpoint's group is more scalable, but here we present two examples form our experience: Acquisitions: in case of an acquisition, the new employees are progressively moved through dierent groups until they get the same group as regular employ ees. The reverse also holds, when part of a company is 10sold, their users are moved to a group that is associated with more restrictive policies. Service insertion: it is common that trac has to go through middleboxes, e.g a rewall or a WAN optimizer. In some deployments, the SDA operators decide to update the group from the packets so that devices in the service chain decide whether to apply a policy or not. In other words, instead of applying dierent policies across the path for the same group, they change the group along the way so that dierent policies are applied across this same path. 6 Related Work "
186,Griefing-Penalty: Countermeasure for Griefing Attack in Lightning Network.txt,"Lightning Network can execute unlimited number of off-chain payments, without
incurring the cost of recording each of them in the blockchain. However,
conditional payments in such networks is susceptible to Griefing Attack. In
this attack, an adversary doesn't resolve the payment with the intention of
blocking channel capacity of the network. We propose an efficient
countermeasure for the attack, known as Griefing-Penalty. If any party in the
network mounts a griefing attack, it needs to pay a penalty proportional to the
collateral cost of executing a payment. The penalty is used for compensating
affected parties in the network. We propose a new payment protocol HTLC-GP or
Hashed Timelock Contract with Griefing-Penalty to demonstrate the utility of
the countermeasure. Upon comparing our protocol with existing payment protocol
Hashed Timelock Contract, we observe that the average revenue earned by the
attacker decreases substantially for HTLC-GP as compared to HTLC. We also study
the impact of path length for routing a transaction and rate of
griefing-penalty on the budget invested by an adversary for mounting the
attack. The budget needed for mounting griefing attack in HTLC-GP is 12 times
more than the budget needed by attacker in HTLC, given that each payment
instance being routed via path length of hop count 20.","Since the inception of Bitcoin [2] in 2009, Blockchain technology has seen widespread adoption in the payment space. In spite of many desired features like decentralization and pseudonymity, a constant criticism faced by Bitcoin and Ethereum [3] is that of scalability. Layertwo protocols [4] enables users to perform transactions ochain , massively cutting down data processing on the blockchain. Payment Channel [5], [6] stood out as a practically deployable solution. It is modular in nature, without requiring any fundamental changes in the protocol layer. Except for the opening and closing of the payment channel, several transactions can be executed ochain without recording it in Blockchain. In case of dispute, any party can unilaterally broadcast the latest valid transaction in the blockchain and terminate the channel. A malicious party will lose all the funds locked in the channel if it tries to broadcast any older transaction. Since opening a payment channel has its overhead in terms of time and funds locked, parties that are not connected directly leverage on the set of existing payment channels for transfer of funds. The set of payment channels form the Payment Channel Network or PCN [6]. In ?A preliminary version of our paper was accepted in the proceedings of The 19th IEEE International Conference on Trust, Security and Privacy in Computing and Communications (IEEE TrustCom 2020) under the title ""Time is Money: Time is Money: Countering Grieng Attack in Lightning Network"" [1]. Corresponding author Email addresses: subhra.mazumdar1993@gmail.com (Subhra Mazumdar), mail.prabal@gmail.com (Prabal Banerjee), Sushmita.Ruj@data61.csiro.au (Sushmita Ruj) Preprint submitted to Journal of L ATEX Templates June 17, 2021arXiv:2005.09327v3  [cs.CR]  16 Jun 2021practice, Lightning Network for Bitcoin [6] and Raiden Network for Ethereum [7] are the widely deployed PCNs. Figure 1: Bobmounts Grieng Attack Payment in Lightning Network .If a sender and a recipient of payment do not share a channel, such payments make use of Hashed Timelock Contracts or HTLCs [6]. Since the payment gets routed via several intermediaries, a specic condition is imposed via ochain contracts in order to prevent cheating. Payments are contingent to fulllment of this condition. We describe with an example how conditional payments get executed between parties not directly connected by payment channel in Lightning Network. Suppose Alice wants to transfer pcoins to Bob via path comprising payment channels AliceDave, DaveCharlie and CharlieBob , as shown in Fig. 1. Each intermediate node charge a processing fee of p0.Alice forwards a conditional payment to Dave , forming an ochain contract, denoted as Contract (p+ 2p0;t+ 2), locking p+ 2p0coins for a time period t+ 2. Here  is the worstcase conrmation time for settling a transaction onchain. Dave deductsp0coins from the amount and forwards the payment to Charlie by forming a o chain contract, locking p+p0coins fort+ . Finally, Charlie deductsp0coins from the payment amount and lockspcoins with Bob for a time period t. In order to claim pcoins from Charlie ,Bob must resolve the payment within time period t. If the time period elapses, Charlie goes onchain to claim refund, closes the channel CharlieBob and unlocks the money from the contract. Using the information released by Bob, rest of the intermediaries resolve the payment as well, each claiming a processing fee of p0. Payment susceptible to Grieng Attack .Grieng Attack in Lightning Network was rst mentioned in [8]. Paralyzing the network for multiple days by overloading each channel with maximum unresolved HTLCs has been studied in [9], [10]. In [11], sybil nodes initiate several payments via multiple paths and griefs them simultaneously. In the example described above, Bob mounts grieng attack by not responding, as shown in Fig. 1. Charlie can go onchain and withdraw the coins locked in the contract only after the elapse of the contract's timeperiod. Thus Bobmanages to lockO(p) coins in each of the preceding payment channels for a timeperiod oftunits, without investing any money. Note that tcould be of the order of 24 hours . Hence for an entire day, none of the parties can utilize the amount locked in their respective ochain contracts. Motive behind Grieng Attack .By mounting grieng attack, an adversary may try to achieve either of the objectives: •Stalling network using self payment: The adversary controls the sender and receiver of several payment requests, blocking multiple intermediaries from accepting any other payments to be routed through it [11], [12]. In order to decrease the network throughput, an adversary may setup several Sybil nodes at strategic positions across the PCN and amplify the damage by submitting several payment requests. •Eliminating a competitor from the network: The adversary tries to eliminate a competitor and block all its existing channel's outgoing capacity [13], [12].The adversary sets the victim as an intermediate node in the path carrying out the selfpayment. The transaction value of self payment is equivalent to the victim's outgoing channel capacity, jamming all the channels of the victim node. The victim cannot utilize the 2fund until the adversary decides to claim the payment. As a consequence, several future payment request which could have been routed through the victim node now gets routed through the adversary. It reaps indirect economic benet by claiming the processing fee for routing such transactions. In Fig. 2, Node Bhas outgoing channel with AandC, each of capacity 0.1 BTC (each party having a balance of 0.05 BTC ). NodeDhas channel with Aand C, each of capacity 0.2 BTC . It conducts selfpayment of 0.05 BTC , in each direction. Upon grieng for 24 hrs ,DdeniesBfrom accepting any transaction request. AandC, having residual outgoing capacity of 0.1 BTC each in channel ADand CD, is now forced to route all the payments via D. A B MC D0.05 BTC 0.05 BTC 0.05 BTC 0.05 BTC0.05 BTC0.05 BTC0.05 BTC 0.05 BTC Figure 2: Eliminating a competitor •Stalling network using intermediary: The adversary controls a node with a high degree centrality and broadcasts its processing fee to be extremely low in order to ensure multiple payments get routed through such nodes [14]. It later ignores all the payment by not forwarding the message to outgoing neighbours, locking funds across multiple paths thereby aecting a large portion of the network. 1.1. Our Goal Grieng attack in Lightning Network cannot be prevented as long as a malicious node has nothing to lose or, in other words, it has nothing at stake . The problem cannot be solved until and unless the attacker has the fear of losing money upon mounting the attack. Thus, before accepting the payment parties must make a commitment to pay a compensation, in case they stop responding intentionally. The amount deducted from adversary's balance must be able to compensate all the parties which got aected by the attack. A high level idea of the countermeasure has been pictorially depicted in Fig. 3. Alice forwards the payment toBobvia some intermediaries. Each party accepting the ochain contract is supposed to lock an amount, which gets deducted if the party fails to resolve the payment before the contract timeout period. Here Bob doesn't respond intentionally, allowing the timeout period of the contract to elapse. As per the terms of the contract, he gets penalized and the funds slashed from his account is used to compensate Alice, Dave and Charlie . Figure 3: Bobis penalized 31.2. Our Contributions In this paper, we have made the following contributions: •We propose a countermeasure for mitigating grieng attack in Lightning Network, known as Grieng Penalty . It punishes the griefer by forcing it to pay compensation to all the parties whose funds got locked for a certain timeperiod as a result of the attack. •To illustrate the benet of the proposed countermeasure, we propose a new payment protocol, called HTLCGP or Hashed Timelock Contract with GriengPenalty. The penalty deducted is a fraction of the amount of funds locked by the attacker per unit time. This fraction is termed as rate of grieng penalty . •We propose a construction for secure multihop payment using HTLCGP and provide security analysis for the same. It proves that our protocol is privacy preserving and mitigates loss due to grieng attack by compensating the honest nodes. •We study two attacking strategies for eliminating competitor node from network. Upon mounting the grieng attack following either of the strategy, we compare the prot made by the attacker in HTLC and HTLCGP , by executing the protocols on several snapshots of Lightning Network. The prot here is termed as Return on Investment (RoI) . It is observed that RoI is negative for HTLCGP compared to a positive RoI in HTLC , hence disincentivizing a node from mounting griengattack due to substantial loss incurred. •We compare the investment made by the adversary for mounting the attack in both HTLCGP andHTLC upon varying path length and rate of griengpenalty . The budget needed for mounting grieng attack in HTLCGP is 4 times more than the budget needed for HTLC, when the path length is set to 4. The ratio increases to 12 for path length of 20, which is the maximum hop count allowed in Lightning Network. For a xed path length, the ratio increases upto 500 for rate of grieng penalty exceeding 10"
46,SRP-MS: A New Routing Protocol for Delay Tolerant Wireless Sensor Networks.txt,"Sink Mobility is becoming popular due to excellent load balancing between
nodes and ultimately resulting in prolonged network lifetime and throughput. A
major challenge is to provide reliable and energy-efficient operations are to
be taken into consideration for differentmobility patterns of sink. Aim of this
paper is lifetime maximization of Delay TolerantWireless Sensor Networks (WSNs)
through the manipulation of Mobile Sink (MS) on different trajectories. We
propose Square Routing Protocol with MS (SRP-MS) based on existing SEP (Stable
Election Protocol) by making it Cluster Less (CL) and introducing sink
mobility.","WSNsare basedontinysensor nodeswhichhavelimiteden ergy. Wireless Sensors are being used in medical, environ ment monitoring, in security surveillance, etc. Strive for the betterment of WSNs is still motivating to work on different techniquesandmodiﬁcationstoenhancethelifetimeandlow energyconsumption. ThemainconstraintinWSNsisthelife time due to limited energy of the sensors. Lot of work has been done and yet many doors are still open to explore. Pur poseofthisworkistomaximizethelifetimeofWSNswithout affecting the cost of network. Main focus of the paper is on sink mobility and its motion on different trajectories. In [ 1] speedofthemovingsinkis discussed,its fast orslow inboth cases lifetime of the network will improve because mobility increasesthedimension(degreeoffreedom)oftheproblem. Assinksareproﬁcientmachineswhichareprovidedwith sufﬁcient energy (able to reﬁll). Sensor which are deployed inthe ﬁeldact assources,astheygatherdataandprovidethe needed information. Sensor nodes send their sensed data to thesinkforfurtherprocessing. Thedatawhichistransmitt ed tothesinkissendeitherinpullmodelorpushmodel. Sensors send their data actively to the sink in push model and in pull they will send data the sensed data only on the sinks request. Asthesinkissometimesoutoftherangeofmanysensorsanddatasendingtakesmuchenergy. Iftransmissionismultihop , the nodes which are located near sink deplete their batterie s ﬁrst as they will act as rely for the farthest sensors. Anothe r drawback is that if every node near the sink remains in ac tive mode then it creates a bottle neck near the sink and the connectionoffarthestnodeswiththe sinkisdisturbed. Toavoidit,weareintroducingMSinourproposedscheme SRP.Itsvariantsareusetoﬁndtheshortestpathbetweensen  sors and sink. When sink is moving on the predeﬁned tra jectory the sensor nodes in the ﬁeld and gathering data, only sensorsinthesensingrangesendtheirdatatothesink. Othe r nodeswhichareoutfromsensingrangegoinsleepmodeun til sinkarrives. In this paper, we extend conventional routing protocol Stable Election Protocol (SEP) [2] removing its clustering mechanism and introducing MS in the ﬁeld. Then we en hance the data collection in WSNs by MS in clusteless net work. Here, we implement three different mobility patterns in the ﬁeld to efﬁcientlygatherdata in our proposedprotoco l SRP. The remainder of this paper is organized as follows. In Section 2, related research works including MS. Section 3, discussesourmotivations. Section4givesournetworkmode l description and details our proposed protocol SRP for efﬁ ciently data gathering with MS in WSN environments. Sim ulationresultshavebeendiscussedin section5. Finally,c on cludingremarksarepresentedinsection6. 2. RELATED WORK "
406,"9-1-1 DDoS: Threat, Analysis and Mitigation.txt","The 911 emergency service belongs to one of the 16 critical infrastructure
sectors in the United States. Distributed denial of service (DDoS) attacks
launched from a mobile phone botnet pose a significant threat to the
availability of this vital service. In this paper we show how attackers can
exploit the cellular network protocols in order to launch an anonymized DDoS
attack on 911. The current FCC regulations require that all emergency calls be
immediately routed regardless of the caller's identifiers (e.g., IMSI and
IMEI). A rootkit placed within the baseband firmware of a mobile phone can mask
and randomize all cellular identifiers, causing the device to have no genuine
identification within the cellular network. Such anonymized phones can issue
repeated emergency calls that cannot be blocked by the network or the emergency
call centers, technically or legally. We explore the 911 infrastructure and
discuss why it is susceptible to this kind of attack. We then implement
different forms of the attack and test our implementation on a small cellular
network. Finally, we simulate and analyze anonymous attacks on a model of
current 911 infrastructure in order to measure the severity of their impact. We
found that with less than 6K bots (or $100K hardware), attackers can block
emergency services in an entire state (e.g., North Carolina) for days. We
believe that this paper will assist the respective organizations, lawmakers,
and security professionals in understanding the scope of this issue in order to
prevent possible 911-DDoS attacks in the future.","The '911' emergency number was instituted in the US in  1968 in response to the need for a universal and effective  method of reporting emergencies. Over the years the system  has evolved, and in 1999 the US government enacted the  Wireless Communications and Public Safety Act. This  federal law mandated the use of 911 as a universal  emergency number and “enhanced 911” (E911) as the base  technology  for handling calls from wireline and wireless  phones. The E911 network provides dedicated infrastructure  for routing and connecting 911 calls to the nearest public call  center. These call centers are referred to as public safety  answering points (PSAP).  Today, 911 services are a part of the United States' 16 critical  infrastructure sectors [1]. Its availability is vital to the  population of the United States.   1.1 DDoS Attacks on 911  A DDoS attack launched from a mobile phone botnet is a  significant threat to the availability of 911 services. In this  attack, frequent fraudulent calls are made to 911 by a botnet  comprised of many mobile phones. Many PSAPs work at  full capacity [2]  and cannot handle this large volume of calls.  Moreover, this call volume can disrupt the telephony  network itself, preventing legitimate 911 calls from ever reaching a PSAP. This was evident during the 9/11 terror  attack which, in effect, caused the population to generate a  DDoS attack on New York City’s telephony network by  collectively dialing 911 [3].   In 2015 over 90% of American adults owned a cell phone, and  64% of the devices were smartphones  [4]. An attacker that  recruits even a fraction of these devices to a botnet would give  this attacker has the potential to deny 911 services to an entire  state, or possibly the entire country.   This attack currently affects both the service and the client  in the following ways: 1) Generally, PSAPs have no builtin  way of blacklisting callers. Therefore, in the face of a large  attack, they would have no choice but to answer each and  every call. 2) Even with a blacklisting system in place, the  owner of an infected device would be blocked from  legitimately receiving emergency services, even in a time of  need.   1.2 An Anonymized DDoS Attack on 911   In 1996 the Federal Communications Commission (FCC)  issued the E911 First Report and Order which required  wireless providers to forward 911 calls to a PSAP regardless  of caller validation:  ""The basic 911 rules require wireless carriers to transmit all  911 calls to a Public Safety Answering Point (PSAP) without  regard to validation procedures intended to identify and  intercept calls from nonsubscribers. Under the rules,  therefore, both subscribers and nonsubscribers can dial  911 and reach emergency assistance providers without  having to prove their subscription status.""  ~FCC WIRELESS 911 REQUIREMENTS  [5]  A DDoS attack launched from a mobile phone botnet can  exploit this ruling in order to make its attack more difficult  to mitigate. If a bot randomizes the device’s cellular  identifiers, it becomes impossible to blacklist its 911 calls.   In this paper we expose and analyze this new threat by  proving its feasibility and by measuring its potential impact  via simulations. We found that only 6,000 infected devices  are enough to severely harm the availability of the 911  services of a US state. We also found that some devicelevel  and networklevel countermeasures can help in mitigating  this threat.  1.3 Contributions  The following are the contributions of this paper:   We identify a new threat to the availability of emergency  services: an anonymous, unblockable 911DDoS attack from  mobile phones. We present how this attack is perpetrated and  discuss the bots involved.    We implement bots that can carry out this attack, and test them  on a small cellular network in order to demonstrate the attack’s  feasibility. By describing the behavior and implementation of Mordechai Guri, Yisroel Mirsky, Yuval Elovici  {gurim,yisroel, elovici}@post.bgu.ac.il  BenGurion Univerisity of the Negev  CyberSecurity Research Center  these samples, we provide the tools and knowledge to prevent  potential attacks in the future.   We gauge the severity of the attack and analyze the  weaknesses of the E911 networks by simulating the attack on  a reconstruction of actual E911 infrastructure. The simulations  are based on real call volume statistics, network topologies,  and configurations which we have collected from various  published surveys, reports, statistics, and documentation. We  analyze possible weaknesses of the current E911 network and  measure the number of bots required to accomplish an attack.  We believe that this paper will assist the respective  organizations, lawmakers, and security professionals in  understanding the scope of this issue. It is our intent that the  analysis, simulations, and models will provide these  stakeholders with a means of detecting and preventing  possible attacks in the future.   The remainder of this paper is structured as follows: In  section 2 we review related work. In section 3 we provide a  technical overview of the cellular network and E911  infrastructure as relevant to this paper. In section 4 we  introduce the adversarial attack model and the bot types. In  section 5 we present the design and implementation. In  section 6 we provide an in depth analysis of the attacks at the  state and country level. In section 7 we present  countermeasures, and we conclude in section 8.    2. RELATED WORK  "
368,Networks become navigable as nodes move and forget.txt,"We propose a dynamical process for network evolution, aiming at explaining
the emergence of the small world phenomenon, i.e., the statistical observation
that any pair of individuals are linked by a short chain of acquaintances
computable by a simple decentralized routing algorithm, known as greedy
routing. Previously proposed dynamical processes enabled to demonstrate
experimentally (by simulations) that the small world phenomenon can emerge from
local dynamics. However, the analysis of greedy routing using the probability
distributions arising from these dynamics is quite complex because of mutual
dependencies. In contrast, our process enables complete formal analysis. It is
based on the combination of two simple processes: a random walk process, and an
harmonic forgetting process. Both processes reflect natural behaviors of the
individuals, viewed as nodes in the network of inter-individual acquaintances.
We prove that, in k-dimensional lattices, the combination of these two
processes generates long-range links mutually independently distributed as a
k-harmonic distribution. We analyze the performances of greedy routing at the
stationary regime of our process, and prove that the expected number of steps
for routing from any source to any target in any multidimensional lattice is a
polylogarithmic function of the distance between the two nodes in the lattice.
Up to our knowledge, these results are the first formal proof that navigability
in small worlds can emerge from a dynamical process for network evolution. Our
dynamical process can find practical applications to the design of spatial
gossip and resource location protocols.","Models relating geography and socialnetwork friendship e nable a good un derstanding of the small world phenomenon, a.k.a., six degr ees of separation between individuals [11, 29]. In these models, the probabil ity of befriending a particular person is assumed to be inversely proportional to the number of closer people, ﬁtting with what was observed experimenta lly (cf. [28]). Under this assumption, it was proved that, using ad hoc proba bility distri butions, many classes of graphs are navigable, that is, a sim ple decentralized routing procedure enables eﬃcient routing from any source t o any target. (By eﬃcient, we mean, as it is standard in this framework, tha t routing from any source sto any target ttakes a polylogarithmic expected number of steps). For instance, such a navigability property is sat isﬁed in multi dimensional meshes [24], in graphs of bounded ball growth [1 3], and more generally in graphs of bounded doubling dimension [34]. In a ll these cases, a graphG, that may not only represent geography but also other proxim ity measures like professional activities, religious beliefs , etc., is enhanced with additional links chosen at random. More precisely, every no de is given some longrange links pointing at other nodes in the graph. For each longrange link added at a node u, the probability that the head of this link is vis inversely proportional to the size of the ball of radius dist G(u,v) centered at uinG, hence depending on the density of Garoundu. This setting applies to weighted graphs too [26], and to inﬁnite graphs as well [13 ]. For instance, in thekdimensional lattice Zk, the probability that uhas a longrange link pointing at vis essentially proportional to 1 /dkwheredis the distance be tweenuandvin the lattice. This setting of the longrange links enables greedy routing1to perform in polylogarithmic expected number of steps (as a function of the distance in the lattice between the source a nd the target). 1.1 Navigability as an emerging property In [25] (Problem 7), Jon Kleinberg asks about ”what kinds of g rowth pro cesses or selective pressures might exist to cause networks to become more eﬃciently searchable”. Many attempts have been made to expl ain how the densitybased distribution of thelongrange links can eme rge with time from the evolution of a network. Inspired by the world wide web or b y P2P ﬁle sharingsystems, all the models we are aware of have consider ed the augmen tation process (or rewiring) of a static graph used by its nod es for searching information. Our work uses a diﬀerent approach, starting fro m the following 1Greedy routing [24] aims at modeling the routing strategy pe rformed by the indi viduals in Milgram experiment. In a graph Genhanced with longrange links, a node u handlinga message of destination tselects among all its neighbors, includingits longrange contact(s), the one that is the closest to the target taccording to the distance in the base graphG, and forwards the message to that node. 1observations. One the one hand, anyone of us can call or email any person in the world. On the other hand, to do so, it is frequently the c ase that we have met this person before. We thus start from the assumpt ion that longrange connections are between remote people who have m et once in the past. In other words, longrange links are emerging from nodes mobil ity, that we model by random walks in this paper. Another obse rvation is that people forget some of their former acquaintances along with time. This forgetting mechanism represents the well understood fact t hat one cannot maintain close relationships with an explosive number of pe ople. Thus we couple the random walk process with a forgetting process, an d prove that this idealistic setting is suﬃcient to insure polylogarith mic navigability with simply one longrange connection per node. 1.2 Rewiring processes Clauset and Moore [9] proposed the following rewiring proce ss for the mul tidimensional lattice, inspired by the actions of surfers o n the web. While routingfroma source sto atarget t, if thetarget is not reached after τsteps, then the longrange link of sis rewired to point at the current node x. The threshold τis set based on the distance (in the lattice) between sandt, and on the expected time of greedy routing from stotwhen the kdimensional lattice is augmented using the kharmonic distribution [24]. The simulation results presented in [9] show that the distribution fof the link lengths con verges to the power law h(d)∝1/dk. Sandberg and Clarke [32] proposed a diﬀerent rewiring process, based on Freenet feedback mechan isms [8]. This iterative process selects, at each phase, two nodes sandtuniformly at ran dom, and constructs the greedy path s=x0,x1,...,x k−1,xk=tfromstot. For every i∈ {0,1,...,k}, the longrange link of xiis rewired with probabil ityp, to point at t. Thek+1 decisions (rewiring or not) are taken mutually independently. This process is analyzed in [31]. It is prove d that, under some hypotheses, the process converges. Moreover, the stat ionary distribu tionfof the link lengths can be fully characterized. In the kdimensional lattice, it is close to the power law h(d)∝1/dkfor an appropriate p, and simulations show that greedy routing in rings and meshes enh anced using the stationary distribution fperforms as eﬃciently as when these networks are enhanced using the 1 and 2harmonic distributions, res pectively. For both [9] and[32], thecomplete formal analysis of thepro cess remains open (even the formal characterization of the stationary di stribution of the processes described in [9] remains open). The diﬃculty of th e analysis is due to the dependencies between the longrange links genera ted by the pro cesses. In particular, the computation of the greedy routin g performances is a challenge when the longrank links are not mutually inde pendent. So, building further theory upon these two models looks quite di ﬃcult. In this paper, we propose a dynamical network model based on t he com 2bination of two simple processes: a random walk process, and a harmonic forgetting process.Weprovethat thecombination of theset wo processesgen erates longrange links mutually independently distribut ed as a distribution that resembles the densitybased distribution, and from wh ich navigability provably emerges. 1.3 Sketch of our network evolution process In our network evolution process, called moveandforget, orm&ffor short, individuals are modeled by tokens moving from node to node in thek dimensional lattice Zk, for some ﬁxed integer k≥1 (the dimension of the lattice may be related to the number of proximity criteria us ed by the indi viduals for routing). Initially, each node is occupied by ex actly one token. These tokens are moved mutually independently during the ex ecution of the dynamical process, according to a random walk. Tokens are attached to the heads of the longrange links, who se tails are the nodes from where the tokens initially started their r andom walks. Usingtheanalogyofindividualsmovinginthegeographical world,eachlong rangelinkindicates anacquaintance between an individual located at aﬁxed geographical point (where the token initially stood) and so me individual located atsomegeographical coordinates (wherethetoken c urrentlystands). The random walk process is coupled with another dynamic: nod es may forget their contacts through their longrange links. The m otivation for our forgetting process is that individuals may loose contact wi th former good friends, but they meet new people among which some may become close friends. Sinceolderacquaintances indicatestrongerrela tionships, weassume that they have less probability to be forgotten than recent o nes. More precisely, a longrange link of age a, that is a longrange link that survived asteps of the forgetting process, is forgotten with probabil ityφ(a)∝1/a. When a longrang link is forgotten by a node, it is rewired to p oint at this node (hence creating a selfloop). The token at the head of th e forgotten link is removed, and a new token is launched at the node. (A new local relationship replaces an old remote relationship). Note that m&fis deﬁned independently from the dimension kof the lat tice: tokens execute randomwalks, andthey are forgotten wi th aprobability that depends only of their ages. 1.4 Our results We prove that, for any ﬁxed integer k≥1, them&frewiring process sketched above converges in the kdimensional lattice to a distribution f of the link lengths that resembles the kharmonic distribution. Precisely, we prove that there exists d0≥0 and two positive constants candc′, such that, for any d= (d1,...,dk)∈Zkwith|di| ≥d0for alli∈ {1,...,k}, we 3Convergence Navigability A. Clauset and C. Moore (2003) Simulations Simulations O. Sandberg and I. Clarke (2007) Proof Simulations Moveandforget ( m&f) Proof Proof Table 1: Properties of known network evolution processes co mpared to m&f have c ∝bardbld∝bardblk·ln1+ǫ∝bardbld∝bardbl≤f(d)≤c′lnk/2∝bardbld∝bardbl ∝bardbld∝bardblk·ln1+ǫ∝bardbld∝bardbl whereǫ >0 is a ﬁxed (arbitrary small) parameter of m&f, and∝bardbl · ∝bardbldenotes theℓ∞norm. Moreover, m&fguarantees the mutual independence of the longrange links. As a consequence, the performances of greedy routing in the lattice enhanced using the distribution fcan be analyzed formally. We prove that the expected number of steps of greedy routing from any sourc esto any targettat distance din thekdimensional lattice satisﬁes E[Xs,t]≤O(ln2+ǫd). Therefore, greedy routing performs polylogarithmically a s a function of the distance between the source and the target. In particular, t he performances of greedy routing are essentially the same as the ones obtain ed by Klein berg [24] using the ad hoc kharmonic distribution [24]. Up to our knowledge, these results are the ﬁrst formal proof t hat nav igability in small worlds can emerge from a dynamical proces s for network evolution (see Table 1). Moreover, m&fis simple (by just coupling two simple dynamics), naturally distributed (each node takes c are of just its to ken), robust (the loss of one token simply requires to launch a new token), and scalable (by direct adaptations of the inﬁnite lattice s etting to square toroidal meshes of arbitrary sizes). Last but not least, m&fcan ﬁnd practical applications, including the design of distributed spatial gossip and resource location protocols. 1.5 Related works "
448,Analyzing Zone Routing Protocol in MANET Applying Authentic Parameter.txt,"Routing is the main part of wireless adhoc network conventionally there are
two approaches first one is Proactive and another one is Reactive. Both these
approaches have some substantial disadvantage and to overcome hybrid routing
protocols designed. ZRP (Zone Routing Protocol) is one of the hybrid routing
protocols, it takes advantage of proactive approach by providing reliability
within the scalable zone, and for beyond the scalable zone it looks for the
reactive approach. It (ZRP) uses the proactive and the reactive routing
according to the need of the application at that particular instance of time
depending upon the prevailing scenario. This work revolves around the
performance of ZRP against realistic parameters by varying various attributes
such as Zone Radius of ZRP in different node density. Results vary as we change
the node density on Qualnet 4.0 network simulator.","  Mobile ad hoc networks (MANETs) [1] are collections  of mobile nodes, dynamically forming a temporary  network without preexisting network infrastructure or  centralized administration. These nodes can be arbitra rily  located and are free to move randomly at any given time ,  thus allowing network topology and interconnections  between nodes to change rapidly and unpredictably.  MANET is likely to be use in many practical  applications, including personal area networks, home  area networking, and military environments, and so on  recent advances in wireless technology have enhanced  the feasibility and functionality of wireless mobile ad hoc  networks (MANETs). There has been significant  research activity over the past 10 years into performan ce  of such networks with the view to develop more efficien t  and robust routing protocols. However, there is majority   research has concentrated on proactive or reactive  routing protocol for data transmission, improving  performance metrics and on the Security threats of thi s  protocol by making change in it. But proactive and  reactive both have some disadvantage as hybrid routing  protocol come into existence is combination of both proactive and reactive, ZRP one among them come in to  existence. Our contributions are as follows: Section I ,  introduces ZRP protocol and its component Section II,  give details of previous and related work. In section III,   we discuss about the simulation environment, in section   IV, we discuss the result and in Section V, we conclude  all the work and future work.    I. 1 ZRP (ZONE ROUTING PROTOCOL)  ZRP [6] is a framework by using it we can take  advantage of both table driven and on demand driven  protocol according to the application. In this separation   of nodes, local neighborhood from the global topology of  the entire network allows for applying different  approaches and thus taking advantage of each  technique’s features for a given situation. These local  neighborhoods are called zones (hence the name) each  node may be within multiple overlapping zones, and each  zone may be of a different size. The “size” of a zon e is  not determined by geographical measurement, as one  might expect, but is given by a radius of length  α where α  is the number of hops to the perimeter of the zone.                    Figure 1 ZRP having Zone radius α =2    In the above diagram ZRP, protocol having Zone radius 2  in this in side the zone communication  done in proacti ve  way and out side it between such zones in reactive way.   A, E, F, H, J, C are interior node and D, G, I, k are  border nodes communication between B and K is done  through proactive way and L is located out side the zone.  ZRP consist of [8] three parts IARP [9] proactive part,  Analyzing Zone Routing Protocol in MANET Applying Authentic Parameter Kamaljit I. Lakhtaria MCA Department,  Atmiya Institute of Technology & Science Yogidham, Rajkot, Gujarat, INDIA Email: kamaljit.ilakhtaria@gmail.com  IERP [10] reactive part of it and BRP [11] used with  IERP to reduce the query traffic.    I.2 IARP (INTRA ZONE ROUTING PROTOCOL)  The Intra zone Routing Protocol (IARP) [9] is a  limited scope proactive routing protocol, which used to  support a primary global routing     protocol. The routing  zone radius shows the scope of the proactive part, the  distance in hops that IARP route updates relayed. IARP's  proactive tracking of local network connectivity provides   support for route acquiring and route maintenance. First,  routes   to local nodes are immediately available,  avoiding the traffic overhead and latency of a route  discovery.  Traditional proactive link state protocols  modified to serve as an IARP by limiting link state  updates to the scope of the link source's routing zone.     I.3 IERP (INTER ZONE ROUTING PROTOCOL )  The Interzone Routing Protocol (IERP) is the global  reactive routing component of the Zone Routing Protocol  (ZRP)[6].IERP adapts existing reactive routing protocol  implementations to take advantage of the known  topology of each node's surrounding Rhop neighborhood  (routing zone), provided by the Interzone outing Protocol  (IARP)[9]. The availability of routing zone routes allo ws  IERP to suppress route queries for local destinations.  When a global route discovery is required, the routing  zone based border cast service [11] used for efficiently  guide route queries outward, rather than blindly relaying  queries from neighbor to neighbor. Once a route  discovered, IERP can use routing zones automatically to  redirect data around failed links similarly, suboptimal  route segments identified and traffic rerouted along  shorter paths.       I.4 BRP (BORDERCAST RESOLUTION  PROTOCOL)  The Bordercast Resolution Protocol (BRP) [11] provides  the bordercasting packet delivery service. The BRP uses a   map of an extended routing zone, provided by the local  proactive Intrazone Routing Protocol (IARP) [9], to  construct Bordercast (multicast) trees along which query  packets are directed. (Within the context of the hybrid  ZRP, the BRP used to guide the route requests of the  global reactive Interzone Routing Protocol (IERP) [10]).   The BRP uses   special query control mechanisms to stee r  route requests away from areas of the network that have   already covered by the query. The combination of  multicasting and zone based query control makes  Bordercasting an efficient and tunable service that is  more suitable than flood searching for network probing  applications like route discovery. The Bordercast Resolution Protocol (BRP) is a packet delivery service,   not a full featured routing protocol. Bordercasting  enabled by local proactive Intrazone Routing Protocol  (IARP) and supports global reactive Interzone Routing  Protocol (IERP).     II RELATED WORKS  "
135,CARL-DTN: Context Adaptive Reinforcement Learning based Routing Algorithm in Delay Tolerant Network.txt,"The term Delay/Disruption-Tolerant Networks (DTN) invented to describe and
cover all types of long-delay, disconnected, intermittently connected networks,
where mobility and outages or scheduled contacts may be experienced. This
environment is characterized by frequent network partitioning, intermittent
connectivity, large or variable delay, asymmetric data rate, and low
transmission reliability. There have been routing protocols developed in DTN.
However, those routing algorithms are design based upon specific assumptions.
The assumption makes existing algorithms suitable for specific environment
scenarios. Different routing algorithm uses different relay node selection
criteria to select the replication node. Too Frequently forwarding messages can
result in excessive packet loss and large buffer and network overhead. On the
other hand, less frequent transmission leads to a lower delivery ratio. In DTN
there is a trade-off off between delivery ratio and overhead. In this study, we
proposed context-adaptive reinforcement learning based routing(CARL-DTN)
protocol to determine optimal replicas of the message based on the real-time
density. Our routing protocol jointly uses a real-time physical context,
social-tie strength, and real-time message context using fuzzy logic in the
routing decision. Multi-hop forwarding probability is also considered for the
relay node selection by employing Q-Learning algorithm to estimate the
encounter probability between nodes and to learn about nodes available in the
neighbor by discounting reward. The performance of the proposed protocol is
evaluated based on various simulation scenarios. The result shows that the
proposed protocol has better performance in terms of message delivery ratio and
overhead.","Delay/disruption Tolerant Networks (DTN) are a class of wireless network in which at a given instance of time the existence of an end to end path from source to destination is low or it may not exist forthe particular time [1]. DTN provides connectivity in challenging environment, such as wildlife track ing, village communication network, Vehicular Ad hoc Network (VANET), health service for developing regions, satellite communication, socialbased mobile 1arXiv:2105.00544v1  [cs.NI]  2 May 2021network, and Internet of Things (IoT). In such kinds of environment network topology changes frequently, there is no preexisting infrastructure and endtoend paths are rarely available due to node mobility behav ior and limited capability of mobile nodes (in terms of battery, processing and buer storage) [2, 3, 1, 4]. According to [5], most of the nodes in DTN are mo bile, the connectivity of the network is maintained by participant nodes only when they are in the commu nication range of one another. Due to the node mobil ity, the network topology is changing frequently, and the assumption of the endtoend path may not be available temporarily. As a result, routing in DTNs follows a series or relay nodes, this paradigm is known as StoreCarryandForward paradigm [5]. In this paradigm if a node has a message copy but if it is not connected to another node, it stores the message in its buer until another node comes in to the com munication range, once the other node comes in to the communication range it forwards the message to the encountered node with the hope that the encoun tered node can deliver the message to destination. This process will continue to every encounter node until the message reaches to the destination. When multiple nodes come in the communication range the best relay node selection mechanism will be used ac cording to the routing algorithm design. Dierent algorithm uses dierent relay node selection crite ria from social network metrics (such as similarity, community, popularity, and betweenness) or pure op portunistic metrics (such as  ooding, history of en counter and probabilistic) [6]. DTNs communication mainly focuses on sending messages resides in the node buer to their intended destination by achieving high message delivery and reducing overhead in the network. In this commu nication environment, there is a thread o between message delivery probability and overhead. When ever a connection established between two nodes, and if there is a message that needs to be transmitted a decision needs to be made by the routing algorithm runs on the node whether the message should be for warded or not to the encountered node. Forwarding the message frequently can result in excessive packet loss and large overhead and buer utilization. On the other side, less frequent transmission leads to lowerdelivery ratio [3]. Selection of best relay node which have higher de livery probability towards to destination is one of the main challenges in DTN routing. The probability of successful delivery is dependent on various factors that represent the history and capability of nodes to successfully deliver the message. The node should know the network structure and other nodes available in the network whether there is a sparse or dense con nectivity in the area. The network density in a given communication area have higher impact in the mes sage delivery and overhead in the network. Knowing exact density of the node in a given communication area helps to determine the the number of message replicas in a given area to get lower overhead in the network. Due to topology change network interruption and limited capability of node aect the amount of packet delivery from source to destination node. To achieve higher message delivery ratio in DTN nodes gener ate multiple message copy to the encountered node, results additional overhead. As indicated by [2] in DTN environment there is a tradeo between deliv ery probability and overhead. There have been several existing routing protocols proposed in DTN, those routing algorithms are dier entiated by queue management, the amount of infor mation available to make forwarding decision, max imum hopcount a message can have and maximum number of allowed message replicas in the network. To achieve better performance in terms of delivery probability and overhead, in this study we take into account realtime physical context of node, socialtie strength among nodes, and realtime message context jointly. We use fuzzy logic in the routing decision to prioritize nodes based on their realtime context. Multihop forwarding probability is considered using reinforcement learning. In this study we design and develop a context adap tive reinforcement learning based routing (CARL DTN) protocol to determine optimal replica of the message in the network based on the network den sity. The protocol dynamically detects network envi ronment changes and the current context of nodes to determine a replica of the message, to prioritize the messages and to identify the best relay node in the 2network. 2. RELATED WORK "
446,WebFlow: Scalable and Decentralized Routing for Payment Channel Networks with High Resource Utilization.txt,"Payment channel networks (PCNs) have been designed and utilized to address
the scalability challenge and throughput limitation of blockchains. Routing is
a core problem of PCNs. An ideal PCN routing method needs to achieve 1) high
scalability that can maintain low per-node memory and communication cost for
large PCNs, 2) high resource utilization of payment channels, and 3) the
privacy of users. However, none of the existing PCN systems consider all these
requirements. In this work, we propose WebFlow, a distributed routing solution
for PCNs, which only requires each user to maintain localized information and
can be used for massive-scale networks with high resource utilization. We make
use of two distributed data structures: multi-hop Delaunay triangulation (MDT)
originally proposed for wireless networks and our innovation called distributed
Voronoi diagram. We propose new protocols to generate a virtual Euclidean space
in order to apply MDT to PCNs and use the distributed Voronoi diagram to
enhance routing privacy. We conduct extensive simulations and prototype
implementation to further evaluate WebFlow. The results using real and
synthetic PCN topologies and transaction traces show that WebFlow can achieve
extremely low per-node overhead and a high success rate compared to existing
methods.","Blockchain is a promising solution for decentralized digital ledgers. Since Bitcoin was invented in 2008 [ 18], there have been many other payment systems emerging based on blockchains, such as Ripple [ 3], Stellar [ 10], and Ethereum [ 9]. While blockchains have shown the great success as decentralized digital ledgers, scalability remains a huge problem with growing numbers of users and transactions [ 5, 20]. For instance, Bitcoin can only support 10 transactions per second at peak in 2020 [ 2]. In contrast, some widely used centralized payment hubs such as Visa and MasterCard can process more than 65,000 transaction messages per second as of June 30, 2019 [ 1]. The reason for such a low throughput is that every node processes all transactions and the consensus is achieved by proofofwork, a time and resourceconsuming process. Whenever a new block arrives, all nodes in the network have to process it and update the state of the blockchain. Hence using blockchains as a global transaction system for massive users is impractical at this moment. There are some improvements in basic blockchain such as BitcoinNG [ 8] and Monoxide [ 24]. However, their performance is limited by the processing capacity of the nodes and network bandwidth, and thus, cannot be used as largescale global transaction systems. aMultihop payment  path of $3Channel $5: $5b Channel $5: $5 c (a) Before payment aChannel $2: $8b Channel $2: $8 c (b) After paymentFigure 1: A multihop payment in a PCN. The recently proposed concept of payment channel networks (PCN) [ 12,20] provides a highthroughput solution for blockchain based payment systems. In a PCN, a user 𝑎can conduct transactions with another user 𝑏through a bidirectional channel. For this chan nel, only two transactions need to be recorded on the blockchain: opening and shutting down the channel. Each user commits a cer tain fund at the opening of this channel. Then they can make any number of transactions that update the tentative distribution of the channel’s funds as long as the remaining funds allow. Fig. 1(a) shows a simple example of a PCN. There is a channel 𝑎−𝑏between user𝑎and𝑏which includes $5from𝑎and$5from𝑏, and a channel 𝑏−𝑐between user 𝑏and𝑐which includes $5from𝑏and$5from𝑐. When𝑎pays𝑏$3, the fund distribution in the channle 𝑎−𝑏changes to$2for𝑎and$8for𝑏. These transactions only need to be signed by the signatures of 𝑎and𝑏but do notneed to be broadcast to the entire blockchain. Each user can establish channels to multiple other users. But the channel is not always existed between two arbitrary users, and two users sharing a channel usually reflects some level of trust. A user can make a transaction with another arbitrary user via a multihop path, where any two consecutive users on the path share a channel. For example, if 𝑎wants to make a payment to another user 𝑐without a direct channel, as shown in Fig. 1(a).𝑏has direct channels to both 𝑎and𝑐. Hence they can use the multihop path 𝑎−𝑏−𝑐and adjust the fund distribution on the channels 𝑎−𝑏and𝑏−𝑐accordingly as in Fig. 1(b). The PCN is a promising solution to achieve scalability of blockchains because most transactions can be achieved in an offchain manner. The ultimate vision is that everyone can conduct payment transac tions with any other person in the world using a trust network [ 11] without centralized organizations such as banks and governments. The core problem of a PCN is routing, i.e., finding a path be tween two arbitrary users. Current routing solutions of PCNs can be classified into two types. 1) Centralized routing that assumes every user knows the entire network topology, including all nodes (users), links (channels), and link balances (available funds on each link). Then each user runs a centralized algorithm to determine the routing paths [ 20,23,25].This approach is not a scalable solution because when a PCN includes many users, each user needs a large memory space to store the network information and every change on any link needs to broadcast to all users. The massive link state updates could cause high network bandwidth cost and the memory 1arXiv:2109.11665v1  [cs.NI]  23 Sep 2021Node  overhead Low Good PoorHigh Resource utilizationCentralized  Landmark Embedded WebFlowFigure 2: Tradeoff of PCN routing ab cd ab cd ab cd ab cd (a) A PCN (b) Landmark routingLandmarkLandmarkChannel resource around the landmark  could run out quickly (d) WebFlow (c) Embedding routinge Figure 3: Example of different routing methods for PCNs. cost is a severe problem for mobile users . 2) Distributed routing for which each user only knows and interacts with a small subset of other users, independent of the entire network size [ 15,21]. It is ideal for largescale PCNs. Existing distributed routing methods for PCNs, however, have acrucial limitation : they cannot effectively utilize the channel resource in a PCN. We show an example of a PCN with 7 users and 9 channels as in Fig. 3(a). One typical distributed routing for PCNs is landmark routing [ 15], in which a spanning tree rooted at a landmark user is generated as shown in Fig. 3(b). Every transaction (such as the one from 𝑐to𝑑) will be sent to the landmark first. The landmark knows the whole network topology and will find the path to the destination 𝑑. This approach does not utilize non tree channels, and channel resources around the landmark could quickly run out. One improvement is embeddingbased routing, which is designed to avoid some unnecessary hops in the landmark routing [ 21]. It learns a vector embedding for each node. Each node relays each transaction to the neighbor whose embedding is closest to the destination’s embedding. Hence it is possible to utilize some nontree links in a subtree as shown in Fig. 3(c). However, many transactions still need to pass through the landmark and cause similar problems. Poor channel utilization means fewer transactions can be successfully delivered in a PCN. In this paper, we introduce WebFlow, a scalable and distributed routing solution for PCNs with small pernode overhead and high channel resource utilization. As in Fig. 3(d), WebFlow allows each node to explore the routing paths without relying on certain “hot spots” such as landmarks. Hence, the resource utilization is signifi cantly improved. Meanwhile, each node only stores the information of a few neighbors without knowing the global topology. As shown in Fig. 2, WebFlow provides significantly lower pernode overhead compared to centralized, landmark, and embedding routing while achieving similar channel resource utilization to that of central ized routing. In theory, centralized routing should always achieve better resource utilization than all distributed routing because it can apply any optimization. However, in our evaluation, we com pare WebFlow with two recent centralized LCN routing methods [23,25] in terms of resource utilization and found it ties with one and outperforms the other. WebFlow is a coordinatedbased geographic routing protocol for PCNs. It allows every node to calculate a set of Euclidean co ordinates and uses the coordinates to perform coordinatedbased greedy routing. We design a system that nodes maintain a multi hop Delaunay triangulation (MDT) [ 14] based on only the channelswith trusted users to achieve a high success ratio of pathfinding. To further protect the anonymity of senders and recipients, our impor tant innovation is to use the property of a distributed Voronoi diagram to achieve the routing tasks. Different from traditional greedy routing, it does not require the coordinates of the destina tion in a routing message. Instead, it introduces a direction vector to help to determine the path that hides the actual destination. In summary, this paper makes the following contributions: •We design WebFlow, a new routing protocol for PCNs with low pernode overhead while achieves high resource utilization. •We propose an enhanced version of WebFlow to protect user privacy, i.e., the identities of source and destination of a transaction can be hidden, even if the attacker stands on the path. •We implement WebFlow based on realworld PCN topolo gies and transactions and build a prototype that can run as a real system. The results show the claimed advantages of WebFlow compared to the stateoftheart protocols. The rest of this paper is organized as follows. Section 2 introduces the background of PCNs and the related work. The system overview and model are presented in Section 3. We describe the detail design of the WebFlow protocols in Section 4 and Section 5. Section 7 presents the evaluation results of WebFlow. Section 9 summarizes our conclusions. This work does not raise any ethical issues. 2 RELATED WORK "
108,"RALL - Routing-Aware Of Path Length, Link Quality, And Traffic Load For Wireless Sensor Networks.txt","Due to the enormous variety of application scenarios and ubiquity,Internet of
Things (IoT) brought a new perspective of applications for the current and
future Internet. The Wireless Sensor Networks provide key devices for
developing the IoT communication paradigm, such as the sensors collecting
various kind of information and the routing and MAC protocols. However, this
type of network has strong power consumption and transmission capacity
restrictions (low speed wireless links and subject to interference). In this
context, it is necessary to develop solutions that enable a more efficient
communication based on the optimized utilization of the network resources. This
papers aims to present a multi-objective routing algorithm, named Routing-Aware
of path Length, Link quality, and traffic Load (RALL), that seeks to balance
three objectives: to minimize bottlenecks, to minimize path length, and to
avoid links with low quality. RALL results in good performance when taking into
consideration delivery rate, overhead, delay, and power consumption.","The Internet has been employed more and more, and becoming an essential tool forhumans. Nowadays, notonlypeopleusethisinformationandcommunication technology, as well as machines employ it to communicate with each other, mak ing measurement of various types of information. The Internet of Things (IoT) paradigm allows these machines to communicate and feel the environment [3]. 1arXiv:1609.04735v1  [cs.NI]  15 Sep 2016WirelessSensorNetworks(WSNs)playanimportantrolewithintheIoTand have gained increasing prominence as part of ubiquitous computing in various environments, such as industry, smart cities, smart spaces, smart grids, health monitoring environmental, realtime multimedia applications [3, 15, 2]. WSNs consist of various nodes that generally have strong processing, battery, and memoryconstraints. Typically, eachnodehasonlyoneradiointerface(generally 802.15.4 CSMA/CA) with a ﬁxed transmission rate (250 kbps) [20]. Usually, a ﬂat model is employed to organize the network, where all the nodes play the same role in sensing, processing, and (re)broadcast packets. The information is forwarded (routed) node by node until it reaches the sink node, where it is processed [1, 14, 17]. This paper will treat the routing optimization problem based on three objectives: (i) minimize the path length (number of hops), (ii) minimize the bottleneck, and (iii) minimize the interference in the path. At the routing, each hop could increase the delay. This article is organized as follows: In Section 2, we present a model for the routing problem of multiobjective optimization. In Section 3, we describe the proposed algorithm to determine a solution for the model. In Section 4, we present the simulation results. In Section 5, we analyze the most relevant related work on routing approaches for WSNs. The conclusion and future work is carried out in Section 6. 2 System Model WSNs consist of various sensors, distributed in an area, that enable data collec tion. Most of these sensors monitor or interact with the environment in which they are. A node in particular, called sink, is designed to gather all the data collected by the sensors. The sink node is attached to a machine with more processing capacity (e.g. servers in cloud computing environment) so that col lected data can be transformed into information and knowledge, to be used by various applications. WSNs are modeled as a graph G= (V; E), where Vis the set of vertices that represents the sensors, Eis the set of communication links between two network devices. The link esd2Ebetween s; d2Vexists only if the device s accomplish a data transmission to the node d, i.e. the node dmust be in the transmission range of s. Some metrics can be employed for determining if a link between two sensors can actually be used. Every sensor s2V"
321,CBHRP: A Cluster Based Routing Protocol for Wireless Sensor Network.txt,"A new two layer hierarchical routing protocol called Cluster Based
Hierarchical Routing Protocol (CBHRP) is proposed in this paper. It is an
extension of LEACH routing protocol. We introduce cluster head-set idea for
cluster-based routing where several clusters are formed with the deployed
sensors to collect information from target field. On rotation basis, a head-set
member receives data from the neighbor nodes and transmits the aggregated
results to the distance base station. This protocol reduces energy consumption
quite significantly and prolongs the life time of sensor network. It is found
that CBHRP performs better than other well accepted hierarchical routing
protocols like LEACH in term of energy consumption and time requirement.","Wireless sensor networks (WSN) have been identified  as one of the most important technologies  in the 21st century for various applications such a s habitat monitoring, automation, agriculture,  and security. WSN consists of several tiny sensors called nodes that are organized in spatially  distributed topography. Researchers define WNS as a n important component in the field of  Ubiquitous computing [1, 2]. Proactive computing co ncepts apply on WSN. With the proactive  computing model, computers will anticipate our need s and sometimes take action on our behalf.  Wireless sensor networks and proactive computing ca n assist us to improve efficiency, have data  from places which are otherwise difficult to get or  to costly to monitor [3].     The dimension of microsensor is another important d esign goal. The size of sensor becomes very  tiny day by day. The nodes are typically battery op erated sensing devices with limited energy  resources. Due to the small size, the battery of th e nodes is fixed. One of the elegant ways to turn  off the sensor hardware when they are not used [4].  But replacing the sensor nodes is difficult  when their energy is depleted [5]. Computer Science & Engineering: An International Jo urnal (CSEIJ), Vol.1, No.3, August 2011  2 Scalability and performance consistency are the maj or design attributes of sensor networks.  To  allow the system to cope with additional load and t o be able to cover a large area of interest  without degrading the services, networking clusteri ng has been pursued in some routing approach  [6]. The main objectives of clustering hierarchy is  to efficiently maintain the energy consumption  of sensor nodes by involving them in adhoc communi cation within a particular cluster and by  performing data aggregation and fusion in order to decrease the number of transmitted message to  the base station. Cluster formation is typically ba sed on the reserve of sensors and sensors’  proximity to the cluster head.    The lifetime of sensor can be increased by optimize d the applications, operating systems, and  communication protocols. Using existing hardware, i mprovement of communication protocol can  prolong the lifetime of the network. This feature o f WSN has opened new era for scientists and  engineers to develop efficient routing protocol. Nu merous concept of communication protocol  can be found in literature [7, 8] to reduce the ene rgy consumption of the wireless sensor  networks. LowEnergy Adaptive Clustering Hierarchy (LEACH), is one of the best  communication protocols for wireless sensor network s [911]. However, improvement of LEACH  protocol is going on to make it more efficient [4,] , [1213]. Therefore, it is significant to extend  the sensor networks lifetime through proficient use  of the sensor nodes energy. Our new proposed  protocol increases the lifetime effectively than th at of others by reducing the energy consumption.  2.  RELATED WORKS   "
128,Topology-Aware Resilient Routing Protocol for FANETs: An Adaptive Q-Learning Approach.txt,"Flying ad hoc networks (FANETs) play a crucial role in numerous military and
civil applications since it shortens mission duration and enhances coverage
significantly compared with a single unmanned aerial vehicle (UAV). Whereas,
designing an energy-efficient FANET routing protocol with a high packet
delivery rate (PDR) and low delay is challenging owing to the dynamic topology
changes. In this article, we propose a topology-aware resilient routing
strategy based on adaptive Q-learning (TARRAQ) to accurately capture topology
changes with low overhead and make routing decisions in a distributed and
autonomous way. First, we analyze the dynamic behavior of UAV nodes via the
queuing theory, and then the closed-form solutions of neighbors' change rate
(NCR) and neighbors' change interarrival time (NCIT) distribution are derived.
Based on the real-time NCR and NCIT, a resilient sensing interval (SI) is
determined by defining the expected sensing delay of network events. Besides,
we also present an adaptive Q-learning approach that enables UAVs to make
distributed, autonomous, and adaptive routing decisions, where the above SI
ensures that the action space can be updated in time at a low cost. The
simulation results verify the accuracy of the topology dynamic analysis model
and also prove that our TARRAQ outperforms the Q-learning-based topology-aware
routing (QTAR), mobility prediction-based virtual routing (MPVR), and greedy
perimeter stateless routing based on energy-efficient hello (EE-Hello) in terms
of 25.23%, 20.24%, and 13.73% lower overhead, 9.41%, 14.77%, and 16.70% higher
PDR, and 5.12%, 15.65%, and 11.31% lower energy consumption, respectively.","THE paradigm of the Internet of Things (IoT) enables highly integrated smart machines and devices to ac cess and process information from the physical environment without human interaction [1]. As the emerging device of IoT and the carrier of aerial technology, Unmanned Aerial Vehicle (UA V) plays a crucial role in military and civilian IoT applications such as coverage monitoring, emergency communication, remote sensing and disaster rescue (e.g. the recent Australian wildfire) [2], thanks to its flexibility, small volume, low cost, concealment, rapid deployment [3], etc. Compared with the application of a single UA V node, the This work was partly supported by National Key Research and Development Project (Grant No. 2020YFA0711300) and National Natural Science Foun dation of China (NSFC) (Grant No. 62022020, 61790553). (Corresponding author: Zhiyong Feng.) Yanpeng Cui, Qixun Zhang, Zhiyong Feng, Zhiqing Wei, Ce Shi and Heng Yang are with the Key Laboratory of Universal Wireless Communi cations, Ministry of Education, School of Information and Communication Engineering, Beijing University of Posts and Telecommunications, Beijing 100876, China, email: {cuiyanpeng94; zhangqixun; fengzy; weizhiqing; sc; yangheng }@bupt.edu.cn.coordination of multiUA Vs can shorten the mission duration and improve efficiency. Thus, the Flying Adhoc Networks (FANETs) emerges to improve cooperation and scalability. However, there are challenges in cooperative communication and routing in FANETs due to the intermittent connectivity and the energy consumption of UA Vs [4]. Recently, extensive research has been conducted on how to improve the mo bile adhoc network routing protocols and implement them in FANETs, but the latter’s sparse heterogeneity structure, dynamic mobility, limited energy and serious fragmentation are the major issues in designing an efficient routing strategy ensuring a robust data exchange between UA Vs [5]. There are multiple categories of FANETs routing protocols for different Quality of Service (QoS), such as topologybased and geographicbased. The topologybased protocols include hierarchical and flat patterns. The former are designed for largescale networks due to the strong scalability, whereas the cost and complexity of clustering might outweigh the pros in sparse FANETs [6]. For flat routing methods, the proactive ones have a huge overhead for routing table while the reactive ones create the intolerable delay, and most of their hybrid ignore the standard attributes of UA Vs, namely the Global Positioning System (GPS), which provides a precious oppor tunity for geographicbased protocols [7]. Based on location information, the geographicbased protocols find appropriate relays towards the destination by greedy forwarding, hence nodes no longer need to explore the state of the entire net work [8]. Although FANETs with high mobility and dynamic mission will benefit from geographicbased protocols, there are still some issues to be addressed. First, the routing decisions should be made in a distributed and autonomous way for each UA V since the global state of the entire network is unavailable when they are configured with geographicbased protocols. Qlearning, which is one of the easiest and most practiced reinforcement learning (RL) techniques, is envisioned as a promising solution [9]. By adjusting their behavior according to the reward function of environmental feedback, the intelligent agent can achieve optimal decisions without prior knowledge. This makes it possible for adaptive autonomous routing decisions. Whereas, the shortest route may be the one with poor link duration (LD) and unbalanced energy consumption, and the routing holes will appear once there is no suitable relay next [10]. At the time of writing, considering multiple metrics can work to a certain extent at the cost of detour. However, since the learningbased protocol works via the continuous and periodic interaction between agents and the environment, the relays willarXiv:2306.17360v1  [cs.NI]  30 Jun 20232 deviate from the best decision if there is a false hole owing to the inaccurate environment information. Due to the timevarying topology of FANETs, the learning performance will deteriorate since nodes often lag in capturing rapid topology changes. Thanks to the Hello protocol, nodes can announce their existence and exchange status periodically with each other [11]. The Qlearningbased routing protocols use Hello messages to interactive with the dynamic environ ment, namely maintain the neighbor status, where the Hello timer and expiration timer (ET) play a significant role. More concretely, the former represents the periodic sensing interval (SI) while the latter reflects the validity period of neighbors [12]. However, both of them are deterministic in the routing protocol standard proposed by the Internet Engineering Task Force [13], which often has a poor performance in the rapidly changing FANETs due to the following reasons. On one hand, the network performance is affected by SI. A smaller SI can ensure the accuracy of topology change detection whereas the additional overhead is wasted if the frequency of perception is higher than the neighbors’ change rate (NCR) or the traffics’ arrival rate (TAR). Conversely, although the overhead and energy consumption can be reduced by a larger SI, there will be serious packet loss if the SI lags behind the arrival of traffics or is too large to perceive the change of key links [14]. On the other hand, the SI is determined by the network performance demands. For example, UA Vs are sensitive to delay when acting as an aerial relay [15], and they will have more stringent requirements for overhead (energy efficiency) when performing coverage monitoring tasks [16]. Besides, the stability and reliability of the links are more critical when UA Vs are utilized to search and rescue [17]. Thus, resilient SI should be designed to enable the network to meet various performance demands. In this paper, we conduct thorough research on the above is sues. We begin with constructing a queuing service framework for analyzing link establishment and disconnection between UA Vs, then the closedform expressions of LD, NCR and distribution of neighbors’ change interarrival time (NCIT) are derived. Then we propose a protocol called Topology Aware Resilient Routing based on Adaptive Qlearning (TAR RAQ) that enables UA Vs to make distributed, autonomous and adaptive routing decisions, which contains three phases: 1) neighbor discovery; 2) neighbor maintenance; 3) relay selection. During the first two phases, the residual LD pre dicted by Kalman Filter (KF) is working as an expiration timer for available neighbors, and the NCR and NCIT are used to calculate the resilient SI on demand, namely all UA Vs can dynamically adjust their sensing scheme based on dynamic behavior and performance requirements, thus the accurate information of neighbors can be obtained accordingly with tolerable overhead. When it comes to the last phase, the neighbor information obtained previously is regarded as the finite states where agents attempt to take actions, and an adaptive Qlearning approach is presented to ensure the distributed and autonomous routing decisions. For clarity, we summarize our contribution as follows. •We analyze the dynamic topology changes of FANETs via queuing theory, which reveals the mapping relaTABLE I: Main Abbreviations Used in This Paper. Abbreviations Explanation CQS Cyclic Queuing System DEWMA Dynamic Exponential Weighted Moving Average EEHello EnergyEfficient Hello EIT Events’ Interarrival Time ET Expiration Timer E2ED EndtoEnd Delay FANETs Flying Adhoc Networks KF Kalman Filter LD Link Duration MPVR Mobility Predictionbased Virtual Routing NCIT Neighbors’ Changes Interarrival Time NCR Neighbors’ Change Rate NIT Neighbors’ Interarrival Time PDR Packet Delivery Ratio PPP Poisson Point Process QTAR QLearningbased TopologyAware Routing RWP Random Waypoint SI Sensing interval TAR Traffics’ Arrival Rate TARRAQTopologyAware Resilient Routing Based on Adaptive Qlearning tionship between LD and service duration, NCR and customer change rate, NCIT and distribution of customer change interarrival time, respectively. And the closed form expressions of LD, NCR and NCIT are derived to describe the mobility behavior accurately. To the best of our knowledge, this is the first research to accurately characterize the topology changes of FANETs; •We propose a novel resilient perception strategy based on the first contribution. The NCR with dynamic exponential weighted moving average (DEWMA) process is used to calculate the topology changes. By defining the expected sensing delay of the network events, the resilient SI is determined based on the realtime NCR and NCIT to satisfy the network’s dynamic demands. Besides, with the KF method introduced, the residual LD is predicted to determine the validity period of neighbors; •We present an adaptive Qlearning approach, which en ables UA Vs to make distributed and autonomous rout ing decisions. In dynamic FANETs, the action space is updated in time with the low cost through the second contribution. The reward function is designed based on the link quality, residual energy and distance of neighbors to find a stable path with a lower loss rate, fewer hops and energy consumption. Besides, the action selection, learning rate and discount factor are adjusted according to the residual LD, which achieves adaptive learning from the variable network environment. The remainder of this article is organized as follows. In section II, the related works are classified and analyzed. Section III introduces the motivation scenario, network model and Qlearning framework for FANETs routing. The queuing service system model and the TARRAQ protocol is proposed in sections IV and V , respectively. Extensive simulations are performed in section VI to verify the accuracy of the proposed model, and the performance of TARRAQ is discussed. Finally, we conclude this article in section VII. The key and unique3 abbreviations are summarized in Table I . II. R ELATED WORKS "
296,ShorTor: Improving Tor Network Latency via Multi-hop Overlay Routing.txt,"We present ShorTor, a protocol for reducing latency on the Tor network.
ShorTor uses multi-hop overlay routing, a technique typically employed by
content delivery networks, to influence the route Tor traffic takes across the
internet. ShorTor functions as an overlay on top of onion routing-Tor's
existing routing protocol and is run by Tor relays, making it independent of
the path selection performed by Tor clients. As such, ShorTor reduces latency
while preserving Tor's existing security properties. Specifically, the routes
taken in ShorTor are in no way correlated to either the Tor user or their
destination, including the geographic location of either party. We analyze the
security of ShorTor using the AnoA framework, showing that ShorTor maintains
all of Tor's anonymity guarantees. We augment our theoretical claims with an
empirical analysis. To evaluate ShorTor's performance, we collect a real-world
dataset of over 400,000 latency measurements between the 1,000 most popular Tor
relays, which collectively see the vast majority of Tor traffic. With this
data, we identify pairs of relays that could benefit from ShorTor: that is, two
relays where introducing an additional intermediate network hop results in
lower latency than the direct route between them. We use our measurement
dataset to simulate the impact on end users by applying ShorTor to two million
Tor circuits chosen according to Tor's specification. ShorTor reduces the
latency for the 99th percentile of relay pairs in Tor by 148 ms. Similarly,
ShorTor reduces the latency of Tor circuits by 122 ms at the 99th percentile.
In practice, this translates to ShorTor truncating tail latencies for Tor which
has a direct impact on page load times and, consequently, user experience on
the Tor browser.","Tor is the foremost deployed system for anonymous commu nication. Millions of people around the world use Tor every day to escape censorship and avoid surveillance of their browsing habits [ 27,58]. This broad user base is a critical component of Tor’s privacy guarantees. Tor users are anonymous only amongst each other—not within the general internet population. That is, an internet censor may be able to know that some Tor user visited a blocked site, but not which Tor user. Because of this, the degree of anonymity Tor provides in practice grows with the total number of concurrent users on the network [ 25]. This relationship between the privacy of individual users and the overall popularity of Tor makes user experience a major concern for Tor. A poor experience relative to nonprivatebrowsing results in lower adoption of Tor and, ultimately, limits the degree of anonymity Tor is capable of providing. A major factor contributing to positive user experience is latency. Inter net users are very sensitive to latency, and increased page load times discourage user interaction [ 10,11,24]. Unfortunately, anonymous communication incurs higher latency than typical internet connections [8,31,53,54,56,65,83,84]. In Tor, much of this overhead is due to the underlying structure of its connections [ 26,27]. Tor is a network composed of7;000volunteerrun servers, or relays , used to route client trafﬁc. Rather than connecting directly to their destination, Tor clients tunnel their trafﬁc through a series of Tor relays in a process known as onion routing . This drastically increases the path length for Tor trafﬁc, and, in turn, latency. A substantial body of prior work aims to reduce latency in Tor by changing the relay selection process [ 5,7,9,16,42, 74,79,87,90]. By default, Tor clients select relays for their circuit at random, weighted by relay bandwidth, and do not consider path length or circuit latency in the process. In contrast, proposals that aim to reduce latency often prioritize selecting circuits that have low latency between relays [ 5,9,16,42,74,79]. Unfortunately, preferentially choosing circuits in this way also selects relays that are correlated with the identity of the user or their destination [ 12,14,60]. Many attacks show how this can be exploited to deanonymize Tor users, allowing a passive observer to identify information about user locations [ 12,14, 36,60,61,74,85,86]. In this paper, we propose ShorTor, an entirely different approach to reducing the latency of Tor trafﬁc. Rather than alter the circuit selection process, ShorTor exploits a technique used by content delivery networks (CDNs) known as multihop overlay routing [22,81]. Multihop overlay routing, like Tor, functions by introducing intermediate hops into its connections, but does so for the explicit purpose of reducing latency . In the wild, CDNs use multihop overlay routing to inﬂuence the path internet trafﬁc takes. They do this by inserting their own servers as intermediate points in client connections, avoiding slow default routes by forcing trafﬁc to travel through their server, rather than directly to its destination. The success of this technique is due to the existence of suboptimal default routes across the internet [ 28] and the distributed nature of CDNcontrolled nodes. The broad presence of CDN controlledarXiv:2204.04489v1  [cs.NI]  9 Apr 2022servers gives them many possible routes to choose from, and consequently, increases their odds of ﬁnding a faster route to send trafﬁc through. In practice, this allows CDNs to avoid outages, congestion, or other delays along the default path. With ShorTor, we ask: Can multihop overlay routing reduce latency in Tor without compromising anonymity? While multihop overlay routing is widely successful for CDNs (which share some similarities to the Tor network), Tor is much smaller with 7;000nodes [ 67] compared to the 300;000operated by a CDN [ 3]. In addition to the difference in scale, Tor relays are volunteer run and their placement is not optimized for fast routing. ShorTor is the ﬁrst proposal to apply and analyze the impact of multihop overlay routing on the Tor network, and is likely of independent interest to other distributed communication systems. A. ShorTor To reduce the latency experienced by end users of Tor, ShorTor uses multihop routing as an additional overlay layer on top of Tor’s onion routing protocol. Crucially, ShorTor is independent of Tor’s circuit selection algorithm and the client, operating only between relays. ShorTor introduces additional hops, which we call viarelays, that tunnel trafﬁc between relays on a Tor circuit. Acting as a via is simply a role that a normal Tor relay may take in addition to its usual function on circuits. Via relays, unlike circuit relays, can be introduced after circuit establishment in response to changing network conditions without client involvement or any modiﬁcation to the circuit itself. While the basic idea of ShorTor is simple in retrospect, multihop overlay routing has security implications for anonymous communication that are not present in CDNs. Security: We demonstrate that ShorTor can ﬁnd faster paths across Tor without the loss in anonymity experienced by other approaches. ShorTor selects via relays based solely on the adjacent circuit relays. This process ensures that malicious vias cannot lie about their performance to artiﬁcially increase their selection probability. Speciﬁcally, ShorTor operates as an overlay routing layer, requiring no modiﬁcation to Tor’s onion routing or encryption, preserving Tor’s security guarantees. We provide a formal security analysis of the impact ShorTor has on Tor’s anonymity using the AnoA framework, which was introduced by Backes et al. [12] to analyze the anonymity guarantees of Tor [ 13,14]. Using AnoA, we show that ShorTor has minimal impact on security when compared to baseline Tor. However, we ﬁnd that when used in conjunction with alternative,1locationaware path selection algorithms such as LASTor [ 5], ShorTor can exacerbate the existing leakage. We validate these claims through an empirical analysis on data collected from the Tor network. Latency Measurements: To quantify the beneﬁts of ShorTor, we conduct latency measurements between approxi mately 400,000 pairs of the 1,000 most popular Tor relays. We 1Tor’s only deployed path selection algorithm is independent of user location.collect measurements ourselves, rather than use a general purpose source for internet measurements such as RIPE Atlas [ 2], for two main reasons. (1) internet routing operates at a scale and complexity that cannot easily be simulated [ 75] and (2) ISPs often treat Tor packets differently from other internet trafﬁc [ 23]. Using our own pairwise latency dataset we determine that, despite being much smaller than a typical CDN, Tor can still beneﬁt from multihop overlay routing. Ethics: Our measurements were conducted on the live Tor network, but did notinvolve any observations on Tor users or their trafﬁc. We underwent Tor’s security review process and followed best practices to limit our impact on the Tor network. Details can be found in Section IVA5. Practicality: While ShorTor does require modiﬁcations to Tor relays, it does notrely on participation of all, or even a majority of, relays and makes no assumptions about or modiﬁcations to client behavior. Tor circuits can beneﬁt from multihop overlay routing as long as any two adjacent relays on the path both support it. The majority of our evaluation assumes that only the 1,000 most popular Tor relays participate, but we ﬁnd ShorTor is beneﬁcial with even fewer relays participating. ShorTor achieves a latency reduction of 178 ms at the 99.9th percentile with only the 500most popular relays supporting the protocol. As such, ShorTor can be deployed incrementally and still provide meaningful reductions of tail latency on Tor. Limitations: Our dataset of pairwise latencies was col lected from the 1,000 most popular Tor relays. While these relays do see the majority of trafﬁc on Tor [ 39], they are not representative of the full network. The less popular relays, while not as likely to be included in circuits, may beneﬁt similarly from ShorTor, and could broaden the pool of available via relays. A deployed version of ShorTor, however, would naturally include all available relays regardless of popularity. As such, the scale of our dataset is strictly a limitation of our evaluation, not of ShorTor’s effectiveness in practice. Using this data, we ﬁnd that ShorTor primarily impacts tail latencies on the Tor network. On average, ShorTor reduced the RTT between a pair of relays from 42.6 ms to23.5 ms , while at the 99.9thpercentile the RTT dropped much more substantially from 487 ms to125 ms . As a result, the speedups ShorTor offers disproportionally beneﬁt a relatively small fraction of Tor users—approximately 20,000 out of two million daily users select circuits that ShorTor can speed up by 120 ms or more. Contributions: We propose ShorTor, the ﬁrst protocol to apply multihop overlay routing to an anonymous communica tion network. ShorTor is designed to improve performance while preserving the security guarantees of baseline Tor, preventing adversarial relays from gaining an advantage by participating in ShorTor. We evaluate ShorTor using measured latencies from the live Tor network and show that ShorTor can signiﬁcantly improve tail latencies on the Tor network with minimal bandwidth overhead. In summary, this paper contributes: 1)ShorTor: a protocol for multihop overlay routing on Tor which reduces the latency experienced by Tor circuit trafﬁc by 122 ms in the 99thpercentile. 2Onion Encryption:  Guard Middle Exit  TLS Guard Middle  Exit Server Client  m  TCP/TLS Connection Fig. 1: A Tor circuit between a client and server: Tor relays are represented by onions. The circuit is a series of connections between three relays carrying onionencrypted Tor cells. 2)An evaluation of ShorTor’s performance at various levels of deployment based on measured latency between the thousand most popular Tor relays. 3)A security analysis of ShorTor in the AnoA framework, demonstrating minimal impact to user anonymity. II. B ACKGROUND Here, we provide background on Tor and multihop overlay routing, which we combine in Section III to design ShorTor. A. Tor The Onion Router (Tor) is a network for anonymous commu nication comprising approximately 7,000 [67] volunteerrun relays that carry user trafﬁc. We provide a brief overview of Tor’s architecture and security guarantees. For more details on Tor, see the Tor speciﬁcation [26] or paper [27]. 1) Onion Routing: Tor users send their trafﬁc through the Tor network using onion routing . Rather than communicating directly with their destination, clients send their trafﬁc through “layers:” encrypted connections to three (or more) Tor relays in sequence. These relays form a circuit and have ﬁxed roles: Guard relays connect directly to the client and serve as an entry point into the Tor network, Exit relays connect directly to the server and proxy communi cation on behalf of the client, and Middle relays pass trafﬁc between the Guard and Exit. Figure 1 shows a single Tor circuit between a client and server including the connections and layers of encryption involved in Tor’s onion routing protocol. The trafﬁc ﬂowing over a circuit is carried in ﬁxedsize packets called cells which are onion encrypted. That is, cells have a layer of encryption for each relay on the circuit. Tor relays remove their layer of encryption when forwarding cells in the clienttoserver direction and add their layer when returning the responses. This ensures that only the Exit can remove the innermost onion layer, protecting the client’s privacy without requiring destination servers to handle onion encrypted data. 2) Path/Circuit Selection: Path—or circuit—selection is the process by which Tor clients select the set of relays that will form their circuit. This is a randomized process to ensure that the selection of relays is neither predictable nor correlated with BGP Route Multihop  80 ms50 ms  120 ms  90 ms Default   Multihop Server  & Connection  Client  Server 60 ms CDN  Server  Internet  Router Internet  Router Fig. 2: Multihop overlay routing as in a CDN: the client avoids a slow BGP route to the blue server by addressing data to the red CDN server, which then forwards the trafﬁc. the identities of either the client or server. It is, however, not uniformly random as relays have highly variable capacities and not every relay can support the same volume of trafﬁc. As such, path selection is weighted based on a relay’s available bandwidth, along with security considerations. 3) Tor’s Adversarial Model: Tor is intended to provide anonymity to its users. Speciﬁcally, no adversary should be able to link the source and destination of any trafﬁc stream across Tor. Tor’s threat model considers adversaries in the form of malicious relays as well as external observers such as users’ internet service providers. Anonymity in Tor is provided among all concurrent Tor users. While onion routing prevents any individual relay or localized network observer from directly linking a client to their destination, it does nothide the fact that a client is connected to the Tor network in the ﬁrst place. Similarly, onion routing alone does not hide which servers are the destination of Tor connections. As such, both the volume anddiversity of Tor users inﬂuence the degree of anonymity Tor is able to provide. In a wellknown example of this principle, the sender of a 2013 Harvard bomb threat was identiﬁed despite their use of Tor because they were the only client connecting to Tor from Harvard’s campus at the time [21]. 4) Trafﬁc Analysis: Trafﬁc analysis attacks are a type of anonymitycompromising attack against Tor that identify features of encrypted trafﬁc stream, such as packet interarrival times [ 57], to either: 1) recognize a previously observed stream [ 38,47,50,62], linking it across Tor or, 2) observe a pattern corresponding to a website ﬁngerprint and infer the destination of trafﬁc [ 20,45,72,80,88]. Both styles give the adversary an advantage in linking a client to their destination, compromising Tor’s anonymity by making clients, servers, or clientserver pairs more identiﬁable. We give additional details on the capabilities of such adversaries and their impact on Tor in Section V. B. Multihop Overlay Routing Multihop overlay routing is a technique that introduces intermediate waypoints into the connection between a client and server for the purpose of altering the route their trafﬁc takes across the internet. There are many motivations for this technique—Tor’s onion routing is itself an example of multi 3hop overlay routing that provides anonymity by masking the direct relationship between client and destination server. More commonly, CDNs route their trafﬁc over a multihop overlay in order to reduce the latency of their connections as illustrated in Figure 2 [ 22,81]. Two such examples are Cloudﬂare’s Argo [ 55] and Akamai’s SureRoute [ 4]. Rather than relying solely on the Border Gateway Protocol (BGP) to decide routes for their trafﬁc, both Argo and SureRoute instead establish intermediate connections via their own servers. By routing their trafﬁc via these intermediate waypoints they are able to identify and use a route which may be faster than the route selected by BGP. This is possible because BGP is subject to routing policies based on business relationships, not solely on shortest paths [77]. Importantly, this technique is an overlay —it runs on top of standard BGP without modifying any of the underlying protocols. This is achieved by establishing pairwise TCP connections between each of the intermediate points on the multihop overlay route rather than a single direct connection between the client and server. As such, standard BGP handles the route used between hops while the overlay protocol adjusts the ultimate path between client and server via the placement of its waypoints. III. S HORTOR We propose ShorTor, a protocol for reducing the latency of connections over Tor. Like other such proposals, ShorTor preferentially selects faster routes across the Tor network for client circuits. In prior work, fast routes across Tor are equivalent to fast Tor circuits —Tor clients simply optimize for latency when selecting relays for their circuits. Instead, ShorTor creates a multihop overlay on top of the Tor protocol to improve latency as shown in Figure 3. Rather than altering the circuit selection process to favor faster paths, ShorTor changes the routing between relays on existing circuits. It does this by offering circuit relays the option to route their trafﬁc through an additional Tor relay rather than directly to the next hop. These intermediate hops, called via relays , are chosen ondemand by the relays themselves instead of in advance by clients. Via relays are notpart of client circuits and do not participate in onion routing or encryption. By routing as an overlay rather than altering circuit composi tion, ShorTor avoids security pitfalls of prior works while still providing a substantial reduction in latency on the Tor network. Directly optimizing for faster circuits, as in past proposals, has the unfortunate side effect of creating a correlation between the relays a client chooses and the client’s location. Via relays in ShorTor are chosen only based on the circuit relays and inherit their relationship to the client—if circuits are chosen independently, as in the default Tor circuit selection, then via relay choices leak no information about the client. We discuss the implications of running ShorTor with alternative circuit selection techniques in Section V and Section VII. ShorTor’s design gives it several advantages over proposals that modify circuit selection: 1)Security: Routes in ShorTor are independent of the client and destination. Onion Encryption:  Guard Middle Exit  TLS Guard  Middle Exit  m  TCP/TLS Connection  Via  b ms c msa ms Fig. 3: A Tor circuit routing using a via relay between the guard and middle. A via relay will be used when the latency over the via (a+b ms) is less than that of the direct connection (c ms). The via does notparticipate in onion routing. For clarity, and because Shortor only operates between Tor relays, the client and server are not shown. 2)Agility: ShorTor can modify its routes as needed, not just during circuit construction. 3)Compatibility: ShorTor operates with anycircuit selec tion algorithm, making it modular and compatible with future changes to the Tor protocol. While we describe ShorTor in Torspeciﬁc terms, we note that it applies to other distributed communication systems as well. A. Security Model ShorTor inherits Tor’s adversarial model, as described in Section IIA3. It is designed to preserve the same anonymity guarantees against an adversary identifying the sender or recipient of a trafﬁc stream which we deﬁne more formally in Section V. In particular, ShorTor requires no modiﬁcation to Tor’s baseline circuit selection or encryption and preserves independence between circuit choice and the identities of the client and server. However, ShorTor does necessarily change the number and distribution of relays that may see a given trafﬁc stream, which could potentially be exploited by an adversarial Tor relay to deanonymize a larger share of Tor trafﬁc. We formally consider the anonymity impact of ShorTor in our security analysis (Section V). B. ShorTor Protocol ShorTor introduces only one additional step into Tor’s routing procedure. Rather than forwarding cells solely along previously established circuits, relays establish transient alternate routes between themselves and the next hop on their circuits. These alternate routes forward trafﬁc via an additional Tor relay rather than sending it directly to the next relay on the circuit. As such, we refer to the intermediate hops between circuit relays asvia relays , the connection between a circuit relay and a via relay as a via connection , and the communications over this connection as via trafﬁc . Note that the ‘circuit’ and ‘via’ modiﬁers denote different roles a relay may play in ShorTor, but do notcorrespond to different physical entities. A via relay is simply a regular Tor relay that has been chosen as an intermediate hop for some circuit rather than as part of the circuit itself. Any relay in Tor 4Protocol 1: ShorTor CIRCUIT RELAY // Circuit relays conduct data races to determine if a suitable via exists // between themselves and the next relay on the circuit. // Parameter: self, Tor ID for this relay. // State: Routes , the routing table for each circuit. SHORTOR.CHOOSE VIA(circ;dst;candidates ) 1:via RACE.RUN(candidates ;circ;dst)// (Protocol 3). 2:ifvia=?,then return. // no via faster than default route. 3:Routes [circ]:via via. SHORTOR.HANDLE TRAFFIC (cell) 1:ifcell.cmd =VIA then return S HORTOR.HANDLE VIA(cell). 2:candidates LATENCIES .VIASFOR(cell.next ). // (Protocol 2) 3:ifRoutes [cell.circ ] =?then // no routing table entry. 3.1: S HORTOR.CHOOSE VIA(cell.circ ;cell.next ;candidates ). 4:via Routes [cell.circ ]:via. 5:ifvia=?then proceed with default cell routing and return. 6: Set cell.cmd =VIA andcell.prev =self. 7: Send cellto relay via. 8:ifno response from viathen 8.1: candidates candidatesnfviag 8.2: S HORTOR.CHOOSE VIA(cell.circ ;cell.next ;candidates ). 8.3: S HORTOR.HANDLE TRAFFIC (cell) VIARELAY // Via relays forward cells between circuit relays. // Via relays do not perform onion decryption and only forward trafﬁc // if they have the available resources (i.e., bandwidth). SHORTOR.HANDLE VIA(cell) 1:route Routes [cell.circ ] 2:ifunder heavy load or route =?then drop cell and return. 3: Forward cell to route.next . 4: Forward response from route.next toroute.prev . can act as both a circuit and a via relay simultaneously for different trafﬁc streams. 1) ShorTor Protocol Stages: The ShorTor protocol pro ceeds in several stages. On an ongoing basis, relays take measurements of their roundtrip latencies with other relays (LATENCIES .UPDATE (), Protocol 2). Circuit relays use these measurements to choose candidate via relays for outgoing trafﬁc ( SHORTOR.CHOOSE VIA(), Protocol 1). They perform a “data race” to choose the fastest path ( RACE, Protocol 3). If a route with a via relay is faster than the default path, the circuit relay updates its routing table. In the steady state, the circuit relay handles trafﬁc for its circuits as usual, but directs it to the via relay rather than to the next circuit hop. Establishment: When establishing a connection for a given circuit, relays on that circuit will run LATENCIES .VIAFOR() (Protocol 2) to obtain a shortlist of potential vias. These vias are those that have recently been observed to provide the largest latency improvements over the default path between this relay and the next hop on its circuit. The circuit relay then performs a data race over each of the candidate vias ( RACE.RUN(), Protocol 3). The ﬁnish line of this race is the next relay on the relevant circuit which can report to the starting relay which CMD CircID  PrevID NextID  Payload Routing Table  CircID NextID ViaID  . . .. . .. . .Fig. 4: Via Cell and Routing Table (ﬁelds added to baseline Tor highlighted in grey): Via cells contain additional header ﬁelds with routing info. This information is used by circuit relays to populate the routing table with which via (if any) each circuit should be routed through, while via relays use it to record where to forward cells from a given circuit. of the data race cells arrived ﬁrst. We provide details on the selection of candidate via relays in Section IIIB2. Routing: While establishing a via connection, both the circuit and via relays must update their routing tables: circuit relays note which via to send cells to, while vias record which circuit relay should receive their forwarded trafﬁc. To do this, we simply introduce new ﬁelds in Tor cell headers and routing tables, described in Figure 4. These allow relays to recognize trafﬁc streams and route them to the correct next hop. SteadyState: Trafﬁc over via connections that have already been established is handled similarly to regular Tor trafﬁc. Via relays simply forward the received trafﬁc stream according to their routing table for the circuit. As via relays are not part of client circuits, they do notperform onion decryption/encryption prior to forwarding cells. Circuit relays also function as in baseline Tor except in cases where their routing table for a circuit contains a via relay. Then, the relay will alter the header on cells for these circuits as shown in Figure 4 and send the cells to the indicated via rather than to the next relay on the circuit. Periodically, relays on a circuit can repeat the data race to determine whether a given via is still the fastest option based current network status. 2) Latency Measurements: ShorTor relies on two forms of latency measurements (1) an uptodate table of probable via candidates for each relay pair (Protocol 2) and (2) the data race that determines the fastest of the candidates (Protocol 3). 3) Pairwise Latency: ShorTor requires latency measurements between Tor relays to narrow down the set of potential via relay options for a circuit. In LATENCIES .UPDATE ()(Protocol 2), each Tor relay collects this latency information as needed, distributing the involved storage, computation, and network load across the Tor network. This is in contrast to the centralized measurement methodology we use to evaluate ShorTor in Section IV which, while useful for this work, would not meet the performance needs of the live ShorTor protocol. To participate in the distributed latency measurements of Protocol 2, each relay maintains their estimated roundtrip latency to every other relay along with a list of “candidate” via relays. The candidates are computed by each relay using the roundtrip latency tables for itself and for the destination relay based on latencies provided by the destination . ShorTor uses latencies reported from the destination for security reasons: an honest destination will not recommend a dishonest via relay disproportionately often, while a dishonest destination was 5Protocol 2: L ATENCIES ALLRELAYS // Parameter: `, how many routes to keep. // Parameter: IDs of all nactive Tor relays: Tor=fid1; : : : ; idng. // State: table RTTs : ping times to each other relay. // State: table NextHop : for each relay, the top `candidate vias (id;rtt). LATENCIES .UPDATE () // Keep RTTs andNextHop tables uptodate. // Run periodically (once per day). 1:forid2Tor: 1.1: Ping relay idto estimate roundtrip time (RTT). 1.2: Set RTTs[ID]to estimated value. 1.3: Remove (;rtt)2NextHop [id]with rttRTTs[id]. 1.4: RTTs id LATENCIES .RTT S()(remote call to relay id). 1.5: forvia2Tor 1.5.1: rtt RTTs[via] +RTTs id[via]. 1.5.2: ifrttRTTs[id]then continue // no speedup. 1.5.3: Add(via;rtt)toNextHop [id], keeping fastest `entries. LATENCIES .RTT S() 1: Output RTTs . LATENCIES .VIASFOR(id) 1: Output Routes [id]. // up to `candidate via relays. already on the circuit and gains nothing by lying. The list of candidate vias is used to inform the data race which will select the fastest via from the list at the time of the race. 4) Data Race: Directly choosing via connections based on measured latencies has several potential drawbacks. First, the measured latencies are roundtrip, while network paths are directional: the fastest path from relay A to relay B might be different from the fastest path from relay B to relay A. Timestamping at the destination halfway through the round tripdoes not address this issue, as it becomes impossible to distinguish between imperfect clock synchronization and path asymmetry. Second, latencies change in realtime in response to network conditions, like congestion at relays or on internet links. Third, latencies might be inaccurate due to measurement errors or even misreporting by malicious relays; we must take care to prevent such relays from seeing disproportionate amounts of trafﬁc. As such, measured latencies alone are insufﬁcient. Instead circuit relays choose the fastest via using a “data race:” sending packets along different routes to see which arrives at the destination ﬁrst ( RACE.RUN(), Protocol 3). The starting relay simultaneously sends a copy of a data race cell to each prospective via relay, and one copy directly to the destination. The destination relay, which is the next hop on the circuit, responds only to the ﬁrst of these cells to arrive. Data races are directional —relays can identify the fastest path in each direction separately. Additionally malicious via relays cannot report lower latencies to artiﬁcially increase their odds of being selected. Data race cells are not forgeable by the via, so the via must wait to receive the cell from the source circuit relay before delivering it to the destination relay. Thus, the via cannot artiﬁcially reduce its perceived latency below the true time it takes to forward the cell.Protocol 3: R ACE CIRCUIT RELAY : // Find the fastest via relay for reaching the destination relay. // Parameter: myId , Tor ID of this relay. // State: Seen , a set of circuit IDs for which this relay has seen data race packets. RACE.RUN(vias;circ;dst) Input: Candidate vias vias=fv1; : : : ; v `g, destination relay dst Output: Fastest via vif one exists;?otherwise. 1:Create data race cell cellwith ﬁelds cmd=RACE ,prev=self, next=dst, and circ=circ. 2:forvia2vias: send celltovia. 3: Send data race cell directly to dst. 4:resp response from dst. 5: Output resp:via. // May be?if no via provides speedup. RACE.RESPOND (cell) Input: Data race cell from source relay ( sender ). 1:ifcell.circ2Seen then drop cell and return. 2: Add cell.circ toSeen . 3:ifcell.prev =sender then via ? 4:elsevia sender . 5: Send response resp tocell.prev with resp.via =via. VIARELAY : // Via relays update their routing tables to forward trafﬁc on a stream, // provided sufﬁcient resources are available to do so. // State: Routes , the routing table for each circuit. RACE.VIAFORWARD (cell) Input: Data race cell cellwith cell.cmd =RACE . 1:ifunder heavy load then drop cell and return. 2: Add cell.prev andcell.next toRoutes [cell.circ ]. 3: Forward the cell to relay cell.next . 5) Avoiding Trafﬁc Loops: We deﬁne a loop to occur when the same trafﬁc stream passes through a relay more than once. This is an issue as such relays could utilize trafﬁc correlation to identify the previously seen trafﬁc stream, thus learning a larger portion of its path through Tor than they should have been privy to. Tor only builds circuits using distinct, unrelated relays to ensure that circuits contain no loops. However, because ShorTor selects via relays separately from the circuit selection process, care must be taken to avoid loops. In order to provide the same guarantee as Tor, we require that ShorTor is applied only to circuits of length exactly three (the default in Tor) and that only a single via is used between any pair of relays. This ensures that the middle relay of a circuit is capable of observing allvias on that circuit and enforcing the same guarantees as for circuit relays. That is, in either direction of a circuit, the middle relay will not choose to use a via that is already in use for the prior hop or is related to a relay on the circuit. We elaborate on security in Section V, but note here that a malicious middle relay gains no advantage by failing to enforce this guarantee, as it already knows the identities of both the guard and exit relays and does not need to correlate trafﬁc across the via to get this information. 6) Stability: ShorTor’s distributed via selection protocol must avoid oscillations where circuit relays swap back and forth between vias. As an example, without appropriate 6precautions, a cycle could form where trafﬁc streams dropped from an overwhelmed via all divert to the same alternate via, subsequently overwhelming that via and causing the streams to revert to the original choice, and so on. We note that this situation is not prohibitive: CDNs use a similar overlay routing technique in practice, carrying substantial portions of internet trafﬁc, without such stability problems. We mitigate the risk of this situation in ShorTor through backoff and capacity parameters in the data race. We note that races are an integral component of the ShorTor protocol and are conducted to identify faster routes for trafﬁc, not for stability purposes. These backoff and capacity parameters simply ensure that races avoid oscillations between vias. Circuits never attempt to send trafﬁc through a via without ﬁrst conducting a race (though they may fall back to their direct path at any point). First, vias without available capacity will drop data race cells, preventing them from being selected at the small cost of processing a single packet. Second, upon being dropped from a via path, circuit relays will apply randomized exponential backoff and will not include that via in data races again until a set period of time has passed. The exact parameters for via capacity and backoff timing are network dependent and may evolve based on the current state of the Tor network. However, because ShorTor is an optional performance enhancement, these values can initially be set conservatively and then decreased adaptively. C. Integration with Tor While the ShorTor approach has potential applications to other networks, we designed and evaluated ShorTor’s protocol to integrate with Tor speciﬁcally. Maintaining Tor’s existing security guarantees is one main focus of this design and informed the structure of our data races and avoidance of loops. However, successful integration with Tor also requires that ShorTor be deployable . In this section, we discuss the components of ShorTor that are most relevant Tor deployment, including support for load balancing and fairness, required modiﬁcation to Tor relays, and incremental deployment. 1) Load Balancing & Fairness: Fairness to circuit trafﬁc and load balancing are both necessary to ensure that ShorTor does not inadvertently increase latency for some circuits as a consequence of reducing it on others. This could happen if via trafﬁc was allowed to consume more resources than a relay had available to spare, resulting in increased processing times or congestion at the relay. ShorTor provides both fairness and load balancing through the same mechanism: prioritizing circuit trafﬁc over via trafﬁc. Tor already recognizes different trafﬁc priorities—web browsing is prioritized over large ﬁle downloads [ 26]. We extend this to ensure that relays will preferentially schedule trafﬁc from circuit queues over via queues (Figure 5). Circuits will select vias that have lower latency than the default path, including the transit time through the via itself. This is very important as relay congestion and the associated queuing delays are a primary source of latency in Tor [ 43,44,46]. Congestion at a via will appear naturally during the data race Circuit  and Via  Queues Tor Output Buffer Input Buffer TCP TCP①②③ ④ ⑤Fig. 5: Tor relay with circuit and via trafﬁc (queuing architecture unmodiﬁed from baseline Tor). 1 Via and circuit trafﬁc are mul tiplexed on a TCP connection entering the Tor relay. 2 The TLS layer is decrypted and circuit cells are onion encrypted/decrypted. 3 Circuit and via cells are sent to their individual queues. 4 Cells are scheduled for release to the output buffer based on priority order. 5 The contents of the output buffer are encrypted using TLS, then sent to the kernel for transit over a TCP connection to the next hop. in the form of increased latency or could be indicated explicitly by dropping race packets. In addition, vias are transitory and can be dropped or swapped at will with minimal cost compared to that of circuit construction/teardown. As such, ShorTor ensures that: (1) circuit trafﬁc on a relay is never delayed by via trafﬁc and (2) load from via trafﬁc is distributed only across relays with available capacity. 2) Tor Modiﬁcations: ShorTor’s primary modiﬁcation to Tor is the introduction of data races, all other components are simple extensions of Tor’s existing mechanisms for routing and prioritizing circuits. To support ShorTor, Tor relays (though not clients) require additional protocol messages, a new data path for via trafﬁc, and state for managing via trafﬁc. The protocol requires new cell headers for data races, ping, and via trafﬁc. Speciﬁcally, via trafﬁc needs a new priority level lower than circuit trafﬁc (optionally, this level can be higher than that of bulk download trafﬁc, such as torrenting, which is currently of lower priority than circuit trafﬁc) [ 26]. Incoming via trafﬁc needs a new data path that bypasses onion encryption and decryption. Relays must also handle ping and data race trafﬁc as speciﬁed in Protocol 2 and Protocol 3. Finally, relays must hold two additional pieces of state: ﬁrst, a new ﬁeld in the routing table to indicate the via (if any) for each circuit; second, the list of candidate via nodes for each possible next hop (see Section IIIB2 for details). These modiﬁcations are relatively minor, do not touch Tor’s onion encryption layer, and represent an optional overlay on Tor’s routing. We discuss more details of required modiﬁcations in Appendix B, but note here that the high upfront cost of integrating and deploying modiﬁcations to the Tor protocol was a large factor in the ultimate design of ShorTor. This consideration motivated ShorTor’s construction as an extension to Tor’s existing architecture that operates largely separately from the baseline protocol. Furthermore, ShorTor’s modiﬁcations are conﬁgurable, triv ially backwards compatible,2and support incremental deploy ment. This allows relay operators to choose whether to support 2Relays lacking support for ShorTor simply route as usual without any vias. 7ShorTor and how much capacity to dedicate to the protocol. As shown in Section IVC 3, ShorTor can substantially reduce tail latencies even with relatively low support. This is important, as it minimizes the risk of up front development efforts being wasted due to slow deployment. 3) Incremental Deployment: Tor relays are volunteer run and notoriously slow to update [ 58]. As such, any proposal that requires support of all—or even a majority of—Tor relays is unlikely to be effective. ShorTor is incrementally deployable and improves the latency of any Tor circuits that meet the following two requirements: (1) two adjacent circuit relays support ShorTor and (2) some other relay supporting ShorTor provides a faster path between the two circuit relays. Because Tor does not select its relays with uniform probability, a small set of popular relays could meet these conditions for many circuits without support from the rest of the network. We demonstrate this concretely in Section IVC3. Security is another important consideration—incremental deployment inherently creates differences between Tor clients or relays that have adopted a modiﬁcation and those who have not. This has been an issue for client side proposals as anonymity in Tor relies on all clients behaving uniformly [12, 14,36,60,61,74,85]. ShorTor avoids this issue entirely as it is a fully serverside protocol that does not require participation from, or modify the behavior of, Tor clients in any way. So, while ShorTor is an observable modiﬁcation to the Tor protocol,3it is in no way correlated to client identity. As such, support for ShorTor cannot be used to distinguish between clients. In fact, Tor clients should nottry to preferentially select relays with support for ShorTor. While this would improve their latency, it would also differentiate them from Tor clients following Tor’s baseline circuit selection algorithm, reducing their anonymity. IV. E VALUATION We evaluate ShorTor using a dataset of approximately 400,000 latency measurements we collected from the live Tor network over the course of 42days during summer 2021. Our measurements allow us to compare the direct latency between relays to the latency when routing through an intermediate hop, as in ShorTor. Using measured latencies allows us to avoid relying on simulated or approximate data. While simulations can be a useful tool, prior work [ 75] has shown that routing protocols are best evaluated using live internet paths rather than through a simulation with, necessarily, reduced scale and complexity. We evaluate the performance of ShorTor in terms of its direct impact on the latency between pairs of Tor relays as well as its ability to reduce the latency of Tor circuits. Evaluating on circuits as well as pairs allows us to account for the relative popularity of relays and more closely model the expected reduction in latency ShorTor can provide to Tor’s end users. 3Both adversarial relays and network adversaries can likely detect when trafﬁc is routed using ShorTor as opposed to baseline Tor.A. Measurement Methodology 1) Ting: For our measurements, we adapt the Ting method of Cangialosi et al. [23] for estimating latencies between Tor relays. Ting creates a set of three circuits involving observers , which are Tor relays run solely for the purpose of obtaining latency measurements. Speciﬁcally, to obtain the latency between two Tor relays, RelayAandRelayB, we run two observer relays Obs1andObs2along with a measurement client on the same physical machine. Once each circuit is established, the measurement client “pings” itself through the circuit to estimate roundtrip latencies for the following circuits: 1)rttAB=RTT (Obs 1!RelayA!RelayB!Obs 2) 2)rttA=RTT (Obs 1!RelayA!Obs 2) 3)rttB=RTT (Obs 1!RelayB!Obs 2) With these, we estimate the roundtrip time between RelayA andRelayBasrttAB"
147,CORMEN: Coding-Aware Opportunistic Routing in Wireless Mess Network.txt,"These Network Coding improves the network operation beyond the traditional
routing or store-and-forward, by mixing of data stream within a network.
Network coding techniques explicitly minimizes the total no of transmission in
wireless network. The Coding-aware routing maximizes the coding opportunity by
finding the coding possible path for every packet in the network. Here we
propose CORMEN: a new coding-aware routing mechanism based on opportunistic
routing. In CORMEN, every node independently can take the decision whether to
code packets or not and forwarding of packets is based on the coding
opportunity available.","Network Coding [1] has emerged as promising method to  increase the network throughput and reliability. Network  Coding breaks the conventi onal store and forward ap proach of transmission in packet based network. Network  coding offers the flexibility of encoding different packets  at the intermediate node an d transmits it in a single  transmission. The receiver node  can decode it and extract  the specific packet destined for it. The basic idea of net work coding is illustrated in Fig. 1 where nodes A, B and C share the common wireless medium. Consider a scena rio where nodes A and node C have to exchange some  information. Due to the channel constraints only one node can transmit at any given time. The traditional way  of accomplishing this information exchange is as follows.  Node A sends its packet p1 to the relay node B. The node B forwards this packet to node C. Similarly, node C sends  its packet p2 to node B which in turn forwards it to node  A as shown in the Figure 1(a). This involves a total of four transmissions.    Now, consider the scenario  where network coding is  applied to reduce the number of transmissions. The node A and node C transmit packets to central node B sequentially (two transmissions). The node B, instead of directly forwarding each packet to it s destination, XOR’s the two  packets and broadcasts the resu lt as a single packet in the  shared medium as shown in the Figure 1(b). Both nodes A and C know their own packet (p1 and p2, respectively) that originated from them. They can therefore retrieve the unknown packet by XORing the known packet with broadcast packet. For example, node A on receiving                       Fig 1. (a) No Coding (b) Network Coding   (p1⊕p2) performs the operation p1 ⊕ (p1⊕p2) to obtain p2.  Similarly, node C retrieves packet p1. This entire process  takes three transmissions as opposed to four transmissions as  is the cse in traditional routing.     Opportunistic Routing differs fr om traditional routing. It  exploits the broadcast nature of wireless medium and differs the route selection after packet transmission. Each  packet holders chooses a subset of its neighboring nodes  as a potential next hope and among those which one have the best node to the destination will be selected as next  sender. The main benefits of opportunistic routing is that  it can combine multiple weak link into strong link and reduces the retransmission rate especially in wireless me dium  In this paper, we are presenting a new routing algorithm  which is based on opportunistic routing as well as network coding. The main idea of this algorithm to find a path with minimum delay to the destination which is codingaware.    2 R ELATED WORK   "
88,PARRoT: Predictive Ad-hoc Routing Fueled by Reinforcement Learning and Trajectory Knowledge.txt,"Swarms of collaborating Unmanned Aerial Vehicles (UAVs) that utilize ad-hoc
networking technologies for coordinating their actions offer the potential to
catalyze emerging research fields such as autonomous exploration of disaster
areas, demanddriven network provisioning, and near field packet delivery in
Intelligent Transportation Systems (ITSs). As these mobile robotic networks are
characterized by high grades of relative mobility, existing routing protocols
often fail to adopt their decision making to the implied network topology
dynamics. For addressing these challenges, we present Predictive Ad-hoc Routing
fueled by Reinforcement learning and Trajectory knowledge (PARRoT) as a novel
machine learning-enabled routing protocol which exploits mobility control
information for integrating knowledge about the future motion of the mobile
agents into the routing process. The performance of the proposed routing
approach is evaluated using comprehensive network simulation. In comparison to
established routing protocols, PARRoT achieves a massively higher robustness
and a significantly lower end-to-end latency.","Collaborating autonomous drones that coordinate their ac tions using Flying Adhoc Networks (FANETs) offer the potential to efﬁciently perform important disaster relief tasks — e.g., remote sensing and network provisioning — without risking the lives of human helpers [1]. A closely related emerging research ﬁeld is the integration of smallscale UA Vs into future ITSs [2] for applications such as aerial trafﬁc monitoring [3] and UA Vaided near ﬁeld delivery [4]. While the latter concept has been initially proposed for reducing the delivery time in inner cities, its inherent avoidance of direct humantohuman interaction also makes it a promising candidate for increasing the delivery safety during the COVID 19 pandemic [5]. An illustration about different applications of UA Vbased FANETs is shown in Fig. 1. For enabling these novel usecases, the provision of efﬁcient and reliable means of communication even in challenging environments is an important prerequisite. However, established Mobile Ad hoc Network (MANET) routing protocols can often barely cope with the small channel coherence time and the network topology dynamic implied by the high grade of relative mo bility. Anticipatory mobile networking [6] has been proposed for explicitly addressing the interdependency of mobility and communication by integrating context knowledge into the corresponding decision processes. This novel communications paradigm has a strong relationship to the usage of machine learning for optimizing wireless communication networks [7] Hybrid Intelligent Transportation Systems UAVEnabled Emergency ManagementMission ControlMobile Relays Exploring Swarm Aerial Sensing and WarningUAVEnabled Near Field Delivery Hazardous AreaFig. 1. Example applications of UA Venabled wireless mesh networks. which manifests in the trend of replacing complex mathemat ical models by learned representations of the corresponding phenomena [8]. Moreover, it has catalyzed the emergence of novel performance evaluation methods that are capable of replacing computationally expensive entitybased modeling with machine learningbased endtoend models [9]. In this paper, we present PARRoT as a novel reinforcement learning enabled crosslayer routing protocol which leverages appli cation layer knowledge from the mobility control routines for proactively optimizing the robustness of vehicular routing paths. The remainder of the paper is structured as follows. After discussing the related work in Sec. II, the novel PARRoT protocol is presented in Sec. III. Afterwards, an overview about the methodological aspects of the simulative performance evaluation is given in Sec. IV. Finally, detailed simulation results are provided and discussed in Sec. V. II. R ELATED WORK "
117,Adaptive Routing Between Capsules.txt,"Capsule network is the most recent exciting advancement in the deep learning
field and represents positional information by stacking features into vectors.
The dynamic routing algorithm is used in the capsule network, however, there
are some disadvantages such as the inability to stack multiple layers and a
large amount of computation. In this paper, we propose an adaptive routing
algorithm that can solve the problems mentioned above. First, the low-layer
capsules adaptively adjust their direction and length in the routing algorithm
and removing the influence of the coupling coefficient on the gradient
propagation, so that the network can work when stacked in multiple layers.
Then, the iterative process of routing is simplified to reduce the amount of
computation and we introduce the gradient coefficient $\lambda$. Further, we
tested the performance of our proposed adaptive routing algorithm on CIFAR10,
Fashion-MNIST, SVHN and MNIST, while achieving better results than the dynamic
routing algorithm.","In last few years, deep learning has made breakthroughs in many computer vision tasks, especially convolutional neural networks leading to stateoftheart performance. In the convolutional neural network, neurons are scalar and un able to learn the complex relationship between neurons. But in the human brain, neurons usually work together rather than work alone. To overcome this shortcoming of con volutional neural networks, Hitton proposed the concept of “capsule”[4] that a combination of neurons that stack fea tures (neurons) of the feature map into vectors (capsules). In the capsule network, the model not only considers the at tributes of the feature when training, but also takes account of the relationship between the features. The proposed dy namic routing algorithm enables the idea of “capsule” to be implemented [15]. After the neurons are stacked into vectors(capsules), the coupling coefﬁcient between the low layer capsule and the highlayer capsule is learned througha dynamic routing algorithm. The relationship between the partial features and the whole will be obtained. Improving the performance of neural networks is a major direction of deep learning research. A common method to improve the performance of deep neural net works is to increase the depth of the network. For exam ple, VGG[16], GoogLeNet[17], and ResNet[3] improves the network depth by proposed effective solutions and continuously improves the accuracy of classiﬁcation of ImageNet[1]. In capsule networks, in order to improve the performance of the capsule network can be achieved by in creasing the number of capsule layers. Rajasegaran et al. [14] have tried and achieved impressive results in this re search direction. However, the dynamic routing algorithm proposed by Sabour et al. [15] cannot simply increase the number of capsule layers in the capsule network. Dynamic routing algorithm is the method used to learn the relationship between partial features and the whole in a capsule network, but it shows some shortcomings. After several iterations of training, the coupling coefﬁcient cijof the capsule network shows a large sparsity, indicating that only a small number of lowlayer capsules are useful for highlayer capsules. Most coupling coefﬁcient computa tions are futile, which increases the amount of invalid com putation during gradient backpropagation. The sparsity of the coupling coefﬁcients in the dynamic routing algorithm makes most of the gradient ﬂow propagating between the capsule layers very small. If the capsule layer is simply stacked, the gradient in the front layer of the model will be come small, so that the model not working. If the interfer ence of the coupling coefﬁcient can be removed during the routing process, the stacked layers can continue to work. To this end, in this paper, we proposed adaptive routing that a new routing algorithm for capsule networks. Unlike the dynamic routing algorithm, which updates the coupling coefﬁcient at the end of each iteration, our proposed algo rithm only updates the lowlayer capsule itself at the end of each iteration, which makes the lowlayer capsules more ”similar” to the highlayer capsules. Since there is no cou pling coefﬁcient cij, the propagation of the gradient ﬂow 1arXiv:1911.08119v1  [cs.LG]  19 Nov 2019in the capsule network is not suppressed during the rout ing process, so the gradient can be better transmitted to the layer in front of the model. More speciﬁcally, we made the following contributions in this article: 1. The motivation proposed by the adaptive routing algo rithm and explains why the dynamic routing algorithm causes the gradient vanishing and the capsule network to not work when stacking multiple layers. 2. The adaptive routing algorithm is proposed to over come the shortcoming that the dynamic routing algo rithm will cause the gradient vanishing when stacking multiple layers. The adaptive routing algorithm can stack multiple layers and improve the performance of the capsule network. 3. The iterative process of adaptive routing algorithms can be simpliﬁed, and the adaptive routing algorithm without routing process is used. The introduced hyper parameteris used instead of the iteration number, which reduces the amount of computation and ampli fying the gradient. The rest of the paper is organized as follows: In Sec tion 2, we discuss the related work on Capsule Networks, Section 3 describes the motivation and adaptive routing al gorithm, Section 4 shows our experimental results. Finally, Section 5 concludes the paper. 2. Related Work "
42,A One-Hop Information Based Geographic Routing Protocol for Delay Tolerant MANETs.txt,"Delay and Disruption Tolerant Networks (DTNs) may lack continuous network
connectivity. Routing in DTNs is thus a challenge since it must handle network
partitioning, long delays, and dynamic topology. Meanwhile, routing protocols
of the traditional Mobile Ad hoc NETworks (MANETs) cannot work well due to the
failure of its assumption that most network connections are available. In this
article, a geographic routing protocol is proposed for MANETs in delay tolerant
situations, by using no more than one-hop information. A utility function is
designed for implementing the under-controlled replication strategy. To reduce
the overheads caused by message flooding, we employ a criterion so as to
evaluate the degree of message redundancy. Consequently a message redundancy
coping mechanism is added to our routing protocol. Extensive simulations have
been conducted and the results show that when node moving speed is relatively
low, our routing protocol outperforms the other schemes such as Epidemic, Spray
and Wait, FirstContact in delivery ratio and average hop count, while
introducing an acceptable overhead ratio into the network.","Delay and Disruption Tolerant Networks (DTNs) has grown from relatively obscure research activities to a healthy re search topic attracting both network designers and application developers[1], due to that the communication model of the Internet is based on some inherent networking assumptions, e.g., the existence of a continuous endtoend path between two nodes, the relatively short roundtrip delays, the symmetric data rates and the low error rates[2]. However, in DTNs these assumptions usually fail, which leads the fact that the TCP/IP protocol does not work. Hence, many application protocols designed for the Internet architecture cannot operate well in the DTN scenarios such as Interplanetary Internet (IPN). Besides, another major contributor to this trend is the observation that quite a few terrestrial networks exhibit delaytolerant properties, albeit of different nature: from sparse mobile ad hoc to sensor networks to mobile Internet access, it is found that delay tolerance also exists as an important element to describe communication behavior and to design protocols suitable for operation in the corresponding challenged net working environment[3]. Though there are many research achievements in Mobile Adhoc NETworks (MANETs), most of them assumed that the endtoend connection usually exists in the network. Besides, the research of communication has been extended into areas previously beyond the grasp of generic networkingarchitectures in the past few years. These networks have a variety of applications in situations that include crisis envi ronments like emergency response and military battleﬁelds[4], vehicular communication[5], mobile sensor networks[6] and noninteractive Internet access in rural areas[7]. From the users perspective, not all the applications need a realtime response and thus such kind of requirements under the overlay network ing should be relaxed with delay tolerance, so that the concept of MANETs could get much closer to reality. And such kind of MANETs applications include email service, news disseminating service and local temperature measure etc. For these kind of application requests, there is an urgent need for designing a new networking architecture to converge all kinds of heterogeneous networks. All these applications mentioned above address the importance of successful delivery instead of realtime response, and we call this characteristic delay tolerance. Kevin fall et. al in [8] present an early thinking about the subject and speciﬁes the characteristics of networking in this kind of challenged networks. The DTN architecture is deﬁned in RFC 4838[9]. and the Bundle Protocol (BP) is deﬁned in RFC 5050[10], which runs between the application layer and the network layer. Most research achievements on DTNs focus on the design of routing protocols. Though there are something common of routing between Internet and DTNs, routing in DTNs still faces many challenges. Nodes in Mobile Delay Tolerant Networks (MDTNs) are more than ﬁxed hosts and routers. Furthermore, there are scarcely no predeployed infrastructures or assistant controlled nodes in delay tolerant MANETs, which means that there is no routerlike device, and thus routing will be executed by all mobile nodes in the network cooperating with each other. In other words, each node plays a role of router and hence acts in a storecarryforward manner. Though that not relying on infrastructures or controlled nodes would highly increase the difﬁculty for routing, there are many reasons for paying more attention to the networks that own the ad hoc properties. For example, for communication in military battleﬁelds, a node statistically has a high possibility to be destroyed, which may lead to intermittent connections in the whole network. Furthermore, the mobility pattern will change according to the tactical plan. Thus nodes need to spontaneously form the network and then server as routers in order to deliver the message. For vehicular to communicate, although we can predeploy some access points along the road or somewhere else at regular intervals, it is still considered to be much more expensive than assembling the wirelessarXiv:1602.08461v2  [cs.NI]  21 Jun 20172 device on vehicle itself and relying on their mobility to communication. And this has already been a hot research topic as a new branch of MANETs and named as Vehicular Ad hoc NETworks (V ANETs). Some proposed routing protocols rely on acquiring more than onehop information or the assumption of the availability of global topology knowledge. Some others employ various kinds of message distribution protocols so as to obtain the needed information for routing. However, most of them are unrealistic to practically implement due to that partitioning, long delays, and dynamic topology may cause the failure of transmitting the needed routing information. Taking a step back, although those information distribution mechanisms worked well, the collected information would be inaccurate or expired thus losing their realtime value for routing. In this article, we intend to focus on investigating the mobile ad hoc networks with delay tolerance. Our work mainly differs from other achievements in the following aspects: The routing scheme is based on no more than one hop information. There is no need to broadcast the link status to the whole network or to record any history informations for each node. Most of the current research achievements devote to utilize a metric evaluating the relationship between the current node and the destination node (i.e. destination aware metric). However, this implicitly requires that each node has the knowledge of all its prospective destination nodes and thus is of relatively low feasibility in DTNs. In this paper, we try to provide a kind of fresh thinking of the routing problem in DTNs, that let each node to ensure uniform geographical spread of the message copies. It is necessary to cope with the overloads in the network due to that the multicopy strategy usually introduces high message redundancy in the networks. As far as our information goes, this is the ﬁrst paper to give the concept of message redundancy degree based on the message coverage in the network. Our contributions are listed as following: A distributed geographic routing scheme is proposed based on no more than onehop information. In details, a node only need its local onehop neighbor(s) position information to make the nexthop choice. The only as sumption we made is that every node in the network is equipped with a local positioning device, thus having the ability to obtain its neighbors locations. This kind of geographic routing is easy to implement in the real network, and would not trigger abundant calculations, so that the scarce energy resource could be saved. A simple criterion named as the Message Redundancy Degree (MRD) is proposed for measuring the message redundancy. In this paper the accurate deﬁnition of 2 order MRD is given, and the concept of MRD can be extended to korder (k > 2). We leave this to be our future work. A mechanism to cope with the message redundancy, by which we can reduce the size of useless message overlapping area during the whole routing process. Weset a threshold value of 2order MRD, for that when two nodes meet with a MRD value larger than the margin, the redundancy coping mechanism will be triggered for the purpose of saving the constrained buffer resource. The routing performance is evaluated and compared with other wellknown routing schemes by extensive simula tions. The simulation results show that when node moving speed is relatively low, our routing protocol outperforms the other schemes such as Epidemic, Spray and Wait, FirstContact in the aspect of delivery ratio and average hop count, while introducing an acceptable overhead ratio into the network. The paper is organized as follows. In Section II we report on previous works in the ﬁeld of DTNs. In Section III we introduce the preliminary and motivation of the routing strategy. In section IV we put forward key problems in routing design. Section V is devoted to mechanism routing design techniques. In section VI we show the simulation results. Section VII eventually concludes this paper. II. R ELATED WORK "
188,"Evaluating Feasibility of Using Wireless Sensor Networks in a Coffee Crop Through Simulation of AODV, AOMDV, DSDV and Their Variants with 802.15.4 Mac Protocol.txt","A Wireless Sensor Networks is a network formed with sensors that have
characteristics to sensor an area to extract a specific metric, depending of
the application. We would like to analyse the feasibility to use sensors in a
coffee crop. In this work we are evaluating routing protocols using real
dimensions and characteristics of a coffee crop. We evaluate, through
simulation, AODV, DSDV and AOMDV and two variants known in this work as AODVMOD
and AOMDVMOD with 802.15.4 MAC Protocol. For this comparison, we defined three
performance metrics: Packet Delivery Ratio (PDR), End -to-End Delay and Average
Energy Consumption. Simulation results show that AOMDVMOD overall, outperforms
others routing protocols evaluated, showing that is possible to use WSN in a
real coffee crop environment.","In the last years several technologies emerged  with the objective to assist human  being. One  of  these emerging technologies is known as Wireless Sensor Networks (WSN). The use of  new  ""smart"" wireless equipments to sensing and to communicate with each other open new   perspectives. In this kind of network, sensors can sensing, measure and  gather information  from  the environment, consequently sending such data to the user.   Wireless sensor networks is an area that several research groups around the world have   concentrated their efforts to solve problems in all communication layers, including  physical  layer communication up to the development of new applications. Wireless sensor networks   consist  of many smart sensor nodes, where these sensors are equipped with one or more  sensors,  a processor, memory, a power supply and a radio wireless channe l to communicate  with each  other [1].  Wireless sensor networks can be considered as a special type of Ad Hoc  Networks . They can be  static, where the nodes do not have any movement , or mobile, known also in the literature as  Mobile Ad Hoc Networks (MANET) . Ad Hoc Networks is d ifferent from infrastructure  networks, where such architecture  has a base station coordinating the communication of the  nodes.  Usually, wireless sensor  networks has not centralized control and predefined  communication link, transferring  signals to the exterior world. All nodes are capable to act as  source or sink node at the same  time. One of the drawbacks of the wireless sensor networks is  due to the fact of the nodes  have limited processing power because of their tiny physical size, which limits the capacity  of processor and size of battery. When collectively works together,  they have an ability to  collect information of the physical environment. In the Figure 1 is  showed an example of  a MANET with infrastructure and infrastructureless or pure ad hoc  manner [2].   One of the main challenges to be solved in Wireless sensor networks is routing  data of the  source node up to destiny node. Several factors can influence the  design of the routing protocols  such as: Node Deployment, Power Consump tion, Data Delivery Models, Node/link  Heterogeneity, Fault Tolerance, Scalability, Network Dynamics, Transmission Media,  Connectivity, Operating Environment, Data Aggregation/Fusion, Quality of Service  (QoS), Production Costs, Data Latency and Overhead and  Autonomy . Hence, is possible to  see that routing protocols are needed to  cope  with the nature of wireless sensor networks and  that proper routing in ad hoc networks  is the challenge to the designers [3, 4].          Figure 1.  MANET with infrastructure (left side) and infrastructureless (right side)  [2]    This work objective to evaluate the feasibility of using Wireless Sensor Networks in a  coffee  crop through simulations using three classics routing protocols for ad hoc networks  and two  little variants :    Proactive routing protocol named DSDV (Destination Sequenced Distance Vector  Routing Algorithm)  [5];    Reactive routing protocol knows as AODV (Ad Hoc On Demand Distance Vector  Routing)  [6]   Routing protocol based in multiple paths called as AOMDV  (Ad hoc On demand  Multi path Distance Vector Routing) [7 ];    A modification of AOMDV protocol called in this work as AOMDVMOD. The  modification consists to increase HELLO messages dissemination interval to 5 seconds .  Default value used by the protocol is 1 second ;    AOD V named AODVMOD.  The modification consists to increase HELLO messages  dissemination interval to 5 seconds.  Default value used by the protocol is 1 second.   Furthermore, these routing protocols are simulated using IEEE 802.15.4 as the  underlying  MAC  layer . So, the main contribution s of this paper is : (1) evaluate routing protocols for ad hoc   networks using realistic dimen sions used in a coffee crop and (2) sensors located in the  scenario s evaluated considering characteristics used in a real coffee crop  such as spacing  between coffee seed s.  The remaining of the paper is organized as follows: In the Section 2 is described about the  routing protocols used in this work . Section 3 shows the related works . Section 4  describes  about the performance evaluation describing scenarios , communications patterns, metrics and  more.  In the Section 5 the results are analys ed and discussed and the paper in concluded  in the  Section 6.    2. ROUTING PROTOCOLS BACKGROUND   The ad hoc networks routing protocols have as main objec tive to find better route between a  source destiny node by the information existing in the routing tables of the nodes . In the WSN,  the movement of the nodes is not a challenging considering the type of application to deploy,  and, commonly, when movement i s used, the nodes have lower speed than other kind of ad hoc  networks (e.g. VANETs). One of the major restrictions to be considered in the WSN is the  battery of the nodes. Sensor nodes have limited available power. So, energy efficient routing  protocols are truly crucial for life of WSN. But energy consumption is not the only factor to be  analysed. Considering that in a real environment, such as coffee crop (our objective to  deployment WSN), user needs information more fast possible (low delay) and with reliability   (high packet delivery rate). So, is possible to see that other metrics are very important as well.   Routing protocols in WSN can be classified depending o f the characteristics such as [3 ]:   Route Establishment    Network Structure    Protocol Operation    Initiator of Communicator     The Figure 2 gives and overview of the routing taxonomy.                                           Figure 2.  Taxonomy of Wireless Routing Protocol   Considering our work, we will focus in the Route Establishment classification. More details  about the protocols evaluated inserted in such classification will be describe later.      WSN Routing Protocol   Route  Establishment   Network  Structure   Protocol  Operation   Initiator of  Communicator   Proactive   Reactive   Hybrid   Flat  Hierarchical   Location   Negotiation   Query   Multipath   QoS  Coherent   Source  Initiator   Destination  Initiator  2.1 ROUTE ESTABLISHMENT BASED ROUTING PROTOCOL  CLASSIFICATION   Different strategies can be used to route packets among source destiny node in the network.   Routing protocols must be developed aiming maximize lifetime network with low delay and  high packet delivery ratio.  Basically, three different route establishment strategies can be used:    Proactive or Table Driven Routing : In this approach when the routing protocol begin s  to work, nodes try to populate its routing tables with possible destination nodes. This  kind of network is not suitable for larger networks, as they need to maintain node  entries for each and every node in the routing table. This leads to more overhead in the   routing table leading to consum ption of more bandwidth Classic examples of routing  protocols categorized as proactive or table driven routing are: OLSR  [8] and DSDV.      Reactive or On Demand Routing : This type of routing protocols c onstruct routes only  when is necessary to send information. In a situation where a node wants to  communicate to another node this kind of protocol searches  for the route in an on  demand manner and establishes the connection in order to transmit and receive the  packet.  A technique usually used by reactive routing protocols to route discovery is  using flooding route request packets throughout the network.  We c an cite as routing  protocols in this category: AODV, DSR  [9].     Hybrid Routing : In this case  routing protocols use both reactive and proactive  mechanisms to fill routing tables (create or update new routes). Examples of hybrid  routing protocols are : ZRP [10]    2.1.1  DESTINATION SEQUENCE DISTANCE VECTOR (DSDV)   Each node in the network maintains a routing table for the transmission of the packets. Each   node has  a list of possible destinations in the network and the number of hops necessary to reach  each destination in the routing table.  With the objective to maintain the information in the  routing tables always updated each station transmits a HELLO message in a  broadcast manner  periodically.  Each new route will contain the following information  as showed in Table 1 .  Table 1: Fields of Routing Table using DSD V [11]  DESTINATIO N NEXT HOP HOPS/METRIC  SEQ. NO. INSTALL  TIME STABLE  DATA    The newest route is used (identified with the highest sequence number).  With this information is  possible to identify the old routes from the new ones, thereby avoiding the formation of loops.     2.1.2  ADHOC ONDEMAND DISTANCE VECTOR  (AODV)   AODV (Ad hoc On demand Distance Vector) is a loop free routing protocol for ad hoc  networks  based on vector distance algorithm, as DSDV . It is designed to be self starting in an  environment of mobile nodes, withstanding a variety of network behaviours such as node  mobility, link failures and pac ket losses .  The AODV protocol is based in topology information  that works in a reactive mode.  In other  words, when a  source node wants to send data to a destination node,  a route discovery process is  started. In this process, the  source node broadcasts a R OUTE REQUEST (RREQ)  packet to all  your neighbours . Neighbours  nodes which do  not know an active route to destination node, forward  the packet to their neighbors until an available route  is found or the maximum number  of hops is reached.  When an intermediat e node knows an active route to  the requested  destination node, it sends back a ROUTE  REPLY (RREP) packet to the source node in unicast   mode, enabling to the node create s the route among the  source and destination nodes. In case of  a link failure, the neighbourhood  nodes are notified by route error messages (RERR) on both  sides of link.     2.1.3  ADHOC ONDEMAND MULTIPATH DISTANCE VECTOR (AOMDV)   The main characteristic in AOMDV is computing multiple loop free paths per route discovery.  Due to fact to create multiple redundant paths , the protocol switches routes to a different path  when an earlier path fails.  Thus a new route discovery is avoided. Route discovery process is  initiated only when all paths to a node destination fail. For efficiency, only link dis joint paths  are computed so that the paths fail independently of each other. Note that link disjoint paths are  sufficient for our purpose, as we use multipath routing for reducing routing overheads rather  than for load balancing . The  multi path routing  pr otocol  discovers  multiple  paths  during  the   single route discovery process. These multiple paths can be used for load spreading or as  backup routes when the primary route fails  [12].   Different of AODV routing protocol, AOMDV do not discard duplicate RREQs. AOMDV look  for an opportunity of getting an alternate route with each duplicate RREQ. In AOMDV, RREQ   propagation from the  source towards the destination establishes multiple reverse paths both at  intermediate nodes as well as the destination. Multiple RREPs traverse these reverse paths back,  to form multiple forward paths to the destination at the source and i ntermediate nodes. AOMDV   also provides intermediate nodes with alternate pat hs as they are  found to be useful in reducing  route discovery frequency. The core of the AOMDV protocol lies in ensuring that multiple   paths  discovered are loop free and disjoint; and in efficiently finding such paths using a flood  based route discovery. A OMDV route update rules, applied locally at each node, play a key role  in maintaining loop freedom and disjoint ness properties  [13].    3. RELATED WORKS   "
424,Performance Evaluation and Optimization of B.A.T.M.A.N. V Routing for Aerial and Ground-based Mobile Ad-hoc Networks.txt,"The provision of reliable and efficient end-to-end communication within
ground- and air-based mobile mesh networks is a major challenge for routing
protocols due to the mobility-related dynamics of the channel properties and
the resulting mesh network topology. In this paper, we evaluate the performance
of the novel Better Approach To Mobile Adhoc Networking (B.A.T.M.A.N.) V
routing protocol for vehicular mesh networks and propose a mobility-predictive
extension that explicitly addresses highly dynamic communication networks. In
order to enable large-scale simulative analysis, we present an open source
simulation model, which is validated by field experiments. Within a
comprehensive evaluation campaign in Vehicle-to-Everything (V2X) and Unmanned
Aerial Vehicle (UAV) scenarios, it is shown that the predictive B.A.T.M.A.N.
V-based approach is significantly better suited for maintaining reliable
connectivity within highly mobile mesh networks than established routing
protocols.","The usage of multihop communication within meshbased Mobile Adhoc Networks (MANETs) enables signiﬁcant range extensions as well as path redundancy, which is exploited in vehicular platooning, remote sensing of disaster areas using UA Vs and adhoc network provisioning (c.f. Fig. 1). Due to the potentially high relative mobility of the different nodes and the short lifetime of routing paths, which results in a highly dynamic network topology, routing is immanently challenging in these networks. A promising solution approach that explicitly addresses these challenges, is the usage of anticipatory communication [1], [2], which aims to utilize the existing communication network in a more efﬁcient way by an increased situation awareness. Crosslayer principles allow the integration of the mobility characteristics of the vehicles themselves into the routing decisions. In this paper, we extend previous work on mobilityaware vehicular mesh routing [3] based on the B.A.T.M.A.N. routing protocol [4] in order to leverage new features of the ﬁfth protocol version. Unlike most established routing protocols, which handle routing on the network layer, B.A.T.M.A.N. operates on the Medium Access Control (MAC) layer since version IV [5]. Moreover, version V introduces major changes and novelties in the routing behavior and its metrics. In the remainder of this paper, the following contributions to anticipatory mesh networking are provided:Presentation of a novel open source simulation model of B.A.T.M.A.N. V for Objective Modular Network Testbed in C++ (OMNeT++) [6] and its INET /INETMANET framework, which is close to the Linux kernel imple mentation of the protocol. Simulation model validation using ﬁeld measurements and empirical channel modeling in Sec. V. Optimization and extension of B.A.T.M.A.N. V for high mobility scenarios using mobility prediction in Sec. III. Performance comparison of B.A.T.M.A.N. V and the proposed experimental extensions with established pro tocols in aerial and groundbased simulation scenarios in Sec. VI. All raw results are provided in an open access way. II. R ELATED WORK "
293,An optimum energy consumption hybrid algorithm for xln strategic design in wsns.txt,"In this paper, X-Layer protocol is originated which executes mobility error
prediction (MEP) algorithm to calculate the remaining energy level of each
node. This X-Layer protocol structure employs the mobility aware protocol that
senses the mobility concerned to each node with the utilization of Ad-hoc
On-Demand Distance Vector (AODV), which shares the information or data specific
to the distance among individual nodes. With the help of this theory, the
neighbour list will be updated only to those nodes which are mobile resulting
in less energy consumption when compared to all (static/mobile) other nodes in
the network. Apart from the MEP algorithm, clustering head (CH) election
algorithm has also been specified to identify the relevant clusters whether
they exists within the network region or not. Also clustering multi-hop routing
(CMHR) algorithm was implemented in which the node can identify the cluster to
which it belongs depending upon the distance from each cluster surrounding the
node. Finally comprising the AODV routing protocol with the Two-Ray Ground
method, we implement X-Layer protocol structure by considering MAC protocol in
accordance to IEEE 802.15.4 to obtain the best results in energy consumption
and also by reducing the energy wastage with respect to each node. The
effective results had been illustrated through Network Simulator-II platform.","  IEEE 802.15.4 standard has its requirements in Medi um Access Layer as well as in Physical  Layer. It upholds the network topologies based on m esh, cluster, tree & star. In a star topology,  the nodes cannot communicate directly without passi ng through the data collector node through  peertopeer topology concept, the node itself comm unicates with irrespective of passing through  the sink node which is implemented to multiple netw ork strategies. This standard operates on two  different nodes: One is Beacon mode that is Slotted  CSMA/CA and the other is NonBeacon  Mode which is NonSlotted CSMA/CA. Mainly they are dual things that are necessarily to be  determined. Out of which, the primary is how to sta bilize the energy of the nodes & the second is  how to acquire the energy efficiency within the LR WANs. Universally, all the protocols had to  oversee the energy related issues as mentioned belo w:   International Journal of Computer Networks & Commun ications (IJCNC) Vol.11, No.4, July 2019  62  1.  Idle Listening : This state resembles that no transmission is done  throughout the simulation  process.  2.  Over Hearing : This state resembles that transceiver is actively  listening to the message  without worthwhile.  3.  Collisions : This state occurs when multiple transmissions are  done in such a way that the  acknowledgment of any one of the message fails.  4.  Over Emitting : This state resembles the packets that are transmi tted when the destination  node is not prepared to accept them.  5.  Signaling Overhead : This state resembles to the energy based on ackno wledgments &  synchronization of the packets.    The recent advancements in the field with concern t o the above aspects have observed a rapid  growth in MEMS, low power consumption, huge digital  integrated circuits, small scale energy  industries, and radio technologies with less power,  cost effective and multifunctionality WSNs,  which can analyze the changes, occurred in the envi ronment [30]. These devices are integrated  with a mini size battery, a mini microprocessor, an  aerial, and an array of transducers which  converts one form of energy to another, which is us ed to gain the information that responds to the  changes occurred, in the environment of the sensor node [7]. The necessity of these type of device  in the WSNs has motivated the emerging research in the recent decades relevant to the potential  of association among sensors in data collection and  operation, which leads to the era of WSNs  [2223].    The utmost originating prototype IEEE 802.15.4 whic h has been employed along with the X Layer model is a standard arising intelligence medi um access control protocol which is widely  opted for LowRate WAN's also it is convenient for mobile sensor networks localization [1]. It is  accomplished as a medium of intercommunication link ing (MAC) & (PHY) layer [37]. MAC &  PHY routing in a zigzag style along with which it is a structure for secured & data assembling of  efficient energy. AODV performs better as compared to DSR (Dynamic Source Routing) protocol  with respect to few parameters like high packet del ivery ratio, high system throughput, minimum  energy consumption as it (AODV) is faster at effici ent data circulation [18]. TwoRay Ground  method is taken into consideration in this paper as  a propagation model in contrast with the  shadowing method as it is having genuine performanc e in some of the parameters like energy  consumption, endtoend delay & system throughput [ 1920].    Table 1  Different Approaches & Methods of IEEE 802.15.4 bas ed MAC Layer    Types Definition  Parameter  Tuning  Method Tuning of superframe parameters to enhance the per formance without  rectifying the level & specification of IEEE 802.15 .4. It is entirely dependent  upon the application & its performance is based upo n its parameter’s value.  CrossLayer  Method Provides key solutions depending upon the influence  of various layers within  the protocol, but leads in enhancement in latency.  802.11  Method Relocates the key solutions that had been projected  by it to 802.15.4  environment. It has a capability of reutilizing th e experimented technology  where power consumption has no priority in this met hod.  Priority  Method Improves the Quality of Service assistance so that all the nodes along with its  traffic is been given the priority where power cons umption has no importance.    Duty Cycle  Method Manages the active frames to obtain maximum power p reservation with  minimum manipulations. International Journal of Computer Networks & Commun ications (IJCNC) Vol.11, No.4, July 2019  63  BackOff  Method Provides dynamic assistance to various topologies w hich requires no hardware  upgradation & may lead to maximum manipulation of the standard.  QoS Method  Better assistance for applications based on timese nsitivity.  Hidden  Term  Resolution Drastic collisions are being minimized with less pa cket retransmissions.    2.  RELATED WORK   "
154,Deep-learning based Tools for Automated Protocol Definition of Advanced Diagnostic Imaging Exams.txt,"Purpose: This study evaluates the effectiveness and impact of automated
order-based protocol assignment for magnetic resonance imaging (MRI) exams
using natural language processing (NLP) and deep learning (DL).
  Methods: NLP tools were applied to retrospectively process orders from over
116,000 MRI exams with 200 unique sub-specialized protocols (""Local"" protocol
class). Separate DL models were trained on 70\% of the processed data for
""Local"" protocols as well as 93 American College of Radiology (""ACR"") protocols
and 48 ""General"" protocols. The DL Models were assessed in an ""auto-protocoling
(AP)"" inference mode which returns the top recommendation and in a ""clinical
decision support (CDS)"" inference mode which returns up to 10 protocols for
radiologist review. The accuracy of each protocol recommendation was computed
and analyzed based on the difference between the normalized output score of the
corresponding neural net for the top two recommendations.
  Results: The top predicted protocol in AP mode was correct for 82.8%, 73.8%,
and 69.3% of the test cases for ""General"", ""ACR"", and ""Local"" protocol classes,
respectively. Higher levels of accuracy over 96% were obtained for all protocol
classes in CDS mode. However, at current validation performance levels, the
proposed models offer modest, positive, financial impact on large-scale imaging
networks.
  Conclusions: DL-based protocol automation is feasible and can be tuned to
route substantial fractions of exams for auto-protocoling, with higher accuracy
with more general protocols. Economic analyses of the tested algorithms
indicate that improved algorithm performance is required to yield a practical
exam auto-protocoling tool for sub-specialized imaging exams.","Health care expenditures in the United States (US) rep resent more than 19% of its gross domestic product. This is approximately twice that of other highincome countries, with a similar outcome in life expectancy [1, 2, 3]. Ad vanced imaging, including computed tomography (CT) and magnetic resonance imaging (MRI), strongly contributes to health care costs. Notably, the number of MRI exams per 1,000residentsintheUShasdoubledoverthepasttwodecades[4]. Theimbalancebetweenimagingcostsanddiagnosticben eﬁts is rooted in the inappropriate utilization of imaging re sources. Ineﬃciencies have motivated reforms in imaging utilization which support evidencebased imaging [5] and utilizeclinicaldecisionsupport(CDS)systems[6,7]. Com puterized physician order entry [8, 9] software tools have provided evidence supporting improved process outcomes. These outcomes include both guideline adherence [10] and reduced imaging overuse [11]. ThoughCDSalgorithmsoﬀerappropriate“general”imag ing protocols (e.g, contrastenhanced imaging in malignant disease), they do not currently model more complex, ad vancedsubspecializedimagingprotocolsthatrequireexpert radiologist intervention. In a valueoriented radiology model, protocol selection, anoninterpretivetask,takesplacebeforeimageacquisition, diagnostic interpretation, and report completion [12]. Pro tocol selection takes up to 6% of a radiologist’s time and is a frequent source of interruptions [13]. It is also labor intensive,requiringthechoiceofimagingmodalityandplanes, contrast agent, acquisition parameters, acquired series, and anatomical area covered. Such complexity causes protocol variation [14] due to individual radiologist practices and preferences. This vari ationleadstodecreasedimagingappropriateness,increased interpretivetime,andlessoptimaloutcomes. Thishasmoti vated the development of tools to standardize protocol con struction [15]. Standardization aligns with the principles of Imaging 3.0TM: appropriateness, quality, safety, eﬃciency, and patient experience [16]. Radiologic technologists rarely change protocols from an ordered advanced imaging exam. Furthermore, the over all change rate for radiologists and residents for the most commonlyorderedCTandMRIstudiesissimilarlyverylow. These factors have led experts to conclude that order entry protocol selection is amenable for automation [17]. Machine learning and deep learning (DL) [18] can be leveraged with information from orders and patients’ elec tronic medical records (EMRs)to train artiﬁcial intelligence (AI)modelstopredictprotocolsfromneworders. Robustly autoprotocoling subspecialized exams could a) reduce the expert eﬀort in protocoling exams, b) enable workﬂows for patient selfscheduling advanced exams, c) simplify the use ofsubspecializedprotocols,d)reduceerrorarisingfromin terruptingradiologistinterpretiveworkﬂows,ande)expand time for radiologists to perform more valuable tasks. The growth of AI applications in interpretive and non iterpretiveradiologyhasbeenextensivelyreviewed[19,20]. Figure1: Thefullyconnectedneuralnetworkutilizedinthis study for MRI order protocoling. A onehot encoded input vector of indication and diagnosis words is input, and vec tor scoring each protocol is output. Dropout and batch nor malizationlayersareincludedtoimproveperformancewith limited training data. Related to this work, AIDLbased models have been em ployedforprotocolassignmentandqualityimprovement,demon stratingpromisingresultsinneuroradiology[21,22]andmus culoskeletalMRI[23,24]. Recently,Karla etal.[25]demon stratedanAIaugmentedworkﬂowtoautomateCTandMRI protocoling for 69% of orders in a moderately sized sam plefromahomogeneousclinicalenvironment. Theyshowed >95%concordancewithradiologistsinthosecases,andpro vide 92% accuracy in topthree protocol suggestion for the remaining cases. Here, a similar exam protocoling technique is presented and analyzed. This algorithm uses physicianprovided indi cations for imaging and associated a prioridiagnoses noted in the EMR. The present work holds some key distinctions fromthestudypresentedbyKarlaetal[25]. First,theappli cationinthisworkisbothmorespecializedandtargetedata diversepatientpopulation. Whilepreviousworkconsidered both CT and MRI, the present work exclusively considers MRI examinations from a data bank that is over six times largerthanthecombinedMRIandCTdatasetusedbyKarla etal.[25]. Additionally,theconsideredpatientpopulationis extractedfromanacademichospitalnetworkservingamore diverseurbanandsuburbanpopulationcomparedtothepre viouslystudiedsamplefromaVeteransAdministrationhos pital. Finally, this work provides an economic analysis of thetechnologytoillustratetheimpactofimplementingsuch technology in a large imaging network. 2. METHODS "
209,Optimal bandwidth-aware VM allocation for Infrastructure-as-a-Service.txt,"Infrastructure-as-a-Service (IaaS) providers need to offer richer services to
be competitive while optimizing their resource usage to keep costs down. Richer
service offerings include new resource request models involving bandwidth
guarantees between virtual machines (VMs). Thus we consider the following
problem: given a VM request graph (where nodes are VMs and edges represent
virtual network connectivity between the VMs) and a real data center topology,
find an allocation of VMs to servers that satisfies the bandwidth guarantees
for every virtual network edge---which maps to a path in the physical
network---and minimizes congestion of the network.
  Previous work has shown that for arbitrary networks and requests, finding the
optimal embedding satisfying bandwidth requests is $\mathcal{NP}$-hard.
However, in most data center architectures, the routing protocols employed are
based on a spanning tree of the physical network. In this paper, we prove that
the problem remains $\mathcal{NP}$-hard even when the physical network topology
is restricted to be a tree, and the request graph topology is also restricted.
We also present a dynamic programming algorithm for computing the optimal
embedding in a tree network which runs in time $O(3^kn)$, where $n$ is the
number of nodes in the physical topology and $k$ is the size of the request
graph, which is well suited for practical requests which have small $k$. Such
requests form a large class of web-service and enterprise workloads. Also, if
we restrict the requests topology to a clique (all VMs connected to a virtual
switch with uniform bandwidth requirements), we show that the dynamic
programming algorithm can be modified to output the minimum congestion
embedding in time $O(k^2n)$.","InfrastructureasaService(IaaS)providerslikeAmazo n[htta],Rackspace[httd]andGogrid[hh]providecomputi ng and other services on demand and charge based on usage. This h as resulted in the commoditization of computing and storage. Typically, these providers provide service le vel agreements (SLA) [htte] where they guarantee the type of virtual machines (VMs) that they provide and the amount of disk space available to these VMs. Although some providersofferadditionalserviceslikededicatedﬁrewal lsandloadbalancers,nonetworkperformanceguaranteesa re provided, which are critical for workloads like content dis tribution networks, desktop virtualization, etc. Given th e rapid growth and innovationin these services [hcbiglc], it is importantfor service providers(SPs) to offer innovativ e service models for differentiation, e.g., by offering rich er network SLAs to be competitive while optimizing their resourceusagetokeepcostsdown. Next generation cloud services will require improved quali ty of service (QoS) guarantees for application work loads. For example, multitier enterprise applications [h ttb] require network isolation and QoS guarantees such as bandwidth guarantees, and for overthetop content distri bution using a cloud infrastructure, bandwidth, jitter and delay guaranteesare important in determining performance . Similar guarantees are necessary for MapReducebased 1analytics workloads too. Moreover, networking costs are cu rrently a signiﬁcant fraction of the total infrastructure cost in most data center (DC) designs [GT11, httc] since serv ers are cheap compared to core switches and routers. Thus, in order to provide richer network SLAs, it is importan t for SPs to ensure that networking resources are efﬁ cientlyutilizedwhileatthesametimeensuringlowcongest ion(thatleadstobetterloadbalancingandmoreroomfor overprovisioning). Inthispaperweconsideravirtualizationrequestmodelinw hichclientscanrequestbandwidthguaranteesbetween pairs of virtual machines (VMs) [GLW+10] for which SPs will allocate resources within their infra structure. This naturally leads us to study the following resource allocati on problem: given a VM request graph—where nodes are VMs and edges represent virtual network connectivity betwe en the VMs—and a real data center topology, ﬁnd an allocation of VMs to servers that satisﬁes the bandwidth gua rantees for every virtual network edge and minimizes congestionofthenetwork. Notethatinthissetting,eachvi rtualedgemapstoapathinthephysicalnetworktopology. The above request graph model is driven by application workl oads that execute on top of network infrastructure providedbytheSPs. Commonworkloadsincludeenterpriseap plications[httb],MapReduce[DG08],andwebhosting, anddifferentworkloadscanleadtodifferentservicemodel s. Forinstance,manywebservicesrequestasmallnumber ofVMstoimplementthewebservers,theapplicationservers ,andthedatabase. TheVMimplementingthewebserver receivesarequestandforwardsittoanapplicationserverV M,whichinturnqueriesthedatabaseserverVMs. Insuch cases,speciﬁcbandwidthguaranteesbetweentheoutsidewo rldandthewebserver,thewebserverandtheapplication server, and so on, are important to ensure QoS. In MapReduce w orkloads on the other hand, it has been shown that network optimizationcan yield better results than addingm achines[hsinfmc10], but in this setting since all the VMs implementingmap andreducetaskscommunicatewitheach oth erviadata shufﬂe,theaggregatebandwidthavailable tothe VMsmaydeterminetheapplicationperformance. Anumberofmetricshavebeenstudiedtomeasurethenetworkl oadincludingcongestion,jitter,delay,hopcount, or a combination of the above. Here we focus on minimizing con gestion, but we also note that our algorithmic techniquesaregenericandcaneasilybeadaptedto optimize othermetrics. It has been shown previously that the problem of embedding vi rtual requests in arbitrary networks is NPhard [CRB09, GLW+10]. However in most data center networks, routing protocol s used rely on a spanning tree of the physicalnetwork[httc]. Hence,inthispaperwestudythepr oblemofminimizingnetworkcongestionwhileallocating virtualrequestswhenthenetworktopologyisrestrictedto bea tree. 1.1 OurContributions First, we prove that optimally allocating VMs remains NPhard even when both the physical network topology and request topology are highly restricted. We show that if t he network topology is a tree then even for simple request topologies like weighted paths with the weights sig nifying the amount of bandwidth required between the correspondingVMs, it is NPhard to approximate the minimum congestion to a factor bett er thanO(θ), whereθis the ratio of the largest to smallest bandwidth requirements in the path request. We also show that in the unweighted case (or uniform bandwidth requirement on all edges) the pro blem isNPhard to approximate to within a factor of O(n1−ǫ)foranyǫ∈(0,1),evenforthe casewhentherequesttopologyisatree. Giventhesecomplexityresults,wecannothopeforanefﬁcie ntalgorithmforallinstancesoftheproblem. However, we note that in practice, many workloadsconsist of a small nu mber of VMs allocated in a huge datacenter. Accord ingly, our second result is a dynamic programmingalgorithm (Algorithm 2) for computingthe minimum congestion embeddingof VMs in a tree network for any request graph,whic h satisﬁes the pairwise bandwidthrequirementsand runs in time O(3kn), wherenis the number of nodes in the physical topology and kis the number of VMs in the request graph. Enterprise workloads often consist of small requests with speciﬁc bandwidth requirements between VMs, and for these instances the exponential O(3k)term is quite small, and can thus be optimally served using ou r algorithmwhoseruntimeisonlylinearinthenetworksize. Third, workloads like MapReduce jobs have too many VMs to us e an algorithm with a runtime of O(3kn), but thesehaveuniformbandwidthrequirementsbetweentheVMs[ MPZ10],andweshowthattheexponentialdependence onkcan be removed when the request network is uniform. For the sp ecial case in where the requests are restricted to be cliques or virtual clusters [BCKR11], we propose an algorithm that ﬁnds the minimum cong estion embedding inO(k2n)time (Algorithm 3). Hence our algorithms yield the minimum c ongestion embeddings of virtualization 2requestsforseveralcommonuse cases. Wealsopresentsimulationswhichvalidateourresultsforc ommonrequestmodelsandpracticalnetworkconﬁgu rations. 1.2 Outlineofthe paper The paper is organized as follows. We ﬁrst review previous wo rk in Section 2 and formally deﬁne the problem and notation in Section 3. We prove the hardness results in Secti on 4 followed the algorithms in Section 5. In Section 6 we providesimulations, which validate the runningtime and correctnessof ouralgorithms. Finally, we concludeand pointto futureworkin Section7. 2 Related Work "
109,Coordinator Location Effects in AODV Routing Protocol in ZigBee Mesh Network.txt,"ZigBee mesh network is very important research field in computer networks.
However, the location of ZigBee coordinator plays a significant role in design
and routing performance. In this paper, an extensive study on the factors that
influence the performance of AODV routing protocol had been performed through
the study of battery voltage decaying of nodes, neighboring tables, time delay
and network topology structure. Simulation results reveal that the location of
the coordinator within approximate equal distances to all nodes is more
appropriate for lifelong batteries and AODV routing performance.","ZigBee is one of the newest technologies developed by   ZigBee Alliance where  its characteristics depend mainly on  IEEE 802.15.4 standards which consist of both Medium  Access Control (MAC) layer and Physical layers (PHY).  ZigBee protocols have been designed to provide data  communication through RF environments that are used  commerc ially and in industry applications, this  communication protocol stack is used for WSN applications  [1].  ZigBee technology had been used widely in different  commercial, medical, industrial and home automation  applications, and the importance of keeping the network  operating a longer time was the main objective of ZigBee  manufacturers [2].   ZigBee devices had been designed to operate from several  months to several years at low bit rate transmission in  wireless networks applications at UHF and Microwave  frequen cies. ZigBee devices were  classifies in three different  categories, a coordinator that initiate the transmission , routers  that build up routes between nodes and an end units that  considered as final destination.  ZigBee  was manufactured   according to specific application where  each network  required  at least one coordinator to initiate the network operation in  which a personal area network identifier (PAN ID) will be  assigned  and routes will be established to  communicate  among the different n odes of the network. Therefore ,  coordinators  are the most important device in ZigBee network  which is able to store information about node and mange  network routes  [3, 5]. Most of the research work in this field  was more on mesh  network  topology  and less on the impact  of coordinator location on routing process .  In this research work , two different networks  were analyzed ,  the first where the coordinator was located at the center of the  network, and the second where the coordinator was locat ed at  the corner of the network and each  netw ork had two different  scenarios of route connection, the 1st  and the 2 nd shortest  routes.  The work depends mainly on Ad hoc On Demand  Distance Vector Algorithm (AODV) as a routing protocol that  communicates between  routers and broadcast packets to  destination for the two cases of Mesh Networks . The  established neighboring table will support AODV routing  protocol to direct packets toward destination in order to  establish a shortest route, Figure .1 shows a flowchart of the  routing  process.   Fixed positioning of coordinator in different spots of the  network will be researched and analyzed where routes  schematics, voltage decline curves, neighboring tables and  energy maps were the concluded results.   The rest of this paper is organized as following: In section 2  related works, the simulation steps present in Section 3.  simulation analysis  in section 4 and section 5 concludes the  results.       Fig .1 Flow Chart of AODV Routing  Schema .     International Journal of Computer Applications (0975 – 8887)   Volume 127 – No.8, October 2015   2 2.  RELATED WORK   "
297,CryptoMaze: Privacy-Preserving Splitting of Off-Chain Payments.txt,"Payment protocols developed to realize off-chain transactions in Payment
channel network (PCN) assumes the underlying routing algorithm transfers the
payment via a single path. However, a path may not have sufficient capacity to
route a transaction. It is inevitable to split the payment across multiple
paths. If we run independent instances of the protocol on each path, the
execution may fail in some of the paths, leading to partial transfer of funds.
A payer has to reattempt the entire process for the residual amount. We propose
a secure and privacy-preserving payment protocol, CryptoMaze. Instead of
independent paths, the funds are transferred from sender to receiver across
several payment channels responsible for routing, in a breadth-first fashion.
Payments are resolved faster at reduced setup cost, compared to existing
state-of-the-art. Correlation among the partial payments is captured,
guaranteeing atomicity. Further, two party ECDSA signature is used for
establishing scriptless locks among parties involved in the payment. It reduces
space overhead by leveraging on core Bitcoin scripts. We provide a formal model
in the Universal Composability framework and state the privacy goals achieved
by CryptoMaze. We compare the performance of our protocol with the existing
single path based payment protocol, Multi-hop HTLC, applied iteratively on one
path at a time on several instances. It is observed that CryptoMaze requires
less communication overhead and low execution time, demonstrating efficiency
and scalability.","Cryptocurrencies are gaining prominence as an alterna tive method of payment. Blockchain forms the backbone of such currencies, guaranteeing security and privacy. It allows transacting parties to remain pseudonymous and ensures the immutability of records. Records in blockchain are publicly veriﬁable. Bitcoin mining relies on Proofof Work (PoW) [1], [2], [3] to ensure a Sybilresistant network. Unfortunately, PoW is quite resourceintensive and time consuming, reducing transaction throughput [4], [5]. Layertwo protocols provide a solution to the problem of scalability. It enables users to perform transactions offchain and massively cut down data processing on the blockchain. Solutions like payment channels, channel factories, pay ment channel hub, sidechains, and commitchains have been stated in the literature survey [6]. Payment Channels [7], [5] are widely deployed in many applications. It is modular and does not require any fundamental changes in the protocol layer. Two parties can mutually agree to open a payment channel by locking their funds for a certain period. Nodes not directly connected by a payment channel route a payment via an existing set of channels. This set of interconnected payment channels forms a Payment Channel Network or PCN. Lightning Network for Bitcoin [5] and Raiden Network for Ethereum [8] are the two most popular net works. Designing privacypreserving routing and payment protocols for such networks is a big challenge. Most of the routing algorithms focus on ﬁnding a single path for routing a transaction. However, ﬁnding a single route for a highvalued transaction is a challenging task. After several payments get executed in the network, channels in a path may not have sufﬁcient balance to relay the funds. In such circumstances, it is better to split highvalued payments across multiple paths to increase the success rate of trans actions. However, it is not trivial to design a protocol for Subhra Mazumdar is with the Cryptology and Security Research Unit, Indian Statistical Institute, Kolkata, India Email: subhra.mazumdar1993@gmail.com Dr. Sushmita Ruj is with University of New South Wales, Sydney, Australia Email: Sushmita.ruj@unsw.edu.aumultipath payment and we discuss the challenges faced. Challenges faced in multipath payments Atomicity of payments : Several distributed routing algo rithms [9], [10], [11], [12], [13], [14], [15], [16], [17], [18] have been proposed for relaying transactions across mul tiple paths. A payment transferred from payer to payee must be atomic . Either all the partial payments succeed or fail in their entirety. Applying existing payment protocols like Hashed Timelock Contract [5], [19], BOLT [20], Sprites [21], [22], Anonymous MultiHop Lock or AMHL [23], on individual paths routing partial payment might not guarantee atomicity. If an instance of the protocol fails in one of the paths, only the partial amount gets transferred to the receiver, violating atomicity. Susceptible to wormhole attack : Existing multipath payment protocols like AMP [24], Boomerang [25] achieve atomicity. Each path forwarding the partial payment uses the same commitment, making it susceptible to wormhole attack [23]. Malicious parties in a given path may collude and steal an honest party’s processing fee. Multiple offchain contracts on shared channels : Multiple paths routing a single payment may not be edgedisjoint. In Figure 1, Mwants to transfer 5:1units toN. The payment is split across two paths p1=hMA!AB! BD!DNiandp2=hMA!AC!CD!DNi into 2.6 units and 2.5 units respectively. Each intermediate parties charge a processing fee of 0.1 units. Channels MA andDN are shared by the two paths. Thus, two off chain contracts need to be established for routing each partial payment. Also, nodes AandDget paid twice for forwarding each partial payment, levying an additional cost overhead on the sender M. To save cost and avoid the overhead of instantiating offchain contracts, it is better to construct one offchain contract on shared payment channels for a payment instance. Linkability between partial payments : A given node will be willing to route full payment instead of partial payments [26]. The success rate is low when payment is split. If a partial payment fails in one of the paths, then the entirearXiv:2005.07574v3  [cs.CR]  5 Feb 20222 Fig. 1: Paths p1andp2shares channels MA andDN payment rolls back. If colluding parties can link partial payments, they will tend to reject such requests and pre serve their channel capacity for routing the full amount. Unlinkability must be ensured to prevent censoring split payments. Our goal is to construct a payment protocol that addresses all the shortcomings discussed above. 1.1 Contributions We propose CryptoMaze, an efﬁcient, privacypreserving, atomic multipath payment protocol. Our protocol opti mizes the setup cost by avoiding the formation of multiple offchain contracts on a channel shared by partial pay ments. To date, no other protocol has been able to achieve this optimization. Our protocol ensures balance security, i.e., honest interme diaries do not lose coins while forwarding the payment. Our protocol description ensures unlinkability between partial payments. We have modeled CryptoMaze and deﬁned its security and privacy notions in the Universal Composability or UC framework. Experimental Analysis on several instances of Lightning Network and simulated networks show that our proposed payment is as fast as Atomic Multipath Payment [24]. The run time is around 11s for routing a payment of 0.04 BTC in a network instance of 25600 nodes. The communication overhead is within feasible bounds, being less than 1MB. The code is available in [27]. 1.2 Organization The rest of the paper has been organized as follows: Section 2 provides the background concept needed for understand ing our paper. Section 3 discusses the related works in multi path payments. Our proposed protocol has been described in detail in Section 4. We discuss the security of our protocol in Universal Composability (UC) framework in Section 6 and provide the security analysis. The experimental obser vation has been provided in Section 7. Finally, we conclude our paper in Section 9. 2 B ACKGROUND In this section, we provide the required background for understanding our protocol. The terms source/payer means the sender node. Similarly, sink/payee/destination means the receiver node. A payment channel has been referred to as an edge. Table 1 states the notations used in the paper.Notation Description G:= (V;E) Bidirected Graph representing PCN V Nodes inG E Payment channels in G,EVV C:EN!R+Capacity function f:V!R+Function deﬁning processing fee idi;j Identiﬁer of payment channel (Ui;Uj)2E B Blockchain G Elliptic curve of order q whereq=pn;pis a prime number G Base point of elliptic curve G  Security Parameter H:f0;1g!f0;1gStandard Cryptographic Hash function  Worstcase conﬁrmation time for a transaction to get recorded in Blockchain U0 Payer, a node in set V Ur Payee, a node in set V gain :V!R+Function deﬁning coins gained by a node PC Set of payment channels, created by U0 Ti Timestamp at which node Uireceives its ﬁrst incoming contract request.  latency F Ideal functionality for payment in PCN FB Ideal functionality for Blockchain B Fsmt Ideal functionality for secure message transmission Sim Ideal world adversary A Adversary in the real world Z Environment TABLE 1: Notations used in the paper 2.1 Payment channels A payment channel enables several payments between two users without committing every single transaction to the blockchain. Any two users can mutually agree to open a payment channel by locking their coins into a multi signature address controlled by both users. These parties can perform several offchain payments by locally agree ing on the new deposit balance. Correctness of payments is enforced cryptographically by the use of hash locks, time locks [5], or scriptless locking [23]. A party can close the payment channel, with or without the cooperation of counterparties, broadcasting the latest transaction on the Blockchain. Broadcasting of older transactions leads to the slashing of deposits made by the malicious party. 2.2 Payment channel networks (PCNs) A Payment Channel Network is modeled as a bidirected graphG= (V;E)whereVrepresents the participants in the network and EVVdenotes the payment channels existing between parties [5], [7]. Opening a pay ment channel (Ui;Uj)is equivalent to the opening of two unidirectional payment channels (Ui;Uj)and(Uj;Ui). The channel identiﬁer for (Ui;Uj)is denoted as idi;j. The under lying blockchain, denoted as B, acts like a trusted append only ledger recording the opening and closing of payment channels. A capacity function, deﬁned as C:EN!R+, denotes the balance of each party in the channel at a given time. For example, C((Ui;Uj);t)denotes the balance of partyUiin the channel idi;jat timet. We deﬁne the fee charged by each node as f:V!R+. The fee calculated is proportional to the coins a particular node is routing through its channel. If a party Uireceives a request to transfervalcoins at time tcurrent to a nodeUj, it checks locally whether there exist payment channels connected to UiandC((Ui;Uj);tcurrent )val. 2.3 Offchain contracts OffChain contracts are smart contracts where the logic en coded in the contract is not run by the miners. It is mutually3 executed by the participants involved in instantiating the contract. The advantage of having offchain contracts are that computationintensive tasks can be executed without involving blockchain as long as participants behave hon estly. An individual player can prove the correct contract state independently. Cheating is prevented as the state of the contract is signed by all the players. If a party misbehaves by broadcasting a wrong state in blockchain, the counterparty can raise a dispute and publish the valid accepted state. Hashed Timelock Contract or HTLC [5] is one such example used in PCN for routing payments in the network. The logic used is a hash function, where players need to provide the preimage of the hash to claim coins. 2.4 Wormhole attack in PCNs HTLC uses the same commitment across the path routing the payment. Consider an example where U0wants to transfercoins toUrvia nodesU1;U2;:::;Un"
379,Towards a Fast and Accurate Model of Intercontact Times for Epidemic Routing.txt,"We present an accurate user-encounter trace generator based on analytical
models. Our method generates traces of intercontact times faster than models
that explicitly generate mobility traces. We use this trace generator to study
the characteristics of pair-wise intercontact-time distributions and visualize,
using simulations, how they combine to form the aggregate intercontact-time
distribution. Finally, we apply our trace-generation model to the epidemic
routing protocol.","Pocketswitched networks (PSNs) are networks in which mobile agents use small communication devices with a short range communication protocol. By using the movement of the members of this network to transport data, we explore the opportunities for connections that arrive from the users’ encounters to exchange information. In this type of network, paths between nodes are not available at all times. Therefore, since it is necessary to wait for human encounters to establish connectivity, this network type falls under the category of delaytolerant networks (DTNs) [8]. When studying PSNs, an important parameter is a time between the end of a connection and the start of the next connection [1]. This parameter is called the intercontact time. Several authors have used these parameters to estimate the potential of PSNs since it allows us to estimate the expected time the network must wait for establishing communication between agents. Chaintreau, Hui, Crowcroft, Diot, Gass, and Scott [1] have proposed a power law as a ﬁt for the intercontact time probability distribution and analyzed the performance of naive forwarding protocols under this hypothesis, indicating that we would have an inﬁnite expected time for message arrival. However, Karagiannis, Le Boudec, and V ojnovi ´c [10] obtained a ﬁnite expected time for message arrival when remarking the exponential decay present in the same traces after the powerlaw pattern. A vital aspect to consider when studying PSN is the heterogeneity of the networks [15]. There is a distinction between the aggregate intercontacttime distribution, which is generated by analyzing all intercontact times obtained in an experiment, to the pairwise intercontacttime distribution, which comes from the intercontact times of single pairs of users. Both Chaintreau et al. [1] and Karagiannis et al. [10]assumed that the pairwise distribution was equal to the aggregate distribution for their analysis. Even if the aggregate intercontacttime distribution follows a powerlaw with an exponential decay after the halfday period [10], this does not imply that all pairs follow the same distribution. More recent research in human mobility patterns tends to indicate that pairwise distributions are indeed heterogeneous [14], [15], [2], [13] and the aggregate intercontacttime distribution measured in several contact trace experiments is generated by the combination of different distributions. Another relevant parameter when dealing with PSNs is the contact rate or the number of contacts per time unit. The con tact rate is deﬁned by Hern ´andezOrallo, Cano, Calafate, and Manzoni [7] as the limit of the expected number of contacts as a function of time divided by time. If we model the intercontact times as purely exponential distributions, the expected contact rate becomes the inverse of the scale parameter. However, in this paper, we will approximate this limit for ﬁnite times as the number of contacts throughout the trace experiment. Usually, the evaluation of the performance of opportunistic networks uses computationally expensive mobility models [7]. Thus we propose in this paper a human encounter trace gener ator that uses the pairwise intercontacttime distributions and contact duration probability distributions for the construction of its traces. We will show that our proposed model can generate an ag gregated intercontacttime distribution similar to the obtained in the real humanmobility experiments. Also, the model can reproduce the contact rates seen in real data. Finally, we were able to introduce preferential meeting times and periodicity to the intercontact times, an aspect of human encounters with is discussed in mobility models [4]. Moreover, we conducted simulations regarding the behavior of our trace generation in epidemic routing. By adapting the centrality measurement used by Gao, Li, Zhao, and Cao [5], we did a similar analysis to our traces. The idea behind this is to explore the use of intercontacttime models in digital epidemiology, similar to Pajevic, Karlsson, and Helgason [13]. We believe that, by creating traces that can accurately replicate epidemic routing behavior, we could potentially translate those results to modeling disease epidemics. For simplicity, we chose not to add a social aspect to intercontact times between a group of distributions and theirarXiv:2104.07298v1  [cs.DC]  15 Apr 2021intercontacttime distributions. Hui, Chaintreau, Scott, Gass, and Crowcroft [9] used the social characteristics of commu nities to improve routing protocols. Moreover, Yang, Jiang, et al. [22] have described a new behavior on intercontact times regarding the alternation between bursts of contacts and extended periods with no contacts, and the importance of weekdays when modeling intercontact times, with weekends having fewer contacts. We leave the incorporation of their ﬁndings to this model to future work. Contribution. We make the following contributions in this paper: 1) We provide a fast and accurate stochastic trace generator for intercontact times in PSNs. For instance, the studied traces on the results were generated under one second on a home computer. However, studies of this application for larger populations have been left to future work. 2) The trace generation provided by this model does not rely on mobility models. Therefore, it does not need to compute users’ movement. As far as we know, this is the ﬁrst work that generates trace experiments from mobilityfree analytical models. 3) We compare the model predictions to measured traces from the literature and thereby show its accuracy. 4) We analyze how this model would perform under the epidemic routing protocol as an attempt to link intercontacttime modeling with digital epidemiology. II. R ELATED WORK "
351,An Energy-Aware On-Demand Routing Protocol for Ad-Hoc Wireless Networks.txt,"An ad-hoc wireless network is a collection of nodes that come together to
dynamically create a network, with no fixed infrastructure or centralized
administration. An ad-hoc network is characterized by energy constrained nodes,
bandwidth constrained links and dynamic topology. With the growing use of
wireless networks (including ad-hoc networks) for real-time applications, such
as voice, video, and real-time data, the need for Quality of Service (QoS)
guarantees in terms of delay, bandwidth, and packet loss is becoming
increasingly important. Providing QoS in ad-hoc networks is a challenging task
because of dynamic nature of network topology and imprecise state information.
Hence, it is important to have a dynamic routing protocol with fast re-routing
capability, which also provides stable route during the life-time of the flows.
  In this thesis, we have proposed a novel, energy aware, stable routing
protocol named, Stability-based QoS-capable Ad-hoc On-demand Distance Vector
(SQ-AODV), which is an enhancement of the well-known Ad-hoc On-demand Distance
Vector (AODV) routing protocol for ad-hoc wireless networks. SQ-AODV utilizes a
cross-layer design approach in which information about the residual energy of a
node is used for route selection and maintenance. An important feature of
SQ-AODV protocol is that it uses only local information and requires no
additional communication or co-operation between the network nodes. SQ-AODV
possesses a make-before-break re-routing capability that enables near-zero
packet drops and is compatible with the basic AODV data formats and operation,
making it easy to adopt in ad-hoc networks.",1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 
300,A Novel Hierarchical Ant based QoS aware Intelligent Routing Scheme for MANETS.txt,"MANET is a collection of mobile devices with no centralized control and no
pre-existing infrastructures. Due to the nodal mobility, supporting QoS during
routing in this type of networks is a very challenging task. To tackle this
type of overhead many routing algorithms with clustering approach have been
proposed. Clustering is an effective method for resource management regarding
network performance, routing protocol design, QoS etc. Most of the flat network
architecture contains homogeneous capacity of nodes but in real time nodes are
with heterogeneous capacity and transmission power. Hierarchical routing
provides routing through this kind of heterogeneous nodes. Here, routes can be
recorded hierarchically, across clusters to increase routing flexibility.
Besides this, it increases scalability and robustness of routes. In this paper,
a novel ant based QoS aware routing is proposed on a three level hierarchical
cluster based topology in MANET which will be more scalable and efficient
compared to flat architecture and will give better throughput.","  A Mobile Ad Hoc network (MANET) [1] is a dynamicall y formed wireless network by the  mobile nodes. In this network nodes can move random ly. Due to the node mobility network is not  stable and topology is not fixed. So, stable routin g is a very essential part in MANET. There are  three kinds of routing: Proactive, reactive and hyb rid. In proactive routing, topology information  is distributed proactively; even there is no data t o send. So, control overhead increased. To  overcome this problem, reactive approach is introdu ced, where route search is initiated only when  needed. But in this routing, there is an initial ro ute discovery delay which is undesirable in many  scenarios. So, to overcome these problems, hybrid r outing is proposed which is the combination  of both the proactive and reactive routing. Alterna tively, it is possible to form a cluster of nodes  which produces communication hierarchy. There are s ome advantages of this type of hierarchical  routing. Many of the contemporary ad hoc networks a re heterogeneous in nature. Mobile devices  of this kind of network are equipped with different  communication capabilities with respect to  frequency band, battery power, radio range, data ra te etc. e.g. in military networks, soldiers, tanks  and command posts works in different interfaces. So , scalability of this kind of heterogeneous  wireless networks is a most important factor. Hiera rchical routing makes the protocol more  scalable. Flat routing protocols cannot differentia te the mobile nodes with different capacities.  Thus, performance of network degrades as the number  of mobile nodes with different capacity  increases. Furthermore, control overhead, routing o verhead much decreases with the hierarchical  routing scheme. Hierarchical routing keeps the rout ing table size smaller in comparison with flat International Journal of Computer Networks & Commun ications (IJCNC) Vol.5, No.6, November 2013    216 routing scheme. Failure is isolated in hierarchical  network topology. So, overhead of route  maintenance also decreases.    In this paper, clustering technique is used to orga nize mobile nodes in small cluster to provide a  hierarchical network structure of heterogeneous mob ile nodes in MANET. This algorithm takes  advantages of Ant Colony Optimization (ACO) [3]. It  uses ACO technique for selecting cluster  heads. Also intracluster routing is done by ACO. I t also provides QoS provisioning in each level  of hierarchy for efficient and scalable QoS aware r oute discovery and maintenance. This proposed  routing scheme decreases the overhead and improves the overall performance of MANET.   The paper is organized as follows: Section 2 descri bes the Ant colony optimization. Section 3  describes the related works. In section 4 assumptio ns of this algorithm is given. Section 5  describes the design of the protocol. Section 6 exp lains the proposed routing protocol. Section 7  explains the performance analysis. Finally section 8 concludes the paper.    2.  ANT COLONY OPTIMIZATION     The Ant colony optimization is based on the foragin g behavior of ants [3, 11]. When ant started  food searching they wonder randomly. When they find  the food they return to their colony laying  a chemical substance called pheromone. The ants tra vel randomly exploring all paths but the ants  which travel the shortest path reinforce the path w ith more pheromone. Most of the ant follows  the path which has the greater pheromone intensity.   This autocatalytic behavior quickly identifies  the shortest path.    Some properties characterizes ACO instances for rou ting problems, they are:     a.  In a network where the topology changes dynamically , highly adaptive routing is necessary.  Also, in the network without any centralized contro l, due to node mobility the link can be  broken any time and the communication may be lost. If multiple paths exist between source  and the destination, one path lost cannot effect th e communication, because anyone of the  existing paths can be used for routing. ACO provide s both the trafficadaptive and the  multipath routing.  b.  It is necessary to choose a path for routing which satisfies both the required                                     constraints for routing, for this some previous inf ormation are needed and based on the  newer and the previous information the path is chos en. In ACO, both the passive and active  information are gathered and monitored.    c.  ACO uses the stochastic components for routing.  d.  ACO does not allow local search estimates to have g lobal impact for the required solution.  In ACO no routing information has to transmit to ne ighbor or all the nodes.  e.  ACO does not set paths like other greedy shortest p ath schemes, at the time of path set up it  also taken care of load balancing. So, it taken car e of the link quality also.    f.  Another important aspect is parameter setting. It i s done by ACO in less sensitive way.    Figure 1 illustrates the behavior of ants. A set of  ants moves along a straight line from their nest A   to a food source B (Figure 1a). At a given moment, an obstacle is put across this way so that side  (E) is longer than side (F) (Figure 1b). Now, the a nts have to decide which direction they will  take: either E or F. The first ones will choose a r andom direction and will deposit pheromone  along their way. The ants taking the way AEB (or AF B), will arrive at the end of the obstacle  (depositing more pheromone on their way) before tho se that take the way AEB (or AFB). So,  pheromone intensity of route AFB becomes greater th an that of route AEB. So, the ants choose  the path AFB (Figure 1c). The ants will then find t he shortest way between their nest and the food  source. International Journal of Computer Networks & Commun ications (IJCNC) Vol.5, No.6, November 2013    217                             Fig. 1.  Behaviour of ants for searching the food from A to  B    The mechanism of ant colony optimization is describ ed below:    Suppose, an artificial ant deposit a quantity of ph eromone represented by ∆τ i,j  only after  completing their route and not  in an incremental w ay during their advancement. This quantity of  pheromone is a function of the found route quality.       Pheromone is a volatile substance. An ant changes t he amount of pheromone on the path (i, j)  when moving from node  i  to node j  as follows:                                                    τi,j  = σ.τi,j  + ∆τ  i,j                            (1)                            Where 1 0 <<ρ and ρ is the pheromone evaporation factor which avoids i nfinite increment of  pheromone which may leads to stagnation of the rout e.    At one point i, an ant chooses the point j (i.e. to  follow the path (i, j)) according to the following   probability:                            P i,j = ∑ ∈Ckiik ik ij ij  ,).( )().( )( β αβ α η τη τ      (2)           Where,   τi,j : is the pheromone intensity on path ( i, j).   ηi,j : is the ant’s visibility field on path ( i, j)(an ant assumes that there is food at the end of this  path).   α and β : are the parameters which control the relative im portance of the pheromone intensity  compared to ant’s visibility field.   C: represents the set of possible paths starting fr om point i (( i, k ) is a path of C).  Like real pheromone the artificial pheromone decrea ses over time for fast convergence of  pheromone on the edges. This happen in ACO accordin g to the following formula:          τi,j  = (1q). τi,j                          q∈(0,1]             (3)                     3. R ELATED WORKS   "
280,Solving bandwidth-guaranteed routing problem using routing data.txt,"This paper introduces a traffic engineering routing algorithm that aims to
accept as many routing demands as possible on the condition that a certain
amount of bandwidth resource is reserved for each accepted demand. The novel
idea is to select routes based on not only network states but also information
derived from routing data such as probabilities of the ingress egress pairs and
usage frequencies of the links. Experiments with respect to acceptance ratio
and computation time have been conducted against various test sets. Results
indicate that the proposed algorithm has better performance than the existing
popular algorithms including Minimum Interference Routing Algorithm (MIRA) and
Random Race based Algorithm for Traffic Engineering (RRATE).","There are increasingly more network applications such as live stream and online games that require certain quality of service (QoS) guarantees. Apart from meeting the QoS requirements, network providers need to optimize their network performance in order to effectively fulfil as many customer demands as possible. Therefore, traffic engineering (TE), which manages network activities with dual objectives of QoS satisfaction and network optimi zation, becomes important. Routing is a powerful technique of TE as it allows for controlling network data flows. In general, routing algorithms are categorized into proactive and reactive ones. The former pre  selects paths for routing demands based on fi xed network information, while the later uses dynamic network states to establish routes upon receiving demands. As a result, reactive algorithms adapt to traffic demands and have good routing performance [1]. Furthermore, although there are several types of QoS criteria such as bandwidth, delay, and loss ratio, most research considers bandwidth as a primary constraint as the others can be efficiently conv erted into bandwidth demand [2]. Therefore, this paper focuses on reactive bandwidth guaranteed routing problem. Besides network states (e.g. network topology, link residual bandwidth), which are used in existing solutions [3], the proposed algorithm introduces a novel idea to exploit historical routing data such as request probability and link usage frequency for route selection. The rest of the paper is organized as follows. Section 2 presents the definition of the TE routing problem and a review of related work. The proposed algorithm named Traffic Engineering routing Algorithm with Rou ting Data (TEARD) is discussed in section 3. Section 4 describes the experimental setup and compares the proposed algorithm with some popular ones with respect toInternational Journal of Computer Networks & Communications (IJCNC) Vol.6, No.6, November 2014 98acceptance ratio of demands and average computation time. Finally, section 5 discusses conclusions and future work. 2.PROBLEMDEFINITION &RELATEDWORK 2.1.Problem Definition A network topology with nnodes and mlinks is considered. Each link has its own capacity and residual bandwidth at a given time. A routing demand, which requires a path with certain bandwidth from an ingress node to an egress node, is handled by the routing algorithm. The algorithm sequentia lly processes demands with an assumption that network states such as topology, link bandwidths and ingress egress (ie) pairs are available. However, routing demands are not known in prior. Table 1lists the mathematical notations used to describe the probl em. Table 1. Problem notations Symbol Description G(N, L) A direct graph presents the network topology N(|N| = n)is a set of nodes L(|L| = m)is a set of links IE A set of all ingress egress pairs c(l) Capacity bandwidth of link l r(l) Residual bandwidth of link l d(i, e, b) A traffic demand requesting bbandwidth units from an ingress nodeito an egress node e pie A routing path from itoe Pie A set of all paths from itoe The objective of TE routing algorithm is to route as many demands as possible on the condition that each established route will reserve an amount of bandwidth resource for a period of time (i.e. bandwidth for each route is guaranteed). Since ingress egresspairs have commodity integral flows, the TE routing problem is NP hard[4]. Most of reactive routing alg orithms first calculate link weights based on network states then use shortest path algorithms (e.g. Dijkstra or Bellman  Ford) to select the least weighted route. Table 2generalizes the steps of reactive routing algorithms. Table 2.  General steps of TE routing algorithms Input A network graph G(N, L)withnecessary information e.g. link bandwidths . A traffic demand d(i, e, b) Output A satisfie d bandwidth path from itoe, pie, towardthe optimal goal of maximizing the number of accepted demands . Ornoroute satisfying the demand Steps 1.Calculate link weights w(l) 2.Temporarily remove links that have residual bandwidth less than b. 3.Find the least weight path p ie. If found then return p ie,otherwise rejects the demand .International Journal of Computer Networks & Communications (IJCNC) Vol.6, No.6, November 2014 992.2.Related Work "
77,Structural Attacks on Local Routing in Payment Channel Networks.txt,"Payment channel networks (PCN) enable scalable blockchain transactions
without fundamentally changing the underlying distributed ledger algorithm.
However, routing a payment via multiple channels in a PCN requires locking
collateral for potentially long periods of time. Adversaries can abuse this
mechanism to conduct denial-of-service attacks. Previous work focused on source
routing, which is unlikely to remain a viable routing approach as these
networks grow.
  In this work, we examine the effectiveness of attacks in PCNs that use
routing algorithms based on local knowledge, where compromised intermediate
nodes can delay or drop transactions to create denial-of-service. We focus on
SpeedyMurmurs as a representative of such protocols. We identify two attacker
node selection strategies; one based on the position in the routing tree, and
the other on betweenness centrality. Our simulation-driven study shows that
while they are both effective, the centrality-based attack approaches
near-optimal effectiveness. We also show that the attacks are ineffective in
less centralized networks and discuss incentives for the participants in PCNs
to create less centralized topologies through the payment channels they
establish among themselves.","Payment channel networks such as Lightning [1] are the predominant solution to scaling blockchains without fundamentally changing the underlying consensus algo rithm [2]. At their core, they rely on the concept of a pay ment channel , wherein two parties who wish to perform transactions offtheledger put funds in escrow dedicated to such operations. For parties that do not directly share a channel, payment channel networks facilitate transactions by forwarding the payment along one [1] or multiple [3], [4], [5] paths in the graph created by all existing direct payment channels. The chosen paths need to have the necessary funds to complete the transaction. The process of ﬁnding suitable paths is referred to as routing , as an analogy to routing in networks, with the caveat that the main goal here is completion of the payment. Routing payments along one or multiple paths pro ceeds in two phases: First, all involved nodes commit to paying their successor on the path. Such a commitment implies that they lock the funds required for the payment ascollateral . As a consequence, these funds are not avail able for any concurrent payments. Second, the paymentsare ﬁnalized. If the payment fails, the collateral is released after a timeout. These timeouts tend to be on the order of minutes or even hours, e.g., for Lightning, 40 Bitcoin blocks in the future from the current block number (at the start of the transaction) — more than 6 hours [6]. Adversarial parties can abuse this mechanism for a denial ofservice attack. By forcing collateral to remain locked in a maximal number of channels for long periods, they can drastically reduce the funds available for other concurrent payments. As a consequence, concurrent payments can fail due to a lack of available funds [7], [8]. Such an attack is called a grieﬁng attack [9]. Previous work [8], [7], [10] on grieﬁng attacks has focused on singlepath source routing as this is the current type of algorithm in the Lighting Network. In such a setting the attacker is the source of the payment and no intermediate nodes are involved in the attack. Initiating payments for an attack is costly, however. The attacks exploit either the speciﬁcs of Lightning’s source routing protocol by selecting a cheap path, or leverage proper ties of the underlying PoW blockchain ( e.g., block size, transaction limit). It is unlikely that source routing will remain the rout ing in the Lightning Network as network usage increases. Not only does source routing require storing a snapshot of the global topology at each node, it also prevents intermediary nodes from adjusting the path if a channel does not have sufﬁcient funds, thus leading to routing failures even in the absence of attacks [5]. A na ¨ıve solution would be to maintain information about current funds at the source. However, keeping such information uptodate is infeasible in a large network, because each successful transaction entails changes in the available funds of one or more channels. In a network of one million nodes, every update due to a transaction has to be forwarded at least one million times. If PCNs, indeed, settle thousands of transactions per second, as the VISA network does [11], billions of update messages have to be sent per second; an unacceptable overhead. To overcome the limitations of source routing, rout ing algorithms solely based on local information have been developed [12], [3], [13]. Such approaches allow intermediaries to choose suitable channels based on the currently available funds. However, giving more power to intermediate nodes also opens these routing algorithms to attacks. Prior work did not evaluate the effect of denial ofservice attacks on such routing algorithms. Given the severity of such attacks for source routing, it is essential to evaluate novel algorithms in the presence of such attacks before deploying them. To the best of our knowledgearXiv:2007.09047v2  [cs.CR]  7 Sep 2021such attacks have not been studied for payment channels routing with local knowledge. In this work, we focus on attacks against local rout ing algorithms in payment channel networks, where the attacker is an intermediate node on a payment path. More precisely, we perform two versions of a denialofservice attack on SpeedyMurmurs [3], a routing algorithm based on local information, which is considered a promising alternative to source routing [2]. In the ﬁrst variant of our attack, the attacker drops payments entirely. In the second variant, the attacker performs grieﬁng by delaying the payment without causing it to fail. All attacks are performed by intermediaries rather than the source, with the intermediaries being selected strategically based on their position in the network. To conduct the attacks, the attacker needs to know the topology of the network. Note that attackers cannot be prevented from learning the topology as in all currently deployed PCNs (includ ing SpeedyMurmurs), channel opening and closing are recorded on the public blockchain. In contrast to source routing, SpeedyMurmurs’s abil ity to let intermediaries detect and avoid channels with blocked collateral should make it more resistant to such attacks. Our simulations show the vulnerability of Speedy Murmurs to attacks. We observe, in all simulated scenar ios, that dropping is more damaging than grieﬁng. How ever, network operators can more easily detect dropping than grieﬁng. This is because in a grieﬁng attack, a trans action may fail due to an attacker delaying a transaction on a partially overlapping path, whereas with dropping, the transaction must be directly routed through the attacker’s node. Our results indicate that selecting attackers by graph centrality is the most effective selection method. Specif ically, a centralitybased attacker must corrupt just 0.1% of the nodes to reduce the fraction of successful transac tions to near zero, which is only slightly less effective than an ideal attacker that selects the nodes based on the number of transactions they relay. In contrast, our SpeedyMurmursspeciﬁc attack, which selects attackers based on spanning treedepth, requires 3%, while a ran dom node selection requires 20% to do the same degree of damage. Though SpeedyMurmurs is a treebased algo rithm, it allows the use of channels not in the tree. Thus, nodes in central positions in the tree do not forward as many transactions as nodes with a central positions in the graph, leading to the lower effectiveness of the treebased attack. We perform a costanalysis and show that our most powerful attack, which requires only 10 attackers in a net work of 10,000, would cost an estimated one million USD to perform. This may seem expensive, however, as our simulated network resembles the size of Lightning, which as of Mar. 22, 2021 [14] has a capacity of 64 million USD, the lost income due to nearly all the transactions failing could dwarf the attack cost. Based on the observation that centrality drastically increases the impact of the attacker, we evaluate the attacks in a smallworld network with homogeneous node centralities and ﬁnd that the attack is indeed less effective. Consequently, we discuss incentives for nodes to trans form existing payment channel networks to more suitable topologies.In summary, our contributions are: A design of dropping and grieﬁng attacks speciﬁc to local routing with intermediaries as attackers. A simulationbased evaluation of the proposed attacks revealing that highcentrality nodes allow for highly effective attacks. The strongest attacker uses just 0.1% of such nodes to reduce the fraction of successful transactions to near zero, close to what an ideal attacker could do. A costanalysis of our attacks with current transaction pricing, indicating that the attack would cost 1 million USD in a network worth 64 million USD. A strategy for reducing a network’s susceptibility to our attacks by incentivizing nodes to build less centralized topologies. 2. Payment Channel Networks In this section, we introduce the key ideas of PCNs as well as components of PCNs relevant for the remainder of the paper. 2.1. Payment Channels Apayment channel deﬁnes the relationship between two parties who wish to perform monetary transactions in a common digital currency. In the most general form, a channel is deﬁned by the two parties that establish it and the amount of funds that they make available for transactions to each other. There are three operations that can be performed on each payment channel: i) opening the channel, ii) performing transactions, and iii) closing the channel. Figure 1: A payment channel network. Open channel. The channel balance is initially estab lished by a channel open operation. This operation may be a veriﬁed transaction as is the case for Bitcoin’s [15] Lightning Network [1] or Ethereum’s [16] Raiden Net work [17], where channel creation is a blockchain trans action that uses smart contracts to hold the party’s funds in escrow. Payment channels may be either bidirectional or unidirectional. We focus on bidirectional payments channels, i.e., payments can be sent in either direction. A diagram of a payment channel network can be found in Figure 1. Perform transaction. Atransaction in a payment chan nel is initiated by one party, referred to as the sender , proposing a new state of the channel to the other party, referred to as the recipient . The transaction changes the balance of the channel, i.e., the amount the sender can send to the recipient. There are a number of mecha nisms that enable secure transactions on a channel [2] — mechanisms that ensure the recipient receives exactly the promised funds.Close channel. Either party on the channel can decide to close the channel. When closing the channel, one or both parties publish the latest state of the channel on the blockchain to regain the coins corresponding to the balance they have on their side. Disputes between the two parties are resolved by the blockchain consensus [2]. 2.2. Payment Channel Networks An open payment channel requires at least one party to escrow funds. As a result, the number of channels a party is willing or able to open is limited. Payment channel networks were proposed to facilitate payments between parties who do not have a direct channel between them. If one considers the parties and the channels between them as a graph, then as long as at least one path with enough liquidity exists between the two parties, they can conduct transactions without having a direct channel by performing a series of pairwise transactions along each channel of each path. If a payment is split over multiple paths, the sum of the partial payments must equal at least the total payment value. A brief note on semantics: we will follow the con vention of Bagaria et al. [18] and use the term payment to indicate the highlevel task that a user might wish to accomplish, and the term transaction to mean the components that make up that payment; these components include individual hops along a single path and also payment splits in multipath routing. Depending on the implementation, there are various mechanisms in place to guarantee atomicity so that either all of the pairwise transactions succeed, or none of them do [1], [19], [4]. These typically proceed in two rounds: During the commitment phase, all involved parties agree to participate in the payment using a smart contract that enforces cooperation later on. In the payment phase, par ties then ﬁnalize the payment if all parties agree to make the commitment. Otherwise, the commitments expire after some time and the parties are able to use those funds for other payments. When making a transaction, both parties must lock the value of that transaction as collateral which cannot be used for other, concurrent transactions. The key idea of a grieﬁng attack is to have parties lock collateral for longer than intended periods of time. In this manner, the attacker prevents benign transactions from succeeding as the locked collateral is not available and hence the liquidity of the network reduced [7]. 2.3. Routing Algorithms Finding payment paths is one of the core challenges of PCNs. Several algorithms have been proposed with different properties and goals [1], [20], [12], [3], [5], [21]. Many of the algorithms use source routing [1], [20], [12], [3], [5], [21]. Of the remaining algorithms, Flare [20] seems unable to deal with network dynamics and Celer [21] has not been evaluated for more than 100 nodes. The only algorithms based on local information with an indepth analysis are SilentWhispers [12] and SpeedyMurmurs [3]. Both algorithms provide various pri vacy properties with SpeedyMurmurs showing consider ably better performance [3].Hence, we choose SpeedyMurmurs for our attack in vestigation and use FordFulkerson as a baseline. Ford Fulkerson makes a good baseline for the success ratio, however, it results in an unacceptably high overhead to be a suitable algorithm in practice [3]. In the following, we describe SpeedyMurmurs in detail, for more informa tion on an implementation of FordFulkerson suitable for PCNs, please refer to [3], which is also the implementation we use for our evaluation. SpeedyMurmurs. SpeedyMurmurs [3] is a privacy preserving routing algorithm for PCNs based on local knowledge; it consists of three stages. In the ﬁrst stage, n spanning trees are created. The number of spanning trees corresponds to the number of paths a payment can use. Increasing the number of spanning trees may improve the success ratio and privacy properties but comes at a cost of performance as overhead operations will increase as well. The SpeedyMurmurs protocol uses Perlmans’s distributed algorithm for building spanning trees [22]. The protocol starts by selecting the root nodes the details of which are not included in the SpeedyMurmurs paper, but are covered in works such as Byrenheid et al. [23]. Next, the nodes in the network organize into a spanning tree with each node connecting to another that is already in the spanning tree — searching through the topology until it ﬁnds such a node. The newly joined node then alerts its neighbors of its connection and the index of the tree it is connected to. In the second stage, which can be interleaved with the spanning tree generations, nodes construct a network embedding for each spanning tree, i.e., each node receives a coordinate from its parent for each spanning tree based on its position in the respective tree. These coordinates enable deﬁning a distance between two nodes, Uand V, that corresponds to the length of the path when re stricted to the spanning tree. Concretely, for each tree, the root node has the empty vector as coordinate. A child adds a random 64bit number to the vector representing its parent’s coordinate to form its own coordinate. The shortest path between two nodes in a rooted spanning tree is the sum of the length of the paths to their least common ancestor in the tree. Let jujdenote the length of a coordinate uandcpl(u;v)be the common preﬁx length of coordinates uandv,i.e., the number of leading elements they have in common. Then the shortest path length in the tree is a distance function dwith d(u;v) =juj+jvj"
75,Scalable Routing Easy as PIE: a Practical Isometric Embedding Protocol (Technical Report).txt,"We present PIE, a scalable routing scheme that achieves 100% packet delivery
and low path stretch. It is easy to implement in a distributed fashion and
works well when costs are associated to links. Scalability is achieved by using
virtual coordinates in a space of concise dimensionality, which enables greedy
routing based only on local knowledge. PIE is a general routing scheme, meaning
that it works on any graph. We focus however on the Internet, where routing
scalability is an urgent concern. We show analytically and by using simulation
that the scheme scales extremely well on Internet-like graphs. In addition, its
geometric nature allows it to react efficiently to topological changes or
failures by finding new paths in the network at no cost, yielding better
delivery ratios than standard algorithms. The proposed routing scheme needs an
amount of memory polylogarithmic in the size of the network and requires only
local communication between the nodes. Although each node constructs its
coordinates and routes packets locally, the path stretch remains extremely low,
even lower than for centralized or less scalable state-of-the-art algorithms:
PIE always finds short paths and often enough finds the shortest paths.","In the Internet, the tremendous growth of the number of destinations translates into a corresponding growth of the routing tables. The Internet Architecture Board recently recog nized the scalability of routing as being “the most important problem facing the Internet today” [2]. The core routers need an excessive amount of resource and power to store, maintain and perform lookups in huge routing tables. The amount of trafﬁc exchanged between the routers is proportional to the size of these tables, and the complexity of managing some state for every destination in the network results in convergence problems and instabilities. The arrival of IPv6, along with new trends such as ubiquitous and mobile computing, is likely to make the number of potential destinations explode, thus exacerbating this fundamental scalability issue. In addition, there are some other contexts where the scalability of routing can be an important concern, such as large sensor networks in which the nodes have only a very limited amount of memory. There is a fundamental relationship between the size of the state required by a routing algorithm and the quality of the 1This work has been previously published in [1]. The present document contains an additional optional mechanism, presented in Section IIID, to further improve performance by using route asymmetry. It also contains new simulation results.routes that it can ﬁnd. It is wellknown that to accomplish shortest path routing on any network of nnodes, the routing table of each node needs to grow as O(n). Indeed, if we denote by path stretch the ratio of the path length achieved by a routing protocol, divided by the shortest possible path on the graph, then it is known that any protocol that would keep the path stretch in the worst case strictly below three, would require a O(n)bit state at each node as well [3]. As a direct consequence, if we want to signiﬁcantly reduce the state required by routing algorithms in the future, we should consider algorithms that may inﬂate the path lengths. One potential avenue is to design practical protocols that create, for all the nodes of the network topology, some virtual coordinates in a metric space such that the relative position of the nodes can be expressed as a function of their distance. Greedy forwarding consists in forwarding a packet to a node’s neighbor closest to the destination. As this forwarding depends only on the distances between the neighbors of a node and the destination, it is a purely local mechanism. Further, the routing table consists only of the coordinates of a node’s neighbors: This information scales as the maximum degree of the graph times the size of the coordinates. These are typically of the order of O(log(n)), making these so called geographic (orgeometric ) routing schemes very scalable ( log(n)bits are already required to merely name each node in the network). In addition, as the routing decision is a simple comparison of the relative distance between a set of neighbors and a destination, the forwarding decisions are fast and easy to implement. In his famous 1967 smallworld experiment [4], Milgram observes that human beings have the ability to efﬁciently route messages among themselves without having a full view of the topology; by just forwarding the messages to their acquaintances that they think are the closest to the ﬁnal destination . To some extent, the Internet and a large category of random graphs exhibit similar smallworld properties [5]. It is therefore natural to ask whether a more formal and explicit notion of distance can be obtained in the context of computer networks, that ﬁts well the structure of such graphs. LetG= (V;E)denote the graph deﬁned by the topology of the communication network. Vrepresents the set of nodes (routers) and Edenotes the set of bidirectional links connect ing these nodes. Also, consider an embedding space (X;d),arXiv:1305.2190v1  [cs.NI]  9 May 2013that is the metric space Xequipped with the distance d. For each node v2V, deﬁne its set of neighbors Nv, namely:Nv=fw2V;(v;w)2Eg. We recall the deﬁnition of a greedy embedding [6]: Deﬁnition 1.1: A greedy embedding is a mapping f:V! Xsuch that8u;w2V;u6=w: 9v2Nusuch thatd(f(v);f(w))<d(f(u);f(w)): (1) Applied to routing, this simply states that, if the node uis trying to send or relay a packet to the destination w, it will always ﬁnd a neighbor vsuch thatvis closer to wthanu is, and thus that delivering the packet to vbrings it closer to, and eventually at, its destination. Most geographical coordinate systems, including some virtual coordinate embeddings, do not produce greedy embeddings and require mechanisms to recover from local minima. There is much theoretical work (some of which we describe in Section II) that considers whether a topology can be greedily embedded in a space (X;d), and under which conditions. Most of this work focuses on providing guarantees, and does not lend itself to implementation, as a full view of the topology is essential to most results. As a consequence, to our knowledge there exists no routing scheme that is practical, scalable (i.e., requiring an amount of memory polylogarithmic inn), achieves close to optimal path stretch and guarantees the success of routing. Our intent is to present such a scheme. Outline: In the next section, we summarize the related work. In Section III, we present PIE and the embedding protocol. In Section IV, we provide an analysis of PIE. In Section V, we present an evaluation of the performances of PIE. We discuss practical relevance for Internet routing in Section VI and we ﬁnally conclude in Section VII. II. R ELATED WORK "
375,Multipath Approach for Reliability in Query Network based Overlaid Multicasting.txt,"In Application layer multicast (ALM) also called Overlay Multicast,
multicast-related functionalities are moved to end-hosts. The key advantages,
overlays offers, are flexibility, adaptability and ease of deployment [1].
Application layer multicast builds a peer-to-peer (P2P) overlay multicast tree
topology consisting of end-to-end unicast connections between end-hosts. End
users self organize themselves into logical overlay networks for efficient data
delivery. Major concern in designing ALM protocol is how to build and maintain
a topology, to route data efficiently and reliably. We propose here a scheme in
which the topology is built incrementally while maintaining dual feeds of the
media stream to any node from the source with minimum differential delay in
receiving packets from both alternatives. We have made the assumption of
availability of a P2P query search network. This enables building of multicast
tree directly as an overlay. There is no need of maintaining an overlaid mesh
and running multicast routing protocol to maintain a multicast tree in this
mesh. Thus the scheme is much more simplified than in the earlier work on
multicast overlay mesh creation and management and then creation and management
of multicast trees using this mesh.","The internet has seen an unprecedented growth due to  the success of one toone applications such as reliable file  transfer, electronic mail and http based information access  over web. The most of the Internet’s infrastructure is  unicast only, and does not provide efficient support for real  time multicasting applications viz. Internet TV, Video  conferencing, live Lecture Delivery Systems (LLDS) and content delivery networks over Internet. In these  applications, copies of a message need to be transported to  multiple recipients at different locations. IP multicast [2] at  network layer defines an efficient way for multicastin g  whereby the sources transmit only one copy of the data and  intermediate multicast enabled routers make the required  number of copies for onward transmission. However IP  multicast has not been widely deploy ed due to the various  reasons [3 ]. IP multicast r equires routers to maintain per  group state which leads to scaling constraints when  numbers of groups become huge. Although, possibly using  aggregation techniques, the number of states can be  reduced, IP multicast still needs changes at infrastructure  level (deployment/ enabling of multicast routing protocols  in the routers) in the Internet. Internet lacks in multicast  support as it evolved primarily for   unicast applications  since beginning. IP multicast is based on best effort data  delivery, and hence ca nnot support QoS. This is not  desirable in applications where real time synchronous data  delivery is needed such as multi party gaming and multi  party conferencing. The QoS is not possible until it is  implemented in all the lower layers of the network. Finally  IP multicast provides only a limited support for group  management, multicast address allocation and network  management.  In IPv4, multicast is an optional service as it  has matured much later. As a result, most of the networks  have not enabled multica st or provide it as only as a value  added service. The multicast has been mostly limited to  ‘islands’ of network domains under single administrative  control or in local area networks.   Application layer multicast (ALM), also known as  Overlay Multicast is an  attractive alternative solution  where multicast related functionalities are moved to end  hosts. We can see this as a mechanism to provide multicast  services using whatever available unicast network services.  The key advantages, overlays offer, are flexibi lity,  adaptability and ease of deployment. Since the multicast  connections here are based on end hosts, there is no need  of multicast enabled network routers. ALM achieves  multicast via piece wise unicast connections.   A peer topeer (P2P) overlay network is needed for  ALM implementation. In this P2P network, the distributed index of resources is maintained. For ALM  implementation, the resources will typically be end nodes  who can potentially act as media forwarders (equivalent of  multicast routers). Each n ode desirous of receiving the  media feed searches for the resource in distributed index in  P2P overlay, connects to a node having the resource to get  the feed, and then adds itself as a resource provider in the  distributed index.  Once a node is acting as forwarder for  sufficient number of node, it can remove itself from the  distributed index as now it may not able to accept requests  for the feed from the new nodes. It shall be noted that at  any point of time, there are two overlays, one for  maintaining dis tributed resource index, also called query  network and second multicast data transport network.   However ALM incurs a performance penalty over IP  Multicast. Links near the end users carry redundant copy  of data and also the delay to some of the end users is  more  than what would have been in the case of IP multicast. The  major concerns in ALM are how to form an efficient  topology for reliable media transport. Switching off a  single node has a potential to partition the whole overlay  multicast network interrup ting media feed distributions to  some of the subscribing nodes. This problem is prominent  in the multicast topology creation mechanism outlined  above. Here the overlay itself is a tree, and hence failure of  a node will fragment the multicast topology unles s the  recovery mechanism is built. While, in the mesh based  overlays where the multicast tree is created through  separately running multicast routing protocols, the mesh  itself is created in such a way that a node or link failure  does not partition the net work. A streaming application  usually has a playback deadline by which data delivery and  loss recovery have to be accomplished.   To enhance the reliability, we propose here a scheme  in which data forwarding topology is incrementally built.  The topology gov erns the data forwarding in such a way  that it maintains double feed to any node from the source.  These two feeds come f rom two different node disjoint  paths from the source and thus resilient to single failures in   overlay network. For this, we need a quer y search network  with distributed indexing service that maintains the list of  presently active potential forwarders for the two different  feeds. Distributed indexing service based query search  network helps in locating/searching the source for the  desired feeds. Peers form a structured overlay for streaming   media forwarding. Each node maintains a table of next hop  clients to whom media stream has to be forwarded. It also  maintains links with parents from which duplicate feeds  are received.  The algorithm fur ther allows healing of  topology after a failure to keep the two feeds intact to every  node via two node disjoint paths from source.  II RELATED WORK   "
98,An Adaptive and Multi-Service Routing Protocol for Wireless Sensor Networks.txt,"Wireless Sensor Networks (WSNs) are highly distributed networks consisting of
a large number of tiny, low-cost, light-weight wireless nodes deployed to
monitor an environment or a system. Each node in a WSN consists of three
subsystems: the sensor subsystem which senses the environment, the processing
subsystem which performs local computations on the sensed data, and the
communication subsystem which is responsible for message exchange with
neighboring sensor nodes. While an individual sensor node has limited sensing
region, processing power, and energy, networking a large number of sensor nodes
give rise to a robust, reliable, and accurate sensor network covering a wide
region. Thus, routing in WSNs is a very important issue. This paper presents a
query-based routing protocol for a WSN that provides different levels of
Quality of Service (QoS): energy-efficiency, reliability, low latency and
fault-tolerance-under different application scenarios. The algorithm has low
computational complexity but can dynamically guarantee different QoS support
depending on the requirement of the applications. The novelty of the proposed
algorithm is its ability to provide multiple QoS support without
reconfiguration and redeployment of the sensor nodes. The algorithm is
implemented in network simulator ns-2 and its performance has been evaluated.
The results show that the algorithm is more efficient than some of the
currently existing routing algorithms for WSNs.","Recent convergence of technological and application trends  has resulted in an exceptional level of interest in wireless adhoc networks and in particular in wireless sensor networks (WSNs). The push was provided by rapid progress in computation and communication technology as well as the emerging field of low cost, reliable, MEMSbased sensors. The pull was provided by numerous applications that can be summarized under the umbrella of computational worlds, where the physical world can be observed and influenced through the Internet and WSN infrastructures.  Consequently, there have been a number of vigorous research and development efforts at all levels of development and usage of  WSNs, including applications, operating systems, architectures, middleware, integrated circuits, and systems. Typically, WSNs contain hundreds or thousands of sensor  nodes that have the ability to communicate with each other and also with an external base station (BS) [1]. While the sensor nodes have limited sensing region, processing power and energy, networking a large number of such nodes gives rise to a robust, reliable and accurate sensor network covering a wider region. Since the sensor nodes are energyconstrained, a typical deployment of a WSN poses many challenges and necessitates energyawareness at all layers of the networking protocol stack.  For example, at the network layer, it is highly desirable to find methods for energyefficient route discovery and relaying of data from the sensor nodes to the BS such that the lifetime of the network is maximized.   Design of an efficient routing protocol is a particularly  challenging task due to some of the characteristic features of such networks. First, due to large number of sensor nodes, a global addressing scheme cannot be applied and hence IPbased protocols are not applicable.  Second, in contrast to other wireless networks, applications in WSNs require flow of sensed data from multiple sensor nodes (sources) to a particular BS (sink).  Third, sensor nodes are tightly constrained in terms  of energy, processing, and storage capacities and a routing  protocol should minimize the resource consumption. Finally, data collected by many sensors in WSNs is typically based on common phenomena. Hence, there is a high probability that these data have some redundancy. Such redundancy needs to be exploited by the routing protocols so as to improve the energyefficiency and bandwidth utilization.  A large number of routing protocols for WSNs currently  exists in the literature.  These protocols can be classified into multipathbased, querybased, negotiationbased, and qualityofservice (QoS)based depending on the application of the protocol [2]. In this paper, a querybased adaptive routing protocol is proposed that can satisfy multiple QoS requirements such as reliability and latency. Since the algorithm does not involve any complex computation, it is highly energyefficient.   The rest of the paper is organized as follows. Section II  discusses some of the currently existing routing protocols for WSNs. Section III presents the details of the proposed algorithm. Section IV describes the simulation scenarios and the results obtained. Finally, Section V concludes the paper while highlighting some future scope of work. II. RELATED WORK  "
91,Improving Route Discovery Using Stable Connected Dominating Set in MANETs.txt,"A Connected Dominating Set (CDS) based virtual backbone plays an important
role in wireless ad hoc networks for efficient routing and broadcasting. Each
node in the network can select some of its 1-hop neighbors as Multi Point Relay
(MPR) to cover all its 2-hop neighbors. A MPR based CDS is a promising approach
for broadcasting. A node in the CDS consumes more energy and the energy
depletes quickly than non dominating nodes. Although previous CDS construction
algorithms achieve good results in terms of the size of CDS, a minimum size CDS
does not necessarily guarantee an optimal network performance from an energy
efficient point of view. In this paper, we propose a distributed algorithm for
energy efficient stable MPR based CDS construction to extend the lifetime of ad
hoc wireless networks by considering energy and velocity of nodes. We have also
implemented route discovery protocol to make use of the CDS nodes to relay
route request messages. The simulation results show that our algorithm
increases the lifetime up to 25% than previous works and 60% reduction in the
route request messages during route discovery process.","Wireless ad hoc networks are self configuring netwo rks, can be deployed for many applications  such as automated battlefield, search and rescue an d disaster relief.  Mobile ad hoc network  (MANET) consists of wireless nodes that communicate  with each other without any  infrastructure. A communication session is achieved  either through a single hop radio  transmission if the communication parties are withi n the transmission range, or through relaying  by intermediate nodes otherwise. Two important feat ures of an ad hoc network are its dynamic  topology and resource limitation.  These features m ake routing decision very challenging. Every  node in mobile ad hoc networks can move in any dire ction at any time and any speed. A  temporary infrastructure or a virtual backbone can be formed to provide communication. This  virtual backbone may be broken due to the node move ment.   A network can be modeled as a Unit Disk Graphs (UDG ) where two nodes are connected if they  are within each other’s transmission range. To supp ort various network functions, some wireless  nodes are selected to form a virtual backbone. It i s proved that multipoint relaying (MPR) is an  efficient stated for onthefly broadcasting in Mob ile Ad Hoc Networks. The relaying nodes  which are selected by the source node are responsib le for flooding a receiving packet. A  connected dominating set (CDS) consists of all the relay nodes.  Finding connected dominating  International journal on applications of graph theo ry in wireless ad hoc networks and sensor networks  (GRAPHHOC) Vol.4, No.1, March 2012  16   set is a NPhard problem. There are many algorithms  based on MPR to reduce the size of the  CDS. In the original MPR based CDS schemes [1, 2, 1 1, 12, 13], nodes are chosen based on node  id or node degree. The CDS selection has to conside r other information such as energy,  bandwidth and mobility in order to provide suitable  links for some specific applications.      In this paper, we propose an approach to generate quality connected dominating set based on  MPR by considering the energy and link velocity fac tors. There are many works on MPR based  CDS construction [1, 2, 11, 12, 13, 14], but none o f work considered the energy of nodes and  their mobility together for the construction work.      1.1 Problem Definitions  The connected dominating set or virtual backbone is  proposed to facilitate routing, broadcasting  and establishing a dynamic infrastructure. Minimizi ng the CDS produces a simpler abstracted  topology of the MANET and allows for using shorter routes between any pair of hosts.  A  wireless network is usually modeled as a unit disk graph G = (V, E) where V is the set of nodes  and E is the set of links in the network. Each node  has uniform transmission range R. Each node  in V is associated with coordination in 2D Euclide an space.  A wireless link (u,v) ∈ E if and only  if the Euclidean distance between nodes u and v is smaller than transmission range R.      Connected Dominating set:  A subset S ⊆ V is called a dominating set (DS) of G if { v ∈V, either v is in S or has an adjacent  neighbor in S}. The subset S is called Connected Do minating Set if the graph G’, induced by S is  connected i.e, G’[S] is connected.    Multipoint Relay:  For a given a graph G=(V,E) and a node v ∈ V, let N1(v)  and N2(v)  represent the set of 1hop and  2hop neighbors of v, respectively. MPR asks for a minimum size subset MPR of N1(v)  such that   N2(v)  is covered by MPR.     The rest of the paper is organized as follows: Sect ion 2 describes the works related to CDS  construction; Section 3 describes the energy effici ent stable connected dominating set  construction algorithm and route discovery process using CDS nodes. We describe our simulation  environment and the performance metrics in Section 4. Section 5 concludes the paper.    2.  RELATED WORKS   "
176,Efficient and Robust Geocasting Protocols for Sensor Networks.txt,"Geocasting is the delivery of packets to nodes within a certain geographic
area. For many applications in wireless ad hoc and sensor networks, geocasting
is an important and frequent communication service. The challenging problem in
geocasting is distributing the packets to all the nodes within the geocast
region with high probability but with low overhead. According to our study we
notice a clear tradeoff between the proportion of nodes in the geocast region
that receive the packet and the overhead incurred by the geocast packet
especially at low densities and irregular distributions. We present two novel
protocols for geocasting that achieve high delivery rate and low overhead by
utilizing the local location information of nodes to combine geographic routing
mechanisms with region flooding. We show that the first protocol
Geographic-Forwarding-Geocast (GFG) has close-to-minimum overhead in dense
networks and that the second protocol Geographic-Forwarding-Perimeter-Geocast
(GFPG) provides guaranteed delivery without global flooding or global network
information even at low densities and with the existence of region gaps or
obstacles. An adaptive version of the second protocol (GFPG*) has the desirable
property of perfect delivery at all densities and close-to-minimum overhead at
high densities. We evaluate our mechanisms and compare them using simulation to
other proposed geocasting mechanisms. The results show the significant
improvement in delivery rate (up to 63% higher delivery percentage in low
density networks) and reduction in overhead (up to 80% reduction) achieved by
our mechanisms. We hope for our protocols to become building block mechanisms
for dependable sensor network architectures that require robust efficient
geocast services.","Geocasting, transmission of packets to nodes within a certain geographic area, is becoming a crucial  communication primitive for many applications in wireless sensor networks. Geocasting could be used  to assign  tasks to nodes or to query nodes in a certain area. For example, a user may request all sensors in an area where a  fire is spreading to report their temperature. Geocasting could also  facilitate location based services by  announcing a service in a certain region or sendi ng an emergency warning to a region.   In dependable sensor networks, robust geocasting mechanisms may be necessary for the correct operations of  many applications that need the packet to be delivered to all nodes within a region. Sensor networks are expecte d  to be deployed in a wide range of environments, including very harsh environments, therefore robust protocols  should be able to cope with different conditions, such as irregular node distributions, gaps and obstacles. As we  will show , many of the current  geocasting mechanisms become unreliable under these conditions , and robust  geocasting mechanisms that consider these environments need to be developed. By robustness here, we mean  protocols that are able to reach a maximum number of nodes in the region, w hile keeping the overhead low in  order to conserve energy, which is a critical requirement for sensor network applications. In this work, we  develop robust and efficient geocasting mechanisms suitable for different kinds of environments ; these protocols   provide a high level of dependability in sensor networks.       In order to preserve the scarce bandwidth and energy consumption of sensor  nodes  and increase their lifetime , it  is desirable to have efficient geocasting mechanisms with low overhead that are ab le to deliver the data to all  nodes within the geocast region. The challenge is that in order to reach all nodes in the region, the packet may  have to traverse other nodes outside the region causing extra overhead. There is a tradeoff between the ratio of  region nodes reached and the overall overhead incurred due to a geocast transmission. For example, in order to  guarantee that all nodes in the region receive a geocast packet, global flooding , by sending the packet to all nodes  in the network , may be used which causes very high bandwidth and energy consumption , and can significantly  reduce the network lifetime. Other proposed geocast mechanisms that do not rely on global flooding or global  3 information about the network (e.g. [9]) use restricted forwarding zones to limit the number of nodes that forward  the geocast packet, and thus they do not guarantee that all nodes in the region receive the packet. This is more  significant in sparse networks and networks with irregular dis tributions or obstacles, where due to disconnections  in geographical regions it may not be possible  to reach all nodes in the geocast region through a limited  forwarding zone. In this paper we will present a mechanism that achieves guaranteed delivery with out global  flooding and without nodes having global information about the network.   We utilize the geographic location information of nodes to provide two efficient geocast mechanisms with high  delivery. Location awareness is essential for many wireless ne twork applications including geocasting  applications, so it is expected that wireless nodes will be equipped with localization techniques that are either  based on an infrastructure (e.g. GPS) or ad hoc based [6]. Geographic rou ting [8][12] has already shown that  utilizing this location information can provide very efficient routing protocols. In this work we extend the benefits  of geographic routing to geocast application s.  The first mechanism  we propose, Geographic Forwarding Geocast (GFG) , has close tominimum overhead by  combining geographic forwarding with region flooding and is ideal in dense networks or in applications where it  is sufficient to reach only a proportio n of the nodes and guaranteed delivery is not critical. The second  mechanism , Geographic Forwarding Perimeter Geocast (GFPG),  provides guaranteed delivery to all nodes in the  region without global flooding or global information. A n adaptive  version of the second mechanism is presented  which has the desirable property of perfect delivery at all densities in addition to low overhead in dense networks.  Extensive simulations that evaluate our mechanisms show the significant improvements provided.    These mechan isms could be used as building blocks for supporting other architectures that require robust  geocast services. For example, one of our objectives for building a reliable geocasting mechanism was to provide  consistent storage and retrieval  of information in  Rendezvous Regions  [17]. Rendezvous Regions is a geographic  rendezvous  architecture for resource discovery and data centric storage in large scale wireless networks.  In  Rendezvous Regions  the network topology is divided into g eographical regions, where each region is responsible  for a set of keys representing the services or data of interest. Each key is mapped to a region based on a hash  table like mapping scheme. A few elected nodes inside each region are responsible for main taining the mapped  4 information. The service or data provider stores the information in the corresponding region and the seekers  retrieve it from there.  For insertions, we use geocasting to store the information at all the elected servers and for  lookups we  use anycasting  to retrieve the information from any of the servers . In order to achieve consistency  between insertions and lookups , we need a geocasting mechanism that can reach all nodes in the region , otherwise  lookups may query servers that are not rea ched by the insertion geocast . GFPG is a perfect match for providing  the geocasting component in this architecture .  Following is a summary of our contributions in this paper:    The design and evaluation of efficient and robust geocasting protocols that com bine geographic routing  mechanisms with region flooding to achieve high delivery rate and low overhead.    Presenting a guaranteed delivery mechanism based on the observation that by traversing all faces intersecting a  region in a connected planar graph, ev ery node of the graph inside the region is traversed. Although this theorem  is known, the design of a distributed algorithm that practically and efficiently achieves that in a wireless network  is new. Our algorithm is efficient by using a combination of fa ce routing and region flooding , and initiating the  face routing only at specific nodes.    Providing an adaptive mechanism in which nodes perform face routing selectively and only when needed based  on the density and node distribution in their neighborhood to reduce the unnecessary overhead.     Thorough analysis and comparison of the performance of a class of geocasting protocols under different   scenarios.   The rest of the paper is structured as follows. In Section II we show the related work and previously proposed  mechanisms. In Section III we describe the pro posed algorithms in detail. In S ection IV we evaluate the  performance of our mechanisms and compar e to previous mechanisms. Section V contains the conclusions.     5 II. RELATED WORK   "
125,RRDVCR: Real-Time Reliable Data Delivery Based on Virtual Coordinating Routing for Wireless Sensor Networks.txt,"Real-time industrial application requires routing protocol that guarantees
data delivery with reliable, efficient and low end-to-end delay. Existing
Routing(THVR) [13] is based velocity of Two-Hop Velocity and protocol relates
two-hop velocity to delay to select the next forwarding node, that has overhead
of exchanging control packets, and depleting the available energy in nodes. We
propose a Real-Time Reliable Data delivery based on Virtual Coordinates Routing
(RRDVCR) algorithm, based on the number of hops to the destination rather than
geographic distance. Selection of forwarding node is based on packet progress
offered by two-hops, link quality and available energy at the forwarding nodes.
All these metric are co-related by dynamic co-relation factor. The proposed
protocol uses selective acknowledgment scheme that results in lower overhead
and energy consumption. Simulation results shows that there is about 22% and
9.5% decrease in energy consumption compared to SPEED [8] and THVR [13]
respectively, 16% and 38% increase in packet delivery compared to THVR [13] and
SPEED[8] respectively, and overhead is reduced by 50%.","Wireless Sensor Networks has a wide range application  namely, intruder tracking, medical care, health diagnosis and  ﬁre monitoring [ 15]. Industrial communication community  ap plications demands rigid end toend delivery and  reliability [1 0][13 ] under the constraints of wireless  communication. QoS guarantees for Real time application  can be differentiated into two types : rigid and soft real time.  In ri gid real time system, one way delay  tolerance is not  allowed. The arrival of a packet after its speciﬁed end toend  delay is considered as default of system . On other hand, in  soft real time system, a probabilistic QOS guarantee is  expected and delay is tolerated. Therefore , QoS  for Real  time application of  WSNs should guarantee deterministic o r  probabilistic end toend latency. For  realtime application of   WSNs, efﬁciency  of energy  cannot be neglected because  the  sensor nodes have a limited energy.  Sensor nodes radio can  be in active or sle ep state to make it energy efﬁcient, if nodes  are in sleep state, and they are not able to receive or transmit  data during that period. These active or sleep states do not  favour the use of sensor networks in rigid real  time data  delivery. The MAC layer p rovides channel access to the next hop while the net work layer provides the end toend  transmission time. Using cross layer design  approach  optimum results can be obtained  [15].   Motivation: The guaranteed delivery of data with low  endtoend delay and ene rgyefﬁciency is the most  demanding requirement in industrial applications of WSNs.  The traditional QoS routing protocol based on tree based  routing are inefﬁcient for dynamic network  topology/asymmetric lin k charac teristics. The geographically  based routin g achieve maximum packet progress towards  destination within end toend delay. However, it considers  only geographic distance rather than number of hops in the  expenditure of energy and delay. Shortest pathﬁrst  maintains a list of optimal routes between t he source and  destination satisfyin g either reliability or timeli ness.  Hence ,  it is required  to develop  a realtime QoS routing protocol that  guarantees packet delivery within a deadline and lower  energy usage resulting in enhanced lifetime of the network.    Contribution: We have proposed RRDVCR protocol and  the contributions are listed as follows: (i)  Optimum routing  path between source and the destination node is achieved in  terms of the number of hops using virtual coordinates  routing. (ii)  Introduce a ne w dynamic weighting factor that  analyses packets differently, depending on the remaining  time to meet the end toend delay. (iii) A QoS parameter  Maximum Number of Transmission Count [MTX] indicates  link quality between the two nodes. (iv)  Simulation  perfo rmance comparison demonstrates low control overhead  and energy consumption of the proposed RRDVCR protocol.  Organization : The structure of a paper  as follows: Section 2  reviews on related work.  Section 3 gives  system model,  mathematical model and problem d eﬁnition. The proposed  protocol is explained in section 4 . Simulation pa rameters are  listed in section 5 . The simulatio n results discussed  in  section 6 . Conclusions are contained in section 7.  II. RELATED WORK   "
253,"Approximations and Bounds for (n, k) Fork-Join Queues: A Linear Transformation Approach.txt","Compared to basic fork-join queues, a job in (n, k) fork-join queues only
needs its k out of all n sub-tasks to be finished. Since (n, k) fork-join
queues are prevalent in popular distributed systems, erasure coding based cloud
storages, and modern network protocols like multipath routing, estimating the
sojourn time of such queues is thus critical for the performance measurement
and resource plan of computer clusters. However, the estimating keeps to be a
well-known open challenge for years, and only rough bounds for a limited range
of load factors have been given. In this paper, we developed a closed-form
linear transformation technique for jointly-identical random variables: An
order statistic can be represented by a linear combination of maxima. This
brand-new technique is then used to transform the sojourn time of non-purging
(n, k) fork-join queues into a linear combination of the sojourn times of basic
(k, k), (k+1, k+1), ..., (n, n) fork-join queues. Consequently, existing
approximations for basic fork-join queues can be bridged to the approximations
for non-purging (n, k) fork-join queues. The uncovered approximations are then
used to improve the upper bounds for purging (n, k) fork-join queues.
Simulation experiments show that this linear transformation approach is
practiced well for moderate n and relatively large k.","The performance of forkjoin queues is a highly focused re search topic for many years for the ubiquitousness of forkjoin queues in both reallife workﬂows and computing systems. In a forkjoin queueing system, a job is forked intonsubtasks when it arrives at a control node, and each subtask is sent to a single node to be conquered. Results of ﬁnished subtasks are summarized at a central join node. When the job arrival rate is high, a subtask may have to wait for service in the sub queue of its hosting node in a ﬁrstcomeﬁrstserving order. A basic forkjoin queue considers a job is done after all results of the job have been received at the join node (see Fig. 1 (a)). In Big Data era, more and more mainstream computing infrastructures become distributively deployed, and inevitably recruit forkjoin queues to facilitate the storing and processing of largescale datasets. For example: 1) Cassandra [1] and Dynamo [2], two popular keyvalue data stores, use forkjoin queues to concurrently perform read and write operations on all the replicas of the target keyvalue pairs; 2) The client of an(n;k)MDS (maximum distance separable) erasure coding based cloud storage system only needs to retrieve any k This work was supported by the National Key Research Program of China (2016YFB1000600, 2016YFB0501900). Corresponding author is Jianhui Li.out of allnblocks of a ﬁle to reconstruct the ﬁle; 3) The data transmission process of multipath routing protocols can generally be simpliﬁed as a multistage forkjoin queueing process. Latency is commonly a critical concern in building and optimizing Big Data clusters. For example, in Amazon’s cloud platform, services commonly have latency requirements which are in general measured at the 99:9thpercentile of the distribution [2]. The Dynamo storage system must be capable of meeting such stringent SLAs. In this scenario, basic fork join queues may cause serious performance issues when the number of data replicas are large, since they require all the sub tasks of a job to be ﬁnished before making the job’s response. By contrast, (n;k)forkjoin queues, as named in [3], only require the job’s any kout ofnsubtasks to be ﬁnished, and thus have performance advantages in such scenarios. For example, a write request in Casandra can either be responded when a quorum of replicas have been successfully written, or just get responded once the fast answer from all touched replicas is acknowledged when there is a need to pursue high throughputs. As depicted in Fig. 1, there are mainly two versions of (n;k)forkjoin queues: The purging one removes all the remaining subtasks of a job from both subqueues and service stations once it receives the job’s kthanswer. The ﬁle retrieval process from an MDS coded cloud storage system is such an example. As a contrast, the nonpurging one keeps queuing and executing remaining subtasks. For example, a write operation in Cassandra needs to update all the replicas of the target key value pair, while can response to user as soon as a quorum of replicas have been successfully written. a) The StateoftheArt Research on Basic ForkJoin Queues: The popularity of forkjoin systems has drawn great attentions from database/OS/networking communities to the performance analyses of forkjoin queues for a rather long period of time. Unfortunately, there is still no exact closed form solution of the sojourn time of the job in n3basic forkjoin queues. The difﬁculty lies in the fact that the sojourn times of a job’s subtasks are not independent, as their hosting subqueues share the same subtask arrival process. Since most of existing exact analysis techniques are developed for independent and identical (iid) random variables, it is very hard to trace the sojourn time distribution for forkjoin queues.arXiv:1707.08860v7  [cs.PF]  11 Dec 2017ĚĞƉĂƌƚĞĚ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :Žŝ Ŷ ;ϯͿ;ϮͿ;ϯͿ&ŽƌŬ ĞŐŝŶ ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ ĚĞƉĂƌƚĞĚĞŐŝŶ;ϭͿ ƉƵƌŐĞĚ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ¬ ¬ ¬ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ ;ϯͿ;ϮͿ;ϯͿ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ:Žď ĚĞƉĂƌƚĞĚ :Žď ĚĞƉĂƌƚĞĚ ;ϮͿ ;ϭͿ6SOLW­ ­ ­0HUJH;ϯͿ¬ dĂƐŬ;ϭͿƉƵƌŐĞĚ(a) Basic (3;3)ForkJoin Queues ĚĞƉĂƌƚĞĚ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :Žŝ Ŷ ;ϯͿ;ϮͿ;ϯͿ&ŽƌŬ ĞŐŝŶ ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ ĚĞƉĂƌƚĞĚĞŐŝŶ;ϭͿ ƉƵƌŐĞĚ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ¬ ¬ ¬ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ ;ϯͿ;ϮͿ;ϯͿ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ:Žď ĚĞƉĂƌƚĞĚ :Žď ĚĞƉĂƌƚĞĚ ;ϮͿ ;ϭͿ6SOLW­ ­ ­0HUJH;ϯͿ¬ dĂƐŬ;ϭͿƉƵƌŐĞĚ (b) NonPurging (3;2)ForkJoin Queues ĚĞƉĂƌƚĞĚ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :Žŝ Ŷ ;ϯͿ;ϮͿ;ϯͿ&ŽƌŬ ĞŐŝŶ ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ ĚĞƉĂƌƚĞĚĞŐŝŶ;ϭͿ ƉƵƌŐĞĚ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ¬ ¬ ¬ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ ;ϯͿ;ϮͿ;ϯͿ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ:Žď ĚĞƉĂƌƚĞĚ :Žď ĚĞƉĂƌƚĞĚ ;ϮͿ ;ϭͿ6SOLW­ ­ ­0HUJH;ϯͿ¬ dĂƐŬ;ϭͿƉƵƌŐĞĚ (c) Purging (3;2)ForkJoin Queues Fig. 1. ForkJoin Queues: A(1)Is a SubTask of Job A Forn3forkjoin queues under Poisson job arrival pro cess and with iid exponential service time distributions, Nelson et al. [4] proposed an initiative approximation technique which is based on the fact that the sojourn times X1::kof sub tasks 1;2;:::;k are associated variables, whose maximum can be bounded by the maximum of their iid equivalents [5]: P(X1::nt)Qn i=1P(XIID it). According to that, the upper bounds and closedform approximations of the sojourn time were given in this work. Simulation experiments in [6] showed that Nelson’s approximation is still the most reliable one, compared to following works such as [7] and [8]. b) The StateoftheArt Research and Open Challenges on(n;k)ForkJoin Queues: Despite the popularity of (n;k) forkjoin queues in Big Data systems and many other ﬁelds, there are even no practical approximations on the sojourn time of(n;k)forkjoin queues: Unlike the maximum, the kthorder statistic cannot be bounded by using associated variables’ property, which makes the sojourn time of (n;k)forkjoin queues more hard to analyze, compared to basic forkjoin queues. ĚĞƉĂƌƚĞĚ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :Žŝ Ŷ ;ϯͿ;ϮͿ;ϯͿ&ŽƌŬ ĞŐŝŶ ^ĞƌǀŝŶŐ;ϭͿ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ ĚĞƉĂƌƚĞĚĞŐŝŶ;ϭͿ ƉƵƌŐĞĚ;ϭͿ;ϭͿ;ϭͿ ­ ;ϮͿ;ϮͿ;ϮͿ ­ ;ϯͿ;ϯͿ ­  :ŽŝŶ ;ϯͿ&ŽƌŬ¬ ¬ ¬ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ ;ϯͿ;ϮͿ;ϯͿ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ ;ϯͿ;ϯͿ ;ϮͿ;ϮͿ;ϮͿ ;ϭͿ;ϭͿ;ϭͿ)RUN ¬­ ­ ­RLQ;ϯͿ:Žď ĚĞƉĂƌƚĞĚ :Žď ĚĞƉĂƌƚĞĚ ;ϮͿ ;ϭͿ6SOLW­ ­ ­0HUJH;ϯͿ¬ dĂƐŬ;ϭͿƉƵƌŐĞĚ Fig. 2. A (3;2)SplitMerge Queue Currently, there are only exact quantity analyses for purging (n;1)forkjoin queues [9], [10], because such a queue is equivalent to a single queue with ntimes the subqueue’s service rate. For general purging (n;k)forkjoin queues, there are only rough bounds have been given: Joshi et al. [3], [11] resort to the splitmerge queue model (see Fig. 2) to ﬁnd proper upper and lower bounds. Compared to purging (n;k)forkjoin queues, all empty subqueues in the split merge model are blocked and cannot serve subsequent tasks untilksubtasks of the current job are completed, which makes the splitmerge model much easier to trace. However, these splitmerge based bounds tend to be extremely loose when increasingkor the load factor , as we depict in Section IV. Since nonpurging (n;k)forkjoin queues cannot be re duced to the splitmerge model, they are more difﬁcult to analyze, even including (n;1)queues. Recently, Fidler et al. [12] gave nonasymptotic statistical bounds on the sojourn times for nonpurging forkjoin queues. However, no reason able approximations have been proposed.c) Methodology and Contributions: This paper aims at ﬁxing the lack of proper approximations for nonpurging (n;k) forkjoin queues and tackling the uncontrollability of bounds for purging (n;k)forkjoin queues. To achieve these objec tives, we trace forkjoin queues in a fundamental way: The linear relationship between (n;k)forkjoin queues and their basic (k;k);(k+ 1;k+ 1);:::;(n;n)equivalents is depicted for the ﬁrst time; This relationship is then used to bridge the existing approximations for basic forkjoin queues to the approximations and bounds for (n;k)forkjoin queues. Our innovations and contributions are highlighted as fol lows: A brandnew closedform linear transformation technique for jointlyidentical random variables, by which order statistics can be transformed into a closed form linear combination of maxima. Besides, there is no need to assume the independence of variables. The ﬁrst reasonable and practical method to approximate the expected sojourn time of nonpurging (n;k)fork join queues with general service time distributions. This method relies on the cooperation between the linear transformation technique and the existing approximations for basic forkjoin queues. Improvements over the upper bounds on the expected sojourn time of purging (n;k)forkjoin queues, which are gained by resorting the bounds to that of the non purging equivalent (n;k)forkjoin queues. This paper is organized as follows: The linear transforma tion technique is developed in Section II; This technique is then employed in Section III to ﬁnd proper approximations for nonpurging (n;k)forkjoin queues; The ﬂaws of existing bounds for purging (n;k)forkjoin queues and our improve ments over upper bounds are depicted in Section IV; In Section V, we discuss the limitation of this linear transformation technique; Related works are reviewed in Section VI; We conclude this work and point out some promising future research directions in Section VII. II. P RELIMINARIES : LINEAR TRANSFORMATIONS OF ORDER STATISTICS In this section, we consider a family of rvs (random vari ables)X1;X2;:::;Xn(denoted as X1::n) deﬁned on a prob ability space, and let X(n;k)denotes their kthorder statistic, Pkdenotes the possibility P(X1t;X2t;:::;Xkt) andPn;kdenotes the possibility P(X1t;X2t;:::;Xk t;Xk+1> t;Xk+2> t;:::;X n> t). Obviously, Pkis the distribution of the maximum of X1::k.Deﬁnition 1 (JointlyIdentical) .Fornidentically distributed rvsX1::nand8k2[1:: n], if anykarbitrarily chosen rvs keep the same joint probability distribution, these nidentical rvs are named as jointlyidentical rvs. Lemma 1. Fornjointlyidentical rvs X1::n, Pn;k=nX i=kAn;k iPi;18kn; where the const coefﬁcient An;k ican be calculated by the following recurrence: An;k i=( 1 i=k; "
431,Performance Enhancement of Ad Hoc Networks with Janitor Based Routing.txt,"We propose and analyze a new on the fly strategy that discovers, repairs and
maintains routes in hierarchical and distributed fashion called Janitor Based
Routing (JBR). The main motivation behind our JBR protocol is to decrease
flooding and routing overhead and increase efficiencies in packet movement. An
analytical model for the proposed JBR is presented and detailed simulation is
used to observe the performance of JBR. This route discovery and maintenance
protocol clearly achieved improvement in terms of reduction of flooding,
routing overhead, and, hence, provides enhanced reliability.","  An ad hoc network is a class of wireless systems  that consists of independent mobile nodes  communicating with each other over wireless links,  without any static infrastructure such as base  stations. Two nodes that are out of each other’s radio  range communicate through an intermediate node,  which also serves as a router. Since the nodes move  randomly, the topology of the network changes with  time. Dynamically changing topology and lack of  centralized control make the design of an adaptive  distributed routing protocol challenging. Many  protocols have been proposed for mobile ad hoc networks, with the aim of making the route  discovery and route maintenance more efficient [1].  Today, ad hoc networks are becoming popular  because of their 3 “Anys” Any person, Any where  and Any time. But the problem of designing an  efficient routing protocol for wireless systems has  been studied by many researchers. Defense  Advanced Research Projects Agency (DARPA)  supported Packet Radio Network (PRNET) [2] and  Survivable Radio Network (SURAN) [3] projects  provide automatic route setup and maintenance in a  packet radio network with moderate mobility. Recent interests in such networks have resulted in the  formation of a working group within the Internet  Engineering Task Force (IETF) called Mobile Ad  hoc Networking (MANET). This group supports  development of new routing protocols for ad hoc networks apart from tailoring wire line Internet  protocols to ad hoc networks.  The routing protocols for MANET can be  classified as proactive and reactive [4], depending on  how they maintain routing information and how they  respond to topology changes. These protocols, like  Clusterhead Gateway Switch Routing CGSR [5],  Zone Routing Protocol ZRP [6] or Localized Route  Repair LRR [7] if they work efficiently, then they  represent drawbacks in contrast. They surmise that  they will avoid flooding but in essence, the network  overhead increases formidably. The protocols can be  categorized under many characteristics such as the structure, number of routes, possibility of source  routing, route recover mechanisms, beckoning  requirements, stored information, update period,  update information, update destination and packet  propagation method, etc. In this JBR protocol, we  have proved it to be stoic in avoiding flooding.  Proposed JBR protocol also reduces packet and byte  overhead which is elaborated in the analytical model  and simulation performance presented in this paper.  On the fly route discovery algorithms suffer from the  complexity, JBR is immune from them. JBR does  not consume limited network bandwidth also.  Nevertheless, measurement of efficiency in  performance criteria is well beyond from the ad hoc  network’s point of view, which all other protocols promise, eventually stays miles away from JBR.     2. Related works  "
26,Machine Learning Applications in the Routing in Computer Networks.txt,"Development of routing algorithms is of clear importance as the volume of
Internet traffic continues to increase. In this survey, there is much research
into how Machine Learning techniques can be employed to improve the performance
and scalability of routing algorithms. We surveyed both centralized and
decentralized ML routing architectures and using a variety of ML techniques
broadly divided into supervised learning and reinforcement learning. Many of
the papers showed promise in their ability to optimize some aspect of network
routing. We also implemented two routing protocols within 14 surveyed routing
algorithms and verified the efficacy of their results. While the results of
most of the papers showed promise, many of them are based on simulations of
potentially unrealistic network configurations. To provide further efficacy to
the results, more real-world results are necessary.","With the rapid development of the Internet in many areas, higher speed and  larger capacity of the network for new Internet applications are required.  However, some of the traditional network technologies meet bottlenecks when  it comes to satisfying the increasing demand. Meanwhile, machine learning  technologies have shown great potential in many regions in recent years. Based  on this situation, it is worthwhile to research applications of machine learning  in the computer network field.  Network Routing, which determines the route taken by packets from  source to destination [1], plays a critical role in networking for selecting the  path for packet transmission. Different operation policies and objectives  determine which selection criteria we need for choosing or designing the  routing method. Cost minimization, maximization of link utilization, and QoS  provisioning are all common criteria [2]. Normally, traditional routing  algorithms are designed based on one criterion, which do not scale well for  different types of realworld scenarios. For example, as shown in [3], with Open  Shortest Path First (OSPF), all the packets will be delivered via the 100 Mbps  path, and this will waste resources along the other links and lead to network  congestion. We desired development of new algorithms which are better at  utilizing the network resources.  For many years, researchers have devoted themselves to designing routing  algorithms for better reachability, performance, and scalability. One of the  directions is the combination of machine learning technologies and routing  algorithms.  Machine learning can be divided into 3 classes, supervised machine  learning, unsupervised machine learning, and reinforcement learning based on  the popular connectionism [45]. Each of these classes is quickly developing  and evolving in many areas, including medical image processing, computer  vision, and natural language processing. One of their advantages is the huge  potential for improving the scalability for the model, due to the data driven  mechanism. Especially with the development of graph neural networks and  reinforcement learning, there is much research being done in that direction,  mainly because computer network scenarios can be easily described with the  graph, and reinforcement learning can be easily applied for the objective value.  The machine learning technologies can be used in both centralized routing algorithms and decentralized routing algorithms. For each of the classes,  multiple machine learning methods are used in two ways, online and offline.   We aim to give a relatively comprehensive survey for introducing some  novel machine learning applications in routing in computer networks. The  assumption of all the methods in the paper is that they are applications  combining with routing and supervised learning or reinforcement learning  technologies. In section 2, we explain how and why we classify the literature.  In section 3, we give the details, pros, and cons of each paper for each class. In  section 4, we implement and evaluate two approaches, and we explain the  results and interpretations for each method and experiments. In section 5, we  summarize the main results of the paper, together with some discussions on  emerging trends. Section 6 shows the contributions of each team member.  2 Classification  Routing algorithms can be divided into 2 classes: centralized methods and  decentralized methods. In centralized methods, a logically centralized  controller is responsible for observing the network and making routing  decisions. In a decentralized architecture, such as traditional networking, each  router decides how to route its packets, but may exchange messages with other  nodes to learn about the rest of the network. In this paper, we classify the  literatures into these two classes, but we also further subdivide each class into  two subclasses: supervised learning methods (e.g. Convolutional Neural  Networks, Graph Neural Networks, and Recurrent Neural Networks, etc.) and  reinforcement learning methods (e.g. QLearning, Deep QLearning, etc.). The  reasons for these two subclasses are based on classifications of the machine  learning methods from the popular connectionism as mentioned in introduction,  which is the most popular theory for machine learning these years [45].  Generally speaking, the idea of connectionism is from neural biology. It treats  the unit of the machine learning model as the neurons. More details for each  class will be introduced in section 3.  3 Presentation of each class   This section will be divided into 3 parts, including centralized routing  algorithms, decentralized routing algorithms, and comparison of each class. In  the first two subsections, the details of each class are explained based on the  type of machine learning methods, including supervised learning methods and  reinforcement learning methods. For each subclass, the literatures are  introduced based on the time. In the third part of the section, we make a  comparison table to conclude the methods described.  3.1 Centralized Routing Algorithms  3.1.1 Supervised Learning Methods  In 2018, Zirui Zhuang, et al. [6] proposed the GraphAware Deep Learning  based intelligent routing strategy (GADL), which aimed to solve the problems,  such as slow convergence and performance decline when configuring the  complex dynamics condition in networking. The GADL consisted of 2 parts,  including the graph kernel and the convolutional neural network, and they also used a feature processing model to convert the network state measurements into  the representative features. The phases of the method include tracking of the  network state measurements continuously, updating the optimal path,  calculating the optimal path via machine learning method (as shown in [6]).  The experiments showed that GADL had better learning performance than the  previous CNN and DBA models, and the average network latency of it was  lower than OSPF (as shown in [6]) and was more stable than DBA.  In 2019, Gangxiang Shen, et al. [7] proposed the MLassisted Least  Loaded (LL) algorithm which was the combination of the supervised naïve  Bayes classifier and the original LL algorithm to conquer the connection failure  problems within the following situation in circuitswitched networks. The  structure of the MLassisted Least Loaded (LL) algorithm is proposed in [7].  When a request was received, all possible paths between the nodes were  considered. For those which are not already at capacity, the algorithm computed  the current load for each path. It also considered the state of the network if a  connection was established over the path, hypothetically updating the loads.  Then, the naïve Bayes classifier was used to determine how likely a blocked  connection would be in the new network state. The candidate paths were scored  using both the current load and future blocking chance. The algorithm  established the connection over the path with the best overall score and  constantly updated its parameters in response to network events. The  experiments were carried out in an SDNlike fashion with a central control in  charge of evaluating and establishing paths, which showed the MLassisted LL  algorithm outperforms the LL algorithm significantly in NSFNET and ARPA 2 datasets. The results are shown in [7].   In 2019 to 2020, K. Rusek, et al. [89] proposed RouteNet, which was a  novel network model based on graph neural networks (GNNs). In this method,  machine learning was used to help optimize the routing scheme based for the  average delay. The model made use of the ability of GNNs to learn and model  the graphbased information.   It first came up with a way to model the program. It used a set of the links   𝑁={𝑙௜ | 𝑖∈(1,…,𝑛௟)} to represent the network and the routing scheme could  be regarded as by a set of paths 𝑃=൛𝑝௞ | 𝑘∈൫1,…,𝑛௣൯ൟ , where each path  consisted of a set of sequential links 𝑝௞=൫𝑙௞(1),…,𝑙௞(|𝑝௞|)൯  (and 𝑘(𝑖)  is  the index of the 𝑖th link in path 𝑘). GNNs models usually have three basic  functions: message, update, and readout. As for the RouteNet, the update  functions are based on the input routing scheme. The architecture of the  RouteNet is flexible to represent any sourcedestination routing scheme, and  the Recurrent Neural Network (RNN) is used to aggregate link states on paths.  The authors test the model with the QoSaware routing optimization scenario  and achieve good results for both mean delay and packet loss compared to the  traditional shortest path methods.    3.1.2 Reinforcement Learning Methods  In 2016, S. Lin et al. [10] proposed the QoSaware adaptive reinforcement  learning routing method in multilayer hierarchical software defined networks.  The distributed hierarchical control plane architecture was used to reduce the  delay of the controllers, and the QAR algorithm with the help of reinforcement learning could have good timeefficiency with the experiments. The method  worked as described: the switch forwarded the first packet of the flow to the  domain controller and requested the path. The current network state was  updated based on the latest information from the slave controller via  reinforcement learning method. The reinforcement learning offered the feasible  path with the QoS requirements and modified the forwarding tables.  In 2020, Jiawei Wu et al. [11] proposed a deep reinforcement learning and  DDPGbased cognitive routing, a qualityaware algorithm. The goal of the  routing algorithm was to show feasibility and a network simulation utility was  developed to aid further research of cognitive routing algorithms. The method  makes use of the network diagnostic metrics to make routing decisions. The  cognitive routing was used as an extension for the ability to infer the network  state and learn policies based on it. The problem is modeled as a reinforcement  learning (RL) task where the network is the environment, and the routing  controller is the agent. Furthermore, the state is encapsulated as the amount of  traffic (in total size) of data flowing between each pair of routers. The actions  correspond to updating the weights which govern how a router chooses which  interface to forward to. Reward is computed based on the delay, where lesser  delay corresponds to greater reward. Qlearning with Deep Deterministic  Policy Gradient (DDPG) is used to solve the RL task. Wu et al. simulated their  algorithm using a newly developed utility, called RL4net. After simulating, it  was found that both the critic and actor network were able to be successfully  trained. The algorithm displayed a lower average endtoend delay.  3.2 Decentralized Routing Algorithms  3.2.1 Supervised Learning Methods  In 2017, N. Kato et al. [5] proposed a deep learning routing algorithm which  uses the history of network traffic to adaptively route packets. Each node was  the unit for the neural networks. The input of the model was an array of numbers  representing how many packets were forwarded through each node in the  network, and the output was the interface to forward the packet along. The  algorithm worked in three phases. First, OSPF was used to collect training data.  Then, the network was trained using a greedy layerwise approach, with back propagation used to fine tune afterwards. Finally, the network used the trained  networks to make routing decisions. An interesting optimization was that the  networks trained at each node were sent to every edge node, and the path was  decided at the node that receives the packet initially. The deep learning method  outperformed the OSPF baseline on the experimental 16node network.  In 2017, B. Mao et al. [12] introduced the routing strategy based on the  deep learning architecture, Deep Belief Architectures (DBA). The input of the  deep learning model was the traffic pattern observed at each router, and the  pattern was defined as the relationship between the quantity of inbound packets  and the time interval. The DBA consisted of multiple layers of Restricted  Boltzmann Machines (RBM), which included one visible layer and one hidden  layer. As for the training step, they first used the Greedy LayerWise method to  train the model, and then the values of weights and biases were updated based  on gradient descent method to maximize the value of the loglikelihood function. The experiment results showed the method they proposed  outperformed the benchmark method on the performance of the delay,  throughput, and signaling overhead.  In 2018, Geyer and Carle [13] proposed a method for automated protocol  design for automated network control and management. The method was based  on the extension of Graph Neural Network (GNN). The model for distributed  routing protocols had two important aspects, including how to distribute  topology information among different nodes, and how to compute routes given  a topology and link weights. In this model, the interface of the router was  regarded as the additional nodes in the graph and the hidden node  representation storing to the messages from the neighbor nodes contributed to  the destination router we wanted from the routing algorithm. The model used  two algorithms to learn its routing, including shortest path and maxmin routing.  Based on the evaluation results, the approach to the distributed routing  protocols performed good. The accuracy could reach 98% and 95% for the two  routing methods, respectively.  In 2018, D. K. Sharma et al. [14] proposed MLProph, a machine learning  enhanced version of a prior work, PROPHET+, a probabilistic routing approach  for opportunistic networks (OppNets) in which link performance and  connectivity is variable and intermittent. The authors used two alternatives to  enhance PROPHET+, neural networks and decision trees. Each had access to a  variety of input parameters such as buffer capacity, node popularity, and  number of successful deliveries. A neural network was trained for each link,  and the output represents whether successful delivery was likely if the packet  is forwarded along this link. Backpropagation was used to train the networks  against the sample data. The second alternative uses decision trees. Each  decision node divided the sample data into two classes by comparing one of the  inputs to a value, and leaf nodes represented a classification the same as in the  neural network model. Both alternatives outperform PROPHET+ in both  delivery chance and average latency.  In 2019, J Reis et al. [15] proposed a flexible supervised learning  framework via learning paths from optimal Mixed Integer Linear Programming  (MILP) and the trained model incorporating all the path pairs. Instead of always  choosing the shortest path, the Deep Neural Networks method gave the routing  path minimizing the congestion for the network system. The paper formulated  the problem of finding the best path for a given sequence of flows by optimizing  the function for minimizing the congestion of networks with maximum link  utilization and the congestion measurement proposed by Fortz and Thorup [16].  There were two parts in the supervisedlearningbased (SLbased) routing  system, including the deep neural network (DNN) and the postprocessing  routing algorithm. The DNN was used to determine the path, and the post processing model was used to filter the invalid path. The SLmodel took the  concatenation of the features of the flow, including source name, destination  name and bandwidth as input, and output the optimal path according to the  congestion cost for each flow. The dataset used for the model was based on  topology and TMs from GEANT network, and the same information from the  Abilene network. The results of the model greatly outperformed the shortest  path method for both MLU and Fortz metrics. 3.2.2 Reinforcement Learning Methods  In 1993, Justin Boyan et al. [17] proposed an adaptive routing policy based on  Qlearning, called Qrouting. Each node had its own Q function to learn. The  Q function took the destination and candidate next hop node as inputs and  outputted the estimated time to deliver the packet using the next hop. This time  included any queuing and transmission delays. When a packet is forwarded  from node X to Y, Y responded to X with Y’s estimated time of delivery for the  packet. Using this X could in turn update its Q function to account for any  differences in estimated time. (It is similar to distance vector algorithm with  estimated times instead of link costs). The Q function was stored as a 2D table  with a nodes’ neighbors as one dimension and all possible destinations as the  other and the estimated time as the value. Compared to the shortest path, Q routing performed roughly the same under low network load but outperformed  under high load by adapting to avoid congestion. Qrouting was also capable  of adapting to changing network conditions and topology. The equation for  updating the Q value is shown in the Eq. (1), where 𝑄௫(𝑦,𝑑) represents the  time that node x estimates it takes to deliver a packet bound for node d by way  of x’s neighbor node y, q means the packet takes q steps in x’s queue, s means  the steps needed for transmission from x to y, and η is the learning rate [17].               ∆𝑄௫(𝑦,𝑑)=𝜂൫𝑚𝑖𝑛௓∈ே(௬)𝑄௬(𝑧,𝑑)+𝑞௫+𝛿−𝑄௫(𝑦,𝑑)൯          (1)  In 1998, Shailesh Kumar et al. [18] proposed the CQRouting algorithm,  which used the confidence values to improve the quality of exploration for  adaptive packet routing in communication networks. Instead of treating the  learning rate as a constant, CQRouting uses a confidence value for each Q  value to determine the learning rate for each update. The experiments showed  that CQRouting outperformed OSPF, BF, and QRouting on average delivery  time for any kind of load and was more adaptive to the network topology  changes. The equations for updating C value and Q value are shown in the Eq.  (2), Eq. (3),and Eq. (4), where 𝑄௫(𝑦,𝑑)  represents the time that node x  estimates it takes to deliver a packet bound for node d by way of x’s neighbor  node y, q means the packet takes q steps in x’s queue, s means the steps needed  for transmission from x to y, and λ is the constant decay rate[18]. When Q values  are not updated in last step, we use Eq. (3a) to calculate C, otherwise, we use  Eq. (3b).  𝜂(𝐶௢௟ௗ,𝐶௘௦௧)=𝑚𝑎𝑥(𝐶௘௦௧,1−𝐶௢௟ௗ)                       (2)  𝐶௡௘௪= ൜𝜆𝐶௢௟ௗ                                                                                                 (3a) 𝐶௢௟ௗ+𝜂(𝐶௢௟ௗ,𝐶௘௦௧)(𝐶௘௦௧−𝐶௢௟ௗ)                                              (3b)   ∆𝑄௫(𝑦,𝑑)=𝜂(𝐶௢௟ௗ,𝐶௘௦௧)൫𝑚𝑖𝑛௓∈ே(௬)𝑄௬(𝑧,𝑑)+𝑞௫+𝛿−𝑄௫(𝑦,𝑑)൯     (4)  In 2002, Will Newton et al. [19] proposed the NNQRouting algorithm,  which used a neural network approximation to help improve the scalability of  QRouting. The original Qlearning based QRouting algorithm used a table  store the Q function, but this did not scale up. In the paper, the Q function was  replaced by a 3layer perceptron model, where the bits of the source and  destination IP were the input and the output is a linear node intended to  approximate the delay for using the link. Delays and dropped packets (caused by excessive forwarding) were penalties while successful deliveries are rewards  in the Qlearning method. Two training alternatives were used: traditional Q learning off policy was used as well as Sarsa method on policy. The experiment  was an overall failure with each configuration either diverging or not showing  any sense of converging in the best case. It was believed the nonlinear nature  of the neural network caused the Q function to fail to converge.  In 2009, B. Xia et al. [20] proposed the spectrumaware DRQrouting  protocol for routing in multihop cognitive radio networks (CRN). The method  included two adaptive reinforcement learning techniques, QLearning and Dual  Reinforcement Learning. The backward exploration and forward exploration  are used in the model. The Qvalue routing table was used to store the cognitive  nodes to estimate the quantity of the available routes. The method was more  costeffective, and more sensitive to the dynamic routing and avoided the  limitations in ondemand protocols. The experiments showed that their protocol  outperformed the shortest path methods on the metrics of average packet  delivery time in high load condition (>2.5 packets/s).  3.3 Summary  One of the advantages of the centralized routing algorithms is that they can  save the resource. Just one table is built and control all the network routing.  Also, it is easy to modify the routing policies based on the control plane, which  makes the centralized routing algorithm flexible. Besides, since the centralized  routing algorithms based on the full network topology and possibly network  state information, they can take full consideration in a global view. A limitation  depending on the method is needed to communicate with the central controller  for routing decisions. Therefore, when changes happen in the forwarding table,  it needs more time and more capacity to updates. Besides, when it comes the  attack or problem in the control plane, it may have the single point of failure.  In decentralized algorithms, there is no central controller, so some  mechanism must be used to allow access to further network state. Each of the  node will store a forwarding table, and will decide the routing policy for itself,  which means it is more scalable since you can easily modify some parts of the  routing methods by yourself. The methods can adaptively react to the changes  well. But at the same time, the decentralized methods require more space and  there may infinity loop problems.   In most supervised learning methods, the inputs, outputs of the methods,  hyperparameters and how to configure the embeddings must be carefully  constructed. But once we have the good preprocessing, the model is very  scalable. However, in supervised learning methods, training dataset need to be  generated from simulations to make the model work well in realistic scenarios.   A benefit for reinforcement learning is that the methods are often trained  online, reacting to rewards from the environment. They can be continually  learning. However, carefully constructing the rewards and responses function,  like the Q function in Qlearning, is still important. As can see in [19], the  neural network Q function approximator was not sufficient to model the Q function. That is why lots of variant QRouting algorithm come out.  As for the cons and pros for each of the 14 methods, we have made a  "
411,A Performance Analysis of LAR Protocol for Vehicular Ad Hoc Networks in City Scenarios.txt,"In this paper, performance analysis of Location Aided Routing (LAR) protocol
in different city scenarios has been done. The mobility model considered is
Manhattan model. This mobility model used to emulate the movement pattern of
nodes i.e., vehicles on streets defined by maps. Our objective is to provide a
qualitative analysis of the LAR protocol in different city scenarios in
Vehicular Ad hoc Networks. We have considered three different city scenarios
for the analysis of the protocol. The simulation work has been conducted using
the Glomosim 2.03 simulator. The results show that LAR1 protocol achieves
maximum packet delivery ratio is 99.68 % and maximum average end-to-end delay
is 7.319969 ms when the network is sparsely populated. Further, for densely
populated network maximum achieved packet delivery ratio is 87.58% and average
end-to-end delay is 0.017684 ms.","VANET is a special class of Mobile Ad hoc Network  (MANET), where every node is a vehicle moving on the  road.  In this network a node behaves l ike a router to  relay a message from one node to another.  In VANET  mobility of vehicles; structure of the geographical areas  since node movement depends on it, timely delivery of  messages, privacy are very important characteristics.  VANET uses two types o f communication methods  One  from vehicle to vehicle (V2V) and the other is vehicle to  fixed road side equipment (V2R). In both the methods  vehicles can communicate to other vehicles or road side  unit either directly or through multiple hops. This totally  depends on the position of the vehicles [1].  Further, the  road side units (RSU) can also communicate with other  RSU via single or multi hop fashion. The RSU supports  numerous applications like road safety, message delivery;  maintain connectivity by sendin g, receiving or  forwarding data in the network. The main focus of the  VANET is to provide real time and safety applications  for drivers and passengers. By delivering message on  time can minimize road accidents and save total journey  time.  The RSU can impr ove traffic management system  by providing drivers and passengers with vital  information i.e., collision warnings, road sign alarms,  blind turn warning, etc. There are various services  currently support by VANET are internet connections  facility, electroni c toll collection, and a variety of multimedia services. It is desirable that protocols should  maintain the low end toend delay and, high delivery  ratio, low overheads and minimum numbers of hops .     II. RELATED WORKS   "
408,Formal Models of the OSPF Routing Protocol.txt,"We present three formal models of the OSPF routing protocol. The first two
are formalised in the timed process algebra T-AWN, which is not only tailored
to routing protocols, but also specifies protocols in pseudo-code that is
easily readable. The difference between the two models lies in the level of
detail (level of abstraction). From the more abstract model we then generate
the third model. It is based on networks of timed automata and can be executed
in the model checker Uppaal.","Finding routes between nodes within networks is one of the most common tasks in networking. To solve this problem, researchers and engineers have designed dozens of different routing protocols, which specify how routers communicate with each other and distribute information that enables them to select routes between any two nodes. Even though most of these protocols are based on ‘simple’ techniques such as Dijkstra’s shortest path algorithm [11] or the BellmanFord algorithm1, it seems incredibly hard to ensure that the protocols are functionally correct. For example, routing protocols regularly establish nonoptimal routes [31], the protocol AODV can yield routing loops [19] or the Border Gateway Protocol (BGP) can exhibit persistent route oscillations [41]. These examples show that careful protocol analysis is essential. However, a formal analysis needs to be based on an unambiguous model, which often does not exist as “despite the maturity of formal description languages and formal methods for analyzing them, the description of real protocols is still overwhelmingly informal” [42]. We present formal and unambiguous models for the Open Shortest Path First (OSPF) routing proto col [33, 9], a widely used interior gateway protocol. While we are not the ﬁrst to create formal models for OSPF (see Section 7), it is our belief that we present the ﬁrst formal model that covers not only the core functionality of OSPF, but also most other details deﬁned in the protocol standard (Section 4). As usual, that standard [33, 9] is written in English prose and contains ambiguities, which we had to resolve. Our detailed model is written in the process algebra TAWN [6, 7], which we brieﬂy describe in Section 3. It is a variant of standard process algebras, such as CCS [30], CSP [23] or ACP [4]. As for any process algebra, TAWN’s semantics is completely formal and hence our model is absolutely precise (no contradictions, no under/overspeciﬁcations) and free of ambiguities. Moreover, TAWN is particularly tailored for routing protocols such as OSPF and deﬁnes the protocol in pseudocode that is easily readable by any network or software researcher/engineer. Modelling many aspects and details of a routing protocol is important, but for an (initial) formal analysis a more abstract model can be extremely useful. For example, it allows an analysis using model 1First proposed by Shimbel [39]; later Bellman [3], Ford [16] and Moore [34] published the same algorithm.J. Drury, P. H ¨ofner & W. Wang 73 checking techniques, which is infeasible with too many details present, due to state space problems. To this end we present, in Section 5, a second model, also written in TAWN, that abstracts from aspects such as the retransmission of lost messages, the periodic refreshing of link information and the internal hierarchy of subnets. Last but not least, in Section 6, we translate that model into a network of timed automata, which can be executed by the model checker Uppaal [25, 2]. All three models are presented in full in the appendices. 2 The Open Shortest Path First (OSPF) Routing Protocol The Open Shortest Path First (OSPF) protocol [33] is a widely used proactive, linkstate routing protocol used to distribute routing information throughout a single autonomous system. Being a linkstate proto col means that the routers (nodes in the network) exchange topological information about onehop links with their neighbours, i.e. the nodes within transmission range. That information is ﬂooded through the network so that (eventually) every router has a complete picture of available links in the network. This image is used to calculate the shortest/best routes between any two nodes, usually using a variant of Dijkstra’s algorithm [11]. OSPF routers use H ELLO messages to discover neighbouring nodes. H ELLO messages are broadcast at regular intervals by every node and contain, next to the sender’s identiﬁcation, a list of all those nodes that the sender has received H ELLO messages from. These messages are not ﬂooded through the network, but are sent only a single hop from their origin. A node will distribute information about the state of its connections by sending Link State Advertise ments (LSAs). Data received by a router that is used for determining the network topology is stored in the LinkState Database (LSDB) . This database represents the router’s current view of the network topology; it contains the most recently received L SAs from each unique originator. Next to the LSDB, every node maintains a list of discovered neighbours, with whom routing information may be exchanged. Network nodes also use H ELLO messages (or lack thereof) to determine whether neighbours have become inactive or lost connectivity. When a node receives the ﬁrst H ELLO message from a neighbour, it learns of that neighbour’s existence. If the node ﬁnds its own IP address listed within that H ELLO message—meaning that the neighbour is aware of the node’s existence—it checks whether it needs to form an adjacency with that neighbour. The term adjacency describes the relationship between two neighbouring nodes that must exchange all of their topological information—the content of their LSDBs. Eventually, they will have an identical understanding of the network. Not all onehop neighbours will form an adjacency. This is because net work trafﬁc can be greatly reduced by forming as few adjacencies as possible whilst still ensuring that all singlehop neighbours will end up with synchronised LSDBs (through a ‘chaining’ of adjacencies). When two nodes recognise that they need to become adjacent one of them will be nominated as master , the other as slave . It is the master that initiates the exchange of data by sending the necessary informa tion using Database Description ( DBD) messages . The slave sends D BDmessages in response to D BD messages from the master. Once a node has received a full description of the other node’s LSDB, it compares that description with its own LSDB. To resolve inconsistencies between the two LSDBs, such as missing entries, it sends Link State Request (LSR) messages, asking for L SAs containing the newest information available. L SR messages are answered by Link State Update (LSU) messages; they contain the requested L SAs. Each receipt of an L SUmessage is acknowledged by a Link State Acknowledgement (LSACK ) message.74 Formal Models for OSPF Designated routers are used in combination with adjacency to further reduce network trafﬁc. As they are not crucial in the understanding of the main functionality of OSPF we omit a detailed description. Our model follows closely the OSPF speciﬁcation as described in the RFC version 2 [33]; the amend ments described in [9] are taken into account as well. However, many of these changes concern the introduction of IPv6 support—the original speciﬁcation only allowed IPv4—; as we model IP addresses as arbitrary unique identiﬁers the amendments had little effect on our model. 3 The Speciﬁcation Language TA WN One of the standard tools to describe interactions, communications and synchronisations between a col lection of agents, processes or network nodes are process algebras. They provide algebraic laws that allow formal reasoning. We chose to model OSPF using TAWN [6, 7], a timed process algebra speciﬁ cally tailored for wireless networks in general and routing protocols in particular. TAWN ‘extends’ the (untimed) language AWN (Algebra of Wireless Networks) [14], by timing constructs. In fact, the syntax of both algebras is (nearly) identical. Both AWN and TAWN provide the right level of abstraction to model key protocol features, while abstracting from implementationrelated details. As its semantics is completely unambiguous, specifying a protocol in such a framework enforces total precision and the removal of any ambiguity. (T)AWN is tailored for modelling and verifying routing and communication protocols and therefore offers primitives such as unicast andmulticast /groupcast ;it deﬁnes the protocol in a pseudocode that is easily readable—the language itself is implementation inde pendent. Currently the tool support is limited; that is why we present an executable model in Section 6. (T)AWN is a variant of standard process algebras (e.g. [23, 29, 4]) extended with a local broadcast mechanism and a novel conditional unicast operator—allowing error handling in response to failed com munications while abstracting from link layer implementations of the communication handling—and incorporating data structures with assignments; its operational semantics is deﬁned in [14]. We use an underlying data structure (described later) with several types, variables ranging over these types, operators and predicates. First order predicate logic yields terms (or data expressions ) and formu las to denote data values and statements about them. The data structure has to contain the types DATA , MSG,IPandP(IP)ofapplication layer data ,messages ,identiﬁers andsets of identiﬁers . The messages comprise data packets , containing application layer data, and control messages . A network is modelled as a parallel composition of network routers. Several processes may run in parallel on a single router. An entire network is modelled as an encapsulated parallel composition of network nodes. Nodes can only communicate with their direct neighbours, i.e. with nodes that are currently within transmission range. There are three different ways for internode communication: broadcast, unicast, or an iterative unicast/multicast (called groupcast in (T)AWN). Theprocess expressions are given in Table 1. They should be understandable without further expla nation; we add a short description in Appendix A. When designing or formalising a protocol in (T)AWN, an engineer should not be bothered with timing aspects; except for functions and procedures that schedule tasks depending on the current time. Because of this, the only difference between the syntax of AWN and the one of TAWN is that the later is equipped with a local timer now. TAWN assumes a discrete model of time, where each sequential process maintains the local variable nowholding its local clock value—an integer. Only one clock for each sequential process is employed. All (sequential) processes in a network synchronise in taking time steps, and at each time step all local clocks are incremented by one time unit. For the rest, the variable now behaves as any other variableJ. Drury, P. H ¨ofner & W. Wang 75 Table 1: process expressions [20] X(exp1;:::;expn) process name with arguments P+Q choice between process PandQ [j]P conditional process (ifstatement) [ [var:=exp] ]P assignment followed by process P broadcast (ms):P broadcast msfollowed by P groupcast (dests ;ms):P iterative unicast or multicast to all destinations dests unicast (dest;ms):PIQunicast mstodest; if successful proceed with P; otherwise with Q send(ms):P synchronously transmit msto parallel process on same node deliver (data):P deliver data to application layer receive (msg):P receive a message x;P process with valuation VhhW parallel procs. on the same node id:V:R node idrunning Vwith range R NkM parallel composition of nodes [N] encapsulation maintained by a process: its value can be read when evaluating guards, thereby making progress time dependent, and any value can be assigned to it. TAWN does not model clock drift nor clock skew implicitly: however, as nowis a standard variable that can be changed, these concepts could be integrated in a model. As neither of the two concepts is of practical relevance for OSPF we ignore them. 4 A Detailed Model of OSPF Our ﬁrst model, written in the speciﬁcation language TAWN (Section 3), is a detailed rendering of OSPF as described in the Request For Comments (RFC) [33, 9], the defacto standard; only a few abstractions are made. The model is about 165 lines long, split over 9 processes, and uses around 30 functions. Compared to the 244 pages of the RFC, this is a signiﬁcant reduction in size, while being more precise. We do not advocate to abandon a speciﬁcation written in English prose as it often describes the intention and the intuition of protocol designs. However, we believe that many problems of protocol development and speciﬁcation could be avoided if formal protocol descriptions, such as the one presented here, would accompany the textual speciﬁcation. In this section, we describe the abstractions and deviations from the RFC taken, present the overall structure of our model and discuss in detail the TAWN process HELLO , which models all the actions after the receipt of a H ELLO message. The full model is given in Appendix C. 4.1 Abstractions & Deviations In OSPF only certain pairs of nodes will form adjacencies—not to be confused with node connectivity— and share topological information. Although the procedure to ﬁnd these pairs varies with the capabilities of the network in question, such determination always relies on information provided by a network administrator. As we cannot model the intention of a network administrator, we assume the existence of a predicate adj(ip;ip0), which evaluates to true if the nodes ip and ip0are supposed to form an adjacency. To enhance scalability, OSPF allows networks to be split into multiple areas . Some of the nodes that are connected to at least two areas will summarise and share intraarea topological information between the adjoining areas. Usually, the introduction of areas greatly reduces the number of messages sent. For the moment we assume a single area; we plan to add this feature in the future.76 Formal Models for OSPF On top of these abstractions we also make the following assumptions. (a) We assume that every message has a payload of arbitrary size. In reality, as the content of LSDBs can be very large, a node splits the information into smaller fragments before sending and the receivers reassemble these fragments. However, this feature is independent of the core functionality of OSPF. (b) Messages are complete and correct and do not become corrupted (we do allow packet loss, though). (c) Our model focuses on the sharing of L SAs and synchronisation of LSDBs. Since L SAs are only shared via bidirectional connections, we assume all connections to be bidirectional. (d) We abstract from the socalled ﬁghtback mechanism (Sect. 13.4 of [33]), which handles the receipt of selforiginated L SAs. 4.2 Overall Structure The detailed model consists of the 9 processes OSPF ,HELLO ,DBD,SNMIS ,REQ,UPD,ACK,QMSG andQSND . The main process OSPF reads a single message from the input queue. Depending on the type of the message it calls other processes, such as HELLO . The process also sends H ELLO messages at periodic intervals and maintains the node’s LSDB by removing dead neighbours. The process HELLO describes all the actions performed when a H ELLO message is received. This includes updating the relevant inactivity timer and, if the H ELLO message is from a previously unknown neighbour, updating the node’s neighbour list. The process DBD handles incoming D BDmessages. Sending requests for those L SAs from D BD message that do not have a matching partner in the node’s LSDB is among its actions. The process SNMIS describes the actions required when a sequence number mismatch occurs during the adjacencyestablishment procedure. The process REQdescribes the actions following the receipt of an L SRmessage, such as ﬁnding the requested L SAs in the node’s local data, and sending them back to the sender of the message. The process UPDmanages incoming L SUmessages, including the installation of uptodate L SAs in the node’s LSDB, and broadcasting the updated information. The process ACKdescribes the actions taken to handle the receipt of an L SA. The process QMSG models a message queue. As before we have two instances, a queue for incoming messages and one for outgoing processes. The process QSND is responsible for sending outgoing messages that were generated by the other processes described above. 4.3 Handling H ELLO Messages The process OSPF handles the receipt of a message using the expression receive (msg). In case the received message is a H ELLO message, which is tested by the command [msg=hello (ips;sip)], the process HELLO is called. Here, sip is the unique identiﬁer of the sender (usually its IP address) and ips is the actual content of the H ELLO message, listing all onehop neighbours of sip. Next to the content of the received H ELLO message (ips and sip), HELLO maintains the following data: the node’s own identiﬁer ip, a set nbrs of neighbour structures , the LinkState Database lsdb (see Section 2) and a time value hello t that indicates the time at which ip should send the next H ELLO message—remember that H ELLO messages are sent periodically. Each neighbour structure stored in nbrs contains, next to the identiﬁer nip of the neighbour, additional information such as an inactivity timer. The inactivity timer indicates when ip should consider a node nip inactive, and hence when the entry concerning nip should be removed from nbrs. There are seven other ﬁelds that we only discuss in the appendix.J. Drury, P. H ¨ofner & W. Wang 77 HELLO ﬁrst checks whether the sender sip of the H ELLO message is already known,i.e. whether the node has received a H ELLO message sent by sip before. This check is performed using the predicate nbrExist , which takes the set nbrs of neighbour structures and the sender identiﬁer sip as parameters. If sip is unknown (Line 1) the sender is added to the list of known neighbours nbrs, using the function newNBR (Line 2). Afterwards the process determines what to do, by calling the process HELLO —as the predicate nbrExist (nbrs;sip)now evaluates to true, the actions between Lines 5 and 21 are performed. Process 9 Handling H ELLO messages HELLO (ips;sip;ip;nbrs;lsdb;hello t)def= 1.[:nbrExist (nbrs;sip)] /* the sender sip is unknown */ 2. [ [nbrs : =newNBR (nbrs;sip)] ] 3.HELLO (ips;sip;ip;nbrs;lsdb;hello t) 4.+[nbrExist (nbrs;sip)] /* sip is a known neighbour */ 5. [ [nbrs : =setINACTT (nbrs;sip;now+rtdead intvl )] ] 6. [ [ns :=getNS (nbrs;sip)] ] 7. ( 8. [ip2ips^adj(ip;sip)^ns=“Init” ] /* 2WayReceived, start adjacencyforming */ 9. [ [nbrs : =setNS (nbrs;sip;“ExStart” )] ] 10. [ [nbrs : =incDDSQN (nbrs;sip)] ] 11. [ [nbrs : =setDDT (nbrs;sip;now+rxmt intvl )] ] 12. send(sndmsg (genDBD (nbrs;lsdb;sip;ip);fsipg)).OSPF(ip;nbrs;lsdb;hello t) 13. +[ip2ips^adj(ip;sip)^ns“ExStart” ] /* Adjacencyforming already underway */ 14. OSPF(ip;nbrs;lsdb;hello t) 15. +[ip2ips^:adj(ip;sip)] /* 2WayReceived, adjacencyforming not needed */ 16. [ [nbrs : =setNS (nbrs;sip;“2Way” )] ] 17. OSPF(ip;nbrs;lsdb;hello t) 18. +[ip=2ips] /* 1WayReceived */ 19. [ [nbrs : =initNBR (nbrs;sip;“Init” )] ] 20. OSPF(ip;nbrs;lsdb;hello t) 21. ) If the neighbour exists the process ﬁrst resets the inactivity timer for sip in Line 5: the value of now+rtdead intvl identiﬁes the latest time when the ip should have received another H ELLO message from sip. In Line 6, the neighbour state for node sip is distilled from nbrs and stored in the local variable ns. The neighbour state is one of the additional pieces of information in the neighbour structure. It is a string representing the adjacency status of ip and sip; its value is one of the following. Init: ip has received a H ELLO message from sip, but a bidirectional communication is not yet veriﬁed; 2Way: communication has been identiﬁed as bidirectional, but adjdoes not allow adjacency. The remaining values indicate different stages during the creation of an adjacency between sip and ip. ExStart: the ﬁrst step of the adjacencyestablishment procedure, which decides which router is the master, and which is the slave; Exchange: the two routers ip and sip exchange descriptions of their entire LSDBs, using D BDmessages; Loading: nodes compare the received LSDB description with their own and send out L SRmessages to ﬁnd missing information, collect newer information or to resolve conﬂicting information; Full: adjacency is established between ip and sip; the nodes now have identical LSDBs.78 Formal Models for OSPF Depending on the current status between ip and sip, the process HELLO performs different actions. Let us ﬁrst consider the case where the receiver’s ip is listed in the incoming H ELLO message (ip2ips). Lines 9 to 12 are executed when the two routers want to form an adjacency, but the process has not yet begun (the status of ns is “Init”). In this case, the process updates the value of ns to “ExStart” (Line 9), increments the Database Description Sequence Number (DDSQN), which is used to ensure that both nodes correctly communicate a description of their entire LSDB (Line 10), resets the timer for the retransmission of D BDmessages (Line 11), generates and sends a D BDmessage (Line 12) and then returns to the main process OSPF . For the sake of readability we do not detail how D BDmessages are created. However, it is worth mentioning that all messages generated by processes such as HELLO are not sent directly to nodes in transmission range, but they are ﬁrst passed to another process running on the same node, using the primitive send . It is that process that broadcast s,groupcast s and unicast s the message, respectively. The reason for that design is twofold: First, it reﬂects reality as on every router there exists an output queue, which collects and sends messages, using a lowerlevel protocol such as CSMA [24]. Second, sending messages takes time (in reality and in TAWN); if a message would be sent from the process HELLO it could potentially block other incoming message (and their effects). If the nodes sip and ip have already started the adjacencyestablishment procedure—the neighbour state is either “ExStart”, “Exchange”, “Loading” or “Full”—then no further action is required and the process returns to the main process OSPF (Line 14). If ip is listed in ips but the two routers do not want to form an adjacency (Line 15), the neighbour state ns is set to “2Way” (Line 16). No other action is performed and the protocol returns to the process OSPF . The last possible sequence of actions (Lines 19 and 20) is executed if ip is not listed in ips and therefore the sender of the H ELLO message is not aware of the receiver’s existence. In this case the process sets ns to “Init” for the neighbour structure of sip and returns to OSPF . If it was the case that prior to the receipt of this H ELLO message the formula ns >“2Way” evaluates to true, it means that the two nodes had, at the very least, attempted to form an adjacency. Hence Line 19 also wipes any information related to previous adjacencyforming attempts. 5 An Abstract Model of OSPF The model described above is too complex for automated analyses such as model checking. For example, a network consisting of only two nodes needs to exchange 18 messages before reaching a steady state. One of the main reasons for this complexity is that there is a lot of redundancy built into OSPF to protect against message loss. Another contributing factor is that fresh L SAs are created and distributed regularly, even when no topological changes have occurred. If we assume that all sent messages are received2we can simplify the model without changing its core functionality. For example, we no longer need retransmission lists and timers, and we only need to generate L SAs in case of a topological change. The simpliﬁed model comes in at roughly 70 lines, splits over 7 processes and uses only 12 functions. As before, we only present the handling of H ELLO messages; the full model is given in Appendix B. 5.1 Abstractions & Deviations As this model is an abstraction of the previous model, we make the same assumptions as in Section 4. Additionally, we now assume that all sent messages are received. This means that we no longer need to maintain retransmission lists, as their sole purpose is to hold messages that are yet to be acknowledged. 2This is one of the fundamental features of (T)AWN.J. Drury, P. H ¨ofner & W. Wang 79 We are also able to remove acknowledgement messages for the same reason. We assume that all L SR messages will be handled and responded to correctly. Along with that, we further assume that an L SR message can contain multiple L SAheaders. By doing so, a router can request all L SAs needed by sending a single request. According to the RFC all routers should refresh their L SAs at regular intervals by sending out L SUmessages, even if nothing has changed. We assume that this is no longer necessary and remove this functionality. Finally, we assume that each node will form adjacencies with all its one hop neighbours. In terms of exchanging topological information, this is equivalent to assuming that all connections are pointtopoint. 5.2 Handling H ELLO Messages The overall structure is the same as for the detailed model (Section 4.2), with the exception that the processes SNMIS andACKare not needed any longer. The simpliﬁed process HELLO is shown in Process 2. As we no longer have to check whether nodes form adjacencies the process simpliﬁes drastically. Process 2 Handling H ELLO messages (simpliﬁed) HELLO (ips;sip;ip;nbrs;lsdb;hello t)def= 1.[:nbrExist (nbrs;sip)] /* the sender sip is unknown */ 2. [ [nbrs : =newNBR (nbrs;sip)] ] 3. [ [nbrs : =setINACTT (nbrs;sip;now+rtdead intvl )] ] 4. [ [lsa :=newLSA (ip;now;nbrs)] ] /* generate new L SA*/ 5. [ [lsdb :=install (lsdb;flsag)] ] /* install L SA*/ 6. send(sndmsg (upd(flsag;ip);fnipj(nip;)2nbrsg)). /* send L SA*/ 7. send(sndmsg (dbd(fhdr(lsa)jlsa2lsdbg;ip);fsipg)). /* send D BDback to sip */ 8.OSPF(ip;nbrs;lsdb;hello t) 9.+[nbrExist (nbrs;sip)] /* sip is a known neighbour */ 10. [ [nbrs : =setINACTT (nbrs;sip;now+rtdead intvl )] ] 11. OSPF(ip;nbrs;lsdb;hello t) The only case distinction that remains is to check whether router ip has seen messages from the sender sip of the H ELLO message (Lines 1 and 9). In the case that ip has previously received a message from the sender ( nbrExist (nbrs;sip)), the inactivity timer is reset (Line 10) and the process returns to theOSPF process (Line 11), ready to receive another message. These two lines are the only actions that remain of Lines 5–21 in the detailed Process 9. Otherwise, if the message received is the ﬁrst H ELLO message from sip ( :nbrExist (nbrs;sip)), the router ip creates a new neighbour structure (Line 2) and initialises its inactivity timer (Line 3). Taking into account that in the detailed model the process HELLO is called in Line 3, these two lines correspond to Line 2 and Line 5 of Process 9, respectively. Afterwards, ip generates a new L SA(Line 4), adds it to its own database lsdb (Line 5) and sends it out to all of the neighbours it is aware of, which are determined by the formula fnipj(nip;)2nbrsg; here, all onehop neighbours will form an adjacency and there is no lengthy establishment procedure, therefore the nodes are considered adjacent upon discovery. Then, in Line 7, the receiving router ip sends a D BDmessage to the originator sip of the H ELLO message so that they can compare their LSDBs. This is similar to Line 12 of Process 9. However, the data structure of the detailed model is more complex and therefore more assignments and different functions are needed. Finally the process returns to OSPF .80 Formal Models for OSPF 6 An Executable Model of OSPF We translate the simpliﬁed TAWN model into an executable model, which can be used by Uppaal [2, 25], which is an established model checker for networks of timed automata . Uppaal is well suited for an automated analysis of (T)AWN speciﬁcations as it provides (a) two synchronisation mechanisms, which translate to uni and broadcast communication; (b) common data structures, such as arrays and structs, and a Clike programming language to deﬁne updates on these data structures; (c) mechanisms for time. 6.1 Uppaal’s Speciﬁcation Language Uppaal accepts networks of timed automata with guards and data structures as input. The state of the system is determined, in part, by the values of data variables that can be either shared between automata, or local. As for (T)AWN, we assume a data structure with several types, variables ranging over these types, operators and predicates. Each automaton is a graph, with locations, and edges between locations. Every edge has a guard—if not speciﬁed the guard is true —, optionally a synchronisation label, and an update. Synchronisation oc curs via socalled channels. For each channel athere is one label a! to denote the sender, and a? to denote the receiver. Transitions without labels are internal; all others use one of two types of synchronisation. Inbinary handshake synchronisation, one automaton having an edge with a label that has the sufﬁx ! synchronises with a single other automaton that has an edge with the same label including a ?sufﬁx. These two transitions synchronise when both guards are true in the current state, and only then. When the transition is taken both locations change, and the updates will be applied to the state variables; ﬁrst the updates on the !edge, then the updates on the ?edge. If there is more than one possible pair, then the transition is selected nondeterministically. Inbroadcast synchronisation, one automaton with a !labelled edge synchronises with a set of other automata. The initiating automaton can change its location, and apply its update, if the guard on its edge evaluates to true. It does not require a second synchronising automaton. Automata with a matching ? labelled edge have to synchronise if their guard is currently true. They change their location and update the state. The automaton with the !edge will update the state ﬁrst, followed by the other automata. 6.2 TA WN to Uppaal The translation from (T)AWN to Uppaal is more or less straightforward. A possible translation from AWN to Uppaal is sketched in [32].3 The main process OSPF (including the subprocesses it calls, such as HELLO ) of every node in the network is modelled as a single automaton, each having its own data structures such as an LSDB and message buffers. A node’s output queue is modelled as a separate automaton. As a slight optimisation we are able to avoid another automaton for the input queue. A network of nnodes is modelled by n copies of the two automata; each tagged with a unique identiﬁer. The implementation of the data structure deﬁned in TAWN is straightforward. An LSDB for exam ple is an array of LSAs, one entry for every node in the network. An LSA is given by the data type t y p e d e f s t r u c t fi n t [ 0 ,N 1 ] i p ; // identifier of originator i n t [ 0 , age bound +1] age ; // time when the LSA is originated gLSA ; where agedenotes the time when the LSA was generated. 3A similar translation is also mentioned in [13].J. Drury, P. H ¨ofner & W. Wang 81 (a)[ [var :=expr] ]  (b)unicast (expmsg;dip):PIQ Figure 1: Translating TAWN to Uppaal An assignment [ [var :=expr] ]is translated into an edge with a single update, as depicted in Figure 1a. Similarly, the translation of a conditional [j]yields an edge with a single guard. Translating the sending primitives is more complicated as one has to take care of the intended destinations, the connectivity between nodes as well as the exchange of the actual messages. Figure 1b depicts the translation schema forunicast : the locations named PandQstand for subautomata resulting from the translation of the subprocess PandQ;unicast[sip][dip] represents a unique channel where data is sent from node sip todip; the predicate connected characterises the topology—only when the two nodes are connected is the message transferred. When the transition is taken, the sender sipcopies its message to a global variable msgglobal , and the receiver copies it subsequently to its local buffer. As we currently do not have software supporting this translation we perform the translation manually; this allows us to optimise the Uppaal model. For example, a sequence of assignments can be combined into a single edge. A major difference between the (T)AWN and Uppaal models is that in Uppaal message queues can only be of ﬁnite length, which is in contrast to the TAWN model. The local message buffer is modelled as a ﬁxedlength array of messages. Uppaal will give a warning if during model checking an outofbounds error occurs, i.e. if the array was too small. Another difference is that (T)AWN is based on discrete time, while Uppaal uses dense time. It is easy to see that (for our models) an embedding of discrete time into dense time does not cause any problems. We translate the simpler model, presented in Section 5, into an executable Uppaal model. The result ing timed automaton modelling OSPF , including its subprocesses such as HELLO , is presented in Figure 2. Figure 2: Executable Model of OSPF as timed automaton82 Formal Models for OSPF Figure 3: Translation of the process HELLO We have assumed that each node will form adjacencies with all its onehop neighbours; an assump tion that signiﬁcantly decreased the size of our model. For model checking, however, this assumption potentially increases the state space as creating and maintaining adjacencies requires a lot of message passing. 6.3 Handling Hello Messages To illustrate the relationship between TAWN and Uppaal we present the translation of the HELLO process in Figure 3. That ﬁgure is an enlarged version of the rightupper corner of the automaton in Figure 2. For simplicity we skip the data structures and the deﬁnitions of functions occurring in the timed automaton; for the full description see Appendix D. The two edges correspond with the two conditions in Lines 1 and 9 of the process HELLO (Process 2). The outermost edge—the one that states && !nbrsExist() in the second line—combines Lines 1–8 of Process 2 in a single edge. The guard ﬁrst checks that the received message is indeed a H ELLO mes sage ( msg_inqueue[0].msgtype == HELLO ) and then validates whether it received a H ELLO message from the sender using && !nbrsExist() . The latter is a direct translation of Line 1. The remaining actions of Process 2 are translated into simple updates of the data structure. Additionally we have to delete the received H ELLO message from the input queue. This is done by deletemsg_inqueue . The innermost path corresponds directly to Lines 9–11. It describes the scenario where the router has seen a H ELLO message from the sender before. As before, we need the additional action of deleting the H ELLO message. 7 Related Work "
343,Modeling and Evaluating Enhancements in Expanding Ring Search Algorithm for Wireless Reactive Protocols.txt,"In case of high dynamic topology, reactive routing protocols provide quick
convergence by faster route discoveries and route maintenance. Frequent
roadcasts reduce routing efficiency in terms of broadcast cost; Bk, and
expected time cost; E[t]. These costs are optimized using different mechanisms.
So, we select three reactive routing protocols; Ad-hoc On-demand Distance
Vector (AODV), Dynamic Source Routing (DSR), and DYnamic Manet On-demad (DYMO).
We model expanding Ring Search (ERS); an optimization mechanism in the selected
protocols to reduce Bk and E[t]. A novel contribution of this work is
enhancement of default ERS in the protocols to optimize Bk and E[t]. Using
NS-2, we evaluate and compare default-ERS used by these protocols; AODV-ERS1,
DSR-ERS1 and DYMO-ERS1 with enhanced-ERS; AODVERS2, DSR-ERS2 and DYMO-ERS2.
From modeling and analytical comparison, we deduce that by adjusting
Time-To-Live (T TL) value of a network, efficient optimizations of Bk and E[t]
can be achieved.","WMhNs provides accessibility to the users in different rate s of nodes’ mobilities and densities. Routing protocols oper  atedonWMhNsareresponsibleforcalculatingefﬁcientend toend paths. There are two categories of routing protocols ; reactiveandproactive,basedontheirroutingbehavior. Ba nd widthisacriticalissueofwirelessnetworkswhichintrodu ces routingoverhead; routinglatency and routing load, while e s tablishing endtoend paths. So, routing protocols are aim ed to optimize the broadcast ;Bkandexpected consumed time ; E[t]. Reactive routingprotocolssuch as AODV [1], DSR [2] andDYMO[3]aredesignedforhighmobilenetworks. These threeprotocolsoptimizetheirroutingoverheadofblindﬂo od ingbyusingExpandingRing Search(ERS)algorithmduring routediscovery;anoptimizationtechniqueforblindﬂoodi ng. In this paper,we modelroutingoverheadof AODV, DSR andDYMOwiththeiroriginalERSstrategiesasAODVERS1,DSRERS1andDYMOERS1. Theroutingoverheadofreac tive protocolsmainlydependsupon TTLandwaiting time values of ERS. For improving the performance of ERS, we modifytheoriginalERSinAODV,DSRandDYMOasAODV ERS2, DSRERS2 and DYMOERS2. Using NS2, we eval uate performance of selected protocols in different mobili  ties. The selected performance metrics for the protocols ar e throughput,E2EDandNRL.Thesemetricsarecomputedfrom simulationresultstoanalyzethebehaviorprotocolswitht heir original and enhanced ERS algorithms (ERS1 and ERS2 in AODV,DSR andDYMO). 2. RELATED WORKAND MOTIVATION "
397,How to Specify and How to Prove Correctness of Secure Routing Protocols for MANET.txt,"Secure routing protocols for mobile ad hoc networks have been developed
recently, yet, it has been unclear what are the properties they achieve, as a
formal analysis of these protocols is mostly lacking. In this paper, we are
concerned with this problem, how to specify and how to prove the correctness of
a secure routing protocol. We provide a definition of what a protocol is
expected to achieve independently of its functionality, as well as
communication and adversary models. This way, we enable formal reasoning on the
correctness of secure routing protocols. We demonstrate this by analyzing two
protocols from the literature.","A number of protocols have been recently developed to secure the route discovery in mobile ad hoc networks, e.g, [11, 20, 18, 10]. Informally, secure routing proto cols provide mechanisms that prevent adversaries, that is, nodes that deviate from the protocol deﬁnition, from inﬂu encing, controlling,or abusing the route discovery. For ex  ample,adversariesshouldbepreventedfromimpersonating network destinations, advertising unreachabledestinati ons, links that do not reﬂect the actual network connectivity, or misleadingtheirpeersthatadestinationcanbereachedata lower(higher)cost thantheactualone. At ﬁrst, such requirements depend on the functionality of the routing protocol. In spite of a variety of secure rout ingprotocolsforadhocnetworksproposedintheliterature , there is no deﬁnition of what a protocol should achieve in dependently of how it operates. In other words, differing solutionshavebeendevelopedwithouta speciﬁcation. Moreover, the requirements themselves do not capture the characteristics of the communication environment and the adversary. The literature so far assumes mostly a defacto data link layer protocol on top of which the routing protocol operates. At the same time, the capabilities of the adversarieshavenotbeenexplicitlydeﬁned,eitherinterm s ofwhattheadversariesknoworwhatcanbetheiractions. Finally, the security of different protocols has been an alyzed mostly through informal arguments, with a small number of works taking a formal approach [11, 19, 3] but notaddressingallthe abovementionedproblems. Our contribution here is a speciﬁcation, that is, a deﬁ nition of the sought properties for any candidate protocol, independentlyof the protocol’sdesignand mechanisms. In particular,wedeﬁnethepropertiesoftheprotocol’soutpu t, oneormorediscoveredroutes. Wesaythataprotocoliscor rect if it satisﬁes the speciﬁcation. Furthermore, we deﬁne an adversarymodel, also independentof the protocolfunc tionality. In addition,we outline a networkcommunication model that captures the features of the ad hoc paradigm. With these components, we form a framework to enable formal reasoning on the properties of any secure routing protocol. To illustrate this, we analyze two secure routing protocols. Finally,wediscussrelatedandfuturework. 2.System Model 2.1. Network Model Mobilehostsmovefreelywithinsomegeographicalarea and collaborativelysupport the network operation, withou t necessarily pursuing a common objective or running the same application. The network connectivity and member ship can change frequently, and so does the network area reachablebythemigratingmobilehosts. Connectivitymay be intermittent even when hosts are fairly stationary, e.g. , whentheirpeersalternatebetween’sleep’and’active’per i ods. We deﬁne a network node as a processwith (i) a unique identityV, (ii) a public/private key pair EV,DV, (iii) amodule implementing the networking protocols, e.g., rout ing, and (iv) a module providing communication across a wirelessnetworkinterface. Asmobilehostsmayhavemore than one network interface [9], more than one node may run on a mobile host. It is convenient to view mobile ad hoc networksas systems with a single node per mobile de vice;however,such a considerationis notnecessaryforthe resultspresentedhere. We focus on the network operation above the datalink layer. The node communication at the datalink layer is modeled by the following primitives and assumptions, for someradius Randtimeτ. 1.SendL(V,m): transmitsmessage mtonodeVwithin radiusRofthetransmittingnode. 2.BcastL(m): broadcastsmessage mtoallnodeswithin radiusRofthetransmittingnode. 3.Receive L(m): receives message mtransmitted by a nodewithinradius Rofthereceiver; misprocessedat areceiver VifmwasBcastL(m)orSendL(V,m). 4. A link (U,V)exists or it is upwhen two nodes Uand Vare ableto communicatedirectly,i.e., U(V)canre ceive transmissions from V(U). We denote any two nodes connected by an uplink, and thus capable of bidirectionalcommunication,asneighbors. 5. Links are either upordown, and their state does not change faster than the transmission time of a single packet. 6. The network connectivity at a particular instance in timeisthegraph Gcomprisingall uplinks. 7. Transmissions from Uare received by all nodes Vi suchthat (U,Vi)isupduringtheentiredurationofthe packettransmission. 8. Packets are delivered across an uplink within a max imum link delay τ, or they are not delivered at all. In the latter case, the delivery failure is reported to the upperlayerprotocol. Thedatalinklayerhandlestran sient network failures, it retransmits, but it does not duplicatepackets. Communication across the network is dependent on the availabilityof sufﬁcient resources(bandwidth). The shar ed medium implies that knodes within Rof each other con tend and obtain a portion of the bandwidth, in principle, inverselyproportionalto k. We do not assume that the net work provides fairness, which is beyond the scope of this work. In general, the available bandwidthcan ﬂuctuate, be unevenlydistributedamongneighbors,adversariescansel f ishlyattempttotransmitathighratesandthenetworklinkscan be congested. Such failures can either be transient and thus masked by the data link layer, or they can persist and cause messages to be dropped from the nodes’ buffers, or prevent nodes from accessing the medium altogether. The latter case is equivalent to having all affected links at the downstate. The widely adopted IEEE 802.11 speciﬁcation, without the Wireless Equivalent Protocol (WEP) security mecha nism, provides bidirectional communication according to primitives13andsatisﬁes assumptions7and8above.1 In this work, we are concerned with pairwise commu nication across multiple wireless links between a sourceS and adestination T. We denote SandTas theend nodes , and nodes that assist the S,Tcommunication as interme diate nodes . Each node in the network is equipped with a certiﬁcate; the possession of a certiﬁcate2does not convey authorization or does not imply trustworthiness. Rather, i t is a minimum requirement for nodes to engage in secure communicationand providesthe means to authenticate the origin(ortherelay)ofnetworktrafﬁc. Digital signatures provide a straightforward mechanism to authenticate each nodes to all other network nodes. Nonetheless,whichcryptographicprimitives(e.g.,symme t ric or public key) are in use, and which nodes’ public keys a network node knows (or which nodes it shares symmet ric keys with) are orthogonal to our discussion. These are issues relatedwith the implementationofanycandidatese cureroutingprotocol. 2.2. Adversary Model We make no assumptions on the motivation of the net work nodes, which either comply with the protocol rules (benign behavior), or deviate and actively disrupt the net workoperation(maliciousbehavior). Intheformercasewe denote a node as correct, while in the latter as adversary . Adversarieshaveﬁniteprocessingpowerandcannotmount a cryptanalytic attack to compromise a private or a secret symmetric key, or invert oneway or hash functions; as a result, cryptographicprimitives are assumed secure. Give n the above assumptions, we consider two models of active adversaries: independent andarbitrary adversaries. Deﬁnition 1 :Independent adversaries are network nodes thatignoreanddonotreproduceanyreceivedmessagethat doesnotcomplywiththeoperationofthenetworkingproto cols,butcangenerate,modifyorreplayanyothermessage. 1Note that our abstraction of Rdoes not imply an idealized communi cation model; Ris a nominal range of direct wireless communication, yet this varies and depends both onthePhysical Layerprotocol a nd theSignal to Interference and Noise Ratio at thereceiver. 2For a survey of different approaches to equip nodes with cert iﬁcates in the context of ad hoc networks see [14].Noncompliance must be explicitly deﬁned solely with respect to the deﬁnition of the networking protocol. Any messagethatdoesnotfollowtheexpected,protocolspeciﬁ c format or fails one of the employed protocol checks is deemed as noncompliant. We emphasize, however, that trafﬁc is noncompliant if and only if the receiving node can detect that a message does not comply with the proto col; otherwise, messages that appear to be compliant, but actuallyare not,will be processedas compliantby the pro tocol(andthusbyindependentadversaries). Def. 1imposesarestrictionontheactionsofadversaries, in that it disallows their reproducing or modifying and re laying any noncompliant message they receive. Nonethe less,Def. 1allowsadversariestoprocessandthusreplayor modify compliant messages or generate any message dif ferent than the noncompliant ones they received. Further more,itallowsadversariestoactsimultaneously,withthe ir actions(attacks),inspiteoftheabovediscussedconstrai nts, possiblyhavinga compoundeffect. Independent adversaries’ behavior allows malicious be havior and extends, in a sense, benign failure models that considernodecrashes,messageloss(omissionfailures[8] ), and message transmission timing failures, when a pre scribed message is sent too early, or too late, or never [5]. Yet, independent adversarial behavior is protocolaware (butnotprotocolspeciﬁc) and thus it is not outright more generalthanthosefailuremodels.3 As it will becomeclear duringthe protocolanalysis, the model of independent adversaries, with the imposed con straints, servesasa necessaryconditionto achievestrong er protocolpropertiesthanthoseachievedwithoutthemodel’ s constraints on the adversarial behavior. In contrast to Def . 1,wehave: Deﬁnition 2 :Arbitrary adversariesare network nodesthat can generate any message, and replay or modify any re ceivedmessage. Adversariesthatmountrelativelysimpleattacksﬁtinthe model of independent adversaries. Consider an adversary Mwithinthetransmissionrangeofanaccesspointorapeer that allows high bitrate data downloador video stream ac cess.Mcan disrupt the route discovery to ensure that no or few routes are established across its neighborhood and, consequently, little or no network bandwidth is consumed byotherdata ﬂows. Anotherexampleis a nodethat simply discards packets to avoid depleting its own resources (bat tery power or CPU cycles), or an adversary that tampers withandinjectsforgedroutinginformationinanattemptto attractdataﬂowsandinterceptsensitiveinformation. Independentadversarialbehaviorissuchthatitprecludes anyactionasaconsequenceoforbasedonreceiptofanon 3For example, an omissionfailing node could relay a noncom pliant message.compliant message. Within this deﬁnition, one can iden tify preclusion of actions that attempt to assist other ad versariesmountinganattack,if,informally,oneconsider ed noncomplianttrafﬁcattributedtomisbehavior. Incontra st, arbitraryadversariescanperformactionsthatattempttoa s sist ongoingattacksmountedbyotheradversaries. Arbitraryadversariesare moresophisticatedand power fulthan independentones,having,forexample,knowledge of the identities of other adversaries in the network, devot  ingresources(e.g.,routediscoveries)toestablishdirec tand possiblyprivatecommunicationwithotheradversaries,an d exchangingtrafﬁc and informationabout their local execu tionoftheprotocol. Themodelofarbitraryadversariescan encompassarangeofscenarios,fromahandfulofattackers thatcollaboratein tryingto defeatanetworkprotocolsecu  rity mechanism, to adversarial nodes deployed, for exam ple,byanindustrialadversarytodegradeortakeadvantage oftheservicesofanotheroperator,oranenemythathijacks nodesandinjectscompromiseddevicesina battleﬁeld. 3.Routing Speciﬁcation LetNbe the set of network nodes and Ethe set of unordered pairs of distinct nodes we denote as edges or links. Arouteis a sequence of nodes Vi∈N, and edges ei,i+1= (Vi,Vi+1)∈E, for0≤i≤n−1, i.e., route=V0,e0,1,V1,e1,2,V2,...,V n−1,en−1,n,Vn. Re ferring to a route as a sequence of nodes implies that for anytwoconsecutivenodesoftheroute (Vi,Vi+1)∈E. We calla routewith V0≡SandVn≡Tan(S,T)route. The routing protocol input is a pair of nodes, SandT. Lett1andt2> t1be two pointsin time deﬁninga time in terval(t1,t2),withtime t2theinstanceatwhichtherouting protocol returns its output to S. When the protocol returns its output, we say that the protocol discovers a route. De pending on the output form, we distinguish two classes of routediscovery: explicitandimplicit. An explicit route discovery returns a fully and clearly expressed, readily observable (S,T)route, that is a V0,V1,...,V n−1,Vnsequence of nodes. An implicit route discovery is a distributed computation that returns a tuple (Vi,Vi+1,Vn),i= 0,...,n−1,oftheform( currentnode , relay node ,destination ), with each (Vi,Vi+1)∈E. The (S,T)route is not readily apparent, as the protocol out put toSis a(V0,V1,Vn)tuple. Yet, the route is implied through a sequence of nodes Vj,1≤j≤n−1, each of themalsostoringa (Vj,Vj+1,Vn)tuple. We term a protocol performing an implicit or explicit route discovery deﬁned above as a basicrouting protocol. A basic routingprotocol providesthe structure of the route butdoesnotprovideattributesoftherouteoritsconstitue nt nodesandedges. Letf:E→M⊆ ℜbe a function that assigns labels,that is, real values to edges ei,i+1. Each label f(ei,i+1) = mi,i+1∈M, which we denote as a link metric , providesa quantitativedescriptionofthe ei,i+1attribute(s). Forexam ple, a metric can capture the link’s reliability or resistan ce tofailure,calculatedasthefractionofthenumbersofdeli v eredovertransmittedpacketsacrossthelink. The attributesofa routecan be ’summarized’bythe ag gregate of the labels of ei,i+1∈(S,T)route. The aggre gate value is calculated by a function g:M→ ℜ, the routemetric g(m0,1,...,m n−1,n),whoseformisprotocol dependent. The route metric can be, for example, the sum, the product, the minimum, or the maximum of the route’s constituent link metrics. Moreover, we deﬁne li,i+1to be theactualmetric value for ei,i+1, and the aggregate g(l0,1,...,ln−1,n)of the actual link metrics as the actual routemetric. We consider an augmented routing protocol. The input isSandT,andtheoutputisan (S,T)routeand: (i)forex plicit discovery, a sequence of labels {m0,1,...,m n−1,n}, with one label for each link of the (S,T)route, and (ii) for implicit discovery, a route metric g(m0,1,...,m n−1,n) overthe linkmetricsdistributedtothe Vi∈(S,T)route. We are interested in routing protocols that ensure the threepropertiesinDef. 3belowforthediscoveredroute(s) : loopfreedom ,freshness, andaccuracy. Loopfreedomand freshness are relevant to both basic and augmented proto cols, while accuracy is relevant only to augmented proto cols. We term a route discovered by a basic (augmented) protocolascorrectifitsatisﬁesloopfreedomandfreshne ss (loopfreedom,freshness,andaccuracy). Deﬁnition3 : •Loopfreedom : an(S,T)routeis loopfreeif it hasno repetitionsofnodes. •Freshness : an(S,T)route is fresh with respect to an interval(t1,t2)if each of the route’s constituent links isupatsomepointintimeduringtheinterval (t1,t2). •Accuracy : an(S,T)route is accurate with respect to a route metric gand a constant ∆good≥0if |g(m0,1,...,m n−1,n)−g(l0,1,...,ln−1,n)|<∆good. Loopfreedom is selfexplanatory; in our context, the property implies that adversaries cannot manipulate or abusetheroutediscoveryto createloops. Routefreshnessensuresthateachoftheconstituentlinks of the discovered route was uprecently, that is, within a (t1,t2)intervalpriorto the routediscovery. We clarifythat freshnessdoesnotguaranteethatlinkswere upconcurrently orthroughout (t1,t2);alinkcouldgo downimmediatelyaf ter its discovery,or links couldbe alternately upanddown, so that a route may never be intact throughout the (t1,t2)interval. Freshness prevents the discovery of routes com prisinglinksthatexistedatnopoint(were down)duringthe (t1,t2)interval,andyetare ’advertised’byanadversary. Route accuracy provides the additional assurance that the quantitative description of a route reﬂects its actual attributes: the route metric calculated by the protocol is within∆goodfrom the actual route metric. ∆goodis a con stant such that, despite malicious or benign faults that lea d toinaccuratemetricvalues,theroutemetricisstill ’reas on ably’ close to the actual value and meaningful for the pro tocol. The protocol and metricspeciﬁc ∆good≥0is al lowed because, even in a benign network, impairmentscan affectmeasurementsandcalculationsformetricvalues. Ac  curacy prevents adversaries from manipulating the metric values,contributingarbitrarymetricvalues,alteringme trics provided by other intermediate nodes, and misleading end nodesinto believingthat a discoveredrouteis better thani t actuallyis. Thenumberofroutelinks,orhopcount,isaspecialcase of a route attribute, with link metric values mi,i+1= 1 for alli= 0,...,n−1,g()the sum of the mi,i+1, and ∆good= 0. The hop count is trivially given by an ex plicit route discovery. But for an implicit discovery it can beviewedasa routeattribute. We emphasize that routes with the properties deﬁned above are not guaranteed to be adversaryfree. A secure routingprotocolcannotdetectanadversarythatfullyabid es withtheroutingprotocol,andonlylater,onceitbelongsto a utilizedroute,disruptsthedatacommunication[13]. More  over, ensuring the correctness of the discovered routes is orthogonal to the ability to actually discover one or more correct routes. Routes may not be discovered at all times dueto the compoundeffectof adversaries’actionsand net work impairments. We also note that if either SorTis faulty, the protocol does not ensure any of the correctness properties. 4.Secure Routing Correctness We analyze the Secure Routing Protocol ( SRP), an ex plicit, basic protocol [11], and the augmented version of SRP[16]. Using the same framework, we have also an alyzed the DistanceVector Secure Routing Protocol (DV SRP), an implicit augmented protocol [15], and the Secure Link State Routing Protocol (SLSP), an explicit basic pro tocol [12]. These protocols are diverse in terms of their design and functionality (reactive vs. proactive, distanc e vector vs. source routing). However, due to space limita tions,wepresenthereonlytheanalysisofthebasic andthe augmented SRP. The deﬁnitions of the two protocols are givenintheAppendices. We assume that trafﬁc relayed by adversaries that act as raw data (or signal) repeaters is detected, and that eachnode knows its neighbors (identities and keys). Protocols that bound the propagation delay (and thus transmission range and distance) for pointtopoint data link transmis sionscan beused[2]. Theseprotocols,aswell asprotocols that use geographicallocation information, can prevent th e establishmentof’longhaul’linksacrossthenetwork. Suc h attacks, frequently denoted as ’wormhole attacks,’ are not speciﬁc to the operation of particular routing protocols bu t ratherpertaintotheneighbordiscovery. Secureroutingpr o tocolseitherincludeneighbortoneighborauthenticati onas partoftheroutediscovery(e.g.,[18]),orinteroperatea se cure neighbor discovery protocol (e.g., [11]). At the same time, wormhole prevention protocols necessitate authenti  cationof transmissionsbetween neighboringnodes. We do notdwellonthespeciﬁcsofneighbortoneighborauthenti  cation,ascryptographicprimitivesandsystemassumption s vary. Lemma 1 :Routes discovered by SRPin the presence of arbitraryadversariesareloopfree. Proof: LetManarbitraryadversarythatattemptstocreate a loop:Mcan include its own or any other node’s iden tity in the NodeList of theRREQmore than once, it can replay aRREQin an attempt to cause other nodes to re forwardRREQandthusreappendtheirownaddress,orit can receivea RREQwith a loop alreadyformedandrelay it further. In all cases, the duplicate entries in NodeList will be detected by T. Similarly, if Mcreates or relays a RREPwith a loop in the Routelist, the duplicate entries will be detectedby S. Note that intermediatecorrectnodes can also detect the loops in the RREQandRREPpack ets as they relay them; however, it is possible that all S,T trafﬁcisrelayedonlybyadversaries. /square Lemma2 :Routesdiscoveredby SRPinthepresenceofin dependentadversaries are fresh with respect to an interval (t1,t2), wheret1is the point in time at which Stransmit ted aRREQwith identiﬁer Qseeking for T, andt2is the point in time at which Sreceived a RREPin response to thequeryidentiﬁedby Q. Proof: We outline below, for easy reference, the assump tions we rely on, from the system model and the lemma statement: (a) each node can identify the source of each BcastL()andSendL()transmission (nodes know their neighbors), (b) trafﬁc is deemed noncompliant if it does not follow the format of a RREQor aRREPand any of checksin the protocoldeﬁnition fails (Apps. A, B), (c) ad versarialnodesactasindependentadversaries,(d)eachen d node knows its peer end node (identity and key) (Appen dicesA,B). Let anRREPcarrying a Route={Vn−1...,V2,V1} list,andan (S,T)routebeingthe {S,V1,V2,...,V n−1,T} sequence of nodes. Let (Vi,Vi+1)be a link that was neverupduring the (t1,t2)interval, with ViandVi+1either ad versariesor correctnodes. We will showthat nosuch route will be discovered (accepted) by SRP. An adversary can causetheinclusionofsucha linkina RREQ/RREP. First, consider an adversary Vk,k > i+ 1, tamper ing with the NodeList of aRREQit receives, remov ing and/or adding one or more node identities and relaying the tampered RREQ′. WhenTresponds to and returns a RREP,Vi+1executesSendL(Vi,RREP), asRREPap pears compliant with the protocol (Steps 4.14.3). How ever,Vidoes not Receive L(RREP), because (Vi,Vi+1) wasdownat all times during (t1,t2), and thus RREPis never received by S. In the special case that Vkis a neigh bor ofViand executes SendL(Vi,RREP) upon receiving RREP,Viwill reject RREPas noncompliant, because the node now forwarding the RREPis notVi’s succes sor along RREP’sRoute(Step 4.1, (a)(c)), and/or it did notpreviouslyrelaythequerythat VihadBcastL(RREQ) (Steps2.2.4,4.2,assumption(a)). Furthermore,ifanadve r saryMrelayed a tampered RREQ′′such that M/ne}ationslash=Vi, Vi∈NodeList′′, then all Vjnodes and Tthat execute Receive L(RREQ′′)will discard RREQ′′, because the lastnodein NodeList′′isnottheneighborthatrelays(Step 2.3.2,assumptions(a)(c)). Second,consideranadversary Vk,k≤i,tamperingwith theRREQNodeList . Then,Vi+2willdiscard RREQ,ei therbecause Vi+1isnotitspredecessor(Step2.2.2,(a)(c)), or because it detected a duplicate entry in the NodeList (Step 2.2.3), as it must hold that Vk≡Vi+1for the adver sarytoavoidhavingthe RREQdiscarded. Third, consider an adversary Vk,k≤i, that tampers with entries in the RREPRoutelist, removing and/or adding one or more node identities, and then relaying the tampered RREP′. AllVjintermediate nodes with 1≤j < krelayRREP′, since it appears compliant with the protocol. However, Swill discard RREP′, be causefK(S,T,Q,Route′)/ne}ationslash=fK(S,T,Q,Route )(Step 4.5). Furthermore, if an adversary Mrelayed a tampered RREP′′such that M/ne}ationslash=Viand∀Vi∈Route′′, then allVjnodes (and S) that execute Receive L()will discard RREP′′,becausetheirsuccessoralongthe RREP′′Route is not the neighbor that relays RREP′′(Step 4.1, (a)(c)). In the special case that the adversary impersonates T,Vi discards the RREPbecause its successor is not T(Step 4.1,assumptions(a)(c)). Fourth, consider an adversary Vk,k≤i, which, upon receipt of a RREQ, generates a RREP′′′with aRoute′′′ that includes (Vi,Vi+1), andSendL(Vk−1,RREP′′′). All Vj,1≤j < k, intermediate nodes relay RREP′′′, which appearstobe compliantwith the protocol. However, Sdis cardsRREP′′′, because fK(S,T,Q,Route )/ne}ationslash=A′′′, with A′′′the authenticator the adversary appended to RREP′′′ (Step4.5,assumption(d)).Finally, consider an adversary Vk,k≤i, transmitting a RREPgeneratedby Tand identiﬁedby Q′/ne}ationslash=Q. Assum ingthat all (Vj,Vj+1)linksof the RREPRouteareupfor 1≤j < k, all intermediate nodes Vjdeem the RREP compliantandrelayittowards S. However, Smaintainsthe value ofQthat identiﬁes RREQof the current route dis covery (App. A). Thus, it discards any RREPgenerated byTand identiﬁed by Q′/ne}ationslash=Qas noncompliant, because fK(S,T,Q,Route )/ne}ationslash=A′=fK(S,T,Q′,Route)(Step 4.5). Moreover,the adversary cannot forge a RREQfrom Sseekingfor Tandidentiﬁedby Qbeforetime t1,andthus misleadTto respond with a RREPidentiﬁed by Q. As a result, the adversary cannot send such a RREPtoSafter Sactually transmits a RREQidentiﬁed by Q, because T respondswith aroutereplyonlyto RREQwhose originis S(Steps1.1.4,2.3.4,assumption(d)). /square For the augmented version of the protocol, all nodes use the same algorithm to calculate or estimate mi,i+1for their incident links. For (Vi,Vi+1), we denote the met ric calculated by Viasmi i,i+1and the one calculated by Vi+1asmi+1 i,i+1.SRPrequires that mi i,i+1=mi+1 i,i+1or |mi i,i+1−mi+1 i,i+1|< ǫforsomeǫ >0,aprotocolselectable andmetricspeciﬁcthresholdthatdeterminesthemaximum allowablediscrepancybetween mi i,i+1andmi+1 i,i+1. Despite the assumed symmetry of the link, ǫallows for inaccuracy due to network impairments that may affect measurements necessary for the metric calculation. If the metric in use is a ﬁxed, ’administrative’ cost agreed upon between the two neighbors, then mi i,i+1=mi+1 i,i+1must hold. Metrics such as the willingness of the node to relay data, or its remain ingbatterypower,canbedeterminedonlyindependentlyat eachnodeanddonotﬁt intheabovedeﬁnition. Ifg(m1 0,1,...,mn n−1,n) =/summationtextn−1 i=0mi+1 i,i+1, we denotethe function gasgaddand the constant ∆goodas∆add good, if g(m1 0,1,...,mn n−1,n) = max 0≤i≤n−1{mi+1 i,i+1}the func tion is denoted as gmaxand the constant as ∆max good, and ifg(m1 0,1,...,mn n−1,n) = min 0≤i≤n−1{mi+1 i,i+1}asgmin and∆min good. Formi+1 i,i+1>0,g(m1 0,1,...,mn n−1,n) =/producttextn−1 i=0mi+1 i,i+1can be written as gadd(¯m1 0,1,...,¯mn n−1,n), where¯mi+1 i,i+1= log(mi+1 i,i+1), for0≤i≤n−1. Lemma3 :Routesdiscoveredby SRPinthepresenceofin dependentadversariesareaccurate,withrespectto(i) gadd and∆add good=n2ǫ+n˜δ, (ii)gmaxand∆max good=nǫ+˜δ, and (iii)gminand∆min good=nǫ+˜δ, withnthe number of route links, ǫ >0the maximum allowable difference be tweenmi i,i+1andmi+1 i,i+1, and˜δ≥0the maximum error fora metriccalculationbyacorrect node. Proof: Consider an adversary Vithat modiﬁesone or more of theMetricList entries, relaying a RREPwith a tamperedMetricList′.Swilldiscardsucha RREP,because fK(S,T,Q,Route,MetricList′)/ne}ationslash=A′. Next, consider an adversary Vithat tampers with one of the values in the MetricList , forj < i−1, and relays a RREQwith the tampered metric list. The RREQappears as protocol compliant to intermediate nodes and T, which generates a RREP. WhenRREParrivesbackat Vj,mS,i−m′ S,i/ne}ationslash= 0, andVjrejectsRREPasnoncompliant. Moreover, let Vitamper with one of the in the MetricList , forj≥i, and relay RREQwith a tam pered metric list. Then, Vi+1will reject RREQas non compliant, because all mj+1 j,j+1∈MetricList forj≥i must be void, as these entries correspond to links not yet discovered. If Viappended one or more additional entries toNodeList ,RREQwouldbediscardedas Vi’sneighbors Receive L(RREQ)with the last node in NodeList differ entfromitsprecursor(Step2.2.2). Next, consider an adversary Vithat appends an erro neous link metric, with δi≥0denoting the metric calcu lationerrorwith respectto the actuallinkmetric; mi i−1,i= li−1,i±δiandmi i,i+1=li,i+1±δi.Vi−1deems a RREQ/RREPas compliant only if Viappendsmi i−1,i such that |mi i−1,i−mi−1 i−1,i|< ǫ. For the discovery of an (S,T)routewith knodes,theaboveinequalitymustbetrue forall1≤i≤n. Weconsidertheworstcase,with SandT correct,i.e., δ0<˜δandδn<˜δ, and all intermediatenodes adversaries. Then,fortheﬁrstlink |m0 0,1−m1 0,1|=|l0,1±δ0−(l0,1± δ1)|< ǫ⇒δ1< ǫ+˜δ;forthesecondlink, |m1 1,2−m2 1,2|= |l1,2±δ1−(l1,2±δ2)|< ǫ⇒δ2< ǫ+δ1<2ǫ+˜δand, ingeneral, δi< iǫ+˜δ. Similarly, for the route links in the reverse order, |mn−1 n−1,n−mn n−1,n|< ǫ⇒δn−1< ǫ+˜δ, and in gen eralδi<(n−i)ǫ+˜δ. Thus,δi<min{iǫ+˜δ,(n−i)ǫ+˜δ} for1≤i≤n−1. Since˜δdoesnot dependon n,i, andǫ, δi<min{iǫ,(n−i)ǫ}+˜δ. Then,for gadd=/summationtextn−1 i=0mi+1 i,i+1=g(l0,1,...,ln−1,n)±/summationtextn−1 i=1δi±˜δ. The sum is bounded since each δiterm is bounded:/summationtextn−1 i=1δi</summationtextn−1 i=1(min{iǫ,(n−i)ǫ}+˜δ) =/braceleftBigg ǫn2−1 4+(n−1)˜δifnisodd, ǫn2 4+(n−1)˜δifniseven, and we select ∆add good= n2ǫ+n˜δ. Then, for gmaxwe get similarly: gmax = max 0≤i≤n−1{li,i+i±δi+1}=/braceleftBigg max0≤i≤n−1{li,i+1}+max 0≤i≤n−1{δi} max0≤i≤n−1{li,i+1}−min0≤i≤n−1{δi}, and select ∆max good=nǫ+˜δ. And for and gmin:gmin= min 0≤i≤n−1{li,i+i±δi+1}=/braceleftBigg min0≤i≤n−1{li,i+1}+min 0≤i≤n−1{δi} min0≤i≤n−1{li,i+1}−max0≤i≤n−1{δi}, and seFigure 1. Arbitrary adversaries: an illustra tion of two attack conﬁgurations, (a) two ad versaries, (b)k=3 adversaries. lect∆min good=nǫ+˜δ,to completetheproof. /square Theorem 1 :Routes discovered by SRPin the presence of independentadversariesare loopfree,fresh,andaccurat e. Proof: FromLemmas13. /square The assumption of independent adversaries in Theorem 1 is a necessary condition to achieve freshness and accu racy, which cannot be achieved if independence of adver sariesisweakened. Inthepresenceofarbitraryadversarie s, SRPprovidesweakerproperties,discoveringloopfreeand weakly fresh routes . Informally, a route is weakly fresh if there exists a sequence of links, in general different than thosecomprisedbytheroute,witheachofthem upatsome point within the (t1,t2)interval. More precisely, we call an(S,T)route={V0,...,V n}weakly fresh if for some j≥1,k≤n−1, andj < k, there exists a sequence {V′ 0,V′ 1,...,V′ x}of nodes such that V′ 0≡Vj,V′ x≡Vk, andall(V′ i,V′ i+1)wereupat some point during (t1,t2)in terval, and for i < jandk≤i < nall(Vi,Vi+1)wereup atsomepointduring (t1,t2). Theorem 2 :Routes discovered by SRPin the presence of arbitraryadversariesareloopfreeandweaklyfresh. Proof: Lemma1showsloopfreedominthepresenceofar bitrary adversaries. To show weak freshness, it sufﬁces to show that at least a (Vi,Vi+1)link of the discovered route was never upduring the (t1,t2)due to the adversaries’ ac tions, and then show that a sequence of links (V′ i,V′ i+1), 0≤i≤x−1, for some x≥1wasupat some point dur ing the(t1,t2). We show two types of attacks by arbitraryadversariesleadingtosucha route,illustratedinFigure1 . First, in Fig. 1.(a), let {S,X,M 1,Y,M2,Z,T}be an (S,T)route in the network, with X,Y/ne}ationslash=∅,Z, in general sequencesofnodes,and M1,M2two arbitraryadversaries. M1canimplementthefollowingprotocolwhenreceivinga RREQwithNodeList ={X}: Send(RREQ,M 2);BcastL(RREQ);Wait for RREP; M1sendsRREQwithNodeList ={X,M1}directly toM2, as if an (M1,M2)link were up, using a Send() that forwards a message across multiple hops (rather than SendL()).M1can do so in a way that relaying nodes inYcannot identify the payload (e.g., by encrypting the packet). M1also broadcasts RREQ, so that the last node inXaddsM1in itsForwardList and later re lays the corresponding RREP.M2relaysRREQwith NodeList ={X,M1,M2}and later returns RREPwith Route={Z,M2,M1,X}directlyto M1, e.g., routingthe RREPacrossY. Each of the links in Ywasupat some point in (t1,t2), becauseotherwise M1wouldnothavereceivedthe RREP. IfM1,M2were independent, M2would have ignored the RREQsent byM1, as it would not be compliant. Sim ilarly, in a variation of this attack, if M2ﬁrst modiﬁed one or more entries in the RREQ NodeList and then Send(RREP,M 1),M1would have ignored the RREP forthe samereason. Second, in Fig. 1.(b), consider an (S,T)route {X,V,M 1,M2,...,M k,V′,Y}, withMk,k≥2, arbi trary adversaries, and V,V′benign nodes. As long as M1 andMkfollow the protocol, neither VnorV′can discard RREQorRREP. However, any Mi, fori/ne}ationslash= 1,k, can modifyNodeList inanarbitrarymanneranditsufﬁcesthat Mj, forj > i, do not perform the checks required by the protocoland simply relaythe protocolpackets. In contrast , ifMiwere independent, M3for example would have ig noredanynoncompliant RREQit receivedfrom M2. Inallcases,sincethereisatleastonelinkthatwasnever up,andadversariescan’insert’multiplesuchlinksandcon tribute any arbitrary values for their link metrics, accura cy cannotbeachieved. /square 5 Related Work "
328,Routing and Forwarding in nTorrent using ndnSIM.txt,"BitTorrent is a popular communication protocol for peer-to-peer file sharing.
It uses a data-centric approach, wherein the data is decentralized and peers
request each other for pieces of the file(s). Aspects of this process is
similar to the Named Data Networking (NDN) architecture, but is realized
completely at the application level on top of TCP/IP networking. nTorrent is a
peer-to-peer file sharing application that is based on NDN. The goal of this
project is to port the application onto ndnSIM and illustrate the effects of
routing and forwarding.","Named Data Networking (NDN) [18] is a network layer protocol that is being actively researched with the hope of serving as a replacement for the IP protocol. nTorrent [13] is an NDN peertopeer ﬁle sharing application. The current implementation runs with a few modiﬁcations to the base ns 3 network simulator in order to compile and run successfully. The idea behind this paper is to extend the functionality of nTorrent and make it run on top of ndnSIM [14], [12], [11] that features full integration with the NDN Forwarding Daemon (NFD) [8] to simulate routing and forwarding. This paper builds upon work done earlier this year [16] and includes relevant sections of that paper. For consistency, this paper uses the same topologies as that in the nTorrent [13] paper. The code is available at https://github.com/akshayraman/ scenariontorrent. II. R ELATED WORK "
126,Efficient Greedy Geographical Non-Planar Routing with Reactive Deflection.txt,"We present a novel geographical routing scheme for spontaneous wireless mesh
networks. Greedy geographical routing has many advantages, but suffers from
packet losses occurring at the border of voids. In this paper, we propose a
flexible greedy routing scheme that can be adapted to any variant of
geographical routing and works for any connectivity graph, not necessarily Unit
Disk Graphs. The idea is to reactively detect voids, backtrack packets, and
propagate information on blocked sectors to reduce packet loss. We also propose
an extrapolating algorithm to reduce the latency of void discovery and to limit
route stretch. Performance evaluation via simulation shows that our modified
greedy routing avoids most of packet losses.","We consider wireless mesh networks composed of a large numbe r of wireless routers providing connectivity to mobile nodes. They begin to emerg e in some regions to providecheapnetworkconnectivitytoacommunityofenduse rs. Usuallytheygrowin aspontaneous way when users or operatorsadd more routersto increase capa city and coverage. We assume that mesh routers beneﬁt from abundant resources ( memory, energy, computation power, GPS devices in some cases), may only move , quit, or join oc casionally, so that the topology of a typical mesh networks s tays fairly stable. The organizationof mesh networks needs to be autonomic , because unlike the current In ternet, they cannot rely on highly skilled personnel for con ﬁguring, connecting, and runningmeshrouters. Spontaneousgrowthofsuchnetworksm ayresultinadenseand unplannedtopologywith someuncoveredareas. 1EfﬁcientGreedyGeographicalNonPlanarRoutingwith Reac tiveDeﬂection 2 Unliketraditionalapproaches, geographicalrouting presentsinterestingproperties for spontaneous wireless mesh networks: it does not require any information on the global topologysince a node choses the next hop among its nei ghborroutersbased of the destinationlocation. Consequently,the routingschem eis scalable, because it only involves local decisions. Geographical routing is simple, because it does not require routing tables so that there is no overhead of their creation and maintenance. Joining the network is also simple, because a new mesh router only nee ds an address based on its geographicalposition. Such addresses can be obtaine d from a dedicated device (e.g. GPS) or with methodsfor derivingconsistentlocation addressesbased onthe in formationfromneighboringnodesaboutradiosignalstreng th[4]orconnectivity[16]. Themostfamiliarvariantofgeographicalroutingis greedyforwarding inwhichanode forwardsapackettotheneighborclosesttothedestination [2,13]. Greedyforwarding guaranteesloopfreeoperation,butpacketsmaybedropped atblockednodes thathave only neighbors in the backward direction. Blocked nodes app ear at some places near uncoveredareas( voids)orclose toobstaclesto radiowavesin agivendirection. Our main contributionis to proposea new greedyroutingthat correctlydeals with voids. First,we deﬁneanewmechanismtoreactivelydetectv oidsandsurroundthem, which signiﬁcantly reduces packet loss. Moreover, the info rmation of detected voids propagatesbackwardssothatsubsequentpacketstothesame directionbeneﬁtfromthis reactive detection. Second, we propose a mechanism in which voids deviate packets andshortenthelengthofaroutecomparedtoclassicalappro aches. Ourroutingscheme works in any network topology independently of whether it co rresponds to a planar graphornot. We start with the description of the related work on geograph ical routing in Sec tion 2. Section 3 presents the details of the proposed new gre edy routing protocol. Then,we evaluateitsperformanceviasimulationinSection 4andconclude. 2 Related Work "
127,A Channel-Aware Routing Protocol With Nearest Neighbor Regression For Underwater Sensor Networks.txt,"The underwater acoustic channel is one of the most challenging communication
channels. Due to periodical tidal and daily climatic variation, underwater
noise is periodically fluctuating, which result in the periodical changing of
acoustic channel quality in long-term. Also, time-variant channel quality leads
to routing failure. Routing protocols with acoustic channel estimation, namely
underwater channel-aware routing protocols are recently proposed to maintain
the routing performance. However, channel estimation algorithms for these
routing protocols are mostly linear and rarely consider periodicity of acoustic
channels. In this paper, we introduce acoustic channel estimation based on
nearest neighbor regression for underwater acoustic networks. We extend nearest
neighbor regression for SNR (Signal-to-Noise Ratio) time series prediction,
providing an outstanding prediction accuracy for intricately periodical and
fluctuating received SNR time series. Moreover, we propose a quick search
algorithm and use statistical storage compression to optimize the time and
space complexity of the algorithm. In contrast with linear methods, this
algorithm significantly improves channel prediction accuracy (over three times
at most) on both simulation and sea trial data sets. With this channel
estimation method, we then propose a Depth-Based Channel-Aware Routing protocol
(DBCAR). Taking advantage of depth-greedy forwarding and channel-aware reliable
communication, DBCAR has an outstanding network performance on packet delivery
ratio, average energy consumption and average transmission delay which is
validated through extensive simulations.","During the past decade, there has been a signiﬁcant develop ment in underwater acoustic communication, thus inspiring extensive research on underwater sensor networks (UWSNs). At the same time, marine applications on underwater sensor networks, including ocean exploration, submarine tracking, and marine rescue [1]–[3] have gradually matured. Long term and reliable data transmission is the primary research object for UWSNs which faces many challenges: long trans mission delay as the propagation speed of acoustic waves in water is approximately 1500 m/s, which is ﬁve orders of magnitude lower than that of radio frequency [4]; limited bandwidth as it is difﬁcult for the bit rate of acoustic channels to exceed 100 kbps in a longrange system [5]; time variable channel as underwater acoustic channel affected by ambient noise, leading to severe bit error [1].Due to periodical tidal and daily climatic variation, un derwater noise is periodically changing, result in acoustic channel quality changing with a periodical trend in long term. Since underwater acoustic channels are time variable, it is useful to estimate channel anterior to data transmission, in order to explore reliable communication links. Also, time variant channel quality leads to routing failure. Routing with acoustic channel estimation, namely underwater channel aware routing protocols are recently proposed to maintain the performance of routing protocols [6]–[9]. These proto cols are able to investigate a reliable communication path from sources to sinks hop by hop. In channelaware routing protocols, acoustic channel quality estimation is the core process of the best forwarder selection. With a group of quality indicators, channel quality estimation can be mod eled as a time series analysis problem. Simple mean sta VOLUME 4, 2016 1arXiv:2108.05057v2  [cs.NI]  14 Aug 2021Boyu Diao et al. : A ChannelAware Routing Protocol With Nearest Neighbor Regression For Underwater Sensor Networks tistical analysis, exponential moving average (EMA) and autoregression (AR) were adopted for underwater channel quality series analysis. However, these algorithms are linear and rarely consider periodicity of acoustic channels. With periodical tidal and daily climatic variation, underwater noise is changing periodically in longterm [10]. Meanwhile, the ﬂuctuations of SNR values exist intrinsic periodicity in long term underwater communication. In this paper, we consider intrinsic periodicity in longterm underwater acoustic channels and propose the nearest neigh bor regression (NNR) based channel estimation algorithm. Moreover, we propose a depthbased channelaware routing (DBCAR) protocol with NNR channel estimation algorithm. Depthbased routing protocols [11]–[13] are locationfree and stateless which have unstable packet delivery ratios in sparse networks but low transmission delay. On the contrary, channelaware routing protocols have better packet deliv ery rates but high transmission delay. DBCAR with NNR channel estimation provides a more powerful solution with excellent packet delivery ratios while keeping a reasonable transmission delay. In summary, we make two signiﬁcant contributions for underwater acoustic channel estimation and channelaware routing protocols: 1) We introduce NNR for underwater channel quality estimation, and extend NNR for time series analysis, thus providing a better prediction pre cise for intricately periodical and ﬂuctuating received SNR time series. In addition, we use hash table and statistical storage compression to optimize the time and space com plexity of NNR quality estimation algorithm. 2) Based on the NNR quality estimation algorithm, we propose a depthbased channelaware routing protocol, DBCAR. Besides residual energy, we take historical statistical parameters, current SNR gradient, and depth into consideration to explore the best forwarder hop by hop. The accuracy of NNR quality esti mation algorithm has been evaluated through simulations on different SNR ﬂuctuation scenarios and sea trials data sets, including ideal periodic ﬂuctuation, periodic ﬂuctuation with stochastic noises and random periodic ﬂuctuation, and under water experiment data, KW14 and KAM11. The performance of DBCAR has been evaluated through extensive simulations using Bellhop [14] and Aquasim [15]. The rest of the paper is organized as follows. Selected works on acoustic channel estimation methods and channel aware routing protocols are summarized in Section II. Pro posed channel estimation algorithm and a channelaware routing protocol are presented in Section III, including NNR channel quality estimation algorithm, time and space com plexity optimization and DBCAR, a depthbased channel aware routing protocol with NNR. Extensive evaluations and results are analyzed in Section IV. Section V concludes this paper. II. RELATED WORK "
169,Towards Skewness and Balancing of RPL Trees for the Internet of Things.txt,"In many application areas such as large-scale disaster detection, IoT
networks connote the characteristics of LLN (Low power and Lossy Network). With
few exceptions, prior work on RPL(Routing Protocol for LLN), a standard routing
protocol standardized in the IETF, has focused on the evaluation of various
aspects of routing performances and control overheads. In this paper, we
address the problem of DODAG (Destination Oriented Directed Acyclic Graph)
created by the direct application of RPL. We first evaluate the skewness of
DODAG both via numerical simulations and via actual large-scale testbed. RPL
secures its flexibility and wide applicability by allowing the adoption of
implementer-specific rank definitions and parent selection criteria. In
addition to the metrics used in ContikiRPL and TinyRPL, the two most widely
used open source implementations, we evaluated the skewness of RPL trees
generated by applying various routing metrics. Performance analysis results
show that RPL trees suffer from severe skewness regardless of routing metrics
in both randomly generated networks and in real-world networks. We propose a
novel routing protocol that may improve the balance of RPL trees. Rigorous
performance analysis based on computer simulations shows that our algorithm
improves the tree balance significantly.","A. Overview With great progress and development made in information and communication technology, Internet of Things (IoT) and MachinetoMachine (M2M) [1] have merged to provide ubiq uitous communication of smart embedded devices, so that retrieving realtime information can become possible [2] [3]. Due to the great potential brought by M2M and IoT commu nication, they are being considered as the evolutionary change in the ﬁeld of wireless communications. A potential large number of nodes is able to establish lowpower shortrange wireless links, thus forming a capillary network infrastructure This work was supported by the National Research Foundation of Korea (NRF) Grant funded by the Korean Government (MSIP) (No.2016R1A5A1012966, and No. NRF2015R1A2A1A01007400) and by Institute for Information & communications Technology Promo tion(IITP) grant funded by the Korea government(MSIT) (No.2015000557, Resilient/FaultTolerant Autonomic Networking Based on Physicality, Rela tionship and Service Semantic of IoT Devices). Also, this work was partly supported by the Institute for Industrial Systems Innovation of Seoul National University (Corresponding author: DucLam Nguyen, ChongKwon Kim) . DucLam Nguyen is with Social Computer & Networks Laboratory, Depart ment of Computer Science and Engineering, College of Engineering, Seoul National University, 1 Gwanakro, Gwanakgu, Seoul 08826, Republic of Korea. Email: lam@popeye.snu.ac.kr. ChongKwon Kim is with the Department of Computer Science and Engineering, College of Engineering, Seoul National University, 1 Gwanakro, Gwanakgu, Seoul 08826, Republic of Korea. Email: ckim@popeye.snu.ac.kr.that can be connected to the global Internet [4]. A new class of multihop wireless sensor network has emerged that is generally characterized by a resource constrained failureprone architecture and subsequently has given rise to new challenges to provide robustness and resilience [5], [6]. These types of WSN are used in natural disaster monitoring, surveillance and industrial management where a certain reliability should be guaranteed while providing robustness in the presence of harsh surroundings [5]–[12]. The analysis of the different application scenarios has demonstrated that the routing protocol for LLNs should be able to cope with resourceconstraint, quality of service and scalability issues. Several routing protocols have been introduced to ﬁgure out these issues such as AODV [13], Collection Tree Protocol [14], and LOAD [15]. In order to achieve reliable and energy efﬁcient data collec tion, the Internet Engineering Task Force (IETF) has proposed RPL [7] as an IoT routing standard for IPv6 LowPower and Lossy Networks (LLNs). RPL is an oriented distance vector routing protocol that allows users to establish logical routing topology known as a DestinationOriented Directed Acyclic Graph (DODAG) structure, meaning that each node may have one or more than one parent towards the sink. RPL is designed to meet the different requirements of 6LoWPANs, it guarantees a fast network establishment which allows the efﬁcient monitoring of critical applications. RPL is one of the most promising routing solution for a wide range of network types as well as industrial applications such as Smart Gird [16], Building Automation [17], Home Automation [18], and Advanced Metering Infrastructure (AMI) [19]. B. Motivation Recently, RPL provisions several robust features such as selfhealing, loopfree network, and exiguous delay. However, the load balancing has been considered as a weakness in the RPL standard. The routing protocol for LLNs should be lightweight, speciﬁcally in LLNs in which nodes are equipped with highly resourceconstraints and featured short range communication abilities. Thus, high protocol overhead associated with path maintenance and discovery might drain resources quickly and interfere with data transmission. On the one hand, depending on the speciﬁc requirements, different routing metrics and constraints [20] can be adopted such as hopcount [21], latency, energy consumption or ex pected transmission count (ETX) [22]. Routing path construc tion relying solely on a single pairwise transmission quality metric may not be able to capture the real communication scenarios. The sizes of the networks necessitate the need toarXiv:1903.01839v1  [cs.NI]  5 Mar 20192 ,QWHUQHW haibg ec kf /%5 //1%RUGHU5RXWHU53/6LQN 53/1RGHV6WDQGDUG &RPSXWHU //1d 5RXWLQJ6XEWUHH67 67 67 67 Fig. 1: An example of IoT multihop LLN . The LLN is connected to Wide Area Network (WAN) which might be public global Internet via LBR (LLN Border Router). In this example, the LLN includes one sink (DODAG root), 10 source nodes, and several subtrees namely ST1 ( ST¹cº), ST2 ST¹bº, ST3 ( ST¹aº), ST4 ( ST¹dº) and so on. communicate over multiple hops requiring higher layer proto col support. Reliable and efﬁcient of communications in large LLNs has yet to be sufﬁciently addressed [4]. Potential future applications will inevitably require the need to communicate beyond the range of sinks and require larger networks than that are supported recently. The fact that largescale LLNs are not common is likely due to lack of support from current protocols and approaches, so motivating our research. On the other hand, LLNs are resourceconstraint networks, it is a requirement of RPL to be energy efﬁciency. So that, RPL needs to balance not only the trafﬁc load but also the number of connections of each node to provide fair energy consumption among nodes. RPL is designed for LLNs and performs routing in a distributed way, however, the load balancing feature is missing in RPL. Without load balancing the data trafﬁc and the distribution of wireless sensor nodes in LLNs may result in signiﬁcant unbalance for those nodes that have more neighbor nodes than others. As mentioned above, in largescale networks, the nodes close to the gateway often handle heavy trafﬁc load even others generate lightly trafﬁc load. Thus, this results in gaps and holes in the whole network and causes the disconnected of the network connection. It leads to RPL needs to address the load imbalance problem. C. Key Idea The key idea of this study is that we investigate the topology construction of RPL not only using casual metrics as standard RPL but also exploiting the skewness and balancing to apply the combination of metrics. We achieved the balance and the stability by taking into account the size of DODAG subtrees for selecting each parent candidate in the parent selection procedure. We deﬁned a new speciﬁc metric representing for the inﬂuence of parent candidates to new joining nodes for routing procedure. In detail, a node willing to join DODAG should consider both the link quality with parent candidates and the inﬂuence of parent candidates to joining node, so the stability and balancing of routing path are guaranteed and reliable. The detail is described in Section III.D. Contributions With the aforementioned motivations and ideas, we propose SBRPL, standing for Skewness and Balancing of RPL Trees for IoT networks, a new extension of RPL that provides enhanced support for largescale network and incorporates the load balance mechanism into RPL. SBRPL is able to effectively increase the endtoend reliability as well as the network balance. We implemented SBRPL in ContikiOS [23] and conducted extensive numerical simulations using Contiki Cooja simulator and experiments using actual largescale testbed FITIoT Lab [24] with 100 nodes ArmM3Cortex [25]. In total, our evaluation based on around hundreds of individual simulations and experiments, the duration is from one to two hour per experiment1. Our evaluation shows that SBRPL improves not only skewness and balancing of RPL trees but also reliability and endtoend delay signiﬁcantly in comparison with existing RPL studies in both practical experiments and simulations. The main contributions of this paper can be summarized as follows: 1) We proposed SBRPL, the ﬁrst work that investigates skewness and balancing and evaluates the performance in both Cooja simulation environment and practical largescale FITIoTLab platform of Lille, France. SB RPL exploits the combination of multiple metrics and skewness for routing efﬁciency in RPL DODAG (Sec tion III.D). 2) SBRPL uses extended control message structures based on the standard structure deﬁned in the speciﬁcation of RPL. This makes sure that our proposed scheme SBRPL is interoperable with standard RPL, thus LLN devices using standard RPL or SBRPL can operate together seamlessly in a hybrid environment (Section III.C). 3) Our proposed scheme SBRPL not only improves the skewness and balancing among subtrees in a DODAG but also supports adaptivity and mobility of the network without requiring speciﬁc statical assumptions on the Objective Functions. This factor is convenient for imple mentation in the actual environment because Objective Functions in IoT applications can be widely dissimilar. On the other hand, there is no any constraint on the designs of Objective Functions in the speciﬁcation of RPL, it keeps opening for new researches (Section IV). 4) We implemented SBRPL in ContikiOS which is an open source operating system for IoT and LLNs. Via extensive computer simulations using Contiki’s network simulator and realworld experiments on the FIT IoT LAB testbed, we proved that our proposed scheme signiﬁcantly outperforms the existing methods in terms of reliability, adaptability to network balance of LLNs under various scenarios(Section IV). 1In terms of simulation, with the largescale networks, one hour in simulator can equivalent to several hours in reallife.3 E. Paper Organization The remainder of our paper is structured as follows: Section II provides prior works in this area. Our proposed scheme named SBRPL is described in Section III. In particular, it covers high level detail of RPL protocol and we describe our SBRPL protocol more speciﬁc. Section IV presents results from the performance evaluation of SBRPL and discusses issues that may have a signiﬁcant impact on its behaviors. The detail of our evaluation method such as information of testbed, simulator, evaluation metrics are explained in detail. Finally, we conclude the paper in Section V . II. R ELATED WORK "
256,Energy-aware Traffic Engineering in Hybrid SDN_IP Backbone Networks.txt,"Software Defined Networking (SDN) can effectively improve the performance of
traffic engineering and has promising application foreground in backbone
networks. Therefore, new energy saving schemes must take SDN into account,
which is extremely important considering the rapidly increasing energy
consumption from Telecom and ISP networks. At the same time, the introduction
of SDN in a current network must be incremental in most cases, for both
technical and economic reasons. During this period, operators have to manage
hybrid networks, where SDN and traditional protocols coexist. In this paper, we
study the energy efficient traffic engineering problem in hybrid SDN/IP
networks. We first formulate the mathematic optimization model considering
SDN/IP hybrid routing mode. As the problem is NP-hard, we propose the fast
heuristic algorithm named HEATE (Hybrid Energy-Aware Traffic Engineering). In
our proposed HEATE algorithm, the IP routers perform the shortest path routing
using the distribute OSPF link weight optimization. The SDNs perform the
multi-path routing with traffic flow splitting by the global SDN controller.
The HEATE algorithm finds the optimal setting of OSPF link weight and splitting
ratio of SDNs. Thus traffic flow is aggregated onto partial links and the
underutilized links can be turned off to save energy. By computer simulation
results, we show that our algorithm has a significant improvement in energy
efficiency in hybrid SDN/IP networks.","SOFTWARE Deﬁned Network (SDN) is a new networking paradigm [13] with the control plane and the data plane sep arated, which allows operators to easily deploy network applica tions through a central controller in the control plane and to dis tribute the ﬁnegrained policies into the switch ﬂow table in the data plane through standard interfaces. In the SDN, a logically centralized controller that has a global network state is respon sible for path selection and it communicates with the network wide distributed forwarding elements by OpenFlow protocol. Google has reported that it is using a SDN to interconnect its worldwide data centers due to the ease, efﬁciency in achieving trafﬁc engineering objectives [4]. It expects that the SDN archi Manuscript received October 23, 2015; approved for publication by Grace Kim, April 23, 2016. This work has been supported by National Key Technology Research and Development Program of China under Grant No.2015BAH08F01, the National Natural Science Foundation of China (61201129), Information Technology Re search Projects of Ministry of Transport of China (2014 364X14 040), and the Fundamental Research Funds for the Central Universities (ZYGX2013J009). The Authors are with the School of Communication and Information Engi neering, University of Electronic Science and Technology of China, Chengdu, China. Postcode: 611731. Xiaoning Zhang is the corresponding Author. Email: {ykwei, xnzhang, lxie, spleng}@uestc.edu.cn.tecture to realize better network capacity utilization and reduce time delay. At present, fulﬁlling full SDN deployment is impossible for network operators in a short term as it requires a lot of modi ﬁcations to current existing networking architecture and the re placement of ""old"" network equipments cause high cost. On the other hand, SDN comes with its own set of challenges and limi tations, ranging from deployment obstacles to concerns on logic centralization guarantees, e.g., in terms of resilience, robustness and scalability. Thus the introduction of SDN in an existing net work must be incremental in most cases. Hybrid SDN model will be widely used in the future. As shown in Fig.1, in a hybrid SDN/IP network, the SDNenabled switches and traditional IP routers coexist, which are distinguished by whether supporting SDN protocols. The detailed description of the hybrid model is provided in Subsection III.B. At the same time, energy consumption from the Information and Communication Technologies (ICT) sector, and in particu lar from Telecom and ISP networks, is increasing fast. To mit igate this problem, new schemes must adapt to such new envi ronment of hybrid SDN/IP networks. In this paper, we study the problem of energyaware trafﬁc engineering in hybrid SDN/IP networks. Our objective is to minimize network energy consumption. In our considered hy brid network, we assume only one controller controls all SDN enabled switches in the network, and the rest of the network nodes are IP routers running hopbyhop routing using a stan dard routing protocol. In IP network, Open Shortest Path First (OSPF) is the most commonly used intradomain internet rout ing protocol. The network operator assigns a weight to each link, and trafﬁc ﬂows are routed along the shortest path which are computed using these weights. IP network energy can be minimized by ﬁnding an optimal set of link weights [5]. In such a hybrid SDN/IP network, we propose energyaware trafﬁc en gineering algorithm that the set of OSPF link weights and trafﬁc ﬂow routing controlled by the SDN controller can be jointly op timized to achieve energy efﬁciency. We hope that the proposed algorithm can adaptively and dynamically manage trafﬁc in a network to accommodate trafﬁc varies and minimize network energy consumption. In general, the main contributions of our work can be summarized as follows:  We ﬁrst present a linear programming mathematic model to minimize the SDN/IP hybrid network energy. In this model, IP routers perform the shortest path routing by the set of link weight from OSPF protocol; SDNenabled switches perform multipath routing with trafﬁc split by the central SDN con troller.  We also propose the fast heuristic algorithm named HEATE (Hybrid EnergyAware Trafﬁc Engineering). The HEATE al xxxxxxxx/xx/$xx.xx © 201x KICSarXiv:1605.03678v1  [cs.NI]  12 May 20162 JOURNAL OF COMMUNICATIONS AND NETWORKS, VOL. X, NO. X, XXX 2016 gorithm mainly consists of two parts: the ﬁrst part is the link weight optimization for IP routers based on Neighboring Re gion Search and the second one is trafﬁc ﬂow splitting at the SDNenabled switches by the global controller. The algorithm aggregates trafﬁc ﬂow onto partial links and turns off underuti lized links for energy saving.  We conduct extensive simulations to evaluate our proposed algorithm using real network topologies and trafﬁc traces. We ﬁnd that even when only a small number of SDNenabled switches are deployed in the traditional IP network, a signiﬁcant improvement in energy efﬁciency can be gained. The rest of the paper is organized as follows. Section II brieﬂy describes the related work. The hybrid SDN/IP network archi tecture is presented in Section III. In Section IV , we formulate a mathematical optimization model to minimize energy consump tion in the hybrid network. The fast HEATE heuristic algorithm is presented in Section V . The simulation results and the perfor mance analysis are depicted in Section VI. Finally, conclusions are made in Section VII. II. RELATED WORK "
3,Integrating Industrial Artifacts and Agents Through Apache Camel.txt,"There are many challenges for building up the smart factory, among them to
deal with distributed data, high volume of information, and wide diversity of
devices and applications. In this sense, Cyber-Physical System (CPS) concept
emerges to virtualize and integrate factory resources. Based on studies that
use Multi-Agent System as the core of a CPS, in this paper, we show that many
resources of the factories can be modelled following the well-known Agents and
Artifacts method of integrating agents and their environment. To enhance the
interoperability of this system, we use Apache Camel framework, a middleware to
define routes allowing the integration with a wide range of endpoints using
different protocols. Finally, we present a Camel component for artifacts,
designed in this research, illustrating its use.","The ripening of technologies like the Internet of Things (IoT) and Internet of Services (IoS) brought focus of stud ies on the emergent 4th Industrial Revolution, i.e. Industry 4.0 and Industrial Internet concepts (Chen, 2017; Kager mann et al., 2013; Thoben et al., 2017). These research agree that those technologies are provoking changes on the overall value chain of industries, from raw materials acqui sition, logistic, and goods production to the delivery and even post sales services. This wide use and diversity of re sources brings challenges when it is necessary to integrate industrial resources as required by the smart factories of Industry 4.0 concept. The interoperability, which in this context means that the CyberPhysical System (CPS) and all sorts of resources can communicate with each other, is a key factor (Hermann et al., 2016; Lu, 2017). However, the incipient convergence of technology with no standard, usually requires the study of specic integration interfaces and high eorts on development. To face this challenge, we propose the use of Apache Camel frame work, a message routing and mediation engine. Camel allows dening communication routes among data produc ers and consumers by using a DomainSpecic Language, independent of the protocol or networking technology on each side (Ibsen and Anstey, 2010). Camel already has a ?Sponsor and nancial support acknowledgment goes here. Paper titles should be written in uppercase and lowercase letters, not all uppercase.wide range of components and allows to design new ones facilitating the integration of current and new technologies used by industrial resources. In many studies (Leit~ ao et al., 2018; Rolo et al., 2016; Cook et al., 2009), MultiAgent System (MAS) is being the CPS. In fact, it can partially reach some of smart factory 's requirements (Hermann et al., 2016; Li and Si, 2017; Monostori et al., 2016; Zhong et al., 2017), like decentralization and virtualization, leaving to devices the solution of issues like robustness and realtime capability. However, MAS applications are becoming very complex and computationally heavy specially due indiscriminately agentication of entities, i.e., the approach that model al most any entity of a system as an agent. In the other hand, in recent MAS research (H ubner et al., 2010; Omicini et al., 2008; Ricci et al., 2006; Rolo et al., 2014), dynamic and complex scenarios are being analysed in dimensions, it interprets that some elements are not necessarily agents. Agents and Artifacts approach (A&A) is proposing: (i) agent's dimension for proactive entities which encapsulate autonomous execution in some activities (ii) environment dimension which includes artifacts , i.e., simpler entities that can be manipulated and shared by agents. In this sense, the question this paper is employed to answer is: how to integrate all sorts of resources like machines, sensors and software with a MAS in a scalable manner? This paper presents a new component developed to allow the integration of artifacts from MAS to many commu nication protocols thanks to Apache Camel framework.arXiv:2006.11694v1  [cs.MA]  21 Jun 2020We think that cognitive agents can play the intelligent part of the system. They can be enhanced with several Articial Intelligence technologies. The use of artifacts besides a proper method to model non autonomous entities can make the whole system computationally lighter. This paper is structured as follows: in order to show the background technologies we have used to build a communication component, the framework Apache Camel is brie y presented in Section 2, and CArtAgO framework, employed to design artifacts, is introduced in Section 3. Then, in Section 4, we show the evolution of factory automation culminating in our proposal and what we refer as Industrial Artifacts . In Section 5, we show how theCamelArtifact component was modelled and how to use it in an application. Following this, in Section 6, we discuss two illustrative experiments. Finally, related work and conclusions complete this paper. 2. APACHE CAMEL The Apache Camel framework is a lightweight Javabased message routing and mediation engine (Ibsen and Anstey, 2010). Camel can achieve high performance processes since it handles multiple messages concurrently and provides functions like for interception, routing, exception handling and testing that allows creation of complex routes. This framework uses structured messages and queues as de ned on Enterprise Integration Patterns (EIP) (Hohpe and Woolf, 2003), preserving loose coupling among the re sources. The complexity of the protocol of each supported technology is embedded in a component, which works as a bridge to Camel routes. There are more than two hundred components available on Camel website and many others on community's repositories. A whole route has a data producer, a consumer endpoint, a producer endpoint and, nally, a data consumer. Routes aord the use of multiple endpoints, which means multiple and heterogeneous producers and consumers communicat ing in the same logical channel where messages go through. An endpoint is a connector that encapsulates a specic protocol. Messages are entities that carry data which has a body, which is the payload, headers and optionally at tachments. 1from ("" artifact : cartago "") 2. transform (). mvel (""( request . body [0] * 1.8 + 32). toString ()"") 3.to("" mqtt : foo ? host = tcp :// broker (...) ""); 4 5from ("" mqtt : foo ? host = tcp :// broker (...) "") 6. setHeader ("" ArtifactName "",constant (""s1"")) 7. setHeader ("" OperationName "",constant ("" temp "")) 8. transform (). mvel (""[ ( request . body [0]. toString ()  32) / 1.8 ]"") 9.to("" artifact : cartago ""); Listing 1. Lines 13: route from artifact to an external MQTT server to publish in a topic. Lines 59: route from a MQTT server to an artifact. In order to write route denitions, there are three available DomainSpecic Languages (DSLs): Java, Scala and XML based language. Using these languages, Camel allows towrap in the route the necessary transformations to inte grate a set of data consumers and producers. Camel works as a middleware that can be incorporated in an applica tion for concentrating integration matters. In this fashion, programming complexity may be reduced since there is a separation between MAS and integrating programming. For instance, a route may be used to convert temperature unities when an endpoint that uses celsius needs to send some data to another endpoint that is expecting it in fahrenheit. The code in Listing 1 illustrates its route denitions in Java. In the rst, the route is processing the content, applying some math and sending to a MQTT1 endpoint. The next route is displaying the way back, adding on the header of the message necessary tags to destination endpoint2. 3.CARTAGO ARTIFACTS In MAS the agents are situated entities. They are perceiv ing and acting on an environment. Nonagent elements of a MAS are usually considered as part of the environ ment (Weyns et al., 2007), which may have tools and other objects that can be used and shared by agents. The framework CArtAgO calls these resources artifacts (Ricci et al., 2006). Essentially what diers Agents and Arti facts is autonomy, agents are considered the active part of the system. The Artifacts, on the other hand, are not autonomous, they have functions, they provide operations and behave predictably (Omicini et al., 2008). Artifacts commonly are utilized to: (i) simulate the real world, (ii) as virtual representations touchable by the agents, (iii) for coordination purposes, and (iv) as inter faces to the external world wrapping some technology. Many of these uses are related to shareable knowledge about the environment, which refers to synchronization issues. About wrapping functions, the called resource arti facts are responsible for this. They mediate access to such functions or eectively embody a resource of a MAS. Observable  properties ArtifactAcessible  Operations Link  OperationsArtifact's Usage Interface  Artifact's Link Interface Observable EventsManualAct Perceive Agent Figure 1. Artifact's structure. CArtAgO is a Javabased framework that brings many functions to promote knowledge synchronization among agents and environment. The API provides basic classes to dene artifacts, the interface to interact with agents and a runtime infrastructure to support the dynamic management of working environments (Ricci et al., 2006). 1Message Queuing Telemetry Transport by IBMTM. 2broker(...) refers to broker's address. Some Math is omitted.Besides these facilities, the framework processes trans actions atomically to ensure data integrity and provides synchronization functions for multiple agents and multiple infrastructure servers. Artifacts are used by the agent through its interface which provides operations to achieve the services it oers. Typically, artifacts' implementation are computationally lighter than agents since they are passive entities. The operations performed by artifacts commonly require lit tle attention from the agent since they are passive and characterized to be routine behaviour. Artifacts are located in logical areas called workspaces . The agent that is focusing on an artifact reads its ob servable properties , perceives events and may trigger its interfaced operations. Another feature that artifacts may provide is a manual with machinereadable description of their functions which is useful especially in open systems. Finally, artifacts provide linking interfaces allowing to connect artifacts and use linked operations (Figure 1). With this function an artifact may invoke an operation of another, for instance, to communicate with a resource through another artifact. 4. INDUSTRIAL ARTIFACTS A traditional automated factory may be seen in four levels of a pyramid as showed in Figure 2. The strategic decisions are placed on an Enterprise Resource Planning level. Ac cording to priorities and other aspects, the manufacturing is scheduled and monitored in the Process Execution level. The next level has the responsibility to control the wide spread devices, often in realtime. These devices, like sen sors and actuators are situated in the bottom level of the pyramid. The presented pyramid is being more populated for all sorts of nodes including peripheral nodes (i.e logistic monitoring and control). The automation is usually still partial as we can see by human presence, in all levels, lling gaps of the processes. AsynchronousRealtimeDevice LevelControl LevelProcess Execution LevelResources Planning Level Figure 2. Traditional Automation Pyramid Many of those devices communicate via OPC (OLE for Process Control) which is widely accepted communication standard on factory shop  oor automation(Bajer, 2014). This standard is used by devices and supervisory software located on Device and Control levels of the pyramid. The higher levels of the pyramid commonly use other applica tions with restricted or no integration with lower levels. In this scenario, as illustrated in Figure 3a, interoperability Figure 3. A factory automation integrating two devices. a) ad hoc solution. b) agentication approach. d) CamelArtifact and endpoints. among dierent levels and dierent technologies is com monly solved by ad hoc solutions. The gure illustrates some integration between an industrial device (i.e. an OPC controller) and a messaging device (i.e. IoT sensor) by specic APIs (Application Program Interfaces). Factory automation is evolving, especially towards Cyber Physical Systems (CPS) concept, which is integrating vir tual and physical processes (Lee, 2008; Li and Si, 2017). CPS has a standardized abstraction and architecture inte gration in a broad sense (Monostori et al., 2016). This con cept is central to the so called smart factory of the Industry 4.0 (Kagermann et al., 2013). MAS is playing the central part of the CPS virtualizing entities allowing decentralized control and interoperability in many researches. However, studies (Ma r k et al., 2005; NakaCho et al., 2000) opted to represent almost any factory entity as agents (Figure 3b), which increases complexity and makes synchronization of the environment information more dicult. Virtual representations of the plant, including software entities as well as the physical world, may be reached at A&A approach using artifacts andworkspaces . All sorts of resources that accept command by operations and gener ate events can be modelled as artifacts. Artifacts allow to represent heterogeneous entities in a common format and make these virtual representations interoperable. In fact, without a mediation tool like Camel the usual solution to integrate artifacts and each technology is by APIs, what increases development eorts. Using our proposition (Figure 3c) interoperability is facilitated using Camel that makes available many components for dierent protocols. The integration provided by Camel is also facilitated through DLSs, the application just need to specify the routes via URIs parameters and message headers. In most cases this approach provides the needed functionality with fewer programming eorts and faster learning curve. 5. THE ARTIFACT COMPONENT In order to address interoperability, we propose joining Camel framework and artifacts . Artifact's operations are responsive execution processes lighter than agent's actions which are usually consciously behaviour. Dierent device protocols and networking technologies can be integrated to a MAS similarly, using Camel as routing and mediationengine. In this sense, the developed component, called CamelArtifact , is responsible for link artifacts and ex ternal resources. Each CamelArtifact may contain routes denitions using specic endpoints for each resource. The endpoints are encapsulating the communication protocol complexity. To use this component, an instance of CamelArtifact should be set to listen its routes. Any message coming from, or going to the routes, will be kept in queues. Mes sages that are arriving or being sent can be transformed. The transformation is usually to make compatible both sides of the route depending on the application. The arti fact may have route denitions on itself or it may receive and send messages through other CamelArtifact , which may forward messages. The use of forwarding function may save computer memory, on the other hand, each artifact as a CamelArtifact has his own thread taking computer parallelism advantages. 5.1 The Component Architecture The structure of the created component was based on the available Camel Component Archetype , which provides a useful component template. The default conguration of an Apache Camel component is mainly a DefaultCom ponent class that creates its endpoints, normally a con sumer and a producer. In a MAS application, an artifact essentially uses CArtAgO Artifact original class. In our component, a new class, the called CamelArtifact , extends Artifact from CArtAgO framework and imports the Camel API to implement Apache Camel routes. The data used by the artifacts were modelled as OpRequest , meaning Operation Request, which contains the name of an artifact, an operation to be performed and its parameters. Producer and consumer sides work in a very similar man ner by polling processes supported by queues for incoming and outgoing messages. With the polling consumer to send messages, the artifact places messages in the outgoing queue that will be repeatedly checked by the endpoint consumer to send it through the route. For incoming messages process, the component implements an ad hoc process using CArtAgO's IBlockingCmd class to check for new messages delivering it to the artifact. The message structure used by Camel provides in the header a map of Java objects, in the body any Java object, and optional attachments. In the header of CamelArtifact messages, it is expected to nd tags for the artifact name and operation, this last regards to a method to be performed. The body may contain a list of params the referred method needs. The operation tagged will be invoked as a CArtAgO internal operation or it may be forwarded when addressed to other artifact. 6. ILLUSTRATIVE USE AND RESULTS To test the designed Camel component, two MAS applica tions were developed. The rst was centred on a scalabil ity experiment of the component making use of multiple consumers, forwarding function and loopback communica tions. The second experiment was to try the component in a scenario needing interoperability among dierent tech nologies and protocols in the context of Industry 4.0.6.1 Terminal and Router scalability experiment In the rst application, two scenarios are used to illustrate theArtifactComponent . For communication point of view, there are the scenarios have artifacts as terminals, which are endpoints of the communication and an artifact as a router, which is a middleware to forward messages to endpoints. Scenario 1 is varying the number of terminals instantiating multiple CamelArtifacts . Scenario 2 is vary ing the number of common artifacts, all of them linked to aCamelArtifact as a message router. The router, in this context, contains routes of other artifacts using Apache Camel MQTT supported endpoint. All the CamelArtifacts were set to publish and subscribe its own topic, being able to receive back its own sending messages. When playing the router function, an extra route was created to the linked artifacts. The scenario 1 had the number of camel terminals varied from 10 to 500 artifacts. The scenario 2 had the number of common artifacts varied from 10 to 200. The MAS was designed with Jason framework (Boissier et al., 2013). It has only one agent, liable to make the artifacts, link and manage them. We have used MQTT QoS 2 setting, which mean the most guaranteed message delivering method provided by this protocol. The resources exchanged messages in both ways every 6 seconds. For our virtual Ubuntu Linux server with 2 cores and 2 GB RAM, it is a stressing situation that allows to check the message processing limits. In scenario 1, we notice that the system uses more RAM memory since it creates several Camel instances. The application with 10 CamelArtifacts used 127 MB growing an average of 1.3 MB for each instance added. In scenario 2, variance is not conclusive, main changes occurred by other Java Virtual Machine processes (Figure 4a). In addiction, on scenario 1 the system needed more time to load, for 10 artifacts it needed 21 seconds increasing an average of 1.5 seconds for each CamelArtifact added. Scenario 2 had no signicant increase (Figure 4b). In contrast, messages per second rate of scenario 1 reach better results, growing from 2 to 16.6 when the system was tested with 200 CamelArtifacts , scenario 2 grew only until 4.1 messages/s (Figure 4c). 6.2 Industry 4.0 context experiment The CamelArtifact was tried in an Industry 4.0 context scenario (Figure 5). To assess the solution, the application uses three resources with dierent features, one being an OPC3server, which may re ect some current industrial resource (e.g. a Programmable Logical Controller  PLC). Another resource is a compatible MQTT client, which may be an IoT device (e.g. a sensor). Finally, the last resource is a generic TCP/IP entity, which may be a software communicating by socket (e.g. a Robot or an Enterprise Resource Planning  ERP). In this test, all the three resources, were modelled as CamelArtifact . To check the OPCDA route a numerical variable was cre ated in the OPC server and an observable property in the 3OPC: integration standard in industrial automation.50100150200100150200250300350400 Number of artifactsMemory usage (MB)a) Sc1 Sc2 5010015020050100150200250300 Number of artifactsLoading time (s)b) Sc1 Sc2 501001502002468101214161820 Number of artifactsMessages / sc) Sc1 Sc2 Figure 4. Scenarios 1 and 2 (Sc1 and Sc2) comparison as increase the number of artifacts. a) Memory use b) Time to load c) Message/s rate artifact. The OPCDA component used is provided by an independent developer. The routes did the synchronization of the value of the variable with the observable property. The MQTT client, using the supported component, had its routes to send and receive messages from a MQTT broker. Finally, a robot rmware was deployed in a virtual machine to simulate a cargo moving robot. A generic TCP/IP route, using Netty4 supported endpoint, was set to send and receive messages in a proprietary protocol. OPCDA ServerMultiAgent System MQTT  endpoint Camel  RouteAgent OPCDA endpoint  Netty4  endpointCamel  RouteCamel  RouteCargo Moving Robot (TCP/IP) MQTT Server Figure 5. MAS communicating with dierent resources. The MAS was designed with two Jason agents, one of them responsible to make the artifacts and share with another agent, a counter, the relevant information that came from the OPC server. The interoperability was tried when the agent used the counter from OPC server to act over the MQTT sensor and TCP/IP robot according to the variance of this information. 7. RELATED WORK "
471,Neural-Shadow Quantum State Tomography.txt,"Quantum state tomography (QST) is the art of reconstructing an unknown
quantum state through measurements. It is a key primitive for developing
quantum technologies. Neural network quantum state tomography (NNQST), which
aims to reconstruct the quantum state via a neural network ansatz, is often
implemented via a basis-dependent cross-entropy loss function. State-of-the-art
implementations of NNQST are often restricted to characterizing a particular
subclass of states, to avoid an exponential growth in the number of required
measurement settings. To provide a more broadly applicable method for efficient
state reconstruction, we present ""neural-shadow quantum state tomography""
(NSQST)-an alternative neural network-based QST protocol that uses infidelity
as the loss function. The infidelity is estimated using the classical shadows
of the target state. Infidelity is a natural choice for training loss,
benefiting from the proven measurement sample efficiency of the classical
shadow formalism. Furthermore, NSQST is robust against various types of noise
without any error mitigation. We numerically demonstrate the advantage of NSQST
over NNQST at learning the relative phases of three target quantum states of
practical interest. NSQST greatly extends the practical reach of NNQST and
provides a novel route to effective quantum state tomography.","Eﬃcient methods for state reconstruction are essential in the development of advanced quantum technologies. Important applications include the eﬃcient characteri zation, readout, processing, and veriﬁcation of quantum systems in a variety of areas ranging from quantum com puting and quantum simulation to quantum sensors and quantumnetworks[ 1–6]. However, withphysicalquantum platformsgrowinglargerinrecentyears[ 7], reconstructing the target quantum state through bruteforce quantum state tomography (QST) has become much more compu tationally demanding due to a exponentially increasing number of required measurements. To address this issue, various approaches have been proposed that are eﬃcient in both the number of required measurement samples and in the number of parameters used to characterize the quantum state. These include classical shadows [ 8] and neural network quantum state tomography (NNQST) [9]. The goal of NNQST is to produce a neural network representation of a complete physical quantum state that is close to some target state. In contrast, the classical shadows formalism does not aim to reconstruct a full quantum state, but rather to obtain a reduced classical description that allows for eﬃcient evaluation of certain observables. A neural network quantum state ansatz has been shown ∗victor.wei203@gmail.com †william.coish@mcgill.ca ‡pooya.ronagh@uwaterloo.ca §christine.muschik@uwaterloo.cato have suﬃcient expressivity to represent a wide range of quantum states [10–13] using a number of model param eters that scales polynomially in the number of qubits. Furthermore, as methods for training neural networks have long been investigated in the machine learning com munity, many useful strategies for neural network model design and optimization have been directly adopted for NNQST [ 14–16]. Following the introduction of neural network quantum states [ 17], Torlai et al.proposed the ﬁrst version of NNQST, an eﬃcient QST protocol based on a restricted Boltzmann machine (RBM) neural net work ansatz and a crossentropy loss function [ 9]. NNQST has been applied successfully to characterize various pure states, including W states, the ground states of many body Hamiltonians, and timeevolved manybody states [9,18,19]. Despite the promising results of NNQST in many use cases, the protocol faces a fundamental chal lenge: An exponentially large number of measurement settings is required to identify a general unknown quan tum state (although a polynomial number is suﬃcient in some examples [ 20]). During NNQST, a series of mea surements is performed in random local Pauli bases Bfor nqubits (B= (P1,P2,···,Pn), wherePi∈{X,Y,Z}). Because this set is exponentially large, some convenient subset of all possible Bmust be selected for a large sys tem, but this subset may limit the ability of NNQST to identify certain states. An important example is the phaseshifted multiqubit GHZ state, relevant to applica tions such as quantum sensing. In this case, the relative phase associated with nonlocal correlations cannot be captured by measurement samples from almostdiagonal local Pauli bases, i.e., bases with m/lessmuchnindicesifor whichPi=XorPi=Y. Nonetheless, this limited setarXiv:2305.01078v1  [quantph]  1 May 20232 of almostdiagonal Pauli bases is widely used in NNQST implementations to avoid an exponential cost in classical postprocessing [9, 18]. To address this challenge, we use the classical shadows of the target quantum state to estimate the inﬁdelity between the model and target states. This is in contrast withapproachesthatusetheconventionalbasisdependent crossentropy as the training loss for the neural network. This choice is motivated by two main factors. Firstly, inﬁ delity is a natural candidate for a loss function compared to crossentropy; the magnitude of the basisdependent crossentropy loss is in general not indicative of the dis tance between the neural network quantum state and the target state. Additionally, inﬁdelity is the squared Bures distance [21], a measure of the statistical distance between quantum states that enjoys metric properties such as symmetry and the triangle inequality. The inﬁ delity is therefore a better behaved objective function for optimization. Secondly, the classical shadow formalism of Huang et al.was originally developed to address precisely the scaling issues of bruteforce QST [ 8]. Instead of recon structingthe unknownstate, shadowbased protocols, ﬁrst proposed by Aaronson [ 22], predict certain properties of the quantum state with a polynomial number of measure ments. Therefore, classical shadows provide the following two main advantages in our work: (i) they are provably eﬃcient in the number of required measurement samples for predicting various observables (e.g. the inﬁdelity), and (ii) there is no choice of measurement bases required and therefore no previous knowledge of the target state is assumed. Our new purestate QST protocol, “neural–shadow quantum state tomography” (NSQST), reconstructs the unknown quantum state in a neural network quantum state ansatz by using classical shadow estimations of the gradients of inﬁdelity for training (Fig. 1b). In our numerical experiments, NSQST demonstrates clear ad vantages in three example tasks: (i) reconstructing a timeevolved state in onedimensional quantum chromo dynamics, (ii) reconstructing a timeevolved state for an antiferromagnetic Heisenberg model, and (iii) reconstruct ing a phaseshifted multiqubit GHZ state. Moreover, the natural appearance and inversion of a depolarizing channel from randomized measurements in the classical shadow formalism makes NSQST noiserobust without any calibration or modiﬁcations to the loss function, while one of these two extra steps is required in noiserobust classical shadows [ 23,24]. We numerically demonstrate NSQST’s robustness against two of the most dominant sources of noise across a wide range of physical imple mentations: twoqubit CNOT errors and readout errors. The rest of this paper is organized as follows: In Sec. II, we summarize the methods used in our numerical simula tions, including the neural network quantum state ansatz, NNQST, classical shadows, NSQST, and NSQST with pretraining. In Sec. III and Sec. IV, we provide numeri cal simulation results for NNQST, NSQST, and NSQST with pretraining in three useful examples, both noisefreeand in the presence of noise. Finally, Sec. V summarizes the key advantages of NSQST and some possible future directions. We provide additional technical details and suggestions for further improvements to NSQST in the appendices. a Selfattention  blockpλ(s)φλ(s)Samplinĝρi(U†i,bi)|bi⟩|Φ⟩ U†ib|Φ⟩ |s,B⟩pΦ(s,B)Selfattention  blockpλ(s)φλ(s)Sampling ∇λLNNQST NSQST ∇λ FIG. 1. Overview of the NNQST and NSQST protocols. Panel ashows the NNQST protocol with the crossentropy loss func tionLλ. The training data determine pΦ(s,B), the measured probability distribution of measurement outcomes sfor mea surements of the target state |Φ/angbracketrightperformed in the local Pauli basisB. Thefeedbackloopontherighthandsideindicatesthe iterative ﬁrstorder optimization for neural network training. Panelbdisplays the NSQST protocol described in Sec. IID, where the training data set consists of classical shadows only and where the network parameters λare trained via an in ﬁdelity loss function Lλ. The expression ˆρi(U† i, bi)is the stored classical shadow of the target state |Φ/angbracketrightwith the Cliﬀord unitaryU† iand bitstring|bi/angbracketright. II. METHODS "
244,Making Name-Based Content Routing More Efficient than Link-State Routing.txt,"The Diffusive Name-based Routing Protocol (DNRP) is introduced for efficient
name-based routing in information-centric networks (ICN). DNRP establishes and
maintains multiple loop-free routes to the nearest instances of a name prefix
using only distance information. DNRP eliminates the need for periodic updates,
maintaining topology information, storing complete paths to content replicas,
or knowing about all the sites storing replicas of named content. DNRP is
suitable for large ICNs with large numbers of prefixes stored at multiple
sites. It is shown that DNRP provides loop-free routes to content independently
of the state of the topology and that it converges within a finite time to
correct routes to name prefixes after arbitrary changes in the network topology
or the placement of prefix instances. The result of simulation experiments
illustrates that DNRP is more efficient than link-state routing approaches.","Several InformationCentric Networking (ICN) architectures have been introduced to address the increasing demand of usergenerated content [1], [3]. The goal of these architectures is to provide a costefﬁcient, scalable, and mobile access to content and services by adopting a contentbased model of communication. ICN architectures seek to dissociate content and services from their producers in such a way that the content can be retrieved independently of its original location or the location of consumers. The most prominent ICN archi tectures can be characterized as Interestbased architectures, in which locationindependent, selfdeﬁned, unique naming is used to retrieve data. In this approach, messages ﬂow from producers to consumers based on the name of the content rather than the address of the senders or receivers exchanging such content. Content providers or producers create named data objects (NDOs), and advertise routable name preﬁxes associated with the content objects whose own names are part of the name preﬁxes. The only identiﬁer of an NDO is its name. A consumer requests a piece of content by sending an Interest (a request for the NDO) that is routed along content routers toward the producer(s). Clearly, an efﬁcient namebased content routing protocol must be used for any ICN architecture to succeed using name based forwarding of Interests and requested content. Section II summarizes recent prior work in namebased content routing, and this review reveals that all prior proposals for namebased content routing rely on periodic transmissions of update mes sages. This paper focuses on an approach that avoids the needfor periodic messaging by means of diffusing computations [5]. Section III presents DNRP (Diffusive Namebased Routing Protocol ), a namebased content routing protocol for ICNs. DNRP provides multiple loopfree routes to the nearest in stances of a named preﬁx or to all instances of a named preﬁx using only distance information and without requiring periodic updates, knowledge of the network topology, or the exchange of path information. Section IV shows that DNRP prevents routingtable loops even in the presence of topology changes as well as changes in the hosting of preﬁxes, and converges within a ﬁnite time to correct multipaths to name preﬁxes. Section V presents the results of simulation experiments comparing DNRP with an efﬁcient linkstate approach similar to NLSR [13]. The results show that DNRP produces less communication and computation overhead in the case of topology changes as well as the addition of preﬁxes. II. R ELATED WORK "
389,Channel Selection Scheme for Cooperative Routing Protocols in Cognitive Radio Networks.txt,"Cognitive radio networks (CRNs) propose a smart solution for spectrum usage
inefficiency. Routing protocols for CRNs follow different criteria to choose
the best route to the destination and to avoid the interference with primary
users. Some protocols use cooperative communication techniques to achieve the
full coexistence between secondary users (SUs) and primary users (PUs).
Although using such cross-layer techniques have a great impact on the quality
of the chosen routes, the existing work do not choose the best channel to send
the data over. Thus, the available spectrum is not utilized efficiently. In
this work, we propose CSCR, a channel selection scheme for cooperation-based
routing protocols in CRNs. The proposed scheme increases the spectrum
utilization through integrating the channels selection in the route discovery
phase of the cooperation-based routing protocols. The best channels, that are
less congested with primary users and that lead to minimum switching overhead,
are chosen while constructing the cooperative group. Evaluating CSCR via NS2
simulations shows that it outperforms its counterparts in terms of goodput,
end-to-end delay, and packet delivery ratio. The proposed scheme can enhance
the network goodput, in some cases, by more than 150%, as compared to other
related protocols.","Cognitive Radio Networks (CRNs) appeared as a promising solution for the spectrum underutilization problem. In these networks, the primary users (PUs) are the only licensed users to use the spectrum. However, secondary users (SUs) are able to use it too, but under the condition of not interfering with the PUs. Several routing protocols were designed to construct routes between SUs in CRNs [1], each has its own criteria. In this paper, we are extending Undercover [2] which utilizes the cooperative communication techniques in the routing process. Using these crosslayer techniques, the signal quality can be enhanced in the direction of the receiver SU (cooperative diversity), while nulling the transmissions in the directions of the PUs (cooperative beamforming). Although this idea allows the full coexistence between SUs and PUs, the existing work ignore choosing the proper channel to transmit signals on, and this leads to an inefﬁcient use of the spectrum. In this paper, we propose CSCR : a Channel Selection scheme for Cooperative Routing protocols in CRNs. This scheme aims at choosing dynamically the best channel to use at each relay along the route. It avoids choosing the chan nels with high PUs activities while having the least possible channel switching delay. This strategy enhances the network metrics in terms of achievable capacity, endtoend delay, and packet delivery ratio. Although the core idea has been SU1  SU2 SU3 PU5 PU6  PU1 PU2 PU3  PU4 Cooperative  Grouppactive=0.95 pactive=0.8 pactive=0.9(a) Channel 1 SU1  SU2 SU3 PU5 PU6  PU1 PU2 PU3  PU4 Cooperative  Grouppactive=0.5 pactive=0.3 (b) Channel 3 SU1  SU2 SU3 PU5 PU6  PU1 PU2 PU3  PU4 Cooperative  Grouppactive=0.9 (c) Channel 10 Fig. 1: Example on the effect of choosing the optimal channel to send the data over. Note that pactive represents the activity probability of a primary user on a particular channel. used previously in the CRNs literature, the task of selecting the best channel for a cooperative group (during routing) was not discussed before. Thus, this is the ﬁrst work that investigates this problem and integrates the channel selection with a cooperative routing protocol. Our scheme is motivated by the example in Figure 1 in which the advantage of choosing the appropriate channel, to send the data over, is shown. Consider having a cooperative group of three SUs that are required to select a channel (channel 1 is the default) to send some data through. Sending on the default channel (channel 1) is not the best choice due to the high number and activity of the surrounding PUs (Figure 1a). Also, sending on channel 10 (Figure 1c) is not the best choice too, since switching from the default channel to channel 10 will take a long time, as the latter channel is the farthest one from the default channel [3]. Thus, the best channel is channel 3 (Figure 1b) because, it achieves the compromise between avoiding highly active PUs and minimizing the channel switching overhead. The proposed scheme has been evaluated using NS2 [4], and its performance is compared to two other CRN protocols. Results show that CSCR can enhance the network goodput, in some cases, by more than 150%. In addition, it is shown that CSCR always experiences a higher data delivery ratio, with the least endtoend delay, compared to its counterparts. The rest of the paper is organized as follows: Section II presents the related work. Then, our system model is described in Section III. The proposed channel selection scheme is given in Section IV. Section V evaluates CSCR and Section VI concludes the paper and gives directions for future work. II. R ELATED WORK "
124,A QoS-Aware Routing Protocol for Real-time Applications in Wireless Sensor Networks.txt,"The paper presents a quality of service aware routing protocol which provides
low latency for high priority packets. Packets are differentiated based on
their priority by applying queuing theory. Low priority packets are transferred
through less energy paths. The sensor nodes interact with the pivot nodes which
in turn communicate with the sink node. This protocol can be applied in
monitoring context aware physical environments for critical applications.","A wireless sensor network is  a wireless network consisting of spatially distributed autonomous devices  using sensors to cooperatively monitor physical or environmental conditions, such as temperature, sound,  vibration, pressure, motion or pollutants, at diffe rent locations. The development of wireless sensor  networks was originally motivated by military applications such as battlefield surveillance. However, these  networks  are now used in many industrial and civilian application areas, including industrial pro cess  monitoring and control, machine health monitoring, environment and habitat monitoring, healthcare  applications, home automation, and traffic control.  In addition to one or more sensors, each node in a  sensor network is typically equipped with a radio transceiver or other wireless communication device ,  processor and battery  (Akyildiz  et al.  2002) .The environment under surveillance can be populated with  sensors for capturing the context information  and communicating to  the base station for further action   (Intanagonwiwat   et al.  2000) .    1.1  QoS aware routing protocols    The main goal of QoS aware routing protocols is  to find a path to meet the  QoS requirements . The routing  protocol searches for lower cost and energy efficient path between end to end conn ections (Heinzelman et Innovative Sys tems Design and Engineering    www.iiste.org   ISSN 2222 1727 (Paper) ISSN 2222 2871 (Online)   Vol 2, No 7, 2011     85 | P a g e   www.iiste.org   al. 2000) . This paper introduces the Pivot node which is different from the sensor nodes. Pivot node has  better processing and communication power, and longer lifetime batteries. Pivot nodes are added between  the sensor nodes and the  sink node.   The network  QoS aims at defining the bandwidth,  latency, jitter that  each packet expects  from the network.  As the bandwidth in each link in a network is fixed, the bandwidth given for each flow depends on the QoS  requirement of the particular flow. A QoS architecture specifies the performance  requirements for  different  types of packets and methods for delivering  those performance requirements  (Carpenter  et al.  2002) . The  network and applications use three types of communication schemes. They ar e periodic interaction s,  interactions  triggered by certain events and interactions through queries  (Boukerche  et al.  2004) . Such  kinds of communication schemes have some requirements. These requirements include: low latency  delivery of high priority packet s, packet delivery reliability, fast path repair in the presence of failures,  uniform energy saving and support to differentiated service packets.         The rest of the paper is organized as follows: Section 2 discusses the related work. Section 3, gives  the  protocol description. Section 4, indicates  simulation and results. Section 5, draws conclusions  and provides  the future work s possible .  2.  Related Work   "
111,Classification and Characterization of Core Grid Protocols for Global Grid Computing.txt,"Grid computing has attracted many researchers over a few years, and as a
result many new protocols have emerged and also evolved since its inception a
decade ago. Grid protocols play major role in implementing services that
facilitate coordinated resource sharing across diverse organizations. In this
paper, we provide comprehensive coverage of different core Grid protocols that
can be used in Global Grid Computing. We establish the classification of core
Grid protocols into i) Grid network communication and Grid data transfer
protocols, ii) Grid information security protocols, iii) Grid resource
information protocols, iv) Grid management protocols, and v) Grid interface
protocols, depending upon the kind of activities handled by these protocols.
All the classified protocols are also organized into layers of the Hourglass
model of Grid architecture to understand dependency among these protocols. We
also present the characteristics of each protocol. For better understanding of
these protocols, we also discuss applied protocols as examples from either
Globus toolkit or other popular Grid middleware projects. We believe that our
classification and characterization of Grid protocols will enable better
understanding of core Grid protocols and will motivate further research in the
area of Global Grid Computing.","Towards the realization of Global Grid Computing, m any researchers have been attracted to broad resear ch areas such as  architectures, protocols, services, APIs, and toolk its of Grid in a last decade. Grid applications exp loit services provided by Grid  architecture to enable various scientific applicati ons such as high performance computing, highthroug hput computing,  distributed supercomputing, dataintensive computi ng, etc. Different services in Grid computing are d efined in terms of the  protocols that are used to interact with them and t he expected behaviors from the services. Considerab le research is going on  protocols used in Grid computing and certain protoc ols are also standardized by Global Grid Forum [1].  However, proprietary  Grid protocols are used for domain/application spec ific Grid architectures. Interoperability among the se protocols is a headache  while integrating different proprietary Grid archit ectures.     The three point checklist definition of Grid in [2] , “ Grid is a system that coordinates resources that ar e not subject to central  control using standard, open, generalpurpose proto cols and interfaces to deliver nontrivial qualities  of service ”, stresses on  standard protocols and interfaces to enable global deployment of Grid as it is today for the Internet.  Many international Grid  projects (e.g., [3], [4], [5]) and national Grid pr ojects (e.g., [6], [7], [8]), started in a last dec ade, have demonstrated the power  and capability of Grid computing and have stimulate d Grid computing at global scale to solve different  scientific problems.  Moreover, the distributed.net [9] and the SETI@home  [10] popularized the Grid computing at global scal e. The availability of  Grid middleware (e.g., Globus) has opened doors for  other forms of Grid computing such as cloud comput ing, utility computing,  autonomic computing, volunteer computing, etc. In t his paper, by Global Grid Computing, we mean Grid b e able to exploit  resources provided by any organizational, national,  or international Grids that exist today or will ex ist in future.  Consequently, to  enable this global connectivity for resource sharin g at global scale, Foster in [2] suggests requireme nt of common, standardized,  InterGrid Grid protocols for any entity to become p art of global Grid.  In simplest words, a protocol can be defined as a c ommunication procedure with the specific rules gove rning the syntax,  semantics, sequence of statements, and synchronizat ion of communication between communicating entities . A protocol in  computing includes set of rules for (i) formatting the messages that are exchanged, (ii) message excha nge sequence/pattern, and  (iii) timings of exchanged messages. Certain protoc ols in computing can also specify the behavior as a  result of particular  message exchange. Behavior specification enables di fferent implementations of behavior possible thus n ot restricting the  creativity. Grid protocols play major role in imple menting services that facilitate Global Grid Comput ing. We expect the  standardization of all Grid protocols that are used  in implementing various activities and services fo r global Grid deployment.    Manuscript Modified last on Aug 28, 2010.   H. B. Prajapati is with the Information Technology Department of Faculty of Technology, Dharmsinh Desa i University, Nadiad 387001, Gujarat, INDIA. (e mail: harshad.b.prajapati@gmail.com).  V. K. Dabhi is with the Information Technology Depa rtment of Faculty of Technology, Dharmsinh Desai Un iversity, Nadiad 387001, Gujarat, INDIA.    Classification and Characterization of Core Grid  Protocols for Global Grid Computing  Harshad B. Prajapati and Vipul K. Dabhi    2 Considerable research is still to be carried out fo r well engineering and standardizing the Grid proto cols. Our goal in the paper is  to provide good understanding and comprehensive cov erage of major core Grid protocols that can be used  for Global Grid  Computing by classify and characterize approach.  Our objectives in this paper are (i) Classify all c ore Grid protocols that can be used in Global Grid Computing into different  categories depending upon the kind of activities ha ndled by the protocols. (ii) Organize all classifie d protocols into Hourglass  model of Grid architecture to understand protocol d ependency among them. (iii) Characterize all core G rid protocols to  understand specific characteristics and behaviors o f the protocols. We believe that our classification  and characterization of core  Grid protocols will enable better understanding of core Grid protocols and will motivate further resea rch in the area.  The paper is structured as follows. Section II disc usses related work and motivation for the work. Sec tion III discusses basic  concepts, terms, and related terminology. Section I V provides the classification of core Grid protocol s that can be used for Global  Grid Computing and also shows placement of classifi ed core Grid protocols in Hourglass model based Gri d architecture. Section  V characterizes and discusses protocols related to Grid network communication and Grid data transfer. Section VI characterizes  and discusses protocols related to Grid information  security. Section VII characterizes and discusses protocols related to Grid  resource information. Section VIII characterizes an d discusses protocols related to Grid management ac tivities. Section IX  characterizes and discusses protocols related to pr oviding Web services standards based interfaces. Fi nally, Section X provides  the conclusions. We have tried to make this paper a pproachable to the reader unfamiliar with the Grid,  however, the reader  interested in getting exhaustive details need to re ad relevant referenced work.  II.  RELATED WORK AND MOTIVATION FOR THE WORK   "
100,Data Aggregation Techniques for Internet of Things.txt,"The goal of this dissertation is to design efficient data aggregation
frameworks for massive IoT networks in different scenarios to support the
proper functioning of IoT analytics layer. This dissertation includes modern
algorithmic frameworks such as non convex optimization, machine learning,
stochastic matrix perturbation theory and federated filtering along with modern
computing infrastructure such as fog computing and cloud computing. The
development of such an ambitious design involves many open challenges, this
proposal envisions three major open challenges for IoT data aggregation: first,
severe resource constraints of IoT nodes due to limited power and computational
ability, second, the highly uncertain (unreliable) raw IoT data is not fit for
decisionmaking and third, network latency and privacy issue for critical
applications. This dissertation presents three independent novel approaches for
distinct scenarios to solve one or more aforementioned open challenges. The
first approach focuses on energy efficient routing; discusses a clustering
protocol based on device to device communication for both stationary and mobile
IoT nodes. The second approach focuses on processing uncertain raw IoT data;
presents an IoT data aggregation scheme to improve the quality of raw IoT data.
Finally, the third approach focuses on power loss due to communication overhead
and privacy issues for medical IoT devices (IoMT); describes a prediction based
data aggregation framework for massive IoMT devices.",1.1 Taxonomy  of Massive IoT data  ................................ ................................ ..... 2  1.1.1.  Data Generation  ................................ ................................ ................  2  1.1.2 Data Quantity  ................................ ................................ ....................  2  1.2 IoT Analytics  ................................ ................................ ................................  3  1.2.1  IoT Analytics Architecture  ................................ ................................ . 5  1.2.2 Taxonomy of IoT Analytics  ................................ ...............................  6  1.3 Open Challenges  ................................ ................................ ...........................  7  1.3.1  Open Challenges related to Data Analytics Layer  ..............................  8  1.3.2  Open Chanllenges related to IoT Sesnors Networks  .........................  10  1.3.3  Open Chanllenges related to Routing Network  ................................  10  1.4 Potential Solution  ................................ ................................ ........................  10  1.4.1  Objective  ................................ ................................ .........................  11  1.4.2  Overview  ................................ ................................ .........................  12  1.4.3  Major C ontributions  ................................ ................................ ........  14  1.4.4  Thesis Organization  ................................ ................................ .........  15  Chapter 2 Mobility Based Cooperative Data Aggregation Scheme  ........................  17  2.1 Chapter Overview  ................................ ................................ .......................  17 Thesis for Master’s Degree  of CQUPT                                          Contents     VI 2.2 Background and Related Work  ................................ ................................ .... 18  2.3 System Model  ................................ ................................ .............................  19  2.3.1  Energy Efficiency  ................................ ................................ ............  21  2.3.2  Accelerometer  ................................ ................................ .................  22  2.3.3  Corelative Mobility  ................................ ................................ ........  22  2.4 Proposed Cluster Formation Scheme  ................................ ...........................  24  2.5 Propsed Data Uploading Scheme ................................ ................................ . 25  2.6 Implementation and Result s ................................ ................................ ........  26  2.7 Chapter Conclusion  ................................ ................................ .....................  29  Chapter 3 A Heuristic Solution to Data Veracity for Massive Raw IoT Data  ........  31  3.1 Chapter Overview  ................................ ................................ .......................  31  3.2 Related Work  ................................ ................................ ..............................  33  
19,Performance Evaluation of netfilter: A Study on the Performance Loss When Using netfilter as a Firewall.txt,"Since GNU/Linux became a popular operating system on computer network
routers, its packet routing mechanisms attracted more interest. This does not
only concern 'big' Linux servers acting as a router but more and more small and
medium network access devices, such as DSL or cable access devices.
  Although there are a lot of documents dealing with high performance routing
with GNU/Linux, only a few offer experimental results to prove the given
advices. This study evaluates the throughput performance of Linux' routing
subsystem netfilter under various conditions like different data transport
protocols in combination with different IP address families and transmission
strategies. Those conditions were evaluated with two different types of
netfilter rules for a high number in the rule tables. In addition to this, our
experiments allowed us to evaluate two prominent client connection handling
techniques (threads and the epoll() facility).
  The evaluation of the 1.260 different combinations of our test parameters
shows a nearly linear but small throughput loss with the number of rules which
is independant from the transport protocol and framesize. However, this
evaluation identifies another issue concerning the throughput loss when it
comes to the address family, i.e. IPv4 and IPv6.","One of the benets of the Linux kernel is the availability for nearly every technical architecture. The combina tion with the GNU operating system (often referred as GNU/Linux or simply Linux ) makes it a good choice for router in computer networks because its memory footprint is quite small based on the modularity of the kernel modules.In addition to this, the Linux kernel has outofthe box routing capabilities as well as advanced packet l ter and transformation mechanisms which can be found in the netlter framework inside of the Linux kernel. Quality of service based classication and priorization are available, too. Along with other key features such as the big varie ty of server software, GNU/Linux is now one of the most preferred operating systems especially for small routing devices, for example DSL or cable access de vices in enduser environments. Another famous ex ample for GNU/Linux is the usage in wireless access routers known as DDWRT . Those devices as well as \big"" GNU/Linux routers, for example PCs or servers, share the same disadvan tage: the routing and ltering is based on software whose execution time is in uenced by many factors, for example CPU, main memory and hardware drivers. In the worst case, the technical components of the router are not performant enough to process the data packets and they are delayed or discarded. The main objective of this study is to evaluate the im pact of netlter rules on the throughput rate per client in a distributed clientserver application, i.e. a perfor mance test. Although we are aware of the fact, that netlter features a variety of lter rules, we focus for our experiments only on the most interesting rules for router operators: rules for both permitting clients to pass the router (ACL) and measuring their trac vo lume (known as IP accounting ) as well as rules for reg ulating the available network bandwidth among those clients (known as QoS). In section 2 we describe the reasons why we did not use the test apparatus for this kind of performance test that is suggested in RFC 3511. Additionally, we speci fy our test apparatus and the extended set of possible in uence parameters. Since we used our own test apparatus, we were able to clearify another aspect in clientserver applications: the handling of client connections in the server compo nent. We evaluated two widely used kinds in terms of the throughput rate. The rst is to handle each client 1arXiv:1502.05487v1  [cs.NI]  19 Feb 2015netfilter Command &  Control ClientCommand &  Control ServerServer Client Command &  Control GatewayFigure 1: netlter performance testing architec ture connection in its own thread (threading) and the other is the epoll() facility oered by the Linux kernel that proclaims to be more performant and easier to imple ment. Our results along with other observations are discussed in section 3. 2. TEST APPARATUS The test apparatus follows the guidelines described in RFC 3511 [5]. Basically it is a clientserver architecture where a central gateway lters and transforms the data transmissions between the clients and the server. Contrary to RFC3511, we did not use the suggested HTTP benchmark because we were fundamentally in terested in the evaluation of a bigger number of in u ence parameters than only HTTP transactions per se cond. All test parameters that we were interested in are listed in table 1. We developed a distributed appli cation1instead that has the same semantics like other popular command line benchmark tools like iperf or netperf , but incorperates a third component gateway in the clientserver concept. Table 1: Parameters of a test case Parameter Description and tested values n Number of client threads (5,10,20,40,80, 160,320) t Duration of the experiment (100s) f Frame size (either xed [64,128,256,512, 1024] or ranged between 64 and 1024) P Transport protocol for the transmission (either TCP, UDP or SCTP) A Address family (either IPv4 or IPv6) T Server component uses threads for han dling the client connections (only valid for stream oriented protocols) F netlter rule generation per client thread: 0 for plain forwarding, 2 for up and down load and 4 for additional QoS marks As shown in gure 1, our application consists of three independant command line tools. The communication between those three components can be divided into 1(Link removed according to doubleblind review process).two parts: a) the control connection between the client and the gateway as well as the server component and b) the data connections between the client threads and the server thread(s). The control connection is used for sending the test parameters to the components and (once they congured themselfes according to the pa rameters) to signal the start and the end of the specic experiment. Every experiment follows the same steps: 1. The test parameters are given as command line pa rameters when the client component starts. The parameters are validated and transferred to the gateway component. The gateway component con gures the netlter subsystem according to the submitted test parameters by inserting appropiate lter rules as specied in test parameter F. 2. When the gateway components signals its readi ness for the conguration, the client component submits the test conguration to the server compo nent. The server component then awaits any client connections by opening a server socket. When this socket is successfully opened and bound, the server component signals its readiness back to the client component. 3. The client component initializes and executes n client threads. They subsequently connect to the server component. According to the parameter T the server component handles each of the client connection in a) its own thread or b) in a single thread using the epoll() facility. 4. Once all client threads are connected, they be gin to send and to receive data packets accord ing to the test parameters P,Aandf. Every of thenclientserverconnections has its own inde pendant sending/receiving cycle as depicted in  gure 2: the client sends a specic amount of data (measurement point 1), the server thread receives the data (measurement point 2) and echos it back to the client thread (measurement point 3). The client thread nally receives the data (measure ment point 4). 5. When the test duration tis reached, the client threads get a signal to end the current sending/re ceiving cycle, to disconnect from the server com ponent and nally to end. The client component instructs the server and then the gateway compo nent to restore the system state that existed before the experiment. For each of the four measurement points as shown in  gure 2, several values were recorded. For measurement point 1 and 3 the number of successful sent/unsent data 2Client Server1 2 4 3Figure 2: Measurement points of the send ing/receiving cycle frames and the frame sizes were saved. The term \un sent"" in this context means that a data frame could not be send successfully within a specic timeout (500 ms). For measurement point 2 and 4 the number of re ceived data frames as well as the frame size and the result of the validation were saved. Please note that a read timeout was possible, but not used. For the valida tion process every data frame sent by a client was lled with a data record that contains the following informa tion: a) the number of the client in the range from 1 tonb) the chosen frame size according to test param eterfand consecutive sequence number starting with 1 and raised with every send/receive cycle. This allows to validate if a received data frame belongs to the asso ciated sender and the data was successfully transmitted by comparing the received amount of data with test pa rameter f. In addition to this, it allows to detect \gaps"" in the sending/receiving cycle. All those recorded values formed the basis for our evaluation. 2.1 Test series We composed three test series based on the test para meter F(refer to table 1): 1.Plain forwarding : this test series only makes use ofnetlter 's forwarding capabilities. This means that the gateway component is instructed to for ward all data transmission between the client and the server component without any limitations, i.e. nonetlter rules were inserted. 2.Simple up and download rules : this test series is like the rst one but the gateway component in serts a upload and a download netlter rule per client thread. The rules simply checks the IP ad dresses and the protocol to test2. In total 2 n rules are active for a specic experiment. At the endnetlter is instructed to discard any other data packet that does not conform with the inserted rules. This is done by setting the policy of the specic rule table to drop anything that was not matched by any existing rule. 2To be more precise: \ iptables A FORWARD s <client> d <server> p <protocol> j ACCEPT "" for the upload and vice versa for the download direction.3.Simple up and download rules as well as QoS marks : this test series does the same as the se cond one but additionally inserts netlter rules per client thread that are responsible to tag in and outgoing network data packets with a QoS mark3. Those marks can be used within the iproute2 uti lity collection to manipulate the QoS subsystem of the Linux kernel. In total 4 nnetlter rules are inserted for a specic experiment. Please note that the QoS subsystems of all three test machines were not modied and used the default ( pfo fast, a simple packet rstinrstout queue with almost no overhead). The results of the rst test series served us as a baseline for the other two. During the experiments the hardware metrics were recorded, e.g. CPU and main memory usa ge. 2.2 Test machines characteristics The machine for the client component has two AMD Opteron 870 CPUs with 4 cores each and 2 GHz fre quency. The machines for the gateway and server com ponent have two AMD Opteron 890 CPUs with 4 cores each and 2.8 GHz frequency. Each of the three ma chines have 32 GByte of main memory (DDR2, ECC error correction). All test machines used a recent GNU/Linux distribu tion (Ubuntu 14.04 in the 64 bit server edition) as an operating system with a recent Linux kernel (3.1303). All unnecessary services were turned o. 2.3 Network conﬁguration Each of the three machines used for the tests has a 4 port network adapter with two Intel 82546EB chipsets. This allows four physical GBit connections. The gate way machine is dualhomed with a physical GBit con nection to each the client and server component ma chine. Each the client and server component has its own IP network. Since the gateway machine is dualhomed, it can con nect both networks and uses netlter to route, to lter and to transform the data transmissions between the two networks. All settings that were available for the tested trans port protocols and address families were left to their defaults. Although they oer the potential to raise the processing performance, the complexity in conjunction with our test parameters was too high. 3The rule template for this is \ iptables t mangle A PREROUTING s <client> d <server> p <protocol> j MARK setmark <QoSmark> "" for the upload and vice versa for the download direction. 33. DISCUSSION OF THE TEST RESULTS We executed every test series three times and all shown results use the mean value; the variance was uniformly low. In total we executed 3.780 single experiments. 3.1 General observations All three test series gave us a rst impression of the throughput rate for the tested protocols and address families. The average throughput rate for all 3.780 ex periments is depicted in gure 3 and 4. Both show the results for the tested address families and scaled to the potential transmission maximum of 1 GBit per second. The rst gure shows the throughput rate grouped by the tested number of concurrent client threads. This way it is possible to estimate the average throughput for any application where the number of clients are known. Please note that the shown throughput rates already include the decrease resulted by netlter 's ltering and routing. As visible in gure 3, the average throughput rate is quite stable but decreases with a higher num ber of concurrent clients. The only exception is SCTP where the throughput rate is surprisingly higher for 320 concurrent clients than for 80 and 160. The latter gure 4 shows the throughput rate grouped by the tested frame sizes. This gure also include all experiments where netlter rules were involved. Unsur prisingly the throughput rate increases with a higher frame size. The general case is shown in the last bar group labeled \ranged"". In this case the frame size was randomly chosen4in a range between 64 and 1024 be fore every send/receive cycle in every client thread. We can conrm the widely known fact that SCTP in terms of throughput is slower than TCP which is slower than UDP. Our results show that SCTP is in average 32.65 percent slower than TCP (minimum/maximum dierence: 9.28 and 48.23 percent) for all experiments. TCP however is in average 8.42 percent slower than UDP (minimum/maximum dierence: 5.18 and 10.64 percent). Our test results also showed that the throughput rate for IPv6 is noticeable lower than for IPv4. All tested protocols using IPv4 are in average 9.22 percent faster than with IPv6 (minimum/maximum dierence: 4.59 and 13.8 percent). As mentioned before, we recorded the available hard ware usage statistics during all experiments. Compared to the statistics for our router machine in its idle state, the impact of the netlter routing during the experi ments in average is marginal. In fact, this depends on the utilized network adapters and the system drivers. Our network adapters featured a special network pro cessor that massively reduced the CPU load by valida ting incoming network data packets natively, e.g. cal 4AMersenne random number generator was used. 510204080160320Average throughput per client for the tested number of clients Number of concurrent clientsThroughput in GByte/s (the higher the better) 0 0.2 0.4 0.6 0.8 1 SCTP/IPv4 SCTP/IPv6 TCP/IPv4 TCP/IPv6 UDP/IPv4 UDP/IPv6Figure 3: Average throughput rate per client for the tested number of clients 64128 256 5121024rangedAverage throughput for the tested framesizes Framesize of packets in bytesThroughput in GByte/s (the higher the better) 0 0.2 0.4 0.6 0.8 1 SCTP/IPv4 SCTP/IPv6 TCP/IPv4 TCP/IPv6 UDP/IPv4 UDP/IPv6 Figure 4: Average throughput rate per client for tested frame sizes culating checksums and verifying packet headers, which is otherwise done by the operating system. 3.2 Impact of netﬁlter As stated in the previous section, the rst test series (without any netlter rules) served us as a baseline for the other two that we executed (with dierent numbers ofnetlter rules). 4For the second and third test series, we calculated the dierence with the rst one. The results showed a de crease of 2.25 percent in average for all experiments where netlter rules were involved. We summarized the average throughput decrease in gure 5 (IPv4) and 6 (IPv6). These gures show the average throughput decrease grouped by the tested client thread numbers and additionally for every tested protocol and number of active netlter rules per client. As depicted in gure 5 and 6, the decrease is dierent for the tested address families: the decrease for IPv6 is lower than for IPv4 (2.71 vs. 1.79 percent in average). By considering the decrease percentages as a function of the number of inserted netlter rules, we calculated the gradient for each tested protocol and address family. In average the gradients are nearly constant . This can be barely seen on gure 5 and 6 because the xaxis is not linearly scaled. To conrm the nearly constant impact ofnetlter on the throughput rate, we reviewed our test results with respect to the number of routed data packets between the client and server thread(s) rather than the throughput rate. The review also proves our main ndings: 1.netlter 's performance in terms of throughput is independant from the used transport protocol, fra me size and address family as long as simple net lter rules are active 2. the throughput loss increases roughly linear with the number of inserted (simple) netlter rules al though this loss is quite insignicant The second main nding shown above allowed us to ex press the throughput loss per netlter rule: one can assume a throughput loss of 0.05 percent for any (sim ple) IPv4 rule and 0.03 percent for any (simple) IPv6 rule. 3.3 Client handling techniques The last objective of this study was to evaluate the client handling techniques in a clientserver applica tion: the server component was instructed to handle the data transmissions of streamoriented clients either in a separate thread per client or in a single thread using epoll() . To consider the dierences in the throughput between those two client handling techniques, we only used the experiment results of the rst test series and only for SCTP and TCP as well as for both address families. The average dierence is illustrated in gure 7 as a percentage between the threaded and unthreaded tech nique. This gure clearly indicates that there is a turning point which technique oers a higher throughput rate for a specic number of client connections to handle in a server process. 510204080160320Average throughput decrease by concurrent clients Number of concurrent clientsThroughput decrease in percent (the lower the better) 0.00.40.81.21.62.02.42.83.23.64.04.44.8SCTP with u/d rules per client SCTP width u/d and QoS rules per client TCP with u/d rules per client TCP width u/d and QoS rules per client UDP with u/d rules per client UDP width u/d and QoS rules per clientFigure 5: Average throughput decrease per client for IPv4 when netlter rules are active (u/d = up and download) 510204080160320Average throughput decrease by concurrent clients Number of concurrent clientsThroughput decrease in percent (the lower the better) 0.00.40.81.21.62.02.42.83.23.64.04.44.8SCTP with u/d rules per client SCTP width u/d and QoS rules per client TCP with u/d rules per client TCP width u/d and QoS rules per client UDP with u/d rules per client UDP width u/d and QoS rules per client Figure 6: Average throughput decrease per client for IPv6 when netlter rules are active (u/d = up and download) In our experiments this turning point was around 40 concurrent client connections. The technical specica tions of our test machine executing the server compo nent states the native handling of 32 concurrent threads. 5510204080160320Average throughput difference of threaded/unthreaded  client handling Number of concurrent clientsThroughput difference in percent −4.0−3.0−2.0−1.00.01.02.03.04.05.06.0 Positive values: throughput rate is higher for client handling with multiple threads than within a single thread. Negative values: throughput rate is higer for client handling within a single thread than with multiple threads,i.e. epoll().SCTP/IPv4 SCTP/IPv6 TCP/IPv4 TCP/IPv6Figure 7: Average throughput dierence be tween client handling with multiple threads and within a single thread This brought us to examine the system usage statis tics that were recorded during the experiments. We noticed a signicant increase of the number of context switches for our experiments with more than 40 con current threads. A context switch takes place when the operating system saves the current state of a process or thread for a later execution in favor of the execution of another process or thread. This storing/restoring of contexts is quite expensive in terms of computation time and can cause the system to slown down. In contrast the same experiments with 40 or more client connec tions that were handled via epoll() in a single thread did not show this impact. In summary we recommend to use the epoll() fa cility of the Linux kernel in a clientserver architecture in general. The reason is the better scalability com pared to a client handling with threads for a higher number of client connections. Although the through put rate is higher when threads are used, the rate dif ference is not signicantly higher compared to the hand ling with epoll() . In addition to this, an application using epoll() can prevent the operating system from unnecessary context switches that also eects other con current applications. 4. RELATED WORK "
279,Measuring Fatigue of Soldiers in Wireless Body Area Sensor Networks.txt,"Wireless Body Area Sensor Networks (WBASNs) consist of on-body or in-body
sensors placed on human body for health monitoring. Energy conservation of
these sensors, while guaranteeing a required level of performance, is a
challenging task. Energy efficient routing schemes are designed for the
longevity of network lifetime. In this paper, we propose a routing protocol for
measuring fatigue of a soldier. Three sensors are attached to soldier's body
that monitor specific parameters. Our proposed protocol is an event driven
protocol and takes three scenarios for measuring the fatigue of a soldier. We
evaluate our proposed work in terms of network lifetime, throughput, remaining
energy of sensors and fatigue of a soldier.","Wireless Sensor Networks (WSNs) seek the attention of researchers due to their effectiveness in multiple applica tions. A particular subclass of WSNs known as WBASN consists of multiple sensors attached with the human body to provide us real time feedback like temperature, heartbeat, pulse rate and ECG monitoring. Through WBASN a patient is monitored, and in case of critical situation an immediate action is made possible. Sensors collect data from the body of a patient and send it to physician. The primary application of WBASN is continuous healthcare monitoring. In WBASNs, monitoring of environment is a challenging task due to limited number and sensitive placementof sensor s. Misplacement of sensors cause degradation in the quality of captureddata. So, placement of tiny and light poweredsenso rs is an important factor. To prolong the lifetime of sensors, route selection is of key importance. Thus, Authors in [1], [ 2] and[3]proposedenergyefﬁcientroutingprotocols.Acommo n method for maximizing the sensors lifetime is minimization of communication between sensors. For energy consumption minimization [4], special attention must be given to enhanc e the communication system. Fatigue, physical or mental, is a subjective feeling of tiredness. Sometimes, it is correlated with lethargy. Phys i cal fatigue is the inability of muscles to maintain optimal physical performance. Medically, fatigue is considered as a symptom rather than a sign because it is reported by a patient in a subjective manner. Normally, fatigue is caused by loaded work, depression, boredom, mental stress, lack of sleep, etc [5]. Different routing protocols have been propo sed for various data demands in WBASNs. If sensors sense andgather data constantly and transmit it periodically then th is type of communication is called clock driven communication . In event driven communication, transmission is triggered b y a particular event. Query driven communication deals with th e transmission occurrence in response to a query. Various techniques are proposed for improving the efﬁ ciency of direct communication. In this paper, we present a new routingscheme formeasuringthe fatigueof a soldier. Ou r routingprotocoltakesthreescenariosintoaccount:(1)wa lking (2) slow running and (3) fast running. We use an event driven approach i.e. transmission is triggered by a particular eve nt. II. RELATED WORK AND MOTIVATION "
285,Making On-Demand Routing Efficient with Route-Request Aggregation.txt,"In theory, on-demand routing is very attractive for mobile ad hoc networks
(MANET), because it induces signaling only for those destinations for which
there is data traffic. However, in practice, the signaling overhead of existing
on-demand routing protocols becomes excessive as the rate of topology changes
increases due to mobility or other causes. We introduce the first on-demand
routing approach that eliminates the main limitation of on-demand routing by
aggregating route requests (RREQ) for the same destinations. The approach can
be applied to any existing on-demand routing protocol, and we introduce the
Ad-hoc Demand-Aggregated Routing with Adaptation (ADARA) as an example of how
RREQ aggregation can be used. ADARA is compared to AODV and OLSR using
discrete-event simulations, and the results show that aggregating RREQs can
make on-demand routing more efficient than existing proactive or on-demand
routing protocols.","Many routing protocols have been proposed for mobile ad hoc networks (MANET), and can be categorized as proac tive, reactive, and hybrid routing protocols [1, 2, 12, 16, 21]. Proactive or tabledriven routing protocols maintain routes to every network destination independently of the data traf c being forwarded. Reactive or ondemand routing pro tocols maintain routes for only this destinations for which there are data packets to be forwarded. Hybrid protocols use proactive and ondemand mechanisms. Section 2 provides a brief summary of the basic opera tion of proactive and ondemand routing. The proactive Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full cita tion on the ﬁrst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. Request permissions from permissions@acm.org. MSWiM ’16, November 1317, 2016, Malta, Malta c 2016 ACM. ISBN 9781450345026/16/11. . . $15.00 DOI:http://dx.doi.org/10.1145/2988287.2989155routing approach has the potential of high packetdelivery ratios and shorter endtoend delays, because routes are es tablished before data packets requiring those routes are of fered to the network. The price paid for such responsiveness is that signaling overhead is incurred even for those destina tions that are not needed, which may be too high. In theory, ondemand routing is designed to address this problem by requiring signaling overhead only for active destinations at the expense of incurring slightly longer latencies, because some data packets must wait for routes to be found. How ever, as prior comparative analysis of the performance of ondemand versus proactive routing schemes show [3, 5, 9, 18, 25], ondemand routing protocols end up incurring more overhead than proactive routing protocols in MANETs when topology changes that impact existing data  ows increase. Many techniques (e.g., see [1, 2, 16]) have been proposed to reduce the overhead incurred in the dissemination of each route request (RREQ), including clustering, location infor mation, dominating sets, and virtual coordinates. However, no prior work has addressed the impact of having relay routers aggregate RREQs they need to forward when they are intended for the same destinations. The main contribution of this paper is the introduction of a faulttolerant approach for routers to aggregate RREQs originated by dierent sources and intended for the same destinations. The proposed routerequest aggregation ap proach can be applied to any ondemand routing protocol (e.g., AODV or DSR [16]) and can make any routing proto col that uses ondemand routing techniques more ecient. Section 3 introduces the Adhoc DemandAggregated Rout ing with Adaptation (ADARA) protocol as a specic ex ample of the RREQ aggregation approach. Like AODV, ADARA uses destinationbased sequence numbers to pre vent routingtable loops and request identiers to denote each RREQ uniquely as in AODV. ADARA introduces route request aggregation and the use of broadcast signaling pack ets (RREQs, route replies and route errors) to substantially reduce signaling overhead. Section 4 presents an example of the operation of ADARA and how it improves performance compared to AODV [16]. However, the approach used in ADARA can be applied with proper modications to ondemand routing based on source routes (e.g., DSR [16]) or path information [8]. It can also be used in combination with prior techniques aimed at reducing signaling overhead, such as the use of geographical coordi nates of destinations [11, 24], virtual coordinates, connected dominating sets [23], address aggregation [22], and cluster ing [2, 15].arXiv:1608.08725v1  [cs.NI]  31 Aug 2016Section 5 presents the results of simulation experiments used to compare ADARA with two routing protocols that are representative of the state of the art in proactive routing and ondemand routing for MANETs, namely OLSR [4] and AODV. The experiments were designed to study the impact of node speed, pause times, number of sources, and network size on the packetdelivery ratio, average endtoend delay, and signaling overhead. The results show that ADARA per forms better than OLSR and AODV in all cases. The key reason for this is that ADARA is able to establish routes on demand incurring far less overhead than AODV and OLSR. 2. RELATED WORK "
181,A Machine Learning Approach to Routing.txt,"Can ideas and techniques from machine learning be leveraged to automatically
generate ""good"" routing configurations? We investigate the power of data-driven
routing protocols. Our results suggest that applying ideas and techniques from
deep reinforcement learning to this context yields high performance, motivating
further research along these lines.","Applying machine learning (ML) to computational chal lenges is prevalent in numerous areas in computer science (AI, computer vision, graphics, NLP, compbio, and beyond). Computer networking, in contrast, has largely withstood the ML tide until recently. Recent advances suggest that this might be changing [23, 33, 32]. We ask whether datadriven protocol design [23] can im prove upon today’s approaches in the context of routing, i.e., the selection of paths for trafﬁc within a network, or across networks. Why apply machine learning to routing? Routing is, ar guably, the most fundamental networking task and, conse quently, has been extensively researched in a broad variety of contexts (data centers, WANs, ISP networks, interdomain routing with BGP, wireless networks, and more). Tradition ally, routeoptimization contends with uncertainty about fu ture trafﬁc conditions in one of two manners: (1) optimizing routing conﬁgurations with respect to previously observed trafﬁc conditions, with the hope that these conﬁgurations fare well also with respect to the future, or (2) optimizing with respect to a range of feasible trafﬁc scenarios, in hope of providing high performance across the entire range [16, 10, 29, 7].Unfortunately, in general, routing conﬁgurations optimized with respect to speciﬁc trafﬁc conditions can fail miserably in achieving good performance even under nottoodifferent trafﬁc conditions. In addition, optimizing worstcase perfor mance across a broad range of considered trafﬁc scenarios might come at the expense of being far from the achievable optimum for the actual trafﬁc conditions. Intuitively, ML suggests a third option: leveraging infor mation about past trafﬁc conditions to learn good routing conﬁgurations for future conditions. While the exact future trafﬁc demands are unknown to the decision maker in advance, a realistic assumption is that the history of trafﬁc demands contains some information regarding the future (e.g., changes in trafﬁc across times of day, the skewness of trafﬁc, whether certain endhosts communicate often, etc.). Hence, a natural approach is to continuously observe trafﬁc demands and adapt routing with respect to (implicit or explicit) predictions about the future. Intradomain trafﬁc engineering (TE) as a case study. We initiate the study of MLguided routing by examining the classical environment of intradomain TE [15, 16, 17, 24, 50, 29, 10]–the optimization of routing within a single, self administered network. We leave the investigation of data driven routing in other contexts to future research (Section 7). We present a model for datadriven (intradomain) rout ing that builds on the rich body of literature on intradomain TE [15, 16, 17, 24, 50, 29, 10] and (multicommodity [43, 22, 7, 10, 29, 16, 5]) ﬂow optimization. We investigate, within this model, the application of different ML paradigms and machinery. In our investigation of MLguided intradomain TE we grap ple with two main questions: (1) How should routing be formulated as an ML problem? and (2) What are suitable representations for the inputs and outputs of learning in this domain? We next expand on each of these challenges, which also pertain to datadriven routing in other contexts. Learn future trafﬁc demands or learn routing conﬁgura tions? Supervised learning or reinforcement learning? A natural approach to MLbased routing is the following: ob serve past trafﬁc demands, apply ML to explicitly predict the upcoming trafﬁc demands, and optimize routing with respect to the predicted demands. In ML terms, this is a supervisedarXiv:1708.03074v2  [cs.NI]  11 Nov 2017learning task [39]. We evaluate several supervised learning schemes for pre dicting trafﬁc demands. Our preliminary results are discour aging, indicating that supervised learning might be ineffective if the trafﬁc conditions do not exhibit very high regularity. We next turn our attention to a different approach: reinforce ment learning [45]. Now, instead of explicitly learning future trafﬁc demands and optimizing with respect to these, the goal is to learn a good mapping from the observed history of trafﬁc demands to routing conﬁgurations. Our preliminary results suggest that this approach is more promising, yet realizing it requires care, as discussed next. What should the output of the learning scheme be? The intradomain routing context poses signiﬁcant challenges to the application of reinforcement learning. A key challenge is that the natural “output” of a routing scheme is a collection of rules specifying how trafﬁc is forwarded from each source to each destination. This output’s naive representation involves a very large set of parameters (as opposed to, e.g., selecting a single action from a fairly small set [32, 33]). Our initial results indicate that this can render learning slow and ineffec tive. We hence devise methods for constraining the size of the output without losing “too much” in terms of routing expres siveness. We leverage ideas from the literature on hopbyhop trafﬁc engineering [35, 50, 16] to efﬁciently learn, via deep reinforcement learning, good routing conﬁgurations. Our pre liminary ﬁndings suggest that this is a promising direction for improving upon today’s intradomain TE. Outlining a research agenda for datadriven routing. We believe that our investigation below but scratched the surface of datadriven routing. We leave the reader with many interest ing research questions, including (1) extending our approach to other routing contexts, (2) examining other performance metrics, (3) identifying better supervised learning approaches to trafﬁcdemand estimation, (4) scaling reinforcement learn ing in this context, and beyond. We discuss this research agenda in Section 7. 2. DATADRIVEN ROUTING MODEL In our framework, a decision maker (network operator / automated system) repeatedly selects routing conﬁgurations. Trafﬁc conditions vary and routing decisions are oblivious to future trafﬁc demands. Our focus is on the conventional opti mization objective of minimizing link overutilization (a.k.a. minimizing congestion) from trafﬁc engineering literature [16, 7, 10, 29]. Network. We model the network as a capacitated directed graphG= (V;E;c ), whereVandEare the vertex and edge sets, respectively, and c:E!R+assigns a capacity to each edge. Letndenote the number of vertices in Vand"
326,Distance's Quantification Algorithm in AODV Protocol.txt,"Mobility is one of the basic features that define an ad hoc network, an asset
that leaves the field free for the nodes to move. The most important aspect of
this kind of network turns into a great disadvantage when it comes to
commercial applications, take as an example: the automotive networks that allow
communication between a groups of vehicles. The ad hoc on-demand distance
vector (AODV) routing protocol, designed for mobile ad hoc networks, has two
main functions. First, it enables route establishment between a source and a
destination node by initiating a route discovery process. Second, it maintains
the active routes, which means finding alternative routes in a case of a link
failure and deleting routes when they are no longer desired. In a highly mobile
network those are demanding tasks to be performed efficiently and accurately.
In this paper, we focused in the first point to enhance the local decision of
each node in the network by the quantification of the mobility of their
neighbours. Quantification is made around RSSI algorithm a well known distance
estimation method.","Mobile ad hoc network (MANET) is an appealing technology tha t has attracted lots of research  efforts. Ad hoc networks are temporary networks with a dynamic topology which doesn’t have  any established infrastructure or centralized administration or standard support devices regularly  available as conventional network s [1]. Mobile Ad Hoc Networks (MANETs) are a set of  wireless mobile nodes that cooperatively form a network without infrastructure, those nodes can  be computers or devices such as laptops, PDAs, mobile phones, pocket PC with wireless  connectivity.  The ide a of forming a network without any existing infrastructure originates  already from DARPA (Defense Advanced Research Projects Agency) packet radio network's  days [2][3]. In general, an Ad hoc network is a network in which every node is potentially a  router and every node is potentially mobile. The presence of wireless communication and  mobility make an Ad hoc network unlike a traditional wired network and requires that the  routing protocols used in an Ad hoc network be based on new and different principles. Routing  protocols for traditional wired networks are designed to support tremendous numbers of nodes,  but they assume that the relative position of the nodes will generally remain unchanged. In ad  hoc, since the nodes are mobile, the network topology may c hange rapidly and unpredictably  and the connectivity among the terminals may vary with time. However, since there is no fixed  infrastructure in this network, each mobile node operates not only as a node but also as a router forwarding packets from one node  to other mobile nodes in the network that are outside the  range of the sender. Routing, as an act of transporting information from a source to a destination  through intermediate nodes, is a fundamental issue for networks. [4]   The problem that arises in th e context of ad hoc networks is an adaptation of the method of  transport used with the large number of existing units in an environment characterized by  modest computing capabilities and backup and fast topology changes.   According to the way of the creatio n and maintenance of roads in the routing of data, routing  protocols can be separated into three categories, proactive, reactive and hybrid protocols. The  proactive protocols establish routes in advance based on the periodic exchange of the routing  tables , while the reactive protocols seek routes to the request. A third approach, which combines  the strengths of proactive and reactive schemes, is also presented. This is called a  hybrid  protocol.   Adhoc On Demand Distance Vector routing protocol (AODV) [5]  is a reactive routing  protocol, who was standardized by the working group MANET [6] with IETF (Internet  Engineering Task force), by the (RFC 3561).   The protocol's  algorithm  creates routes betw een nodes only when the routes are requested by  the source  nodes, giving the network the flexibility to allow nodes to enter and leave the  network at will. Routes remain active only as long as dat a packets  are traveling along the paths  from the source to the  destination .When the source stops sending packets, the path will  time  out and close.   In this paper we propose a solution that enables each node in the network to determine the  location of its neighbors in order to create a more stable and less mobile road. For that purpose,  we locally quantify the neighbor’s distances of a n ode as the metric of mobility using AODV  protocol.   The remainder of this paper is organized as follows.  Section 2 , describes briefly the AODV  protocol. In  Section 3 , a summary of related work is presented. we present in Section 4 how to  quantify, evaluate, estimate mobility in ad hoc network. Section 5 shows the algorith m used the  quantification of the distance in AODV protocol.  Section 6  presents some simulations and  results. Finally  Section  7 concludes this paper.     2. AD HOC  ONDEMAND  DISTANCE  VECTOR   AODV is an on demand protocol which is capable of providing unicast, multicast [7], broadcast  communication and Quality of Service aspects (QoS) [8], [9]. It combines mechanisms of  discovery and maintenance roads of DSR (RFC 4728) [10] involving the sequence number (for  maintains the consistency of routing information) and the periodic updates of DSDV [11].   At the discovery of routes, AODV maintains on each node transit information on the route  discovery, the AODV routing tables con tain:   The destination address    The next node    The distance in number of nodes to traverse    The sequence number of destination    The expiry date of the entry of the table time.     When a node receives a packet route discovery (RREQ), it also notes in its  routing table  information from the source node and the node that just sent him the package, so it will be able  to retransmit the response packet (RREP). This means that the links are necessarily  symmetrical. The destination sequence number field of a rout e discovery request is null if the  source has never been linked to the destination, else it uses the last known sequence number. It  also indicates in this query its own sequence number. When an application sends a route discovery, the source waits for a mo ment before rebroadcast its search query (RREQ) road, after  a number of trials, it defines that the source is unreachable.   Maintained roads is done by periodically sends short message application called ""HELLO"" , if  three consecutive messages are not rece ived from a neighbor, the link in question is deemed to  have failed . When a link between two nodes of a routing path becomes faulty, the nodes  broadcast packets to indicate that the link is no longer valid. Once the source is prevented, it can  restart a p rocess of route discovery.   AODV maintains its routing tables according to their use, a neighbor is considered active as  long as the node delivers packets for a given destination, beyond a certain time without  transmission destination, the neighbor is consi dered inactive. An entered routing table is  considered active if at least one of the active neighbors using the path between source and  destination through active routing table entries is called the active path. If a link failure is  detected, all entries o f the routing tables participating in the active path are removed.   3. RELATED WORK   "
442,ethp2psim: Evaluating and deploying privacy-enhanced peer-to-peer routing protocols for the Ethereum network.txt,"Network-level privacy is the Achilles heel of financial privacy in
cryptocurrencies. Financial privacy amounts to achieving and maintaining
blockchain- and network-level privacy. Blockchain-level privacy recently
received substantial attention. Specifically, several privacy-enhancing
technologies were proposed and deployed to enhance blockchain-level privacy. On
the other hand, network-level privacy, i.e., privacy on the peer-to-peer layer,
has seen far less attention and development. In this work, we aim to provide a
peer-to-peer network simulator, ethp2psim, that allows researchers to evaluate
the privacy guarantees of privacy-enhanced broadcast and message routing
algorithms. Our goal is two-fold. First, we want to enable researchers to
implement their proposed protocols in our modular simulator framework. Second,
our simulator allows researchers to evaluate the privacy guarantees of
privacy-enhanced routing algorithms. Finally, ethp2psim can help choose the
right protocol parameters for efficient, robust, and private deployment.","Ethereum is the most popular public blockchain according to the number of issued transactions. Ethereum’s public ledger is completely transparent: every account’s balance and transaction history is visible to everyone. In numer ous applications, this level of transparency is undesirable. There are numerous privacyenhancing technologies described in the literature: mixers [13, 15, 18], stealth addresses [20], and confidential transactions [5, 22]. Some of these pro tocols have already been deployed and are continuously serving the Ethereum community by enhancing their privacy on the blockchain [2, 21]. However, blockchain privacy alone is not enough to achieve financial pri vacy. Users should be able to broadcast transactions in a privacypreserving manner. Specifically, no adversary should be able to link cryptocurrency ad dresses to their actual users’ unique identifiers, e.g., IP addresses, by logging networklevel communication between Ethereum full nodes. This problem is 1arXiv:2306.15024v1  [cs.CR]  26 Jun 2023even more pronounced in proofofstake Ethereum, where consensus partici pants must regularly broadcast privacycritical messages such as blocks and attestations. Previous work has already shown various attacks on privacy that exploited peertopeer (P2P) information [3, 8, 12]. To enhance the privacy of cryptocurrency users, several privacyenhanced broadcast and routing algo rithms were proposed [4, 7, 14]. In this work, we provide the following contributions. •We develop an opensource simulator, ethp2psim , that allows anyone to implement and evaluate various privacyenhanced broadcast and message routing algorithms. •Using our simulator, we evaluate the privacy guarantees of existing privacy enhanced message routing algorithms on the Ethereum P2P layer. •We identify several tradeoffs between privacy, robustness, and efficiency. The quantification of these tradeoffs can inform the deployment of these protocols. The rest of this paper is organized as follows. In Section 2, we present the related work on privacy on the P2P layer of cryptocurrencies. In Section 3, we introduce the pertinent background knowledge on privacyenhanced mes sage routing algorithms. Section 4 describes our system and threat model of Ethereum’s P2P layer. We introduce ethp2psim in Section 6 and evaluate stateoftheart routing protocols in Section 7. Finally, we conclude our work in Section 8. 2 Related work "
63,Effect of node mobility on AOMDV protocol in MANET.txt,"In this paper, we have analyzed the effect of node mobility on the
performance of AOMDV multipath routing protocol. This routing protocol in ad
hoc network has been analyzed with random way point mobility model only. This
is not sufficient to evaluate the behavior of a routing protocol. Therefore, in
this paper, we have considered Random waypoint, Random Direction and
Probabilistic Random Walk mobility Model for performance analysis of AOMDV
protocol. The result reveals that packet delivery ratio decreases with the
increasing node mobility for all mobility models. Also, average end-to-end
delay is also vary with varying node speed, initially upto 20 nodes in all
mobility models delay is minimum.","  A Mobile AdHoc Network (MANET) is a network where more than two autonomous mobile  hosts (mobile devices i.e. mobile phone, laptop, iP od, PDAs etc.) can communicate to each other  without any mean of fixed infrastructure.When sourc e( S) node want to send some data toward the  destination ( D), if they are fall in the same transmission range only can directly communicate  with each other.Otherwise with the help of intermed iate nodes communication can be established.  Any node may join and leave the network in any poin t of time, therefore the topology of the net  work changes frequently.  In this network some scar ce resources like battery power of mobile  devices, bandwidth of network. The depletion of bat tery power may affect lifetime of the whole  network as well as individual node existence in the  network.Due to dynamic topology and other  network constraint routing in MANET is a challengin g issue. Single path routing is not always  sufficient to disseminate data to the destination. Therefore; multipath routing comes into exis  tence toovercome the problem of single path routing .     In this paper we have considered various mobility m odels for proper and in depth analysis of  AOMDV protocol. In literature we have discussed var ious works related to AOMDV protocol  and brief about various multipath routing protocols . Most of the work carried out based on ran  dom waypoint mobility model.Therefore,we have analy zed AOMDV protocol with various net  work parameters and mobility models. Finally, we ha ve computed packet delivery ratio and aver  age endtoend delay with varying node speed for in dividual mobility models.    International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 6, No. 3, June 2014  92  The rest of the paper is organized as follows. In s ection II we have discussed various works re  lated to multipath routing. In section III, various  mobility models and AOMDV routing protocol  briefly discussed. Results analysis and simulation work is presented in Section IV and finally, we  have concluded the paper in Section V.    2.  RELATED WORKS   "
274,On the Routing Convergence Delay in the Lightning Network.txt,"Nodes in the Lightning Network synchronise routing information through a
gossip protocol that makes use of a staggered broadcast mechanism. In this
work, we show that the convergence delay in the network is larger than what
would be expected from the protocol's specification and that payment attempt
failures caused by the delay are more frequent, the larger the delay is. To
this end, we measure the convergence delay incurred in the network and analyse
what its primary causes are. Moreover, we further investigate and confirm our
findings through a time-discrete simulation of the Lightning Network gossip
protocol. We explore the use of alternative gossip protocols as well as
parameter variations of the current protocol and evaluate them by the resulting
bandwidth usage and convergence delay. Our research shows that there are
multiple ways of lowering the convergence delay, ranging from simple parameter
changes to overhauling the entire protocol.","Since its inception in 2008, the Bitcoin [8] network showed a n inability to scale to a high volume of transactions [13]. The Bitcoin Lightning Network [11] is a secondlayer payment channel network (PCN) that enables a high volume of lowcost oﬀchain Bitcoin transactions. In the Lightning Network, nodes route payments by ﬁnding a pa th to the destination based on a local copy of the public channel graph that each node maintains. In order to keep their channel graph views in sync , nodes propagate update messages via a peertopeer gossip protocol that uti lizes a socalled stag gered broadcast mechanism. As a result of the gossip protocol, it can—in the worst case—take more than 10minutes for a message to reach all nodes in the network. To avoid issues caused by stale routing information, a conve rgence delay of this magnitude goes against the common goal of routing pro tocols to reach2 N. Gögge et al. convergence quickly and reliably. The larger the convergen ce delay is, the more likely it is for payment attempts to fail since a source node m ight be computing a route based on stale information. Payment attempt failure s stemming from the convergence delay currently account for roughly 1.24%of all failures according to [14]. These failures can not be eliminated completely giv en that message propagation cannot be instant. Moreover, improved routing algorithms such as multipart payments (MPPs) do not improve the rate at which t hese failures occur. In fact, they may even increase their occurrences as t he probability of such failures only increases with the number of channels inv olved in a payment. In this work, we investigate the convergence delay of routin g information and its eﬀects on payments in the Lightning Network. Our main goa l is to present the state of the convergence delay in the Lightning Network, the issues it causes, and to layout potential improvement ideas. Our contributions c an be summarized as follows: –We analyze the Lightning Network’s gossip protocol in its cu rrent state by looking at and comparing clightning andLND, the two most popular node implementations. We measure the delay seen in the real netwo rk through a passive experiment and catalog the seen gossip messages (s peciﬁcally all channel updates) to understand why and when gossip messages are broadcast by nodes. The catalog is also useful to understand which type s of channel updates are potentially disruptive to payment routing. (Se ction 3) –We implemented a simulator capable of simulating the Lightn ing Network’s gossip protocol as well as payments in the Lightning Network . We can boot strap our simulation from historical topology data and repl ay recorded gossip messages. We use the simulation to gain further inside into h ow the gossip protocol operates and where its ineﬃciencies lie. (Section 4) –We evaluate the use of alternative message propagation mech anisms in the Lightning Network. Through simulation, we compare ﬂooding , a structured broadcast utilizing the channel graph topology, inventory based gossip, as well as eﬃcient set reconciliation using Minisketch [4]. (S ection 4) To our knowledge, there exists no prior related work on the co nvergence delay in the Lightning Network. However, there is a long history of convergence delay research in internet routing through the Border Gateway Pro tocol (BGP), which we use to draw inspiration for potential improvement ideas [ 1, 2, 7]. We discuss these and other related works in Section 6. In the following, we give a primer on information propagation and the convergence delay in the Li ghtning Network. 2 Information Propagation in the Lightning Network The Bitcoin Lightning Network [11] is a secondlayer paymen t channel network (PCN) that enables a high volume of lowcost oﬀchain Bitcoi n transactions. A payment channel describes a type of smart contract that enab les two parties to transact oﬀchain, with the only bottleneck being the netwo rk latency betweenOn the Routing Convergence Delay in the Lightning Network 3 the two parties. A PCN enables payments between nodes that do not have di rect channels with each other by routing payments over inter mediary nodes to reach the destination. In order to ensure that payment forwa rding requires no trust towards these intermediaries, such multihop paymen ts are secured through socalled Hash Time Locked Contracts (HTLCs). Candidate routes are discov ered by the originators through a sourcerouting algorithm operating on a local copy of the network graph, i.e., the routing information bas e (RIB). These lo cal information are regularly kept in sync by gossiping upda te messages in the network. Thechannel_announcement ,node_announcement andchannel_update mes sages are the three main messages of the Lightning Network’s gossip protocol. Channel announcements are used by two nodes to prove that the re is a channel between them. The proof comes in the form of four signatures t ying the nodes to the keys used in the funding transaction. Node announcement s are used to pro vide additional information about a node such as reachable n etwork addresses. Channel updates provide routing information for a channel e dge, such as routing fees and lock times. Each channel counterparty is able to bro adcast a channel update for its outgoing channel edge. In order for a channel t o be operational the network has to see three messages, one channel announcement and two channel updates (one for each edge of the channel). 2.1 Inﬂuences on the Convergence Delay While the details of the information dissemination protoco ls are left to the imple mentations, the most common implementations, such as clightning3andLND4, generally follow the same concepts. As we show later, the con cepts presented in the following and their concrete parameterizations can hav e a signiﬁcant impact on the convergence delay. Staggered Broadcast. The gossip protocol of the Lightning Network uses a stag gered broadcast that acts as a natural rate limiting mechani sm to ensure that the network is resistant to certain types of denialofserv ice (DoS) attacks. In a staggered broadcast, each node listens for gossip messages for a speciﬁed inter val (stagger interval) before broadcasting all messages to a subset of peers. While listening, messages concerning the same channels are dedup licated by the times tamp ﬁeld provided in the messages. If two channel updates fo r the same channel edge are seen, only the most recent update is kept in the broad cast queue. The value chosen for the stagger interval has a big impact on the c onvergence delay, since the higher it is the longer messages take to reach a majo rity of nodes. The speciﬁcation5recommends a 60second stagger interval. 3https://github.com/ElementsProject/lightning 4https://github.com/lightningnetwork/lnd 5https://github.com/lightning/bolts4 N. Gögge et al. clightning LND Staggered Broadcast 60 second stagger interval. 90 second stagger interval, batches are broadcast in 5 second intervals. Gossip Syncers Five syncers, individual rotations every hour.Three syncers, one being rotated every 20 minutes. Rate Limiting One channel update per day, burst up to 4.One channel update per minute, burst of up to 10. Table 1: Comparison of clightning andLNDwith regard to the most inﬂuential concepts on the convergence delay. Gossip Syncers. Thegossip_timestamp_filter message allows nodes to man age from which peers they want to receive new gossip. Not send ing the ﬁlter message is equivalent to not requesting any gossip. By defau lt, nodes only send ﬁlters to a subset of their peers, which are called active gossip syncers , while all other peers are passive gossip syncers . The number of active syncer connections each node maintains has an impact on the convergence delay si nce it determines how well nodes are connected. The more active syncer nodes ch oose the faster messages will propagate. Rate Limiting. While the staggered broadcast already oﬀers a form of rate li m iting, nodes in addition apply a second rate limit on a pered ge basis. Only a certain number of updates from the same edge are allowed for e ach rate limiting interval. Such policies exist to prevent nodes from spammin g the network with channel updates, but also to prevent I/O DoS attacks, since n odes write new channel updates to disk. A third rate limiting applies to red undant channel up dates (only diﬀering in the timestamp of the message), which are also considered askeep alive updates . A node will broadcast keep alive updates to indicate that its channels are still active and should not be pruned from ot her nodes’ views of the network. To rate limit keep alive updates, nodes usually only allow them in a deﬁned frequency, but the details diﬀer from implementatio n to implementation. Comparing Node Implementations While the Lightning implementations gen erally follow the concepts just discussed, the speciﬁc para meters used by these implementations can diﬀer quite a bit. In the following, we t herefore discuss the relevant details of the two most popular implementation s of the Lightning Network protocol, clightning andLND. As also shown in Table 1, the behavior of clightning generally sticks to the speciﬁcation’s guidance, while LNDdiﬀers from it signiﬁcantly with a stagger interval of 90seconds. When the timer expires, all seen messages are split up into batches and broadcast to all relevant peers in 5second intervals. The function for calculating the batch size from the total number of messa gesnto broadcastOn the Routing Convergence Delay in the Lightning Network 5 is the following: sb(n) =min/parenleftbigg 10,n·5s+90s−1 90s/parenrightbigg The number of broadcast batches increases with the number of messages, but is capped at 18in order to prevent the overlapping of stagger intervals. Wi th5 seconds between batches and a maximum of 18batches, the last message may potentially be broadcast 17·5 = 85 seconds after the stagger timer expires. A plot ofsb(n)can be seen in Figure 1a. Only if there are more than 162messages seen per 90second stagger interval, all 18batches will be ﬁlled. If the general rate of messages in the network is lower than that, less batch es will be used lowering the convergence delay.6 The rate limiting policies of these two node implementation s do not play to gether without friction. If a channel is updated once per min ute, aclightning node would disregard all updates after the fourth for up to on e hour, while a LND node would happily accept all updates. The clightning node will not relay disregarded updates, which can cause the convergence delay for these updates to increase. However, this is not an observable issue, since the majority of nodes are running LND. 3 Gossip Traﬃc Analysis In the following, we describe our methodology for measuring and analysing gossip traﬃc in the Lightning Network. 3.1 Measuring the Convergence Delay In order to measure the convergence delay in the Lightning Ne twork, we used the pythonpylnproto7package to connect to and communicate with nodes on the network. The node addresses were extracted from a topology s napshot collected from anLNDnode right before the start of the experiment (Oct. 30, 2021) . We connected to as many nodes as possible and chose all of them as our active gossip syncers. We recorded all received messages including at whi ch times {t1,...,tn} and from which node we got the message. The recorded timestam ps can then be used to estimate the convergence delay in the network by look ing at the diﬀerence between the ﬁrst and last timestamp. This estimation method assumes that the ﬁrst timestamps in these lists correspond to the time of init ial broadcast and that all nodes have seen the message after the last timestamp . 6The stagger interval was increased in January 2019 from 30to90seconds with the reasoning to lower bandwidth usage by slowing the propagati on of messages [10]. In April 2019, the subbatch broadcast was introduced with the reasoning to eliminate bursty resource usage after the stagger timer expires [6]. W e could not ﬁnd records of detailed discussion on how the exact parameter values for th ese changes were chosen. 7https://github.com/ElementsProject/lightning/tree/m aster/contrib/pylnproto6 N. Gögge et al. 0 200 400 600 800 1 ,0000204060 Number of messages to be broadcastNo. msgs/batch No. batches (a)LNDbatch sizes.0 500 1000 1500 Time in seconds0.000.250.500.751.00Share of converged nodes (b) Measured convergence delay. Fig. 1:LND’s broadcast batching and measured convergence delay. 0 10000 20000 30000 Time in seconds0.000.250.500.751.00Share of all messageschannel updates node announcements channel announcements (a) Observed shares of update messages.0 10000 20000 30000 Time in seconds0.000.250.500.751.00Share of all updateskeep alive closures reopens disruptive non disruptive misc (b) Channel updates cataloged by type. Fig. 2: Categorization of observed gossip messages. In total, we received 69,942unique gossip messages from 1,046nodes over a time span of close to 10hours. To estimate the convergence delay, we used all messages that were received at least from 500diﬀerent nodes. Figure 1b shows the share of nodes that have seen a message in r elation to the time since initial broadcast: the average time it takes f or a node to see a message is 359.9seconds, with 95%of nodes seeing messages after 753seconds and100% of nodes seeing messages after 2,500seconds. 3.2 Dissecting Recorded Gossip We then categorized the collected data and examined which sh are of gossip messages are node announcements, channel announcements or channel updates. We also analyzed the contents of all channel updates to under stand when nodes send updates and how they typically update channel policies . As seen in Figure 2a, the rate at which new messages arrive is m ore or less constant. Of all messages we recorded, 5.13%were node announcements, 0.34%were channel announcements and 94.53%were channel updates. This distribution matches our expectations, as channel announc ements are directly rate limited by the blockchain, node announcements only nee d to be broadcastOn the Routing Convergence Delay in the Lightning Network 7 infrequently to modify network addresses or add new feature announcements, and channel updates change channel policies, which happens regularly over the course of a channel’s lifespan. We categorized channel updates into six diﬀerent categorie s: –Keepalive updates only diﬀer in the timestamp ﬁeld. These updates are meant to tell the network that a channel is still active. They made up 45.32% of all recorded messages. –Channel closure updates close a channel temporarily or permanently. Tem porary channel closures can happen if a peer goes oﬄine due to network issues, in which case the other peer will broadcast such an up date to in form the network not to route over the oﬄine peer. These updat es made up 19.29%of all recorded messages. –Channel reopen updates open a channel that was previously closed. These updates made up 18.66%of all recorded messages. –Disruptive updates change the channel policy in a way that could cause payment failures, if the payment source does not know of the u pdate. Chan nel closures are excluded because we categorize them separa tely. Disruptive updates made up 8.57%of all recorded messages. –Nondisruptive updates change the channel policy in a way that could cause a payment source to overpay on fees or use a higher lock time t han needed. These updates made up 7.22%of all recorded messages. –Misc. updates are all other updates that we saw. For example, updat es that change the htlc_minimum_msat ﬁeld fall into this category. These updates made up 0.99%of all recorded messages. The observed amount of keepalive updates is slightly conce rning, as they make up roughly 50%of all seen updates. This amount of keepalive updates cannot be explained by nodes broadcasting them at a reasonab le rate. In theory, a keepalive only has to be sent for channels that did not have an update within 14days. Therefore, transmitting a keepalive update every 13days should be suﬃcient to prevent other nodes from pruning the channel. Fi gure 3a shows the diﬀerence in the timestamp ﬁeld between the keepalive a nd the previous update: we observe that for almost all of the keepalive upda tes the diﬀerences lie between 86,400and88,200seconds, which corresponds to exactly 1day and1 day plus 30minutes. We found that LNDnodes are responsible for these updates, because they check every 30minutes if any of their channels had an update within the last day, and will broadcast a keepalive update o therwise. However, we were not able to explain the large peaks seen in Figure 3a at the interval boundaries. Moreover, we did not observe any keepalive upd ates with a smaller diﬀerence, because LNDnodes do not relay such updates and therefore they do not propagate through the network. Looking at the timestamp diﬀerences for all updates in our ch annel reopen category (cf. Figure 3b), we see that most channels edges tha t get reopened were disabled for short periods of time. For example, 60%of edges were closed for less than 22minutes. This is likely caused by network issues that lead no des to temporarily disable edges.8 N. Gögge et al. 86000 87000 88000 Timestamp delta101103No. keepalives (a) Time since last keepalive.0 2500 5000 7500 10000 Timestamp delta0.000.250.500.751.00Share of temporary closures (b) Cumulative channel closure durations. Fig. 3: Timestamp diﬀerences of keepalive and channel clos ure updates. 4 Simulation Study In the following, we discuss the conducted modelbased simu lation study on the routing convergence delay in the Lightning Network. 4.1 Simulation Model The behavior of realworld peertopeer networks is inﬂuen ced by many diﬀerent variables. Nodes participating in such networks can be dive rse in geographical location, bandwidth restrictions, software implementati on, software version or conﬁguration, and simulating all diﬀerent permutations is simply not feasible. In the context of investigating the gossip protocol of the Li ghtning Network, we restrict the scope of our simulation by making the followi ng assumptions: if two nodes are connected through a channel, they have a consta nt TCP connec tion. The snapshot we use to bootstrap our simulation contai ns all nodes and all channels that exist in the network. We ignore any nonlis tening nodes that were not announced to the network, as well as private channel s. Our simulation propagates node and channel announcements, but does not act ually add them to the simulated topology. Only channel updates are applied to the simulated topology. The gossip algorithm is the main inﬂuence on the co nvergence delay, and we do not simulate other potential inﬂuences such as an ov erhead caused by cryptographic functions. Payments are atomic and instan t. All nodes in each simulation follow the same gossip protocol. All nodes have t he same bandwidth of1MB/s in up and download. We chose to implement our discreteevent simulator8in the Go programming language and bootstrap the simulation from historical topo logy snapshots that were extracted from an LNDnode with a fully synced network graph. These snap shots contain a list of nodes and channels which we use to buil d our simulation network. The snapshot we use for all simulations contains 17,332nodes,77,921 channels and was taken on Oct. 30, 2021. In order to simulate a realistic amount 8https://github.com/dergoegge/lnconvpapersimOn the Routing Convergence Delay in the Lightning Network 9 of traﬃc, we replay gossip messages that we recorded in the re al network. This works well as most gossip messages can be traced back to an ori gin node in the network as long the snapshot we use to bootstrap the simulati on is not much older than the start of the recorded period. For messages for which we could not ﬁnd an origin in our snapshot we choose a random origin. Bandw idth is mod eled by each node having an incoming byte counter that gets in cremented with every message that is being downloaded and decremented with every message that is fully received. The arrival time of a new message is ca lculated based on a ﬁxed bandwidth, the number of incoming bytes and a ﬁxed late ncy overhead of100ms. 4.2 Simulation Results In this section, we present the data collected on an LNDsimulation scenario in which we replayed the ﬁrst hour of the gossip we recorded in Se ction 3, consist ing of7,217network messages. We simulate 100,000payment attempts which were uniformly distributed over the hour. Payment sources a nd destinations are chosen randomly and the payment amount is set to 1satin order to reduce interference by failures originating from anything else th an outdated routing information. Bandwidth. The simulated network transferred a total of 40.77GBto deliver the 7,217messages to all nodes. The theoretical lower bound for bandw idth usage Bminis the product of the number of all nodes, the total number of m essages and the average message size, i.e., Bmin=num_nodes·num_messages ·avg_message _size Assuming all messages are channel updates with a size of 128bytes,Bmin= 16.01GB. We therefore found that the network uses 2.55times the theoretically needed bandwidth Bmin. Redundancy. 6.29%of messages will be seen only once, 33.28%will be seen twice, 59.93%will be seen three, and 0.5%will be seen four times. All nodes have 3 active gossip syncers which explains why most messages are s een three times or less. A message is only seen 4times if it is received as part of the initial broadcast, which goes out to all connected peers. On average each messag e is seen2.55times. Note that this is the same factor as the one from our bandwidth calculations: every message that is received more than once is exactly the o verhead to a perfect broadcast in which every message is received only once by eac h node. Convergence Delay. We measure the convergence delay by recording how long it takes a message to be seen for the ﬁrst time by every node. This is very similar to the measurements conducted in Section 3, but within a simu lation we get much more accurate data since we have an omniscient view. Fig ure 4a compares the convergence delay we recorded in the real network to the o ne we observed10 N. Gögge et al. 0 1000 2000 Time in seconds0.000.250.500.751.00Share of converged nodeslnd lndnokeepalives real (a) Measured vs. simulated conv. delay.0 50 100 150 Wait time in seconds0.000.250.500.751.00Share of messages lnd lndnokeepalives (b) Queue waiting times. Fig. 4: Convergence delay and broadcast queue waiting times in a simulated network consisting only of LNDnodes. in the simulation. In our simulation, the average time it too k for a node to see a message is 291.21seconds, with 95%of nodes seeing messages after 510seconds and100% of nodes seeing messages after 1,075seconds. The convergence delay seen in the simulation slightly diﬀers from the delay measur ed in the real network with messages in the simulation propagating faster after in itially being broadcast and messages taking longer to reach all nodes in the real netw ork. From 20%to 80%of nodes having seen the messages it takes 240seconds in the simulation while in took 265seconds in the real network. As mentioned previously, roughly 50%of the messages that we recorded are keepalive updates. We ran a simulation without the keep alive updates (lndnokeepalives ) and found that the convergence delay was signiﬁcantly reduced, with 95%of nodes converging after 374.19instead of 510seconds. Waiting Times. Looking at the broadcast queue waiting times of messages we observed that waiting times and hence the convergence delay become larger the more messages are propagating through the network. This is e xplained by the subbatch trickling approach that LNDhas chosen which makes waiting times dynamic to a certain degree. The growth of waiting times is bo unded by the maximum number of subbatches that LNDwill send. A plot of the waiting times can be seen in Figure 4b. The minimum waiting time is 0seconds and the maximum is 175seconds. A message will wait 175seconds, if it arrives at the beginning of the 90second stagger interval and gets broadcast in the last sub batch,85seconds after the stagger timer ticks. Failed Payment Attempts. Out of the 100,000tried payment attempts, 42% were successful and 58%failed.0.114% of attempts failed because the payment source did not have a recent update for one of the channel edge s in the payment route. As we have seen, the staggered broadcast is quite ineﬃcient i n its bandwidth usage with messages being seen 2.55times on average by the same node andOn the Routing Convergence Delay in the Lightning Network 11 Algorithm Conv. Delay Bandwidth Usage Payment attempts lnd 509.75s 40.47 GB 602 lndt1s 312.65s 39.36 GB 349 lndsb100 266.54s 38.9 GB 316 lndinv 509.46s 19.26 GB 592 lndinvt1s 313.45s 19.41 GB 394 lndinvsb100 267.93s 20.23 GB 274 clightning 101.29s 59.52 GB 171 clightninginv 103.2s 26.36 GB 161 spanning (BFS) 1.11s 15.7 GB 5 flooding4 2.72s 50.7 GB 3 flooding8 1.72s 94.7 GB 1 flooding16 1.16s 180.92 GB 2 flooding32 0.82s 353.21 GB 4 minisketch4 19.25s 19.15 GB 33 minisketch8 20.24s 19.84 GB 43 minisketch16 20.7s 21.45 GB 43 minisketch32 20.54s 21.46 GB 30 Table 2: Convergence Delays (95%), bandwidth usage, and unc onverged payment attempts. 95%of nodes converging after 510seconds. The share of unconverged payment attempts ( 0.114%) does not seem that problematic but it could be argued that in absolute numbers the total number of unconverged payment at tempts can still be large. The research by Waugh and Holz suggests that this rate is actually higher at around 1.2%[14]. Exploring alternative gossip algorithms seems worth while based on these results. 4.3 Evaluating Alternative Gossip Strategies In this section, we layout ideas for potential alternative g ossip algorithms that the Lightning Network could employ. We use our simulator to comp are the diﬀerent algorithms and evaluate the feasibility of these alternati ves being used in the real network based on bandwidth usage, convergence delays, and their impact on payment attempts. We compare the following alternative s trategies: ﬂooding, a structured broadcast using a global spanning tree, invent ory based gossip, parameter variations of the current protocol, as well as set reconciliation using Minisketch [4]. We compare all alternative strategies to each other and the s imulation data from Section 4.2. We speciﬁcally compare bandwidth usage, c onvergence times and the number of unconverged payment attempts and simulate each algorithm using the same snapshot and replaying the same messages as be fore (17,332 nodes,77,921channels, 7,217messages over 1hour,100,000payment attempts). The convergence delays and bandwidth usage for all the diﬀer ent algorithms are listed in Table 2.12 N. Gögge et al. As expected, ﬂooding has the highest bandwidth usage with lo w convergence delays and the spanning tree algorithm (global tree constru cted using breadth ﬁrst search) has the lowest bandwidth usage and the lowest co nvergence delay. With ﬂooding, we see the bandwidth consumption scaling prop ortionally with increased connectivity (number of active syncer connectio ns). The convergence delay is naturally smaller with increased connectivity. LND’s choice of staggered broadcast parameters results in a rou ghly ﬁve times increase in the convergence delay compared to clightning . WhileLND’s ap proach leads to a larger convergence delay it also reduces ba ndwidth usage by about33%. We simulated two variations of LND’s algorithm, one with a minimum subbatch size of 100instead of 10messages ( lndsb100 ), and one with a sub batch delay of one instead of ﬁve seconds ( lndt1s ). Both of these parameter changes lead to faster messages broadcast after the stagger timer expires leading to an decrease in convergence delay of 39%forlndt1s and48%forlndsb100 . Inventorybased protocols announce a shortened version of the full message to give the receiver the chance to only request the full messa ge once. For gossip messages in the lightning network, the size of an inventory m essage can be 64 bits [12]. We see that inventory based protocols reduce band width usage signiﬁ cantly when compared to their regular variants. With lndinv requiring 52.4% less bandwidth than lndandclightninginv requiring 55.7%less bandwidth thanclightning . The convergence delays however are unaﬀected by the de crease in bandwidth usage. Usually it would be expected that latency increases with an inventorybased gossip protocol but the extra round trip has no impact here, given that the stagger interval is multiples larger th an the round trip time. In Figure 5a, we compare the bandwidth usage of ﬂooding and se t reconcili ation, in relation to the connections made by each node. Our s et reconciliation algorithm is based on the Erlay protocol that was proposed fo r the transaction relay in the Bitcoin network [9]. In our protocol, we impleme nted no fanout ﬂooding and hence all messages are exchanged via set reconci liation. We observe that bandwidth usage does not increase proportionally with the number of con nections made for the set reconciliation protocol. Instead , the bandwidth usage scales with the rate of messages in the network, just like the Erlay protocol. We observe that the number of unconverged payment attempts i s highly correlated with the convergence delay. We do not distinguis h between failed payment attempts and attempts that arise due to opportunity costs, as the com bined number of these attempts is suﬃcient in evaluating diﬀ erent protocols. As seen in Figure 5b, based on our limited data set of the diﬀeren t algorithms, the relationship between the convergence delay and the number o f unconverged pay ment attempts is linear. The lower the convergence delay, th e fewer unconverged payment attempts can be observed. 5 Discussion The staggered broadcast protocols ratelimit the propagat ion of channel updates by deduplicating updates for the same channel with in the st agger interval. ThisOn the Routing Convergence Delay in the Lightning Network 13 4 8 16 32 Number of active gossip connections0100200300Bandwidth in GBﬂooding minisketch (a) Bandwidth usage vs. increased connec tivity.0 200 400 Convergence delay in seconds0200400600Payment attempts (b) Unconverged payment attempts vs. convergence delay. Fig. 5: Simulated parameter interdependencies. means that a node will only forward one channel update for the same channel edge in every stagger interval. No potentially important up dates are discarded, since the newest update that was seen will always be forwarde d. This form of rate limiting prevents the network from witnessing rapid ch anges in channel policies, while still propagating the newest updates. The p ropagation of the newest updates is signiﬁcantly delayed as we have shown thro ugh the simulations and measured in Section 3. We argue that this form of rate limi ting implicitly discourages frequent channel updates at the cost of deliver ing the newest updates with large delays. Explicitly discouraging frequent updat es through strict per channel rate limiting as discussed in Section 3 could be well suited for some of our alternative protocols that aim to deliver messages fast er. A strict rate limit would discard newer updates that violate the rate limit, so h onest nodes should never broadcast messages for the same channel in violation o f the limit. LND’s choice of parameters for its staggered broadcast is a bit o f a mystery, since there is no public record on how the exact values were ch osen. However, broadcasting messages in subbatches instead of one large b atch after the stagger timer expires is a good choice to reduce bursty resource usag e. We would however recommend that the LNDdevelopers revisit their choice of parameters for the staggered broadcast, because reducing bandwidth usage by 33%while increasing the convergence delay by a factor of ﬁve does not seem like a re asonable trade oﬀ (compared to parameters mentioned in the speciﬁcation). As we have shown through the simulations, adjusting the parameters can have a big impact on the convergence delay. Adjusting these parameters would be the least complex software change to address the large convergence delay, whi le maintaining the rate limiting properties of the staggered broadcast. Introducing an inventorybased gossip protocol reduces th e bandwidth usage without changing the convergence delay at all. In combinati on with adjusting the parameters of the staggered broadcast the convergence d elay could also be lowered. An inventorybased gossip protocol could remain a staggered broadcast and thereby maintain its rate limiting eﬀect without introd ucing strict rate lim14 N. Gögge et al. iting. The added software complexity of an inventorybased gossip is fairly low and there already exists a proposal on the speciﬁcation [5]. Increasing the number of connections that nodes make to goss ip (connectiv ity) can lead to better reliability in adversarial environm ents. With low connec tivity an attacker has to control less connections to be able to censor information from reaching a victim. For some protocols an increase in con nectivity can also lead to a reduction in convergence times because the spread f actor is higher. Even though the spanning tree protocol seems great based on t he results, it is not a great ﬁt for the real network. As mentioned earlier, the protocol makes the assumption that all nodes agree on the exact same static span ning tree, which would not trivially work in the real network. A single tree is also not going work for security and reliability reasons. If one node in the tree goes oﬄine, none of the nodes in its subtree would receive new messages. Introd ucing multiple trees to gain redundancy would increase the bandwidth usage which makes using a spanning tree less desirable in the ﬁrst place. A spanning tr ee protocol with multiple trees would probably turnout to be similar in eﬃcie ncy to a ﬂooding protocol. A ﬂooding protocol comes with a small convergence delay of on e to two sec onds but increases bandwidth usage above that of the current algorithm ( lnd). Bandwidth usage increases linearly with increased connect ivity. If an increase in connectivity is wanted then ﬂooding would not be suitable . In fact all proto cols besides set reconciliation lead to a proportional incr ease in bandwidth with increased connectivity. Compared to the other protocols, set reconciliation has a sm all convergence delay and low bandwidth usage. Increasing connectivity is a lso possible without increasing bandwidth usage, as the bandwidth usage scales w ith the rate of mes sages seen in the network. Introducing set reconciliation c omes with much greater software complexity than any of the other protocols. Multip le new message types would need to be introduced and the Minisketch library adds a dependency. Decreasing the number of unconverged payment attempts can a lso be done without changing the gossip protocol. Nodes could temporar ily allow payments that use old channel policies, after broadcasting a new poli cy. This would work well for fee or lock time adjustments. In the end this depends on the channel owners preferences on whether or not they want updates to imm ediately take eﬀect. 6 Related Work "
240,Security Issues in the Optimized Link State Routing Protocol Version 2 (OLSRV2).txt,"Mobile Ad hoc NETworks (MANETs) are leaving the confines of research
laboratories, to find place in real-world deployments. Outside specialized
domains (military, vehicular, etc.), city-wide communitynetworks are emerging,
connecting regular Internet users with each other, and with the Internet, via
MANETs. Growing to encompass more than a handful of ""trusted participants"", the
question of preserving the MANET network connectivity, even when faced with
careless or malicious participants, arises, and must be addressed. A first step
towards protecting a MANET is to analyze the vulnerabilities of the routing
protocol, managing the connectivity. By understanding how the algorithms of the
routing protocol operate, and how these can be exploited by those with ill
intent, countermeasures can be developed, readying MANETs for wider deployment
and use. This paper takes an abstract look at the algorithms that constitute
the Optimized Link State Routing Protocol version 2 (OLSRv2), and identifies
for each protocol element the possible vulnerabilities and attacks -- in a
certain way, provides a ""cookbook"" for how to best attack an operational OLSRv2
network, or for how to proceed with developing protective countermeasures
against these attacks.","OLSRv2 (the Optimized Link State Routing Protocol version 2) [1] , [2], [3], [4], [5] is a succes  sor to the widely deployed OLSR [6] routing protocol for MANETs (M obile Ad hoc NET  works). OLSRv2 retains the same basic algorithms as its pr edecessor, however offers various  improvements, e.g. a modular and flexible architecture allow ing extensions, such as for security,  to be developed as addons to the basic protocol.   The developments reflected in OLSRv2 have been motivated by incre ased realworld deploy  ment experiences, e.g. from networks such as FunkFeuer [7], an d the requirements presented for  continued successful operation of these networks. With particip ation in such networks increasing  (the FunkFeuer community network has, e.g., roughly 400 individual participants), operating  with the assumption, that participants can be “trusted” to behave in a nondestructive way, is  utopia. Taking the Internet as an example, as participation in t he network increases and becomes  more diverse, more efforts are required to preserve the int egrity and operation of the network.  Most SMTPservers were, e.g., initially available for use by all and sundry on the Internet – with  an increased populace on the Internet, attacks and abuses caused t he recommended practice is  today to require authentication and accounting for users of such S MTP servers [8]. International Journal of Network Security & Its App lications (IJNSA), Volume 2, Number 2, April 2010    163   A first step towards hardening against attacks disrupting t he connectivity of a network, is to un  derstand the vulnerabilities of routing protocol, managing the co nnectivity. This paper therefore  analyzes OLSRv2, to understand its inherent vulnerabilities and resil iences. The authors do not  claim completeness of the analysis, but hope that the identif ied attacks, as presented, form a  meaningful startingpoint for developing secured OLSRv2 networks.  1.1  OLSRv2 Overview  OLSRv2 contains three basic processes: Neighborhood Discovery, MP R Flooding and Link  State Advertisements, described in the below with sufficien t details for elaborating the analysis  in latter sections of this paper.  1.1.1  Neighborhood Discovery  Neighborhood Discovery is the process, whereby each router discover s the routers which are in  direct communication range of itself (1hop neighbors), and dete cts with which of these it can  establish bidirectional communication. Each router sends HELLOs , listing the identifiers of all  the routers from which it has recently received a HELLO,  as well as the “status” of the link  (heard, verified bidirectional). A router a receiving a HELLO from a neighbor b, in which b  indicates to have recently received a HELLO from a, considers the link ab to be bidirectional.  As b lists identifiers of all its neighbors in its HELLO, a learns the “neighbors of its neighbors”  (2hop neighbors) through this process. HELLOs are sent periodically,  however certain events  may trigger nonperiodic HELLOs.  1.1.2  MPR Flooding  MPR Flooding is the process whereby each router is able to, ef ficiently, conduct networkwide  broadcasts. Each router designates, from among its bidirec tional neighbors, a subset (MPR set)  such that a message transmitted by the router and relayed by t he MPR set is received by all its 2 hop neighbors. MPR selection is encoded in outgoing HELLOs. Routers m ay express, in their  HELLO messages, their “willingness” to be selected as MP R, which is taken into consideration  for the MPR calculation, and which is useful for example when a n OLSRv2 network is  “planned”. The set of routers having selected a given router as MPR is the MPRselectorset of  that router. A study of the MPR flooding algorithm can be found in [9] .  1.1.3  Link State Advertisement  Link State Advertisement is the process whereby routers are determining which link state infor  mation to advertise through the network. Each router must advertis e, at least, all links between  itself and its MPRselectorset, in order to allow all r outers to calculate shortest paths. Such link  state advertisements are carried in TCs, broadcast through t he network using the MPR flooding  process described above. As a router selects MPRs only from among  bidirectional neighbors,  links advertised in TC are also bidirectional and routing paths  calculated by OLSRv2 contain  only bidirectional links. TCs are sent periodically, however certain events may trigger non periodic TCs.  1.2  Link State Vulnerability Taxonomy  Proper functioning of OLSRv2 assumes that (i) each router can acquire and maintain a topology  map, accurately reflecting the effective network topology; and  (ii) that the network converges,  i.e.  that all routers in the network will have sufficiently i dentical topology maps. An OLSRv2  network can be disrupted by breaking either of these assumptions,  specifically (a) routers may be  prevented from acquiring a topology map of the network; (b) router s may acquire a topology  map, which does not reflect the effective network topology; a nd (c) two or more routers may  acquire inconsistent topology maps.  International Journal of Network Security & Its App lications (IJNSA), Volume 2, Number 2, April 2010    164   1.3  OLSRv2 Attack Vectors  Besides “radio jamming”, attacks on OLSRv2 consist of a mali cious router injecting “correctly  looking, but invalid, control traffic” (TCs, HELLOs) into the ne twork. A malicious router can  either (a) lie about itself (its ID, its willingness to serve as MPR), henceforth Identity Spoofing  or  (b) lie about its relationship to other routers (pretend existence  of links to other routers), hence  forth Link Spoofing . Such attacks will infine  cause disruption in the Link State Advertisement  process, through targeting the MPR Flooding mechanism, or by caus ing incorrect link state in  formation to be included in TCs, causing routers to have incomple te, inaccurate or inconsistent  topology maps. In a different class of attacks, a malicious rout er injects control traffic, tuned to  cause an inrouter resource exhaustion , e.g.  by causing the algorithms calculating routing tables  to be invoked continuously, preventing the internal state of the route r from converging.  1.4  Paper Outline  The remainder of this paper is organized as follows: section 2 p resents related work to this pa  per. Section 3, 4, 5 and 6 each represents a class of disrupti ve attacks against OLSRv2, detailing  a number of attacks in each class. Section 7 summarizes inhere nt resilience, as observed in  OLSRv2, and the paper is concluded in section 8.  2  RELATED WORK   "
183,Study of Uniform Jitter Mechanism for Metric-based Wireless Routing.txt,"Many wireless protocols wait a small and random amount of time which is
called jitter before sending a packet to avoid high contention and packet
collision. Jitter has been already proposed for many routing protocols
including AODV and LOADng. However, since they do not consider any link quality
parameters or metrics (such as ETX) in routing, they fail to be efficient in
metric-based routing protocols. A metric-based jitter mechanism is proposed in
this paper and a closed form expression is derived that enables us to obtain
the probability of delay inversion for all jitter mechanisms available.
Simulation results are also presented to show the performance of different
jitter mechanisms.","Wireless network is prone to high contention and collision   due to it shared nature. In many cases, for instance when an  event occurs  in some region of wirel ess sensor network, a  large number of nodes embark on generating and sending  packets informing that event simultaneously. This common  behavior  contributes to high collision which degrades the  throughput of the network dramatically. Hence, it could be  reaso nable to prevent nodes from sending their packet  immediately. In many protocols, the idea of waiting for a  small, random amount of time is exploited to alleviate  collision. For many routing protocols such as AODV [6] and  LOADng [7], a random value of delay , called jitter, has been  already recommended in route discovery stage [1].  Simple jitter mechanism in which jitter is selected by a  uniform random variable is analyzed  mathematically in [2]. It  is shown that the standard jitter mechanism is not efficient in  many cases. Therefore, two other mechanisms, called window  and adaptive jitter, have been proposed to solve some  deficiencies of simple jitter mechanism [3]. Window jitter  mechanism has been proposed to reduce the probability of  delay inversion, a pheno menon  in in which RREQ packet in  the longer route (or worse route regarding any metric) reaches  the destination sooner than the better route. In order to  consider link metric or quality in jitter mechanism, adaptive  jitter mechanism has been proposed. In [4,5], a closed form  expression is obtained that gives the probability of delay  inversion for window jitter mechanism. However, there is no  mathematical expression to obtain probability of delay  inversion in adaptive jitter mechanism or any arbitrary jitter   mechanism.   Although jitter mechanisms are proposed to reduce  collision, it can be exploited in routing protocols to find better  routes. Adaptive jitter mechanism uses link metric (such as  ETX [8]) to obtain a random jitter to exploit this feature [3]. Authors in [10] have also extensively studied the impact of  using different random distribution on routing metrics.  However, they did not obtain a closed form expression to  obtain the probability of delay inversion of a whole path.   In this paper, we derive a closed form expression that  enables us to obtain probability of delay inversion of uniform  distribution, using any arbitrary shaping function, as defined  in [10]. We also illustrate results of our simulation of our jitter  mechanism that can dramatically im prove routes found in  route discovery stage.   I. BACKGOUND   A. Ondemand Routing Protocols   Routing protocols which try to find a route towards  destination only when it is required are called on demand  routing protocols. One of the most important phases of these  routing protocols is discovery stage in which the source sends  and floods a route request packet (RREQ) over the network to  find the destination. When the RREQ reaches the destination,  a route is being formed and announced to the source by route  reply packet . Hence, the way these RREP packets are  forwarded has a dramatic influence on the quality of route  formed in this stage. When the route failure occurs, the other  phase, called route maintenance, starts to recover the route or  find a new route.   B. Jittering in  Route Discovery Stage   If all nodes try to send and flood RREP packet  simultaneously, most packets will be dropped due to high  collision. To solve this issue, nodes are recommended to send  the RREQ packet after a random amount of delay in RFC  5148 [1]. This essentially reduces the collision. Additionally,  by imposing different value of delay, a routing protocol can  find more desirable routes. For instance, nodes with low  metric can be forced to send their RREQ with high value of  delay to increase the chanc e of having a route with high  metric. That is the reason why jittering mechanism are so  important.   II. DELAY INVERSION AND JITTERING METHODS   In this section, the delay inversion effect, an undesirable  repercussion of jitter mechanisms, is introduced. Then,  window and adaptive jittering designed for hop based routing  and metric based routing, respectively, are introduced. Finally,  a better adaptive jitter mechanism for tackling the delay  inversion in metric based routing as well as a formula to  obtain probabi lity of delay inversion is provided.      Submit ted to  2016 1st International Conference on New Research Achievements in  Electrical and Computer Engineering       Fig. 1 Two possible routes for different routing mechanism: (a) when routing  metric is hop count, the shortest path, R1, is optimal. (b) When a metric is  assigned for each link, the best route would be the path with highest average  metric, namely R1.   A. The Delay I nversion   In Fig. 1 (a), there are two routes available from the source,  S, to destination, D. Assuming that the hop count is used as a  metric, the shortest (or better) route would be R1. Using  random jitter in route discovery stage, however, a routing  proto col may choose the worse path which is R2. In other  words, the RREQ packet may encounter more delay at the  node A than the nodes W and X together. This undesirable  phenomenon is called delay inversion effect [4].  This undesirable effect can also occur in n etworks where  there is a routing metric rather than hop count (e.g queue  length, node's energy, etc). Assume that the metric shown in  Fig.1 ( b) represents available bandwidth. In this case, the route  R1 obviously has more bandwidth than R2. However, if a  routing protocol uses a simple random jitter without  considering links' metric;  both routes would have the same  chance of getting selected since they have the same length  (hop count). Therefore, it is of paramount importance to use a  jitter mechanism wisely  to be able to choose better routes.   The delay inversion probability can be obtained  mathematically in different cases and scenarios. In the  following sections, we will introduce several jittering  techniques and mathematical formula to obtain their delay  inversion so as to compare them.   B. Hopbased Jitter   To mitigate the problem of collision and simultaneous  transmission, RFC 5148 [1] recommends a jitter based  transmission in which nodes delay each transmission by a  random value from a uniform distribution  𝑈 ~ [0,𝐽max]. 𝐽𝑚 is  the maximum value of delay which is considered constant for  a whole network. Although this mechanism can effectively  reduce number of collisions, it slows the route discovery  process and increases the probability of delay inversion [4].  In hop based routing metric, where the shortest path is  more preferable, a deterministic delay can completely  eliminate the probability of delay inversion. In the  deterministic approach, each node sends packets after  $J_{max}$ milliseconds and, as a resu lt, there is no  randomness. Needless to say, this approach has the slowest  route discovery stage as well as high collision probability [3].  Window jitter mechanism is proposed in [5] which is a  trade off between probability of delay inversion and route discovery time. In the window jitter mechanism, each node  delays its transmissions by a random value from a uniform  distribution 𝑈 ~ [𝛼 𝐽𝑚𝑎𝑥,𝐽𝑚𝑎𝑥] that 𝛼=0 is tantamount to the  method of RFC 5148 and 𝛼=1  is tantamount to the  deterministic approa ch.  C. Metric based Jitter   Although a few jittering methods are proposed for hop  based routing protocols, in which the shortest path is more  preferable, jitter mechanisms for metric based routing  protocols need further scrutiny. Given a li nk metric 𝑀 ∈  (0,1) (m=1 indicates high quality links), authors in [5]   proposed adaptive jitter mechanism which selects jitter values  uniformly within [(1−𝑚)𝐽𝑚𝑎𝑥,𝐽𝑚𝑎𝑥]ough the average delay  imposed on better links would be lower, the probability of  delay inversion is not  insignificant owing to the fix upper  bound.   To reduce the probability of delay inversion as well as  route discovery time of better routes [10], delay values can be  obtained from a random variable 𝑈𝐶 ~ [(1−𝑚)𝐽𝑚𝑎𝑥,(1− 𝑚)𝐽𝑚𝑎𝑥 +𝐶], where C indicates the  range of 𝑈𝑐, a trade off  between number of collisions and discovery time. The smaller  the value of C is, the higher the number of collisions would  be. The bigger the value of C is, the longer the process of  route discovery would be. Since the distributi on of high  quality and low quality links has  less overlap in general, the  probability of delay inversion is lower than the adaptive jitter  mechanism in [5].  D. Analysis   Let Ω1,Ω2,…,Ω𝑛 be independent uniform random  variables on (𝑎𝑖,𝑏𝑖) and also 𝑏𝑖>𝑎𝑖. Moreover, let 𝑙𝑖=𝑏𝑖− 𝑎𝑖, 𝐴𝑛= ∑ 𝑎𝑖𝑛 𝑖=1 and 𝐵𝑛= ∑ 𝑏𝑖𝑛 𝑖=1. Now, S, a set containing  all possible sum o f i arbitrary elements of {𝑙1,𝑙2,…,𝑙𝑛}, is  defined as follows [9]  𝑺 =  { 𝝎𝟏𝒍𝟏+ 𝝎𝟐𝒍𝟐+⋯+ 𝝎𝒏𝒍𝒏   |    𝝎𝒊∈{𝟎,𝟏},𝒊 = 𝟏,𝟐,…𝒏 }   (1)  Having been sorted in ascending order , 𝑆= { 𝑠1,𝑠2,...,𝑠2𝑛 } is used to define the function, 𝑟𝑛(𝑥), as  follows   𝑟𝑛(𝑥)= 𝑚𝑎𝑥 { 𝑗  |  𝑥−𝐴𝑛−𝑠𝑗>0  𝑎𝑛𝑑   𝑠𝑗∈𝑆  𝑓𝑜𝑟  𝑗= 1,...,2𝑛 }            (2)   In other words, 𝑟𝑛(𝑥) indicates the maximum o f index j in  which 𝐴𝑛+𝑠𝑗< x. Assuming 𝑊𝑛 is a subspace of a n  dimen sional Euclidean vector space {0,1}𝑛, for each j (𝑗= 1,2,...,2𝑛), there exist s a vector 𝑤𝑛𝑗=(Ω1,Ω2,…,Ω𝑛) such  that    𝑠𝑗= Ω1𝑙1+Ω2𝑙2+ ...+ Ω𝑛𝑙𝑛        (3)  Then, density function of sum of n independent random  variable, uniformly distributed on  (𝑎𝑖,𝑏𝑖), is [9]  ℎ𝑛(𝑥)= ∑ (−1)‖𝑤𝑛𝑗‖ 𝑟𝑛 (𝑥) 𝑗=1 (𝑥−𝐴𝑛−𝑠𝑗)𝑛−1 𝐼(𝐴𝑛,𝐵𝑛)(𝑥) (𝑛−1)!∏ (𝑏𝑖−𝑎𝑖)𝑛 𝑖=1   (4)    Submit ted to  2016 1st International Conference on New Research Achievements in  Electrical and Computer Engineering     where ||.|| is the norm of the vector and 𝐼(𝐴𝑛,𝐵𝑛)(𝑥) is the  indicator function. Hence, the distribution function can be  obtained as follows   𝐻𝑛(𝑥)= ∑ (−1)‖𝑤𝑛𝑗‖ 𝑟𝑛 (𝑥) 𝑗=1 (𝑥−𝐴𝑛−𝑠𝑗)𝑛 𝐼(𝐴𝑛,𝐵𝑛)(𝑥) (𝑛)!∏ (𝑏𝑖−𝑎𝑖)𝑛 𝑖=1+𝐼(𝐵𝑛,∞)(𝑥)  (5)  The following theorem can be used to obtain the  probability of delay inversion of any jitter mechanism which  uses uniform distribution.   Theorem 1:  Let 𝑅1 and 𝑅2 be two routes and 𝑅1 be better   than 𝑅2 regarding an arbitrary routing metric. Using uniform  distribution in jitter mechanism, the probability of delay  inversion  is  P(R1>R2)=ξnξ̅ m∑∑(−1)‖𝑤𝑛𝑗‖+‖𝑤̅𝑚𝑘‖2m k=12n j=1                ×[𝐹12(𝑚+1,1−𝑛;𝑚+2;𝑥−𝐴̅𝑚−𝑠̅𝑘 𝐴𝑛+𝑠𝑗−𝐴̅𝑚−𝑠̅𝑘)  ×(𝐴̅𝑚+𝑠̅𝑘−𝐴𝑛−𝑠𝑗)𝑛−1 (𝑚+1)×(𝑥−𝐴̅𝑚−𝑠̅𝑘)−(𝑚+1)] max (𝐴𝑛+𝑠𝑗, 𝐴̅𝑚+𝑠̅𝑘)min (𝐵𝑛,𝐵̅𝑚) + (𝐻𝑛(𝐵𝑛)−𝐻𝑛(𝐵̅𝑚))𝐼(0,∞)(𝐵𝑛−𝐵̅𝑚)  (6)  where  𝐹12is hypergeometric function. A macron is used to  explicitly indicate variables related to the second route, 𝑅2. ξn  and ξ̅m are defined  as follows     ξn ≜ 1 (𝑛−1)!∏ (𝑏𝑖−𝑎𝑖)𝑛 𝑖=1              (7)    ξ̅ m ≜ 1 (𝑚)!∏ (𝑏̅𝑖−𝑎̅𝑖)𝑚 𝑖=1            (8)  Proof: Delay inversion occurs whenever the sum of n  uniform random variables of the first route is greater than the  sum of m uniform random variables of the second route, that  is  𝑃(𝑅1>𝑅2)= ∫∫ℎ𝑛(𝑥)ℎ̅𝑚(𝑦)𝑑𝑦 𝑑𝑥𝑥 0∞ 0 = ∫ℎ𝑛(𝑥)𝐻̅𝑚(𝑥)𝑑𝑥∞ 0   (9)  Since the maximum value of 𝑟𝑛(𝑥) is 2𝑛, (4) can be  written as follows   ℎ𝑛(𝑥)=ξn ∑ (−1)‖𝑤𝑛𝑗‖2𝑛 𝑗=1 (𝑥−𝐴𝑛 −𝑠𝑗)𝑛−1 𝐼(𝐴𝑛,𝐵𝑛)(𝑥)𝐼(0,𝑟𝑛(𝑥))(𝑗)  (10)   Fig. 2 Probability of delay inversion when two paths have the same length   Hence,   𝑃(𝑅1>𝑅2) =ξnξ̅m∫ ∑∑(−1)‖𝑤𝑛𝑗‖+‖𝑤̅𝑚𝑘‖2m k=12n j=1(𝑥−𝐴𝑛−𝑠𝑗)𝑛−1 (𝑥−𝐴̅𝑚−𝑠̅𝑘)−m𝐵̅𝑚 0  ×𝐼(𝐴𝑛,𝐵𝑛)(𝑥)𝐼(0,𝑟𝑛(𝑥))(𝑗)𝐼(𝐴̅𝑚,𝐵̅𝑚)(𝑥)𝐼(0,𝑟̅𝑚(𝑥))(𝑘)𝑑𝑥 + ξn∫∑ (−1)‖𝑤𝑛𝑗‖2𝑛 𝑗=1 (𝑥−𝐴𝑛∞ 0 −𝑠𝑗)𝑛−1  𝐼(𝐴𝑛,𝐵𝑛)(𝑥)𝐼(𝐵̅𝑚,∞)(𝑥)𝐼(0,𝑟𝑛(𝑥))(𝑗)𝑑𝑥      (11)  Therefore,   𝑃(𝑅1>𝑅2) =ξnξ̅m∑∑(−1)‖𝑤𝑛𝑗‖+‖𝑤̅𝑚𝑘‖ 2m k=12n j=1 ∫(𝑥−𝐴𝑛−𝑠𝑗)𝑛−1 (𝑥−𝐴̅𝑚−𝑠̅𝑘)−mmin  (𝐵𝑛,𝐵̅𝑚) max  (𝐴𝑛,𝐴̅𝑚) ×𝐼(0,𝑟𝑛(𝑥))(𝑗)𝐼(0,𝑟̅𝑚(𝑥))(𝑘)𝑑𝑥+𝐼(0,∞)(𝐵𝑛−𝐵̅𝑚) ×∫ ξn𝐵𝑛 𝐵̅𝑚∑ (−1)‖𝑤𝑛𝑗‖2𝑛 𝑗=1 (𝑥−𝐴𝑛−𝑠𝑗)𝑛−1𝐼(0,𝑟𝑛(𝑥))(𝑗)𝑑𝑥   (12)  For each term in the summations, j and k are constant. So ,  in order for terms conta ining  𝐼(0,𝑟𝑛(𝑥))(𝑗) to be non zero, the  value of 𝑟𝑛(𝑥) must  be greater than j . Therefore, the smallest  value of x that sa tisfies the condition would be 𝑟𝑛−1(𝑗)=𝐴𝑛+ 𝑠𝑗 and consequently 𝑃(𝑅1>𝑅2) can be rewriten as follows   𝑃(𝑅1>𝑅2)=ξnξ̅m∑∑(−1)‖𝑤𝑛𝑗‖+‖𝑤̅𝑚𝑘‖2m k=12n j=1 ×∫(𝑥−𝐴𝑛−𝑠𝑗)𝑛−1 (𝑥−𝐴̅𝑚−𝑠̅𝑘)−mmin (𝐵𝑛,𝐵̅𝑚) max (𝐴𝑛+𝑠𝑗, 𝐴̅𝑚+𝑠̅𝑘)𝑑𝑥 +(𝐻𝑛(𝐵𝑛)−𝐻𝑛(𝐵̅𝑚))𝐼(0,∞)(𝐵𝑛−𝐵̅𝑚)  (13)      Submit ted to  2016 1st International Conference on New Research Achievements in  Electrical and Computer Engineering       Fig. 3 Average metric of all routes     The proof follows immediately by integrating the lat  equation.   □  Using theorem 1, we computed average probability of  delay inversion when the two paths have the same length, in  this case 6 hops, using Maple software. We ass umed link  metrics are in range (0,1] and route metric is the average  metric  of its links. We als o assumed 𝐽𝑚𝑎𝑥 100ms and C  is  30ms. Therefore, the RFC 5148 [1] obtained delay values  from 𝑈 ~ [0,100 ], adaptive jitter method from 𝑈 ~ [(1− 𝑚)100 ,100 ], and our method from 𝑈 ~ [(1−𝑚)100 ,(1− 𝑚)100 +30]. The average probability of delay inversion was  obtained by putting over thousand different possible values in  equation (6)  As it is shown in Fig  2, hopbased jitter mechanism which  ignores link metrics leads to a constant value of 0.5, despite  the difference in quality of routes. Our method signifi cantly  reduces the probability of delay inversion, even when the two  routes' metric are relatively close.   III. SIMULATIONS   In this section, we present results of a set of simulations  conducted by ns 2 to comprehensively show the effect of jitter  mechanism on ro uting. In our simulation, 100 nodes were  randomly depl oyed in a square region of 1000× 1000 meters.  Transmission range was 250m and 𝐽𝑚 was 250ms. Link  metrics were selected within $[0.5,1]$ and C was 40ms. The  simulations lasted for 100 seconds and 10 random nodes  initiated route discovery every 2 seconds. We compared three  different mechanisms, th at is RFC 5148 ( 𝑈 ~ [0,250 ]),  adaptive jitter ( 𝑈 ~ [(1−𝑚)250 ,250 ]) and our method  (𝑈 ~ [(1−𝑚)250 ,(1−𝑚)250 +40]).  Fig. 3 demonstrates the effect of increasing number of  nodes on route metric. As it is expected,    Fig. 4 Average route discovery time   our method finds be tter routes. Additionally, since more nodes  mean more possible routes from a source to a destination,  routes' metrics increase as number of nodes increases, if the  mechanism exploits  the opportunity. A mechanism that has the  least value of probability of d elay inversion is more likely to  find optimal routes. That is the reason our method outperforms  other methods.   Range and lower bounds of a uniform random variable  used to obtain delay in route discovery process can  dramatically impact route discovery time . RFC 5 148 always  uses a fixed range ( 𝑈 ~ [0,250 ]). Adaptive jitter method  imposes more average delay than RFC 5148 on low quality  links. Moreover, since average forwarding delay of high  quality links in adaptive jitter method is as long as that of FRC  5148 method, in general, route discovery process takes longer  "
444,A Deep Reinforcement Learning Approach for Global Routing.txt,"Global routing has been a historically challenging problem in electronic
circuit design, where the challenge is to connect a large and arbitrary number
of circuit components with wires without violating the design rules for the
printed circuit boards or integrated circuits. Similar routing problems also
exist in the design of complex hydraulic systems, pipe systems and logistic
networks. Existing solutions typically consist of greedy algorithms and
hard-coded heuristics. As such, existing approaches suffer from a lack of model
flexibility and non-optimum solutions. As an alternative approach, this work
presents a deep reinforcement learning method for solving the global routing
problem in a simulated environment. At the heart of the proposed method is deep
reinforcement learning that enables an agent to produce an optimal policy for
routing based on the variety of problems it is presented with leveraging the
conjoint optimization mechanism of deep reinforcement learning. Conjoint
optimization mechanism is explained and demonstrated in details; the best
network structure and the parameters of the learned model are explored. Based
on the fine-tuned model, routing solutions and rewards are presented and
analyzed. The results indicate that the approach can outperform the benchmark
method of a sequential A* method, suggesting a promising potential for deep
reinforcement learning for global routing and other routing or path planning
problems in general. Another major contribution of this work is the development
of a global routing problem sets generator with the ability to generate
parameterized global routing problem sets with different size and constraints,
enabling evaluation of different routing algorithms and the generation of
training datasets for future data-driven routing approaches.","Keeping pace with Moore’s Law, Integrated Circuits (IC) are becoming increasingly more sophisticated with the number of transistors in a unit area increasing exponentially over time [1, 2]. More capable automatic design systems are needed to help engineers tasked with solving increasingly Address all correspondence to this author.more challenging IC design problems. In the design ﬂow of IC, global routing is a particularly critical and challeng ing stage in which the resources for routing (hence design constraints) in the chip design is allocated based on the pre ceding step of component placement and conﬁgurations of the chip to be designed [3]. The routing problem is then ad dressed in two stages, the ﬁrst being the global routing step (the focus of this work), followed by detailed routing where the actual path of the wires and vias connecting those elec tronic components are decided. Global routing has been a historically challenging prob lem in IC physical design for decades. Global routing in volves a large and arbitrary number of nets to be routed, where each net may consist of many pins to be intercon nected with wires. Even the simplest version of the problem, where a single net with only two pins needs to be routed un der the design constraints is an NPcomplete problem [4]. In real settings, millions of components and nets may need to be integrated on a single chip, making the problem ex tremely challenging. Similar routing problems are encoun tered in other domains including routingdesign of hydraulic systems [5], complex pipe system routing in ships [6], urban water distribution systems [7, 8], and routing of city logistic services [9, 10]. Owing to the difﬁculties of the problem and demand for tools for designing increasingly complicated IC, global rout ing has been one of the most active research areas in IC de sign [3,11,12,13]. However, current solutions rely primarily on heuristically driven greedy methods such as net ordering followed by sequential net routing [3], routing different ar eas of chip sequentially [14], and net ordering followed by forcedirected routing [15]. These heuristic based methods are primarily applicable with strong constraints on the prob lems to be solved. As such, there remains potential to iden tify better solutions that can further minimize the objective functions of interest such as the total wirelength and edge overﬂow commonly utilized in IC design. This work presents a deep reinforcement learning (DRL) driven approach to global routing. DRL combines reinforce ment learning and deep learning, and has been successfully 1 Copyright c by ASMEarXiv:1906.08809v1  [cs.LG]  20 Jun 2019utilized in a variety of sequential decision making problems [16, 17, 18, 19, 20, 21, 16]. In our setting, both the state space (routing states) and the action space (routing decisions) are discrete and ﬁnite. Moreover, since a future routing state only depends on the current routing state and all states fea tures are observable, we model the problem as a Markov De cision Process [22]. We choose a Deep Qnetwork (DQN) as our fundamental RL algorithm to address the global routing problem. At the heart of our approach is the observation that a properly trained Qnetwork within our DQN formulation can consider the nets and the pins to be routed conjointly, as op posed to attempting to route them sequentially with little or no backtracking. A single Qnetwork is trained and learned on the target problem of interest. When trained, it produces a ‘best’ action for the dynamically evolving state of the routing by taking into account all the previous successful as well as unsuccessful net routing attempts that inform a reward func tion. To the best of our knowledge, the presented work is the ﬁrst attempt to formulate and solve global routing as a deep reinforcement learning problem. A global routing prob lem sets generator is also developed to automatically gener ate parameterized problems with different scales and con straints, enabling comparisons between algorithms and pro viding training, testing and validation data for future data driven approaches. We describe our DQN formulation to gether with the parametric studies of the best parameters of the algorithm and network structure. We compare our ap proach against solutions obtained by the commonly used A* search, which is sequentially applied to solve a set of nets. It is noted however that our approach, similar to previous ap proaches, does not guarantee global optimum. 2 BACKGROUND and RELATED WORK 2.1 Global Routing Global routing allocates space resources on the chip to be designed by connecting the electronic components in a circuit coarsely based on a given placement solution [23]. It can be modeled as a grid graph G(V;E), where each vertex vi represents a rectangular region of the chip, socalled a global routing cell (Gcell) or a global routing tile, and each edge ei j represents the boundary between viandvj. In a given rout ing problem, IC design considerations impose constraints on the edges between neighboring global routing tiles. For this, each edge ei jis assigned a capacity ci j2Z+that indicates the maximum number of wire crossings that are permitted without penalty across that edge. In the ﬁnal routing solu tion, if the number of wire crossings across ei jexceeds ci j, this excess is represented as the overﬂow of the edge o fi j and the realtime capacity of ei jbecomes"
441,Robust Energy Management for Green and Survivable IP Networks.txt,"Despite the growing necessity to make Internet greener, it is worth pointing
out that energy-aware strategies to minimize network energy consumption must
not undermine the normal network operation. In particular, two very important
issues that may limit the application of green networking techniques concern,
respectively, network survivability, i.e. the network capability to react to
device failures, and robustness to traffic variations. We propose novel
modelling techniques to minimize the daily energy consumption of IP networks,
while explicitly guaranteeing, in addition to typical QoS requirements, both
network survivability and robustness to traffic variations. The impact of such
limitations on final network consumption is exhaustively investigated. Daily
traffic variations are modelled by dividing a single day into multiple time
intervals (multi-period problem), and network consumption is reduced by putting
to sleep idle line cards and chassis. To preserve network resiliency we
consider two different protection schemes, i.e. dedicated and shared
protection, according to which a backup path is assigned to each demand and a
certain amount of spare capacity has to be available on each link. Robustness
to traffic variations is provided by means of a specific modelling framework
that allows to tune the conservatism degree of the solutions and to take into
account load variations of different magnitude. Furthermore, we impose some
inter-period constraints necessary to guarantee network stability and preserve
the device lifetime. Both exact and heuristic methods are proposed.
Experimentations carried out with realistic networks operated with flow-based
routing protocols (i.e. MPLS) show that significant savings, up to 30%, can be
achieved also when both survivability and robustness are fully guaranteed.","Both network operators and device manufacturers agree that the energy consumption of communications networks cannot be neglected anymore [5]. According to recent es timates [1], the worldwide electricity consumption of tele com operators has grown from 150 Twh/y in 2007 to 260 TWh/y in 2012, which accounts for almost 3% of the total worldwide consumption. This growing consumption has stimulated the develop ment of new strategies to increase the energy eﬃciency of communicationsnetworks,with particularfocuson IPnet works [6, 7, 8]. In this context, remarkable improvements can be obtained with energyaware strategies for network ∗Corresponding author Email addresses: bernardetta.addis@loria.fr (B. Addis), capone@elet.polimi.it (A. Capone ), giuliana.carello@polimi.it (G. Carello), gianoli@elet.polimi.it (L.G. Gianoli), brunilde.sanso@polymtl.ca (B. Sans` o)management and traﬃc engineering that dynamically op timize the network conﬁguration by putting in sleep mode some of the network components (line cards and nodes) and using the remaining active part to serve the actual traﬃc [9, 10, 11, 12, 7, 13]. Basically, the aim of energyawaremanagement is to ad just both the network topology and the available capacity to varying traﬃc levels in order to keep active only the resources that are essential for the actual load. It is ba sically a dynamic redesign of the network that takes as input the predicted or measured traﬃc pattern. Manage ment approaches diﬀer depending on the strategy to select the sleeping/active parts, on how optimizing the network routing through the active network, and on how closely traﬃc variations can be followed by network reconﬁgura tion. It is quite evident that the best energy performance can be obtained tailoring perfectly the network capacity to the traﬃc level. But on the other side there are several impor tant functions that depend on the spare capacity available in the network in case actual working conditions are dif Preprint submitted to Elsevier August 26, 2018ferent from expected. Protection techniques are widely used to guarantee the network capability of being resilient to failures of links (or device interface serving a link) and nodes. In case of failure occurrence, the aﬀected traﬃc is rerouted on the surviving part of the network. To verify the possibility of accommodatingthis traﬃc on alternative paths to destination it is obviously necessary to have some spare capacity left there to cope with these anomalous sit uations. Also traﬃc can be diﬀerent from what expected becauseoftheuncertaintyintrinsicintraﬃcestimationsor possible rapid deviations that cannot be followed by mon itoring and measurement techniques. Networks should be designed to be robust to these variations, and also in this case the price to pay is some spare capacity in the network to be used for compensatingtraﬃc ﬂuctuationsaroundthe nominal value. For these reasons, thereis clearlya trade oﬀbetween en ergyconsumptionandthelevelofresilienceandrobustness of the network. However, how protection techniques and robustness strategies are integrated in the energyaware network management methodologies is fundamental to de termine their energy cost. Moreover, if technologies are available for rapidly reactivating sleeping elements when needed, more energyeﬃcient approaches can be deﬁned by integrating procedures to recover from failures within the network energy management framework. The fundamental questionthat wetacklein this paperis whether it is possible to design a network with embedded reliability, survivability and robustness and still aiming at energy reduction. We also want to investigate what is the energy cost of protection and robustness considering dif ferent available techniques. To this aim, we introduce a novel framework for survivable and robust energyaware network management that builds on our recent work on multiperiod energyawarenetworkmanagementin IPnet works[14]1. Thecentralideaistointroducededicatedand shared protection into the energyaware IP network man agement models and add as well the notion of network robustness to traﬃc variations [18]. This paper is organized as follows. In Section 2 we re view stateoftheart literature on energyaware network management and point out the novelties of our work. In Section 3 we discuss the most relevant aspects of the pro posed energyaware framework, while in Sections 4, 5 and 6 we present some MILP formulations to take into ac count both survivability and robustness issues. The reso lution methods and computational results are extensively discussed in Section 7 and 8, respectively. Finally, some concluding remarks are reported in Section 9. 2. Related work "
472,Greedy Routing and the Algorithmic Small-World Phenomenom.txt,"The algorithmic small-world phenomenon, empirically established by Milgram's
letter forwarding experiments from the 60s, was theoretically explained by
Kleinberg in 2000. However, from today's perspective his model has several
severe shortcomings that limit the applicability to real-world networks. In
order to give a more convincing explanation of the algorithmic small-world
phenomenon, we study decentralized greedy routing in a more flexible random
graph model (geometric inhomogeneous random graphs) which overcomes all
previous shortcomings. Apart from exhibiting good properties in theory, it has
also been extensively experimentally validated that this model reasonably
captures real-world networks.
  In this model, the greedy routing protocol is purely distributed as each
vertex only needs to know information about its direct neighbors. We prove that
it succeeds with constant probability, and in case of success almost surely
finds an almost shortest path of length {\theta}(loglog n), where our bound is
tight including the leading constant. Moreover, we study natural local patching
methods which augment greedy routing by backtracking and which do not require
any global knowledge. We show that such methods can ensure success probability
1 in an asymptotically tight number of steps.
  These results also address the question of Krioukov et al. whether there are
efficient local routing protocols for the internet graph. There were promising
experimental studies, but the question remained unsolved theoretically. Our
results give for the first time a rigorous and analytical affirmative answer.",1.1 Related Work and Choice of Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 
405,Performance Comparison of the RPL and LOADng Routing Protocols in a Home Automation Scenario.txt,"RPL, the routing protocol proposed by IETF for IPv6/6LoWPAN Low Power and
Lossy Networks has significant complexity. Another protocol called LOADng, a
lightweight variant of AODV, emerges as an alternative solution. In this paper,
we compare the performance of the two protocols in a Home Automation scenario
with heterogenous traffic patterns including a mix of multipoint-to-point and
point-to-multipoint routes in realistic dense non-uniform network topologies.
We use Contiki OS and Cooja simulator to evaluate the behavior of the
ContikiRPL implementation and a basic non-optimized implementation of LOADng.
Unlike previous studies, our results show that RPL provides shorter delays,
less control overhead, and requires less memory than LOADng. Nevertheless,
enhancing LOADng with more efficient flooding and a better route storage
algorithm may improve its performance.","IETF standardization efforts for sensor networks have en abled their full interoperability and have made the envisioned “Internet of Things” (IoT) a reality. 6LoWPAN, the IPv6 over Low power Wireless Personal Area Networks protocol [1] is the adaptation layer that allowed tiny devices to become reachable on the global IP network. In parallel, the IETF ROLL working group speciﬁed RPL, a Routing Protocol for Low Power and Lossy Networks (LLNs) [2]. Many argued that even if RPL met the initial goal of providing the industry actors with a fullyﬂedged routing protocol, its signiﬁcant complexity poses a threat for implementation interoperability of constrained devices. Another routing proposal is LOADng (The Lightweight Ondemand Ad hoc Distancevector routing protocol  Next Generation) [3], a lightweight variant of AODV [4]. The aim of this paper is to analyze the performance characteristics and issues of the two routing protocols for a speciﬁc scenario of Home Automation networks. Routing in LLNs is one of the key challenges for the IoT emergence. The constraints of LLNs have a signiﬁcant impact on the protocol design. Small memory limits the number of stored route entries. Limited energy supply dictates minimal radio usage and optimized control overhead. The increasing scale of IoT networks calls for scalable solutions. Finally, Home Automation interactive applications may require low latency communications. Much research work focused on the performance of RPL [5], [6], [7], [8] leading to the common observation that RPL performs well in case of multipointtopoint trafﬁc, but induces a large overhead in scenarios where pointto multipoint trafﬁc is nonnegligible. We show how the ContikiRPL implementation behaves in a realistic Home Automation scenario. LOADng is a more recent protocol compared to RPL and less studied. Our paper compares both protocols and gives new insights into their performance, existing issues, and draws possible research directions. We have used the framework for low power IPv6 routing simulation, experimentation, and evaluation based on Con tiki OS and its Cooja simulator/emulator [9]. Cooja uses a hardware emulator to run the code, so the simulation results perfectly reﬂect the behavior of the underlying protocols. The only part of the simulation that approximates realworld con ditions is the radio propagation model with the assumption of the Unit Disk Graph. We strictly follow the Home Automation scenario [10] by mimicking the logical roles of nodes and appropriate trafﬁc patterns, as well as by generating realistic topologies on a virtual home plan. The paper is organized as follows. Sections II and III give an overview of RPL and LOADng, respectively. Sections IV and V discuss the simulation scenario and the performance results. Section VI presents the related work. Finally, we provide some concluding remarks, observations, and perspectives in Section VII. II. RPL—R OUTING PROTOCOL FOR LOWPOWER AND LOSSY NETWORKS RPL is a Distance Vector protocol that speciﬁes how to construct a Destination Oriented Directed Acyclic Graph (DODAG) with a deﬁned objective function and a set of metrics and constraints. RPL uses a proactive approach: it ﬁnds and maintains routes without any trafﬁc considerations— routes are created even if not used. RPL speciﬁes a set of new ICMPv6 control messages to exchange information related to a DODAG: DODAG Information Solicitation (DIS) messages pro actively solicit the DODAG related information from neighboring nodes. DODAG Information Object (DIO) deﬁnes and maintains upward routes. DODAG Destination Advertisement Object (DAO) ad vertizes preﬁx reachability towards the leaf nodes of a DODAG enabling downward trafﬁc. A root starts the DODAG building process by transmitting a DIO. Neighboring nodes process DIOs and make a decision on joining the DODAG based on the objective function and/or local policy. A node computes its Rank with respect to the rootarXiv:1401.0997v1  [cs.NI]  6 Jan 2014and starts advertising DIO messages to its neighbors with the updated information. As the process converges, each node in the network receives one or more DIO messages and has a preferred parent towards the sink. Hence, RPL optimizes the upward routes for multipointtopoint trafﬁc that accounts for most of the trafﬁc in LLNs. To support downward routes, RPL uses DAO control mes sages that give the preﬁx information, the route lifetime, and other information about the distance of the preﬁx. RPL RFC [2] deﬁnes the storing and nonstoring modes. In the non storing mode, packets use sourcerouting for downward trafﬁc. In our study, we focus on the storing mode in which each node keeps track of all accessible downlink preﬁxes. The Trickle algorithm [11] governs the emission interval of DIOs. The idea is to reduce the control overhead of the protocol by sending DIOs less frequently when there is no change in the topology. In case of a change in the network, trickle forces more frequent emissions of DIOs. The RPL RFC [2] does not specify the mechanisms for the DAO emission (it is left to implementation). ContikiRPL emits DAOs with a similar approach to the trickle algorithm based on the DIO transmission timers. III. LOAD NG The LOADng protocol [3] uses a reactive approach based on the idea that LLNs are idle most of the time so a proactive ap proach would generate unnecessary overhead. Thus, LOADng establishes a route towards a given destination only on demand when there is some data to send. As IETF did a lot of work on designing AODV , a reactive protocol for MANETs [4], a logical consequence was to adapt it for LLNs to make it implementable on memory constrained devices. When a device has a packet to send towards a given destination, it consults a routing table and invokes LOADng in case of an invalid entry. The protocol ﬂoods a RouteRequest (RREQ) message through the network to reach all nodes. A node receiving a RREQ checks if it is the message destination. If not, it forwards RREQ to its neighbors. The node also learns the reverse path towards the originator of the RREQ message and adds it to the routing table. Eventually, the destination node receives RREQ and responds by unicasting a Route Reply (RREP) message towards the request originator. RREP follows the stored reverse route. At the same time, intermediate nodes learn the forward route towards the destination. When RREP reaches the request originator, the bidirectional route is installed at intermediate nodes. One of the main drawbacks of LOADng is the route dis covery delay. During the discovery process, outgoing packets are buffered, which may cause losses in memory constrained devices. Moreover, ﬂooding is highly energy inefﬁcient so nodes may suffer from energy depletion. Another issue is related to the collisions of control messages due to ﬂooding, which may lead to unnecessary retransmissions. We have used a LOADng implementation developed in our lab based on the AODV implementation in Contiki.IV. S IMULATION SCENARIO Home automation is one of the key applications of the envisioned “Internet of Things”. Nodes in such networks are typical highly constrained devices. Good examples are light dimmers, window shades, motion sensors, typical monitoring sensors, remote control units. When it comes to the network architecture, two approaches are generally used [10]: Centralized architecture: each networked device commu nicates with a central node that controls the network. Distributed architecture: different devices within the net work may cooperate to locally control the network. Fig. 1. An example 25 node topology generated in a virtual house. The majority of existing deployments uses the centralized approach, but the distributed approach is also gaining popular ity, mainly because of better latency. However, in a futuristic scenario, “smart homes” are expected to be a part of a “smart grid” and a “smart city” with dynamical adjustments of their energy consumption and production. Thus, the central unit playing the role of a coordinator among home devices and the external ones, has to exist. For this reason, we have decided to use the centralized architecture for our study. A. Topology A very common simpliﬁcation in the literature is the as sumption of a gridlike network topology. Its main conse quence is a nearuniform distribution of the number of node neighbors (node degree) that does not reﬂect common “smart home” deployment scenarios. Furthermore, the simpliﬁcation strongly impacts the performance of routing protocols. To obtain realistic results, we have designed a virtual 130m2 home map and developed a realistic topology generator. The home map is the background for generating topologies of different sizes. Nowadays, networks of around 20 nodes are quite common. However, this number is expected to grow and may exceed 250 in the near future [10]. Due to the ﬁxed size area, topologies with a larger number of devices in a network become more dense and consequently, the number of neighbors increases. We have generated topologies under the assumption of having 80 % of devices uniformly placed on the walls of a room, while the remaining 20 % are uniformly distributed around. The number of devices in each room is proportional to its area. The controlling unit (sink) is placed in the livingroom. 70 % of the devices have the logical role of sensors, while the remaining 30 % are assigned the role of actuators. 70 % of all sensors perform monitoring while the other 30 % generate events (switches, motion detectors). Fig. 1 shows an example network topology with 25 nodes in the virtual house. The average number of neighbors for the generated topologies ranged from 4.13 for a 15 node topology, 6.24 for a 25 node network, up to 12.2 for the largest simulated network composed of 40 nodes. B. Trafﬁc Pattern The trafﬁc pattern of each node in the network depends on its assigned logical role. We have deﬁned four logical types summarized in Table I. It is important to note that we have chosen the reporting periods and the general trafﬁc patterns as suggested by IETF [10]. Nodes use UDP as the trans port layer protocol and the application process acknowledges each received message. Therefore, trafﬁc in the network is evenly distributed between pointtomultipoint and multipoint topoint. TABLE I TRAFFIC PATTERN OF DIFFERENT NODE TYPES IN THE NETWORK . Node Type Trafﬁc Pattern Monitoring Sensor Periodic reporting in [8, 12] minute interval Event Sensor Poisson process with a mean of 10 packets per hour for the whole house Actuator Periodic reporting in [8, 12] minute interval and sending acknowledgment frames Main Controller Unit Acknowledgment of received frames; sending a 5 packet burst to different actuators as a Poisson process with a mean of 10 bursts per hour and upon reception of a frame from an Event Sensor C. Simulation Parameters To closely reﬂect real deployments, nodes run Contiki OS with the whole protocol stack. We have compiled Contiki for the Tmote Sky platform based on MSP430 microcontroller with 10 KB of RAM and an IEEE 802.15.4 compliant radio [12]. By using the MSP430 hardware emulator, Cooja thus takes into account all the hardware constraints of the devices under study. Table II summarizes the Contiki OS and Cooja setups. TABLE II CONTIKI OS AND COOJA PARAMETER SETUP . Settings Value Wireless channel model UDG Model with Distance Loss Communication range 5 m Mote type Tmote Sky Transport and network layers UDP + IPv6 + 6LoWPAN Max number of queued packets 2 MAC layer nonslotted CSMA + ContikiMAC Radio interface CC2420 2.4 GHz (IEEE 802.15.4) Simulation time 8h Notice a fairly low communication range at the PHY layer. Indeed, we have chosen this setup to reﬂect the assumption that nodes will operate with a very low power, i.e. with a low power ampliﬁer gain mainly to reduce interference. Furthermore, radiopropagation obstacles present in a typical home environment, coupled with 2.4 GHz frequency, limit the communication range. With our parameters, the wholehouse is covered within four hops as suggested before [10]. We have modiﬁed Contiki CSMA to buffer multicast packets and retransmit them when the channel was found busy at the initial attempt. Without this modiﬁcation, the performance of LOADng was highly degraded due to a large number of dropped RREQ messages. Another realistic assumption taken into account in our simulation was the use of ContikiMAC, a Radio Duty Cycling (RDC) protocol [13] based on preamble sampling and possibly sleeping receivers. Note that ContikiMAC operates on top of the IEEE 802.15.4 nonslotted CSMA and it may lead to some lost frames, which alleviates the assumption of the Unit Disk Graph that does not introduce any losses for nodes in the radio range. TABLE III PROTOCOL PARAMETERS . (a) RPL DIO Min Interval (s) 4 DIO Max Interval (s) 1048 Mode of Operation Storing(b) LOADng Net Traversal Time (s) 10 Route Hold Time (s) 600, 1800, RHT 3600 Table III summarizes RPL and LOADng protocol param eters. Notice that we vary the Route Hold Time (RHT) of LOADng to study the protocol performance as a function of the route lifetime. RPL uses the Trickle algorithm [11] to emit DIO messages with default parameters and we have set the DIO Max Interval used in the steady state to approximately 17 minutes (1048 s). Tuning of RHT and the DIO Max Interval is an engineering challenge that should take into account the dynamic behavior of a given network, loss rate, and the probability of a node failure. Our choices for the LOADng parameters cover a broad range of cases. We can still decrease the overhead of RPL by increasing the DIO Max Interval. We average the simulation results over 5 simulation runs and show 95 % conﬁdence intervals. We plot CDF graphs using the cumulative results of 5 simulation runs. V. P ERFORMANCE EVALUATION We ﬁrst focus on a 25 node network (cf. Fig. 1) and evaluate LOADng and RPL in terms of packet delays, hop counts, and the routing table size. Furthermore, we study the control plane overhead and the average routing table size as a function of the number of nodes to show how the protocols scale for larger networks. A. Packet Delay The latency studied in this section represents the total delay that a packet experiences from the instant it is passed to the UDP layer until it is successfully received at the destination. Fig. 2 presents the Cumulative Distribution Function (CDF) of packet delays for different hop counts. LOADng performs worse and packets experience signiﬁcantly higher delays. Even though some LLNs can be delay insensitive, the interactive nature of home automation applications requires a routing protocol with delays of less than 0.5 seconds [10]. Due to the route discovery procedure of LOADng, the delay CDF con verges slowly and 56.8 % of packets are within 0.5 seconds incase of a 10 minute RHT. Flooding is less frequent when RHT increases to one hour and the delay becomes smaller. However, the delay CDF still converges slowly and approximately 26 % of packets experience a delay greater than 0.5 seconds (cf. Fig. 2a). The proactive route discovery of RPL results in shorter delays and 90.9 % of packets experience a delay less than 0.5 seconds in case of the one hop distance. 0 1 2 3 400.20.40.60.81 secondsCDF RPL LOADng 1h hold LOADng 30 min hold LOADng 10 min hold (a) One hop delays 0 1 2 3 400.10.20.30.40.50.60.70.80.91 secondsCDF RPL LOADng1hhold LOADng30minhold LOADng10minhold  (b) Two hop delays 0 1 2 3 400.20.40.60.81 secondsCDF RPL LOADng 1h hold LOADng 30 min hold LOADng 10 min hold (c) Three hop delays Fig. 2. Packet delay CDFs in a 25 node network. Packets going through one intermediate node, i.e. two hops away from the sink, (cf. Fig 2b) experience higher delay, as expected. In case of RPL, 15.4 % of packets experience a delay greater than 0.5 seconds. The maximal delay in this case is 2.4 seconds. With respect to the 1 hop distance delays, the delay CDF of RPL converges slightly slower due to the processing time and the channel contention at the intermediate node, because nodes have already a route. In case of LOADng and 1 hour RHT, 31 % of packets experience a delay greater than 0.5 sec. Moving farther away from the sink does not signiﬁcantly increase packet delays of RPL. However, we have observed a signiﬁcant delay increase for LOADng. More precisely, 48.2 % of packets experience a delay greater than 0.5 seconds (cf. Fig. 2c). In case of a lower, 10 minute RHT, approximately 62 % of packets undergo a signiﬁcant delay. The reason for the delay increasing with the hop distance is the ﬂooding operation of LOADng as well as the instillation of forward routes. Basically, a node in the network sends a RREQ with the target address of the sink. Due to ﬂooding, the sink receives more than one RREQ, each containing different path metrics. It responds with a RREP to the ﬁrst RREQ and to all other RREQs with lower metrics. Nodes that form the reverse route and forward the RREPs towards its ﬁnal destination instill the route towards the sink. The sink, however, does not have a route towards the intermediate nodes and upon the reception of a packet from them, has to ﬂood the network with anotherRREQ before sending the acknowledgment. This results in an increased delay with respect to packets destined to nodes physically closer to the sink. B. Hop Distance We have studied the optimality of the constructed routes through path hop and packet hop distances. The path hop distance represents the average number of hops between a source and a destination. As the trafﬁc in the network is either multipointtopoint or pointtomultipoint, the sink node is either a source or a destination of each packet. It is interesting to note that while RPL has built only bidirectional paths, some paths in LOADng networks are unidirectional, because of the stochastic nature of the ﬂooding process. More precisely, most nodes add a route to the sink during the ﬁrst sinkoriginated RREQ ﬂooding. However, the reverse path is found at a later time, when the sink needs to address the node. 1 2 3 4 5 600.20.40.60.81 Number of HopsCDF RPL LOADng 1h hold LOADng 30 min hold LOADng 10 min hold (a) CDF of path hop distances. 2 4 6 800.20.40.60.81 Number of HopsCDF RPL LOADng 1h hold LOADng 30 min hold LOADng 10 min hold  (b) CDF of packet hop distances. Fig. 3. Distance CDFs in the 25 node network. Fig. 3a presents the CDF of path hop distances in the network. Notice that the RPL routes are shorter than those of LOADng. As mentioned in Section IVA, the whole house is covered within four hops. The ﬁgure shows that the average path hop distances of RPL are bounded within four hops, which is not the case for LOADng. Moreover, 29 % of RPL routes are within one hop, while it is around 21 % for the LOADng, in the case of 10 minute RHT. This gap is even larger for two hop paths: 67 % of paths in case of RPL, while only 43 % in case of LOADng. Note that LOADng provides its most optimized routes in the case of a shorter RHT. There are two main reasons for this: i) due to the ﬂooding operation the channel is saturated and some RREQ messages are dropped, because they reach the maximal number of attempts of the CSMA protocol, ii) as the nodes are memory constrained, they are only able to store two packets at a time, so RREQ messages that should be forwarded are often dropped. As a consequence, more frequent ﬂooding (shorter RHT) supersedes the lost RREQs and gives more optimized routes. Another issue is the following. If a node has a packet to send and the route is not ready, the most desired behavior, the one implemented in our case, is to buffer the packet. Once the RREP arrives, the node transmits the packet. However, the ﬁrst arriving RREP is not necessarily the optimal one in terms of the route length. Therefore, the packet will follow a nonoptimized route. We can notice in Fig. 3b that a non negligible number of packets go over more than four hops. Upon reception of a subsequent RREP, the node will update itsrouting table and the following packets will follow the updated route. On the other hand, routes constructed with RPL are optimal: not a single packet goes over more than 4 hops. C. Routing Table Size Due to the memory constraints of LLN devices, the routing table size is an important aspect. Fig. 4 shows the results for a 25 node network. 123456789101112131415161718192021222324250510152025 AverageNumberofEntriesintheRoutingTable NodeIDRPL LOADng1hhold LOADng30minhold LOADng10minhold Fig. 4. Average number of routing table entries during the simulation. LOADng requires much higher number of entries with respect to RPL. Again, as a consequence of ﬂooding, each node receiving a RREQ or on a route of a RREP, instills a route towards the sender, which results in a large number of unnecessary routes. Protocol implementors should thus care about the priority of RREP routes. This fact could endanger the operation of the protocol if a node runs out of the available memory. On the other hand, most nodes in the RPL network just have a default entry towards the preferred parent. However, depending on their position in the network, some nodes also have a signiﬁcant number of entries. Namely, as the RPL operates in the storing mode, intermediate nodes selected as preferred parents by others, have to store downward routes. This is a critical issue, because if such a node runs out of memory, a loop may be formed. To see how the protocols scale for a larger network, we have studied the average number of route entries as a function of an increasing number of nodes (cf. Fig. 5a). We can notice that the main consequence of having a long RHT is a signiﬁcantly increasing number of route entries. With a shorter lifetime, the protocol scales better as the routes expire faster and the average number of required entries slowly increases. For RPL, the average number of routes slowly increases. However, it has a signiﬁcantly higher number of entries for 40 nodes, a consequence of the limited number of neighbor entries that nodes can store. During the simulation time, we have observed oscillations in the RPL graph as parent nodes were constantly overwritten by other neighbors so that a number of nodes played the role of the preferred parent and stored downward routes. This behavior may impact the RPL operation for more dense networks. D. Overhead We have evaluated the routing overhead of the protocols as a function of an increasing number of nodes (cf. Fig. 5b presenting the overhead in bytes during the simulation time). Although the previous work [14] revealed a signiﬁcantly higher overhead with RPL, our results show that RPL beneﬁts from fairly low overhead compared to LOADng. We evaluate 15 20 25 30 35 400510152025 Number of nodesRoute EntriesRPL LOADng 10 min hold LOADng 30 min hold LOADng 1h hold (a) Average number of route entries. 15 20 25 30 35 4002468101214x 106 Number of nodesbytesRPL LOADng 10 min hold LOADng 30 min hold LOADng 1h hold (b) Control plane overhead (bytes). Fig. 5. Memory and overhead for an increased number of nodes. the total overhead as a sum of the lengths of all control messages passed from the routing protocols to the layers bellow. Note that by doing so, we avoid taking into account the overhead introduced by ContikiMAC. We can notice that the implementation of ContikiRPL re sults in a lower overhead than observed previously [14]. As the RPL RFC underspeciﬁes the DAO control message emission, the overhead strongly depends on a given implementation. Fur thermore, it is important to note that our simulation scenario does not trigger any global repairs of the RPL DODAG during the eight hours of simulation. In this way, our results give an idea about the performance of the two protocols in the steady state. Thus, we observe that most of the RPL overhead appears at the beginning of the simulation, reduced later by Trickle. The overhead of LOADng strongly depends on RHT: for a shorter RHT, nodes ﬂood more frequently. We can notice from the ﬁgure that the total amount of the LOADng overhead sharply increases with the number of nodes due to the high density of nodes in the network, which may however, be reduced with an optimized ﬂooding algorithm at the cost of a higher complexity. The lifetime of batterypowered nodes directly relates to the use of the radio transceiver. More precisely, in case of the Tmote Sky platform, power consumption due to the radio use is three orders of magnitude larger than that due to CPU processing [12]. Thus, the control plane overhead and average number of hops of a protocol are the determining factors of the expected node lifetime. Our study shows that the control overhead of LOADng for short hold times does not scale well with dense deployments of smart home applications. As we expect an increasing number of devices in home networks, this effect may signiﬁcantly impact the overall network lifetime.VI. R ELATED WORK "
427,Lying Your Way to Better Traffic Engineering.txt,"To optimize the flow of traffic in IP networks, operators do traffic
engineering (TE), i.e., tune routing-protocol parameters in response to traffic
demands. TE in IP networks typically involves configuring static link weights
and splitting traffic between the resulting shortest-paths via the
Equal-Cost-MultiPath (ECMP) mechanism. Unfortunately, ECMP is a notoriously
cumbersome and indirect means for optimizing traffic flow, often leading to
poor network performance. Also, obtaining accurate knowledge of traffic demands
as the input to TE is elusive, and traffic conditions can be highly variable,
further complicating TE. We leverage recently proposed schemes for increasing
ECMP's expressiveness via carefully disseminated bogus information (""lies"") to
design COYOTE, a readily deployable TE scheme for robust and efficient network
utilization. COYOTE leverages new algorithmic ideas to configure (static)
traffic splitting ratios that are optimized with respect to all (even
adversarially chosen) traffic scenarios within the operator's ""uncertainty
bounds"". Our experimental analyses show that COYOTE significantly outperforms
today's prevalent TE schemes in a manner that is robust to traffic uncertainty
and variation. We discuss experiments with a prototype implementation of
COYOTE.","Today’s trafﬁc engineering is suboptimal. To adapt the routing of trafﬁc to the demands network operators do trafﬁc engineering (TE), i.e., tune routingprotocol parameters so as to inﬂuence how trafﬁc ﬂows in their networks [1]–[3]. Today’s prevalent scheme for TE within an organizational IP network is based on conﬁguring static linkweights into shortestpath protocols such as OSPF [4] and splitting trafﬁc between the resulting shortestpaths via ECMP [5]. Tradi tional TE with ECMP signiﬁcantly constrains both route computation and trafﬁc splitting between multiple paths in two crucial ways: (1) trafﬁc from a source to a destination in the network can only ﬂow along the shortest paths between them (for the given conﬁguration of link weights), and (2) trafﬁc splitting between multiple paths (if multiple shortest paths exist) can only be done in very speciﬁc manners (see Section II for an illustration). ECMP’s lack of expressiveness makes trafﬁc engineering with ECMP a notoriously hard task that often results in poor performance. Indeed, not only does ECMP’s inﬂexibility imply that trafﬁc ﬂow might be arbitrarily far from the global optimum [6], but even choosing “good” link weights for TE with ECMP is infeasible in general [7]. Beyond ECMP’s deﬁciencies, today’s dominant TE schemes also suffer from other predicaments, e.g., obtaining an accurate view of trafﬁc demand so as to optimize TE is elusive, as most networks lackthe appropriate measurement infrastructure. Also, trafﬁc can be highly variable and routing conﬁgurations that are good with respect to one trafﬁc scenario can be bad with respect to another. We thus seek a TE scheme that is backwards compatible with legacy routing infrastructure (i.e., OSPF and ECMP), yet robustly achieves high performance even under uncertain or variable trafﬁc conditions. SDN to the rescue? SoftwareDeﬁned Networking (SDN) comes with the promise of improved network manageability and ﬂexibility. Yet, transition to SDN is extremely challenging in practice as realizing fullﬂedged SDN can involve drastic changes to the legacy routing infrastructure. Consequently, recent proposals focus on providing “SDNlike” control over legacy network devices [8], [9]. However, while such control greatly enhances the expressiveness of today’s IP routing, backwards compatibility with legacy equipment and protocols imposes nontrivial constraints on the design of new SDN applications, including that routing be destinationbased and, typically, absence of an online trafﬁc measurement infrastruc ture. We explore how “legacycompatible SDN control” can be harnessed to improve TE in traditional IP networks. COYOTE: optimized, OSPF/ECMPcompatible TE. We leverage recently introduced approaches for enriching ECMP’s expressiveness without changing router hardware/software to design COYOTE (COmpatible Yet Optimized TE). Recent studies show that by injecting “lies” into OSPFECMP (specif ically, information about fake links and nodes), OSPF and ECMP can support much richer trafﬁc ﬂow conﬁgurations [8], [9]. We exploit these developments to explore how OSPF ECMP routing can be extended to achieve consistently high performance even under great uncertainty about the trafﬁc conditions and high variability of trafﬁc. To accomplish this, COYOTE relies on new algorithmic ideas to conﬁgure (static) trafﬁc splitting ratios at routers/switches that are optimized with respect to all(even adversarially chosen) trafﬁc scenarios within operatorspeciﬁed “uncertainty bounds”. Our experimentation with COYOTE on real network topolo gies shows that COYOTE consistently and robustly achieves good performance even with very limited (in fact, sometimes even no) knowledge about the trafﬁc demands and, in particu lar, exhibits signiﬁcantly better performance than (optimized) traditional TE with ECMP. Our experiments with a prototype implementation of COYOTE also demonstrate its performance beneﬁts. We brieﬂy discuss below the algorithmic challenges facing the design of COYOTE and how these are tackled.arXiv:1610.02728v2  [cs.NI]  1 Nov 20162 As discussed above, we view COYOTE as an important additional step in the recent exploration of how SDNlike functionality can be accomplished without changing today’s networking infrastructure (see [8], [9]). Indeed, COYOTE can be regarded as the ﬁrstlegacycompatible SDN application for TE. New algorithmic framework: destinationbased oblivious routing. A rich body of literature in algorithmic theory investi gates “(trafﬁcdemands)oblivious routing” [10]–[12], i.e., how to compute provably good routing conﬁgurations with limited (possibly even no) knowledge of the trafﬁc demands. Past studies [11], [13] show that, even though lacking accurate in formation about the trafﬁc demands, demandsoblivious rout ing algorithms yield remarkably closetooptimal performance on realworld networks. Unfortunately, the abovementioned algorithms involve forwarding packets based on both source and destination and are so inherently incompatible with des tinationbased routing via OSPFECMP. In addition, realizing these schemes in practice entails either excessive use of (e.g., MPLS) tunneling/tagging in traditional IP networks [11], [14], or the ubiquitous deployment of perﬂow routing software deﬁned networking infrastructure [15]. Our design of COYOTE relies on a novel algorithmic framework for demandsoblivious IP routing. We initiate the study of optimizing oblivious routing under the restriction that forwarding is destinationbased. In light of the recent progress on enhancing OSPFECMP’s expressiveness through “SDNlike” control, we view the algorithmic investigation of destinationbased oblivious routing as an important and timely research agenda. We take the ﬁrst steps in this direction. Our ﬁrst result establishes that, in contrast to unconstrained oblivi ous routing, computing the optimal destinationbased oblivious routing conﬁguration is computationally intractable. We show how, via the decomposition of this problem into subproblems that are easier to address with today’s mathematical toolkit, and by leveraging prior research, good routing conﬁgurations can be generated. Organization. We motivate our approach to TE via a simple example in Section II and formulate a major algorithmic challenge facing legacycompatible TE optimization in Sec tion III. Our negative results are presented in Section IV. We present COYOTE’s design and explain how it addresses these challenges in Sections V. A more detailed exposition of COY OTE’s algorithmic framework is presented in the Appendix. An experimental evaluation of COYOTE on empirically derived datasets and COYOTE’s prototype implementation are presented in Sections VI and VII, respectively. We discuss related work in Section VIII. We conclude and leave the reader with promising directions for future research in Section IX. II. A M OTIVATING EXAMPLE We next motivate our approach to TE in IP networks through a simple example, which will be used as a running example throughout the sequel. Consider the toy example in Fig. 1a. Two network users, s1ands2, wish to send trafﬁc to target t. Suppose that each user is expected to send between 0 and 2 units ofs1s2 vt (a)s1s2 vt1=21=2 1=2 1=2 1 (b) s1s2 vt1=21=2 2=3 1=3 1 (c)t s1s2 vt1=21=2 1=31=3 1=3 1 (d) Fig. 1: A sample network: (a) topology with unit capacity links; (b) perdestination ECMP routing (oblivious perfor mance ratio 3=2); (c) COYOTE (oblivious performance ratio 4=3); and (d) COYOTE implementation with a fake node inserted ats1for realizing the required splitting ratio. ﬂow and each link is of capacity 1. Suppose also that the network operator is oblivious to the actual trafﬁc demands or, alternatively, that trafﬁc is variable and user demands might drastically change over time. The operator aims to provide robustly good network performance, and thus has an ambitious goal: conﬁguring OSPFECMP routing parameters so as to minimize link oversubscription across allpossible combinations of trafﬁc demands within the abovespeciﬁed uncertainty bounds. Consider ﬁrst the traditional practice of splitting trafﬁc equally amongst the nexthops on shortestpaths to the des tination (i.e., traditional TE with ECMP, see Fig. 1b), where the shortest path DAG towards tis depicted by dashed arrows labelled with the resulting ﬂow splitting ratios. The actual OSPF weights are not needed, in terms of exposition, and are omitted from Fig. 1b. Observe that if the actual trafﬁc demands are 2and0fors1ands2, respectively, routing as in Fig. 1b would result in link (over)utilization that is 3=2higher than that of the optimal routing of these speciﬁc demands (which can send all trafﬁc without exceeding any link capacity). Speciﬁcally, routing as in Fig. 1b would result in3=2units of trafﬁc traversing link (v;t), whereas the total ﬂow could be optimally routed without at all exceeding the link capacities by equally splitting it between paths (s1s2t) and(s1v t). One can actually show that this is, in fact, thebest guarantee achievable for this network via traditional TE with ECMP, i.e., for any choice of link weights, equal splitting of trafﬁc between shortest paths would result in link utilization that is 3=2higher than optimal for some possible trafﬁc scenario. Can we do better? We show that this is indeed possible if more ﬂexible trafﬁc splitting than that of traditional TE with ECMP is possible. One can prove that for anytrafﬁc demands of the users, per destination routing as in Fig. 1c results in a maximum link3 utilization at most 4=3times that of the optimal routing1. We explain later how COYOTE realizes such uneven per destination load balancing without any modiﬁcation to legacy OSPFECMP. We next formulate the algorithmic challenge facing COYOTE’s design. III. T HEALGORITHMIC CHALLENGE Recent proposals advocate “SDNlike” control over legacy network devices [8], [9]. By carefully crafting “lies” (fake links and nodes) to inject into OSPFECMP , OSPF and ECMP can be made to support much richer trafﬁc ﬂow conﬁgurations. We aim to investigate how these recent advances can be harnessed to improve TE in traditional IP networks. Importantly, while the proposed SDN approach to legacy networks discussed above can greatly enhance the expressive ness of today’s IP routing, compatibility with legacy equip ment and routing protocols induces nontrivial constraints on the design of “legacycompatible SDN applications”: (1) that routing be destinationbased , and (2) typically, the absence of an online trafﬁc measurement infrastructure. Algorithmic research on trafﬁc ﬂow optimization, in contrast, almost uni versally allows the routing of trafﬁc to be dependent on both sources and targets, and often involves accurate and uptodate knowledge of the trafﬁc demand matrices. We thus seek an algorithmic solution to the following natural and, to the best of our knowledge, previously unex plored, challenge: Compute destinationbased (i.e., IProuting compatible) routing conﬁgurations that optimize the ﬂow of trafﬁc with respect to operatorspeciﬁed “uncretainty margins” regarding the trafﬁc demand matrices. We next proceed to formulating this challenge. Our model draws upon the ideas presented in [11]. Network, routing, and trafﬁc splitting. The network is mod eled as a directed and capacitated graph G= (V;E), wherece denotes the capacity of edge e. Arouting conﬁguration on networkGspeciﬁes, for each vertex t2V, and for each edge e= (u;v)2E, a valuet(e)representing the fraction of the ﬂow totentering vertex uthat should be forwarded through edge (link)e. Clearly, for every vertex v,P (u;v)t(u;v) = 1 . Observe that the combination of all t(e)values (across all verticestand edgese) indeed completely determines how ﬂow will be routed between every two endpoints. Since routing is required to be destinationbased, the routes to each destination vertex must form a directed acyclic graph (DAG). This is formally captured by requiring that for every vertext2Vand directed cycle CinG, for some edge e2Con the cycle t(e) = 0 . We say that a routing conﬁguration that satisﬁes this condition is a perdestination (PD) routing conﬁguration. For a PD routing conﬁguration , letfst(v), for vertices s;t;v2V, be the fraction of the demands!tthat entersv. Observe that in PD routing, fst(v) is welldeﬁned and is induced by the t(e)values as follows: fst(v) =P e=(u;v)fst(u)t(e)ifv6=s,1otherwise. Observe that whenxunits of ﬂow are routed from stotthrough the 1In fact, even the routing conﬁguration in Fig. 1c is not optimal in this respect. Indeed, COYOTE’s optimization techniques, discussed in Section V, yield conﬁgurations with better guarantees (see Appendix B).network, the contribution of this ﬂow to the load on link (u;v) isxfst(u)t(u;v). Performance ratio. We are now ready to formalize the optimization objective. Our focus is on the traditional goal of minimizing link (over)utilization (often also called “con gestion” in TE literature). Given a Demand Matrix (DM) D=fds1t1;:::;dsktkgspecifying the demand between each pair of vertices, the maximum link utilization induced by a PD routing (;f)is MxLU (;D) = max e=(u;v)2EP s;t2Ddstfst(u)t(e)=ce. Anoptimal routing forDis a PD routing that minimizes the load on the most utilized link, i.e., OPTU (D) = min jis a PD routingMxLU (;D). Theperformance ratio of a given PD routing on a speciﬁc given DM DisPERF (;fDg) =MxLU (;D)=OPTU (D). Given a setDof DMs, the performance ratio of a PD routing onDisPERF (;D) = maxD2DPERF (;fDg).D, in this formulation, should be thought of as the space of demand matrices deemed to be feasible by the network operator. When Dis the set of allpossible DMs, the performance ratio is referred to as the oblivious performance ratio. A routing is optimal ifPERF (;D)PERF (0;D)for any0. The OBLIVIOUS IPROUTING problem is computing a PD routing that is optimal with respect to a given set Dof DMs. The OBLIVIOUS IPROUTING can be formulated as the following nonlinear minimization problem. min is a PD routing 8edgese= (u;v) : 8DMsD2D withOPTU (D) =r: P (s;t)dstfst(u)t(e)=c(e)r Observe that this optimization objective thus captures both the computation of perdestination DAGs and the computation of inDAG trafﬁc splitting ratios. Our focus is on sets of demand matricesDthat can be deﬁned through linear con straints as such sets are expressive enough to model trafﬁc uncertainty, but mitigate the complexity of the optimization problem. Speciﬁcally, the actual demand dstfrom a vertex s totcan assume any value in the range dmin stdstdmax st, wheredmin standdmax st are the operator’s “uncertainty margins” regardingdstand are given as input. IV. N EGATIVE RESULTS We formulated, in Section III, the fundamental algorith mic challenge facing COYOTE’s design: optimizing (trafﬁc demands)oblivious routing in IP networks. Importantly, this optimization goal is closely related to the rich body of litera ture in algorithmic theory on “unconstrained” (i.e., not limited to destinationbased) oblivious routing [10]–[12]. Our results in this section show that imposing the real world limitation that routing be destinationbased renders the4 s2 s1 xi 2 xi 1 mi t2wi 2wi 2wiwiwi wi Fig. 2: The I NTE GER gadget. s2 s1 xk 2 xk 1 mk tx1 2 x1 1 m1Fig. 3: Reduction instance. computation of “good” oblivious routing solutions signiﬁ cantly harder. We ﬁrst show that, in contrast to unconstrained oblivious routing [11], destinationbased oblivious routing is intractable, in the sense that computing the optimal routing conﬁguration is NPhard. Worse yet, in general, the oblivious performance ratio, i.e., the distance from the best demands aware routing solution can be very high (as opposed to logarithmic for unconstrained oblivious routing). We explain in Section V how COYOTE’s design addresses these obstacles. We next present our two negative results. A. Oblivious IP Routing is NPHard We examine the computational complexity of the O BLIVI  OUS IPROUTING problem, as formulated in Section III. We present the following computational hardness result. Theorem 1: The O BLIVIOUS IPROUTING problem is NP hard even ifDconsists of only two possible demand matrices, only two vertices can source trafﬁc, and all trafﬁc is destined for a single target vertex. Proof of Theorem 1. Our proof reduces the B IPARTITION problem to O BLIVIOUS IPROUTING . In the B IPARTITION problem, the input is a set W=fw1;:::;wkgofkpositive integers and the goal is to partition then into two sets Aand Bsuch that the sum of the elements in one partition is equal to the sum of the elements in the other partition. We now show how to construct an instance I0of the OBLIVIOUS IPROUTING problem from an instance Iof the BIPARTITION problem so that the reduction holds, i.e., I0is a positive instance if and only if Iis a positive instance.. LetSUM be the sum of all the elements in W. We create a directed graph Gas follows. We add two source vertices s1ands2and a single destination vertex dintoG. For each integerwiinW, we construct an I NTEGER gadget as follows (see Fig. 2). We add three vertices x1 i,x2 i, andmi. We then add bidirectional edges (x1 i;x2 i),(x1 i;mi), and (x2 i;mi)each with capacitywi. Finally, we add two edges (s1;x1 i)and(s2;x2 i) with capacity 2wiand edge (mi;d)with capacity 2wiintoG. Observe that we can narrow our attention to demand ma trices that can be routed in Gwithout exceeding the edge capacities since the performance ratio is invariant to the rescaling of trafﬁc demands. In addition, as this set describes a convex polyhedron in the demand space, we can further restrict our focus to those vertices of the demand polyhedron that arenot “dominated” by any other demand vertex, i.e., demand d= (d1;:::;dn)dominates demandd0= (d0 1;:::;d0 n), if, for alli= 1;:::;n , we havedid0 i. In our reduction, the mincut between the source ver tices and the target tis2SUM , i.e.,mincut (s1;t) = mincut (s2;t) =mincut (fs1;s2g;t) = 2SUM . As such, the set of demand matrices that can be routed within the edge capacities isD=f(ds1t;ds2t)jds1t+ds2t2SUM;ds1t 0;ds2t0g. As observed in Section III, the only relevant demand points are D1= (ds1t;ds2t) = (2SUM; 0)and D2= (ds1t;ds2t) = (0;2SUM ), which are vertices of the demands polyhedron. There are two crucial routing decisions that have to be made at this point in order to route any demand matrix in D. The ﬁrst one is deciding what is the directed acyclic graph that must be used to routed any trafﬁc from the source vertices to t. The second one is computing the splitting ratios within that DAG. Observe that an optimal routing solution for D1(D2) would orient all the edges x1 i(x2 i) towardsx2 i(x1 i) in the per destination DAG rooted at tand split the trafﬁc at s1in such a way that 2wiunits of ﬂow are sent to the i’th I NTEGER gadget and equal split is performed at x1 i(x2 i). In this case, D1(D2) could be routed without exceeding the edge capacities. This optimal routing for DM D1(D2) would cause a link utilization of2when routing DM D2(D1). As such, in order to minimize the oblivious ratio, the crucial routing decision boils down to carefully choose how to orient the edges (x1 i;x2 i)in each INTEGER gadget. Lemma 2: LetIbe a positive instance of B IPARTITION . ThenI0has a solution with oblivious performance4 3. Proof: Let(P1;WnP1)be two equal size partitions of W. We show how to construct an oblivious routing that has oblivious performance4 3. We deﬁne an oblivious routing via splitting ratios at each vertex of the graph, where a splitting ratio of 0implies that the outgoing link is oriented in the opposite direction in the perdestination DAG towards t. The splitting ratios (s1;x1 i) ats1(s2) is4wi 3SUMifwiis inP1(P2),2wi 3SUMotherwise. The splitting ratios (x1 i;x2 i)atx1 i(x2 i) is1 2ifwiis inP1(P2),0 otherwise. The splitting ratios (x1 i;mi)atx1 iis1"
273,Performance evaluation and enhancement of VLAN via wireless networks using OPNET modeler.txt,"A VLAN is a logical connection that allows hosts to be grouped together in
the same broadcast domain, so that packets are delivered only to ports that are
combined to the same VLAN. We can improve wireless network performance and save
bandwidth through the characteristic VLAN network. In addition, the
implementation of VLAN greatly improves wireless network security by reducing
the number of hosts receiving copies of frames broadcast by switches, thus
keeping hosts holding critical data on a separate VLAN. In this paper we
compare wireless network with VLAN via wireless network. The proposed network
is evaluated within terms of delay and average throughput using web browsing
applications and file transfer in heavy traffic. The simulation was carried out
using OPNET 14.5 modeler and the results show that the use of VLAN via wireless
network improved performance by reducing traffic resulting in a minimized delay
time. Furthermore, VLAN implementation reduces network throughput because the
traffic received and transmitted has a positive relationship with throughput.
Eventually, we investigated the use of adhoc routing protocols such as AODV,
DSR, OLSR, TORA and GPR to improve the performance of wireless VLAN networks.","  WLAN (Wireless Local Area Networks) allows devices to move across the network from one  location to another and connect to the LAN wirelessly via radio transmission  to share data and  applications and other resources, withou t being tied to connections [1][ 2]. WiFi (Wireless  Fidelity) is referred to as the standard for WLAN communication . Today, one of the most  common wireless technologies used for data transfer is the IEEE 802.11 standard, due to the need  for high speed data  rates  many standards developed to meet customer's needs  [3][4] . The table 1.  Show  most commonly used protocol in today’s environment  [5].    Table 1. Summary of Various WLAN Standards.     Standards  RF Band  Max. Data Rate  Range   IEEE 802.11  2.4GHz  2Mbs  50 – 100m  IEEE 802.11b  2.4GHz  11Mbps  50 – 100m   IEEE 802.11a  5GHz  54Mbps  50 – 100m   IEEE 802.11g  2.4GHz  54Mbps  50 – 100m    International Journal of Wireless & Mobile Networks (IJWMN) Vol. 12, No. 3, June 2020   16 WLAN infrastructure, as shown in Figure 1, consists of wireless stations and access points (AP)  and supports many wireless stations, depend ing on the specification of the AP . The wireless  network can be connected to the Ethernet network using a UTP cable up to 100 meters from the  AP to the switch or hub  [6]. Mobile stations can move while communicating and automatically  search and connect to the access point device using SSID (Service Set Identifier) which is the  unique name of the wireless network that matches the AP that is defined in the program, SSID  keeps packets within the correct WLAN  [1].      Figure 1. Wireless infrastructure diagram     There are many key performance metrics to consider when evaluating  a wireless 802.11 WLAN  solution, in this paper we considered throughput and delay, throughput is the rate at which the  wireless LAN destination receives data successfully, while delay is th e time it takes to transmit  data from the source to the destination node successfully  [6][7][8].     A Local Area Network (LAN) is usually defined as a broadcast domain,  meaning that all  connected devices are in the same physical LAN without a router. [7]. Virtual LANs that have  been described regularly as a group of devices on different physical LAN segments that can  communicate as if they had a common LAN segment . Switches using VLANs to divide  the  network into separate broadcast domains without any latency  problems [8]. VLAN trunk used  when connecting switches that support multiple VLANs crossing the same Ethernet connections  as shown in Figure 2, the switches tag each frame sent between switches to specify the VLAN the  frame belongs to . VLANs are based on the standard IEEE 802.1Q, which specifies the tagging  frame format [7][9].         Figure 2. Network with Two VLANs     VLANs provide a number of benefits, including ease of management, decreased broadcasting and  implementation of security policies  [8][9]. The ma in advantages of VLAN are listed below :       International Journal of Wireless & Mobile Networks (IJWMN) Vol. 12, No. 3, June 2020   17  Performance: Network traffic is full of broadcast, so VLAN segments a large broadcast domain  into a small broadcast domain that reduces unnecessary traffic in the network by sending packets  only between ports th at are combined to the same VLAN that reduce overhead and delay in  addition to saving bandwidth .   Organization:  VLANs can be very useful to logically group hosts according to their departments  or jobs that are easy to handle compared to a larger broadcast  domain .   Security:  Sensitive data can be accessed by outsiders on the same network, but by creating  VLAN, network security can be greatly enhanced by reducing the number of hosts receiving  copies of frames that are broadcast by switches and keeping hosts  holding sensitive data on a  separate VLAN .    Cost reduction:  It is possible to use VLANs to create broadcast domains that cost less than  costly routers.     The 802.11  communications  standard defines two operating modes , Infrastructure   mode  and adhoc mode  [10]. In infrastructure mode as shown in Fig ure 3, Wireless hosts can  communicate with each other through access points that are typically the default mode [6]. In  adhoc mode as shown in Fig ure 4, Without AP, wireless hosts can communicate directly with  each other as a peer topeer network type, each host acts simultaneously as both a client and a  point of access . An adhoc network is a temporary network connection created for a specific  purpose in which hosts can send data directly to other hosts instead of passing through an access  point  [13].       Figure 3. The 802.11 network Infrastructure operating modes         Figure 4. The 802.11 network adhoc operating modes      This paper provides enormous potential for enhancing wireless network efficiency . A brief  introdu ction to the wireless and VLAN networks is given in this section, whereas the rest of the International Journal of Wireless & Mobile Networks (IJWMN) Vol. 12, No. 3, June 2020   18 paper is organized as follows: Section 2 illuminates adhoc routing protocols with a focus on flat  routing protocol classifications  (reactive, proactive, and hybrid); Section 3 of the paper offers a  brief review of related work in wireless networks and VLAN networks as well as most important  previous studies on adhoc routing performance ; subsequently, simulation model describes the  simulation tool, simulation performanc e metrics, simulation setup and scenarios demonstrating   three type of networks :wireless network, wireless network with VLAN and wireless VLAN  network with adhoc routing protocols are given in section 4. Section 5 shows the simulation  results of a comparis on of all simulations performed to show the performance metrics evaluated .   Finally, the conclusion is given in Section 6 based on all the work done and evaluated  performance.     2. ADHOC ROUTING PROTOCOLS OVERVIEW       The routing protocols that have been develo ped for adhoc networks play an important role in  affecting data transmission and network performance . Since all network nodes act as routers and  participate in the discovery and maintenance of routes to other nodes on the network, each  routing protocol has  its own routing strategy to choose the best path between nodes . There are  three main types of routing protocols for adhoc networks: proactive routing protocols, reactive  routing protocols and hybrid routing protocols [13] [17].     Proactive routing is also known as table driven routing protocols because at any time, each node  in the network has one or more routes to any destination in its own routing table. [14]. Reactive  routing protocols are also known as on demand routing protocols, which are the source n ode to  establish routes only when you have data to send, if there is no path, the protocol begins a route  discovery process to find a route to the destination  [17]. In hybrid routing protocols, each node  acts reactively in a region that is close to it and proactively outside that region [14] [13].     A brief overview of the routing operations performed by the familiar OLSR, GRP, DSR, AODV  and TORA protocols is discussed in this section. Figure 5 illustrates the routing protocols  considered in this paper .       Figure 5. The adhoc routing protocols     Optimized Link State Routing (OLSR): Is a proactive protocol based on a link state algorithm  [18]. The protocol's main concept is to adjust network changes without creating overhead control  messages . Thus, only a grou p of nodes named Multi  Point Relays  (MPR)  in the network  responsible for transmitting control messages and creating link state information . Each MPR  chooses to broadcast state information only between itself and the nodes that selected it  [16].   International Journal of Wireless & Mobile Networks (IJWMN) Vol. 12, No. 3, June 2020   19 Adhoc On Demand Distance Vector Routing (AODV): Reduces the number of broadcasts by  creating routes to the destination only when required, as nodes not on a selected path do not  maintain routing information or participate in routing table exchanges [14]. If the sour ce node has  data to send and does not have a valid route to that destination, it initiates a path discovery  process to find the destination node [15] [19].    Dynamic Source Routing (DSR): Is a simple and efficient routing protocol consisting of two  mechanis ms, route discovery and route maintenance [14]. The source node uses route discovery  to find a route when a request arrives and inserts the paths found in the packet header .  Intermediate nodes do not need to maintain up todate routing information other th an  participation in route discovery and maintenance  [18][15 ].    Temporally  Ordered Routing Algorithm (TORA): Is an on demand routing protocol , TORA's  main objective is to limit the control message in a highly dynamic mobile environment [16]. Each  node must initiate a query to send the data to the destination. In essence, TORA performs three  tasks: creating a route from the source to the destination, maintaining the route and erasing the  route when the route is not valid .     Geographic  Routing Protocol (GRP): Is classified as a proactive routing protocol . The GRP  source node collects network information using the Global Positioning System (GPS) with a  small amount of control overheads  [17].     3. RELATED WORKS    "
201,6RLR-ABC: 6LoWPAN Routing Protocol With Local Repair Using Bio Inspired Artificial Bee Colony.txt,"In recent years, Micro-Electro-Mechanical System (MEMS) has successfully
enabled the development of IPv6 over Low power Wireless Personal Area Network
(6LoWPAN). This network is equipped with low-cost, low-power, lightweight and
varied functions devices. These devices are capable of amassing, storing,
processing environmental information and conversing with neighbouring sensors.
These requisites pose a new and interesting challenge for the development of
IEEE 802.15.4 together with routing protocol. In this work, 6LoWPAN Routing
Protocol with Local Repair Using Bio Inspired Artificial Bee Colony (6RLR-ABC)
has been introduced. This protocol supports connection establishment between
nodes in an energy-efficient manner while maintaining high packet delivery
ratio and throughput and minimizing average end-to-end delay. This protocol has
been evaluated based on increasing generated traffic. The performance of the
designed 6RLR-ABC routing protocol has been evaluated compared to 6LoWPAN
Ad-hoc On-Demand Distance Vector (LOAD) routing protocol. LOAD protocol has
been chosen since it is the most relevant existed 6LoWPANrouting protocol. The
simulation results show that the introduced 6RLR-ABC protocol achieves lower
packet average end-to-end delay and lower energy consumption compared to LOAD
protocol.Additionally,the packet delivery ratio of the designed protocol is
much higher than LOAD protocol. The proposed 6RLR-ABC achieved about 39% higher
packet delivery ratio and about 54.8% higher throughput while simultaneously
offering lower average end-to-end delay and lower average energy consumption
than LOAD protocol.","  Recent advances , in wireless sensor networks , are widely proliferated of embedded applications.  The diversity of applications are ranging from smart mobility and smart tourism, public safety  and environmental monitoring, smart home, smart grid, industrial processing, agriculture and  breeding, logistics and product lifetime management, medical and healthcare , and independent  living [12]. The emergence of a new paradigm, Low power Personal Area Networks  (LoWPANs) is described well by the wireless standard IEEE 802.15.4. Internet Engineering  Task Force (IETF) ha d managed an effort to integrate the standard of IEEE 802.15.4 networks  and Internet Protocol version 6 (IPv6) called 6LoWPAN [3]. The rising of the new device  embedded with internet connectivity is a dominant cand idate for innovative networks [4 ]. International Journal of Computer Networks & Communications (IJCNC) Vol.12, No.3, May 2020   22   6LoWPAN is principally challenging because of two technologies; the Internet Protocol (IP) and  limited device standard IEEE 802.15.4 that collaborate together.  The 6LoWPAN wireless  devices are designed to have battery powered and need  to keep low operation cycles [5 ]. Besides  that, the encapsulated IPv6 packet , within the limited b andwidth and frame size , requir es  fragmentation and reassembly of data packets [6 ]. Hence, some algorithms had been pr oposed  for header compression [7 8]. Routing protocol is used to ensure that the packet is sent from the  source and received by the destin ation through the optimal path s. The optimal paths are  measured in terms of some criteria such as number of hops, traffic, energy usage, bandwidth and  shortest delay and able to work with limited power of nodes and limited capacity of the wireless  link [9 ]. According to network structure , LoWPAN routing protocols ha d been classified into  three main categories: flat based, hierarchical based and location based routing  protocols . On the  other hand, routing protocols had been classified based on protocol opera tion i nto two types :  Firstly, distance vector routing and secondly, link state routing [5 6]. Additionally, r outing   protocols had been classified based on the updating style of routing tables of nodes  to proactive,  reactive and hybrid [10].     In 6LoWPAN, tw o routing schemes had been  introduced : mesh under and route over. In mesh  under , the routing  decision  is not taken in the network layer, and hence it is not performed based  on IP address. Conversely, the routing decision in mesh under routing is perform ed at adaptation  layer. Hence, it is performed based on the IEEE 802.15.4 Medium Access Control ( MAC )  addresses (16 bits or 64 bits).In contrast, in route over, the routing decision  between IPv6  domain and PAN  is performed based on the IP address at the network layer  [11].    In this paper, a new bio inspired swarm intelligence routing scheme  has been proposed. This  scheme is used to establish local route repair in order to overcome the link break between the  source and the destination in 6LoWPAN .The scheme  has its exclusive invent of a reliable routing  protocol that considers the artificial bee colony algorithm of foraging behaviour and the link  breakages.  Simulation  has been  performed to evaluate the performance of our proposed scheme  in comparison to 6LoW PAN Ad hoc OnDemand  Distance Vector (LOAD)  routing . The rest of  this paper is structured as follows: related works that summarize the LOAD, MLOAD and  Originator Recognition ( OR) path recovery mechanism for LOAD Based Routing Protocol  is  presented in Section 2 , background of 6LoWPAN routing protocols and their classification  are  introduced in Section 3 ,artificial bee colony algorithm  is presented in Section 4,  the introduced  6LoWPAN routing protocol with local repair using bio inspired  artificial bee colony  is discussed  in Section 5, results are analysed in Section 6 . Finally, the paper is concluded in Section 7.    2. RELATED WORKS   "
231,Sequence Numbers Do Not Guarantee Loop Freedom; AODV Can Yield Routing Loops.txt,"In the area of mobile ad-hoc networks and wireless mesh networks, sequence
numbers are often used in routing protocols to avoid routing loops. It is
commonly stated in protocol specifications that sequence numbers are sufficient
to guarantee loop freedom if they are monotonically increased over time. A
classical example for the use of sequence numbers is the popular Ad hoc
On-Demand Distance Vector (AODV) routing protocol. The loop freedom of AODV is
not only a common belief, it has been claimed in the abstract of its RFC and at
least two proofs have been proposed. AODV-based protocols such as AODVv2 (DYMO)
and HWMP also claim loop freedom due to the same use of sequence numbers.
  In this paper we show that AODV is not a priori loop free; by this we counter
the proposed proofs in the literature. In fact, loop freedom hinges on
non-evident assumptions to be made when resolving ambiguities occurring in the
RFC. Thus, monotonically increasing sequence numbers, by themselves, do not
guarantee loop freedom.","Wireless Mesh Networks (WMNs), which can be consid ered to include Mobile Adhoc Networks (MANETs), have gainedconsiderablepopularityandareincreasingly deplo yed inawiderangeofapplicationscenarios, includingemergen cy response communication, intelligent transportation syst ems, miningandvideosurveillance. Theyareselforganisingwi re less multihopnetworksthatcanprovidebroadbandcommu nication without relying on a wired backhaul infrastructur e, a beneﬁt for rapid and lowcost network deployment. Highlydynamictopologies are akeyfeature ofWMNs and MANETs, due to mobility of nodes and/or the variability of wireless links. This makes the design and implementation of robust and eﬃcient routing protocols for these networks a challenging task, and a lot of research eﬀort has gone into it . Loop freedom is a critical property for any routing proto col, but it is particularly relevant and challenging for WMN s and MANETs. Descriptions as in [9] capture the common understanding of loop freedom: “ A routingtable loop is a path speciﬁed in the nodes’ routing tables at a particular point in time that visits the same node more than once before reaching the intended destination. ”Packets caught in a rout ing loop, until they are discarded by the IP TimeToLive (TTL) mechanism, can quickly saturate the links and have a detrimental impact on network performance. It is therefore critical to ensure that protocols prevent routing loops. Sequence numbers, indicating the freshness of routing in formation, havebeenwidely usedtoguarantee loop freedom, inparticularfordistancevectorprotocols suchasDSDV[20 ], AODV [19], AODVv2 (formerly known as DYMO) [21] and HWMP [14]. These protocols claim to be loop free due to the use of monotonically increasing sequence numbers. For example, the AODV RFC states: AODV“ uses destination sequence numbers to ensure loop freedom at all times (even in the face of anomalous delivery of routing control mes sages), ... ” [19], and a similar claim is made in the IETF draft of AODVv2 [21]: “ AODVv2 uses sequence numbers to assure loop freedom [Perkins99]. ”1A proof of loop freedom of AODV has been provided in [22]. Another, more recent 1Here, [Perkins99] is our reference [22]. 1proof is [26].2It is therefore a common belief that the use of sequence numbers in this context guarantees loop freedom. However, while this use of sequence numbers can be an eﬃcient approach to address the problem of routing loops, we show in this paper that sequence numbers by themselves do not guarantee loop freedom. We illustrate this using AODV as a running example. We show that loop freedom can be guaranteed only if se quence numbers are used in a careful way, considering fur ther rules and assumptions on the behaviour of the protocol. The problem is, as shown in the case of AODV, that these additional rules and assumptions are not explicitly stated in the RFC, and that the RFC has signiﬁcant ambiguities in this regard. We demonstrate that routing loops can be created—while fully complying with the RFC, and making reasonable assumptions whentheRFCallows diﬀerentinter pretations. As a consequence, which is a key contribution of this paper, we obtain that routing protocols using sequence numbers as described in [19] are not a priori loop free. We argue that the lack of precision and the corresponding ambi guity of the protocol deﬁnition in the RFC is a key problem here—and for RFCs in general. As another contribution we show details of several ambiguities and contradictions in t he AODV RFC, and discuss which interpretations will lead to routing loops. A third contribution of this paper is an ana lysis of ﬁve key implementations of the AODV protocol, and a discussion of their corresponding loop freedom propertie s. To address the problem of ambiguities and contradictions in RFCs, we argue for the beneﬁt of more precise and for mal approaches for the speciﬁcation of protocols, which are suﬃciently expressive to model real networks and protocols , while maintaining usability. As a ﬁnal contribution we show how formal methods can be used to avoid ambiguities in RFCs and to guarantee properties such as loop freedom. The remainder of the paper is organised as follows: in Sec tion 2 we recapitulate the basic principles of the AODV pro tocol. We state what we mean by loop freedom and discuss the existing proofs of AODV’s loop freedom. In Section 3, nearly all plausible readings of the AODVRFC, resolving its ambiguities and contradictions, are discussed. Each of the presented interpretations is analysed w.r.t. loop freedom . In Section 4 we show an example of a routing loop occurring in the AODV routing protocol, as a result of following a rea sonable and plausible interpretation of the RFC. Havingthe various RFC interpretations and the loop example in mind, we then analyse ﬁve diﬀerent key implementations of AODV w.r.t. routing loops. Finally, in Section 6, we sketch how fo r mal methods—here in the form of process algebra—can be applied to model routing protocols and verify the presented results on routing loops. Before we conclude with a short discussion in Section 8, we present major related work in Section 7. 2. AODV To prove that sequence numbers do not a priori guaran tee loop freedom, we use AODV as an example. We expect that other routing protocols such as AODVv2 and HWMP behave similarly. AODV [19] is a popular routing protocol designed for MANETs, and is one of the four protocols cur rently standardised by the IETF MANET working group3. 2We discuss problems with these proofs later in this paper. 3http://datatracker.ietf.org/wg/manet/charter/It also forms the basis of new WMN routing protocols, in cluding the upcoming IEEE 802.11s wireless mesh network standard [14]. AODV is designed for wireless and mobile networks where links are particularly unreliable. 2.1 Brief Overview AODV is a reactive protocol, which means that routes are established only on demand. If a node Swants to send a data packet to a node D, but currently does not know a route, it temporarily buﬀers the packet and initiates a rout e discovery process by broadcasting a route request (RREQ) message in the network. An intermediate node Athat re ceives the RREQ message creates a routing table entry for a route towards node Sreferred to as a reverse route , and rebroadcasts the RREQ. This is repeated until the RREQ reaches the destination node D, or alternatively a node that knows a route to D. In both cases, the node replies by uni casting a corresponding route reply (RREP) message back to the source S, via a previously established reverse route. When forwarding RREP messages, nodes create a routing table entry for node D, called the forward route . When the RREP reaches the originating node S, a route from Sto Dis established and data packets can start to ﬂow. Both forward and reverse routes are maintained in a routing ta ble at every node—details are given below. In the event of link and route breaks, AODV uses route error (RERR) messages to notify the aﬀected nodes: if a link break is de tected by a node, it ﬁrst invalidates all routes stored in the node’s own routing table that actually use the broken link. Then it sends a RERR message containing the unreachable destinations to all (direct) neighbours using this route. In AODV, a routing table consists of a list of entries—at most one for eachdestination—each containingthefollowin g information: •the destination IP address; •the destination sequence number; •the sequencenumberstatus ﬂag—tagging whether the recorded sequence number can be trusted; •a ﬂag tagging the route as being valid or invalid—this ﬂag is set to invalid when a link break is detected; •the hop count, a metric to indicate the distance to the destination; •the next hop, an IP address that identiﬁes the next (in termediate) node on the route to the destination; •a list of precursors, a set of IP addresses of those 1hop neighbours that use this particular route; and •the lifetime (expiration or deletion time) of the route. The destination sequence number constitutes a measure ap proximatingtherelativefreshnessoftheinformationheld —a higher number denotes newer information. The routing ta ble is updated whenever a node receives an AODV control message (RREQ, RREP or RERR) or detects a link break. During the life time of the network, each node not only maintains its routing table, it also stores its own sequence number. This number is used as a local“timer”and is incre mented whenever a new route request is initiated. Full details of the protocol are outlined in the request for comments (RFC) [19], the oﬃcial speciﬁcation of AODV. 22.2 Loop Freedom The “naive” notion of loop freedom is a term that infor mally means that“a packet never goes round in cycles with out (at some point) being delivered”. This dynamic deﬁni tion is too restrictive a requirement for AODV. There are situations where packets are sent in cycles, but which shoul d not be considered“harmful”. This can happenwhen the net work topology keeps changing. The sense of loop freedom is much better captured by a static invariant, saying that at any given time the collective routing tables of the nodes do not admit a loop . Such a requirement does not rule out the dynamic loop alluded to above. However, in situations where the topology remains stable suﬃciently long it does guarantee that packets will not keep going around in cycles. 2.3 Proofs Based OnSequence Numbers As mentioned before, AODV “ uses destination sequence numbers to ensure loop freedom at all times ” [19, Page 2]. Moreover, it has been“proven”at least twice that AODV is loop free [22, 26]. In both papers a main argument is that messages relating to a particular route request are handled only once at ev ery node; moreover that every route discovery process has a unique sequence number. The latter is guaranteed since a node’s own sequence number is incremented whenever a new route discovery is initiated. Each sequence number stored in any routing table for destination dipis ultimately derived fromdip’s own sequence number at the time such a route was discovered. The proof sketch given in [22] uses the fact that when a loop in a route to a destination Zis created, all nodes Xion that loop must have route entries for destination Zwith the same destination sequence number. “ Furthermore, because the destination sequence numbers are all the same, the next hop information must have been derived at every node Xi from the same RREP transmitted by the destination Z”[22, Page 11]. The latter is not true at all: some of the infor mation could have been derived from RREQ messages, or from a RREP message transmitted by an intermediate node that has a route to Z. More importantly, the nodes on the loop may have acquired their information on a route to Z from diﬀerent RREP or RREQ messages, that all carried the same sequence number. This will be illustrated in our forthcoming loop example. The proof of [26] was established in two steps: (i) a math ematical model of AODV was derived4; (ii) based on the derived model loop freedom was proven using the interac tive theorem prover Isabelle [18].5In the model of [26] route replies generated by intermediate nodes [19, Sect. 6.6.2.] are not considered. Since this is a key feature of AODV (and, as we shall see, an essential ingredient in the creation of rout  ing loops), the work of [26] cannot be said to pertain to the full protocol. 3. AMBIGUITIESIN THEAODVRFC “A Request for Comments (RFC) is a publication of the Internet Engineering Task Force (IETF) and the Internet Society [...]. A RFC is authored by engineers and computer scientists in the form of a memorandum describing methods, behaviors, research, or innovations applicable to the work ing 4In [26] the model is only given partially. 5Again only snippets of the proofs can be found in [26].of the Internet and Internetconnected systems. [...] The IETF adopts some of the proposals published as RFCs as In ternet standards. ”6Not all RFCs are standards [13]. How ever, in the case of the AODV routing protocol, the RFC 3561 [19] is the de facto standard. RFCsaretypicallywritteninEnglishandarenotequipped with a formal description language. This has the advantage that everybody can read any RFC. However, it holds the disadvantage that the RFC contains contradictions and am biguities. Additionally, there may be unexpected situatio ns occurring in real networks that are not described or antic ipated by the RFC. In sum, this yields a variety of inter pretations for every RFC; some interpretations being more plausible than others. In this section, we discuss some of the ambiguities found in the speciﬁcation of AODV. We catalogue and analyse the variants of AODV arising from interpretations consis tent with the reading of the RFC and show which of them yields routing loops. Our analysis is based on a rigorous, formal, and mathematical approach [7]. A full and detailed analysis is given in [8]. Table 1 summarises the results; sec  tion numbers refer to [19]. One of the crucial aspects of AODV is the maintenance of routing tables. Hence the update of routing table entries with new information has to be performed carefully. Un fortunately, the RFC speciﬁcation only gives hints how to update routing table entries; an exact and precise deﬁnitio n is missing. 1. Updating the Unknown (Invalid)SequenceNum ber in Response to a Route Reply. If a node receives a RREP message, it might have to update its routing ta ble: “the existing entry is updated only in the following cir cumstances: (i) the sequence number in the routing table is marked as invalid [...] ” [19, Sect. 6.7]. Here it is rele vant that, through the sequencenumberstatus ﬂag, any se quence number can be marked as unknownor invalid. In the same section it is also stated what actions occur if a route is updated. Among others it is stated that“ the destination sequence number is marked as valid, [...] and the [new] des tination sequence number [in the routing table] is the Desti  nation Sequence Number in the RREP message. ” [19, Sect. 6.7]. The interpretation that follows these lines literall y is denoted 1a in Table 2. It can decrement sequence numbers, which immediately yields routing loops, as explained in [8, Sect.8]. ThisupdatemechanismcontradictsSect.6.1of[19 ], which states that any information from an incoming AODV control message that carries a lower sequence number than the corresponding entry in the routing table MUST be dis carded (Interpretation1b). The routingloops resultingfr om following Sect. 6.7 strongly indicate that this contradict ion in the RFC should be resolved in favour of Sect. 6.1. 2. Updating with the Unknown Sequence Number. Whenever a node receives a forwarded AODV control mes sage from a 1hop neighbour, it creates a new or updates an existing routing table entry to that neighbour. For ex ample, “ [w]hen a node receives a RREQ, it ﬁrst creates or updates a route to the previous hop without a valid sequence number”[19, Sect. 6.5]. In case a new routing table entry is created, the sequence number is set to a default value (typi cally 0, as is done in implementations such as AODVUU[2], AODVUIUC [15] and AODVUCSB [4]) and the sequence 6http://en.wikipedia.org/wiki/Request_for_Comments 3Table 1: Analysis of diﬀerent interpretations of the RFC 356 1 (AODV) 1. Updating the Unknown (Invalid) Sequence Number in Respon se to a Route Reply 1a.the destination sequence number (DSN) is copied from the RREP message (Sect 6.7)may decrement sequence numbers, which causes loops 1b.the routing table is not updated when the information that it has is“fresher”(Sect. 6.1)does not cause loops 2. Updating with the Unknown Sequence Number (Sect. 6.5) 2a.no update occurs does not cause loops, but opportunity to improve routes is missed. 2b.overwrite any routing table entry by an update with an unknown DSNmay decrement sequence numbers, which causes loops 2c.use the new entry with the old DSN does not cause loops 3. (Dis)Allowing the Creation of SelfEntries in Response t o a Route Reply 3a.allow (arbitrary) selfentries loop free only if used with Interpretations 4d or 4e below 3b.allow optimal selfentries only; store own sequence number in optimal selfentrydoes not cause loops 3c.disallow selfentries; if selfentries would occur, ignor e msg. does not cause loops 3d.disallow selfentries; if selfentries would occur, forwa rd does not cause loops 4. Invalidating Routing Table Entries in Response to a Route Error Message 4a.always copy DSN from RERR message (Sect. 6.11) may decrement sequence numbers, which causes loops (when allowing selfentries (Interpretation 3a)) 4b.only invalidate if the DSN in the routing table is smaller than or equal to the one fromthe RERRmessage (Sect. 6.1)causes loops (when allowing selfentries) 4c.take the maximum of the DSN of the routing table and the one from the RERR messagecauses loops (when allowing selfentries) 4d.take the maximum of the increased DSN of the routing table and the one from the RERR messagedoes not cause loops 4e.only invalidate if the DSN in the routing table is smaller than the one from the RERR message (Sect. 6.2)does not cause loops numberstatus ﬂag is set to unkto signify that the sequence number corresponding to the neighbour is unknown. But, what happens if there exists already a routing table entry? Following the quote above, the routing table has to be up dated. Unfortunately, it is not stated how the update is done.7There are three reasonable options: (2a) no update occurs. This interpretation is harmless with regard to routing loops, but misses an opportunity to im prove some routes. It can be argued that the RFC rules out this option by including“or updates”in the quote above. (2b) All information is taken from the incoming AODV con trol message; since that message formally does not contain a sequence number for the neighbour, the destination se quence number is set to value 0. Since this can decrease sequence numbers, routing loops might occur. Hence this interpretation must not be used. (2c) The information from the routing table and from the incoming AODV control message is merged.8This interpre tation does not give rise to loops. 3. (Dis)Allowing the Creation of SelfEntries in Re sponse to a Route Reply. In any practical implementa tion, when a node sends a data packet to itself, the packet will be delivered to the corresponding application on the local node without ever involving a routing protocol and therefore without being“seen”by AODV or any other rout ing protocol. Because of this it seems that it does not make a diﬀerence whether any node using AODV stores routing table entries to itself. In AODV, when a node receives a RREP message, it cre ates a routing table entry for the destination node if such an 7Section 6.2 of [19] further explains in which circumstances an updateoccurs. Itdoes not resolve this ambiguity (cf. [8] ). 8By taking the destination sequence number from the exist ing routing table entry and all other information from the AODV control message.entry does not already exist [19, Sect. 6.7]. If the destina tion node happens tobe the processing node itself, this lead s to the creation of a selfentry. The RFC does not mention selfentries explicitly; it only refers to them at one locat ion: “A node may change the sequence number in the routing ta ble entry of a destination only if: – it is itself the destinat ion node [...] ”[19, Sect. 6.1]. This points at least to the pos sibility of having selfentries. We have analysed various i m plementations of AODV and found that the KernelAODV [1], AODVUIUC[15], AODVUCSB [4] and AODVns2im plementations allow the creation of selfentries. If arbitrary selfentries are allowed (Interpretation 3a i n Table 2) this can, in combination with other plausible as sumptions, yield routing loops, as we will show in the next section. However, storing only optimal selfentries in rou t ing tables (Interpretation 3b) does not cause loops. For example, KernelAODV maintains the nodes’ own sequence numbers in this way. On the other hand, there are two possibilities to disallow selfentries: if a node receives a route reply and would crea te a selfentry, it silently discards the message (Interpreta tion 3c). Thisinterpretationhasthedisadvantagethatreplies are lost. The alternative is that the node forwards the message without updating its routing table (3d). Both variants by themselves do not yield routing loops. 4. Invalidating Routing Table Entries in Response to a Route Error Message. If a node receives a RERR message, it might invalidate entries of its routingtable ba sed on information from this message. When invalidating rout ing table entries, destination sequence numbers should be “copied from the incoming RERR ” [19, Sect. 6.11]. This is Interpretation 4a in Table 1. In particular, this part of the RFC prescribes the replacement of an existing destination sequence number in a routing table entry with one that may be strictly smaller, which contradicts Sect. 6.1 of the RFC. 4To make invalidation consistent with Sect. 6.1 of the RFC, one could use two possible variants instead. The ﬁrst (4b), strictly following Sect. 6.1, invalidates only if the desti na tion sequence number in the routing table is smaller than or equal to the destination sequence number provided by the incoming RERR message; it aborts otherwise. The second (4c) invalidates in all circumstances, but prevents a decre ase in the destination sequence number by taking the maximum of the stored and the incoming number.9In the next sec tion we will show that each of these three interpretations can yield routing loops, when used in conjunction with non optimal selfentries. There are two reasonable solutions to avoid routing loops in these circumstances. As a modiﬁcation of Interpretation 4c, one can ﬁrst increment the destination sequence number oftheroutingtablebyoneandthenusethemaximumofthis updated sequence number and the one from the RERR mes sage (Interpretation 4d). Alternatively, one could invali date only if the destination sequence number in the routing table is (strictly) smaller than the destination sequence number provided by the incoming RERR message (4e), and abort if it is larger or equal. The latter interpretation is at least c on sistent with Section 6.2 of the RFC, which states that“ The route is only updated if the new sequence number is either (i) higher than the destination sequence number in the route table, or [...] ”. 4. AODVYIELDS LOOPS In the previous section, we discussed some of the ambigui ties found in the speciﬁcation of AODV, and catalogued the variants of AODV that arise from interpretations consisten t with the RFC. In the following we describe an example of a routing loop in AODV, based on a reasonable and plausi ble interpretation of the RFC, following Interpretations 3 a and any out of 4a, 4b and 4c of AODV, in resolving the ambiguities from Table 1. 4.1 Creating Routing Loops The given example (shown in Figure 1) consists of four parts: (1) First, a standard RREQRREP cycle occurs (Fig ures 1(a)–(b)); (2) Then, a node stores information about itselfin its routing table (Figures 1(c)–(e)); Such informa tion is called a selfentry . (3) Another standard RREQ RREP cycle occurs (Figure 1(f)); (4) Finally, a link break in combination with another route discovery yields the loop (Figures 1(g)–(h)). 1. Standard RREQRREP Cycle. In Figure 1(a), we show the initial network topology, with the nodes’ sequence numbers depicted inside the circles. Figure 1(b) shows node Dsearching for a route to node A. We see that the sequence number for node Dis increased to 2 (“ The Originator Se quence Number in the RREQ message is the node’s own se quence number, which is incremented prior to insertion in a RREQ.” [19, Sect. 6.3]). Figure 1(b) also shows the nodes’ routing tables. Each routing table entry (depicted as a 5 tuple) contains information about the destination, the des  tination’s sequence number, the validity of the routing tab le entry, the hop count and the next hop (cf. Section 2.1). We 9Although this is not really a plausible reading of the RFC, Interpretation 4c can be seen as a compromise between Sec tions 6.11 and 6.1 of the RFC—it seems a natural way to avoid a decrement of destination sequence numbers and still take all information from the RERR message into account.do not show the sequencenumberstatusﬂag, the list of pre cursors intheroutingtableentries andthelifetime ofarou te as they constitute auxiliary information that is not critic al to the loop example here. Due to the successful exchange of RREQRREP messages, nodes DandAcreate routing table entries to each other in their routing table. 2. SelfEntries. In Figure 1(c), we see node Ssearching for aroutetonode D. InFigure1(d), thelinkbetweennodes SandDgoes up(e.g. duetonodemobility)andnode Sthen searches for a route to node X. The route request message RREQ S/shortrightarrowXis forwarded by nodes DandAsince they do not have any information on the destination node X. From the information contained in the RREQ S/shortrightarrowXmessage, a routing table entry to node Sis created in the routing tables of nodesDandA. “Then the node searches for a reverse route to the Originator IP Address [...] If need be, the route is created, or updated using the Originator Sequence Number from the RREQ in its routing table. ” [19, Sect. 6.5]. Node Salso receives the forwarded RREQ S/shortrightarrowXmessage from node D, and before silently discarding the message (since it is the originator of the RREQ message), updates its routing table to create an entry to node D. “When a node receives a RREQ, it ﬁrst creates or updates a route to the previous hop without a valid sequence number. ” [19, Sect. 6.5]. We use the value 0 for an unknown/invalid sequence number created in this manner, as is also done in implementations like AODVUU[2], AODVUIUC[15] and AODVUCSB[4]. At some point, RREQ S/shortrightarrowDﬁnally reaches node A(Fig ure 1(e)). Since node Ahas a valid routing table entry to nodeD, it generates an intermediate route reply message using the information from its routing table [19, Sect. 6.6 and 6.6.2]. The RREP S/shortrightarrowDmessage is unicast to node D, the next hop on the path towards node S. “Once created, the RREP is unicast to the next hop toward the origina tor of the RREQ, as indicated by the routing table entry for that originator. ” [19, Sect. 6.6]. Node Dprocesses the RREP S/shortrightarrowDmessage, updates its routing table and forwards the message to node S, which establishes a route to node D. When updatingits routing table, node Dcreates a selfentry (following Interpretation 3a in Table 1) since the RREP S/shortrightarrowD message contains information about a route to node D[19, Sect. 6.7]. 3. Standard RREQRREP Cycle. In Figure 1(f), the link between nodes SandXgoes up, while the link between nodesDandAgoes down. Node Dalso searches for a route to node X. Due to the successful exchange of RREQ RREP messages, the routing tables of nodes D,S, andX are updated accordingly. 4. From SelfEntries to Loops. The loop example con tinues with the link between nodes SandXgoing down (Figure 1(g)). In addition, node Ddetects that its link to nodeAis broken. Following from this, node Dinitiates pro cessing for a RERR message. “ A node initiates processing for a RERR message [...] if it detects a link break for the next hop of an active [( val)] route in its routing table while transmitting data ”[19, Sect. 6.11]. In this process,“ the node ﬁrst makes a list of unreachable destinations consisting of the unreachable neighbor and any additional destinations [... ] in the local routing table that use the unreachable neighbor as the next hop. ” [19, Sect. 6.11]. In addition, the routing table for node Dhas to be updated for these unreachable destinations as follows: “ 1. The destination sequence number of this route entry, if it exists and is valid, is incremented 5(a) The initial state. (b) Standard RREQRREP cycle; Dis looking for A; (b)A,Destablish routing table entries for each other.10 X 1 A 1D 1S 1X 1 A 1 (D,2,val,1,D)D 2(A,1,val,1,A) S 1RREPD/shortrightarrowARREQD/shortrightarrowA (c)Sbroadcasts RREQ message searching for D. (d) Topology changes; (d)Ssearchesfor X; RREQmessageﬂows throughoutthe network. X 1 A 1 (D,2,val,1,D)D 2(A,1,val,1,A) S 2 RREQS/shortrightarrowDX 1 A 1 (D,2,val,1,D) (S,3,val,2,D)D 2(A,1,val,1,A) (S,3,val,1,S) S 3(D,0,val,1,D) RREQS/shortrightarrowX RREQS/shortrightarrowXRREQS/shortrightarrowXRREQS/shortrightarrowX (e) Finally RREQ S/shortrightarrowD(initiated in Part (c)) reaches node A;(f) Topology changes; Standard RREQRREP cycle; (e)Aprocesses it and unicasts a reply back (via D); (f)Dinitiates route request searching for X. (e)NodeDestablishes selfentry. X 1 A 1 (D,2,val,1,D) (S,3,val,2,D)D 2(A,1,val,1,A) (D,2,val,2,A) (S,3,val,1,S) S 3(D,2,val,3,D) RREQS/shortrightarrowDRREPS/shortrightarrowDRREPS/shortrightarrowDX 1(D,3,val,2,S) (S,0,val,1,S) A 1 (D,2,val,1,D) (S,3,val,2,D)D 3(A,1,val,1,A) (D,2,val,2,A) (S,3,val,1,S) (X,1,val,2,S) S 3(D,3,val,1,D) (X,1,val,1,X)RREQD/shortrightarrowXRREPD/shortrightarrowXRREPD/shortrightarrowXRREQD/shortrightarrowXRREQD/shortrightarrowX (g) Topology changes; (h) Topology changes; (g)Error message is generated by D. (h)Sinitiates route request searching for D. X 1(D,3,val,2,S) (S,0,val,1,S) A 1 (D,2,val,1,D) (S,3,val,2,D)D 3(A,2,inv,1,A) (D,3,inv,2,A) (S,3,val,1,S) (X,1,val,2,S) S 3(D,3,inv,1,D) (X,1,val,1,X) RERRX 1(D,3,val,2,S) (S,4,val,1,S) A 1 (D,2,val,1,D) (S,3,val,2,D)D 3(A,2,inv,1,A) (D,3,inv,2,A) (S,3,val,1,S) (X,1,val,2,S) S 4(D,3,val,3,X) (X,1,val,1,X) RREPS/shortrightarrowDRREQS/shortrightarrowDRREQS/shortrightarrowD Figure 1: Creating routing loops 10Each routing table entry has the form ( destination ,sequence number ,validity,hop count ,next hop ). 6[...]. 2. The entry is invalidated by marking the route entry as invalid ”. [19, Sect. 6.11]. The result of this process is that the sequence numbers of routing table entries for the unreachable destination nodes AandDare increased, and the entries invalidated, as shown in the routing table of nod e Din Figure 1(g). The RERR message generated by node Dcontains infor mation about the unreachable destination nodes AandD, taken from the routing table of node D. The message is sent to node Ssince it is the precursor for the unreachable des tination node D. NodeSreceives the RERR message, and updates its routing table as follows: “ 1. The destination se quence number of this routing entry [...] is copied from the incoming RERR. [...] 2. The entry is invalidated by mark ing the route entry as invalid ”. [19, Sect. 6.11]. Therefore, the entry to node Din nodeS’s routing table is updated to (D,3,inv,1,D).11 InFigure1(h), thelinkbetweennodes SandDgoes down, while the link between nodes SandXgoes up. Node Salso searches for a route to node D. Accordingly, the destina tion sequence number in the RREQ S/shortrightarrowDmessage is set to the value 3 since“ a previously valid route to the destination [...] is marked as invalid. [...] The Destination Sequence Number ﬁeld in the RREQ message is the last known des tination sequence number for this destination and is copied from the Destination Sequence Number ﬁeld in the routing table.” [19, Sect. 6.3]. The RREQ message is received by nodeX, which generates an intermediate RREP message since“it has an active route to the destination, the destina tion sequence number in the node’s existing route table entr y for the destination is valid and greater than or equal to the Destination Sequence Number of the RREQ ”[19, Sect. 6.6]. Due to this, node Xunicasts a RREP S/shortrightarrowDmessage back to nodeS. Finally, node Sreceives this message and updates its routing table, as shown in Figure 1(h). A routing loop between nodes SandXfor destination nodeDis now established. When either of the nodes has a data packet to send to destination node D, the data packet will loop between the two nodes. In this section, we have shown that AODV is not a pri ori loop free. The presented example can create loops if (i) sequence numbers are implemented in a way consistent with the RFC, (ii) selfentries are allowed, and (iii) des tination sequence numbers are copied directly from RERR messages—even when this copying is only executed if it does not cause a decrement in the destination sequence number in the routing table. This shows that loop freedom hinges on nonevident assumptions to be made when interpreting the RFC and not only on monotonically increasing sequence numbers. 5. AODVIMPLEMENTATIONS To show that our results are not only theoretically driven, butdooccurinpractice, weanalyseﬁvediﬀerentopensource implementations of AODV: •AODVUU [2] is an implementation of AODV, developed at Uppsala University. http://aodvuu.sourceforge.net/ •KernelAODV [1]isanimplementationdevelopedatNIST. http://w3.antd.nist.gov/wctg/aodv_kernel/ 11Each of the Interpretations 4a, 4b and 4c in Table 1 will produce the same update in this scenario.•AODVUIUC [15](Univ.ofIllinoisatUrbanaChampaign) is an implementation that is based on an early draft (ver sion 10) of AODV. http://sourceforge.net/projects/aslib/ •AODVUCSB [4] (Univ. of California, Santa Barbara) is another implementation that is based on an early draft (version 6) of AODV. http://moment.cs.ucsb.edu/ AODV/aodvucsb0.1b.tar.gz •AODVns2 is an AODV implementation in the ns2 net worksimulator, originallydevelopedbytheCMUMonarch project andimproveduponlater byS.DasandE. Belding Royer (the authors of the AODVRFC [19]). It is based on an early draft (version 8) of AODV. It is frequently used by academic and industry researchers to simulate AODV. http://ns2.sourcearchive.com/documentation/ 2.35~RC41/aodv_8ccsource.html Although these implementation behave diﬀerently, all of themdocapture the main aspects of the AODV protocol, as speciﬁed in the RFC [19]. As we have shown in the pre vious sections, implementing the AODV protocol based on the RFC speciﬁcation does not necessarily guarantee loop freedom: routing loops may occur when following either In terpretation 1a, Interpretation 2b or the combination of In  terpretation 3a with any of 4a–c of Table 1. Therefore, we look at these ﬁve concrete AODV implementations to de termine whether any of them is susceptible to routing loops. In particular, we examine the code of these implementations to see if routing loops can occur. Table 2 shows the results of this analysis: it indicates for each of the implementa tions which of the interpretations of Table 1 they follow and whether they can create routing loops or not. We found that none of the ﬁveimplementations makes use of the sequencenumberstatus ﬂag, so a positive sequence number can never be marked as unknown. As a result, Am biguity 1 of Table 1 does not arise. In AODVUU, selfentries are never created because a check is always performed on an incoming RREP message to make sure that the destination IP address is not the same as the node’s own IP address. In terms of Table 1 it follows Interpretations 2c, 3c and 4a. It is shown in [8] that this interpretation of the RFC (avoiding selfentries) is loop f ree. InKernelAODV,whichfollows Interpretations2a, 3band 4a of Table 1, an optimal selfentry (with hop count 0 and next hop being the node itself) is always maintained by ev ery node in the network. The optimal selfentry is created during node initialisation. The node also maintains its own sequence number in this entry. Since the selfentry is al ready optimal, a node will never update the selfentry when processing any incoming RREP messages that contain infor mation about itself. As such, a routing loop as described by the example in Section 4.1 will never occur. AODVUIUC follows the Interpretations 2b, 3a and 4a, whereas AODVUCSBimplements2b, 3aand4b. DuetoIn terpretation 3a, both implementations allow the occurrenc e of selfentries. These selfentries are not created during node initialisation, but generated based on information contai ned in received RREP messages. The processing of RERR messages in AODVUIUC and AODVUCSB does not adhere to the RFC speciﬁcation (or even the draft versions that these implementation are based upon). Due to this nonadherence, we are unable to re create the routing loop example in Section 4.1. However, we note that if both AODVUIUC and AODVUCSB were 7Table 2: Analysis of AODV implementations Implementation Interpretation Analysis AODVUU [2] 2c, 3c, 4a Loop free, since selfentries are explicitly excluded. KernelAODV [1] 2a, 3b, 4a Loop free, due to optimal selfentries. AODVUIUC [15] 2b, 3a, 4a Yields loops, through decrement of sequence numbers, by use of Interpretation 2b. AODVUCSB [4] 2b, 3a, 4b Yields loops, through decrement of sequence numbers, by use of Interpretation 2b. AODVns2 2a, 3a, 4bYields routing loops in the way described in Section 4, following plausible interpretations of the RFC w.r.t. Ambi guities 3 and 4. to strictly follow the RFC speciﬁcation with respect to the RERR processing, loops would have been created. Eventhoughtheroutingloop example ofSection4.1 could not be recreated, both implementations allow a decrease of destination sequence numbers in routing table entries to oc  cur, as a result of following Interpretation 2b. This con tradicts the idea of monotonically increasing destination se quence numbers, and can give rise to routing loops in a straightforward way [8, Sect. 8.1]. In AODVns2, selfentries are allowed to occur in nodes and the processing of RERRmessages follows the RFCspec iﬁcation. It follows Interpretations 2a, 3a and 4b. However in AODVns2, whenever a node generates a RREQ message, sequence numbers are incremented by two instead of by one as speciﬁed in the RFC. We have modiﬁed the code such that sequence numbers are incremented by one whenever a node generates a RREQ message, and are able to replicate the routing loop example of Section 4.1 in the ns2 simula tor, with the results showing the existence of a routing loop between node Sand node Xin Figure 1(h). However, we note that even if the code remains unchanged and sequence numbers are incremented by two, AODVns2 can still yield loops; the example is very similar to the one presented and only varies in subtle details. In sum, we discovered not only that three out of ﬁve AODV implementations can produce routing loops, but also that there are essential diﬀerences in various aspects of pr o tocol behaviour. This is due to diﬀerent interpretations of the RFC by the developers of the AODV implementations. 6. METHODOLOGY "
203,Investigating Quality Routing Link Metrics in Wireless Multi-hop Networks.txt,"In this paper, we propose a new Quality Link Metric (QLM), ``Inverse Expected
Transmission Count (InvETX)'' in Optimized Link State Routing (OLSR) protocol.
Then we compare performance of three existing QLMs which are based on loss
probability measurements; Expected Transmission Count (ETX), Minimum Delay
(MD), Minimum Loss (ML) in Static Wireless Multi-hop Networks (SWMhNs). A novel
contribution of this paper is enhancement in conventional OLSR to achieve high
efficiency in terms of optimized routing load and routing latency. For this
purpose, first we present a mathematical framework, and then to validate this
frame work, we select three performance parameters to simulate default and
enhanced versions of OLSR. Three chosen performance parameters are; throughput,
Normalized Routing Load and End-to-End Delay. From simulation results, we
conclude that adjusting the frequencies of topological information exchange
results in high efficiency.","Communication at any time without any disruption for mobile users is pr o vided by Wireless Multihop Networks (WMhNs). These networks hav e some distinguished features due to dynamic topologies; various number o f nodes, communication demand at random times, in random directions and for diﬀer ent sessions. Underlying network demands a routing protocol to d ynamically cope with changing topologies. Mobile nodes in WMhNs are very often lim ited in resources such as processing capabilities, storage capacity, ba ttery power, bandwidth etc. This implies that the routing protocol must be able to mini mize the control traﬃc, (as trigger/periodic update messages), delays (due to retransmissions, or computation of metrics), and so on. The perf ormance of a wireless network depends upon eﬃciency of the routing protocol o perating it. The mostimportant componentofthe routingprotocolis‘routinglin k metric’. Because, a link metric ﬁrst considers the quality routes then decide s the best endtoend path. A Quality Link Metric (QLM) plays a key role to achie ve the desired performance from an underlying network by making the routing protocol: fast enough to adopt topological changes, lightweight to minimally use the resources of nodes, intelligent to select the fastest path from source to destination among available paths and capable to enable the nodes to have a comprehensive idea about the topology. Consideringdemandsofthe underlyingnetworkfromitsoperatingp rotocol and factors inﬂuencing its performance, a QLM is supposed to fulﬁll certain requirements. An eﬃciently designed QLM better helps a routing pro tocol to achieve appreciable performance by dealing with these issues. In ou r previ ous work [1], design requirements of QLM are discussed in detail. More over, a new QLM; InvETX, is also compared with Expected Transmission Cou nt (ETX) [2], Minimum Loss (ML) and Minimum Delay (MD) [4] in Optimized Link State Routing (OLSR) [5] protocol. As, we discuss earlier that a routing protocol and link metric collectively are responsible for eﬃcient perf ormance, therefore, we address improvement in routing protocols as well. Fo r this pur pose, in this paper, we enhance OLSR to reduce routing overhead. To validate our enhancements, we evaluate and compare the performance of selected met rics in default and enhanced OLSR. Among a wide range of reactive and proactive protocols, we have se lected the proactive class, because: (i). proactive routing protocols ar e designed for static networks, so, they perform excellent in such networks [6]. W e therefore, have chosen a proactive protocol, (ii). OLSR is designed for static a nd dense networks [7], (iii). in [8], we have carried out almost the same study in th e same scenario with DestinationSequenced Distance Vector (DSDV ) [9]. So, to provide the readers with another proactive protocol, we have cho sen OLSR.Investigating Quality Routing Link Metrics in Wireless Mul tihop Networks 3 2 Related Work and Motivation "
51,Geographic Centroid Routing for Vehicular Networks.txt,"A number of geolocation-based Delay Tolerant Networking (DTN) routing
protocols have been shown to perform well in selected simulation and mobility
scenarios. However, the suitability of these mechanisms for vehicular networks
utilizing widely-available inexpensive Global Positioning System (GPS) hardware
has not been evaluated. We propose a novel geolocation-based routing primitive
(Centroid Routing) that is resilient to the measurement errors commonly present
in low-cost GPS devices. Using this notion of Centroids, we construct two novel
routing protocols and evaluate their performance with respect to positional
errors as well as traditional DTN routing metrics. We show that they outperform
existing approaches by a significant margin.","Research published by the Delay and DisruptionTolerant Networking (DTN) community over the last decade shows sig niﬁcant beneﬁts to incorporating geolocation information into routing algorithms. This is unsurprising, given that DTN rout ing protocols are required to make local forwarding decisions, without the beneﬁt of consistent global routing information. Much of this work is evaluated only in simulation and emulation environments (and we include our own prior work in making this generalization [1]), in which the positional measurements are assumed to be highly accurate. In practice, vehicular communication modules are often (and perhaps increasingly so) constructed from very inexpensive hardware without highquality antennas or complex GPS chipsets, and expected to function in urban canyons or other environments with partially obstructed GPS signals. Under such conditions, the advertised 20 m civilian GPS accuracy bounds quickly decay to nearly 200 m, with the more eccentric error typically occurring orthogonally to the direction of travel, without resembling a normal error distribution [2]. The implication for the consumer of such position data is that the location delta between updates due to error may be an order of magnitude larger than the actual distance travelled in the same time. Simply taking additional samples cannot resolve this error due to the high correlation between consecutive GPS location readings. This explains the alltoocommon scenario of “my GPS thinks I’m driv ing in a ﬁeld/lake/building/offramp/etc”. Commercial GPS based mapping devices are relatively successful at hiding such inaccuracies by taking hints from the map database and making sophisticated assumptions (learned through decades of development on this single application), such as smoothed This paper is authored by employees of the United States Government and is in the public domain. Nonexclusive copying or redistribution is allowed, provided that the article citation is given and the authors and agency are clearly identiﬁed as its source. Approved for public release: distribution unlimited.travel trajectories and snapping the position to nearby roads. However, when these assumptions are wrong, even greater errors may be introduced so we must ﬁnd other mechanisms for mitigating the underlying errors in positional data. Please note that we don’t mean to imply that advances in technology won’t decrease these errors; technology trickledown, availabil ity of Global Navigation Satellite System (GLONASS), and planned improvements in future GPS satellites will all have that effect in the coming decades, however the current general assumption of zero error will continue to be unwarranted for the foreseeable future. Our contributions in this work include a novel routing primitive and two novel routing protocols based on this prim itive. We also perform an analysis of the effects of errors in positional data on our two protocols and an existing protocol. Lastly, we contribute an oracle router for the ONE simulator. Code for all routers is made available via the Tactical Net worked Communication Architecture Design lab website [ ?]. The structure of this paper is as follows: Section II dis cusses the prior work in DTN routing protocols that we build upon in this work. Section III presents our new routing prim itive, and two DTN routing protocols based on that primitive. Section IV evaluates the protocols via the ONE Simulator. Section V concludes. II. R ELATED WORK "
49,Bottom-up mechanism and improved contract net protocol for the dynamic task planning of heterogeneous Earth observation resources.txt,"Earth observation resources are becoming increasingly indispensable in
disaster relief, damage assessment and related domains. Many unpredicted
factors, such as the change of observation task requirements, to the occurring
of bad weather and resource failures, may cause the scheduled observation
scheme to become infeasible. Therefore, it is crucial to be able to promptly
and maybe frequently develop high-quality replanned observation schemes that
minimize the effects on the scheduled tasks. A bottom-up distributed
coordinated framework together with an improved contract net are proposed to
facilitate the dynamic task replanning for heterogeneous Earth observation
resources. This hierarchical framework consists of three levels, namely,
neighboring resource coordination, single planning center coordination, and
multiple planning center coordination. Observation tasks affected by
unpredicted factors are assigned and treated along with a bottom-up route from
resources to planning centers. This bottom-up distributed coordinated framework
transfers part of the computing load to various nodes of the observation
systems to allocate tasks more efficiently and robustly. To support the prompt
assignment of large-scale tasks to proper Earth observation resources in
dynamic environments, we propose a multiround combinatorial allocation (MCA)
method. Moreover, a new float interval-based local search algorithm is proposed
to obtain the promising planning scheme more quickly. The experiments
demonstrate that the MCA method can achieve a better task completion rate for
large-scale tasks with satisfactory time efficiency. It also demonstrates that
this method can help to efficiently obtain replanning schemes based on original
scheme in dynamic environments.","ARTH  observation  plays a vital role in many fields such  as environment monitoring, disaster relief and urban  analysis  [1]. Earth observation  resources are highly diversified ,  including satellites, unmanned aerial vehicles  (UA Vs ), and  airships . These resources have attracted an increasing attention  of international organizations. For example, the U.S. Air Force  Research Laboratory (AFRL) proposed the TechSat 21  program to verify the capability of coordinated work with  multiple satellites  [2, 3]. China also planned a program to  achieve high quality Earth observation  capabilities  [4]. A high  resolution Earth observation  system is being built, including  space based , near space based and air based  observation  platforms . Observation resources are becoming smaller and     This work was supported by the National Key Research and Development  Program of China (No. 2016YFB0502600), Natural Science Fund for  Distinguished  Young Scholars of Hunan Province  under Grant (No.  2019JJ20026 ), and the Fundamental Research Funds for the Central  Universities of Central South University (No. 2018zzts198).  (Guohua Wu  is  the c orresponding author .)   Baoju Liu, Min Deng, Xinyu Pei and Haifeng Li are  with the School of  Geosciences and Info Physics, Central South University, Changsha, 410000, more intelligent. Moreover,  the development trend for Earth  observation systems  is to realize the  coordinated usage of  heterogeneous observation resource s [5, 6].  The coordinated  planning of heterogeneous observation  resources is a hotspot in the field of Earth observation .  Different observation tasks  have  different observation  requirements in terms of resolution, time window, and sensing  band.  Earth obser vation  users  are in pursuit of more accurate  services  [7]. It is difficult for a single type of resource to meet  the diversified  requirements of various observation tasks.  To  this end, c oordinated planning can take full advantage of  various observation res ources , and  it can accomplish tasks that  cannot be completed by a single type of resource.   It is necessary to perform task planning for observation   resources dynamically. In general, observation environment   involves considerable uncertainties  in task execu tion process ,  such as signal anomalies, intense winds , thick clouds , and road  congestion.  In addition, the task requirement s of observation  targets , such as position and  observation time,  may change  over time.  Once an exception occurs, it needs to dynamica lly  and promptly reformulate  a reasonable  observation scheme in  accordance with  current situation and original observation  scheme.    It is difficult to re formulate  a reasonable observation  scheme efficiently  in dynamically changing environment s [8,  9]. With the current centralized  planning strategy, the  comput ing load of coordination mediator  is too heavy, which  may lead to the collapse of whole  observation system if it fails.   Moreover, the quality, timeliness of replanning  scheme and the  difference with original observation scheme are all factors that  must be considered when reformulating  observation scheme.   The objective of coordinated  task planning is to maximize  the  observation benefits of all resources while timely adjust the   observation scheme  if unpred ictable disturbances occur  [10].  The task planning has been extensively studied for each  kind of observation resources . In the context of  satellite   scheduling , previous studies  mainly  focused on modeling   techniques  and solving algorithms. Many optimization  models  were extended and improved for satellite  scheduling , such as   task clustering [1 1], scene selection [1 2], knapsack problem  optimization [ 13], and workshop scheduling [ 14]. Furthermore,   different kinds of algorithms, including exact  algorithm [11],  heuristic  algorithm  [15] and metaheuristic  algorithm [16, 17],  have been used  to solve this problem . For the  task planning of   airbased observation resources, many scholars studied the  China  (email: baojuliu@csu.edu.cn ; dengmin@csu.edu.cn ;  175011022@csu.edu.com ; lihaifeng@csu.edu.cn ).   Guohua Wu is with the School of Traffic and Transportation Engineering ,  Central South University, Changsha, 410000, China  (email:  guohuawu@csu.edu.cn ).  Witold  Pedrycz  is with the Department of Electrical & Computer  Engineering,  University of Alberta, Edmonton, AB T6R 2V4 Canada (e mail:   wpedrycz@ualberta.ca ).  E    coordinated scheduling  of multi UA V .  The task planning  problem of multi UA V s is essentially a task assignment   problem with complicated constraints [ 18], which has  usually   been  solved by  optimization methods including  mathematical  programming  [19], intelligent optimization [ 20, 18] and  hierarchical decomposition [ 21].   It can b e found that most  task planning methods  are  oriented to  a single type of resource and static environment s,  and under  a centralized framework.  For the coordinated task  planning of multi ple types  of observation resources, several  scholars  also have proposed coordinated planning framework s  for heterogeneous resources  [22, 23 ]. In addition, heuristic  criteria  [24, 25 ] and game theory [26] have been proposed to  solve the coordinated planning problem of heterogeneous  resource s in a static environment. Although several  researchers  have studied the dynamic task planning problems of UA Vs [ 27,  28], satellites [9] and other resources [8], the dynamic task  planning of heterogeneous resources is still an unresolved  problem to the best of our knowledge.   Existing studies proposed some coordinated planning   frameworks and optimization  algorithms in static environment.   These coordinated planning  frameworks first perform the task  assignment process among planning centers. Then, the  planning centers develop observation schemes  for their  resources.  This top down task planning process fails to  take  advantage of the distributed computing ability of different   nodes  of the observation systems . Moreover, the requirement s  for rapid  replanning  due to  unexpected disturbances are  ignored , which makes previous task planning methods  inapplicable to  actual observation scenarios . It is necessary to  make the task planning of  Earth observation  resources adapt to   the case of large scale tasks in dynamic environments. In  addition,  it is needed to r eplace the centralized observation task  allocation mode with a distributed task allocation mode, to  increase the robustness and adaptation capability of the entire  observation systems. This study analyzes and explores the task  planning problems of heteroge neous Earth observation   resource s in dynamic and uncertain environments.   In this paper, a bottom up distributed coordinated  framework  is proposed to realize the dynamic  task planning of  Earth observation  resources. In contrast  to the  traditional top  down t ask assignment process, under this framework , once  unpredictable disturbances occur, affected tasks are first tried  to be replanned through the coordination among  neighboring  observation resources  of the resource that is originally  supposed to execute the task. Next,  if the coordinated task  replanning  on the neighboring resource level fail s, tasks are  transferred to planning center , which then are tackled on the  planning center level . In this manner , the tasks can be  replanned more promptly in a dynamic env ironment.   In addition, a multiround  combinatorial allocation (M CA)  method is proposed to achieve rapid replanning of a large  number of tasks. We integrate a contract net into the  coordinated  task planning process.  With the MCA  method,  tender information is published by the resource s that cannot  perform tasks because of unpredictable disturbances.  Multiple  tasks can be combined and allocated to observation resources  in one bidding process , which significantly improve the task  allocation efficiency. Besides,  a threeround task allocation  process  is designed to improve the task completion rate of  allocation scheme s. We further design a local search algorithm  to select winning bidder  in task allocation process . The  experiment al results demonstrate  that the MCA method can  deal with large scale  concurrent observation tasks dynamically  and efficiently.   Our contribution made through this paper is threefold.   1) For the first time, we design a bottom up distributed  framework for the task replanning of  heterogonous Earth  observation  resources. This approach  is more consistent with  dynamic and uncertain characteristics of the Earth observation  environments .   2) We propose a dynamic environment oriented  multiround  combinatorial allocation ( MCA ) method  to solve  the large scale task replanning  problem rapidly . This method  allocates tasks  in a level  by level  manner  based on the bottom  up distributed coordinated  framework. In addition, task  allocation process is  combined with contract net. The  experiments show that this method  can significantly improve  the efficiency and stability of task replanning .   3) We propose a local search algorithm to  select winn ing  bidder among  observation  resources  and planning center s. This  algorithm uses a probability parameter and a floating price  interval  mechanism to enhance the diversity of solutions  and  considerably  improve s the accuracy of  solutions.  At the same  time,  priority strateg y is used to improve the convergence  speed of the best solution.    The paper is organized as follows. In Section II, we  review  relevant work s. In Section III, the  coordinated  task  planning  problem of Earth observation  under dynamic  environment s is elaborated , and a bottom up distributed  coordinated  framework is proposed . In Section IV, a  multiround  combinatorial allocation method with a solution  algorithm is proposed to  assign dynamic  tasks. Section V  presents and discusses  experimental results. Section VI  concludes this paper and presents directions for future work.   II. RELATED WORK   "
456,Learning to Route with Sparse Trajectory Sets---Extended Version.txt,"Motivated by the increasing availability of vehicle trajectory data, we
propose learn-to-route, a comprehensive trajectory-based routing solution.
Specifically, we first construct a graph-like structure from trajectories as
the routing infrastructure. Second, we enable trajectory-based routing given an
arbitrary (source, destination) pair.
  In the first step, given a road network and a collection of trajectories, we
propose a trajectory-based clustering method that identifies regions in a road
network. If a pair of regions are connected by trajectories, we maintain the
paths used by these trajectories and learn a routing preference for travel
between the regions. As trajectories are skewed and sparse, many region pairs
are not connected by trajectories. We thus transfer routing preferences from
region pairs with sufficient trajectories to such region pairs and then use the
transferred preferences to identify paths between the regions. In the second
step, we exploit the above graph-like structure to achieve a comprehensive
trajectory-based routing solution. Empirical studies with two substantial
trajectory data sets offer insight into the proposed solution, indicating that
it is practical. A comparison with a leading routing service offers evidence
that the paper's proposal is able to enhance routing quality.
  This is an extended version of ""Learning to Route with Sparse Trajectory
Sets"" [1], to appear in IEEE ICDE 2018.","Vehicular transportation is an important aspect of the dail y lives of many people and is essential to many businesses as well as society as a whole [2], [3]. As a part of the continued digitization of societal processes, more and mor e data is becoming available in the form of trajectories that capture the movements of vehicles [4], [5]. This data offers a foundation for improving vehicular transportation, incl uding vehicle routing. Traditional routing is costcentric and aims at returning paths with minimal costs, e.g., distance, travel time, or fu el consumption. The cost of a path is computed from edge costs inedgebased cost modeling [6]–[11] or subpath costs in pathbased cost modeling [12]–[15]. In such routing, trajectory data is often used for annotating the edges or subpaths with travel costs such as travel times; and routing services empl oy shortest path algorithms, e.g., Dijkstra’s algorithm or co ntrac tion hierarchies [16], to return fastest, or simply shortes t, paths. However, an existing study [17] suggests that local drivers who drive passenger vehicles follow paths that differ substant ially from the paths computed using costcentric routing and are often neither fastest nor shortest. Our paper also focuses o n trajectory data that was generated from passenger vehicles .We study a very different routing approach that relies on the availability of trajectories from local drivers. Assuming that local drivers implicitly take into account a multitude of fa ctors, such as trafﬁc conditions, turns, travel time, fuel consump tion, road types, and trafﬁc lights, when making routing decision s and thus know best which paths are preferable, we propose a methodology that utilizes paths found in historical trajec tories to construct new paths between arbitrary (source, destination ) pairs. We call this trajectorybased routing. If historical trajectories show that many drivers travelin g from a source sto a destination dfollow a particular path, it is straightforward to recommend that path to drivers asking for directions from stod. The big challenge now is how to beneﬁt from historical trajectories when no historical trajector ies capture paths from stod. This is important because any set of historical trajectories is sparse in the sense that it is unlikely to provide paths for all s’s andd’s. For example, the road network of Denmark, a small country, contains some 1.6 million edges . Thus, if all edges are candidate s’s andd’s, a minimum of 2.6 trillion(s,d)pairs are needed. Given that the distribution of trajectories in a road network is skewed, an enormous set of trajectories (e.g., trillions for Denmark and quadrillion s for Germany) would be needed before routing could be done by simply looking up paths of past trajectories for any (s,d)pair. Figure 1 exempliﬁes the problem setting. The solid edges and ﬁlled vertices are covered by a set of ﬁve trajectories, while the dashed edges and unﬁlled vertices are not covered by any trajectories. For example, trajectory T1visitedAand thenJ,X,Y, andB3before reaching B. If routing from A toBis requested, the path A→J→X→Y→B3→B, as captured by trajectory T1, can be recommended directly. The challenge is to enable routing for (s,d)pairs that are not connected by trajectories, e.g., (A1,B2)and(H,F). To enable trajectorybased routing with massive, but still sparse, sets of historical trajectories, we propose means t hat are able to generalize the cases where historical trajector ies can be utilized for routing. This includes three steps. In the ﬁrst step, we cluster vertices into regions and thus map a roa d network graph into a region graph . Trajectories that originally connect vertices in the road network graph now connect regions in the region graph. This arrangement generalizes t he cases where trajectories can be used for routing from being between speciﬁc vertex pairs to being between region pairs. As regions include multiple vertices, this arrangement contr ibutes to solving the data sparseness problem.AB CD EFA1 A2B1 B2 G HXY Z Visited Vertex  Unvisited Vertex  Visited Edge  Unvisited Edge  Trajectories: T 1=<A, J, X, Y, B 3, B>   T 2=<D, X, Z, C>    T3=<E, Z, F 2, F>   T 4=<G, H>   T 5=<D, K, Y, F 1, F>Iregion R 1region R 2 B3 region R 4 region R 3F1F2JKN M Fig. 1: Motivating Example For example, in Figure 1, AandJare clustered into region R1, andB3andBare clustered into region R2. Now, although no trajectories connect A1andB2,T1connects regions R1and R2that are close to A1andB2. Thus, the path of T1can be used for recommending a path from A1toB2. For instance, a user may go from A1toA, then follow the path used by T1 to reachB, and then go to B2. This enables trajectorybased routing between regions connected by trajectories. Howeve r, in the region graph, some region pairs are still not connecte d by any trajectories, e.g., regions R3andR4in Figure 1. In the second step, we learn routing preferences from available historical trajectories that connect some regio n pairs and then transfer these preferences to similar region pairs that are not connected by trajectories. Based on the transferred preferences, we identify paths for the noncovered region p airs. Note that the routing preferences are learned for different region pairs, not for different individual drivers. Assume that (R1,R2)is similar to (R3,R4), e.g., because both are from a residential area to a business district. Next, we extract a routing preference from the trajectories connecting R1andR2 that explains the choice of paths from R1toR2. We transfer this routing preference to driving from R3toR4and then identify paths connecting R3andR4, upon which trajectory based routing from HtoFis possible. In the third step, we provide a uniﬁed routing solution, called learntoroute (L2R) , which performs path ﬁnding on the region graph, thus enabling routing between arbitrary (s,d) pairs in the original road network graph. To the best of our knowledge, this is the ﬁrst solution that learns routing preferences from historical trajector ies and transfers the learned preferences to the part of a road netwo rk that is not covered by trajectories, thus supporting compre hen sive trajectorybased routing for arbitrary (s,d)pairs. The paper makes four contributions. First, it presents a trajectorybased road network clustering algorithm that p ro duces the data foundation—the region graph. Second, it presents a general routing preference model, including an algorithm that extracts preferences from historical traje ctories and an algorithm that transfers preference to similar regio npairs. Third, it presents a uniﬁed routing algorithm for the region graph. Fourth, it reports on an empirical evaluation that offers insight into the proposed solution, indicating that it is capable of efﬁciently computing paths that match those of local drivers better than do traditional routing services. Paper Outline: Section 2 covers related work. Section 3 covers preliminaries. Section 4 presents Step 1, region gra ph generation. Section 5 presents Step 2, preference learning and transfer. Section 6 presents Step 3, uniﬁed routing. Sectio n 7 reports on empirical evaluations. Section 8 concludes. II. R ELATED WORK "
40,Evaluation and Performance of Reactive Protocols Using Mobility Model.txt,"A Mobile Ad-hoc Network (MANET) is a self-motivated wireless network which
has no centralized point. It is an independent network that is connected by
wireless link so, in which every point or device work as a router. In this
network every node forward the packets to the destination as a router and it's
not operating as an ending point. In this network every node adjusts them self
by on his way in any direction because they are independent and change their
position regularly. There are exist three main types of routing protocols which
are reactive, proactive and final is hybrid protocols. This whole work compares
the performance of some reactive protocols which also known as on - demand
protocols, which are DSR, AODV and the final is AOMDV. DSR and AODV are
reactive protocols which connected the devices on the network when needed by a
doorway. The AOMDV protocol was designed for ad hoc networks whenever any route
or link fail and also maintain routes with sequence numbers to avoid looping.","A mobile ad hoc network (MANET) is a grouping of  digital nodes that can co mmunicate with each other  through wireless transceiver and without using a central  point, equipped with wireless transceivers that can  communicate with one another node or host without using  any fixed networking or central infrastructure [1]. The data  packets are sent over wireless Communication control to  make communication. A point which makes a big  difference and also advant age from other local area  networks is that they have no centralized point or base station. Whereas, in cellular networks the communication  from a mobile terminal is done by a centralized point and  in these networks the mobile terminals make  communications directly with each other in the radio     transmission range. For transm ission to a node that is  found out of range of radio transmission, work on the  principle of stored and fo rward mechanism, so these  networks also called multi hopes wireless networks  because they use multi hop to send data in the networks.  With some amount of overhead and bandwidth use, the  route creation and repairing is done under some conditions  in the networks [2].  The process of finding a route and  also repairing it is a main working point in dynamic source  routing protocol [3]. The process of finding a complete  route to target node and also acknowledgements from a  destination in the networks make successful route between  sources to destination [4].     1.1  Open issues in MANET’s    There are still many problems exist in mobile ad hoc  networks. As in this routing environment the efficient  routing is affected by mobility of network under security  and time because all nodes in the networks act like a router  and work on the principle of store and forward the packets  from other nodes in the networks. There is another issue  exist in these networks is the consumption of energy  because every node which lies in the networks not only  send the data but also send data from other nodes.    1.2  ‘MANET’ Networking   Wireless communication is an advance technology in these  days and becoming more popular than before and this type   of technology exists between wireless communications  devices such as laptop computers and mobile nodes in a  limited range of networks. There are two main advantages  of this technology is that prices are low and data rates are  much higher which make this type of technology more  interesting and also a reason of growth of this technology.  In wireless communication, there are exit two types of  approach which makes communication between any nodes  which allow existing networks to carry voice and also the  data. In wireless ad hoc networks a grouping of nodes  work on the principle that there is no centralized  communication or there is no central supervision in the  networks [2]. This type of networks has many importance  in a large number of applications such as personal digital  assistant networks, in military application such as tanks,  planes and the aircrafts etc. and also in civil application  and emergency operations    1.3  APPLICABILITY OF MANET’S      We can apply mobile ad hoc network technology in two  different areas which are here:  When a new mobile node is added in wired and wireless  networks then this technology is used. For example  customers in a city who can communicate each other for  obtaining rates information’s and also a student and  employers in universities and company and many other  ways exist.   Another area where mobile ad hoc technology is used,  where a communication network wanted but due to some  reasons it does not exist such as the whole network  destroyed due to wars and disasters and some other  problems. This technology is used in different field such as  in military, police, hospitals and also rescue operation and  many other areas. This technology also reduces the cost of  networks.     2.  Background    2.1  MANET Routing Protocols      There are three main types of adhoc routing protocols,  which explain as here.                                       Fig. 1: Mobile adhoc routing protocols    2.1.1  Proactive Protocols  The proactive protocols which are also known as table  driven protocols work on the bases of fixed mechanism  and also used shortest path. In proactive protocol networks,  every node lies in the network maintain a routing table  which contains all routes to destinations in all over the  networks [5, 6]. For updating the table of networks it  needs to update the table by sending updating messages to  all nodes which lie in the networks. It means the table  refresh after a few moments. As, by using routing table  which has all routing paths of networks in the table which  results consumption of bandwidth and these also have  routing overhead which also  decrease the bandwidth of  networks. So these protocols have a disadvantage which is  that bandwidth consumption of networks. There is also an  advantage of proactive protocols is that there is always , a  route to destination availability of networks. So as a result  the delay is very small in the networks.     2.1.2  Reactive Protocols  As, the reactive protocols which are also called on demand  protocols whenever, they want to send packet to the  destination first they send a request in the whole networks  [7]. The characteristics of thes e protocols are that they find  path on demand and exchange information in networks  when they required and every route request has replying.   As the route finds to destination on demand so the  advantage is that overhead is small which result in low  bandwidth use in the networks. There is also a  disadvantage of this technique is that when it send a route  request in the networks which produce a big delay.    2.1.3  Hybrid Protocols  The hybrid ones are adaptive, and also the combination of  two protocols which are reactive and proactive protocols.  Reactive protocols are not sensitive to delay and work for  network with any movement. While, proactive protocols  came with a small delay. From many research it is found  that there are still no best routing protocols for all kinds of  Mobile ad hoc networks. There are all routing protocols  have its own different adva ntages and capabilities to do  work but some specific environments which create a  problem because all nodes of networks should be able to  work in every environment of the network not for specific.  So there are lots of challenges occurs that how can get  high performance in every environment. In present many  researchers have proposed many hybrid protocols like ZRP,  ZHLS and CEDAR etc. [8].   As, I am working on reactive protocols, first one  is  Adhoc on demand vector, and 2nd is Ad hoc on demand multipath distance vector routing protocols and  3rd is Distance routing protocols which are studied here.    2.2   (AODV) Adhoc on demand distance vector:  This protocol is a type of reactive routing protocol which  work on demand. It is a Single Scope protocol and the  working of this protocol is based on Destination Sequenced DistanceVector ( DSDV). The improvement  has been done by minimizing the number of source  requests which are used to create a route in the networks.  Minimizing the number of broa dcasts required to create  routes in the network. As this is a reactive protocol so that  those nodes which are not used in required path they don’t participate and also don’t maintain route in the network  because there are no need of their participation. When a  source node or any device want to transmit or send two  packets to destination, first it broadcasts a route request in  the whole networks then this request goes to its neighbor  nodes and same way it moves by different intermediary  node to the required destination in networks. As the result  every node reply come and then desired path is selected.  This process is known as a pa th discovery process. (Figure  2(a)). It uses sequence number s to prevent loop just like  DSDV.                           Figure 2(a) (AODV): How to  create a route request  [RREQ]    Each node in the network has two information’s, the first  information is sequence numbers which prevent from  looping and the second is broadcast id which increases a  broadcast from starting node. The RREQ which is send by  source has the following information’s which are Source  address of sender, Source sequence number, Broadcast id,  Destination address, Destina tion sequence number, and the  number of nodes to the destination. The neighbor’s nodes  only reply to request only if neighbor’s nodes have a way  to required destination in the networks with sequence  numbers. When a request is sent to the destination, then all  the intermediary nodes in the network add the address of  its neighbor nodes in the ro uting table (Figure 2 (b)). If  they have equal path then those requests which received  later from other neighbors in the network are deleted.                                     Figure 2(b): Reply path to source    When a source sends request to the destination then all  nodes which come between the source and destination,  they send a reply to that nod e from which request come.  By this process all midway nodes send a reply to its  neighbor from which request come and then final it  reached for the source. A r oute reply that comes from  midway nodes have the following information’s which are  seq no. of the target node, total nodes that come between  source to destination, Source ad dress, Target node address,  Number of Hops to the des tination, Sequence number of  the destination and  time of expiration for the Reverse Path  (Figure 2.8). To establish a link between source and target  node, every node which lies between them send a route  reply to that node from which request come to establish a  path. Therefore this reactive protocol has a bidirectional  link which have a path for request send and also route    reply. If a broadcast node is missing due to some reasons  in the network then route request send again in the  networks to maintain the path between source and  destination.    Advantages  • As there is no updating after some time in the routing  table so, in AODV the overload is small in term of packet  that’s why it is called reactive or on demand protocol. The  calculation of this protocol is small because it uses simple  messages.   • The purpose of this reactive protocol to pr ovide shortest  and fresh path.     Disadvantages    • As this reactive protocol establish a path between those  nodes who want to establish a path for communication. As  this protocol also works on the basis of bidirectional  dealing and also uses the route request for sending packets  to target node so the disadvantage is that the routing  overhead is higher than Dynamic Source Routing protocol.    2.3  THE DYNAMIC SOURCE ROUTING (DSR):    This is another type of r eactive routing protocols which  using a technique known as source routing. The source  nodes that want to send packet to targeted node first find  the path of a packet in the ne twork. A packet header has all  information’s of path from source to destination and also  which is going to send packet must determine the path of  the packet. The path is attach ed in the packet header and  all information’s that are stored in hopes allow for  changing with respect to tim e. When a source node wants  to establish a path to another node, it first finds the way to  that node on the basis of stor ed information because there  are no updating information’s.     Basic Route Discovery:    When a node wants to send a packet to a targeted node it  first looks in the route cache which has a previously  discovered path. When there are no exist a path in its route  cache then the node starts a process for finding the route  by sending a route request packet. This packet has the  following information’s which are, the address of source  no which want to send packets and targeted node address  and also have a request id. When a node in the network  received a route request it firs t goes into cache to find  targets. If there are no exit r oute from source to target node  then this node adds in the r oute record its address in the  route request in the network with the same request id. In Figure 3 (a) how to create a route record when the  spreading of route requests the network is shown here.              Figure 3(a): In route discovery process the   creation of the route               Record        Every node attached its addre ss to the route record in the  request message and nd1 to nd8 show the address which  are added in the route request. When a route request send  to targeted node or an intermediate node then in response  to this request a route reply come in the network. When a  target node has received a rout e request in a route record  and sequence of nodes move in the network. When all  nodes to create a route repl y to access the targeted node  then it copies route record which forwarded at the route  request by source shown in Figure 3 (b).         Figure 3(b): the moveme nt of route replies   with router record.    Maintenance of route  The route maintenance is an important factor in the  networks. When we find an error in or a link fail on the  network then route maintenance play an important role.  When there are errors occurs in between nodes of a  network then a route error message is sent to the source  node. The error message has information’s of those nodes  in which transmission failed due to link fail. As in figure 3  (c), when nd1 is answerable for receiving of packet at nd2  and also intermediary node n d2 is answerable of receiving  packets at node nd5 and then node nd5 is also answerable  for receiving of packets at targeted node nd8.         Figure 3(c): Route Maintenance exemple:    When the intermediate node nd5can not forward packets  of the source node nd1 to targeted node nd8 then the  intermediary node nd5 send a rout error message to source  node nd1 that the link between the nd5 to nd8 is not  available or failed due to some  reason then the source node  nd1 delete this failed link from its cache..    Advantages    • The 1st advantage is that, wh en the packets are sent to  find route then overload is  very minimum because this  reactive protocol establish the path only between those  nodes which want to make communication.  • 2nd advantage is that only route request process creates  routes between source to destination by using cache and  intermediary hopes of networking.   Disadvantages:  • 1st disadvantage of this reactive protocol is that when a  source node moves a packet to  targeted node which use  header and header contain the routes. As of result of this if  nodes lie in the network is more and more than its result in  the form of byte over head.   • 2nd disadvantage is that when a source wants to send the  packet's destination, it sends request but this request goes  to all nodes lie in the network when this is not necessary.   • 3rd disadvantage is that, this reactive protocol using  cache which cause a problem because updating a cache  result in overload on the network.    2.4 Ad hoc Ondemand Mult ipath Distance Vector  Routing (AOMDV):    This is another type of reactive protocols which is an  advanced version of AODV with an advantage of link  disjoint path and looping free. It maintains a route to  destination on demand. When a route is established to  target node then every destination routing entries contain  the address record of next node with related hop count As  in AOMDV, all subsequent hops in network contain same  sequence numbers which is most helpful for continuing the  path of route from source to destination. For reaching to  the destination every node sends an advertisement in the  network to destination and there is a node which makes a  hop count. The purpose of hope count for telling that how  many numbers hopes come in path to reach the destination.  To avoid looping for a node by accepting alternate path to  target node if total numbers of hop count less than  advertisement hop count. Fo r the same sequence number,  the advertisement hop count doe s not change because this  protocol maximum hop count are used to reach to the  destination. The advertisement and next hop are restarted  when a route advertisement is received with a greater  sequence number than the hop count for targeted node.  This protocol used to find disjoint route in the network.  For finding disjoint route, the every node in the network  does not reject duplicate requ est straight away. A request  which come from different destination of network called  node disjoint path. As nodes cannot broadcast same  request twice, This is because the nodes cannot be  broadcast duplicate request,  therefore duplicate request  which arriving at the midway node by source neighbors  cannot traverse the same node. A targeted node answer to  duplicate request to get multiple disjoint link and  destination only answer to requests which come through  by single source nodes.. The advantage of this reactive  protocol is that request reply is allowed to midway node  while selecting of disjoint path.  Sine, it is multipath routing protocol so its message routing  overhead is maximized and also increase due destination  replies  3.  Related work   "
315,QSOR: Quantum-Safe Onion Routing.txt,"In this work, we propose a study on the use of post-quantum cryptographic
primitives for the Tor network in order to make it safe in a quantum world.
With this aim, the underlying keying material has first been analysed. We
observe that breaking the security of the algorithms/protocols that use long-
and medium-term keys (usually RSA keys) have the highest impact in security.
Therefore, we investigate the cost of quantum-safe variants. These include key
generation, key encapsulation and decapsulation. Six different post-quantum
cryptographic algorithms that ensure level 1 NIST security are evaluated. We
further target the Tor circuit creation operation and evaluate the overhead of
the post-quantum variant. This comparative study is performed through a
reference implementation based on SweetOnions that simulates Tor with slight
simplifications. We show that a quantum-safe Tor circuit creation is possible
and suggest two versions - one that can be used in a purely quantum-safe
setting, and one that can be used in a hybrid setting.","Nowadays, information available online is expanding in an unforeseen way, a vast amount of data is uploaded and shared through social media, IoT, etc. [14]. However, this data also attracts unwanted attention and might paint a bad image of some stakeholders. Consider the case of Edward Snowden who put the National Security Agency (NSA) in the spotlight by shedding light on how the American population was wiretapped [13]. When blowing the whistle on such a large scale one would aim to remain anonymous, as this act can negatively aect the career and freedom of the individual. In oppressive regimes, where the freedom of speech is abused, this is even more serious, as any type of negative speech, whistleblowing or expressing freedom of information may be recognized as an act of treason resulting in severe punishments. The Onion Router (Tor [8]) aims to obfuscate the anonymity of its users when accessing or communicating over the Internet. In principle, when using Tor, thearXiv:2001.03418v1  [cs.CR]  10 Jan 20202 Z. Tujner, T.A. Rooijakkers, M. van Heesch, M. Onen messages or website connection requests are sent through a network of relays and after multiple 'hops' reach their destination. So, if Alice wants to send Bob a message, but does not want an eavesdropper to know that she initiated the contact, Alice can use Tor. The cryptographic schemes used today and in Tor are based on hard mathematical assumptions e.g., Discrete Logarithm Problem and integer factorization [12]. These schemes are assumed to be secure against classical adversaries, as solving them with the currently known algorithms cost exponential time. However, with a quantum computer solving these problems become feasible. The transition from current cryptography to postquantum cryptography needs to be started as soon as possible as quantum computers pose a threat to current and in particular publickey cryptographic algowithms. It is expected that this will have signicant eects on IT infrastructure. This is due to the heavier operations quantumsafe cryptography requires for setting up connec tions [11]. Furthermore, network load is also expected to increase as message sizes are bound to get larger due to the increased encryption sizes. Tor is a vol unteer run network all across the globe and both the people running the nodes and the users connecting are going to experience drawbacks. Contributions In this work, we investigate the main challenges to build and maintain a quantumsafe Tor network. We rst examine the dierent keying material used in Tor and identify the impact of the compromise of each of them. We observe that the migration towards quantumsafe Tor should start with the update of cryptographic algorithms that involve longterm and mediumterm keys such as the identity key. Such a migration naturally results in additional cost in terms of CPU and bandwidth. In order to evaluate the actual overhead resulting from the shift to post quantum cryptographic algorithms, we have conducted an experimental study while considering six dierent postquantum publickey encryption algorithms that are part of NIST's round 2 submissions3. The implementation of these al gorithms is provided by the Open Quantum Safe library [18]. We particularly analyze the cost of key generation, key encapsulation and key decapsulation, and compare them with the currently used algorithms deriving from the RSAcryp tosystem or elliptic curve cryptography. We observe that each implementation comes with dierent advantages and limitations, and that consequently there is no ideal solution that oers optimal CPU and bandwidth overhead. We further focus on a Tor network operation, namely circuit building, and compare the cost of the postquantum variant operation with the original one. This comparative study is performed through a reference implementation based on SweetOnions4that simulates Tor with slight modications. Additionally, sim ilar to [11,9], a hybrid implementation combining the use of postquantum cryp tography with classical schemes is also proposed. Such an implementation pro 3https://csrc.nist.gov/Projects/postquantumcryptography/round2submissions 4https://github.com/LeonHeTheFirst/SweetOnions, accessed on 28/11/2019, 11:21amQSOR: QuantumSafe Onion Routing 3 tects against potential security  aws of quantumsafe schemes due to their recent publications. We show that while the increase in CPU time is acceptable and similar among dierent implementations, the bandwidth overhead remains sig nicant and the optimal performance is achieved when Sike [10] is used. 2 Background 2.1 The Onion Router (Tor) The onion routing network, Tor [8], is one of the most popular tools to achieve anonymity for web browsing. When a Tor user accesses a website on the Internet, the trac encrypted with multiple encryption layers is routed across multiple relays. The use of multiple nodes enroute to the destination helps obfuscate the connection of users and hence achieve anonymity: Each node in the path towards the destination (named a circuit), only has information about the previous node and the next node in the path. Messages are encrypted by the source in a layered fashion whereby each encryption layer is removed by one relay node. Nowadays, Tor counts around 6 000 nodes5and the default number of relay nodes to set up a circuit is three (entry node, middle node, exit node)6. Each node has to communicate information called descriptors towards Directory Authorities, who maintain a state of the network. The Directory Authorities vote on the status of the network to obtain a consensus document. The user connects to one of the Directory Authorities, fetches the consensus document and the Tor software will select a path from the available nodes. The overall Tor framework is illustrated in Figure 1. The security and privacy features that Tor ensures rely on the use of essential cryptographic primitives such as encryption, digital signatures and key exchange. Consequently, each Tor node receives and maintains multiple cryptographic keys for dierent purposes. Table 1 provides an overview of the asymmetric keys used in Tor with their lifetime and functionalities. Longterm keys are used at least for one year, mediumterm keys are used for three to twelve months, and shortterm keys have a lifespan of minutes to a maximum of one day. 2.2 Postquantum cryptography The security of the current asymmetric encryption and digital signature stan dards mostly depend on the hardness of integer factorization ( RSA) or discrete logarithm (DieHellman, Elliptic Curve Discrete Logarithm) [12]. As described in [16], such cryptographic schemes can be easily broken in polynomial time when using quantum computers. Hence, researchers are actively developing post quantum cryptographic solutions to resist quantum attacks [4]. 5https://metrics.torproject.org/networksize.html, accessed on 28/11/2019, 4:33pm 6https://trac.torproject.org/projects/tor/wiki/TorRelayGuide, accessed on 28/11/2019, 4:33pm4 Z. Tujner, T.A. Rooijakkers, M. van Heesch, M. Onen Internet Middle nodeUserDAs SkenskmiskexskmiskenConsensus Entry node skex  Exit node Fig. 1. An overview of Tor containing nine directory authorities (DAs), a bridge au thority, the consensus document, Tor nodes, the symmetric keys (sk), and the message (msg). In 2016, the National Institute of Standards and Technology (NIST) opened a call for proposals on the topic of quantumsafe cryptographic solutions for new quantumsafe standards [15]. The rst round contained 69 submissions. On January 30, 2019 the candidates for the second round were announced, consisting of 17 asymmetric key encryption and keyestablishment algorithms and 9 digital signature algorithms. The transition to quantumsafe cryptographic schemes is expected to be a lengthy process. The adoption of quantumsafe schemes results in a signicant increase in bandwidth and computational cost. Developers adopt the hybrid approach whereby currently used standardized cryptographic schemes are com bined with quantumsafe schemes. 2.3 Related work "
24,Towards Expeditious and Unswerving Routing to Corroborate Nascent Internet.txt,"The internet is now-a-days experiencing a stress due to some inherent
problems with the main interdomain routing protocol, boarder gateway protocol
(BGP), the amount of time it takes to converge, number of update message
exchanged followed by a failure to stabilize, the amount of time required to
get a valid alternate path following the failure, the way size of routing table
increasing, and security issues like integrity and privacy of routing tables
and routing updates exchanged among the routers, are of our primary concern. In
our proposed research work we plan to address aforementioned issues related to
internet routing specially in boarder gateway protocol to enable BGP to offer
expeditious unswerving routing to corroborate nascent internet. We plan to make
some changes in the design of boarder gateway protocol and may introduce
addition of extra features in BGP to help support above mentioned objective."," HE structure  of the internet  is a is a collection  of  networks,  or Autonomous  Systems (AS’s), as shown  in figure1 and 2, which are interconnected  to form a  connected  domain [19]. Each AS uses an interior routing  system to maintain  a coherent  view of the topology   within the AS, and uses an exterior routing system to  maintain  adjacency  information  with neighboring  AS’s  and thereby create a view of the connectivity  of the entire  system.   This networkwide connectivity is described in the  routing table used by the BGP4 protocol. Each entry in the  table refers to a distinct route. The attributes of the route are used to determine the best path from the local AS to  the AS that is originating the route. Determining the ’best  path’ in this case is determining which routing advertisement and associated next hop address is the most pre ferred. The BGP routing system is not aware of finer level  of topology within the local AS  or within any remote AS.  From this perspective BGP can be seen as a connectivity  maintenance protocol, and the BGP routing table, a de scription of the current connec tivity of the Internet, using  an AS as the basic element of computation.           Figure 1: Autonomous Systems               T ————————————————   • Dr Shishir Kumar is Head of the Department of Computer Science and  Engineering, Jaypee Institute of Engineeringv and Technology, Guna, Madhya Pradesh (India).   • Mahesh Kumar is with the Department of Computer Science and Engineer ing, Jaypee Institute of Engineeri ngv and Technology, Guna, Madhya  Pradesh (India).       © 2009 Journal of Computing http://sites.google.com/site/journalofcomputing/ JOURNAL OF COMPUTING, VOLUME 1, ISSUE 1, DECEMBER 2009, ISSN: 21519617  HTTPS://SITES.GOOGLE.COM/SITE/JOURNALOFCOMPUTING/    115             Figure 2: Multitier interdomain routing   2 RELATED WORK:  "
212,On Performance Analysis of AMBR Protocol in Mobile Ad Hoc Networks.txt,"Due to mobility of nodes in ad hoc networks, the most challenging issue is to
design and to make sound analysis of a routing protocol that determines its
robustness to deliver packets in low routing packet overhead. In this paper, we
thoroughly analyzed the Adaptive Monitor Based Routing (AMBR) protocol by
varying different parameters that affect a routing protocol to measure its
performance. Analysis shows that it requires less routing control overhead
comparing with other prevalent routing protocols. An improved analytical model
is also presented in this paper. All these analyses firmly prove that AMBR is a
sound and robust protocol in terms of flooding, routing overhead and hence,
enhances reliability.","An ad hoc network is a class of wireless systems th at consists of independent mobile  nodes communicating with each other over wireless l inks, without any static infrastructure  such as base stations [1]. A communication session is achieved either through a singlehop  radio transmission if the communicating parties are  close enough, or through relaying by  intermediate nodes otherwise [2]. Since the nodes m ove randomly, the topology of the  network changes with time. Dynamically changing top ology and lack of centralized  control make the design of an adaptive distributed routing protocol challenging [1]. Due to  the limited spectrum, user’s mobility and power con straints, routing remains a challenge,  particularly in wireless communication systems such  as ad hoc networks. Several other  challenges complicate routing, including scalabilit y, routing efficiency, adaptation to  wireless networks of various densities, and distrib ution [3].  In this paper, a thorough analysis is performed on the Adaptive Monitor Based  Routing (AMBR) [10] protocol to show its robustness  by varying different parameters that  affect most of the routing protocols. AMBR discover s and maintains routes in hierarchical  and distributed fashion and locally repairs the bro ken link. The main motivation behind  the proposed AMBR is to drastically cut down floodi ng, to substantially tame the routing  overhead, to repair broken link locally in order to  minimize the routing overhead, and to IIUM Engineering Journal, Vol. 11, No. 2, 2010   Tanay Dey et al.    241   increase efficiency in packet movement in the ad ho c networks. In all analyzing cases, it is  found that AMBR is a bandwidth efficient routing pr otocol as the routing overhead was  drastically cut down.  In section 2, we describe the related work and the details of AMBR routing protocol  and its algorithm is described in section 3 and in section 4, we describe an improved  analytical model. Simulation results are shown in s ection 5. Finally, section 6 concludes  the paper.    2. RELATED WORK  "
458,Competitive Routing in Hybrid Communication Networks.txt,"Routing is a challenging problem for wireless ad hoc networks, especially
when the nodes are mobile and spread so widely that in most cases multiple hops
are needed to route a message from one node to another. In fact, it is known
that any online routing protocol has a poor performance in the worst case, in a
sense that there is a distribution of nodes resulting in bad routing paths for
that protocol, even if the nodes know their geographic positions and the
geographic position of the destination of a message is known. The reason for
that is that radio holes in the ad hoc network may require messages to take
long detours in order to get to a destination, which are hard to find in an
online fashion.
  In this paper, we assume that the wireless ad hoc network can make limited
use of long-range links provided by a global communication infrastructure like
a cellular infrastructure or a satellite in order to compute an abstraction of
the wireless ad hoc network that allows the messages to be sent along
near-shortest paths in the ad hoc network. We present distributed algorithms
that compute an abstraction of the ad hoc network in $\mathcal{O}\left(\log ^2
n\right)$ time using long-range links, which results in $c$-competitive routing
paths between any two nodes of the ad hoc network for some constant $c$ if the
convex hulls of the radio holes do not intersect. We also show that the storage
needed for the abstraction just depends on the number and size of the radio
holes in the wireless ad hoc network and is independent on the total number of
nodes, and this information just has to be known to a few nodes for the routing
to work.","Nowadays almost every person has a cell phone. Hence, in a city center the density of cell phones would, in principle, be suﬃciently high to set up a wellconnected wireless ad hoc network spanning the entire city center, which could then be used for many interesting applications in the area of social networks. Wireless ad hoc networks have the advantage that there is no limit (other than the bandwidth and battery constraints) on the amount of data that can be exchanged while the amount of data that can be transferred at a reasonable rate via longrange links using the cellular infrastructure or satellite is limited (by some data plan) or costly. However, routing in a mobile ad hoc network is challenging, even if the geographic position of the destination is known, since buildings or other obstacles like rivers may create radio holes that make it nontrivial to ﬁnd a nearshortest routing path. So the question we address in this paper is: Can longrange links be used eﬀectively to ﬁnd nearshortest routing paths in the ad hoc network? A simple solution to that problem would be that all nodes regularly post their geographic position and the nodes within their communication range to a server in the Internet. This would allow the server to compute optimal routing paths so that whenever a node wants to forward a message to a certain destination, the server can tell it which of the neighbors to send it to. An alternative approach that we are pursuing in this paper is a purely peertopeer based approach in which no other equipment other than the cell phones and an infrastructure for the longrange links needs to be used. To the best of our knowledge, our approach is the ﬁrst one that is making use of a global communication infrastructure in a peertopeer manner in order to eﬃciently determine short routing paths for an ad hoc network. Wireless ad hoc networks have been considered before that utilize base stations in order to exchange messages more eﬀectively, but there, messages will be sent via longrange links to bridge long distances while we will only allow messages to be sent via ad hoc links. 1.1 Model Target Radio hole detection Fast calculation of radio hole abstraction 1) 2) Fast calculation of ccompetitive path between source and target 3) Source Figure1 Anoverviewofourapproach. Itcontainsthedetectionofradioholes(1), thecomputation of a hole abstraction (2) and a routing algorithm that ﬁnds ccompetitive paths (3). The blue regions are called bay areas .D. Jung, C. Kolb, C. Scheideler and J. Sundermeier 23:3 Throughout this paper, we consider V⊂R2to be a set of nodes in the Euclidean plane with unique IDs (e.g., phone numbers), where |V|=n. For any given pair of nodes u=(ux, uy),v=(vx, vy), we denote the Euclidean distance between uandvby||uv||=/radicalBig (ux−vx)2+ (uy−vy)2. We model our cell phone network as a hybrid directed graph H=(V, E, E AH)where the node set Vrepresents the set of cell phones, an edge (v, w)is in Ewhenever vknows the phone number (or simply ID) ofw, and an edge (v, w)∈Eis also in thead hoc edge set EAHwhenever vcan send a message to wusing its Wiﬁ interface. For all edges (v, w)∈E\EAH,vcan only use a longrange link to directly send a message to w. We adopt the unit disk graph model for the edges in EAH. IDeﬁnition 1. For any point set V⊆R2theUnit Disk Graph ofV,UDG ( V), is a bidirected graph that contains all edges (u, v)with||uv||≤1. We assume UDG ( V)to be strongly connected so that a message can be sent from every node to every other node in Vby just using ad hoc edges. While the ad hoc edges are ﬁxed in Sections 2  5 , the nodes can nevertheless change Eover time: If a node vknows the IDs of nodes wandw/prime, then it can send the ID of wtow/prime, which adds (w, w/prime)toE. This procedure is called IDintroduction . Alternatively, if vdeletes the address of some node w with (v, w)∈E, then (v, w)is removed from E. There are no other means of changing E, i.e., a node vcannot learn about an ID of a node wunless wis inv’s UDGneighborhood or the ID of wis sent to vby some other node. Moreover, we consider synchronous message passing in which time is divided into rounds. More precisely, we assume that every message initiated in round iis delivered at the beginning of round i+ 1, and a node can process all messages in a round that have been delivered at the beginning of that round. 1.2 Objective Our objective is to design an eﬃcient routing algorithm for ad hoc networks, where the source sof a message knows the ID of the destination t, or in other words, (s, t)∈E. This is a reasonable constraint since cell phone users normally wouldn’t call cell phones whose users are unknown to them. Thus, whenever a message needs to be sent from a source sto some destination t, we assume that the geographic position of tis known, since scan ask t via a longrange link for t/primesgeographic position before sending the message towards tusing the ad hoc network. Our routing algorithm consists of two parts: After determining the radio holes of the wireless ad hoc network, we compute an abstraction, i.e., a compact representation of these radio holes and use that abstraction in order to route messages along ccompetitive paths. See Figure 1 for a visual description of these parts. We call a routing strategy ccompetitive if for all node pairs (s, t), the routing path (s, . . . , t ) from stotobtained by the strategy satisﬁes ||(s, . . . , t )||≤c·d(s, t), where||(s, . . . , t )|| denotes the Euclidean length of (s, . . . , t )andd(s, t)denotes the shortest Euclidean length of a path in UDG ( V)from stot. We will focus on computing suitable abstractions of radio holes in the ad hoc network. The intuition behind that is simple: if there are no radio holes, then simple greedy routing (i.e., always take the neighbor that is closest to the destination) would already give us short routing paths to arbitrary destinations. Radio holes can be speciﬁed by the nodes along its boundary, but there can be many such nodes. Therefore, we will also look at more compact representations of radio holes like the (nodes forming the) convex hull of its CVIT 201623:4 Competitive Routing in Hybrid Communication Networks boundary. Considering convex hulls as radio hole abstractions makes sense because in huge cities like New York City the shape of radio holes (caused by obstacles like buildings) is in many cases convex or close to a convex shape, and these shapes do not overlap. In order to obtain the desired abstraction, we will make use of IDintroductions in order to form an overlay network that allows us to compute these abstractions in a distributed manner using the longrange links. Since sending messages via longrange links is costly (in terms of money), our goal is to keep the longrange communication work of the nodes as low as possible. 1.3 Our Contributions We consider any hybrid graph G= (V, E, E AH)where the Unit Disk Graph of Vis connected. LetHbe the set of radio holes in GandCbe the set of convex hulls of radio holes in H. P(h)denotes the length of the perimeter of a radio hole h∈H. Further, L(c)denotes the circumference of a minimum bounding box of a convex hull c∈C. Our main contribution is: ITheorem 2. For any distribution of the nodes in Vthat ensures that UDG( V) is connected and of bounded degree and that the convex hulls of the radio holes do not overlap, our algorithm computes an abstraction of UDG( V) inO(log2n)communication rounds using only polylogarithmic communication work at each node so that ccompetitive paths between all sourcedestination pairs can be found in an online fashion. The space needed by the convex hull nodes of the radio holes is O/parenleftbig/summationtext c∈CL(c)/parenrightbig . Nodes lying on the boundary of radio holes need storage of size O(max h∈HP(h)). For every other node, the space requirement is constant. The rest of this paper is dedicated to the proof of Theorem 2. For that, we use the following approach: 1.Given the Unit Disk Graph, we compute the 2localized Delaunay Graph. This only needsO(1)communication rounds. The 2localized Delaunay Graph allows the nodes to detect whether they are at the boundary of a radio hole. Nodes at the boundary can then form a ring. 2.We then develop a distributed algorithm that computes a convex hull of a ring of nnodes in expectedO(logn)communication rounds. 3.Afterwards, we introduce the nodes of the convex hulls to each other so that they form a clique. This will allow them to compute ccompetitive paths for all sourcedestination pairs that are outside of a convex hull. The introduction requires O(log2n)communication rounds. In order to handle the case that the source or destination lies inside a convex hull, we will make use of a Dominating Set of the boundary nodes. The Dominating Set can be computed in O(logn)communication rounds. Finally, we also consider the dynamic scenario (i.e., UDG( V) changes over time) in Section 6. 1.4 Related Work "
259,Transaction Propagation on Permissionless Blockchains: Incentive and Routing Mechanisms.txt,"Existing permissionless blockchain solutions rely on peer-to-peer propagation
mechanisms, where nodes in a network transfer transaction they received to
their neighbors. Unfortunately, there is no explicit incentive for such
transaction propagation. Therefore, existing propagation mechanisms will not be
sustainable in a fully decentralized blockchain with rational nodes. In this
work, we formally define the problem of incentivizing nodes for transaction
propagation. We propose an incentive mechanism where each node involved in the
propagation of a transaction receives a share of the transaction fee. We also
show that our proposal is Sybil-proof. Furthermore, we combine the incentive
mechanism with smart routing to reduce the communication and storage costs at
the same time. The proposed routing mechanism reduces the redundant transaction
propagation from the size of the network to a factor of average shortest path
length. The routing mechanism is built upon a specific type of consensus
protocol where the round leader who creates the transaction block is known in
advance. Note that our routing mechanism is a generic one and can be adopted
independently from the incentive mechanism.","In this work, we investigate transaction propagation on per missionless blockchains with respect to incentive compatibility and bandwidth efﬁciency. The former, incentive compatibility, is an essential component of permissionless blockchain to maintain its functionality with rational participants [1], [2]. The latter, bandwidth efﬁciency, is an important factor for efﬁcient use of limited resources available in the network. Although a number of works have studied incentive com patibility problem of blockchains, they are limited to min ing mechanism, e.g. investigating selﬁsh mining attacks [3]– [6], and block withholding attacks [7]–[10]. The existing blockchain solutions such as Bitcoin [11] and Ethereum [12] do not pay attention to incentives for transaction propagation in the network. This is due to the fact that the mining networks in those solutions are centralized in practice [13]–[15] and thus, they do not exhibit a fully decentralized structure. There are only two works that address incentive compatibility of transaction propagation in blockchain by Babaioff et al. [16] and Abraham et al. [17]. Unfortunately, both works suggest a speciﬁc solution for the incentive compatibility but do not provide a formal deﬁnition of the problem. Furthermore,the proposed solutions are also designed for certain network topologies. In terms of bandwidth inefﬁciency, existing solutions suffer from multiple broadcasting of the same transaction over the network. For example, in Bitcoin, each transaction is received by the nodes (miners) in the network twice: once during the advertisement, i.e. broadcasting of the transaction at the beginning, and once after the validation, i.e. broadcasting of the block including the transaction. While validation is essential since each node in the network stores every validated transaction, the advertisement does not need to be received by all nodes. However, redundancy for advertisement is inevitable in such cases where the round leader who creates the validated block is unknown in advance since the transaction needs to be broadcast to all potential round leaders. In recent blockchain proposals where the round leader is known in advance, what we call ﬁrstleaderthenblock (FLTB) type of consensus pro tocols [18]–[21], it is possible to improve bandwidth efﬁciency by reducing the communication cost by directly routing the transaction to the round leader. To the best of our knowledge, there is no prior work on optimizing bandwidth efﬁciency for fully decentralized blockchain. In this work, our contribution is threefold: 1) Sybilproof incentive compatible propagation mechanism, 2) bandwidth efﬁcient routing mechanism, and 3) bandwidth and storage efﬁcient transaction propagation mechanism which combines the ﬁrst two mechanisms. We formally deﬁne incentive compatibility of propagation mechanisms in fully decentralized blockchain networks. We show that there is no Sybilproof and incentive compati ble propagation mechanism for poorly connected networks (speciﬁcally for 1connected networks). For other network topologies, we ﬁnd the following incentive compatible and Sybilproof formula, which distributes the transaction fee among propagating nodes: fk [i]=( FC(1"
341,Achieving Throughput via Fine-Grained Path Planning in Small World DTNs.txt,"We explore the benefits of using fine-grained statistics in small world DTNs
to achieve high throughput without the aid of external infrastructure. We first
design an empirical node-pair inter-contacts model that predicts meetings
within a time frame of suitable length, typically of the order of days, with a
probability above some threshold, and can be readily computed with low
overhead. This temporal knowledge enables effective time-dependent path
planning that can be respond to even per-packet deadline variabilities. We
describe one such routing framework, REAPER (for Reliable, Efficient and
Predictive Routing), that is fully distributed and self-stabilizing. Its key
objective is to provide probabilistic bounds on path length (cost) and delay in
a temporally fine-grained way, while exploiting the small world structure to
entail only polylogarithmic storage and control overhead. A simulation-based
evaluation confirms that REAPER achieves high throughput and energy efficiency
across the spectrum of ultra-light to heavy network traffic, and substantially
outperforms state-of-the-art single copy protocols as well as sociability-based
protocols that rely on essentially coarse-grained metrics.","Disruption Tolerant Networks (DTNs) are characterized by intermittent con nectivity and potentially high endtoend delays. As a consequence, the lack of adequate awareness of temporal path variability impacts throughput, energy eciency and delay In particular, stateoftheart DTN routing protocols that use timeaveraged metrics and onthe y forwarding decisions based on past history not only miss out on good forwarding opportunities but also are vulner able to using paths of poor quality. The more recent sociabilitybased protocols expend large control overheads to achieve better path planning, but are insensi tive to variable packet deadlines. In contrast, we explore in this paper whether a DTN protocol with an expectation of future contacts in a \prediction time frame""|a window into the future|can eectively employ timedependent path planning. We leverage recent analyses of several mobility traces [1,2,3] that havearXiv:1902.06371v1  [cs.NI]  18 Feb 2019shown periodic behavior being exhibited along with some degree of randomness. These hint at the possibility of achieving negrained predictability of node inter contacts within some time frame and, thereby, making timedependent choices of paths which are reliable and/or timely. Recent research has also demonstrated a \smallworld phenomenon"" in reallife dynamic networks [4,5,6], wherein a net work is connected via short paths that grow only logarithmically with its size. These suggest that as long as frame based, negrain path planning preserves the smallworld property, enumeration of available paths should not incur high overhead. Contributions of the paper. We introduce a temporal framebased ap proach for DTN routing. Intuitively, a frame is an interval of time in which nodepair intercontact (link) probabilities are high for suciently many pairs such that together these pairs imply a temporally giant connected graph, over which reliable routing is possible even if there is a tradeo with delay. Through the analysis of real life dynamic network traces, we show that a suitably chosen time frame allows for deterministic or highly reliable meetings of a signicant fraction of node pairs in the network, greatly improving the average path proba bilities and expected throughput, while preserving the smallwoorld property of the network. In the context of a frame, we next introduce a model of pairwise intercontacts that can be used for predicting upperbounds on node meeting instants. The model is simple to implement, and requires minimal information in a realworld dynamic setting. It does not assume the existence of infrastruc ture nor any advance knowledge of the underlying mobility model and network dynamics: nodes leverage the intrinsic pattern of intercontacts to extract link information in the course of normal network evolution. Using the predicted schedules, we then demonstrate negrained network path planning using traditional QoS metrics (such as path length, delay, reliabil ity, etc.), by designing REAPER (for Reliable, Ecient and Predictive Routing), a fully distributed singlecopy routing framework that allows for temporally vari able selection of the best path subject to some deadline constraints for message delivery. The common case control overhead of REAPER is polylogarithmic in the number of relay nodes, while maintaining enough information to be used with a variety of optimization objectives (in this paper, we optimize for path lengths, incerchangeably referred to as costs). REAPER is  exible in that it allows for the specication of the delay constraint on a permessage basis. The protocol also selfstabilizes under a bounded number of failures in the system; the formal proof of stabilization is presented in the Appendix. We have evaluated the performance of REAPER against linkmetric based infrastructurefree singlecopy DTN protocols, namely, Minimum Estimated Ex pected DelayBased Distance Vector Routing (MEEDDVR) [7] and Probabilis tic Routing Protocol using a History of Encounters and Transitivity (PROPHET) [8]. The evaluation is based on ns2 simulations and considers a realistic human carried mobile network setting. It shows an improvement in throughput of up to 135% (200%) over MEEDDVR (PROPHET) across light to heavy trac loads, with up to 4 :5(22) lesser average path lengths. In addition to discussing howthese improvements hold even with respect to more recent singlecopy protocols, we observe that REAPER has O(logn) (best caseO(n)) lower control overhead than the sociability metric based BUBBLE Rap [9], and has about 10% "
9,Creating a Secure Underlay for the Internet.txt,"Adversaries can exploit inter-domain routing vulnerabilities to intercept
communication and compromise the security of critical Internet applications.
Meanwhile the deployment of secure routing solutions such as Border Gateway
Protocol Security (BGPsec) and Scalability, Control and Isolation On
Next-generation networks (SCION) are still limited. How can we leverage
emerging secure routing backbones and extend their security properties to the
broader Internet?
  We design and deploy an architecture to bootstrap secure routing. Our key
insight is to abstract the secure routing backbone as a virtual Autonomous
System (AS), called Secure Backbone AS (SBAS). While SBAS appears as one AS to
the Internet, it is a federated network where routes are exchanged between
participants using a secure backbone. SBAS makes BGP announcements for its
customers' IP prefixes at multiple locations (referred to as Points of Presence
or PoPs) allowing traffic from non-participating hosts to be routed to a nearby
SBAS PoP (where it is then routed over the secure backbone to the true prefix
owner). In this manner, we are the first to integrate a federated secure
non-BGP routing backbone with the BGP-speaking Internet.
  We present a real-world deployment of our architecture that uses SCIONLab to
emulate the secure backbone and the PEERING framework to make BGP announcements
to the Internet. A combination of real-world attacks and Internet-scale
simulations shows that SBAS substantially reduces the threat of routing
attacks. Finally, we survey network operators to better understand optimal
governance and incentive models.","The de facto interdomain routing protocol, the Border Gateway Protocol (BGP), is infamously insecure. Adver saries can exploit vulnerabilities in BGP to advertise bogus routes and hijack or intercept communications towards a vic tim [20, 35, 37, 38, 60]. The initial secure routing efforts have focused on achieving origin validation , i.e., validating theowner—the origin Autonomous Systems (AS)—of an IP pre ﬁx, in order to prevent preﬁx hijacking attacks. A standardized mechanism is the Resource Public Key Infrastructure (RPKI), which generates records that bind an IP preﬁx to the origin AS [24]. However, origin validation is insufﬁcient for prevent ing more sophisticated interception attacks that manipulate routing paths [54]. Recent works demonstrate the severity of interception attacks, including surveillance and compromising critical internet applications [14, 18, 56, 75]. Other proposals achieve path security in the routing backbone by authenticat ing the entire path information. Border Gateway Protocol Se curity (BGPsec) augments BGP by cryptographically signing and validating BGP paths [15]. However, BGPSec requires signiﬁcant changes to the existing routing infrastructure and has yet to see production deployment. Private backbones and cleanslate Internet architectures such as Scalability, Control and Isolation On Nextgeneration networks (SCION) [64] have also been proposed. While they are deployed in produc tion networks, they cannot yet be used pervasively. In this context, can we design a system usable in today’s In ternet for improving routing security by leveraging an emerg ing secure routing backbone, such as SCION? Toward this goal, we propose the Secure Backbone AS (SBAS), a novel federated backbone infrastructure. SBAS abstracts away the secure backbone as a virtual AS that interacts with tradi tional ASes through conventional BGP. Within SBAS, the secure backbone allows for routing between participating cus tomers and is immune to BGP attacks. SBAS ensures that announcements received from participating customers are in deed authorized using existing techniques such as RPKI, and SBAS customers will prioritize routes received from SBAS. Although the customers’ connection to SBAS may cross a short tunnel, we demonstrate that even in this scenario SBAS offers signiﬁcant security beneﬁts. More speciﬁcally, a participating customer (which can be either an AS or a single end host) connects to SBAS via a se cure tunnel—a Virtual Private Network (VPN)—if it is not a direct neighbor. Participating customers can connect to SBAS via one or multiple distributed Points of Presence (PoPs). A 1arXiv:2206.06879v2  [cs.NI]  15 Jun 2022customer can bring its own preﬁx to announce through SBAS (e.g., an AS with its own address space), or use IP preﬁxes assigned by SBAS (e.g., individual clients and servers with out control over their address space). Within SBAS, customer address space is distributed via an SBASinternal iBGP mesh between the PoPs allowing PoPs to announce customer pre ﬁxes to traditional BGP neighbors (providing connectivity and improved security for nonparticipating hosts). We em phasize that SBAS is compatible with conventional BGP. This enables SBAS to route trafﬁc between SBAS customers and nonparticipating ASes,providing security beneﬁts even when one communication endpoint does not participate in SBAS. We have implemented and deployed SBAS on real net works using SCIONLab [49] to emulate a secure SCION backbone, the PEERING framework [71] to send/receive BGP announcements from nonparticipating ASes, and the Wire Guard VPN to establish secure tunnels with SBAS customers. Our implementation minimizes the need for new software and composes existing networking components to implement SBAS routing. Our key evaluation results are as follows: •In our proofofconcept deployment using SCIONLab and PEERING, we perform BGP attacks on IP preﬁxes of SBAS customers and of the VPN endpoints (in an ethi cal manner). SBAS successfully protects all customerto customer communication from our attacks and signiﬁcantly improves the resilience of communication between SBAS customers and nonparticipating hosts. •Our Internet topology simulations further conﬁrm that SBAS improves resilience to routing attacks on commu nication with nonparticipating Internet hosts. Using a SBAS deployment with just six PoPs improves resilience by 61.8%. Furthermore, SBAS integrates well with the exist ing effort on Route Origin Validation (ROV): if the broader Internet enforces ROV , 98.5% of adversaries are topologi cally incapable of hijacking SBASannounced routes. •Our proofofconcept deployment only incurs an 11% la tency overhead on average (compared to the Internet), which decreases as more SBAS PoPs are deployed (as participants are closer to their nearest PoP). An important beneﬁt of the SBAS architecture is its com patibility with diverse secure (possibly nonBGP) backbone approaches [15, 64]. Moreover, given its strong security ben eﬁts with only a small latency overhead, SBAS represents a promising new abstraction for securing interdomain routing that can provide much needed momentum and accelerate real world adoption of secure backbones. To better understand the path towards a production deployment of SBAS, we surveyed network operators on appropriate incentives and governance structures, and found a potential community of early adopters as well as viable governance models. Given the promising experimental and simulation results of our proofofconcept SBAS implementation, we dare the community of network operators to realize SBAS in a production environment.2 Overview of Interdomain Routing Security BGP and BGP attacks. BGP is the interdomain routing pro tocol today. However, BGP lacks authentication of routing information, which allows for BGP attacks where an adver sary maliciously sends BGP updates to hijack or intercept trafﬁc to a victim AS [74]. Research shows that BGP attacks can have devastating consequences on critical Internet ap plications, including those that use cryptographic security mechanisms [18,56,75]. Also, BGP attacks are routinely seen in the wild, impacting availability of Internet services and generating millions in revenue for miscreants [23, 38, 77]. Inequallyspeciﬁc BGP attacks, the adversary makes a malicious BGP announcement for a victim’s preﬁx that has the same preﬁx length as the victim’s preﬁx. Consequently, trafﬁc may reach either the adversary or the victim depending on the routing polices. In morespeciﬁc BGP attacks, the adversary announces a longer preﬁx than the victim’s preﬁx. Because forwarding is based on longest preﬁx match, trafﬁc destined for the more speciﬁc preﬁx will be routed to the adversary. This enables an adversary from almost any location in the Internet to attract a signiﬁcant amount of network trafﬁc destined to the victim. While morespeciﬁc BGP attacks are highly effective, they are not always viable given that most routers ﬁlter BGP announcements for preﬁxes longer than =24[5, 42] (thus protecting =24preﬁxes from morespeciﬁc attacks), and RPKI can also be used to ﬁlter malicious more speciﬁc preﬁx announcements [24]. The adversary may drop/respond to the trafﬁc ( hijack at tack) or forward the trafﬁc back to the victim ( interception attack) via tunneling or existing BGP paths by deliberately shaping the malicious BGP announcements [20,66]. Intercep tion attacks are more sophisticated but also stealthier because the victim may see little to no difference (other than poten tially increased latency) in its data plane trafﬁc. Current Secure Routing: RPKI and route ﬁltering. RPKI mitigates BGP attacks by providing a cryptographi cally secure database of IP address ownership that can be used to ﬁlter out bogus announcements [51]. In RPKI, each AS has a public–private key pair that is used to sign IP Route Origin Authorizations (ROAs) that associate IP preﬁxes with the ASes of their authorized origin ASes. The ASes compile the databases into a set of route ﬁlters which block announce ments that do not contain a valid hIP address, originipair. However, RPKI is vulnerable to forged origin attacks. In this type of attack, the adversary claims a nonexistent link to the victim in a malicious BGP update. Since RPKI only validates the origin of the IP preﬁx in a BGP update, the malicious update will propagate even in the presence of ROV . An AS can implement route ﬁlters on neighbors’ BGP announcements to allow announcements only from approved IP preﬁxes or AS paths [55, 73]. However, strict preﬁxbased route ﬁltering is difﬁcult to scale to peertopeer links and larger networks with a substantial number of IP preﬁxes; AS 2path ﬁltering cannot prevent an adversary from announcing a malicious preﬁx with a legitimatelooking AS path. Secure Internet backbone candidates. A wide variety of secure Internet routing technologies can be used as a secure backbone, ranging from BGP extensions to entirely new In ternet architectures [26,44,45,48,52,58,59,64,79,80,82,83]. Due to space limitations, only a few approaches are discussed below, but a more comprehensive overview of secure routing architectures is also available [25, 57, 68]. Federated backbones. BGPsec offers the properties re quired for a secure backbone by augmenting BGP to provide cryptographic veriﬁcation of routes in the control plane [15]. BGPsec requires each AS to sign outbound BGP announce ments, thus allowing ASes along the path to verify the au thenticity of the announcement. BGPsec not only prevents ASes from falsely originating preﬁxes that were not allocated to them, but also prevents ASes from claiming fake adjacen cies. Several shortcomings hampered widespread BGPsec deployment so far, e.g., scalability issues, slow convergence, high overhead for update veriﬁcation, and vulnerabilities that remain unaddressed. New Internet architectures can also be used for constructing a federated backbone, such as NEBULA [8], NIRA [84], and SCION [64, 86]. Speciﬁcally, SCION has been suggested as a cleanslate Internet architecture to provide secure inter domain routing. SCION provides strong security properties: innetwork perpacket source authentication, sovereignty and transparency for trust roots, and attack resilience for inter domain routing. Of these architectures, SCION is available today as a production network from several ISPs. Private backbones. Several corporations have developed proprietary private backbones that allow for secure data de livery, e.g., AWS and Cloudﬂare Argo [17, 27]. While not federated, some of these backbones allow for participants to connect via VPN tunnels and even announce their own ad dress space. While these commercial offerings are promising, they are challenging to scale as the competing providers do not seem to move towards a federated offering. 3 Design Principles 3.1 Goals and Challenges We seek to design a secure routing architecture that provides to the Internet high resilience against BGP hijacking at tacks . However, our intention is not to introduce another secure routing protocol. Although secure routing protocols provide clear advantages over the currently used BGP, they have so far only achieved partial adoption. The main obstacle to largescale adoption is that a participating entity requires a sizable ﬁnancial investment while gaining limited beneﬁts at the early stage of deployment. To overcome this, the architec ture has to be: (1) readily deployable without modiﬁcations to existing Internet infrastructure and protocols, (2) readilyavailable for customers who want to use the system, requiring minimum changes in setup, and more importantly, (3) readily beneﬁcial to the customer even with a partial deployment of the architecture. Considering incremental deployability, we aim to leverage an alreadydeployed secure routing infras tructure (as a secure backbone) to mediate communication between traditional IP endpoints. This extends the beneﬁts of the secure backbone to the broader Internet, and kickstarts routing security for Internet communication. We call this sys tem SBAS, the Secure Backbone AS. It is important to note that SBAS does not compete with any other secure routing methods; SBAS can beneﬁt from them since it is a comple mentary system, improving security in a synergistic manner. From this approach, the following research challenges arise: Architectural continuity. Coupling of a secure routing in frastructure and the rest of the Internet requires architectural continuity. That is, the secure backbone understands BGP’s control plane and seamlessly bridges remote BGP peers while leaving the leveraged secure routing infrastructure and its security guarantees intact. To this end, the secure backbone must achieve an architectural abstraction of the underlying in frastructure and provide a transparent interface to customers. Endtoend security. In the context of mediating cus tomer’s IP endpoints via a secure backbone, the endtoend communication path can be segmented into: an external (in secure) segment, which is comprised of the Internet links be tween an IP endpoint and the SBAS ingress/egress point, and an internal segment between an arbitrary ingress and egress pair of the secure routing infrastructure. To ensure endtoend secure routing, (1) a customer must be able to select trusted ingress/egress points and securely exchange packets with hi jack resilience, and (2) the secure backbone must deliver the security properties it promised to any pair of ingress/egress points even in the presence of internal adversaries. Routing priority. To enable customers to route trafﬁc from/to the Internet through a secure backbone, SBAS needs to disseminate the customers’ preﬁx announcements to all other customers and external entities. Preﬁxes will then be announced via SBAS and the Internet, resulting in competing announcements. To maximize the ability to route securely, SBAS must be able to convince the entities receiving the an nouncements to prioritize routing paths through the secure backbone over the insecure Internet paths. 3.2 Threat Model Adversary types. SBAS considers two distinct types of ad versaries. The ﬁrst type is an external adversary, who controls an AS on the Internet and is able to make arbitrary BGP announcements. The adversary performs BGP attacks to hi jack or intercept the trafﬁc originated from or destined to customers, which enables more sophisticated attacks such as domain validation attacks [18] and trafﬁc analysis [75]. The second type is an internal adversary, who may compromise 3ServerClientPoPAdversary AS SBASPoPPhysical InterfaceSCIONStackIPStackInterpreterBGPRouting TableControl PlaneData PlanePoPeBGPSecureRoutingProtocolSBAS PoP iBGPHijackingFigure 1: SBAS Overview entities with various roles in SBAS, attempting to disrupt connectivity to legitimate customers. We also allow the two types of adversaries to collude. Attacks that do not target rout ing (e.g., exploiting implementation vulnerabilities, or DDoS attacks) are considered out of scope. BGP attack types. The primary threat that SBAS aims to defend against is equallyspeciﬁc preﬁx attacks. This is justiﬁed since all preﬁxes controlled by SBAS are announced as 24bit preﬁxes (or 48bit IPv6 preﬁxes), which can only be attacked via equallyspeciﬁc preﬁx attacks (recall that preﬁx announcements longer than 24 bits in IPv4 and 48 bits in IPv6 are typically ﬁltered). Even though the primary threat we considered is equallyspeciﬁc preﬁx attacks, we show that communication between two SBAS customers beneﬁts from increased resilience even in the presence of morespeciﬁc preﬁx attacks. We demonstrate this property in Section 7.1. 4 Design of SBAS This section describes the control plane, data plane, and oper ational aspects in the design of SBAS. 4.1 SBAS Overview SBAS is an abstraction that enables a federated backbone network to act as a single AS toward the outside Internet. As shown in Figure 1, customers of the system can connect via secure connections (e.g., VPN tunnels) to one or more PoPs, which are located at the edge of SBAS. The system supports both (1) customers that control their own address preﬁxes to be routed via SBAS, and (2) customers that operate smaller network domains. The latter can simply obtain addresses from an SBASowned address range. Internally, the PoPs form a fullmesh BGP topology over the internal routing protocol of the backbone, which is used to distribute customer announcements to the globally distributed PoPs and to achieve maximum security for trafﬁc to secured preﬁxes. SBAS is fully compatible with conventional BGP security practices and internally performs validation checks to ensure that only legitimate announcements are redistributed by the system. Moreover, the secure routing protocol used internally, along with additional security mechanisms, ensure that the redistri bution scheme tolerates misbehaving SBAS members. Thisenables the system to extend the beneﬁts of the secure feder ated backbone to the broader internet, while addressing the challenge of partial deployment incentives that are limiting the practical use of such approaches. SBAS distinguishes between the following roles: Customer. A customer is an entity that resides outside the backbone and obtains service from SBAS through a contract, which enables it to route trafﬁc securely through the system. SBAS supports both (1) customers that only control single hosts (e.g., server operators or end users), and (2) entities that own entire address ranges and AS numbers. Point of Presence (PoP). A PoP is a member of SBAS that is located at the edge, i.e., provides connectivity to SBAS customers and interfaces with the regular Internet. Backbone operator. Such entities participate in the back bone network, but are not located at the edge; they simply participate in the internal routing and forwarding. This type of member does not need to be aware of the SBAS infrastructure running on top of the backbone. External entity. This term refers to entities on the Internet that are unaware of SBAS. SBAS distinguishes among three address categories: Secure. This includes preﬁxes announced by SBAS cus tomers and SBASowned address ranges, which are assigned to customers. Secure address ranges are announced publicly via BGP. Internal. To provide an internal addressing scheme among PoPs, e.g., to set up iBGP sessions between PoP routers, the PoPs reserve address space for SBAS internal operation. This address space is not visible outside the SBAS infrastructure. Global. We use this term to refer to all globally routable addresses to which the categories above do not apply. 4.2 The SBAS Abstraction Toward the Internet, SBAS is abstracted as a single AS mak ing BGP announcements. The deﬁning characteristic of the system is that it employs a federated structure internally: var ious entities may participate by connecting to the backbone network, which runs a secure interdomain routing protocol. Compared to offering secure routing through a tier1 ISP or IXP that allows any customers to connect via a secure channel (e.g., VPN or direct physical link), SBAS’s federated structure and abstraction provide the following beneﬁts: (1) federation lowers the potential for centralization of the Inter net and surveillance of trafﬁc at the hyperconnected single node, (2) incremental deployability by allowing other ASes to participate, and (3) an expanding SBAS network results in a reduction of the hop distance to customers which increases resilience to routing attacks. Virtualized fullmesh iBGP. The internal structure of SBAS can be abstracted to a fullmesh topology between the PoPs, independent of the routing protocol of the backbone. Over these connections, the PoPs redistribute announcements from 4SBAS AP1P3 P2 C… BD X/24 Path: [SBAS, A]   X/24 Path: [D, B, A]  iBGPeBGPFigure 2: The route redistribution process for a preﬁx X owned by customer AS A. The preﬁx is being announced in parallel through SBAS and to neighbors of A. SBAS customers as well as the Internet, akin to the operation of iBGP in a regular AS. In order to prevent tampering by nonPoP members, the iBGP sessions run over an encrypted and authenticated connection (such as a VPN tunnel). 4.3 Secure Route Redistribution SBAS offers a high degree of ﬂexibility to its customers through support for dynamic route redistribution. Contrary to a traditional AS, which is controlled by a single entity, the redistribution scheme to be used in SBAS must support its federated structure and remain secure in the presence of mali cious members. In the following, we describe the design and security aspects of the route redistribution mechanism. Federated bringyourown IP preﬁx. Customers that al ready control one or multiple IP preﬁxes can use them directly with SBAS. For this purpose, SBAS implements a route redis tribution mechanism that enables a customer to route incom ing trafﬁc from the Internet through the secure backbone. The process is depicted in Figure 2: the customer (AS A) initiates a BGP session with the PoP (AS P1) over a VPN connection. Using this session, Amakes an announcement for its preﬁx X, which is then redistributed to all other PoPs over the fullmesh iBGP topology. A remote PoP such as P2, upon receiving such an announcement over the iBGP session with P1, sends it out to its eBGP neighbors, i.e., Internet peers as well as SBAS customers. Enhanced RPKIbased security. The RPKI system pro vides strong security properties for the ﬁrst hop of BGP adver tisements, but does not protect subsequent hops. The design of SBAS complements this property, as it eliminates attack surfaces on the path through its secure backbone. SBAS lever ages RPKI to defend against two distinct threats: (1) cus tomers advertising preﬁxes that they do not own, and (2) PoPs falsely claiming authorization for a preﬁx from a customer. The ﬁrst threat is prevented in SBAS using route validation at the ingress. Each announcement from a customer must carry a valid ROA that authorizes the AS to originate the preﬁx, which is veriﬁed both at the ingress PoP and by the other PoPs that receive the redistributed announcement. Toprevent sophisticated routing attacks, SBAS additionally veri ﬁes that the AS path of these announcements does not contain any ASNs other than that of the origin (but still allowing for customer trafﬁc engineering using path prepending). An example of the second type of threat would be P3(in Figure 2) forwarding the announcement received from P1in an attempt to attract trafﬁc to A. To prevent such malicious behavior, a customer can use RPKI to authenticate a single or multiple PoPs that are authorized to redistribute a given preﬁx. This approach is similar to pathend validation [28], but in this case, it can be used purely by SBAS members and customers without requiring any external deployment. SBASonly preﬁx. Using an SBASdeﬁned BGP community tag, the customer can instruct the PoPs to only redistribute the announcement internally, i.e., to connected customers. This enables full protection of an address range against hijacking attacks, since secure preﬁxes are always prioritized by SBAS members and customers (as described in Section 4.5). 4.4 Customer Perspective Service management. Customers sign up for SBAS via an interface (e.g., SBAS portal) by setting up a contract at their local PoP (details on governance aspects are given in Sec tion 8.2). The connection to SBAS is managed by a client software that receives information about existing PoPs, in cluding publicly reachable IP addresses and a VPN public key for each PoP. SBAS can suggest a default SBAS PoP based on a network proximity metric. SBAS connection setup. A customer can connect to SBAS by connecting to one or multiple PoPs. A customer looking to maximize resilience to BGP attacks should generally priori tize the PoP that is the fewest BGP hops away. The connection to a PoP is set up over a VPN tunnel with the PoP’s keypair, or where possible, the customer can connect directly at the PoP. The latter case has the additional beneﬁt of eliminating the possibility of any BGP attack on the connection, as a local layer2 connection can be used. If the customer uses multiple PoPs, one connection is designated as the primary ingress point, with the others serving as backups for improved failure resilience. In order to prevent routing loops, the VPN endpoint that is used to connect to the SBAS PoP must be assigned a nonsecure address. A customer may wish to designate a part of its address range to be routed via SBAS (advertised via SBAS), and separate this from their remaining address space (advertised normally on the Internet). Secure address assignment. For customers that do not con trol an address space, SBAS can offer a (paid) feature to assign single addresses from a secure SBASowned preﬁx. This option is conﬁgured via SBAS client software. Upon assigning such an address to a customer, the PoP announces it to the other PoPs over the existing iBGP sessions. This allows them to route trafﬁc to the appropriate location and keep track of addresses that have already been assigned. 5P1 P2 AS CP3 iBGP sessionseBGP sessions… AS A8.0.0.0/16  nexthop(A) 9.0.0.0/24  nexthop(A) … …  AS D1.0.0.0/24  P2 2.0.0.1/32  nexthop(D) … … 1.0.0.0/24 via P 2  BGP announcement Addr ess T ype Secure Internal GlobalHigh priorityLow priorityFigure 3: Controlplane conﬁguration of P1.nexthop (X) refers to the address used as the next hop to AS X. 4.5 Routing Logic at PoPs The following sections describe how an SBAS PoP maintains routing information for the different types of addresses, and how packets are forwarded accordingly. Control plane: Virtualized iBGP. As shown in Figure 3, each PoP maintains several iBGP sessions to other PoPs over the backbone network, as well as eBGP sessions to customers and Internet peers. From the information received over these sessions, two routing tables are constructed: The ﬁrst table, which is given the highest priority, maps secure addresses to internal addresses. Each entry may be either a remote cus tomer preﬁx that is mapped to an internal address representing another PoP (in the example, 1.0.0.0/24 toP2), or a local cus tomer preﬁx that can be delivered to the customer’s VPN endpoint ( 2.0.0.1/32 tonexthop (D)). The advertisements for such routes are received over the iBGP session from other PoPs (in the former case) or over the eBGP session from customers (in the latter case). As a lowerpriority table, P1maintains an Internet rout ing table for routes obtained from its Internet peers. These routes will likely also be received via iBGP from other PoPs distributing preﬁxes they received from their respective neigh bors. In this case, route selection can follow standard Internet policies or custom logic implemented by P1. Data plane: Secure address prioritization. Next, we de scribe dataplane forwarding decisions for different scenarios of source and destination locations, as illustrated in Figure 4. By keeping a strict priority hierarchy between secure routes and external routes, SBAS provides resilience to BGP hi jacking attacks by design. The detailed security properties achieved by this design are explored in Section 7.1. Customertocustomer (HS!HD) In the simplest case, a packet originates from a secure address HSin a customer AS Sand is destined to another secure address HD. The packet from HSis routed through the VPN tunnel to the ingress PoP P2. There, P2looks up the secure address HDand ﬁnds the internal address for the egress PoP P1associated with it. The original packet is encapsulated over the backbone’s internal protocol to P2, which delivers it across the VPN tunnel to the destination in AS D. SBAS AS DP1 P2 AS SHDP2 → P1 HSHS → HDP3… AS S' HS → HDHS → HD Addr ess T ype Secure Internal GlobalFigure 4: Routing logic for incoming trafﬁc to a customer Dwho owns a secure address range. The packet shown is sent from a secure address HSand encapsulated across SBAS using the internal addresses for the PoPs P1andP2, before it is delivered to the secure address HD. Packets may also originate from global addresses such as from AS S0. External origin (S0!HD) We consider a packet that is destined to the secure address HD, but originates from a source in AS S0that is unaware of SBAS. In this case, the data plane operations follow the same sequence: Having received a BGP announcement from P3for the secure preﬁx that contains HD, ASS0will forward the packet to the nearest SBAS PoP. From this point, the same logic is applied as in the previous case. External destination (HD!S0) For trafﬁc with global des tination addresses, the routing decision offers more options through the choice of the egress PoP. Whereas in the previous cases, the trafﬁc was directed to the destination’s preferred PoP, the decision to select an egress location is up to the ingress PoP. This makes it possible to optimize for different metrics such as hijack resilience, which can be achieved by routing based on shortest AS path length, combined with hi jack detection. For instance, if an egress point notices a recent change in the AS origin of an IP preﬁx, this egress point may be avoided for trafﬁc to this IP preﬁx until the origin change can be validated. This approach further improves the system’s resilience to external BGP hijacking attacks. Through a number of key design principles and by leverag ing the secure backbone for internal routing, SBAS is able to disseminate routes securely to customers and out to the Inter net. Using a strict priority hierarchy on the control plane, traf ﬁc to/from customers beneﬁts from strong hijack resilience. 5 Implementation and Deployment We have implemented the SBAS design and deployed it on a globally distributed infrastructure. A key feature of our imple mentation is that it minimizes the need for new software and composes existing networking components in a synergistic manner. Driven by this, we implement the prototype of the SBAS system on top of the globally distributed future Internet research network SCIONLab. The SBAS system is comprised of four PoPs, two PEERING announcement nodes, and three customer locations (Appendix C presents the deployment 6SBAS PoP Internet providersWireGuard … SBAS customersOther SBAS PoPs…SCIONLab BIRD PEERINGSIGRouting engineFigure 5: The interfaces (shown in ﬁlled rectangles) and BGP sessions (solid lines) maintained by an SBAS PoP. map). Our SBAS implementation running on the PoP consists of approximately 1000 lines of code. The software automati cally conﬁgures and runs the various PoP components based on conﬁguration ﬁles that describe the setup of the SBAS instance. The full source code is publicly available. Instantiating SBAS with SCION. We employ SCION as the secure internal routing architecture of SBAS for several reasons: (1) SCION already provides a strong PKI system by design, which is essential for the core SBAS properties such as secure route redistribution, heterogeneous trust for the federated participants, and cryptographic protection in routing, (2) SCION provides network programmability with a high degree of freedom, helping us to virtualize the internal network structure and build a fullmesh intraSBAS topology, and (3) SCION possesses sufﬁcient system maturity with realworld deployment and operation. To integrate SBAS with the existing SCION architecture, we leverage the SCIONIP Gateway (SIG), which translates between IP and SCION through en and decapsulation of packets. The operation of a SIG at each PoP provides trans parent IP connectivity without requiring any changes to cus tomers’ networking stacks. We construct the SBAS protoype deployment on SCIONLab [49], the global SCION research network spanning over 50 infrastructure ASes across the world. In our deployment, four ASes instantiated at AWS datacenters in Oregon, Frankfurt, Singapore, and Tokyo are directly connected to the SCIONLab core infrastructure, op erating as SBAS PoPs. Dataplane interfaces. Each PoP has three interfaces for different types of destinations, as shown in Figure 5: (1) A WireGuard instance to send/receive packets to/from SBAS customers that are connected to that PoP, (2) A traditional Internet interface with IP transit/peering and a BGP routing table, and (3) A SIG that encapsulates IP packets in SCION packets and sends them over the SCION backbone. This mod ular decomposition of interfaces enables a high degree of ﬂexibility for SBAS. For instance, a different backbone ar chitecture can be conﬁgured to replace SCION as a dropin replacement without requiring changes to the other parts of the PoP software. Controlplane management. In addition to these dataplane interfaces, each SBAS PoP maintains BGP sessions with customers, IP transit providers/peers, and other SBAS PoPs. These BGP sessions are handled by the BIRD Internet routing daemon [3]. However, BIRD does not make the ﬁnal routing decision; it simply exports the routes learned from its various BGP sessions into routing tables, which are then pro cessed with different priorities by the SBAS routing engine. More details are presented in Appendix E. Routing engine. The SBAS routing engine compiles the routes from these BGP sessions and produces the ﬁnal for warding table that enforces the security/route preference re quirements of SBAS. In addition to enforcing that secure SBAS customer routes are used over standard Internet routes, the SBAS routing engine can be extended to consider which SCION paths are used to reach speciﬁc SBAS PoPs, enabling advanced route selection models such as carbonemission based routing [33]. See Appendix E for more details. Packet handling. Communications inside SCION (e.g., from the SIG interface to remote PoPs) do not use IP for addressing. In SBAS, we encapsulate a SCION packet into an IP packet, using Generic Routing Encapsulation [41], and maintain a static table at the SIG that contains a single entry per PoP, mapping its internal IP address to its SCION address. This enables us to have a uniﬁed IP routing table for both IP and nonIP packets. The actual routing of each packet can be performed efﬁciently by the Linux kernel. BGP connectivity. To provide PoPs with BGP connec tivity and an Internet routing table, we use the PEERING framework [72], which allows researchers to make BGP an nouncements and forward packets through peers and upstream transit providers. Using this component, our announcements are propagated to the worldwide BGP ecosystem. 6 Latency Evaluation Using the global deployment illustrated in Figure 12, we con duct a series of experiments measuring the latency achieved by SBAS in realistic scenarios. SBAS is competitive with Internet latency and even improves upon it in some cases, de spite running in a research testbed using mostly overlay links. Since the PoP components only introduce submillisecond overhead (Appendix A), we focus on SCIONLab overhead and endtoend latency in this section. The ﬁnal endtoend latency `S!Dbetween a source cus tomer S(connected to ingress PoP I) and a destination cus tomer D(connected to egress PoP E) is composed as follows: `S!D=`S!I+`E!D+Appendix Az}|{ 2delayPoP+Section 6.1z}|{ `I!E| {z } Section 6.2 6.1 Latency Optimization Between PoPs We demonstrate that the backbone network can be leveraged to optimize and even reduce latency between PoPs. By of 7"
22,QEMPAR: QoS and Energy Aware Multi-Path Routing Algorithm for Real-Time Applications in Wireless Sensor Networks.txt,"Enabling real time applications in wireless sensor networks requires certain
delay and bandwidth which pose more challenges in the design of routing
protocols. The algorithm that is used for packet routing in such applications
should be able to establish a tradeoff between end to end delay parameter and
energy consumption. In this paper, we propose a new multi path routing
algorithm for real time applications in wireless sensor networks namely QEMPAR
which is QoS aware and can increase the network lifetime. Simulation results
show that the proposed algorithm is more efficient than previous algorithms in
providing quality of service requirements of real-time applications.","In the recent years, the rapi d advances in microelectro mechanical systems, low po wer and highly integrated  digital electronics, small s cale energy supplies, tiny  microprocessors, and low power radio technologies have  created low power, low cost and multifunctional wireless  sensor devices, which can observe and react to changes in  physical phenomena of their environments. These sensor  devices are equipped with a small battery, a tiny  microprocessor, a radio transceiver, and a set of  transducers that used to gathering information that report the changes in the environment of the sensor node. The  emergence of these low cost and small size wireless sensor  devices has motivated intensive research in the last decade addressing the potential of collaboration among sensors in  data gathering and processing, which led to the creation of  Wireless Sensor Networks (WSNs).   A typical WSN consists of a number of sensor devices that  collaborate with each other to accomplish a common task (e.g. environment monitoring, target tracking, etc) and report the collected data th rough wireless interface to a  base station or sink node. The areas of applications of  WSNs vary from civil, healthcare and environmental to  military. Examples of applica tions include target tracking  in battlefields [1], habitat monitoring [2], civil structure  monitoring [3], forest fire detection [4], and factory  maintenance [5].   However, with the specific consideration of the unique  properties of sensor networks such limited power,  stringent bandwidth, dynamic topology (due to nodes  failures or even physical mobility), high network density and large scale deployments have caused many challenges  in the design and management of sensor networks. These  challenges have demanded energy awareness and robust protocol designs at all layers of the networking protocol  stack [6].   Efficient utilization of sensor’s energy resources and  maximizing the network lifetime were and still are the  main design considerations for the most proposed protocols and algorithms for sensor networks and have  dominated most of the research  in this area. The concepts  of latency, throughput and packet loss have not yet gained a great focus from the research community. However,  depending on the type of application, the generated  sensory data normally have different attributes, where it may contain delay sensitive and reliability demanding  data. For example, the data generated by a sensor network  that monitors the temperature in a normal weather  monitoring station are not re quired to be received by the  sink node within certain time limits. On the other hand, for a sensor network that used for fire detection in a forest,  any sensed data that carries an  indication of a fire should  be reported to the processing center within certain time limits. Furthermore, the introduction of multimedia sensor  networks along with the increasing interest in real time  applications have made strict constraints on both throughput and delay in order to report the timecritical IJCSI International Journal of Computer Sc ience Issues, Vol. 8, Issue 1, January 2011  ISSN (Online): 16940814  www.IJCSI.org   467 data to the sink within certain time limits and bandwidth  requirements without any loss.  These performance metrics  (i.e. delay, energy consumption and bandwidth) are  usually referred to as Quality of Service (QoS) requirements [7]. Therefore, enabling many applications in  sensor networks requires energy and QoS awareness in  different layers of the protocol stack in order to have efficient utilization of the network resources and effective  access to sensors readings. Thus QoS routing is an  important topic in sensor networks research, and it has been under the focus of the research community of WSNs.  Authors of [7] and [8] have surveyed the QoS based  routing protocol in WSNs.    Many routing mechanisms specifically designed for WSNs have been proposed [9][10]. In these works, the unique  properties of the WSNs have been taken into account.  These routing techniques can be classified according to the protocol operation into negotiation based, query based,  QoS based, and multipath based. The negotiation based  protocols have the objective to eliminate the redundant data by include high level data descriptors in the message  exchange. In query based protocols, the sink node initiates  the communication by broadcasting a query for data over the network. The QoS based protocols allow sensor nodes  to make a tradeoff between the energy consumption and  some QoS metrics before delivering the data to the sink node [11]. Finally, multipath routing protocols use  multiple paths rather than a single path in order to improve  the network performance in terms of reliability and robustness. Multipath routing establishes multiple paths  between the sourcedestinatio n pair. Multipath routing  protocols have been discussed in the literature for several  years now [12]. Mutlipath routing has focused on the use  of multiple paths primarily for load balancing, fault tolerance, bandwidth aggregation, and reduced delay. We  focus to guarantee the required quality of service through  multipath routing.   The rest of the paper organized as follows: in section 2, we  explain the related works. Section 3 describes the proposed algorithm with detailed. Section 4 explore the simulation  parameters and result analysis. Final section is containing  of conclusion and future works.   2. Related Works  "
57,Two-Hop Routing with Traffic-Differentiation for QoS Guarantee in Wireless Sensor Networks.txt,"This paper proposes a Traffic-Differentiated Two-Hop Routing protocol for
Quality of Service (QoS) in Wireless Sensor Networks (WSNs). It targets WSN
applications having different types of data traffic with several priorities.
The protocol achieves to increase Packet Reception Ratio (PRR) and reduce
end-to-end delay while considering multi-queue priority policy, two-hop
neighborhood information, link reliability and power efficiency. The protocol
is modular and utilizes effective methods for estimating the link metrics.
Numerical results show that the proposed protocol is a feasible solution to
addresses QoS service differenti- ation for traffic with different priorities.","Wireless Sensor Networks (WSNs) form a framework to accumulate and analyze real time data in smart environment applications. WSNs are composed of inexpensive lowpowered mi cro sensing devices called motes[1], having lim ited computational capability, memory size, ra dio transmission range and energy supply. These sensorsarespread in an environment without any predetermined infrastructure and cooperate to accomplish common monitoring tasks which usu ally involves sensing environmental data. With WSNs, it is possible to assimilate a variety of physical and environmental information in near real time from inaccessible and hostile locations. WSNs havea set ofstringentQoSrequirements that include timeliness, high reliability, availability and integrity. Various performance metrics that can be used to justify the quality of service include, packet reception ratio (PRR), deﬁned as the probability of successful delivery should be maximized. The endtoend delay which is in ﬂuenced by the queuing delay at the intermedi ate nodes and the number of hops traversed by the data ﬂows of the session from the source to the receiver. Sensor nodes typically use batteries for energy supply. Hence, energy eﬃciency and load balancing form important objectives while designing protocols for WSNs. Therefore, pro viding corresponding traﬃc diﬀerentiated QoS in such scenarios pose a great challenge. Our pro posed protocol is motivated primarily by the de ﬁciencies of the previous works (explained in the Section 2) and aims to provide better Quality of Service. 12 Shiva Prakash T, et al., Table 1 Our Results and Comparison with Previous Results for Diﬀerentiated QoS Routing in Wireless Sensor Networks. Related Protocol Considered Estimation Traﬃc Duplication Work Name Metrics Method Diﬀerentiation E. Felemban MMSPEED onehop delay, EWMA Delay Towards et al.,[2] (Multipath link reliability requirement the same and MultiSPEED and residual sink Routing Protocol) energy. M.M. DARA (Data onehop delay Variancebased Critical Towa rds OrRashid Aggregate and transmission Traﬃc and diﬀerent et al.,[3] Routing power. NonCritical sinks Algorithm) Traﬃc Y. Li THVR (TwoHop twohop delay WMEWMA No No et al.,[4] Velocity Based and residual Routing Protocol) energy. D. Djenouri LOCALMOR onehop delay EWMA and Regular, Toward s et al.,[5] (Localized link reliability WMEWMA Reliability Multiobjectives residual energy sensitive,Delay, sink s Routing) and transmission sensitive and power. Critical Traﬃc This paper TDTHR twohop delay, EWMA and Regular, Towards (Traﬃc link reliability WMEWMA Reliability diﬀerent Diﬀerentiated residual energy Responsive,Delay, sinks TwoHop and transmission Responsive and Routing) power. Critical Traﬃc This paper explores the idea of incorporating QoS parameters in making routing decisions the protocol proposes the following features. 1. Data traﬃc is split into regular traﬃc with no speciﬁc QoS requirement, reliability responsive traﬃc; which should be trans mitted without loss but can tolerate some delay, delayresponsivetraﬃc; which should be delivered within a deadline but may tol erate moderate packet loss and critical traf ﬁc; which has high signiﬁcance and de manding both high reliability and short de lay. 2. Link reliability is considered while choos ing the next router, this selects paths which have higher probability of successful deliv ery. 3. Routing decision is basedon twohopneigh borhood information and dynamic velocity that can be modiﬁed according to the re quired deadline, this results in signiﬁcant reduction in endtoend PRR. 4. Choosing nodes with higher residual energy and minimum transmission power, balancesthe load among nodes and results in pro longed lifetime of the network. We test the performance of our proposed ap proaches by implementing our algorithms using ns2simulator. Ourresultsdemonstratestheper formance and beneﬁts of TDTHR over earlier al gorithms. The rest of the paper is organized as follows: Section 2 gives a review of related works. Section 3 and Section 4 explain the network model, nota tions, assumptions and working of the algorithm. Section 5 is devoted to the simulation and evalu ation of the algorithm. Conclusions are presented in Section 6. 2. Related Work "
467,Joint Design of Congestion Control Routing With Distributed Multi Channel Assignment in Wireless Mesh Networks.txt,"In Wireless Mesh Networks (WMN), a channel assignment has to balance the
objectives of maintaining connectivity and increasing the aggregate bandwidth.
The main aim of the channel assignment algorithm is to assign the channels to
the network interfaces, from the given expected load on each virtual link. From
the existing work done so far, we can examine that there is no combined
solution of multi-channel assignment with routing and congestion control. In
this paper, we propose a congestion control routing protocol along with
multi-channel assignment. We use a traffic aware metric in this protocol in
order to provide quality of service. The proposed protocol can improve the
throughput and channel utilization to very high extent because it provides
solution for multi-channel assignment and congestion control. The proposed
algorithm assigns the channels in a way that, congestion is avoided and
co-channel interference levels among links with same channel are reduced. By
our simulation results in NS2, we show that the proposed protocol attains high
throughput and channel utilization along with reduced latency.","Wireless mesh networks (WMNs) contains many  stationary wireless routers which are interconnected by the  wireless links. For the wireless mobile devices these wireless  routers acts as the access points (APs) and some of them act as  gateways to the internet through the high speed wired links.  Wireless mobile devices transfer data to the associated  wireless router and these data are then transferred in a multi hop manner to the internet through the intermediate wireless  routers. Wireless mesh networks are popular because they are  capable to credit their low cost and their auto organizing  features [1].   Topology discovery, traffic profiling, channel assignment  and routing are required in the multichannel wireless mesh  network architecture [3].  The static aggregation nodes which  are similar to wireless LAN access points are comprised in the  multichannel wireless mesh networks. Since the 802.11b  interface hardware handles the bandwidth problem efficiently,  it is used in the construction of the multichannel mesh  network. Each node in a multichannel wireless mesh network  consists of multiple 802.11 complaint NICs. Each of these is tuned to a particular radio channel for a long period of time  such as hours or days [3].    The network congestion is caused due to the interference  between neighboring links. The aggregated throughput will be  reduced for the TCP data connections if the links becomes  congested. To reduce the interference due to the neighboring  transmission of the same channel, an efficient channel  assignment algorithm is necessary [2].     Maintaining connectivity and increasing aggregate  bandwidth are the two goals, a channel assignment algorithm  has to balance.  Binding each network interface to a radio  channel is the objective of the channel assignment in a multi channel wireless mesh network. This is done in a way such  that the available bandwidth on each virtual link is  proportional to its expected load. The channel assignment is  based on the network topology information [3]. With the help  of some outside agency and by the changes which occurs  rarely, the channel assignment is estimated [4]. To support the  dynamic channel assignment, the fixed channel assignment  scheme can be easily extended [5].     The routing consists of traffic from the mobile nodes to  any access point (called Internet gateway) and response traffic  back to the mobile nodes [7]. Routing is based on the scalar  potential fields and not on the route entries. Mostly alternative  routes are estimated without additional overhead when the  primary route fails. The routing algorithms mainly focus on  improving the network capacity or the performance of  individual transfers rather than copying with mobility or  reducing the power utility [8].   From the existing work done so far, we can observe that,  no work is done on the combined solution of multi channel  assignment with routing protocol and congestion control. Also  the use of a traffic aware metric can be investigated which  could optimize the capacity of the network.   In this paper, we propose a congestion control routing  protocol along with multichannel assignment. In this  protocol, we use traffic aware metric to provide quality of  service. Since it provides solution for multi channel  assignment and congestion control, the proposed protocol can  improve the throughput and channel utilization to very high  extent.    .  (IJCSIS) International Journal of Computer Science and Information Security,  Vol. 7, No. 3, March 2010  261 http://sites.google.com/site/ijcsis/  ISSN 19475500 II. RELATED WORK  "
463,Performance Analysis of RFDMRP:River Formation Dynamics based Multi-Hop Routing Protocol in WSNs.txt,"In Wireless sensor networks, sensor nodes sense the data from environment
according to its functionality and forwards to its base station. This process
is called Data collection. The Data collection process is done either directly
or by multi-hop routing. In direct routing, every sensor node directly
transfers its sensed data to base station which has an impact on energy
consumption from sensor node due to the far distance between the sensor node
and base station. In multi-hop routing, the sensed data is relayed through
multiple nodes to the base station, it consumes less energy. This paper
presents and analyzes the performance of a data collection routing protocol
called RFDMRP: River Formation Dynamics based multi-hop routing protocol. The
performance of RFDMRP is tested and analyzed for network parameters such as
Network lifetime, Energy usage, and Node density & data aggregation impact on
network lifetime. The simulated results are compared with two algorithms LEACH
and MOD_LEACH. The comparison reveals that the proposed algorithm performs
better than LEACH and MOD_LEACH with respect to Network lifetime.","Wireless Sensor Networks [1{3] (WSNs) are widely used in various real time applications such as military, medical, disaster detection, structural monitoring, etc. These WSNs consists of huge set of small sensor nodes, deployed in the envi ronment for monitoring environmental conditions such as humidity, temperature, pressure, etc. The wireless sensor nodes sense the data from environ ment based on the application and forwards to the central base station or sink for further processing [4]. This process is called data collection, which is the primary task of the WSNs. In data collec tion process [4], the sensor nodes forward the data to the central base station either by direct com munication or by multihop communication. The direct communication from sensor node to base station is energy expensive due the distance be tween sensor nodes and base station is more, this reduces the lifetime of the network. Alternatively, Multihop communication [5{7] schemes are usedfor better network lifetime and performance due to its eective utilization of resources. In multi hop communication, every sensor node is busy in forwarding the sensed/received data to nearest intermediate (neighbor) nodes or to the base sta tion using multihop routing paths. In this pro cess, selection of next (neighbor) node in routing path is very important for forwarding data. The next node or forwarding node in the routing path is not only meant for relaying the data, but also useful for aggregating the data. Data aggrega tion or Data fusion techniques are used to reduce the size of the data packet to be transmitted to next node by aggregating the data or by eliminat ing similar data, received from previous nodes [2]. Multihop techniques improve the energy conser vation of node and the lifetime of the network. Swarm intelligence is one of the mechanism used for nding the suitable nodes in the routing path between sensor nodes and the base station. In WSNs, swarm intelligence mechanisms [8{10] 1arXiv:1602.04980v1  [cs.NI]  16 Feb 20162 Koppala Guravaiah and R. Leela Velusamy such as ant colony, bee colony, etc., are already used to select the next node in the routing path. A nature inspired mechanism known as River For mation Dynamics (RFD) [11] can be introduced in WSNs for suitable node selection in multihop routing. RFD mechanism is free from local cy cles and this is one of the facts making it suitable for path nding in WSNs. The RFDMRP (River formation Dynamics based MultiHop Routing Protocol) was proposed for WSNs by exploring the applicability of RFD mechanism in path nd ing [12]. The two parameters hop count distance and residual energy are used by RFD for select ing the suitable nodes. In this paper, the per formance of RFDMRP is analyzed and compared with the existing algorithm such as LEACH and MOD LEACH. The Node density, data aggrega tion, network lifetime, and energy consumption are used for comparison. Henceforth the paper is organized as follows: Section 2 discusses the conceptual RFD and ra dio energy model. The related work is explained in Section 3. Section 4 describes the problem statement. The RFDMRP data collection proto col implementation details is discussed in Section 5. The simulation results are analyzed and com pared in Section 6. Finally, Section 7 concludes the paper. 2. BACKGROUND 2.1. River Formation Dynamics (RFD) RFD [11] is one of the heuristic optimization method and a subset topic of swarm intelligence. RFD is based on replicating the concept of how water drops combine to form rivers and rivers in turn combine to join the Sea by selecting the shortest path based on altitudes of the land through which they  ow. In the process of river formation, the water drops are always  owing from higher altitude position to lower altitude positions. Since, the slope of the two positions is more, then the water  owing from higher po sitions to lower positions erode and carry the eroded soil to be deposited in the lower positions. By this deposit the altitude of the lower position get increased. Also shortest path is formed from higher to lower position.Algorithm 1 General RFD algorithm procedure RFD Algorithm //Stage I: Initialization Stage Initialization of Drops generating positions; Initialization of Intermediate positions; Initialization of Destination(Sea) positions; //Stage II: River Formation Stage while (not all drops Flow The Same Path) and (not other Ending Condition) do selectForwardPosition (); moveDrops (); erodePath (); addSediments (); end Analyze the paths; end procedure The basic algorithm of RFD is given in Algo rithm 1. This algorithm mainly consist of two stages viz., Initialization stage and River forma tion stage. In initialization stage, three dier ent positions (called water drop generating posi tions or Source(S), intermediate positions(I), and destination(D) or sea) are initialized. All these positions are represented with dierent altitude values (S and I are represented with positive alti tude values and D is represented with Zero). The water drop generating positions always generates water drops. The intermediate positions receives the water drops from source and forward towards the Sea. In river formation stage, the river is created between drop generating positions and Sea using the iterative process having the func tionsselectForwardPosition (),moveDrops (), erodePath (), andaddSediments (). The it erative process is repeated until either all drops follow the same path or satisfying the other ending conditions such as limited num ber of iterations, limited execution time. In selectForwardPosition (), the drop generating positions select the next neighbor positions for forwarding the drops based on the probability functionP(i;j) in Equation 1, where i, j are the positions such that ( iSoriI) and (jIorjD). The probability function P(i;j) indicates that aPerformance Analysis of RFDMRP 3 positionihaving the probability to select the po sitionjas a next hop position for forwarding drops. P(i;j) =8 < :DG(i;j) P lNb (i)DG(i;l)ifjNb (i) 0 Otherwise(1) whereNb(i) is the neighbor positions of position iand where DG(i;j) is Decreasing Gradient be tween node iand nodejand it can be calculated using the following Equation 2 DG(i;j) =(altitude (i)"
464,Link-Reliability Based Two-Hop Routing for Wireless Sensor Networks.txt,"Wireless Sensor Networks (WSNs) emerge as underlying infrastructures for new
classes of large scale net- worked embedded systems. However, WSNs system
designers must fulfill the Quality-of-Service (QoS) requirements imposed by the
applications (and users). Very harsh and dynamic physical environments and
extremely limited energy/computing/memory/communication node resources are
major obstacles for satisfying QoS metrics such as reliability, timeliness and
system lifetime. The limited communication range of WSN nodes, link asymmetry
and the characteristics of the physical environment lead to a major source of
QoS degradation in WSNs. This paper proposes a Link Reliability based Two-Hop
Routing protocol for wireless Sensor Networks (WSNs). The protocol achieves to
reduce packet deadline miss ratio while consid- ering link reliability, two-hop
velocity and power efficiency and utilizes memory and computational effective
methods for estimating the link metrics. Numerical results provide insights
that the protocol has a lower packet deadline miss ratio and longer sensor
network lifetime. The results show that the proposed protocol is a feasible
solution to the QoS routing problem in wireless sensor networks that support
real-time applications.","Wireless Sensor Networks (WSNs) form a framework to accumulate and analyze real time data in smart environment applications. WSNs are composed of inexpensive lowpowered mi cro sensing devices called motes[1], having lim ited computational capability, memory size, radio transmission range and energy supply. Sensors are spread in an environment without any prede termined infrastructure and cooperate to accom plish common monitoring tasks which usually in volves sensing environmental data. With WSNs, it is possible to assimilate a variety of physicaland environmental information in near real time from inaccessible and hostile locations. WSNs have a wide variety of applications in military, industry, environment monitoring and health care. WSNs operate unattended in harsh environments, such as border protection and bat tleﬁeld reconnaissancehencehelp to minimize the risk to human life. used of WSNs are used ex tensively in the industry for factory automation, processcontrol,realtimemonitoringofmachines, detection of radiation and leakages and remote monitoring of contaminated areas, aid in detect ing possible system deterioration and to initiate 12 Shiva Prakash T, et al., Table 1 Our Results and Comparison with Previous Results for QoS Routing in W ireless Sensor Networks. Related Protocol Considered Estimation Performance Work Name Metric Method Tian He SPEED (Stateless onehop delay EWMA (Exponential Im proves endtoend delay et al.,[2] Protocol for and residual energy Weighted Moving and pro vides good response EndtoEnd Delay) Average) to congestion. E. Felemban MMSPEED onehop delay, EWMA (Exponential Provi des service et al.,[3] (Multipath and link reliability Weighted Moving diﬀer entiation and MultiSPEED and residual energy Average) QoS guarantee in t he Routing Protocol) timeliness and reliability domains. Chipera RPAR (RealTime onehop delay and Jacobson Algorit hm Provides realtime routing et al.,[4] Power Aware transmission power and dynamic power adapti on Routing) to achieve low delays at optimal energy cost. Y. Li THVR (TwoHop twohop delay and WMEWMA (Window Routing decision is made et al.,[5] Velocity Based residual energy Mean Exponential based o n twohop velocity Routing Protocol) Weighted Moving integrated with energy Average balancing mechanism which achieves lower DMR. This paper RTLRR twohop delay, EWMA (Exponential The proto col considers link (Realtime link reliability Weighted Moving reliability a nd uses Link Reliability and residual energy Average) and dynamic v elocity as per Routing) WMEWMA the desired deadline, energy is eﬃciently balanced among the nodes. precautionary maintenance routine before total system breakdown. WSNs are being rapidly de ployed in patient health monitoring in a hospital environment, where diﬀerent health parameters are obtained and forwarded to health care servers accessible by medical staﬀ and surgical implants ofsensorscanalsohelp monitor apatients health. Emerging WSNs have a set of stringent QoS requirements that include timeliness, high reli ability, availability and integrity. The compe tence of a WSN lies in its ability to provide these QoS requirements. The timeliness and reliability levelfordataexchangedbetweensensorsandcon trolstationisofparamountimportanceespecially in real time scenarios. The deadline miss ratio (DMR) [6], deﬁned as the ratio of packets that cannot meet the deadlines should be minimized. Sensor nodes typically use batteries for energy supply. Hence, energy eﬃciency and load bal ancing form important objectives while designing protocols for WSNs. Therefore, providing cor responding QoS in such scenarios pose to be agreat challenge. Our proposed protocol is moti vated primarilyby the deﬁciencies ofthe previous works (explained in the Section 2) and aims to provide better Quality of Service. This paper explores the idea of incorporating QoS parameters in making routing decisions i.e.,: (i) reliability (ii) latency and (iii) energy eﬃ ciency. Traﬃc should be delivered with reliability and within a deadline. Furthermore, energy eﬃ ciency is intertwined with the protocol to achieve a longer network lifetime. Hence, the protocol is named, Link Reliability based TwoHop Routing (LRTHR). The protocol proposes the following features. 1. Link reliability is considered while choos ing the next router, this selects paths which have higher probability of successful deliv ery. 2. Routing decisionis based on twohopneigh borhood information and dynamic veloc ity that can be modiﬁed according to theLinkReliability Based TwoHop Routing for Wireless Sensor Networks 3 required deadline, this results in signiﬁ cant reduction in endtoend DMR (dead line miss ratio). 3. Choosing nodes with higher residual energy balances, the load among nodes and results in prolonged lifetime of the network. The proposed protocol is devised using a modu lardesign,separatemodulesarededicatedtoeach QoS requirement. The link reliability estimation and link delay estimation modules use memory and computational eﬀective methods suitable for WSNs. The node forwarding module is able to make the optimal routing decision using the esti mated metrics. We test the performance of our proposed approaches by implementing our algo rithms using ns2 simulator. Our results demon strates the performance and beneﬁts of LRTHR over earlier algorithms. The rest of the paper is organized as follows: Section 2 gives a review of Related Works. Sec tion 3 and Section 4 explains the Network Model, notations, assumptions and working of the algo rithm. Section 5 is devoted to the Simulation and Evaluationofthe algorithm. Conclusionsarepre sented in Section 6. 2. RELATED WORK "
237,Learning Structured Communication for Multi-agent Reinforcement Learning.txt,"This work explores the large-scale multi-agent communication mechanism under
a multi-agent reinforcement learning (MARL) setting. We summarize the general
categories of topology for communication structures in MARL literature, which
are often manually specified. Then we propose a novel framework termed as
Learning Structured Communication (LSC) by using a more flexible and efficient
communication topology. Our framework allows for adaptive agent grouping to
form different hierarchical formations over episodes, which is generated by an
auxiliary task combined with a hierarchical routing protocol. Given each formed
topology, a hierarchical graph neural network is learned to enable effective
message information generation and propagation among inter- and intra-group
communications. In contrast to existing communication mechanisms, our method
has an explicit while learnable design for hierarchical communication.
Experiments on challenging tasks show the proposed LSC enjoys high
communication efficiency, scalability, and global cooperation capability.","Reinforcement learning (RL) has achieved remarkable success in solving singleagent sequential decision problems under interactive and complicated environments, such as games [13, 18] and robotics [10]. In many realworld applications such as intelligent transportation systems [1] and unmanned systems [17], not only one, but usually a large number of agents are involved in the learn ing tasks. Such a setting naturally leads to the popular multiagent reinforcement learning (MARL) problems, where the key research challenges include how to design scalable and ecient learning schemes under a nonstationary environment (caused by partial observation and/or the dynamics ∗School of Computer Science and Technology, East China Normal University, Shanghai 200092, China. (Email: 52194501003@stu.ecnu.edu.cn) †School of Computer Science and Technology, East China Normal University, Shanghai 200062, China. (Email: xfwang@sei.ecnu.edu.cn) ‡School of Computer Science and Technology, East China Normal University, Shanghai 200062, China. (Email: bjin@cs.ecnu.edu.cn) §Department of Computer Science and Engineering, Articial Intelligence Institute, Shanghai Jiao Tong University, Shanghai 200240, China. (Email: yanjunchi@sjtu.edu.cn) ¶School of Computer Science and Technology, East China Normal University, Shanghai 200092, China. (Email: 52194501026@stu.ecnu.edu.cn) /uni2016School of Science and Engineering, The Chinese University of Hong Kong (Shenzhen), Shenzhen, China. (Email: tsunghui.chang@ieee.org) ∗∗School of Computer Science and Technology, East China Normal University, Shanghai 200062, China. (Email: jwang@sei.ecnu.edu.cn) ††School of Computational Science and Engineering, College of Computing, Georgia Institute of Technology, USA. (Email: zha@cc.gatech.edu) 1arXiv:2002.04235v1  [cs.LG]  11 Feb 2020of other agents' policies) with large and/or dynamic problem dimension, and complicated uncertain relationship between agents. (a) Fullyconnected  (b) Star Step 1 Step 2Step 3 (c) Tree  (d) Neighboring  (e) Hierarchical Figure 1: Topology of dierent communication structures, and LSC falls into the hierarchical one. Learning to communicate eectively among agents has shown crucial to strengthen the inter agent collaboration and ultimately improve the quality of policies learned by MARL. In this paper, we categorize the existing designs for communication topology1into four patterns: i) Fullyconnected: DIAL [4], TarMAC [3] and SchedNet [9] use fullyconnected communication structure (see Fig. 1(a)). Agents need to communicate with all the others, thus requiring high bandwidth when the number of agents is large. ii) Star: CommNet [4] and IC3 [19] assume star communication structure (see Fig. 1(b)). All agents need to transmit messages to the virtual central agent, incurring a major communication bottleneck. iii) Tree: ATOC [8] uses a tree communication structure. Agents only communicate with neighbors. However, communication must be allowed sequentially among groups, leading to high time complexity. iv) neighboring: DGN [7] uses neighboring communication structure. Agents communicate with neighbors concurrently to reduce communication costs. We further analyze the above communication topology patterns by considering the accessibility and comprehension of messages for eective communication. Both the fullyconnected structure and star structure ensure messages are accessible for all agents. While as discussed in ATOC [8], once a large number of messages emerge concurrently, extracting valuable information would become dicult. Tree structure and neighboring structure constrain the communication to neighbors and hence is able to improve message comprehension. To achieve global accessibility, they dene neighbors asKnearest agents and utilize multiround communications. However, due to the lack of pooling mechanism, DGN [7] incurs two rounds of convolutions in communication; thus, only the information from twohop distant agents is aggregated. In this paper, we are aimed to improve both ecient message accessibility and eective message comprehension for largescale MARL by proposing the socalled Learning Structured Communication (LSC ) approach. Specically, our LSC contains a structured communication module and a communication based policy module. It aims to establish a hierarchical communication structure for learning the communication pattern as well as policy. In particular, a hierarchical communication structure (Fig. 1(e)) is established in a distributed fashion by a clusterbased routing protocol. To make the structure be formed dynamically for better cooperation, an auxiliary reinforcement task is designed to learn the communication weight in the endtoend fashion. In the hierarchical structure, agents are grouped to dierent groups, and every group is assigned with a highlevel agent. We design an intrainter group communication mechanism to achieve global communication eciently. Intergroup communication can help agents to capture global information better while intragroup communica tion helps negrained message exchanges. With these two modules, our experiments show that LSC can eciently achieve global communication eciency. The main highlights of this paper are summarized below. 1) We summarize the four existing categories of communication topology in the MARL literature, namely i) fullyconnected, ii) star, iii) tree, and iv) neighboring, which are in general manually 1We interchangeably abuse the term topology and structure. 2specied and xed. We believe this perspective is enlightening for the design of new communication topology, given the fact that it has not been well organized in the existing literature. 2) We develop a new hierarchical communication topology LSC, which diers from the existing four patterns. Our approach allows for an adaptive formation of agents by dynamically grouping agents via a reinforcement learning procedure combined with a routing protocol. The messages can be jointly extracted and propagated through both intra and intergroup communications via a hierarchical graph neural network. 3) Experimental results show that the proposed LSC yields promising results on public bench marks in terms of communication eciency, scalability, and global cooperation capability. To our best knowledge, the current paper is the rst work about hierarchical communication learning in MARL. We note that the idea of adopting hierarchical structure learning on MARL recently appears in HAMA [16]. The dierences are obvious and fundamental: rst, their hierarchy structure is used for learning agents' relation, but not for communication; second, their hierarchy design is xed, other than adaptive and dynamically learned as done in this paper. 2 Related Work "
122,Dynamic Address Allocation Algorithm for Mobile Ad hoc Networks.txt,"A Mobile Ad hoc network (MANET) consists of nodes which use multi-hop
communication to establish connection between nodes. Traditional infrastructure
based systems use a centralized architecture for address allocation. However,
this is not possible in Ad hoc networks due to their dynamic structure. Many
schemes have been proposed to solve this problem, but most of them use
network-wide broadcasts to ensure the availability of a new address. This
becomes extremely difficult as network size grows. In this paper, we propose an
address allocation algorithm which avoids network-wide broadcasts to allocate
address to a new node. Moreover, the algorithm allocates addresses dynamically
such that the network maintains an ""IP resembles topology"" state. In such a
state, routing becomes easier and the overall overhead in communication is
reduced. This algorithm is particularly useful for routing protocols which use
topology information to route messages in the network. Our solution is designed
with scalability in mind such that the cost of address assignment to a new node
is independent of the number of nodes in the network.","variety of addressing schemes have been proposed to  efficiently allocate addresses to no des in Mobile Adhoc  Networks (MANETs). Following are the desirable properties  for addressing schemes in a MANET:   1. Desired Properties of a n Addressing Scheme:    Unique address allocation   A unique address should be allocated to all nodes joining  the network. Th ere are 2 ways to ensure this: Duplicate  Address Detection (DAD) i.e. to make sure an address is  available before assigning it to a node, or using disjoint  address tables to make sure that there is no need for a DAD.     Low overhe ad  The communication overhea d for address assignment  should be low. This means that network wide broadcasts for  address allocation should be avoided.    Network partitions   The addressing scheme should allocate addresses in such a  way that network partitions can be handled easily.    Networ k joins   Network joins are generally associated with a change of  address for a large number of nodes. The addressing algorithm  should work well in this scenario or else it may cause a  congestion in the network.    Zero configuration   The algorithm should config ure itself automatically with  minimum human involvement. This means that address  allocation and claiming free addresses should be done  automatically and dynamically.    Robust towards moving nodes   In MANETs, node move frequently which means that the  path from  node A to node B will change continuously. The  addressing scheme should make this process of finding new  paths easier.    In this paper, we propose an Address allocation algorithm  that attempts to perform the tasks of address allocation and  management in a scalable way by localizing the  communication between nodes for these tasks. We do this by  forming local clusters in the network and assigning a pool of  addresses to this cluster. From here, it is the cluster’s  responsibility to maintain the address table f or this pool of  addresses.   II. RELATED WORK   "
35,"Energy and performance evaluation of reactive, proactive, and hybrid routing protocols in wireless mesh network.txt","This paper evaluates the energy consumption of well-known routing protocols,
along with other metrics such as throughput, packet delivery ratio (PDR), and
delay in different scenarios. We consider two other metrics in order to capture
the efficiency of the energy consumption: e-throughput which is the ratio
between the consumed energy and the throughput; and the e-PDR which is the
ratio between the consumed energy and the PDR. We compare four routing
protocols: AODV, OLSR, and HWMP in Reactive and Proactive modes. The number of
nodes is varying between 25 and 81 nodes, with different mobility models.
Simulations are conducted using NS3 and the parameters of a real network
interface card. From the results, AODV presents the lowest energy consumption
and a better e-Throughput. OLSR provides a better e-PDR in mobile scenarios.
With a smaller e-PDR and e-Throughput, the proactive mode of HWMP is more
energy efficient than the reactive mode.","  Since thei r introduction more than two decades ago, wireless networks are presented as an  appealing solution to connect devices especially i n difficult towire areas. Based on an  infrastructure or not, they are more preferred than wire networks. When the wireless ne twork is  not based on a central infrastructure, it is said to be in ad hoc mode. A wireless ad hoc network  is self organized, that  means it can reconfigure itself when a node joins or leaves the network.  When nodes are mobile, we talk about mobile ad hoc n etworks usually shortened MANETs [1].  Communication between a pair of nodes in a MANET can be done by sending messages  through a s et of intermediate nodes, which may act as routers. When a node fails,  communication in a MANET can still continue as long as the rest of the network is not  partitioned. This characteristic provides some robustness to the network. MANETs can be  considered as a type of wireless mesh networks (WMN), more precisely client mesh network  [2].     During the communication, the path followe d by a message in a MANET or a WMN depends  on the routing protocol mainly defined at the network layer. Depending on their routin g  policies, routing protocols can be classified into three types: reactive, proactive, and hybrid. The  latter type encompasses two modes: reactive and proactive modes. Routing policies play a     central role on the energy consumption and the performance of the network, which can be also          International Journal of Wireless  & Mobile Networks (IJWMN) Vol. 1 1, No. 1, February 201 9    14   influenced by the topology (dynamic or not) of the network.     Quite a lot of routing protocols as we ll as performance factors have been proposed by the  IETF’s MANET working group. However, related energy factors have not be co nsidered [1].  The energy consumption is therefore still a crucial issue, regardless the lot of works which has  been focused on the  improvement of routing protocols performance. This issue is more critical  when nodes are powered essentially by a limited sou rce, as it is the case in most scenarios in  MANETs and in some recent scenarios in WMNs. In fact, mesh routers whose had fixed  locations and were powered by grid energy, have started to be equipped with batteries like in  robots [3]. In addition, most WMNs in rural or remote regions are powered by generator or solar  panels [4][5][6][7]. These trends rise the crucial need of studying n ot only the performance  factors of the routing protocols in MANETs and WMNs, but also their energy consumption.  Despite the pl ethora of works focusing on the evaluation of routing protocols performance in  wireless networks, only few works have been devoted  to the estimation of energy consumption  [8][9]. An interesting survey on energy efficient routing schemes for MANETs is provi ded in  [10].     This paper provides an evaluation of the energy consumption and performance metrics of three  types of routing protoco ls: AODV (reactive), OLSR (proactive), HWMP (hybrid) in reactive  and proactive modes. In addition, to portrait the energy efficiency of selected routing protocols,  two other metrics are used: e throughput determined by the ratio between the consumed energy   and throughput, and the e PDR determined by the ratio between the consumed energy and the  PDR.     The rest of the paper is org anized as follow: the selected routing protocols are presented in  Section 2. Section 3 presents earlier works on the evaluation of p erformance and energy  consumption in routing protocols. The simulation parameters and scenarios are described in  section 4. Simulation results are presented and discussed in section 5.     2. SELECTED ROUTING PROT OCOLS     Three type of routing protocols have been  selected for the comparison : AODV as reactive  protocol, OLSR  as proactive protocol, and HWMP in reactive and proactive mo de as hybrid  protocol.     2.1. AODV     AODV (Ad hoc On Demand Distance Vector) remains the most popular routing protocols  among all the reac tive ones. It is inspired from distance vector protocol such as DSDV and DSR  and serves as a basis for several other rea ctive routing protocols. It has been defined in RFC  3561[12]. It enables dynamic, self starting, multihop routing between mobile nodes i n an ad hoc  network.     AODV starts with a route discovery process before transmitting data. The route discovery  process determines a unicast route to the destination. During this stage, a route request RREQ  packet is flooded from the sending node to its nei ghbours. Each of its neighbours which receive  this packet forwards this packet to their neighbours until the destinatio n is found. Once the  destination is reached, a route reply RREP packet is sent by the initial sender by considering the  route to the sour ce contained in the RREQ packet. This packet follows the reverse path taken by       International Journal of Wireless  & Mobile Networks (IJWMN) Vol. 1 1, No. 1, February 201 9    15   the RREQ, and the route to the destinati on is updated in all intermediate nodes. The discovery  process ends when RREP reaches the initial sender. Data transmission can therefore  start. The  operation of AODV is loop free due to the use of destination sequence number as described in  [12].     A link  may be broken, resulting in an error during data transmission. In this case, the affected  set of nodes is notified so that they are able to invalidate the routes using the lost link. To  achieve this, a route error RERR packet is sent. Moreover, routes tha t are not in active  communication are not maintained: it is the maintenance process.     2.2. OLSR     OLSR (Optimized Link State Routing protocol ) is the most popular proactive routing protocol.   It has been defined in its first version in RFC 3626 [13] in 2003  and later in RFC 7181 in 2014.  In its first version, which is also the most implemented, the route is build beforehand for data  transmissio n by maintaining a routing table at each node. OLSR make therefore use of the  following mechanisms as described in [ 13]:    • Link Sensing: it checks the connectivity between nodes by sending periodic HELLO  messages over the interfaces through which connectivit y is checked.   • Neighbour detection: In a network with only single interface nodes as it is our case, the  neighbour set of a node may be deducted from the information exchanged as part of link  sensing.   • MPR Selection and MPR Signalling:  Multipoint relays (M PRs) nodes are a set of  special nodes selected by each node in its neighbourhood. When a node generates a  broadcast  message, it is retransmit only by MPRs, in such a way that this message will  be received by all nodes 2 hops away.   • Topology Control Message  Diffusion: OLSR being a table driven routing protocol, the  routing table at each node is constructed using topolog y control by the means of  Topology Control (TC) packets. Those TC packets are forwarded only by MPR.   • Route Calculation: The routing table at  each node, containing sufficient link state  information, will be used for route calculation. The link state inform ation is acquired  through periodic message exchange, or through the interface configuration.     2.3. HWMP (R and P)     HWMP  (Hybrid Wireless Mesh P rotocol)  has been defined in IEEE 802.11s and dedicated to  Wireless Mesh Networks [14]. It supports two modes of operation depending on the  configuration: reactive mode and proactive mode. It makes use of four types of control  messages: Route Request (RREQ ), Route Reply (RREP), Root Announcement (RANN), and  Route Error (RERR).     HWMP is essentially a reactive protocol  to which a proactive mechanism has been added in  order to permit a node to announce itself as the root of a tree based topology. In this paper,  we  consider both operation modes. When a source mesh point (MP) needs to find a route in reactive  mode, it broa dcasts a RREQ indicating a destination MP and the metric field being initialized to  0. A MP creates a route to the source or updates its current  route when it receives a RREQ.  When a new route is created or an existing route is modified, the RREQ is forwar ded.  Each MP  may receive multiple copies of the same RREQ coming from the source, but each copy has a       International Journal of Wireless  & Mobile Networks (IJWMN) Vol. 1 1, No. 1, February 201 9    16   unique path from the source to the MP.  T he destination MP sends a unicast RREP back to the  source after creating or updating a route to the source. Two important mechanisms are defined:  “Destination Only” (DO) flag which indicates whether intermediate MP can generate a RREP;  and “Reply and Forwa rd (RF)” flag which indicates whether an intermediate MP can forward a  RREQ. When intermediate MPs receive the R REP, they create a route to the destination, and  then forward the RREP toward the source. The source creates a route to the destination on  recei ving the RREP.     3. RELATED WORK   "
14,Geographic Routing with Limited Information in Sensor Networks.txt,"Geographic routing with greedy relaying strategies have been widely studied
as a routing scheme in sensor networks. These schemes assume that the nodes
have perfect information about the location of the destination. When the
distance between the source and destination is normalized to unity, the
asymptotic routing delays in these schemes are $\Theta(\frac{1}{M(n)}),$ where
M(n) is the maximum distance traveled in a single hop (transmission range of a
radio). In this paper, we consider routing scenarios where nodes have location
errors (imprecise GPS), or where only coarse geographic information about the
destination is available, and only a fraction of the nodes have routing
information. We show that even with such imprecise or limited
destination-location information, the routing delays are
$\Theta(\frac{1}{M(n)})$. We also consider the throughput-capacity of networks
with progressive routing strategies that take packets closer to the destination
in every step, but not necessarily along a straight-line. We show that the
throughput-capacity with progressive routing is order-wise the same as the
maximum achievable throughput-capacity.","The availability of cheap wireless technology and the emerg ence ofmicrosensorsbasedonMEMStechnologywillenabletheub iq uitous deployment of sensor networks [24, 1, 5]. Applicatio ns for sensor networks include robust communication, intrusion d etec tion and commercial applications involving macroscale me asure mentsandcontrol. Suchnetworksarecharacterizedbytheab sence of any largescale established infrastructure, and nodes c ooperate byrelayingpacketstoensurethatthepacketsreachtheirre spective destinations. A popular routing algorithm for sensor network that has been widely studied is geographic routing [12, 13, 11, 6]. The mai n idea is to forward a packet to a node that is closer to the ﬁnal destination than the current packet position (a greedy forw arding Department of Electrical and Computer Engineering, The Uni  versity of Texas at Austin. This research was supported by NS F Grants ACI0305644, CNS0325788, and CNS0347400. Email: {ssubrama,shakkott }@ece.utexas.edu.S DA D SANo Congestion Congestion (ii) No Hotspots(i) (iii) (iv)Hotspot (a)   Hotspots in a network (b) Jump Configurations Fig.1. Random Routing strategy). Whengreedyforwardingfails(duetodeadendso rrout ing loops), alternate routing methods such as perimeter rou ting, or route discovery based methods (using ﬂooding) have been p ro posed [13,12]. In this paper, we study the problem of geographic routing with limited or erroneous destinationlocation informati on. For instance, suppose that nodes only know the quadrant or the ha lf plane on which the ﬁnal destination is. A node could then ran domlyforward the packet to an arbitrary node that is in that di rection. As another example, suppose that nodes have the cor rect destination coordinates. However, the GPSatnodes are erro neous (andpossiblybiased),asaresultofwhichpacketsareroute dinthe wrong direction. 1.1. MainContributions We consider a largescale network where nodes are deployed o ver a unit region. Each node’s maximum transmission range is sca led asM(n) =K/radicalbig (logn/n),forsomeK >1.ForKlargeenough, andnlargeenough, resultsin[8,23]ensurethatstraightlinero ut ing (greedy geographic routing) is possible without recour se to face routing (the “looparound” strategy employed when str aight line routing failsdue todeadends). We ﬁrst consider the case where nodes have precise destina tion coordinates. However, we assume that the GPS at nodes ar e imprecise. We model this by assuming that each routing step h as an angular error1that is random. In other words, nodes attempt to perform greedy straightline routing. However, due to the a ngular error, the packet is forwarded to a random node that is in some sector withinangles φ1andφ2(illustratedinFigure3). 1Notethatbyexpressing theposition ofanodeinpolarcoordi nates, the radial component of the error will not affect geographic rou ting; however theangular componentcouldpointinthewrongdirection. Th us,wemodel GPS errors by randomness in the angular component.We then consider the case where nodes have limited destina tion information. In particular, we consider the case where each node has only a coarse estimate – such as quadrant or halfpla ne information. In other words, each node has a coordinate syst em (a local notion of ‘North’) that need not be common to all node s. All that each node knows is that the local quadrant in which th e destinationlies (orthe halfplane inwhichthe destinatio n lies). In eachofthesecases,theroutingstrategythatisadoptedist osimply forward the packet to a randomly selected node in the appropr iate quadrant (or the halfplane). We also consider the case where only a small fraction of the nodes have any routinginformation at all. Most nodes simply for wardthe packet toa randomly selectedneighbor. Asmall frac tion ofthenodeshavequadrantinformation(asdiscussedearlie r). This could be distributed by some gossip mechanism [17, 14], wher e nodes forward routing information, but also forget this inf orma tion after some time. We consider a simple model where a node has routing information with some ﬁxed probability p∈(0,1), inwhichcase, itroutes tothe appropriate quadrant and othe rwise randomly routes the packet toanarbitraryneighbor. Finally, we consider the throughputcapacity in networks f or the special case of progressive routing strategies where the pack ets are transported closer totheir destinations ineach ste p, but not necessarilyalongastraightline. Sucharoutingstrategy couldpo tentiallyleadtospatial“hotspots”inthenetworkwherema nydata ﬂows intersect at a spatial region (a node or group of nodes), due to“suboptimal” routes withincreasedpathlengths. Fore xample, considerFigure1(a)(i),where nsourcedestinationpairshavenon intersectingpaths (eachof length’1’),thus resulting ina (normal ized)throughput of’1’foreachpair. Ontheotherhand,letu snow allowthepathlengthbetweeneachsourcedestinationpair tobeno morethanlength’3’(duetoimperfectrouting). Then,inthe worst case, all the paths will share a bottleneck node, thus decre asing thethroughput persourcedestination pairtobe 1/n(illustratedin Figure 1(a)(ii)). With nrandomly placed sourcedestination pairs andstraightlinerouting(seeFigure1(a)(iii)),ithasbe enshownin [8] that the throughputcapacity per sourcedestination p air scales as1//radicalbig nlog(n).Analogous to Figure 1(a)(ii), imperfect routing strategies, even when the path length is increased by only a con stantfactor (nonstraightlinerouting)couldleadtohotspots,thus decreasing throughputcapacity inanorderwise sense. In this pa per,weshowthattheeffectofhotspotsdue toprogressive ro uting doesnotreducethenetworkthroughputcapacityinanorder sense. In other words, the throughputcapacity with progressive r outing is orderwise the same as the maximum achievable throughput  capacity. Themain contributions inthis paper are the following: (i) We show that the time to reach the destination with erro neous angular information or limited information (quad rant information) is withina constant factor of straightl ine greedy routing. We derive upper and lower bounds on the routingdelay whichare asymptotically tight(in n). (ii) We show that even in the case where only a ﬁxed fraction of the nodes have routing information, the routing delay is within a constant factor of straightline routing.Thus, th is impliesthatforanyﬁxed p∈(0,1),wecanachieveadelay within a constant factor of the optimal strategy. The trade offis that the constant factor scales as1 p. (iii) In the delay analysis, we adopt a continuum model of a sensor network where packets are routed along points onthe plane, and each hop has a stepsize that is bounded by M(n). In Section 6, we validate the analytical results us ingsimulationswherethediscretizationeffectsduetonod e locations are accounted for. (iv) For networks with progressive routing strategies, we s how that although hot spots might occur, they are not severe enough to reduce the throughputcapacity in an orderwise sense. We comment that for the strategies considered, suppose that we had a deterministic progress toward the destination, the n it is easy to see that the routing delay2will be orderwise equivalent to straightline routing. For example, in Figure 1(b)(i), a packet from source ’S’ to destination ’D’ is routed such that the pac ket’s location at each subsequent hop lies in a sector oriented tow ard the ﬁnal destination in a manner such that there is a determin istic lowerbound on the progress toward the destination. This le ads to an appropriate deterministicupperbound on the routingde lay. However, if a deterministic positive step does not occur, (a s in Figure 1(b)(ii)),then it is possible that the delay is sig niﬁcantly larger. It is reasonable to expect that if the expected dista nce is positive (as in (ii)), we should expect the delay to be order wise equivalent to straightline routing, with a proportionali ty constant equal to the inverse of the mean distance traveled in every ju mp. Indeed, this would be true if the progress toward the destina tion in subsequent hops were independent and identically distri buted (i.i.d.), or such that some form of the law of large numbers we re satisﬁed. However in our case, the progress (the difference be tween|− →SD|and|− − →AD|in Figure 1(b)(ii)) at subsequent hops are neither independent, nor identically distributed. In fact , the mean progress gets smaller as we proceed towards the destination and thesequence iscorrelated. Weshow thatevenunderthesecir cum stances, we can upper and lower bound the projections of subs e quent steps by a sequence of i.i.drandom variables, and use t hese i.i.d. bounds to derive asymptotically tight bounds on the r outing delay. 1.2. Related Work "
391,Shortcutting Fast Failover Routes in the Data Plane.txt,"In networks, availability is of paramount importance. As link failures are
disruptive, modern networks in turn provide Fast ReRoute (FRR) mechanisms to
rapidly restore connectivity. However, existing FRR approaches heavily impact
performance until the slower convergence protocols kick in. The fast failover
routes commonly involve unnecessary loops and detours, disturbing other traffic
while causing costly packet loss.
  In this paper, we make a case for augmenting FRR mechanisms to avoid such
inefficiencies. We introduce ShortCut that routes the packets in a loop free
fashion, avoiding costly detours and decreasing link load. ShortCut achieves
this by leveraging data plane programmability: when a loop is locally observed,
it can be removed by short-cutting the respective route parts. As such,
ShortCut is topology-independent and agnostic to the type of FRR currently
deployed. Our first experimental simulations show that ShortCut can outperform
control plane convergence mechanisms; moreover avoiding loops and keeping
packet loss minimal opposed to existing FRR mechanisms.","With the emergence of lowlatency and highbandwidth distributed applications [ 63] in datacenter or wide area net works, there is an everincreasing pressure on the network operators in the form of stringent SLOs (Service Level Objec tives) to ensure a peak performance in terms of availability, latency, bandwidth, and packet loss. However, unexpected failures (link/switch) are inevitable and happen regularly re quiring a rapid action to ensure seamless connectivity with out compromising on performance. A plethora of Innetwork Fast Reroute (FRR) approaches [ 11,30] have been developed entirely in the data plane to address such a problem. How ever, these approaches are slow, incur loops, trigger packet loss when routes become unavailable, to reroute traffic via a suboptimal path [ 37] which may be shared by other traffic.Control plane Convergence is slow : In the light of fail ures, the global control plane convergence is proven to be slow in seconds scale [ 36] or even in some cases on a minutes scale [ 31], adversely impacting the SLOs, and thus, business of network operators. The reason for slow control plane convergence is attributed to detecting failures, notifying switches of failures, recomputing new paths, and updating forwarding states depending on switch control plane de sign [28] accordingly. Therefore, in order to meet the SLOs, local FRR mechanisms [ 14] have been deployed on the data plane for fast reaction to unexpected and crippling failures. The conventional wisdom is to proactively install backup rules on the switches which take priority when the failure happens. Therefore, a hierarchical control plane design with a global control plane and local reactive control on the data plane has emerged as a popular approach. Navigating the FRR landscape of FRR: Local FRR [ 9,12, 15,17,19–22,27,58] can react almost immediately [ 14] to failures by proactively installing reroute rules, e.g., of lower priority. As such they are the fastest failover schemes, at tempting to always maintain connectivity, but can only do so with some downsides. First, in many scenarios, it is impos sible to protect against more than a single failure [ 12,19,24]. Second, reminiscent of graph exploration [ 6], packets probe for working paths, introducing long detours. Local FRR can also be achieved by means of packet header modification or encapsulation [ 3,33,35]. Here however one has the drawbacks of needing customtailored protocols, potentially disturbing other network functions due to, e.g., header changes, issues due to increased packet sizes, e.g., with the MTU, and encountering reroute loops as well. More over, there is FRR that leverages control plane convergence ideas in the data plane itself. For example, DDC [36] utilizes link reversal algorithms [ 29,57] to provide connectivity, as long as the network is not partitioned. Blink [31], on the other hand, tracks TCP disruptions to switch to backup routes. While FRR implementation in the data plane, opposed to the control plane, significantly speeds up recovery, these mech anisms cannot provide the same rapid protection as local FRR schemes: e.g.,Blink [31] needs disruptions to occur first and link reversal algorithms, as in DDC [36], face quadratic convergence time in the worst case [ 8]. Still, the above con vergence mechanisms also cover a wider range of multiple link failure scenarios, unobtainable by local FRR [19, 24].arXiv:2111.14579v1  [cs.NI]  29 Nov 2021 S  D S1S2 S3S4Routing Table for Node S1 Inport Outport Dest. Priority S S2 D 1 S2 S S 1H (a) Without any failures   S   D S1S2 S3S4Routing Table for Node S1 Inport Outport Dest. Priority S S2 D 1 S S3 D 2 S2 S3 D 1 S2 S S 1H  (b) With FRR after a link failure   S   D S1S2 S3S4Routing Table for Node S1 (after failure    ) Inport Outport Dest. Priority S S2 D 1 S S3 D 1 S2 S3 D 1 S2 S S 1H Routing Table for Node S1 (before failure    ) Inport Outport Dest. Priority S S2 D 1 S S3 D 2 S2 S3 D 1 S2 S S 1 (c) With ShortCut after a link failure Figure 1: Comparison of no FRR without failure, FRR, and ShortCut Problem Statement. In this paper, we pose the following question: Local FRR maintains reachability by paying the price of additional delay and network load. Can we locally and rapidly remove those inefficient detours, before relatively slow convergence protocols kick in? Solution Design. To this end we propose ShortCut , which augments FRR by locally removing reroute loops while main taining protection to a link failure, largely agnostic to un derlying FRR. ShortCut is enabled by data plane methods, but unlike convergence methods, is purely local, without (implicit) message exchange by, e.g., link reversals, and fur thermore does not rely on packet loss TCP signaling, main taining immediate protection. Hereby ShortCut expands the design space of hierarchical FRR and convergence schemes, placing itself as an intermediate layer between both. ShortCut leverages programmable data planes: The P4 language [ 7,16] enables the programmability and customiza tion of data plane functionalities in network devices. P4, an opensource language, allows programming of packet for warding planes, and is increasingly supported by a panoply of network vendors. Via the P4 language, one can define in P4 programs the instructions for processing the packets, e.g., how the received packet should be read, manipulated, and forwarded by a network device, e.g., a switch. Speaking of “local” fast reroute, P4 programs offer the required platform to fast reroute the packets on desired links at line rate when the link failure occurs while avoiding crip pling loops and costly packet loss. Such “local” capability is crucial as the “global” control plane convergence mecha nisms are slow [ 31,36] to react to data plane events which require rapid action. Finally, when the global control plane mechanisms converge, they overwrite the local ShortCut . We observe such hierarchical control as also, shown in [ 36, 59], is crucial to meet the SLO targets. Our experimental simulation endorses our position as ShortCut outperforms the global control plane convergence. Furthermore, we show thatShortCut avoids costly loops and thereby loadinduced packet loss [5], unlike existing FRR [9, 12, 17, 19, 27, 58].Contributions. Our main contributions are: •We identify an untapped opportunity in local FRR mech anisms to shorten failover routes and propose ShortCut , a data plane method leveraging it. Our method is largely ag nostic to the deployed local FRR mechanism, and also leaves data packets unchanged, respectively does not require packet state on the switches. (§2) •We prove correctness and efficiency of ShortCut ,i.e., single link failure protection under shorter (loopfree) routes. More over, we show that ShortCut is realizable without additional communication, i.e., just by observing the data plane. (§3) •We conduct an experimental evaluation of a ShortCut pro totype: ShortCut strongly outperforms control plane conver gence mechanisms, removing FRR loops and keeping packet loss minimal. (§4) •We rigorously discuss FRR mechanisms and their interplay with ShortCut , charting the landscape of FRR in depth. (§5) 2 MOTIVATION AND BACKGROUND The Control Plane is Slow. A cornerstone of FRR mecha nisms is that reactions are immediate, ideally always main taining logical connectivity. We cannot rely on instrumenting the control plane to this end, as “ the control plane typically operates at timescales several orders of magnitude slower than the data plane, which means that failure recovery will always be slow compared to data plane forwarding rates ” [36]. 2.1 Local Fast Reroute Mechanisms Hence, to react without delay to link failures, switches and routers must have the new routing already precomputed, i.e., a mapping of incident faults to forwarding rules. We give an example in Fig. 1a, where the task is to route packets from a source 𝑆to sink𝐷,e.g., via the black path SS1S2 S4D. When the link between S2 and S4 fails, a global view would change the routing at node S1, s.t. the new path is SS1S3S4D. However, for immediate reactions, we can not rely on the control plane, and hence only Node S2 (and S4) can change their behaviour immediately. Here, the sole meaningful option at Node S2 is to bounce the packet back to its only neighbor S1, hoping that the packet reaches 𝐷. 2At this point, the careful preprocessing of the network’s topology by means of FRR comes into play. Stateoftheart FRR leverages that nodes can send the same packet to differ ent outports, based on the inport [ 58]. In other words, when the packet returns from Node S2 to Node S1, the Node S1 can now forward the packet to Node S3, from there to S4 and then to the destination. Various methods have been proposed in this setting, such as (backtracking in [ 19]) DAGs [ 37], par tial structured networks [ 58], or arcdisjoint paths, trees, and arborescences [9, 12], all utilizing inportawareness. As such, FRR has maintained connectivity, by routing the packets along the blackred path SS1S2S1S3S4D. Notwithstanding, until the (slow) global convergence kicks in, this routing is inefficient, due to each packet looping once between S1 and S2. What’s worse, the rerouted packets will compete with the blue HSflow, where we will lose up to ≈50%of the total throughput. Purely local and static FRR cannot overcome this inefficiency, the incident link fault state remains unchanged at Node S1; there are no incident failures. 2.2 Leveraging the Data Plane We are motivated by the above scenario and hence aim at preserving 1)FRR connectivity guarantees while also 2)re moving the inherent inefficiency of detour loops. Our idea is to instrument the data plane to shortcut unnecessary loops in FRR mechanisms, optimizing network performance until the control plane kicks in. In more detail, we propose to observe the data plane, implicitly waiting for packets to traverse the same node twice, and then to remove routing loops. A straightforward approach to packet loop detection would be to remember packets or to mark them, which however comes with undesirable overhead in local storage or header expansion, the latter disturbing other network functions. Rather, we propose to detect loops FRR implicitly, by means of different ports. In Fig. 1a, Node S1 expects packets, des tined for D, to always arrive via S and to exit via Node S2, i.e., such packets arriving by Node S2 and leaving towards Node S3 implicitly signal a failure downstream, as we explain next: Node S1 deduces thereby that the returning packets tra verse an unnecessary loop1andshortcuts the route by match ing packets with inport S and destination D to the outport to Node S3. From now on, no more packets will enter the loop S1S2S1, improving these links’ utilization and in particular the latency of the flow’s packets due to a shorter route. In this example, the shortcutted route is even already the route the control plane will converge to after some time. In more detail, a first packet from the SDflow on the outport to Node S3 triggers Node S1 to change its routing, as shown in Fig. 1b: at the inport from S, the top priority rule (to S2) is removed and the second priority rule (to S3) becomes the default. 1they visit both S2 and S3 from S1, one after another3ShortCut DETAILS We model the network as a graph 𝐺=(𝑉,𝐸)with𝑛nodes (routers, switches, hosts) 𝑉and𝑚directed links 𝐸. We first define the routing for the failurefree case, i.e., without FRR. Each packet in a flow 𝑓is routed from a source 𝑠=𝑠(𝑓)∈𝑉 to a destination 𝑡=𝑡(𝑓) ∈𝑉along a simple path, i.e., a sequence of nodes without repetition. We assume that the forwarding at a node 𝑣(to an outport 𝑣𝑜of𝑣) is deterministic and may only match on 1)the flow’s source2and destination and2)the incoming packet’s port (inport 𝑣𝑖) at𝑣.3 We next specify the FRR model and its routing for a link failure between any node pair 𝑢,𝑤. We will later discuss how to extend ShortCut to further failure models. Now, the forwarding at 𝑢,𝑤 may also match on a third item, namely that the link(𝑢,𝑤)is down. Note that all other nodes are not aware of this failure and hence leave their routing un changed. Now, FRR may route the packets along a walk, i.e., node repetitions are allowed, but due to the deterministic forwarding behaviour, link repetitions lead to the packet not reaching the destination—as we assume packets are not modified by FRR. We assume that each node 𝑣has an ordered priority of outports 𝑣𝑜 1,...,𝑣𝑜 𝑘for a given flow (or destina tion), where 𝑣𝑜 1is the default outport without failures. Herein, the forwarding from each inport 𝑣𝑖may implement a part of this priority list, i.e.,𝑣𝑜 𝑗,...,𝑣𝑜 𝑘, for 1≤𝑗≤𝑘. We give an example for FRR with linkdisjoint spanning arborescences4[17]. In this FRR scheme, the idea is to first try to route on the first arborescence (tree), if a failure is encountered, then to switch to the second one, and so on. To this end, at each node 𝑣, the outport 𝑣𝑜 1corresponds to the first arborescence, 𝑣𝑜 2to the second, and so on, where the inport of the first arborescence starts the priority list with 𝑗=1, the inport of the second arborescence with 𝑗=2etc. 3.1 ShortCut Mechanism At each node 𝑣∈𝑉,ShortCut performs the following oper ation continuously: for each inport 𝑣𝑖and flow𝑓, if packets from𝑓are sent through 1)an outport𝑣𝑜 ℎin the priority list 𝑣𝑜 𝑗,...,𝑣𝑜 𝑘of inport𝑣𝑖for𝑓and2)𝑣𝑜 ℎis not𝑣𝑜 𝑗,i.e., not its top priority, then 𝑣𝑖removes the first items from its outport priority list until only 𝑣𝑜 ℎ,...,𝑣𝑜 𝑘remains. In other words, by observing that a lower priority outport is taken, correspond ing inports make this outport their highest priority choice and remove all outdated higher priority outports in the pro cess from their list. Note that if an outport is not available due to link failure, it is considered as removed as well. 2Our mechanism also works for destinationbased routing via trees. 3ShortCut also works for routing and FRR without usage of the inport, as we can then simply assume the forwarding is identical for all node inports. 4An arborescence is a directed tree oriented towards its root. 3vi j,1vo h,1 vi j,2vo h,2(a) FRR rules without ShortCut vi j,1vi j,2vo h,2  (b) FRR rules with ShortCut Figure 2: Application of ShortCut after a link failure Observation 1. ShortCut operates locally at each node, without control plane messages or exchange between the nodes. 3.2 ShortCut Properties ShortCut 1)maintains the underlying FRR reachability, 2) that the packet route turns into a loopfree subpath of FRR, and3)triggers within one endtoend delay. Theorem 3.1. When the FRR scheme maintains reachability under one link failure, then ShortCut maintains reachability and changes the route to a loopfree FRR subpath. Proof. First, note that due to model assumptions, ShortCut will not trigger before a link failure, as the standard outport has the highest priority on all nodes. Second, we briefly inves tigate FRR after a link failure without ShortCut , before the control plane convergence sets in: from the moment on the first packet hits the failed link (and rerouting is triggered), all following flow packets take the same route as the first flow packet. This route may visit nodes multiple times, but it may visit each link only once due to the deterministic routing behaviour, else the packet would not reach the destination. We now consider the impact of ShortCut on FRR after a link failure at a node 𝑣≠𝑡by case distinction over #visits. For one visit to 𝑣per packet via 𝑣𝑖 𝑗,1to𝑣𝑜 ℎ,1,ShortCut makes no change to the effective routing after FRR, even if some other inports also change their outport to 𝑣𝑜 𝑗,1. For two visits, first 𝑣𝑖 𝑗,1to𝑣𝑜 ℎ,1and second 𝑣𝑖 𝑗,2to𝑣𝑜 ℎ,2,𝑣𝑜 ℎ,1has a higher priority than 𝑣𝑜 ℎ,2, i.e.,𝑣𝑖 𝑗,1changes its outport to 𝑣𝑜 ℎ,1, but𝑣𝑖 𝑗,2remains at𝑣𝑜 ℎ,2. Hence the loop beginning with 𝑣𝑜 ℎ,1 and ending with 𝑣𝑖 𝑗,2is removed and from now on 𝑣will only be visited once. We refer to Fig. 2 for a visualization: in 2a the packet first visits and leaves the node 𝑣via the red arrows, then later returns and leaves again via the blue arrows, form ing a removable detour. By application of ShortCut in 2b, the red outgoing rule is adapted to the (later and blue) 𝑣𝑜 ℎ,2, removing the detour. As all packets exiting via 𝑣𝑜 ℎ,2reach the destination by assumption before application of ShortCut , reachability is maintained, as we only remove the subpath between𝑣𝑖 𝑗,1and𝑣𝑜 ℎ,2. For more than two visits of 𝑣, sayℓ, the argumentation is analogous, where eventually all relevant inports forward to the last outport 𝑣𝑜 ℎ,ℓ, and visit𝑣only once. Hence ShortCut 0 2 4 6 8 100 10 20 30 40 50 Time in secondse2e throughput in MbpsShortcut Control Plane ConvergenceFigure 3: ShortCut vs Control plane convergence w.r.t. mean endto end throughput over multiple TCP experiments. The link failure finally comes into effect at 2 seconds, it takes seconds for the control plane convergence mechanisms to kick in, while ShortCut routes traffic loopfree, maintaining tolerable packet loss. removes all loops while only using links also used by the FRR scheme. Lastly, for a brief amount of time, there can be packets in flight that never hit the failure, but who might be impacted byShortCut . Observe here that if they still use the standard routing on their remaining path, reachability is maintained, and else, they are detoured to (shortcutted) FRR rules, still reaching the destination. □ Observe that for the above routing change actions are all triggered as soon as a packet traverses the whole FRR path. Corollary 3.2. After a link failure, all ShortCut route change actions are triggered within one endtoend delay. 4 PROOFOFCONCEPT EVALUATION In the following section, we demonstrate the effectiveness of aShortCut in P4 over control plane convergence mech anisms (routing protocols) in terms of throughput leverag ing our P4 evaluation. In particular, we note that ShortCut avoids loops and packet loss to ensure better throughput compared to control plane convergence mechanisms. For our experimental evaluation, we choose the topol ogy illustrated in Figure 1 with preinstalled rules. We de ploy an LPM (Longest Prefix match) P4 program [ 1] written in P416[16] in a Mininet [ 41] environment and leveraged iperf [ 18] for generating the endtoend TCP traffic (between end hosts). Our evaluation leverages a centralized controller for simplicity. Furthermore, P4 ensures fast routing on the network dataplane until the control plane convergence kicks in. Therefore, we leverage hierarchical control, i.e., global 4control with control plane convergence and local ShortCut for fast reactive response to immediate dataplane failures. To simulate a 1link failure scenario under TCP traffic (see Figure 1), we use our custom Pythonbased script to “fail and reroute” traffic from SS1S2S4D to SS1S3S4D in the case of control plane mechanism and ShortCut (See Figure 1c). For our evaluation, we derive motivation from [ 31,36], where they observe that the control plane involves CPU operations which are significantly slower (seconds scale) than the opera tions in the data plane (microseconds scale). It is noteworthy that until the control plane mechanism kicks in, the unavail ability of routes leading to packet loss will already occur. However, in ShortCut , the rerouting happens at microsec ond scale while avoiding loops and keeping packet loss to a minimum until switchover to the new route happens. Note, in existing FRR approaches, there will be loops as the path taken will be SS1S2S1S3S4D and packet loss since, the rerouted flow (in red in Figure 1b) competes for the link capacity with another flow (in blue in Figure 1b). Figure 3 illustrates the mean endtoend throughput com parison against the control plane convergence mechanism before and after link failure over multiple experiments. We observe that ShortCut outperforms the control plane con vergence mechanisms with a rapid local reroute, avoiding loops and keeping packet losses minimal. We observe that the iperf tool reports that there is latency in the link failure. We note that link failure with zero throughput fully comes into effect at 2 seconds when we introduce the link failure at the zeroth second. Note, that ShortCut ’s reroute is for a transient amount of time and is finally overwritten by the global control plane convergence. 5 DISCUSSION Beyond, e.g., arborescencebased FRR, we now provide a rig orous discussion on the applicability of ShortCut to further mechanisms and scenarios, charting the local FRR landscape. Greedy FRR. Some FRR mechanisms use a greedy approach to circumvent link failures. For example, in some regular graph topologies such as the 2dimensional torus [ 26], it suffices to first try to go closer to the destination, and else “shift” slightly to other directions, then going closer again. However, these mechanisms, due to their greedy nature, usu ally need to exclude the incoming edge as the next outport, as else the reroute can easily get stuck in a permanent loop; the exception is if the inport is the only remaining choice to reach the destination. As such, there is no longer an ordered priority of outports at each node, as inports put themselves at the bottom of their priority General examples of greedy FRR include directed acyclic graphs (DAGs) [ 19] or partial struc tural networks (PSNs) [ 58], where the quality of greedy FRR depends on the careful precomputation of the DAGs/PSNs.We can nonetheless let ShortCut also augment greedy FRR. If the (local) route is 𝑣1𝑣2𝑣1, then, at𝑣2, bouncing back to𝑣1was the best (greedy) choice. Hence, if the packet were to return to 𝑣2later and would choose a different outport than to𝑣1, then this choice would already have been made at the earlier visit, due to the nature of greedy FRR, and as thus ShortCut can set𝑣1as the highest priority outport. Circular FRR. Some FRR does not have a descending pri ority on alternate failover rules, but rather implements a circular scheme. For example, Chiesa et al. [ 13] take on the concept of arborescencebased FRR in this way: instead of just switching to the next arborescence upon hitting a failure, until the𝑘th (last) one is reached, they propose to switch in a circular fashion, i.e., from the𝑘th one back to the first one, and so on, instead of dropping the packet after packets on the𝑘th arborescence hit a link failure. Such FRR is problem atic for ShortCut as it is no longer clear from a local port view which outport corresponds to the “last” node visit of a packet. However, in case circular FRR stabilizes to just a subset of outports, we can adapt ShortCut . We propose to add a small timer, corresponding to the FRR stabilization time, after which ShortCut reevaluates the local traffic; the purpose of the timer is to drain the network of flow packets emitted before the failure appeared. Now, ShortCut keeps track of the first time a flow packet arrived by a nonstandard inport 𝑣𝑖, and adapts the circular ordering to be noncircular where the outport chosen by 𝑣𝑖is now the top of the list. In other words, we rotate the circular ordering and remove its circular property. An FRR scheme where this idea applies is failover routing on outerplanar graphs, where it suffices to fix an embedding and set all routing to be, e.g., clockwise [24]. Virtual Network Partition FRR. A further idea employed by some FRR mechanisms is to virtually partition the net work𝐺=(𝑉,𝐸)into linkdisjoint parts 𝐺1,...,𝐺𝑘. Then, in each part𝐺𝑖, the FRR scheme attempts to reach the desti nation, continuing with 𝐺𝑖+1if unsuccessful, and so on. An example is to compute 𝑘edgedisjoint sourcedestination paths, where the standard route is set in 𝐺1[27].ShortCut can adapt to this setting by only updating the routing rules for each partition, e.g., if the inport of the standard route switches to a lower priority, only rules for 𝐺1are updated. Hereby we remove routing loops from each partition. If the network partitions are strictly ordered as in, e.g., [27], ShortCut can jump locally to the next partition, removing even loops that span across network partitions. Randomization, Duplication, and State. ShortCut is de terministic and hence does not apply to FRR schemes utiliz ing,e.g., random walks [ 6] or random arborescence switch ing [10]: there is no longer a mapping which outport is “last”. Similarly, ShortCut is also not designed for FRR with packet 5duplication [ 12], as these schemes implicitly accept that some duplicated packets will not reach the destination, and hence locally we cannot distinguish which ones were successful. Moreover, ShortCut does not keep state in the packets or at the nodes and hence is not directly compatible with such FRR, e.g., the rotorrouter mechanism [ 4], which essen tially moves the memory of an exploring agent to the nodes. However, if the state is strictly ordered, then ShortCut can be extended in this direction, e.g., when using log𝑘bits for counting changes between 𝑘arborescence [17]. Multiple Failure FRR. ShortCut is designed with a single link failure in mind, as we expect the control plane to deploy new rules until a new failure appears. However, extending ShortCut to multiple link failures is difficult, as ShortCut is largely agnostic to the underlying FRR. When ShortCut removes the loops introduced by the FRR after the first link failure, it could very well be that exactly those loops guaran tee destination reachability when further failures appear. Notwithstanding, ShortCut can incorporate the scenario of a whole node failing, taking all its attached links down with it. The reason is that for a node failure, the FRR does not change over time, and ShortCut removing FRR loops hence does not impact reachability of the flow’s destination. Segment Routing and MPLS FRR. Conceptually, ShortCut can also augment Segment Routing (SR) and MPLS FRR [ 3] schemes, treating the packet encapsulation or top label iden tically to flow routing rules. However, ShortCut will only re move routing loops for each individual encapsulated header respectively label, not across them. It could be interesting to extend ShortCut across the whole label stack. For example, when using TILFA [ 35] for link protection, the segments to route around the failed link can intersect with the original route, and here ShortCut could remove those loops across header segments/encapsulations, handling failure carrying packet FRR schemes [25, 33] analogously. Nonlocal ShortCut implementation. ShortCut only re quires observation of the data plane at each node individually, without communication between the nodes and/or a logically centralized controller, recall Observation 1. Still, ShortCut requires some ability to actually change the routing at a node upon being triggered by the data plane. While we believe future, e.g., P4 extensions or custom programs could be used to this end, a direct solution would be to proceed analogously as proposed by Ngyuen et al. [ 40]: each node has its own (lowcost) controller, allowing to implement routing table updates near instantaneously. Alternatively, a distributed control plane with, e.g., multiple controllers could be lever aged [ 45], or even a classic centralized controller setup: while a new routing configuration is prepared, the controller could rapidly issue the simple updates needed by ShortCut .Temporary Failures. Some link failures are only tempo rary, e.g., linkflaps due to protocol issues [ 42] or optical reconfiguration [ 52]. In these cases ShortCut does not auto matically switch back to the now again available route, and it would be interesting to study tradeoffs involving delays and probing [ 31], before the control plane takes over. It it would moreover be interesting to investigate the interplay ofShortCut with temporary inconsistencies due to bugs or outdated control plane views [ 47,49,50], respectively during network updates [ 23],e.g., separated into fastpaced rounds [51], and with route verification in P4 [62]. 6 RELATED WORK "
373,"A Review of AI-enabled Routing Protocols for UAV Networks: Trends, Challenges, and Future Outlook.txt","Unmanned Aerial Vehicles (UAVs), as a recently emerging technology, enabled a
new breed of unprecedented applications in different domains. This technology's
ongoing trend is departing from large remotely-controlled drones to networks of
small autonomous drones to collectively complete intricate tasks time and
cost-effectively. An important challenge is developing efficient sensing,
communication, and control algorithms that can accommodate the requirements of
highly dynamic UAV networks with heterogeneous mobility levels. Recently, the
use of Artificial Intelligence (AI) in learning-based networking has gained
momentum to harness the learning power of cognizant nodes to make more
intelligent networking decisions by integrating computational intelligence into
UAV networks. An important example of this trend is developing learning-powered
routing protocols, where machine learning methods are used to model and predict
topology evolution, channel status, traffic mobility, and environmental factors
for enhanced routing.
  This paper reviews AI-enabled routing protocols designed primarily for aerial
networks, including topology-predictive and self-adaptive learning-based
routing algorithms, with an emphasis on accommodating highly-dynamic network
topology. To this end, we justify the importance and adaptation of AI into UAV
network communications. We also address, with an AI emphasis, the closely
related topics of mobility and networking models for UAV networks, simulation
tools and public datasets, and relations to UAV swarming, which serve to choose
the right algorithm for each scenario. We conclude by presenting future trends,
and the remaining challenges in AI-based UAV networking, for different aspects
of routing, connectivity, topology control, security and privacy, energy
efficiency, and spectrum sharing.","UA Vs are an emerging technology that has opened its way into many ﬁelds and is expected to continue impacting the future of human life in the coming years. UA Vs have already been utilized in many applications to provide fast, lowcost, ondemand, and precise monitoring and actuation services while minimizing human intervention and lifethreatening risks. This covers many applications including transportation [1], trafﬁc control [2], surveillance [3], border patrolling [4], search and rescue [5], disaster management [6], wireless network connectivity [7], [8], smart agriculture and forestry [9], and remote immersion via mobile virtual reality [10]– [12]. Drones are also widely used in the military domain. For 1This material is based upon the work supported by the National Science Foundation under Grant No. 2008784.instance, LOCUS is a project by the US navy to utilize a swarm of autonomous drones to perform coordinated military attacks [13]. In addition to these commercialized use cases, many new applications are under design and implementation in academia and industry. For instance, surveying and mapping [14], volcano monitoring [15], UA V control by the brain [16], early warning of severe weather [17], plant protection [18], airborne wind energy harvesting systems [19], robotic herding of a ﬂock of birds [20], Amazon Prime Air [21], and UPS drone delivery service [22] are only a few examples of many projects in their infancy steps. Compared to piloted aircraft, satellitebased imaging, and groundbased sensing and actuation platforms, UA Vs offer several advantages, including a small size, low operational and maintenance cost, less human intervention requirements, less operational hazard, autonomous control, more controlled imaging with adjustable zoom and angle of view, and higher maneuverability levels [23]. Therefore, the UA V market has experienced continued growth in the past decades, from an estimated $19.3 billion in 2019 to a projected $45.8 bil lion market by 2025, which represents a Compound Annual Growth Rate (CAGR) of 15.5% from 2019 to 2025 [24]. Despite the following advantages in using drone technology, there still exist numerous challenges, and technical issues for implementing networking and control protocols for UA V based infrastructures [23]. For instance, the limited payload of UA Vs translates into constraints in power consumption, com munication range, and computational limits that in turn may cause difﬁculties for networking, robust control, information acquisition and processing, autonomy, and task coordination. Another issue is the extreme dynamicity of UA V networks due to their high speed, heterogeneous maneuverability levels, and obstaclesparse ﬂight zones, compared to ground vehicle networks with more predictable motion trajectories dictated by road patterns. Therefore, communication, control, path planning, and information acquisition protocols that are pri marily designed for ground platforms deem inefﬁcient for UA V networks. For instance, connectivity of vehicular networks along roads necessitates optimal positioning of nodes or reg ulating their speed in a onedimensional subspace that is not directly applicable to UA V networks. Likewise, autonomous driving and collision avoidance for drones have different constraints and requirements, compared to similar tasks in selfarXiv:2104.01283v2  [cs.NI]  8 Nov 20212 Fig. 1: The organization of this survey paper. driving cars. The goal of this survey paper is twofold. First, we review UA V networks’ features, including UA V technology, network ing protocols, and swarms, with a focus on characterizing the impact of mobility on network topology, connectivity, and networking performance metrics. In this respect, we highlight the importance of having an accurate mobility prediction system for more efﬁcient networking. Second, we review routing protocols designed for UA V networks, emphasizing AIenabled routing protocols, which present better outcomes for high mobility networks [25]–[27]. Furthermore, we ad dressed the closely related topics of mobility models for UA V networks, simulation tools and public datasets, and relations to UA V swarming, which serve to choose the right algorithm for each scenario, as an additional contribution of this paper. A. Motivation Routing protocols developed for Vehicular AdHoc Net works (V ANETs) and other ground networks are not well positioned to accommodate the requirements of UA V net works. As stated earlier, drones enjoy a higher mobility degree of freedom, compared to ground vehicles. This leads to a more vivid and fastchanging topology in comparison to V ANETs [28]. Also, the lower node density of Flying Adhoc Networks (FANETs), compared to V ANETs, raise connectivity issues due to the drones’ limited communication ranges [29]. In terms of channel modeling, fading, and diversity phenomena, FANETs beneﬁt from more accessible LineofSight (LoS) links between UA Vs and the use of smart directional antennas for collective beamforming, and similar techniques can offer higher gains [30], [31]. From a different point of view, it also highlights the necessity of developing more accurate localization and tracking technology for aerial networks.Furthermore, conventional routing protocols developed for V ANETs merely rely on the node’s prior information or current perception of the network topology, and do not per form well in maintaining connectivity. They either impose a large overhead for constantly updating the global network information or require a timeconsuming route setup phase. Also, UA V networks are structurefree and not consistent with centralized routing protocols. Appropriate routing protocols for UA V networks should have properties like low complexity, low overhead, and preferably without the need for global knowledge and lengthy route setup stages, as discussed in [32]. The new generation of selfadaptive learningbased and topol ogy predictive routing protocols learn the state of the network by experiencing and predicting dominant trends and constantly adapting to both minor or abrupt changes. This approach leads to a higher packet delivery ratio and energy efﬁciency. In this paradigm, decisions are made based on the anticipated network topology, and not solely based on the current state. These key requirements promote AIenabled routing protocols to achieve superior performance [25]–[27]. Therefore, using AI methods to predict motion patterns of freely ﬂying UA Vs "
60,Behavior of Wireless Body-to-Body Networks Routing Strategies for Public Protection and Disaster Relief.txt,"Critical and public safety operations require real-time data transfer from
the incident area(s) to the distant operations command center going through the
evacuation and medical support areas. Any delay in communication may cause
significant loss. In some cases, it is anticipated that the existing
communication infrastructures can be damaged or out-of-service. It is thus
required to deploy tactical ad-hoc networks to cover the operation zones.
Routing data over the deployed network is a significant challenge with
consideration to the operations conditions. In this paper we evaluate the
performance of mutli-hop routing protocols while using different wireless
technologies in an urban critical and emergency scenario. Using a realistic
mobility model, Mobile Ad hoc, geographic based and data-centric routing
protocols are evaluated with different communication technologies (i.e. WiFi
IEEE 802.11; WSN IEEE 802.15.4; WBAN IEEE 802.15.6). It is concluded that, WiFi
IEEE 802.11 is the best wireless technology with consideration to the packet
reception rate and the energy consumption. Whereas, in terms of delay, WBAN
IEEE 802.15.6 is the most efficient. With regards to the routing protocols,
assuming that the location information is available, geographical based routing
protocol with WiFi IEEE 802.11 performed much better compared to the others
routing protocols. In case where the location information is unavailable,
gradient based routing protocol with WBAN IEEE 802.15.6 seems the best
combination.","Disasters are increasing worldwide, impacting not only the  economies and infrastructure but significant number of human  lives. With regards to the emergency response to these  disasters, the role of effective Public Safety Network  (PSN)  infrastructures  (e.g. TETRA, LTE) is extremely vital.   However, it is anticipated that, during and after the disasters,  existing  PSN infrastructure s can be  either completely damaged  or oversaturated.  Consequently, there is a growing demand for  ubiquitous emergency response system which could  be easily  and rapidly deployed.  In this context, it is expected that Wearable Body  Area   Networks  (WBAN) can pl ay a key role in not only providing  an additional connectivity network but it can also be used to  monitor the physiological status  of the  involved workforces  and the surrounding environment [1]. WBAN consists of  smart, low power, miniaturized devices such as sensors ( i.e.,  to sense, transmit and r eceive data), actuator (to act on the  perceive data)  and coordinator (to act as a gateway to external  networks). WBAN communication architecture is composed  of onBody, BodytoBody (or inter Body) and offBody  communication networks. In interBody commun ications, a  device coordinator with specific features could be responsible  to communicate with the adjacent Wireless Body Area  Networks  (WBANs ). A coordinator  is generally considered as  a resource rich device , which  can be a multi standard node to  interfac e with other technologies such as static Wireless  Sensor Networks  (WSNs), WiFi Access , Points or Broadband  Cellular Networks ( e.g., 4G, LTE, etc.) [2]. The advent of  such technology  can thus be served as an ad on to existing  PSN infrastructures for improving the quality ofservice  (QoS) and reliability .  In Public Protection and Disaster Relief  (PPDR)  scenarios, the network connectivity and data is a challenging  problem due to the dynamic mobility and harsh environment   [3]. It is envisioned that, i n case of unavailable or out ofrange  network infrastructure s, the WBANs coordinators al ong with   WBANs sens ors can exploit cooperative and multi hop body  tobody communications to extend the end toend network   connectivity . In this regards, for on body networks, the  Opportunistic and Mobility Aware Routing  (OMAR) scheme  is proposed in one of our earlier works [4]. The emphasis of   this study is on exploration of suitable routing protocols for  Body toBody Networks  (BBN) under dynamic mobility  scenario. To the best knowledge of the authors, there is  currently no comprehensive study using realistic disaster  mobility model and scenari o that could be considered as a  benchmark. In the recent proposed works [5] also, routing  protocols are evaluated without consideration to the   communication technologies, therefore, we as a first step,  investigating various classes of routing protocols to analyze their performance in BBN context with different  commu nication technologies.   In this paper, based on the operational and technical  requirements of the emergency and rescue operations [6], we  investigate the behavior of multi hop routing prot ocols with  different wireless technologies  for a fire emergency case   inside a shopping mall. At first, a realistic mobility pattern and  trace files are generated using a tool called BonnMotion [7].  These patterns and movements are geographically mapped and  simulated over two incident areas inside the mall. The mobility  trace file (which contai ns the nodes movements over space and  time) is fed inside a packet oriented network simulator called  WSNet. This mobility model served as a realistic environment  for the evaluation of various class of routing protocols. We  considered proactive , reactive , gradient based  and  geographical based  routing categories. The state oftheart  individual protocol is selected among each category for a  comparative study. For proactive, reactive, gradient based and  geographical based routing protocols, Optimized Link Stat e  Routing protocol  version 2 (OLSRv2) [8], Adhoc On Demand   Distance Vector  (AODVv2) [9], Directed Diffusion  (DD) [10]  and Greedy Perimeter Stateless Routing  (GPSR) [11] protocols  are selected respectively. In addition, mul tistandard  technologies including IEEE 802.11 (WiFi), Zigbee / IEEE  802.15.4, and IEEE 802.15.6 (WBAN) are investigated for the  BodytoBody Network  coordinator. Finally extensive network  simulations are conducted and the results of average successful  Packet Reception R ate (PRR), Packet Delay  and Energy  Consumption  are presented.   The remainder of this paper is organized as follows. In  Section  II, we present the related works of several categories of  routing protocols; while in Section III, we describe the  target  application and mobility scenario along with the target routing  protocols. In Section IV, we introduce the simulation  parameters and we present the obtained simulation results.  Finally, in Section V, we conclude the paper and discuss future  researc h directions.   II. RELATED WORKS   "
189,Energy Efficient Clustering and Routing in Mobile Wireless Sensor Network.txt,"A critical need in Mobile Wireless Sensor Network (MWSN) is to achieve energy
efficiency during routing as the sensor nodes have scarce energy resource. The
nodes' mobility in MWSN poses a challenge to design an energy efficient routing
protocol. Clustering helps to achieve energy efficiency by reducing the
organization complexity overhead of the network which is proportional to the
number of nodes in the network. This paper proposes a novel hybrid multipath
routing algorithm with an efficient clustering technique. A node is selected as
cluster head if it has high surplus energy, better transmission range and least
mobility. The Energy Aware (EA) selection mechanism and the Maximal Nodal
Surplus Energy estimation technique incorporated in this algorithm improves the
energy performance during routing. Simulation results can show that the
proposed clustering and routing algorithm can scale well in dynamic and energy
deficient mobile sensor network.","Recent research es have shown that introducing mobility in wireless sensor network  is  advantageous as the mobile nodes can relocate after initial deployment to achieve the de sired  density requirement and  reduce the energy holes in the network  thereby increasing the network  life t ime. A mobile wireless sensor network consists of tiny sensor nodes which has  three basic  components: a sensing subsystem for data acquisition from the physical surrounding  environment, a processing subsystem for local data processing and storage, a wirele ss  communication subsystem for data transmission [ 16]. Mobility  of these nodes can be achieved  by equipping t he sensor nodes with mobilizers, springs [17] and wheels  [18] or they can be  attached to transporters like vehicles, animals, robots [1 9] etc. M obility in wireless sensor  network is also very taxing  [2] as path breakage happens frequently due to node movement.  Frequent location updates from a mobile node is needed to establish routing which eventually  leads to excessive drain of sensor node‟s battery supply a nd also increases collisions [20 ].  Lifetime of a sensor network depends on energy supply. Therefore it is necessary to design  energy efficient routing protocol.   This paper is distributed as follows – Section 2  gives an idea on prior works done in this area.  Section  3 gives details about Energy Efficient Clustering and Routing Protocol in Mobile  Wireless Sensor Network. The simulation of the proposed routing  protocol is given in Section 4 .  Finally, Secti on 5 summarizes this paper.      2. RELATED WORK  "
268,Experiments on route choice set generation using a large GPS trajectory set.txt,"Several route choice models developed in the literature were based on a
relatively small number of observations. With the extensive use of tracking
devices in recent surveys, there is a possibility to obtain insights with
respect to the traveler's choice behavior. In this paper, different path
generation algorithms are evaluated using a large GPS trajectory dataset. The
dataset contains 6,000 observations from Tel-Aviv metropolitan area. An initial
analysis is performed by generating a single route based on the shortest path.
Almost 60% percent of the 6,000 observations can be covered (assuming a
threshold of 80% overlap) using a single path. This result significantly
contrasts previous literature findings. Link penalty, link elimination,
simulation and via-node methods are applied to generate route sets, and the
consistency of the algorithms are compared. A modified link penalty method,
which accounts for preference of using higher hierarchical roads, provides a
route set with 97% coverage (80% overlap threshold). The via-node method
produces route set with satisfying coverage, and generates routes that are more
heterogeneous (in terms number of links and routes ratio).","Route choice model ing provides the probability that an  individual traveler choos es a certa in  route from a set of  available alternative routes. Most existing studies on route choice typically  consider  a pathbased twostep approach  (BenAkiva  and Bierlaire , 2003; Bekhor et al.,  2006). First, possible alternative  paths  are explicitly generated to form the choice set. Then,  the pre defined choice set  is used for model estimation.  Some other studies proposed  implicit  linkbased approach es to model the route choice behavior as a recursive link choice  behavior ,  without explicitly specifyin g the choice set  (Dial, 1971; Fosgerau  et al., 2013) .   By explicitly specifying the set of alternative  routes, we can examine possible selection  criteria  for generating realistic routes . However, route choice set generation is still  challenging  to find a representative set not only for model estimation, but also for  applications in travel behavior analysis.   Several methods based on variations on the shortest path were developed to generate  route  choice set s. Typically,  shortest paths are iterati vely generated after  variating  link impedances .  BenAkiva et al. (1984) proposed the labelling approach, in which different link attributes are  exploited to formulate different generalized link costs, and used as selection criteria  for  alternative routes . Dial (2000) generalize d the labeling approach and propose d to construct  efficient paths, which minimize a linear combination of label costs.   De la Barra et al.  (1993 ) proposed the link penal ty method, which  gradually increases the  impedance of all links on the shortest path, and repeat the process till no new path can be  found. Link elimination was proposed by Azevedo et al.  (1993 ), in which links on the  shortest path are removed. The main concern regarding l ink elimination method is network  disconnection, Prato  and Bekhor (2006) suggests a variant to remove only one link at each  iteration, if the link takes the driver further away from destination or to lower hierarchical   roads.  Simulation method generates  alternative paths by drawing link impedances from  different probability distributions  in each iteration , the algorithm then runs pre defined  number of draws to produce alternative paths.   Other studies incorporate network topology in route set generation. For example, Abraham et  al. (2013) introduced the via node method to find alternative routes for navigation, by finding  shortest paths that  pass through some vianodes . Candidate via nodes are meeting nodes  in  the bidirectional  search  which start from the origin and from destination  respectively . Via nodes are selected based on the idea of “admissible path”, where these paths are sufficiently  different from the shortest path , with no unnecessary detours , and not locally over circuitous .  Luxen and Schieferdecker (2014)  extended the via node method by selecting  natural graph   cuts as candidate vianode set , and improve d the algorithm performance.   Table 1 provides an overview of the performances of different algorithms (car mode) in terms  of coverage me asurement , which is an indication of the algorithm ability to reproduce the  observed routes (discussed in detail later). In general, with higher resolution network, map  matching of GPS trajectories on road network becomes substantially  more time consuming . In contrast  to most studies , which  use either a detail network or a relatively larger observation  set, we use a detail network and a large GPS trajectory set.   Table 1 Performance s of path generation algorithms  (car networks)   Coverage  (80% overlap threshold, or  best coverage obtained) Bekhor et al. (2006)about 13,000 nodes,  about  34,000 links188 1 46% Prato and Bekhor (2007) 419 nodes, 1,427 links 236 1 31% Spissu, et al. (2011) 18,000 links 393 1 47% Quattrone and Vitetta (2011) 4480 nodes, 16,029 links 332 5 75% Zhu and Levinson (2015) 8,618 nodes, 22,477 links 657 1 23% Tang and Levinson (2018) 8,618 nodes, 22,477 links 124 1 28% Bekhor et al. (2006)about 13,000 nodes,  about  34,000 links188 30 71% Frejinger and Bierlaire (2007) 3077 nodes, 7459 links 2,978 15 80% Prato and Bekhor (2007) 419 nodes, 1,427 links 236 10 70% Pillat et al. (2011) 7,703 nodes, 22,620 links 1,089 113 60% Ding et al. (2014)  7,808 nodes, 11,106 links 997 30 79% RieserSchüssler, et al. (2013) 408,636 nodes, 882,120 links 500 100 75% Bekhor et al. (2006)about 13,000 nodes,  about  34,000 links188 40 80% Prato and Bekhor (2007) 419 nodes, 1,427 links 236 15 62%# of  observationsNumber of  Routes Labeling Approach Link Elimination Link PenaltyMethod Literature Network Size   In this study, we perform experiments on route choice set generation , applying classical  methods and the recent  vianode method . Specifically, l ink penalty, link elimination,  simulati on and via node methods are applied to generate route sets, and the consistency of the  algorithms are compared  using a large GPS trajectory set.   METHODOLOGY   This section describes the methodology, consisting of: (i) survey and dataset description, (ii)  application of the path generation algorithms , (iii)  consistency measurement   The Tel Aviv Metropolitan Survey Data   This paper uses a dataset from t he household survey conducted in the Tel Aviv metr opolitan  area between September 2016 and December 2017 . The survey collected  general information  about  the household members and their activities. GPS data logger s were provided to the  household members, which record ed their locations for 48 consecutive hours with 2 second  time step on average .  The overall sample includes 28,530 individuals living in 10,305 households. A total of  233,588 trips were recorded, in which 59.3% of them is car (either driver or passenger) trips,  25.9% is walking trips, 10.9% is public transit trips, 2.5% bicycle trips and 1.4% is  motorcycle trips.   Out of all  the trips, we are interested in car trips with sufficient trip length and are related to  main activities, which are  commute trips, maintenance trips (e.g. shopping) and personal trips (visiting friends , entertainments, etc.) . We set a minimum of  2 km as threshold , which  results  in 38,175  main activity car trips.  There are 7.3 billion raw GPS readings  corresponding to all trips . After performing logical  checks and deleting observations with gross errors in GPS  for the selected car trips , there are  3,363,755  points related to 6,000  car trips performed by 2,739  persons. The logical checks  include that (a) a trip should originate and end in Tel Aviv Metropolitan area, and (b) the  average distance  between two conse cutive  GPS data point is no more than 100 m , which   corresponds to the  minimum link length in the Tel Aviv network .   After cleaning and filtering the GPS data, the 6,000 car trips are map matched to a detail ed  planning network of Tel Aviv metropolitan area , which contains 8,583 nodes and 21,151  directed links. We apply Hidden Markov Model (Newson  and Krumm , 2009)  to perform map  matching, by assuming the GPS data noise follows Gaussian Distribution  with mean 𝜇=0  and standard deviation 𝜎=20, tolerance for non direct route 𝛽=2 and the maximal search  distance for candidate road segment  is 50 m . In addition, manual route inspection on the  matched routes was performed to ensure the route  quality .  Path Set Generatio n   We apply variants of selective  path generation algorithms based on shortest path to generate  alternative paths, they are: Labeling Approach, Link Penalty, Link Elimination, Simulation  Method , in which these algorithms repeatedly  change link impendence and find the minimum  cost path. Moreover, we apply the ViaNode Method , which finds admissible paths that pass  through via nodes.   Labeling Approach   Different labels which are related to the time dependent link travel time are used to  generate  alternative routes: fastest route s using link travel times correspond to AMpeak, PM peak,  offpeak, free flow and tripspecific  departure period; and shortest distance routes.  In this  method , a single route is generated for each label.   Link Pena lty  Two variants of  link penalty method s are applied by both replicating for 25 and 50 iterations,  with the following  procedures: (a) calculation of the fastest routes using trip specific  departure period link travel times; (b) increase travel times on the shortest path links by a  factor; (c) calculation of the fastest routes and comparison with the existing routes in th e path  set.   The first variant applies a uniform factor of 1.05 to all the links on the shortest path.  While   the second variant also applies penalties to all the links on the shortest path, but with a higher  penalty factor of 1.20 on local streets and a lo wer factor of 1.05 on higher hierarchical roads .  Because  we found that most of the observations prefer using the higher hierarchical roads  (e.g. highways and urban arterials) even if the total travel time is higher . Link Elimination   We apply link eliminati on as proposed by Prato and Bekhor (2006)  by repeating for 25 and  50 iterations  the following three steps: ( a) computation of the fastest  path by considering the  tripspecific departure period travel time , (b) elimination of a link belonging to the current   shortest path, and (c) computation of the next  shortest path. Shortest path links are eliminated  if they take the driver farther from the destination or compel the driver to turn from a high  hierarchical road to a low hierarchical road.   Simulation Method   Two simulation  approaches  are implemented  by computing  the shortest path for each draw of  link impedances  of the trip specific departure period . The two approaches exploit the same  procedure to draw impedances from a truncated normal distribution character ized from the  following parameters: (a) mean equal to the travel time, (b) variance equal to a percentage of  the mean, (c) left truncation limit equal to the free flow time, and (d) right truncation limit  equal to the travel time calculated for a minimum s peed assumed equal to 10 km/h.   The first simulation approach sets the variance equal to 20% of the mean . The second  simulation approach defines the variance equal to the mean.  Both simulation approaches are  extract ed for 25 and 50 draws.   ViaNode Method   We follow the procedures proposed by Abraham et al . (2013) to generate alternative routes.  The procedure starts by a bidirectional Dijkstra search to grow the search space s from origin  (s) and destination (t) respectively , with maximum search distance (1+ϵ)dst where ϵ is the  maximum detour percentage  and dst is the s t shortest path distance . And the meeting nodes  in search spaces are candidate via nodes  (Figure 1).     Figure 1 Candidate Via Nodes   In addition to the maximum detour constraint, the algorithm aims to generate routes with   overlap length to the shortest path no more than 𝛾⋅dst, i.e. the route generated is sufficiently  different from the shortest path. Moreover, the route also should be reasonable, and it is  formally defined as 𝛼locally optimal . That is, the sub path with forward and backward  length 𝛼⋅dst from the via node should be a shortest path . For example, in Figure 1 the sub  path between the red crosses should be a shortest path.   The maximum detour factor ϵ is set to be 30%, the overlap factor 𝛾 to be 8 5% and local  optimality factor 𝛼 to be 20%, these parameters are the  best setting obtained by trial and error  with our dataset.   Consistency Measurement   The effectiveness of route choice set  generation method  is evaluated  by the generated routes’  coverage over the observed routes. The coverage  is the percentage of observat ions for which  the algorithm is able to generate a route that satis fies a threshold for the overlap measure (eq.  1):  max 𝑟∑𝐼(𝑂𝑛≥𝛿)𝑁 𝑛=1   (1)  where 𝐼(∙) is the coverage function , and it equals to 1 if the argument  is true , 𝑂𝑛 is the  overlap percentage of observation 𝑛 and 𝛿 is the threshold for the overlap measure.  The  overlap measure evaluates the consistency of a generated route  with respect to the observed  behavior by considering the length of the links shared between generated and observed  routes   (eq. 2) :  𝑂𝑛=𝐿𝑛𝑟 𝐿𝑛   (2)  in which, 𝐿𝑛𝑟 is the overlapping length of generated route 𝑟 for observation 𝑛, and 𝐿𝑛 is the  length of the observed route  for observation 𝑛.  RESULTS   Several variations of the route generation algorithms described above were examined  in this  study. Table 2 shows the coverage results of different shortest path  labels. That is, each  algorithm generates exactly one route by minimizing a  specific time period travel time or  distance .  Table 2 Percentage Coverage of the Labeling Approach   80% Overlap  Threshold90% Overlap  Threshold100% Overlap  ThresholdAverage  Overlap Fastest Path (Tripspecific departure period) Fastest Path (AM peak) Fastest Path (PM peak) Fastest Path (Off peak) Fastest Path (Freeflow) Shortest Distance Path 42% 35% 32% 61%57% 47% 37% 73%LabelPercentage Coverage 59% 48% 37% 75% 59% 49% 38% 75%59% 48% 37% 75% 57% 46% 35% 74%   The above table shows that either the tripspecific departure period  fastest path or the off  peak fastest path are the best labels. Almost 60% percent of the 6,000 observations can be  covered (assuming a threshold of 80% distance overlap). This result is significantly higher in  comparison to previous result s reported in the literature, and may be related to compliance  with software navigation apps (such as Waze and Google Map).   As indicated above, the  labeling approach is able to cover almost 60% of the observations. In  order to improve the coverage, additio nal routes must be generated. We  examine link penalty,   link elimination, simulation and via node methods to generate multiple paths . The results are  presented in Table 3.   Table 2 Coverage of selected path generation algorithms   Path Generation Algorithm 80% Overlap  Threshold100% Overlap  ThresholdAverage OverlapAvg. number of  unique routes Link Penalty                        (uniform factor)94% 66% 96% 11.95 Link Penalty                     (higher penalty on local roads)97% 67% 97% 14.53 Link Elimination 82% 56% 91% 15.79 Simulation (large variance) 74% 53% 85% 2.94 Simulation (small variance) 74% 53% 85% 2.95 Combined 99% 76% 98% 32.34 Link Penalty                        (uniform factor)96% 69% 97% 26.64 Link Penalty                     (higher penalty on local roads)98% 69% 97% 31.68 Link Elimination 83% 56% 91% 23.58 Simulation (large variance) 77% 55% 86% 3.5 Simulation (small variance) 77% 56% 86% 3.5 Combined 99% 79% 98% 66.55 ViaNode 94% 69% 96% 28.2625 Shortest Path Iterations 50 Shortest Path Iterations Vianode Method   The link penalty method produce s a very good coverage  (94% for 80% threshold) . The  coverage improve s to 97% if local roads are more heavily penalized in comparison to higher  hierarchy roads.  Also, t he via node method provides sati sfying results in terms of coverage ,  with similar average number of unique routes  compared to the 50 iteration link penalty  methods.  Combining all 5 methods , with 25 iterations  for each method,  we obtain an  "
275,Scheduling links for heavy traffic on interfering routes in wireless mesh networks.txt,"We consider wireless mesh networks and the problem of scheduling the links of
a given set of routes under the assumption of a heavy-traffic pattern. We
assume some TDMA protocol provides a background of synchronized time slots and
seek to schedule the routes' links to maximize the number of packets that get
delivered to their destinations per time slot. Our approach is to construct an
undirected graph G and to heuristically obtain node multicolorings for G that
can be turned into efficient link schedules. In G each node represents a link
to be scheduled and the edges are set up to represent every possible
interference for any given set of interference assumptions. We present two
multicoloring-based heuristics and study their performance through extensive
simulations. One of the two heuristics is based on relaxing the notion of a
node multicoloring by dynamically exploiting the availability of communication
opportunities that would otherwise be wasted. We have found that, as a
consequence, its performance is significantly superior to the other's.","Owing to their numerous advantages, wireless mesh networks (WMN s) consti tute a promising solution for community networks and for providing la stmile connections to Internet users [1, 3, 22]. However, like all wireless n etworks WMNs suﬀer from the problem of decreased capacity as they becom e denser, since in this case attempting simultaneous transmissions causes inte rference to increase signiﬁcantly [15, 25]. One common solution to reduce interfe rence is to adopt some contentionfree TDMA protocol [11] and schedule s imultaneous transmissions for activation only if they do not interfere with one an other. Do ing this while maximizing some measure of network usage and guarante eing that all links are given a fair treatment normally translates into a com plicated optimization problem, one that unfortunately is NPhard [4]. This scheduling problem has been formulated in a great variety of man ners and has received considerable attention in the literature. Prominen t studies include some that seek to calculate the capacity of the network [15, 13], others whose goal is the study of the time complexity associated with the re sulting schedules [21], and still others that aim at scheduling transmissions in order to achieveasmuchofthe network’scapacityaspossible[10,2,28,12, 16,27,23,30, 29]. Onecommonthreadthroughmostthelatteristhat, havingado ptedagraph representation of the network and of how the various transmissio ns can interfere with one another, a solution is sought through some form of graph c oloring. More often than not the transmissions to be scheduled are repres ented by the graph’snodesandthennodecoloring,throughtheabstractionof anindependent set to represent the transmissions that can take place simultaneo usly, is used. But sometimes it is the graph’s edges that stand for transmissions, in which case edge coloring is used, building on the abstraction of matchings t o represent simultaneity [9]. Here we consider a variation of the problem which, to the best of our knowl edge, is novel both in its formulation and in the solution type we propo se. We start by assuming a WMN comprising singlechannel, singleradio node s and for which a set of origintodestination routes has already been de termined, and consider the following question. Should there be an inﬁnite supply of p ackets at each origin to be delivered to the corresponding destination in the FI FO order, and should all nodes in the network be endowed with only a ﬁnite numbe r of buﬀers for the temporary storage of intransit packets, how ca n transmissions be scheduled to maximize the number of packets that get delivered t o the desti nations per TDMA slot without everstalling a transmission, by lack ofb uﬀering space, whenever it is scheduled? This question addresses issues th at lie at the core of successfully designing WMNs and their routing protocols, sin ce it seeks to tackle the problem of transmission interference when the netwo rk is maxi mally strained. The solution we propose is, like in so many of the approa ches mentioned above, based on coloring a graph’s nodes. Unlike them, ho wever, we use node multicolorings instead [26], which are more general and for t his reason allow for a more suitable formulation of the optimization problem to be s olved. 2Given the origintodestination routes (or paths) to be used, we b egin in Section 2 with a precise deﬁnition of a schedule and a precise formulat ion of the problem. We also show, through an example, that had the problem be en for mulated for networkcapacity maximization, a conﬂict with the requ irement of ﬁnite buﬀering might arise. Then we move, in Section 3, to the speciﬁc ation of the undirected graph that underlies our algorithm’s operation. One assumption in that section, and therefore throughout most of the paper, is t hat the commu nication and interference radii are the same for the WMN at hand. M oreover, we also assume that the tenets of the protocolbased interferen ce model [8, 24], including the possibility of bidirectional communication in each transmis sion, are in eﬀect. In Section 4 we guide the reader through various multic olor ing possibilities, which culminates in Section 5 with a preliminary method fo r scheduling, borrowed from the ﬁeld of resource sharing [5]. Impro ving on this preliminary method with the goals of the problem formulated in Section 2 in mind ﬁnally yields our proposal in Section 6. This proposal, essentially, stems from a slight relaxation of the notion of a node multicoloring. The subs equent two sections are dedicated to the presentation of computational results, with the methodology laid down in Section 7 and the results proper in Sectio n 8. Discussion follows in Section 9 and we close in Section 10. 2 Problem formulation We consider a collection P1,P2,...,PPof simple directed paths (i.e., directed paths that visit no node twice), each having at least two nodes (a so urce and a destination). These paths’ sets of nodes are X1,X2,...,X P, respectively, not necessarily disjoint from one another, and we let X=/uniontextP p=1Xp. Their sets of edges are Y1,Y2,...,Y Pand we assume that, for p∝ne}ationslash=q, a member of Ypand one ofYqare distinguishable from each other even if they join the same two no des in the same direction. Letting Y=/uniontextP p=1Yp, we then see that Ymay contain more than one edge joining the same two nodes in the same direction ( parallel edges) or in opposing directions (antiparallel edges). Our discussion begins with the deﬁnition of the directed multigraph D= (X,Y), where all Pdirected paths are represented without sharing any directed edges among them. An example is shown in Figure 1. We take Dto be repre sentative of a wireless network operating under some TDMA protoc ol. In this network, each of paths P1,P2,...,PPis to transmit an unbounded sequence of packets from its source to its destination. Such transmissions are to occur with out contention, meaning that whenever an edge is scheduled to tra nsmit in a given time slot no other edge that can possibly interfere with that tr ansmission is to be scheduled at the same time slot. We assume that each transm ission sends at most one packet across the edge in question (more speciﬁ cally, it sends exactly one packet if there is at least one to be sent but does nothin g otherwise). We also assume that each transmission may involve the need for bidire ctional communication for error control. 33 d e3 1 f g2 4(a)a b c32 a4 2 cegdf b(b) 1 2 34 1 Figure1: Asetof P= 3directedpaths(a)andtheresultingdirectedmultigraph D(b). We call a schedule any ﬁnite sequence S=∝an}bracketle{tS0,S1,...,S L−1∝an}bracketri}htsuch that Sℓ⊆Yfor 0≤ℓ≤L−1, provided/uniontextL−1 ℓ=0Sℓ=Yand moreover no two concurrent transmissions on edges of the same Sℓcan interfere with each other. To schedule the transmissions according to Sis to cycle through the edge sets S0,S1,...,S L−1, indeﬁnitely and in this order, letting all edges in the same set transmit in the same time slot whenever that set is reached along the cycling. GivenS, welet length( S) =Landdenotebydelivered( S) the numberofpackets that can get delivered to all paths’ destinations during a single repe tition of S in the long run (i.e., in the limit as the number of repetitions grows withou t bound). Of course, delivered( S) is bounded from above by the number of times thePpaths’terminaledges(thoseleadingdirectlytoadestinationnode )appear inSaltogether. Before we use these two quantities to deﬁne the optimization proble m of ﬁnding a suitable schedule for D, we must recognize that our focus on the sourcetodestination packet ﬂows on the paths P1,P2,...,PPcarries with it the inherent constraint that the nodes’ capacity to buﬀer intra nsit packets cannot be allowedto growunbounded. We then adopt an upper boun dBon the number of intransit packets that a node can store for each of th e paths (at most P) that go through it. However, there is still a decision to be made reg arding the eﬀect of such a bound on the transmission of packets. One pos sibility would be to impose that, when it is an edge’s turn to transmit it does so if and only if there is a packet to transmit and, moreover, there is room to stor e that packet if it is received as an intransit packet. Another possibility, one that seeks to never stall a transmission by lack of a buﬀer to store the packet at the next intermediate node, is to only admit schedules that automatically rule o ut the occurrence of such a transmission. We adopt the latter alternativ e. The following, then, is how we formulate our scheduling problem on D. Find a schedule Sthat maximizes the throughput T(S) =delivered( S) length(S), (1) subject to the following two constraints: C1. Every node can store up to Bintransit packets for each of the sourceto destination paths that go through it. 43 d e(a)a b c1 4 f g h(b)a1 3 42b c de fgh1 4 36 65 7 7652 Figure2: Asetof P= 3directedpaths(a)andtheresultingdirectedmultigraph D(b). Using the schedule Ssuch that S0={a,f},S1={c,d},S2={b}, S3={e},S4={a,g}, andS5={h}causes unbounded packet accumulation at node 2 when constraint C2 is in eﬀect, thus violating constraint C1. E nforcing constraint C1 for some value of Bcauses constraint C2 to be violated. C2. Whenever an edge is scheduled for transmissionin a time slot and a packet is available to be transmitted, if the edge is not the last one on its sour ce todestination path then there has to be room for the packet to b e stored after it is transmitted. 2.1 Scheduling for maximum network usage Before proceeding, recall that, as mentioned in Section 1, the mos t commonly solved problem regarding the selection of a schedule Sis not the one we just posed, but rather the problem of maximizing network usage. In ter ms of our notation, this problem requires that we ﬁnd a schedule that maximize s U(S) =/summationtextL−1 ℓ=0|Sℓ| length(S)(2) without any constraints other than those that already participat e in the deﬁni tion of a schedule. It is a simple matter to verify that solutions to this problem often fail to re spect constraints C1 and C2 of our formulation. This is exempliﬁed in F igure 2. 3 Graph transformation We wish to address the problem of optimizing T(S) exclusively in terms of some underlying graph. Clearly, though, the directed multigraph Dis not a good candidate for this, since it does not embody any representat ion of how concurrent transmissions on its edges can interfere with one anot her. Our ﬁrst step is then to transform Dinto some more suitable entity, which will be the undirected graph G= (N,E) deﬁned as follows: 1. The node set NofGis the edge set YofD. In other words, Ghas a node for every edge of D. SinceDis a multigraph, a same pair of nodes i,j∈Xsuch that ( i,j)∈Yor (j,i)∈Ymay appear more than once as a member of N. 52. The edge set EofGis obtained along the following four steps: i. Enlarge Nby including in it all node pairs of Dthat do not cor respond to edges on any of the Psourcetodestination paths but nevertheless reﬂect that each node in the pair is within the interfer  ence radius of the other. We refer to these extra members of Nas temporary nodes. ii. Connect any two nodes in Nby an edge if, when regarded as node pairs from D, they share at least one of the nodes of D. In other words, if each of the two pairs i,j∈Xandk,l∈Xcorresponds to a node of G(by virtue of either constituting an edge of Dor being a temporary node), then the two get connected by an edge in Gif at least one of i=k,i=l,j=k, orj=lholds. iii. Connect any two nodes in Nby an edge if, after the previous steps, the distance between them is 2. iv. Eliminate all temporary nodes from Nand all edges from Ethat touch them. Together, these four steps amount to using Gto represent every possible interference that may arise under the assumptions of the protoc olbased model when communication is bidirectional. Graph Gis also known as a distance2 graph relative to D[4]. The entire transformation process, from the set of Ppaths through graph G, is illustrated in Figure 3. It follows from this deﬁnition of Gthat any group of nodes corresponding to parallel or antiparallel edges in Dare a clique (a completely connected sub graph) of G. Similarly, every group of three consecutive edges on any of the pathsP1,P2,...,PPcorresponds to a threenode clique in G. As we discuss in Section 9, these and other cliques are related to how large T(S) can be under one of the scheduling methods we introduce. It is also worth noting that Steps 1 and 2 above are easily adaptable t o mod iﬁcations in any of the assumptions we made. These include the assum ptions that the communication and interference radii are the same and th at communi cation is bidirectional. Changing assumptions would simply require us to adapt Steps 2.i through 2.iii accordingly. 4 Multicoloringbased schedules GraphGallows us to rephrase the deﬁnition of a schedule as follows. We call a schedule any ﬁnite sequence S=∝an}bracketle{tS0,S1,...,S L−1∝an}bracketri}htsuch that Sℓ⊆Nfor 0≤ℓ≤L−1, provided/uniontextL−1 ℓ=0Sℓ=Nand moreover every Sℓis an independent set ofG. The appearance of the notion of an independent set in this deﬁnitio n leads the way to a special class of schedules, namely those that can be identiﬁed with graph multicolorings [26]. Forq≥1, aqcoloring of the nodes of Gis a mapping from N, the graph’s set of nodes, to Nq, whereNis the set of natural numbers, such that no two of a 6fx de f(c)c a x d e gbfx d ea c gb (b) c a e gb d(d)a b c(a) gf Figure 3: The graphtransformation process. We start with the d irected multi graphD(a), to which the node pair labeled xis added as a dashed line to indicate the existence of interference that is not internal to any o f the initial P paths. Panel (b) contains the undirected graph Gas it stands after Step 2.ii. Panels (c) and (d) show Gpast Steps 2.iii and 2.iv, respectively. In these two panels, dashed lines are used to represent the edges added in Step 2.iii. node’sqcolors are the same and besides none of them coincides with any one o f anyneighbor’s qcolors. Ofcourse, the set ofnodes receivingone particularcolor is an independent set. If pis the total number of colors needed to provide G with aqcoloring, then Nis covered by the pindependent sets that correspond to colors and every node is a member of exactly qof these sets. Therefore, lettingL=pand identifying each Sℓwith the set of nodes receiving color ℓ implies that to every qcoloring of the nodes of Gthere corresponds a schedule S. These multicoloringderived schedules constitute a special case in t he sense that every node of Gcan be found in exactly the same number of sets ( q) out of theLsets that make up the schedule. Clearly, though, there are sched ules that do not correspond to multicolorings. For now we concentrate on those that do and note that delivered( S)≤Pqalways holds (recall that Pstands for the number of origintodestination paths). That is, the greatest nu mber of packets that the Pterminal edges of Dcan deliver during the Ltime slots of schedule Sisqper terminal edge. These schedules can be further specialized, as follows. 74.1 Standard coloring Whenq= 1 every node of Greceives exactly one color and length( S) =L≥ χ(G), where χ(G) is the least number of colors with which it is possible to provideGwith a 1coloring, known as the chromatic number of G. UsingT1(S) to denote T(S) in this case, we have T1(S)≤P χ(G). (3) 4.2 Standard multicoloring Coloring G’s nodes optimally in the previous case is minimizing the overall number of colors. This stems not only from the fact that q= 1, but more generally from the fact that qis ﬁxed. We can then generalize and deﬁne χq(G) to be the least number of colors with which it is possible to provide Gwith aqcoloring. Evidently, χ(G) =χ1(G)< χ2(G)<···, so the question of multicoloring G’s nodes optimally when qis not ﬁxed can no longer be viewed as that of minimizing the overall number of colors needed (as this wou ld readily lead toq= 1 and χ(G) colors). Instead, we look at how eﬃciently the overall number of colors is used, i.e., at what the value of qhas to be so that χq(G)/q is minimized. This gives rise to the multichromatic number of G, denoted by χ∗(G) and given by χ∗(G) = inf q≥1χq(G)/q. Because this inﬁmum can be shown to be always attained, we use minimum instead and let q∗be the value ofqfor which χ∗(G) =χq∗(G)/q∗. Using aqcoloringfor scheduling amounts to having length( S) =L≥χq(G). In this case, letting T∗(S) stand for T(S) yields T∗(S)≤Pq χq(G)≤Pq∗ χq∗(G)=P χ∗(G). (4) 4.3 Interleaved multicoloring A special class of qcolorings is what we call interleaved qcolorings [7, 6, 31]. If iandjare two neighboring nodes of G, letci 1< ci 2<···< ci qbe theqcolors assigned to node iby some qcoloring, and likewise let cj 1< cj 2<···< cj qbe those of node j. We say that this qcoloring is interleaved if and only if either ci 1< cj 1< ci 2< cj 2<···< ci q< cj qorcj 1< ci 1< cj 2< ci 2<···< cj q< ci qfor all neighbors iandj. If we restrict ourselves to interleaved qcolorings, then similarly to what we did above we use χq int(G) to denote the least number of colors with which it is possible to provide Gwith an interleaved qcoloring, and similarlydeﬁnetheinterleavedmultichromaticnumberof G, denotedby χ∗ int(G), to beχ∗ int(G) = inf q≥1χq int(G)/q. Once again it is always possible to attain the inﬁmum, so we may take q∗to be the value of qfor which χ∗ int(G) =χq∗ int(G)/q∗. 8As forschedulingbasedonaninterleaved qcoloring,it correspondstohaving length(S) =L≥χq int(G). As before, we use T∗ int(S) in lieu of T(S) and obtain T∗ int(S)≤Pq χq int(G)≤Pq∗ χq∗ int(G)=P χ∗ int(G). (5) 4.4 Discussion It is a wellknown fact that 1 χ(G)≤1 χ∗ int(G)≤1 χ∗(G). (6) The ﬁrst inequality follows from the deﬁnition of χ∗ int(G), considering that ev ery 1coloring is (trivially) interleaved. As for the second inequality, it fol lows directly from the deﬁnition of χ∗(G). By these inequalities, should all of Eqs. (3)–(5) hold with equalities, we would have T1(S)≤T∗ int(S)≤T∗(S). (7) Obtaining equalities in Eqs. (3)–(5), however, requires both that d elivered(S) = Pqforq= 1 orq=q∗, as the case may be, and that length( S) =χq(G) with the same possibilities for qor length( S) =χq∗ int(G). While the combined requirements involve the exact solution of NPhar d problems (ﬁnding any of χ(G),χ∗ int(G), andχ∗(G) is NPhard; cf., respec tively, [17], [7], and [14]), the former one alone is always a property of s chedules based on multicolorings when buﬀering availability is unbounded. To see that this is so, ﬁrst recall that the deﬁnition of delivered( S) refers to a repetition of the whole schedule as far down in time as needed for any transient eﬀ ects to have waned. So, given any of the Psourcetodestination paths, we can prove that delivered( S) =Pqby arguing inductively about what happens on such a path during that future repetition of S. The basis case in this induction is the ﬁrst directed edge on the path (the one leading out of the source) . The prop erty that every appearance of this edge does indeed transmit a pa cket follows trivially from the fact that the source has an endless supply of new p ackets to provide whenever needed. Assuming that this also happens to the n exttolast edge on the path (this is our induction hypothesis) immediately leads t o the same conclusion regarding the last edge, the one on which delivered( S) is de ﬁned. To see this, let ebe the last edge and e−the nexttolast one. Because S is repeated indeﬁnitely, every time slot tsuﬃciently far down in time in which eappears is the closing time slot of a window in which both eande−appear exactlyqtimes each. By the induction hypothesis, it follows that at least one packet is guaranteed to exist for transmission through eat time slot t. Buﬀering availability, however, is not unbounded, so we must argue f or its ﬁniteness. Wedothisbyrecognizinganotherimportantpropertyo fmulticoloring based schedules, one that is related to constraints C1 and C2 intro duced earlier. Because every edge of D(node of G) appears the exact same number qof times 9hb d f h(a) c e g(b) aa eg c f db Figure 4: A set of P= 4 paths (a), with dashed lines indicating all node pairs representing oﬀpath interference. The resulting graph Gis shown in panel (b). Depending on the schedule Sit is possible to obtain equalities in all of Eqs. (3)–(5). The schedules that achieve this while implying strict ine quali ties in Eq. (6) are: S=∝an}bracketle{t{a,d,g},{b,f,h},{c,e}∝an}bracketri}htfor Eq. (3), with T1(S) = 4/3≈1.33;S=∝an}bracketle{t{a,d,f},{b,e,g},{c,f,h},{a,d,g},{b,e,h},{a,c,f},{b,d,g}, {c,e,h}∝an}bracketri}htfor Eq. (5), with T∗ int(S) = 4/(8/3) = 1.5; andS=∝an}bracketle{t{a,c,f},{b,e,g}, {c,e,h},{a,d,g},{b,d,f,h}∝an}bracketri}htfor Eq. (4), with T∗(S) = 4/(5/2) = 1.6. inS, there certainly always is a ﬁnite value of B, the number of buﬀer positions per node per path that goes through it, such that C1 and C2 are sa tisﬁed. In all interleaved cases, this value is B= 1. An example illustrating all of this is presented in Figure 4, where we give a set of four sourcetodestinationpaths, the graph Gthat eventually results from them, and also the three schedules that result in equalities in Eqs. (3 )–(5). In this case the two inequalities in Eq. (6) are strict, since it can be show n that χ(G) = 3,χ∗ int(G) = 8/3, andχ∗(G) = 5/2 [26, 7]. 5 Scheduling by edge reversal From the three schedules illustrated in Figure 4 it would seem that ﬁnd ing a schedule Sto maximize T(S) requires that we give up on the interleaved character of the underlying multicoloring and, along with it, give up on the equivalent property that edges of Dthat are consecutive on some sourceto destination path appear in Salternately. However, once color interleaving is assumedweareautomaticallyprovidedwithaprincipledwaytoheurist icallytry and maximize T(S) by appealing to a curious relationship that exists between multicolorings and the acyclic orientations of G. We now review this heuristic and later build on it by showing how to adapt it to abandon interleaving o nly on occasion during a schedule, aiming at maximizing T(S). Anorientationof Gisanassignmentofdirectionstoitsedges. Anorientation ofGis acyclic if no directed cycles are formed. Every acyclic orientation h as a set of sinks (nodes with no edges oriented outward), which by deﬁ nition are not neighbors of one another. An acyclic orientation’s set of sinks is then an 10independent set. The heuristic we now describe, known as schedulin g by edge reversal (SER) [7, 5], is based on the following property. Should an a cyclic orientation be transformed into another by turning all its sinks into sources (nodes with no edges oriented inward), and should this be repeated indeﬁnitely, wewouldobtainaninﬁnite sequenceofindependent sets, eachgiven bythesetof sinks of the current orientation. Though inﬁnite, this sequence mu st necessarily reach a point from which a certain number of acyclic orientations get s repeated indeﬁnitely. This follows from the facts that there are only ﬁnitely ma ny acyclic orientations of Gand that turning one of them into the next is a deterministic process. The orientations that participate in this cyclic repetition, hencefor th called a period, have the property that every node of Gappears as a sink in the same number of orientations. Furthermore, any two neighboring nodes ofGare sinks in alternating orientations, regardless of whether the period has a lready been reached or not. It clearly follows that the sets of sinks in a period co nstitute a schedule that is based on an interleaved multicoloring. Depending on the very ﬁrst acyclic orientation in the operation of SER more than one p eriod can eventually be reached. The diﬀerent periods’ properties vary from one to another,butitcanbeshownthatatleastoneofthemcorrespond stotheoptimal interleaved multicoloring, i.e., the one that yields χ∗ int(G) [7]. The heuristic nature of SER is then revealed by the need to determine an appropr iate initial acyclic orientation. Determining a schedule Sby SER follows the algorithm given next. We use ω0,ω1,...to denote the sequence of acyclic orientations of G. Fort= 0,1,..., we denote by Sinks( ωt) the set of sinks of ωt. Algorithm SER: 1. Choose ω0. 2.t:= 0. 3. Obtain ωt+1fromωt. 4. If the period has not yet occurred, then t:=t+ 1; go to Step 3. If it has, then let p(ω0) be its number of orientations, m(ω0) the number of times any node appears in them as a sink, and ωk,ωk+1,...,ω k+p(ω0)−1 the orientations themselves. Output S=∝an}bracketle{tSinks(ωk),Sinks(ωk+1),...,Sinks(ωk+p(ω0)−1)∝an}bracketri}ht and T(S) =Pm(ω0) p(ω0). In this algorithm, the explicit dependency of both p(ω0) andm(ω0) onω0is meant to emphasize that, implicitly, the two quantities are already de termined when in Step 1 the initial orientation ω0is chosen. As with the very existence of 11the period, thisfollowsfromthe factthat the algorithm’sStep 3is de terministic, so there really is no choice regarding the period to be reached once ω0has been ﬁxed. The role played by the two quantities is precisely to character ize the interleaved multicoloring mentioned above. That is, the period reach ed from ω0can be regarded as assigning q=m(ω0) distinct colors to each node of G using a total number p=p(ω0) of colors. Equivalently, it can be regarded as a schedule Sfor which delivered( S) =Pq=Pm(ω0) (where the ﬁrst equality is true of all multicoloringbased schedules, as we discussed in Sectio n 4) and length(S) =L=p=p(ω0). By Eq. (1), the ﬁnal determination of T(S) follows easily. As a ﬁnal observation, we note that, although the knowledge of p(ω0) and m(ω0) after Step 1 is only implicit, it can be shown that the ratio m(ω0)/p(ω0) can be known explicitly at that point [7]. It might then seem that the r emainder of the algorithm is useless, since the value of T(S) can be calculated right after Step 1. But the reason why the remaining steps are needed, of cou rse, is that Sitself needs to be found, not just the T(S) that quantiﬁes its performance. 6 Improving on SER In Figure 5 we provide an example to illustrate why giving up interleaving may yield a schedule Sof higher T(S). The general idea is that, given B, it may be possible to schedule a given transmission sooner than it normally wo uld be scheduled by SER, provided there is a packet to be transmitted in th e buﬀers of the sending node in Dand the receiving node has an available buﬀer position for the path in question. While under SER two transmissions sharing a buﬀer alternate with each other in any schedule (and then B= 1 always suﬃces), disrupting this alternance implies that all buﬀering is to be managed in d etail. In the example of Figure 5 transmissions g,h, andiare scheduled without regardto alternanceif B= 2. While this results in improvedperformance(more packetsdeliveredtonode 4pertime slot), it is importanttorealizeth at thisis in great part made possible by the structure of Din this example. Even though all three paths lead from node 1 to node 4, two of them are poised to int erfere with each other particularly heavily by virtue of sharing node 2. The cons equence of this is that transmissions on these paths will occur less in parallel t han they might otherwise. But since B= 2 buﬀering positions are available per node per path, the path that goes through nodes 6 and 7 can compensa te for this by transmitting twice as much traﬃc (thence the double occurrence o fgin a row, and also of handi, for each repetition of the schedule). This, however, is never detrimental to the traﬃc on the other two paths: all that is being d one is to seize the opportunity to transmit in time slots that would otherwise g o unused. Implementing the careful buﬀer management alluded to above requ ires that we look at the dynamics of acyclicorientation transformation unde r SER in more detail. Given any acyclic orientation ωofG, the node set NofGcan be partitioned into independent sets I1,I2,...,I dsuch that I1is the set of all sinks in Gaccording to ω,I2is the set of all sinks we would obtain if all 12(c)a dec f g hib 1 43 52 76(b)a b c d e f g h i1 62 3 4 75 1 12 4 4(a) a c geb h if d Figure 5: A set of P= 3 directed paths (a), the resulting directed multigraph D (b), and the resulting undirected graph G(c). The optimal SER schedule is S= ∝an}bracketle{t{a},{b},{c,g},{d,i},{e,h},{f}∝an}bracketri}ht, yielding T(S) = 3/6 = 0.5. An alternative schedulethatdoesnotcomplywiththeSERalternancecondition, wit hB= 2,is S=∝an}bracketle{t{g,c},{g,f},{h,b},{h,e},{i,a},{i,d}∝an}bracketri}ht, which results in an improvement toT(S) = 4/6≈0.67. nodes in I1were to be eliminated, and so on. In this partition, known as a sink decomposition, dis the number of nodes on a longest directed path of G according to ω. Whenωis turned into ω′by SER a new sink decomposition is obtained, call it I′ 1,I′ 2,...,I′ d′, such that I′ 1=I2,I′ 2⊇I3, etc., with d′≤d. The reason why equality need not hold in all cases, but set containment in stead, is that each Ikmay get enlarged by some of the previous orientation’s sinks before becoming I′ k−1. It is then possible to regard the operation of SER as simply a recipe fo r manipulating sink decompositions. At each iteration the set containin g the currentsinksiseliminatedanditsnodesareredistributedthrought heothersets. The remaining sets are renumbered by decrementing their subscrip ts by 1 and a new, greatestsubscript set may have to be created. The rule fo r redistributing each of the former sinks is to ﬁnd the set of greatest subscript co ntaining one of the node’s neighbors in G, sayIk, and then place the node in set Ik+1. This is illustrated in panels (a) and (b) of Figure 6. Altering this rule is the core of our modiﬁed SER, henceforth called SE R with advancement (SERA). If iis the sink in question, the operation of SERA is based on placing node iin the leastsubscript set that does not contain a neighbor of iinG. This clearly maintains acyclicity just as the previous rule does, but now the former sink is not necessarily turned into a sourc e, but rather 135b c d e 1 2 3 4a(a)f 5 1 2 3 4(c) d ef b ac1 2 3 4(b) d ef bc a Figure 6: Each set in a sink decomposition is represented by a rectan gular box and numbered to indicate the set’s subscript. Note that directed e dges refer to acyclic orientations of G. Applying SER to the sink decomposition in panel (a) yields the one in panel (b). In this transformation both aandbare turned into sources. The alternative of using SERA, on the other hand, makes it possible forato be placed in a lowersubscript set, avoiding the transformation in to a source and yielding the sink decomposition in panel (c). This can be d one only because the set to which ais added contains none of its neighbors in G. Assuming that transmissions a,e, andfare initially arranged consecutively in one of the Ppaths in the order e,a,f, we have i−=e,i=a, andi+=f. We also have, in reference to panel (a), k−= 4,k= 2, and k+= 5. Then the additional conditions for the move from (a) to (c) to occur are tha t the buﬀers shared by transmissions eandacontain at least one packet (since k < k−), and that those shared by aandfhave room for at least one packet (since k < k+). intoanodethatcanhaveedgesorientedbothinwardandoutwardb ythecurrent orientation, respectively from nodes in sets of greater subscript s and to nodes in sets of lesser subscripts. Additionally, while this alternative placem ent of nodeidoes favor it by virtue of lowering the number of time slots that need to go by before it is a sink once again, clearly there is no detriment to a ny of the other transmissions, which will assuredly become sinks no later t han they would otherwise. As we mentioned, however, unlike SER this rule can only be applied as a function of Band the buﬀeringrelated constraints we mentioned. Suppose thatiis preceded by transmission i−and succeeded by transmission i+on the original path out of P1,P2,...,PPto which it belongs. Of course, both i− andi+are nodes of Gas well. Suppose further that these two nodes are in 14setsIk−andIk+, respectively, and that we are attempting to place node iin setIk. The further constraints to be satisﬁed are the following. If k < k−, then the buﬀers shared by transmissions i−andimust contain at least one packet to be transmitted. If k < k+, then the buﬀers shared by transmissions iandi+must contain room to store at least one more packet. This can all be implemented rather easily by keeping a dynamic record of all buﬀers. A simple case of evolving sink decompositions in the SERA style is shown in panels (a) and (c) of Figure 6. SERA,likeSER,operatesonﬁnitelymanypossibilitiesanddeterministic ally. A “possibility” is no longer simply an acyclic orientation, but instead an a cyclic orientation together with a conﬁguration of buﬀer occupation. In any event, periodic behavior is still guaranteed to occur and we go on denoting b yp(ω0) the number of possibilities in the period that one reaches from ω0. The notion behindm(ω0), however,hasbeen losttogetherwith thecertaintyofinterleav ing, since SERA does not guarantee that every node of Gis a sink in the period the same number of times. For i∈N, an alternative deﬁnition is that of mi(ω0), which we henceforth use to denote the number of times node iis a sink in the period, not necessarily the same for all nodes. Determining the schedule Sthrough SERA proceeds according to the fol lowing algorithm. Algorithm SERA: 1. Choose ω0. 2.t:= 0. 3. Obtain ωt+1fromωt, employing advancement as described. 4. If the period has not yet occurred, then t:=t+ 1; go to Step 3. If it has, then let p(ω0) be its number of orientations (with associated buﬀer occupation conﬁgurations), mi(ω0) the number of times node iappears in them as a sink, and ωk,ωk+1,...,ω k+p(ω0)−1the orientations themselves. Output S=∝an}bracketle{tSinks(ωk),Sinks(ωk+1),...,Sinks(ωk+p(ω0)−1)∝an}bracketri}ht and T(S) =/summationtext i∈Tmi(ω0) p(ω0), whereTis the set of the nodes of Gthat correspond to terminal edges of the paths P1,P2,...,PP. In this algorithm, note that the determination of T(S) generalizes what is done in SER. This is achieved by adopting delivered( S) =/summationtext i∈Tmi(ω0) while maintaining length( S) =p(ω0) in Eq. (1). Particularizing this to the case of SER yields delivered( S) =Pm(ω0), as desired, since mi(ω0) becomes m(ω0) for any node iofGand moreover |T|=P. 157 Methods "
30,Improving the Approximation Ratio for Capacitated Vehicle Routing.txt,"We devise a new approximation algorithm for capacitated vehicle routing. Our
algorithm yields a better approximation ratio for general capacitated vehicle
routing as well as for the unit-demand case and the splittable variant. Our
results hold in arbitrary metric spaces. This is the first improvement upon the
classical tour partitioning algorithm by Haimovich and Rinnooy Kan and
Altinkemer and Gavish.","In the Capacitated Vehicle Routing problem, we are given a metric space with a depot and customer s, each with a positive demand between 0 and 1. The goal is to desi gn tours of minimum total length such that each tour contains the depot, each customer is served by some tour, and the total demand of the customers in one tour does not exceed 1 (after scaling, this is the vehic le capacity). Capacitated Vehicle Routing generalizes the famous traveling salesman problem and has o bvious applications in logistics. There is a huge body of literature studying heuristics, mixedinteger pro gramming models, and application scenarios. The so far best known approximation algorithm is more than 30 years old and quite simple: it ﬁrst computes a traveling salesman tour (ignoring the capacity c onstraint) and then partitions the tour optimally into segments of total demand at most 1, each of which is then s erved by a separate tour from the depot. The approximation ratio of this algorithm is α+2, where αis the approximation ratio of an algorithm computing the traveling salesman tour. Essentially the same algorith m has been the best known for the unitdemand special case (where all customers have the same demand), and also for the variant where a customer’s demand can be split and served by more than one tour. For these specia l cases, the approximation ratio is α+ 1. These algorithms have been proposed and analyzed in the 1980 s by Altinkemer and Gavish [ 2] and Haimovich and Rinnooy Kan [ 18]. Despite many eﬀorts and progress in special cases (cf. Sec tion1.3), they have not been improved, except that the traveling salesman t our can now be computed by the Karlin–Klein– Oveis Gharan algorithm [ 20] instead of the Christoﬁdes–Serdjukov algorithm [ 11,24], which improves αto slightly less than3 2if one allows randomization. In this paper we improve upon the classical algorithms of [ 2] and [ 18]. Our result is a better blackbox reduction to the traveling salesman problem. Therefore, ou r new algorithm has a better approximation ratio than the classical algorithms of [ 2] and [ 18], and this will remain true if the approximation ratio for th e traveling salesman problem will be improved further. Here a re our main results: Theorem 1. For every α >1there is an ε >0such that the following holds. If there is an αapproximation algorithm for the traveling salesman problem, then there is an(α+ 2·(1−ε))approximation algorithm for Capacitated Vehicle Routing . For α=3 2we have ε >1 3000. 1Research Institute for Discrete Mathematics and Hausdorﬀ C enter for Mathematics, University of Bonn, Germany. Email: blauth@or.unibonn.de. 2Department of Mathematics, ETH Zurich, Switzerland. Email : vera.traub@ifor.math.ethz.ch. Supported by Swiss Natio nal Science Foundation grant 200021_184622. 3Research Institute for Discrete Mathematics and Hausdorﬀ C enter for Mathematics, University of Bonn, Germany. Email: vygen@or.unibonn.de. 1Theorem 2. For every α >1there is an ε >0such that the following holds. If there is an αapproximation algorithm for the traveling salesman problem, then there is an(α+1−ε)approximation algorithm for Unit Demand Capacitated Vehicle Routing andSplittable Capacitated Vehicle Routing . For α=3 2 we have ε >1 3000. 1.1 Outline To obtain our results, we analyze instances for which the app roximation guarantees of [ 2] and [ 18] are almost tight and exploit their structure to design better solution s. We will call such instances diﬃcult . We view every tour in a solution to a Capacitated Vehicle Routing instance as the union of two paths from the depot to the peak of the tour: the point farthest away from the depot. Our ﬁrst o bservation is that the performance of the classical algorithms can be cl ose to the worst case guarantee only if, for most tours, these two paths have small detour, i.e., they are appr oximately shortest paths from the depot to the peak. We will compute an even number of paths that all start at the de pot such that all customers are visited by some path. The total length of these paths will not be much m ore than the length of an optimum solution to the Capacitated Vehicle Routing instance. Then we combine pairs of these paths to tours by add ing an edge between their endpoints. If there exists a set of paths with small total detour (like th e one induced by an optimum solution to a diﬃcult instance), then we can ﬁnd a set of paths that is not mu ch longer in polynomial time. In fact, this problem is closely related to regretbounded vehicle routi ng, a problem that has been studied by Friggstad and Swamy [ 15,16]. Here, one asks for a minimum number of paths serving all cus tomers such that the detour of any path is bounded. However, combining pairs of paths to tours can be too expensi ve. We need to ensure that a relatively cheap matching of the endpoints of the paths exists. Ideally , two paths end at the peak of each tour in an optimum solution, then the matching would not cost anything . But of course we do not know these peaks. Therefore we try to “guess” them, by exploiting another prop erty of diﬃcult instances: in almost all tours of an optimum solution, the total demand of customers near th e peak is almost 1 (the vehicle capacity). Consequently, we can assume that “most” customers are clust ered, and we can force two paths to end in each cluster. However, another diﬃculty arises because the clusters are n ot necessarily clearly separated from one another. Still we can identify groups of nearby clusters, an d estimate the number of tours whose peak is in that group. Instead of prescribing the endpoints of the path s, we only specify the total number of paths that must end in each group. This number will always be even, in ord er to ensure that we can ﬁnd a matching within each group. Although customers in the same group can b e far away from each other if there is a chain of pairwise overlapping clusters, we will be able to prove th at a relatively cheap matching exists. The key subproblem therefore asks to ﬁnd an appropriate numb er of paths that begin at the depot and end in these target groups, such that all customers (includi ng those that do not belong to any group) are served by some tour. We call this problem Vehicle Routing with Target Groups . The instance of Vehicle Routing with Target Groups that we compute has the property that it has a solution that is cheap and has small total detour. This will enable us to ﬁnd a cheap set of paths in polynomial time: either by a simple and fast combinatorial algorithm, or alte rnatively by leveraging an LPbased approach suggested for regretbounded vehicle routing by Friggstad and Swamy [ 16].1 Once we have these paths, we compute the cheapest matching of their endpoints and combine them to tours. These tours will generally still not meet the capac ity constraint, but we can simply concatenate all these tours (and shortcut) to obtain a traveling salesma n tour. Since this tour will be not much more expensive than an optimum solution to our Capacitated Vehicle Routing instance, applying the classical tour partitioning algorithm ﬁnishes the job. 1.2 Formal problem description Given a depot sand a set Vof customers, we want to design tours serving all customers. For now, a tour is a cycle that contains sand a subset of customers (later we will also consider tours t hat begin in sbut do 1As a byproduct, we will also improve their approximation ra tio for regretbounded vehicle routing from 15 to 10. 2not end in s). To measure the cost of a tour, we have a semimetric c: ({s} ∪V)×({s} ∪V)→R≥0, i.e., cis symmetric and satisﬁes the triangle inequality. We will i nterpret a tour Qas an undirected graph with vertex set V(Q) and edge set E(Q). We write c(Q) =/summationtext {v,w}∈E(Q)c(v, w) for the cost (or total distance) ofQ. Moreover, each customer has a demand, and the total demand o f the customers served by a tour must not exceed the vehicle capacity, which we can assume to b e 1 (by scaling). Then the problem can be described as follows. Deﬁnition 3 (Capacitated Vehicle Routing ).An instance of Capacitated Vehicle Routing con sists of •a ﬁnite set V(ofcustomers ) •adepot s, not belonging to V, •a semimetric con{s} ∪V, deﬁning distances (orcost), •ademand d(v)∈[0,1]for each customer v∈V. A feasible solution is a set Qoftours such that •every tour Q∈ Q is a cycle that contains s, •every customer belongs to exactly one tour, and •/summationtext v∈V(Q)\{s}d(v)≤1for all Q∈ Q. The task is to ﬁnd a feasible solution such that the total cost (or distance) c(Q) :=/summationtext Q∈Qc(Q)is minimum. Throughout, we will denote by OPT( I) or simply OPT the minimum cost of a feasible solution to a giv en instance I. We note the following wellknown lower bound: Proposition 4. OPT ≥/summationtext v∈V2d(v)c(s, v). Proof. LetQbe a feasible solution. For each v∈Vwe obtain two svpaths by splitting the tour Q∈ Q that contains v. By the triangle inequality, each of these paths has length a t least c(s, v), and hence 2c(s, v)≤c(Q). Summation yields/summationtext v∈V2d(v)c(s, v)≤/summationtext Q∈Q/summationtext v∈V(Q)\{s}d(v)c(Q)≤c(Q). Ifd(v) =1 kfor all v∈V, where kis some positive integer, we speak of UnitDemand Capacitated Vehicle Routing (then every tour can serve up to kcustomers). This is closely related to Splittable Capacitated Vehicle Routing : here the demand of a customer is arbitrary but can be split in to several parts, each of which is served by a diﬀerent tour. All variants include the traveling salesman problem as spec ial case and are thus APXhard. Capacitated Vehicle Routing also includes bin packing; hence there is no approximation a lgorithm with ratio less than 3 2unless P=NP. 1.3 Related work "
0,Not All SWAPs Have the Same Cost: A Case for Optimization-Aware Qubit Routing.txt,"Despite rapid advances in quantum computing technologies, the qubit
connectivity limitation remains to be a critical challenge. Both near-term NISQ
quantum computers and relatively long-term scalable quantum architectures do
not offer full connectivity. As a result, quantum circuits may not be directly
executed on quantum hardware, and a quantum compiler needs to perform qubit
routing to make the circuit compatible with the device layout. During the qubit
routing step, the compiler inserts SWAP gates and performs circuit
transformations. Given the connectivity topology of the target hardware, there
are typically multiple qubit routing candidates. The state-of-the-art compilers
use a cost function to evaluate the number of SWAP gates for different routes
and then select the one with the minimum number of SWAP gates. After qubit
routing, the quantum compiler performs gate optimizations upon the circuit with
the newly inserted SWAP gates.
  In this paper, we observe that the aforementioned qubit routing is not
optimal, and qubit routing should \textit{not} be independent on subsequent
gate optimizations. We find that with the consideration of gate optimizations,
not all of the SWAP gates have the same basis-gate cost. These insights lead to
the development of our qubit routing algorithm, NASSC (Not All Swaps have the
Same Cost). NASSC is the first algorithm that considers the subsequent
optimizations during the routing step. Our optimization-aware qubit routing
leads to better routing decisions and benefits subsequent optimizations. We
also propose a new optimization-aware decomposition for the inserted SWAP
gates. Our experiments show that the routing overhead compiled with our routing
algorithm is reduced by up to $69.30\%$ ($21.30\%$ on average) in the number of
CNOT gates and up to $43.50\%$ ($7.61\%$ on average) in the circuit depth
compared with the state-of-the-art scheme, SABRE.","Quantum computing has shown immense promise for accelerating chemistry simulation [15], prime factoriza tion [44], database search [12], and machine learning [8]. Recently, Google, IBM, Intel, and Honeywell announced their quantum computers with 72, 65, 49, and 10 qubits, respectively [2], [11], [13], [16]. These quantum computers with few tens to hundreds of qubits are termed as Noisy IntermediateScale Quantum (NISQ) computers [42]. Many quantum system works [19]–[27] have been recently pro posed for the NISQ systems. Although NISQ computers do not have enough qubits to accommodate error correctioncodes, they are useful for exploring quantum algorithms and demonstrating quantum supremacy [6]. Both nearterm NISQ systems [6], [11], [13] and the longterm scalable quantum architectures [35]–[37] do not support full connectivity among a high number of qubits. However, quantum algorithms are developed with an implicit assumption of a fullyconnected quantum computer. Such mismatch makes the qubit mapping and routing critical challenges in quantum computing systems. A quantum compiler is responsible for a number of tasks, including decomposing higherlevel gates to basic ones supported natively by the target quantum hardware, restruc turing quantum circuits, optimizing circuits, and scheduling quantum gate operations. During the restructuring step, the compiler performs the logicaltophysical qubit mapping and qubit routing. Speciﬁcally, the compiler needs to in sert SWAP gates and perform circuit transformations to make the circuit layout compatible with the device lay out. When inserting the SWAP gates, the compiler would evaluate different routing candidates based on a cost func tion. The cost function is computed based on the number of SWAP gates [28] and/or the ﬁdelity of the inserted SWAP gates [40]. After qubit mapping and routing, the compiler performs circuit optimizations such as template matching [29], commutation analysis [14], and gate can cellation [30] to optimize the circuit. In the stateofthe art approaches [28], [40], the qubit routing step selects the best route based on the backend topology, qubit ﬁdelity, and logical circuit topology while being independent upon the subsequent circuit optimization step. In this paper, we make the key observation that the aforementioned compilation ﬂow and the cost functions have several shortcomings. First, the qubit routing step and the circuit optimization step should not be independent. Finding the shortest path with the minimum number of SWAP gates at the routing step may not lead to the optimal design. The reason is that the inserted SWAP gates can be optimized by the subsequent optimizations. When considering the optimization opportunities at the routing step, the SWAP gates should not be treated equally. Some of the SWAP gates may lead to fewer CNOT gates than others. Therefore, rather than the number of inserted SWAP gates, we propose to use the number of inserted CNOT gates as the cost metric since 1arXiv:2205.10596v1  [quantph]  21 May 2022not all of the SWAP gates lead to the same numbers of CNOT gates. We illustrate this observation with an example in Figure 1. Assume that the circuit to be executed consists of pairwise 2qubit operations, one between qubit 1 and 2, one between qubit 0 and 1, and one between qubit 0 and 2. Also assume that our target device has linear connectivity, i.e.,q1is connected with q0andq2, butq0andq2are not directly connected. As a result, to perform the CNOT gate betweenq0andq2, we need to insert SWAP gates and there are two options: either insert a SWAP gate between ( q0, q1) or between ( q1,q2). If we only consider the SWAP gate count at the routing step, both routing options have the same SWAP gate cost as one SWAP. Therefore, the compiler may randomly select between these two designs. However, if we consider the subsequent optimizations that would re synthesize the consecutive twoqubit gates, these two routes actually have different costs in the number of CNOT gates. As shown in Figure 1, the second routing option only needs to insert one CNOT gate, while the ﬁrst one needs three CNOT gates. q0 q1 U2 q2U1 U3)q0 q1 U2 U3 q2U1)q0 q1 U2 U3 q2U1 (a) SWAP insertion resulting in three extra CNOT gates q0 q1 U2 q2U1 U3)Optimization q0 q1 U2 q2U1 U3)q0 V1 V2 V3 V4 q1 V5 V6 V7 V8 q2U1 U3 (b) SWAP insertion resulting in one extra CNOT gate Figure 1: Two different SWAP gate insertions with the same SWAP gate count but different CNOT gate counts. The second shortcoming of the stateoftheart compila tion schemes is that a ﬁxed template is used to decompose the SWAP gates, losing the logic information that the two qubits of the SWAP gate are interchangeable. As a result, ﬁxed SWAP gate decomposition may result in reduced optimization opportunities. In our approach, we propose an optimizationaware SWAP gate decomposition to overcome this problem. We implemented our NASSC in Qiskit v0.28 and com pared it with a stateoftheart scheme, SABRE [28]. Our experiments show that the routing overhead compiled with our routing algorithm is reduced by up to 69:30% (21:30% on average) in the number of CNOT gates and up to 43:50% (7:61% on average) in the circuit depth compared with SABRE. Our contributions are summarized as follows: We highlight that qubit routing should not be indepen dent upon the subsequent gate optimizations. Besides optimizationaware qubit routing, we propose optimizationaware SWAP gate decomposition to facil itate subsequent optimizations. We show that our proposed NASSC algorithm achievesmuch better results than the prior work. The remainder of the paper is organized as follows. Sec tion II introduces the background and the related work. Sec tion III presents our observations that motivate optimization aware qubit routing. Section IV discusses the overall compi lation process and details our proposed NASSC algorithm. Section V describes our compiler implementation and the benchmark set used in our evaluation. Section VI presents our experimental results on different hardware topologies. Finally, Section VII concludes the paper. II. B ACKGROUND AND RELATED WORK In this section, we brieﬂy introduce the basic concepts of quantum computing and the structure of the quantum compiler. We also discuss the related works. A. Quantum Computing Analogous to classical bits, qubits (quantum bits) are the basic unit in quantum computing. A qubit can not only stay in the classical states, j0iandj1i, it can also stay in the superposition of these two states. The superposition state is expressed asj i=aj0i+bj1i, whereaandbare complex numbers and jaj2+jbj2= 1. An nqubit quantum system can exist in a superposition of 2nstates, which can be represented by a 2nvector of complex values. Besides superposition, entanglement is another unique feature in quantum computing. Qubits can be entangled via twoqubit operations such as CNOT gates. When qubits are entangled, their measurement results are correlated. A quantum program is a sequence of quantum gates that operate on a number of qubits. An nqubit quantum gate can be represented by a 2n2nunitary matrix, U. The gate operation can be considered as multiplying the unitary matrixUwith the input state j 0i. The result is the output statej 1i=Uj 0i. Some quantum gates in a quantum program may commute, and the compiler optimizes the quantum gates based on commutation analysis. The target quantum hardware may only support a small set of basis gates. For example, the basis gates in the IBM Q system are id,rz,sx,x, andcx[46]. A quantum gate with a higher level abstraction such as a Toffoli gate needs to decompose to the basis gates. B. Quantum Compiler Quantum compiler plays a critical role in practical quan tum computation. A typical compilation pass includes four steps. The ﬁrst step is decomposing the quantum gates to the basis gates supported by the quantum hardware. Different quantum hardware might support a different set of basis gates. The second step selects logicaltophysical qubit map ping and inserts SWAP gates to route the qubits. Qubit map ping and routing, also known as the qubit allocation problem, has been proven to be NPhard [10]. There has been exten sive research using heuristic algorithms or converting the 2problem to other wellstudied problems tackled with clas sical solvers. The third step performs optimizations to the quantum circuit. We will discuss the common optimizations in Section IIC. The last step schedules the quantum gates to achieve the minimal program runtime and/or highest ﬁdelity. In Figure 2 we show the simpliﬁed stepwise compilation ﬂow of Qiskit. A different compiler may have different compilation ﬂows. For example, the tjketicompiler [45] has an architectureindependent optimization phase followed by an architecturedependent phase that prepares the circuit for the target hardware. The architecturedependent phase includes gate decomposition, qubit mapping and routing, and gate optimizations. Although the compilation ﬂows may differ, the qubit routing and the gate optimizations are inde pendent steps in these compilers. Such independent design may lose optimization opportunities and lead to suboptimal routing decisions. Based on such ﬁndings, we introduce our optimizationaware qubit routing scheme NASSC, which overcomes this potential design limitation. Figure 2: The compilation ﬂow of IBM Qiskit. C. Related work First, we review qubit mapping and routing algorithms. The evaluation metric in prior works can be classiﬁed into three categories: circuit size (i.e., number of extra gates inserted at the routing step; which is often equivalent to the number of extra SWAP gates), circuit depth (i.e., the number of layers in the ﬁnal circuit), and the circuit error rate. Zulehner et al. [55] proposed an approach to partition quantum circuits into layers. Each layer contains gates that can be executed in parallel. Then for each layer, SWAP gates are inserted to ﬁnd a hardware compliant mapping. The A* algorithm is adopted to search for the path with the lowestcost, where the cost is the number of elementary operations. While their cost function considers the basis gates, their SWAP gates always follow the same decomposition and have the identical cost of seven elementary gates (three CNOTs and four Hadamard operations for monodirectional links). Li et al. [28] proposed a SWAPbased bidirectional heuristic search method named SABRE. SABRE ﬁrst computes a distance matrix of the target hardware. The best route is selected using a heuristic cost function based on the distance matrix. The lookahead cost function considers not only the front layer but also the subsequent layers. They also leverage intrinsic reversibility to enable global optimization. Inspired by SABRE, HA is a hardwareaware heuristic proposed by Niu et al. [40]. HA improved the ﬁdelity and reduced the number of additional gates by introducing a new distance matrix based on hardware connectivity and calibration data. The cost function estimates the success rate of the inserted gates. Itoko et al. [14] takes advantage of the commutation rules to ﬁnd the gates that commute in the original circuit. Such an approach can explore more routing candidates than the ﬁxed layer approach. However, the routing algorithm is not optimizationaware as the CNOT gate count for the SWAP gate decomposition always stays the same. Besides these, there are prior works that use the number of SWAP gates as the cost function and propose different approaches to ﬁnd the best route [9], [48], [53], [54]. There are also works that incorporate the error rates in their cost functions [7], [37], [41]. Some other prior works also take the circuit depth into consideration [51], [52]. In summary, none of these prior works on qubit routing is optimization aware. Next, we review various quantum circuit optimizations. Peephole optimization [31], [32] is widely used in quantum compilers. The peephole optimization identiﬁes subcircuits in speciﬁc patterns and substitutes them with equivalent cir cuits that have lower cost. The Qiskit transpiler [5] contains theOptimize1qGates optimization pass, which identi ﬁes the pattern of consecutive singlequbit gates and substi tutes them altogether with a singlequbit gate. The transpiler also contains optimization passes Collect2qBlocks and UnitarySynthesis to identify the twoqubit blocks and resynthesize them. The tjketi[45] compiler identiﬁes long sequences of single/twoqubit gates and resynthesizes them with Euler and KAK decomposition [17]. Similar optimizations can also be found in the Cirq [1] compiler. These optimizations can be considered as in the category of peephole optimization. Commutation analysis has been uti lized for gate optimization [34] and qubit mapping [4], [14]. The compiler can identify more templates by reordering the quantum gates. In Qiskit, the CommutationAnalysis pass ﬁnds the commutation relations between the quantum gates, and groups the gates in a set of gates that commute. After commutation analysis, the gates are optimized with gate cancellation [30]. Qiskit also has optimization passes 3including noise adaption [37], crosstalk mitigation [38], and scheduling optimization [43]. III. M OTIVATION In this section, we motivate the need for optimization aware qubit routing. We look closely at the Qiskit compiler framework and study the optimization passes that may change the cost of the SWAP gates. Gate optimizations can remarkably reduce the count of the basis gates inserted at the qubit routing step. As we studied the quantum circuit generated by Qiskit, we found that a large proportion of the inserted SWAP gates are actually modiﬁed by the subsequent optimizations, the resynthesis of twoqubit blocks and gate cancellation, in particular. For example, when a 10qubit Grover benchmark is mapped to a backend with 442Dgrid connectivity, 20:7%of the SWAP gates are optimized by the twoqubit block resynthesis while 40:3%of them are optimized by gate cancellation. Such observation indicates that even the compiler selects the path with the fewest number of SWAP insertions at the routing step, the ﬁnal cost of the selected route may not be optimal. The ﬁrst optimization that optimizes the SWAP gate is the resynthesis of twoqubit blocks. A twoqubit block [5] is a sequence of uninterrupted twoqubit gates. Since the two qubit block operator U2SU(4), it can be generated with a twoqubit gate with three CNOTs [47]. The compiler cal culates the matrix representation of the twoqubit block and uses the KAK decomposition [17] to generate a subcircuit with up to three CNOT gates. Figure 3 shows an example of this optimization. In this example, after resynthesis, the cost of implementing the SWAP gate is two CNOT gates and several singlequbit gates. In some extreme cases, when the gate sequence already contains at least three CNOTs before the SWAP insertion, the SWAP gate can be inserted for free. In other words, some SWAP gates can be inserted at no cost! twoqubit block V1 V2 V3 V4) U1 U2 U3 U4 U5 U6 U7 U8 Figure 3: The resynthesis of twoqubit block and the universal twoqubit gate decomposition reduce the cost of the SWAP gate. The second optimization that may affect the cost of SWAP gates is gate cancellation. The compiler will search for thepotential cancellable quantum gates based on commutation analysis. In Qiskit, the CommutativeCancellation pass cancels the selfinverse gates through commutation relations. The following selfinverse gates are considered: H,X,Y,Z,CX,CY, andCZ. We show an example in Figure 4 to illustrate this optimization. In the ﬁrst circuit, the ﬁrst two CNOT gates commute since they share the same target qubit [14]. If we switch the order of the ﬁrst two CNOT gates, an inserted CNOT gate can be canceled with the second CNOT gate in the original circuit. Therefore, the number of CNOT gates required by the SWAP is no longer three. In this example, the SWAP gate will only introduce one extra CNOT gate. In other words, the cost of a SWAP is not a ﬁxed value and is dependent on the subsequent optimizations. commutation )SWAP decomposition ) gate cancellation ) Figure 4: SWAP gate optimization with gate commutation and cancellation. Both of the optimizations can reduce the CNOT gate count required by SWAP gates. This ﬁnding leads to the design of our optimizationaware routing algorithm. As a matter of fact, the abovementioned optimizations may not identify all the potential optimization opportunities for SWAP gates. In Section IVE, we will discuss the SWAPrelated gate optimization and our new optimizationaware SWAP gate decomposition. IV. NASSC In this section, we describe our proposed NASSC ap proach. In Section IVA, we show an overview of the NASSC algorithm and its integration with Qiskit. In Sec tion IVB, we present our search heuristic. In Section IVC we discuss our cost function. In Section IVD and Sec tion IVE we discuss the two optimizations that can impact the cost of SWAP gates. We discuss the integration of multiple optimizations in Section IVF. A. Overview An overview of NASSC and its integration with Qiskit is shown in Figure 5. Our routing algorithm considers the twoqubit block resynthesis and commutationbased gate 4Figure 5: The compilation ﬂow of NASSC integrated with Qiskit cancellation at the routing step. In order to collect the opti mization information and shorten the transpilation time, we move the corresponding optimizations before qubit mapping and routing. We use the same qubit mapping algorithm as SABRE, which includes the random front layer initialization and the reverse traversal initial mapping update [28]. After the initial mapping, for each twoqubit gate that does not ﬁt on the device, the NASSC routing algorithm ﬁnds the SWAP candidates that might move the logical qubits closer. For each SWAP candidate, the algorithm identiﬁes the potential optimizations and calculates CNOT gate count reduction Ck with each optimization. Some of the optimizations might require a special SWAP decomposition. The compiler will ﬂag the SWAP candidates with the special decomposition requirement. Then the algorithm calculates the cost function for each SWAP candidate and inserts the SWAP gate with the smallest cost. The algorithm will iteratively insert SWAP gates until all the twoqubit gates ﬁt the topology of the device. After inserting all the SWAP gates, the last step of the NASSC algorithm is performing optimizationaware SWAP gate decomposition based on the ﬂags. After the routing step, the compiler will perform the rest of the circuit optimizations and schedule the gates. B. OptimizationAware Qubit Routing In our routing algorithm, we ﬁrst reformulate the logi cal quantum circuit representation to the DirectedAcyclic Graph (DAG) format. The DAG is constructed such that a DAG node represents a quantum gate, and the directed edge (i,j) between node i and node j represents the dependency from node i to node j. In other words, gate i should be executed before gate j.Then, the quantum gates in the circuit are divided into three groups: the resolved gates, the executable gates, and the tobeexecutable gates. The resolved gates are the ones that have already been mapped by the algorithm, including the inserted SWAP gates. The resolved gates form the resolved layer. The executable gates are the gates that do not have unexecuted predecessors in the DAG. The executable form the front layer. The tobeexecutable gates are the rest of the gates. Some of the closest successors of the gates in the front layer form the extended layer. The extended layer is set for lookahead analysis. The abstraction of different layers helps to deﬁne the search heuristic. And an illustration of these layers is shown in Figure 6. Next, we perform layered search to determine qubit routing. In our algorithm, we use the random front layer initialization and the reverse traversal initial mapping update, the same as SABRE [28]. For the gates in the front layer, the algorithm will remove the gates that are directly executable with the current mapping and add them to the resolved layer. The remaining gates in the front layer, if there are any, would require SWAP gates insertion. In the example shown in Figure 6, assume that the circuit is to be executed on a hardware backend with linearnearest neighbor connectivity. Then, the CNOT gate in the front layer in Figure 6a is not directly executable since physical qubits q0andq2are not connected. In this case, the compiler needs to ﬁnd SWAP candidates. For each logical qubit in the front layer, the com piler ﬁnds its current physical qubit and its adjacent physical qubits to construct potential routing candidates. Every SWAP corresponding to one of the physical couplings is considered a candidate SWAP. For the example in Figure 6, q0is the physical qubit that correlates to the logical qubit in the front layer, andq1is its adjacent qubit. Hence the SWAP between q0andq1is a candidate SWAP as shown in Figure 6c. Similarly we can have another candidate SWAP between q1andq2as shown in Figure 6d. All of the candidate SWAPs form a SWAP candidate set T. The compiler will calculate the cost of each SWAP candidate in Tbased on an optimizationaware cost function H. For a SWAP candidate, the compiler will analyze its predecessor and successors to estimate the cost. In Figure 6c, the SWAP gate between q0 andq1can be resynthesized with the controlledRx gate. Therefore, it will introduce two CNOT gates. The SWAP gate between q1andq2in Figure 6d will be optimized with gate cancellation and introduce one CNOT gate. The reason is that the CNOT between q1andq2commutes with the controlled Rxgate between q0andq1. As a result, the CNOT can cancel one of the CNOTs decomposed from the SWAP gate. As shown in Figure 6e, the SWAP candidate with the minimum cost is selected. For a gate that requires multiple hops, the compiler iteratively inserts SWAP gates, one hop a time until the gate becomes implementable on the target device. Then, the above process repeats until all of the gates in the front layer are resolved. Once the front layer 5(a) Connec tivity graphResolved Front Extended q0 q1 Rx q2 Rx q3 (b) Original circuitResolved Front Extended q0 q1 Rx q2 Rx q3 (c) SWAP insertion option 1Resolved Front Extended q0 q1 Rx Rx q2 q3 (d) SWAP insertion option 2Resolved Front Extended q0 q1 Rx Rx q2 q3 (e) Circuit after SWAP insertion Figure 6: The layered search heuristic. is empty, the compiler will select the executable gates that form a new front layer, as shown in Figure 6e. The compiler ﬁnishes routing when the front layer and the extended layer are both empty. During SWAP gate insertion, the compiler will maintain the information such as the total number of SWAPs and collect the information relating to the SWAP candidate set T. C. OptimizationAware Cost Function The cost function is crucial for qubit routing as it is used to select the optimal route from the candidate routing sets. The basic cost function in NASSC is deﬁned as: Hbasic =X gate2F3D[g:i][g:j]"
327,Capsules with Inverted Dot-Product Attention Routing.txt,"We introduce a new routing algorithm for capsule networks, in which a child
capsule is routed to a parent based only on agreement between the parent's
state and the child's vote. The new mechanism 1) designs routing via inverted
dot-product attention; 2) imposes Layer Normalization as normalization; and 3)
replaces sequential iterative routing with concurrent iterative routing. When
compared to previously proposed routing algorithms, our method improves
performance on benchmark datasets such as CIFAR-10 and CIFAR-100, and it
performs at-par with a powerful CNN (ResNet-18) with 4x fewer parameters. On a
different task of recognizing digits from overlayed digit images, the proposed
capsule model performs favorably against CNNs given the same number of layers
and neurons per layer. We believe that our work raises the possibility of
applying capsule networks to complex real-world tasks. Our code is publicly
available at: https://github.com/apple/ml-capsules-inverted-attention-routing
An alternative implementation is available at:
https://github.com/yaohungt/Capsules-Inverted-Attention-Routing/blob/master/README.md","Capsule Networks (CapsNets) represent visual features using groups of neurons. Each group (called a “capsule”) encodes a feature and represents one visual entity. Grouping all the information about one entity into one computational unit makes it easy to incorporate priors such as “a part can belong to only one whole” by routing the entire part capsule to its parent whole capsule. Routing is mutually exclusive among parents, which ensures that one part cannot belong to multiple parents. Therefore, capsule routing has the potential to produce an interpretable hierarchical parsing of a visual scene. Such a structure is hard to impose in a typical convolutional neural network (CNN). This hierarchical relationship modeling has spurred a lot of interest in designing capsules and their routing algorithms (Sabour et al., 2017; Hinton et al., 2018; Wang & Liu, 2018; Zhang et al., 2018; Li et al., 2018; Rajasegaran et al., 2019; Kosiorek et al., 2019). In order to do routing, each lowerlevel capsule votes for the state of each higherlevel capsule. The higherlevel (parent) capsule aggregates the votes, updates its state, and uses the updated state to explain each lowerlevel capsule. The ones that are wellexplained end up routing more towards that parent. This process is repeated, with the vote aggregation step taking into account the extent to which a part is routed to that parent. Therefore, the states of the hidden units and the routing probabilities are inferred in an iterative way, analogous to the Mstep and Estep, respectively, of an ExpectationMaximization (EM) algorithm. Dynamic Routing (Sabour et al., 2017) and EM routing (Hinton et al., 2018) can both be seen as variants of this scheme that share the basic iterative structure but differ in terms of details, such as their capsule design, how the votes are aggregated, and whether a nonlinearity is used. We introduce a novel routing algorithm, which we called Inverted DotProduct Attention Routing . In our method, the routing procedure resembles an inverted attention mechanism, where dot products are used to measure agreement. Speciﬁcally, the higherlevel (parent) units compete for the attention of the lowerlevel (child) units, instead of the other way around, which is commonly used in attention 1arXiv:2002.04764v2  [cs.LG]  26 Feb 2020Published as a conference paper at ICLR 2020 Convolutional FeaturesConvolutional  BackbonePrimary CapsulesConvolution + LayerNormRoutingRoutingConvolutional CapsulesFullyConnected CapsulesClass CapsulesClassifierLogitsRoutingRouting Figure 1: Illustration of a Capsule network with a backbone block, 3convolutional capsule layers, 2fully connected capsule layers, and a classiﬁer. The ﬁrst convolutional capsule layer is called the primary capsule layer. The last fullyconnected capsule layer is called the class capsule layer. models. Hence, the routing probability directly depends on the agreement between the parent’s pose (from the previous iteration step) and the child’s vote for the parent’s pose (in the current iteration step). We also propose two modiﬁcations for our routing procedure – (1) using Layer Normalization (Ba et al., 2016) as normalization, and (2) doing inference of the latent capsule states and routing probabilities jointly across multiple capsule layers (instead of doing it layerwise). These modiﬁcations help scale up the model to more challenging datasets. Our model achieves comparable performance as the stateoftheart convolutional neural networks (CNNs), but with much fewer parameters, on CIFAR10 (95.14% test accuracy) and CIFAR100 (78.02% test accuracy). We also introduce a challenging task to recognize single and multiple over lapping objects simultaneously. To be more precise, we construct the DiverseMultiMNIST dataset that contains both singledigit and overlappingdigits images. With the same number of layers and the same number of neurons per layer, the proposed CapsNet has better convergence than a baseline CNN. Overall, we argue that with the proposed routing mechanism, it is no longer impractical to apply CapsNets on realworld tasks. We will release the source code to reproduce the experiments. 2 C APSULE NETWORK ARCHITECTURE An example of our proposed architecture is shown in Figure 1. The backbone is a standard feed forward convolutional neural network. The features extracted from this network are fed through another convolutional layer. At each spatial location, groups of 16channels are made to create capsules (we assume a 16dimensional pose in a capsule). LayerNorm is then applied across the 16 channels to obtain the primary capsules. This is followed by two convolutional capsule layers, and then by two fullyconnected capsule layers. In the last capsule layer, each capsule corresponds to a class. These capsules are then used to compute logits that feed into a softmax to computed the classiﬁcation probabilities. Inference in this network requires a feedforward pass up to the primary capsules. After this, our proposed routing mechanism (discussed in the next section) takes over. In prior work, each capsule has a pose and some way of representing an activation probability. In Dynamic Routing CapsNets (Sabour et al., 2017), the pose is represented by a vector and the activa tion probability is implicitly represented by the norm of the pose. In EM Routing CapsNets (Hinton et al., 2018), the pose is represented by a matrix and the activation probability is determined by the EM algorithm. In our work, we consider a matrixstructured pose in a capsule. We denote the capsules in layer LasPLand the ith capsule in layer LaspL i. The pose pL i2RdLin a vector form and will be reshaped to RpdLpdLwhen representing it as a matrix, where dLis the number of hidden units grouped together to make capsules in layer L. The activation probability is not ex plicitly represented. By doing this, we are essentially asking the network to represent the absence of a capsule by some special value of its pose. 3 I NVERTED DOTPRODUCT ATTENTION ROUTING The proposed routing process consists of two steps. The ﬁrst step computes the agreement between lowerlevel capsules and higherlevel capsules. The second step updates the pose of the higherlevel capsules. Step 1: Computing Agreement: To determine how capsule jin layer L+ 1(pL+1 j) agrees with capsule iin layer L(pL i), we ﬁrst transform the pose pL ito the votevL ijfor the pose pL+1 j. This 2Published as a conference paper at ICLR 2020 Higherlevel CapsulesLowerlevel Capsulespose……Agreement by DotProduct Attention multiplication∑LayerNorm(⋅)routing coefficients Pose Update Routing Coefficients as Normalized Agreementagreementweightmatrix multiplication  reshape⋅dot product  ⊤Softmax(⋅)………… Figure 2: Illustration of the Inverted DotProduct Attention Routing with the pose admitting matrix structure. Procedure 1 Inverted Dotproduct Attention Routing algorithm returns updated poses of the cap sules in layer L+ 1given poses in layer LandL+ 1andweights between layer LandL+ 1. 1:procedure INVERTED DOTPRODUCT ATTENTION ROUTING (PL,PL+1,WL) 2: for all capsule iin layer Land capsule jin layer (L+ 1) :vL ij WL ijpL i .vote 3: for all capsule iin layer Land capsule jin layer (L+ 1) :aL ij pL+1 j>vL ij.agreement 4: for all capsule iin layer L:rL ij exp(aL ij)=P j0exp(aL ij0) .routing coefﬁcient 5: for all capsule jin layer ( L+ 1):pL+1 j P irL ijvL ij .pose update 6: for all capsule jin layer ( L+ 1):pL+1 j LayerNorm (pL+1 j) .normalization 7: return PL+1 transformation is done using a learned transformation matrix WL ij: vL ij=WL ijpL i; (1) where the matrix WL ij2RdL+1dLif the pose has a vector structure and WL ij2Rp dL+1pdL (requires dL+1=dL) if the pose has a matrix structure. Next, the agreement (aL ij) is computed by the dotproduct similarity between a pose pL+1 jand a vote vL ij: aL ij=pL+1 j>vL ij: (2) The pose pL+1 jis obtained from the previous iteration of this procedure, and will be set to 0initially. Step 2: Computing Poses: The agreement scores aL ijare passed through a softmax function to determine the routing probabilities rL ij: rL ij=exp(aL ij)P j0exp(aL ij0); (3) where rL ijis an inverted attention score representing how higherlevel capsules compete for attention of lowerlevel capsules. Using the routing probabilities, we update the pose pL+1 j for capsule jin layer L+ 1from all capsules in layer L: pL+1 j= LayerNorm X irL ijvL ij! : (4) We adopt Layer Normalization (Ba et al., 2016) as the normalization , which we empirically ﬁnd it to be able to improve the convergence for routing. The routing algorithm is summarized in Proce dure 1 and Figure 2. 4 I NFERENCE AND LEARNING To explain how inference and learning are performed, we use Figure 1 as an example. Note that the choice of the backbone, the number of capsules layers, the number of capsules per layer, the design of the classiﬁer may vary for different sets of experiments. We leave the discussions of conﬁgurations in Sections 5 and 6, and in the Appendix. 3Published as a conference paper at ICLR 2020 Procedure 2 Inference. Inference returns class logits given input images andparameters for the model. Capsule layer 1denotes the primary capsules layer and layer Ndenotes the class capsules layer. 1:procedure INFERENCE (I;;W1:N"
474,Cost and Routing of Continuous Variable Quantum Networks.txt,"We study continuous-variable graph states with regular and complex network
shapes and we report for their cost as a global measure of squeezing and number
of squeezed modes that are necessary to build the network. We provide an
analytical formula to compute the experimental resources required to implement
the graph states and we use it to show that the scaling of the squeezing cost
with the size of the network strictly depends on its topology. We show that
homodyne measurements along parallel paths between two nodes allow to increase
the final entanglement in these nodes and we use this effect to boost the
efficiency of an entanglement routing protocol. The devised routing protocol is
particularly efficient in running-time for complex sparse networks.","Networks science has been used to model the structures and properties of many biological, physical and technolog ical systems, including internet and the world wide web. Photonics quantum networks are essential resources for quantum information processing and notably for quantum internet applications, where quantum states of light will allow for the efficient distribution and manipulation of information [ 1–4]. In order to develop large scale quantum communications and build a quantum internet it is com pulsory to grasp the potentialities of quantum networks and exploit all their exceptional features. We can expect that complex networks theory can be used, like in the case of classical networks, to study and drive efficient quantum complex networks design for quantum technologies [5]. In this work we study continuous variable quantum net works in the form of CV graph states with regular and com plex topologies. CV quantum information describes quan tum states living in infinite dimensional Hilbert spaces, protocols mainly rely on coherent (homodyne) detection which, differently from photon counting detectors, can be highly efficient at room temperature. Moreover, CV quan tum networks can be generated deterministically with a large number of nodes [ 6–10], they can be easily re configured [ 11–14] and they have been also exploited in quantum advantage demonstrations [14]. It is known that quantum feature of CV states can be lost because of losses and noise during transmission. Nevertheless substantial progress has been done in CV quantum states distribution [ 15] and CV quantum re peaters design [ 16]. Moreover CV quantum networks, that are easily reconfigurable and with a large number of components [ 7,8,10,14], can be easily exploited as local area quantum networks. In this work we discuss Gaussian graph states using ∗fcentrone@icfo.net †frederic.grosshans@lip6.fr ‡valentina.parigi@lkb.upmc.frmathematical tools from network science in order to esti mate how the cost of their experimental implementation is affected by the topology and the size of the network. In particular, we derive an equation providing the squeezing values required to experimentally build a graph state as a function of its graph spectrum. We then adopt a resource theory of squeezing to estimate the cost of expanding the network. Thereafter, we propose a CV architecture for the quan tum internet based on the Gaussian network previously described. We simulate quantum communication proto cols through the network by letting the spatially separated agents present at each node perform a homodyne measure ment on their optical mode and look for the optimal mea surement strategy to maximize the logarithmic negativity — an entanglement measure [ 17–19] — of the entangled pair shared by the two users who want to communicate, Alice and Bob. We prove that when multiple entangled paths connect Alice to Bob the optimal measurement strategy allows to increase the logarithmic negativity in the final pair. This parallel enhancement of entangle ment can be used to increase the quality of quantum communications in some selected network topologies. Lastly, we employ our previous findings to implement a heuristic routing protocol for distributing and boosting the entanglement between two arbitrary agents. The algorithm we provide, on the one hand, is much more efficient than directly checking all possible combinations of quadrature measurements and, on the other hand, it always provides higher logarithmic negativity than the classical scheme, which is directly employing the shortest path between Alice and Bob and neglect the parallel channels. II. RESULTS A. Cost of quantum networks Consider a graph with Nvertices. It is fully defined by its adjacency matrix A∈RN×N. A way to prepare thearXiv:2108.08176v3  [quantph]  21 Jun 20232 associated graph state is to prepare a mode in the vacuum state for each vertex iand, whenever two vertices i, jare connected by an edge — when Aij̸= 0 —, we apply an entangling get such as a CZgate of strength Aij. We then end up with a Gaussian graph state characterized the 2 N×2Ncovariance matrix σ: σ=1 2 1 A A1+A2 , (1) where we have normalized the vacuum state variance to 1/2. These Gaussian bosonic states are of particular sig nificance in the theory of continuous variable quantum information. They are in fact resources for measurement based quantum computing [ 20,21], quantum simulations [11], multiparty quantum communication [ 7,22], and quantum metrology [ 23,24]. Furthermore, their graphical structure simplifies their study through graphical calculus , a formalism introduced by Menicucci, Flammia and van Loock in Ref. [ 25]. Some elements of graphical calculus are summed up in Appendix C. The correlations between the quadrature measurements of Gaussian states are fully described by their covariance matrix σ. Therefore, as usual in the literature, we will not further mention the first moments, which only describe a deterministic shift of the measurements which can easily be compensated when known and are therefore irrelevant. Through the Bloch–Messiah decomposition (see Sec. III A), one can see the eigenvalues λ± iof the covariance matrix σrepresent the squeezed and antisqueezed vari ances of the uncoupled oscillators, e.g. the uncertainty of measuring the real and imaginary part of the electromag netic field. Together, they form the squeezing spectrum . The first result of this paper is the following analytical relation between the squeezing spectrum of the Gaussian state and the adjacency spectrum of the graph: λ± i=1 2 1 +D2 i/2±q D2 i+D4 i/4 , (2) where Diare the eigenvalues of the adjacency matrix A. Equation (2) shows the interplay between the physical resources necessary to experimentally implement a CV graph state and the spectrum of the underlying graph. This implies that we can use spectral graph theory to char acterize analytically the physical requirements of building Gaussian networks and thus predict which one will be eas ier to realize. A first crucial consequence is that different graph states whose underlying graphs are cospectral, e.g. their adjacency matrices have the same eigenvalues, can be transformed into each other applying passive linear optics1. The intrinsic connection between the squeezing 1In general, any CV graph can be reshaped in any other graph via a symplectic transformation; in this case it is an orthogonal transformation, and its physical realization involves only linear optics without any supplementary squeezing.of a Gaussian network and its topology was already put in evidence in the limit of large squeezing by Gu et al. [ 21], who showed a relation between the squeezing required to produce a CV graph state and the singular value decom position of the associated adjacency matrix. Our result is a generalization of theorems 2 and 3 of Ref. [ 21], exact and valid for finite squeezing, i.e. in a regime accessible with current technology. Another crucial consequence of equation (2) is that for CV graph states the number of independent squeezed modes in their Bloch–Messiah decomposition corresponds to the rank rk(A) of the associated adjacency matrix A. This immediately translate ito the number of squeezers needed to contruct said state Squeezing is the essential resource for building Gaussian entangled states. A natural question is thus: what is the squeezing cost of producing a quantum state? A general resource theory for Gaussian states is provided by Lami et al. in [ 26], with the specific case of squeezing described in [27], where Idel, Lercher and Wolf find an operational squeezing measure, the squeezing cost . Its expression for any pure2Gaussian state of covariance matrix σis G: R2N×2N→ R, G(σ) =NX i=110 log10"
229,Secured Approach Towards Reactive Routing Protocols Using Triple Factor in Mobile Adhoc Networks.txt,"Routing protocols are used to transmit the packets from the source to the
destination node in mobile ad hoc networks. The intruders seek chance to pierce
into the network and becomes a cause of malfunctioning in the network. These
protocols are always prone to attacks. During the phases of routing in
different types of protocols, each of the attack finds a way to degrade the
performance of the routing protocols. The reactive routing protocols DSR and
AODV have lot of similar features and so are considered in this study. In order
to transmit the packets safely, a secured approach using triple factor has been
proposed. This triple factor computes the trust by using the direct information
then verifies the reputation by collecting the information from the
neighbouring nodes called distributed factor and uses cryptographic algorithm
to ensure security. And to ensure that there are routes available to perform
the routing process, the reasons for such attacks are studied so as to
re-integrate back the nodes in to the network, once it has repented for being
malicious before. The availability of routes increases the throughput","A set of mobile nodes that perform basic networking functions in an infrastructure less  environment is said be a mobile ad hoc network  (MANET) , as demonstrated in f igure  1. Nodes that  fall within the communication range communicate with each other and which don’t come in the    Mohammad Riyaz Belgaum, Shahrulniza Musa, Mazliham  MohdSu’ud, Muhammad Alam,  Safeeullah  Soomro and Zainab  Alansari , ""Secured approach towards Reactive Routing Protocols using Triple factor in Mobile Ad hoc Networks ”, Annals of  Emerging Technologies in Computing (AETiC) , Print ISSN: 2516 0281, Online ISSN: 2516 029X, pp. 32 40, Vol. 3 , No. 2 , 1st April  2019, Published by  International Association of Educators and Researchers (IAER) , DOI: 10.33166/AETiC.2019.02.004,  Available: http://aetic.theiaer.org/archive/v3/v3n2/p4.html . AETiC  2019, Vol. 3 No. 2 33  range follow the concept of multi hop for commu nication. In the network each node plays a dual  role as a host by the forwarding and as a router in routing packets to the destination.     Figure 1. Mobile Ad H oc Networks (MANET)   Maintaining security is an important function of any  of the routing protocol in each phase of  the networking function [1]. Because of the non static topological behavio ur of the network and due  to being the network open which allows the network to grow and shrink due to addition and  deletion of the nodes anytime gives chance for the intruder nodes to disturb the normal routing  process. And if there does not exist a common regulatory authority for authenticating and  guaranteeing the nodes then a reliable transmission is not possible .  In the current era of Internet of things (IoT), the wireless sensor networks functionality is  similar to MANETS as both are dynamic and self organized. From the figure 2, we can see that the  IoT devices form into clusters and transmit the information through the network.       Figure 2. MANET IoT network [ 2].  1.1. Security Related Goals and Challenges   Security services are needed to make sure that the data is transferred over the network with  reliability and also the keeping the resources of the system protected. To attain the objectives, the  categorizations of security services are:  availability, confidentiality, authentication, integrity and  non repudiation [3 , 4].   www. aetic.theiaer .org AETiC  2019, Vol. 3 No. 2 34  • Availability : Though the system is suffering from various problems like with bandwidth,  connectivity but the a vailability service ensures that still the resources are available in a timely  manner. The harmful effects of availability of a network are resource depletion attacks and packets  dropping ratio.   • Confidentiality : The information prevailing in the network is not to be shared among all  unauthorized nodes and this is achieved by Confidentiality. In order to achieve Confidentiality  many encryption techniques can be used to make only the authorized nodes can share the  transmission of information and the private  and public keys.    • Authenticity :  To prove a node as a legitimate user the network service used is  Authenticity. The absence of this service can make any node in the network impersonate any node, and then having a total control capture and control over t he complete network.   • Integrity :  The data which is been transmitted in the network can be modified either  wantedly or sometimes unwantedly. The Integrity network service ensures that the information  which is been transmitted is not modified.   • Non repud iation :  This service guarantees that the message transmission has been done  between the two parties and it cannot be denied. Also using this service it helps in detecting and  isolating of compromised nodes in the network.   Communicating through the network  in safe and secure way has been a challenging task  because of   • Not being a stable infrastructure.   • The links in the network are prone to break and not secure.   • Scarcity or overload on the system resources   • The network topology being dynamic   In this study the plan of the research is to study the various reactive routing protocols in  MANETS and analyze the threats and types of attacks in the routing protocols . The reasons for  security threats are studied for giving a solution to meet the challenges of security in the network  and carry out regular network operations in a secured way . The proposed approach will be used to  enhance the existing reactive routing protocols by considering triple factor to improve security in  while the network functions are carried out . Specifically the following issues will be addressed.   1. What are the different security threats for the reactive routing protocols?   2.  What are the reasons for threats?   3. Strategies to make the network strong and secured   The researcher concentrates on the reacti ve routing protocols. The threats on these routing  protocols are studied;  as a result of security such malicious node will be deleted from taking part in  forwarding the packet. Now the reasons for these types of threats are studied and the problems in  this strategy are considered for research . The proposed architecture in  MANETS will improve  security by embedding  triple factor in the reactive routing protocols while forwarding the packets  from source to destination. This could serve as reference for other researchers to enhance other  category of routing protocols based on their behavior to improve security in MANE TS.   The study of working strategy of each of the reactive routing protocol along with the attacks  on them is studied. D ifferent protocols adopt different strategies when the y are prone to attacks on  the protocols. A study of reasons for the attacks and threats will be conducted which makes to   www. aetic.theiaer .org AETiC  2019, Vol. 3 No. 2 35  adopt the triple factor to enhance security in the discovery and route maintenance during the  process of sending the packets to the destination.   2. Li terature Review   The following is the summary of various routing protocols based on their behavior designed for  MANETS  [59]. These protocols can be categorized as follows .    Figure 3.  Routing Protocols     The researcher carries the research with the study of  reactive routing protocols and the attacks  on them . The working functionalities of each of these reactive routing protocols  [10] are  summarized as follows.   2.1. Reactive Routing Protocols   2.1.1. Dynamic Source Routing Protocol   The DSR  protocol communicates by following two phases namely route discovery and  maintenance [1 1]. The routing information is stored while the packets are forwarded. When a  packet arrives at a node, it first checks its cache to ensure that the route for the desti nation node is  available  as it maintains the information of the recently used routes . When there are multiple routes  to the destination then a shortest route with less hop count is selected.  Because of the dynamic  changes in the topology, there is a chance of routes being broken in the route maintenance phase  still it ensures that the packet is safely transmitted to the target.  There are two types of packets  floating between source and destin ation as route request ( RREQ) and route reply ( RREP).  2.1.2 . Ad Hoc on Demand Distance Vector Protocol   The functionality of AODV protocol is explained in  [12]. The authors here proposed an new  protocol using AODV as the base protocol where a fitness functi on is used. The traditional AODV  protocol has a single path from the source to the destination node while in the proposed protocol,  the authors used multipath. It is stated that the features of both DSR and DSDV are combined. The author explains the working of AODV protocol  with two phases in them as route discovery and  route maintenance.  A method to identify the malicious node was explained in order to avoid   www. aetic.theiaer .org AETiC  2019, Vol. 3 No. 2 36  forwarding of the information to the malicious node in the routing table. The solution given did not  impose any overhead on the nodes in the network.   2.1.3 . Temporally Ordered Routing Algorithm   The Temporally ordered Routing Algorithm considers the link reversal concept . This protocol  doesn’t allow the loops to occur  [13]. Th ere are three phases in this protocol as : (a) Route creation  happens in first phase , (b) main tenance of route happens in second phase and (c) the elimination of  invalid routes happen in third phase.  All these phases go in a serial so as to safely transmit the  packets from sour ce to destination.   2.1.4 . Associativity Based Routing   The Associativity Based Routing  (ABR)  protocol is free from loops and has no similar packets.  Also no deadlock occurs in this protocol  [14]. It focuses on route longevity. As there are very few  broken communication links and less need for reconstruction of the routes the overhead involved is  less. An improved version of ABR was to optimize the bandwidth and demand to reduce the  overhead based on the position information was proposed. It was concluded that the path setup time was long for the routes which gave a scope for the future research to improve the ABR  Protocol.   2.1.5 . Signal Stability based Adaptive Routing Protocol   The working of SSR routing protocol states that the large routing tables are not required for  routing [1 5]. The network will not be congested with the control messages . From all the attacks, this  protocol is prone to a threat called denial of service attack. The Signal S tability Table maintains the  neighboring node’s signal’s strength. The authors simulated the protocol in OmNet and a metric  known as CPU usage was considered to measure the performance. It proved that when there are  malicious nodes the usage of CPU was mor e than in the absence of malicious nodes .  2.2. Reasons for Threats and Attacks   Reasons for threats have been summarized as shown in the following figure 4.    Figure 4.  Reasons for threats and attacks   For security the authors in [1 6] have considered the characteristics of the routing protocols in MANETS and  conducted a survey on the different types of certificate of authentication to provide better security services.  These have been categorized into centralized and distributed certifi cate authorities. Based on the factors and  specifications the appropriate certificate authority can be selected.    www. aetic.theiaer .org AETiC  2019, Vol. 3 No. 2 37  3. Methodology   "
56,Deep Tree Learning for Zero-shot Face Anti-Spoofing.txt,"Face anti-spoofing is designed to keep face recognition systems from
recognizing fake faces as the genuine users. While advanced face anti-spoofing
methods are developed, new types of spoof attacks are also being created and
becoming a threat to all existing systems. We define the detection of unknown
spoof attacks as Zero-Shot Face Anti-spoofing (ZSFA). Previous works of ZSFA
only study 1-2 types of spoof attacks, such as print/replay attacks, which
limits the insight of this problem. In this work, we expand the ZSFA problem to
a wide range of 13 types of spoof attacks, including print attack, replay
attack, 3D mask attacks, and so on. A novel Deep Tree Network (DTN) is proposed
to tackle the ZSFA. The tree is learned to partition the spoof samples into
semantic sub-groups in an unsupervised fashion. When a data sample arrives,
being know or unknown attacks, DTN routes it to the most similar spoof cluster,
and make the binary decision. In addition, to enable the study of ZSFA, we
introduce the first face anti-spoofing database that contains diverse types of
spoof attacks. Experiments show that our proposed method achieves the state of
the art on multiple testing protocols of ZSFA.","Face is one of the most popular biometric modalities due to its convenience of usage, e.g., access control, phone un lock. Despite the high recognition accuracy, face recogni tion systems are not able to distinguish between real human faces and fake ones, e.g., photograph, screen. Thus, they are vulnerable to face spoof attacks, which deceives the systems to recognize as another person. To safely use face recog nition, face antispooﬁng techniques are required to detect spoof attacks before performing recognition. Attackers can utilize a wide variety of mediums to launch spoof attacks. The most common ones are replay ing videos/images on digital screens, i.e., replay attack, and printed photograph, i.e., print attack. Different methods are proposed to handle replay and print attacks, based on either handcrafted features [7, 35, 38] or CNNbased fea ……Known Spoof Attacks Unknown Spoof AttacksLiveKnown SpoofUnknown Spoof Mask1 Print Replay Makeup Partial Paper Partial Paper Transparent MaskFigure 1: To detect unknown spoof attacks, we propose a Deep Tree Network (DTN) to unsupervisely learn a hierarchic embed ding for known spoof attacks. Samples of unknown attacks will be routed through DTN and classiﬁed at the destined leaf node. tures [4,18,20,32]. Recently, highquality 3D custom mask is also used for attacking, i.e., 3D mask attack. In [29–31], methods for detecting print/replay attacks are found to be less effective for this new spoof, and hence the authors leverage the remote photoplethysmography (rPPG) to de tect the heart rate pulse as the spooﬁng cue. Further, fa cial makeup may also inﬂuence the outcome of recognition, i.e., makeup attack [12]. Many works [11–13] study facial makeup, despite not as an antispooﬁng problem. All aforementioned methods present algorithmic solu tions to the known spoof attack(s), where models are trained and tested on the same type(s) of spoof attacks. However, in realworld applications, attackers can also initiate spoof attacks that we, the algorithm designers, are not aware of, termed unknown spoof attacks1. Researchers increasingly pay attention to the generalization of antispooﬁng models, i.e., how well they are able to detect spoof attacks that have never been seen during the training? We deﬁne the prob 1There is subtle distinction between 1) unseen attacks , attack types that are known to algorithm designers so that algorithms could be tailored to them, but their data are unseen during training; 2) unknown attacks , attack types that are neither known to designers nor seen during training. We do not differentiate these two cases and term both unknown attacks. 1arXiv:1904.02860v2  [cs.CV]  9 Apr 2019lem of detecting unknown face spoof attacks as ZeroShot Face Antispooﬁng (ZSFA) . Despite the success of face antispooﬁng on known attacks, ZSFA, on the other hand, is a new and unsolved challenge to the community. The ﬁrst attempts on ZSFA are [3, 45]. They address ZSFA between print and replay attacks, and regard it as an outlier detection problem for live faces (a.k.a. real hu man faces). With handcrafted features, the live faces are modeled via standard generative models, e.g., GMM, auto encoder. During testing, an unknown attack is detected if it lies outside the estimated live distribution. These ZSFA works have three drawbacks: Lacking spoof type variety: Prior models are developed w.r.t. print and replay attacks only. The respective feature design may not be applicable to different unknown attacks. No spoof knowledge: Prior models only use live faces, without leveraging the available known spoof data. While the unknown attacks are different, the known spoof attacks may still provide valuable information to learn the model. Limitation of feature selection: They use handcrafted features such as LBP to represent live faces, which were shown to be less effective for known spoof detection [27, 32, 37, 48]. Recent deep learning models [20, 32] show the advantage of CNN models for face antispooﬁng. This work aims to address all three drawbacks. Since one ZSFA model may perform differently when the unknown spoof attack is different, it should be evaluated on a wide range of unknown attacks types. In this work, we substan tially expand the study of ZSFA from 2types of spoof at tacks to 13types. Besides print and replay attacks, we in clude 5types of 3D mask attacks, 3types of makeup at tacks, and 3partial attacks. These attacks cover both imper sonation spooﬁng, i.e., attempt to be authenticated as some one else, and obfuscation spooﬁng, i.e., attempt to cover at tacker’s own identity. We collect the ﬁrst face antispooﬁng database that includes these diverse spoof attacks, termed Spoof in the Wild database with Multiple Attack Types (SiWM). To tackle the broader ZSFA, we propose a Deep Tree Network (DTN). Assuming there are both homogeneous features among different spoof types and distinct features within each spoof type, a treelike model is wellsuited to handle this case: learning the homogeneous features in the early tree nodes and distinct features in later tree nodes. Without any auxiliary labels of spoof types, DTN learns to partition data in an unsupervised manner. At each tree node, the partition is performed along the direction of the largest data variation. In the end, it clusters the data into several subgroups at the leaf level, and learns to detect spoof at tacks for each subgroup independently, shown in Fig. 1. During the testing, a data sample is routed to the most sim ilar leaf node to produce a binary decision of live vs. spoof. In summary, our contributions in this work include :Conduct an extensive study of zeroshot face anti spooﬁng on 13different types of spoof attacks; Propose a Deep Tree Network (DTN) to learn features hierarchically and detect unknown spoof attacks; Collect a new database for ZSFA and achieve the state oftheart performance on multiple testing protocols. 2. Prior Work Face Antispooﬁng Imagebased face antispooﬁng refers to face antispooﬁng techniques that only take RGB im ages as input without extra information such as depth or heat. In early years, researchers utilize liveness cues, such as eye blinking and head motion, to detect print at tacks [24, 36, 37, 39]. However, when encountering un known attacks, such as photograh with eye portion cut, and video replay, those methods suffer from a total failure. Later, research move to a more general texture analysis and address print and replay attacks. Researchers mainly utilize handcrafted features, e.g., LBP [7,16,17,35], HoG [25,47], SIFT [38] and SURF [8], with traditional classiﬁers, e.g., SVM and LDA, to make a binary decision. Those methods perform well on the testing data from the same database. However, while changing the testing conditions such as lighting and background, they often have a large perfor mance drop, which can be viewed as an overﬁtting issue. Moreover, they also show limitations in handling 3D mask attacks, mentioned in [30]. To overcome the overﬁtting issue, researchers make var ious attempts. Boulkenafet et al. extract the spooﬁng fea tures in HSV +YCbCR space [7]. Works in [2, 5, 6, 18, 46] consider features in the temporal domain. Recent works [2, 4] augment the data by using image patches, and fuse the scores from patches to a single decision. For 3D mask at tacks, the heart pulse rate is estimated to differentiate 3D mask from real faces [28, 30]. In the deep learning era, re searchers propose several CNN works [4, 18, 20, 27, 32, 37, 48] that outperform the traditional methods. Zeroshot learning and unknown spoof attacks Zero shot object recognition, or more generally, zeroshot learn ing, aims to recognize objects from unknown classes [40], i.e., object classes unseen in training. The overall idea is to associate the known and unknown classes via a semantic embedding, whose embedding spaces can be attributes [26], word vector [19], text description [49] and human gaze [22]. Zeroshot learning for unknown spoof attack, i.e., ZSFA, is a relatively new topic with unique properties. Firstly, unlike zeroshot object recognition, ZSFA emphasizes the detection of spoof attacks, instead of recognizing speciﬁc spoof types. Secondly, unlike generic objects with rich se mantic embedding, there is no explicit welldeﬁned seman tic embedding for spoof patterns [20]. As elaborated in Sec. 1, prior ZSFA works [3,45] only model the live data via handcrafted features and standard generative models, withTable 1: Comparing our SiWM with existing face antispooﬁng datasets. Dataset YearNum. of Face variations Spoof attack types Total num. of subj./vid. pose expression lighting replay print 3D mask makeup partial spoof types CASIAFASD [50] 2012 50/600 Frontal No No 1 2 0 0 0 3 ReplayAttack [15] 2012 50/1;200 Frontal No Yes 1 1 0 0 0 2 HKBUMARs [30] 2016 35/1;008 Frontal No Yes 0 0 2 0 0 2 OuluNPU [9] 2017 55/5;940 Frontal No No 1 1 0 0 0 2 SiW [32] 2018 165/4;620 ["
7,Integrating 6LoWPAN Security with RPL Using The Chained Secure Mode Framework.txt,"The IPv6 over Low-powered Wireless Personal Area Network (6LoWPAN) protocol
was introduced to allow the transmission of Internet Protocol version 6 (IPv6)
packets using the smaller-size frames of the IEEE 802.15.4 standard, which is
used in many Internet of Things (IoT) networks. The primary duty of the 6LoWPAN
protocol is packet fragmentation and reassembly. However, the protocol standard
currently does not include any security measures, not even authenticating the
fragments immediate sender. This lack of immediate-sender authentication opens
the door for adversaries to launch several attacks on the fragmentation
process, such as the buffer-reservation attacks that lead to a Denial of
Service (DoS) attack and resource exhaustion of the victim nodes. This paper
proposes a security integration between 6LoWPAN and the Routing Protocol for
Low Power and Lossy Networks (RPL) through the Chained Secure Mode (CSM)
framework as a possible solution. Since the CSM framework provides a mean of
immediate-sender trust, through the use of Network Coding (NC), and an
integration interface for the other protocols (or mechanisms) to use this trust
to build security decisions, 6LoWPAN can use this integration to build a
chain-of-trust along the fragments routing path. A proof-of-concept
implementation was done in Contiki Operating System (OS), and its security and
performance were evaluated against an external adversary launching a
buffer-reservation attack. The results from the evaluation showed significant
mitigation of the attack with almost no increase in power consumption, which
presents the great potential for such integration to secure the forwarding
process at the 6LoWPAN Adaptation Layer","The 6LoWPAN Adaptation Layer [1] and its protocol are widely used in many IoT networks to adapt the IPv6 packets to the smallersize Link Layer frames [2]. This adaptation is responsible for the packets’ fragmentation and reassembly at the nodes depending on the used forwarding scheme [1]. The security of 6LoWPAN and its common attacks was the subject of many literature [3]–[6], where it was shown that the 6LoWPAN protocol has a serious security issue: the lack of sender authentication. However, most of the proposed solu tions for this problem require either extensive modiﬁcations of the 6LoWPAN protocol or using external security mechanisms that are independent of the regular uIP stack. The Chained Secure Mode (CSM) framework [7], [8] was proposed (as a new RPL secure mode) to provide immediate sender authentication to RPL as RPL was found to suffer from the same security issue mentioned above as in the 6LoWPAN protocol [9]. Furthermore, the CSM framework includes atrustbased integration interface (the CSMTrust interface) that allows external security mechanisms or protocols to read and control the trust relationship with the node’s immediate neighbors. The evaluation of CSM and its integration interface [8] showed excellent mitigation capabilities against routing replay attacks (e.g., Neighbor attack (NA) and Wormhole (WH) attacks [10]), which opens the door for more use cases, such as the one described in the following paragraph. In this paper, a security integration between RPL and 6LoW PAN protocols is proposed using the CSM framework. Using the CSM framework and integrating a suitable trustbased external security mechanism, the 6LoWPAN protocol can use the generated chainoftrust , using the intraﬂow Network Coding (NC) scheme, to control fragments’ admission to the assembly buffer (see §V). With a focus on mitigating the bufferreservation attacks (see §VIB), a security and perfor mance evaluation is conducted on the proposed integration, which showed the great potentials for such use case, as it was able to mitigate the external adversary of the investigated attack using a simple proofofconcept security mechanism. The rest of the paper goes as follows: Related work is discussed in §II. A brief overview on 6LoWPAN and its common attacks is presented in §III, and another for RPL and the CSM framework is provided in §IV. Section V explains the concept behind the security integration case and its demonstra tion. The evaluation setup, assumptions, and adversary model are described in §VI. Section VII analyzes and discusses the evaluation results. Finally, the paper is concluded in §VIII. II. R ELATED WORK "
82,ESCM: An Efficient and Secure Communication Mechanism for UAV Networks.txt,"UAV (unmanned aerial vehicle) is rapidly gaining traction in various human
activities and has become an integral component of the satellite-air-ground-sea
(SAGS) integrated network. As high-speed moving objects, UAVs not only have
extremely strict requirements for communication delay, but also cannot be
maliciously controlled as a weapon by the attacker. Therefore, an efficient and
secure communication method designed for UAV networks is necessary. We propose
a communication mechanism ESCM. For high efficiency, ESCM provides a routing
protocol based on the artificial bee colony (ABC) algorithm to accelerate
communications between UAVs. Meanwhile, we use blockchain to guarantee the
security of UAV networks. However, blockchain has unstable links in
high-mobility networks resulting in low consensus efficiency and high
communication overhead. Consequently, ESCM introduces digital twin (DT), which
transforms the UAV network into a static network by mapping UAVs from the
physical world into Cyberspace. This virtual UAV network is called CyberUAV.
Then, in CyberUAV, we design a blockchain consensus based on network coding,
named Proof of Network Coding (PoNC). Analysis and simulation show that the
above modules in ESCM have advantages over existing schemes. Through ablation
studies, we demonstrate that these modules are indispensable for efficient and
secure communication of UAV networks.","N recent years, the rapid development of  communication technology has helped UAVs  show great  potential in the public and civil fields, and it has also  become the focus of attention in the communication field   [1]. For example, Ranjha et al.  [2] consider using UAVs as  decode andforward relays to communicate between  controllers and multi mobile robots . In [3], the authors  study    This work was supported by the  Natural Science Foundation of Sichuan  Province under Grant  2022NSFSC0913 . (Corresponding author: Gang Sun,  Hongfang Yu .)   Haoxiang  Luo, and Gang Sun are with the Key Laboratory of Optical Fiber  Sensing and Communications (Ministry of Education), University of  Electronic Science and Technology of China, Chengdu 611731, China (e  mail: lhx991115@163.com; gangsun@uestc.edu.cn).   Yifan Wu is with th e Department of Electrical and Computer Engineering ,  Carnegie Mellon University , Pittsburgh, PA 15260, USA (e mail:  yifanwu2@andrew.cmu.edu).   Hongfang Yu is with the Key La boratory of Optical Fiber Sensing and  Communications (Ministry of Education), University of Electronic Science  and Technology of China, Chengdu 611731, China, and also with Peng Cheng  Laboratory, Shenzhen 518066, China (e mail: yuhf@uestc.edu.cn).    Mohsen Guizani  is with with the Machine Learning Department , Mohamed  Bin Zayed University of Artificial Intelligence  (MBZUAI) , Abu Dhabi,  United Arab Emirates  (email: mguizani@ieee.org ). the quality ofservice capability of UAVs in mobile edge  networks.  Moreover, a s an integral part of the SAGS network,  UAVs can assist 6G communications by performing  indispensable functions such as auxiliary comput ing and  communication relaying.  In [4], the author s use UAVs assisted mobile edge computing systems  to achieve the above  functions . In [ 5], the author s design a multi user  communication network coordinated by UAV s and base  stations .  However, there are stil l many problems that need to be  solved before the UAV  network can achieve efficient  and  reliable functions.  Althoug h there is m uch work in the area of  mobile ad hoc networks , and vehicular ad hoc networks , it  does not address the unique characteristics of the UAV   network. The faster dynamic changes than vehicles and the  fluid topologies both make the UAV network topology change   more frequently and unpredictably. As a result, we need to  design specific communic ation mechanisms for  the UAV   network.   A. Research Motivation   To adapt to the fastmoving  characteristics of drones and  meet the high efficiency  of UAV network communication,  many scholars design reasonable and efficient routing  protocol s for UAV networks to improve communication  performance and efficiency. For example, the routing  protocols are based on geographical location proposed by [ 6 7]. In addition, there are routing protocols based on UAV  network topology, such as  [89]. Recently , bio inspired  methods have received great attention  due to their potential  properties, such as adaptability, self organization, and  robustness [ 10]. Since the UAV  fleet and swarm are similar in  that they both fly at high speed in three dimensional space,  thus, ABC [11]  is selected as the improved method of routing  protocol in ESCM.  This routing  protocol will select several  suitable drone s as candidate relay nodes, which will play a  role and determine the most suitable relay node in the Po NC  consensus propo sed by us.   However, the routing protocol  can only improve the  communication efficiency of the UAV network, but cannot  solve the existing communication security problems in the  UAV network as described in [ 12]. Currently, emerging  blockchain technology provides a viable solution to security  issues of  the UAV network. It can effectively avoid many  security problems of traditional encryption algorithms , such as  single point failure  [1314]. Blockchain is already playing a  huge role in the Intern et of Energy  (IoE) [15] and the Internet  of Vehicles (IoV) [16] through consensus algorithms that audit  and record all nodes  inforamtion  in the network.  There is also  a lot of research  on blockchain in UAV networks. For example, I     in [17], the authors  propos e a blockchain based trusted  framework for UAV network s, the corresponding network  architecture, protocol stack , and key control method.  In [18],  the authors present a case of  the UAV  network based on  blockchain and federated learning in 6G.   As an important part of a blockchain, the consensus  determines  the operational efficiency of the blockchain system  to some extent  [19]. Therefore, some scholars also study  consensus algorithms  used in the blockchain for UAV   networks [20] . However, the impl ementation of consensus is  related to participating nodes. In the UAV network, new  drone s often join the formation or some drone s leave the  formation, resulting in the instability of blockchain connection  and seriously affecting the consensus efficiency. M oreover,  reaching consensus requires many drone s to carry out multiple  rounds of  physical tophysical communications (P2PC) , thus  dragging down the efficiency of communication  [2122].  The rapid development of DT technology offers a solution  to th e above  problem s. By building digital replicas , physical  entities can be mapped into Cyberspace. In this case,  traditional P2PC can be converted to virtual tovirtual   communication (V2VC) via edge network and core network  [23]. More importantly, replicas in Cybersp ace constitute a  static network that is not limited by the geographic location of  UAVs, showing great potential in the management of  drones .  In order to explore the performance of the UAV network in  Cyberspace, we introduce this concept in ESCM, and map the  highly mobile UAV network into a static  network in  Cyberspace, name ly CyberUAV.    Then, we consider the  throughput is also an important  indicator of communication  performance  in the mapped  CyberUAV , thus, we design  a consensus algorithm Po NC  based on network coding to increase the throughput of UAV  network s. PoNC is a consensus algorithm similar to PoW  [24],  but it replaces meaningless mining behavior in PoW with  meaningful coding behavior. Po NC choos es the most suitable  drone  as a relay node to encode and forward the transmitted  message  by comparing the co ding capability of candidate  drone s selected in the ABC routing protoco l.  As mentioned above, communication difficulties in current  UAV network s can be summarized into the following three  points , which are  also problem s that ESCM  focuses on solving :     How to design efficient routing protocol and consensus  algorithm to ensure the timeliness of UAV network  communication.      How to use blockchain technology to ensure the security  of the UAV network.      How to solve the unstable link problem of blockchain in  the high speed mobile environment of UAV network.   B. Our Contribution s   To promote  the message transmission rate and  consensus   efficiency , this work  adopts  ABC to improve the routing  protocol , by selecting  several suitable candidate drone s as  candidate relay  nodes to define the scope for the  subsequent blockchain consensus, which can avoid  global  negotiation in the UAV network an d unnecessary   communication costs .    Additionally, to avoid the instability of blockchain links due to the highspeed movement of drone s, we introduce  the concept of the DT in ESCM, map ping drone s in the  physical world to Cyberspace, and transform ing the high  speed moving UAV network into a static  network named  CyberUAV. Then, we introduce blockchain into static  CyberUAV to improve the security of the UAV network .    To further improve consensus efficiency and increase  throughput , based on the blockchai n system consisting of  static  networks in CyberUAV, we propose a consensus  algorithm based on network coding , named PoNC , to  further improve network throughput . It can replace  meaningless mining behavior in PoW with meaningful  coding behavior. Simulation r esults show that it not only  increase s throughput  and improve s consensus efficiency,  but also ensure s high security.     We theoretically derive and simulate the consensus  success rate of MobileChain ( blockchain in a dynamic  wireless network ). It is proved th at the static CyberUAV   in DT has a higher consensus success rate than that of   mobile  UAV network s. This result further strengthens our  motivation to use DT to enable MobileC hain.  C. Structure of this Paper   The remaining contents are arranged as follows. Section II  reviews the related work. Section III shows the derivation and  simulation of the MobileChain consensus success rate, leading  us to enable MobileChain with DT.  Section IV introduces the  ESCM  model . Section V describes details of the ABC routing,  construction of CyberUAV, coding scheme , and PoNC  consensus. Section V I presents the  performance analysis ,  including the  consensus overhead  and consensus security  of  PoNC . Section VII is the performance evalu ation of ESCM .  Section VI II gives the  conclusion of this work .  II. RELATED WORK  "
16,Modeling and Evaluating Performance of Routing Operations in Proactive Routing Protocols.txt,"To ensure seamless communication in wireless multi-hop networks, certain
classes of routing protocols are defined. This vary paper, is based upon
proactive routing protocols for Wireless multihop networks. Initially, we
discuss Destination Sequence Distance Vector (DSDV), Fish-eye State Routing
(FSR) and Optimized Link State Routing (OLSR), precisely followed by
mathematical frame work of control overhead regarding proactive natured routing
protocols. Finally, extensive simulations are done using NS 2 respecting above
mentioned routing protocols covering mobility and scalability issues. Said
protocols are compared under mobile and dense environments to conclude our
performance analysis.","  In this era of infrastructure less communication, wireless multihop networks are gaining popularity day by day. In such networks nodes communicate with each other without any human interface. This  makes every node not only act as a transceiver but also a router besides its original functionality.  Besides infrastructure less communication provision, such networks gives us liberty of freedom (mobility) and low costs with respect to certain parameters. This concept seems very appealing, as we  can apply such kind of networks in almost every field of life. They can be applied in sensor networks,  in adhoc networks, in body area networks etc. However, in research arena, still there is a lot of work  to ensure such freedom and utility. mobile and scalable environments being the prominent aspects have rooms for betterment and to be more efficient.   End to end route surety is responsibility of a routing protocol. Hence protocols of network layer play  vital role in smooth, uninterrupted and efficient communication. Protocols dedicated for network layer are solely responsible in establishing/ discovering all required data (w.r.t different routes) from  network and than maintaining it.  There are certain classes of protocols defined fo r network layer of multihop networks. Reactive,  Proactive and Hybrid are three major classes of routing protocols having different philosophies of  accomplishing the same task. In reactive approach, we tends to use minimum network resources and  find a route only when it is required. This defines such protocols as event driven protocols. Network remains idle till the time, a request to find a route is made and when a request is made, such routing  protocols at that vary instance start searching route for desired node in network. Considering proactive  class of routing protocols, network resources are used initially in a heavy manner in finding every route to any possible destination in network. This philosophy may ensure no tolerance in delay  compromising on network resources. The third class, hybrid routing protocols are merger of both  reactive and proactive routing protocols [1].  In this work, we are confined only to proactive routing protocols. Initially we discuss three major  proactive protocols i.e. DSDV [2], FSR [4] and OLSR [3]. A mathematical model is presented  calculating routing overhead in idle and routing overhead in ever varying network. In last section, simulations of above mentioned routing protocols along with extensive comparisons and performance  analysis is given.     II.      RELATED WORK    "
182,Fieldable Cross-Layer Optimized Embedded Software Defined Radio is Finally Here!.txt,"The concept of cross-layer optimization has been around for several years
now. The primary goal of the cross-layer approach was to liberate the strict
boundary between the layers of the traditional OSI protocol stack. This is to
enable information flow between layers which then can be leveraged to optimize
the network's performance across the layers. This concept has been of keen
interest for tactical application as there is an overwhelming requirement to
operate in a challenging and dynamic environment. The advent of software
defined radios (SDR) accelerated the growth of this domain due to the added
flexibility provided by SDRs. Even with the immense interest and progress in
this area of research, there has been a gaping abyss between solutions designed
in theory and ones deployed in practice. To the best of our knowledge, this is
the first time in literature, an embedded SDR has been leveraged to
successfully design a cross-layer optimized transceiver that provides high
throughput and high reliability in a ruggedized, weatherized, and fieldable
form-factor. The design ethos focuses on efficiency and flexibility such that
optimization objectives, cross-layer interactions can be reconfigured rapidly.
To demonstrate our claims, we provide results from extensive outdoor
over-the-air evaluation in various settings with up to 10-node network
typologies. The results demonstrate high reliability, throughput, and dynamic
routing capability achieving high technology readiness level (TRL) for tactical
applications.","Wireless communication has undoubtedly become a ubiq uitous part of our lives and we are constantly striving to meet the evolving needs. This includes all connected devices in our smart homes, our cellular network, the entire concept of internetofthings (IoT) networks controlling manufacturing, industry automation, smart grid metering, space communica tions, underwater networks, tactical networks among others. As we move from 5G (5th Generation) to 6G (6th Generation), the need to optimize the scarce resources is becoming evident and inevitable [1]–[5]. Traditionally, the strictly layered architecture proposed by the open systems interconnection (OSI) reference model has been the prevalent design for a majority if not all modern networking architectures. This is strict in the sense that they are designed to maintain only a limited interface between the neighboring layers [6]. Realizing the deﬁciencies in this layered architecture, crosslayer optimized approach has been proposed over the past decade to maximize the utilization of scarce resources by ""erasing"" the strict boundaries between various layers of the protocol stack. In other words, any attempt to violate the OSI reference model is considered a crosslayer design [7]. While there are abundant solutions proposed in literature [6], the majority of it is limited tosimulations that may have strong assumptions and/or do not consider all the hardware constraints and rigidness that may be encountered during a reallife deployment. During the next phase of advancement, the advent of software deﬁned radios (SDR) provided the muchneeded impetus to this concept providing the ﬂexibility to implement novel cross layer architectures. This enabled some of these efforts to be extended to hardwarebased testbed evaluations. In most cases, these efforts still used one or more dedicated (non embedded) host computers to implement the solutions which were then connected to SDRs. Even with these advances, to the best of our knowledge, there does not exist a ruggedized ﬁeldable SDR with a comprehensive crosslayer optimization capable software module implemented on an embedded ARM processor. The main reason for this is the various hurdles that are associated with developing the solution from theory to effective hardware deployable software. Contribution: In this article, we present the ﬁrst, com pletely standalone, ruggedized, and ﬁeldable crosslayer op timized solution build using a low SWaP (Size, Weight, and Power) SDR. In this case, we implement an energy aware crosslayer protocol that aims to maximize network lifetime for enabling telemetry collection of tactical test and evaluation ranges. The primary contribution of this work is the realization of theoretical or simulationlevel concepts to a ﬁeldable hardware entity. We ﬁrst discuss the hardware level modiﬁcation required to customize the baseline SDR into a ﬁeldable solution. Next, we outline how the protocol stack was designed and implemented on a computationally constrained ARM processor. To demonstrate the feasibility of the implementation and the designed transceiver in terms of throughput and reliability, we performed extensive outdoor experiments with up to 10 nodes in the network. Impact: In this paper, we have demonstrated the feasibility and effectiveness of designing and developing an embedded SDRbased crosslayer optimized solution. The proposed ar chitecture and design principles can be leveraged to implement and mature several of the novel crosslayer optimized solutions to meet the evolving needs of both tactical and commercial communication systems. Our implementation principle has been to facilitate rapid reconﬁguration of network objective with only few lines of code thereby enabling a truly software deﬁned radio that evolves with the growing requirements. We hope and believe the unique crosslayer design methodologies and extensive outdoor evaluations (ﬁeld trials) will serve as an impetus for maturation of novel crosslayer solutions.arXiv:2110.01080v1  [cs.NI]  3 Oct 2021II. R ELATED WORK "
99,Multi-Agent Q-Learning Aided Backpressure Routing Algorithm for Delay Reduction.txt,"In queueing networks, it is well known that the throughput-optimal
backpressure routing algorithm results in poor delay performance for light and
moderate traffic loads. To improve delay performance, state-of-the-art
backpressure routing algorithm (called BPmin [1]) exploits queue length
information to direct packets to less congested routes to their destinations.
However, BPmin algorithm estimates route congestion based on unrealistic
assumption that every node in the network knows real-time global queue length
information of all other nodes. In this paper, we propose multi-agent
Q-learning aided backpressure routing algorithm, where each node estimates
route congestion using only local information of neighboring nodes. Our
algorithm not only outperforms state-of-the-art BPmin algorithm in delay
performance but also retains the following appealing features: distributed
implementation, low computation complexity and throughput-optimality.
Simulation results show our algorithm reduces average packet delay by 95% for
light traffic loads and by 41% for moderate traffic loads when compared to
state-of-the-art BPmin algorithm.","Backpressure routing algorithm, which routes packets in a queueing network by congestion gradients, holds great potentials for applications in different areas, like senso r net works [2], mobile ad hoc networks [3] and transportation systems [4], [5]. It is well known that the backpressure rout ing algorithm achieves maximum network throughput ( throughput optimality ) by exploring all possible routes (even route loops) to balance trafﬁc loads over the entire queueing network. Th is is effective for queueing networks with heavy trafﬁc loads. However, for light and moderate trafﬁc loads, excessive rou te exploration may lead to packets being directed to unnecessa rily long routes or even route loops as shown in Fig. 1, which results in poor delay performance [6].  !  ""  #  $  %   &  Fig. 1. A packet directed to a route loop, experiencing long d elay. This material has been submitted in part to International Co nference on Computing, Networking and Communications (ICNC) 2018, Haw aii, USA. J. Gao and M. Ito are with the Graduate School of Information S cience, Nara Institute of Science and Technology, Nara 6300192, Ja pan. Email: {jtgao,ito}@is.naist.jp. Y . Shen is with the School of Computer Science and Technology , Xidian University, Shaanxi 710071, China. Email: ylshen@mail.x idian.edu.cn. N. Shiratori is with Research Institute of Electrical Commu nication, Tohoku University, Sendai 9808579, Japan.To improve delay performance of backpressure routing algorithm, available works [1], [2], [7]–[11] aim at direct ing packets to shorter routes to their destinations by exploiti ng various information of queueing networks, such as informat ion of queue length, shortest path length (distance of the short est path between two nodes) and packet delay (see Section VI for details). Out of these works, stateoftheart BPmin al  gorithm proposed in [1] signiﬁcantly reduces average packe t delay of backpressure routing algorithm. According to BPmi n algorithm, every node in a queueing network needs to know queue length information of all other nodes in real time. Bas ed on these queue length information, every node calculates the sum of queue length of each route as route congestion estimate and then directs packets to least congested routes to their destinations. However, in queueing networks it is unrealistic for nodes to collect such realtime global queu e length information. Moreover, BPmin algorithm requires th e knowledge of network throughput capacity to make routing decisions, which is hard to determine. In this paper, we propose multiagent Qlearning aided backpressure routing algorithm (QLBP), where each node estimates route congestion using only local information of neighboring nodes. Speciﬁcally, every node under our QLBP algorithm maintains multiple Qlearning agents, where eac h Qlearning agent continuously updates its route congestio n estimate using neighboring nodes’ queue length informatio n and neighboring nodes’ route congestion estimates. Based on estimated route congestion, every node directs packets t o least congested routes to their destinations. Our algorith m not only outperforms stateoftheart BPmin algorithm in dela y performance but also retains the following appealing featu res: distributed implementation, low computation complexity a nd throughputoptimality. Simulation results show our algor ithm reduces average packet delay by 95% for light trafﬁc loads and by41% for moderate trafﬁc loads when compared to stateof theart BPmin algorithm. The rest of this paper is organized as follows. In Section II, we introduce network models concerning communication links, resource allocation, transmission rates, packet ge ner ating, etc. In Section III, we describe in details our multi agent Qlearning aided backpressure routing algorithm (QL  BP). In Section IV, we analyze the performance of our QL BP algorithm. In Section V, we do simulations to evaluate the delay performance of our QLBP algorithm. We introduce related work in Section VI and conclude the whole paper in Section VII.2 TABLE I KEY NOTATIONS Notation Deﬁnition (i,j) The communication link between two nodes iandj,i,j∈ N , is denoted by pair (i,j),(i,j)∈ L, which is different from link (j,i). Sij(t) The state of link (i,j)at slott, which represents factors affecting transmission rate of l ink(i,j)at slott, like node position, channel fading and interference coefﬁc ients. S(t)S(t) =/parenleftbigSij(t)/parenrightbig, the matrix of all link states at slot t. Iij(t) The resource allocation decision over link (i,j)at slott, such as link activation, coding, modulation, etc. I(t) I(t) =/parenleftbigIij(t)/parenrightbig, the matrix of resource allocation decision over all links a t slott. I(t)(respectively, Iij(t)) under algorithm Xis denoted by IX(t)(resp.IX ij(t)). µij(t) The offered transmission rate (packets/slot) over link (i,j)at slottunderS(t)andI(t). Actual data amount transmitted over link (i,j)during slot tmay be less than µij(t)due to insufﬁcient data. µ(t)µ(t) =/parenleftbigµij(t)/parenrightbig, the matrix of offered transmission rates over all links. µ(c) ij(t) The offered transmission rate to commodity cover link (i,j)at slott,/summationtext cµ(c) ij(t)≤µij(t). Actual data amount of commodity ctransmitted over link (i,j)during slot tmay be less than µ(c) ij(t). Further,µ(c) ij(t)under algorithm Xis denoted by µ(c)X ij(t). A(c) i(t) The amount of packets node igenerates at slot t, which are destined for node c,c/ne}ationslash=i. U(c) iThe queue of node i, which stores packets destined for node c∈ {1,2,···,N},c/ne}ationslash=i. U(c) i(t) The queue length of queue U(c) iat slott, i.e, the number of packets queueing up at queue U(c) iat slott. By convention, U(i) i(t) = 0 . U(t)U(t) =/parenleftbig U(c) i(t)/parenrightbig , the matrix of queue length of all queues at slot t. B(c) i(t) The bias associated with queue U(c) iat slott. B(t)B(t) =/parenleftbigB(c) i(t)/parenrightbig, the matrix of bias for all queues at slot t. H(t) Matrix of information of a queueing network, which is used to extract bias. Examples include information of queue length, shortest pat h length, packet delay, etc. Q(c) ijRoute congestion estimated by Qlearning agent of node ifor routes of commodity cand by the way of nodei’s neighbor j. Qi Qi= (Q(c) ij), the matrix of route congestion estimates of node i. II. N ETWORK MODEL We consider a multihop queueing network represented by a directed graphG= (N,L)as shown in Fig. 2, where Nis the set ofNnodes andLis the set of Ldirected links. The whole network operates over discrete time slots t∈{0,1,2,···}. In the network, every node both transmits packets generated by itself and relays packets from other nodes to their destinat ions. For this purpose, each node maintains seperate queues to store packets destined for different destinations. For exa m ple, queue U(c) iof nodeistores packets destined for node c∈{1,2,···,N},c/ne}ationslash=i. All packets destined for the same destination care referred to as commodity c. Key deﬁnitions and notations to be used in the following are summarized in Table I.  !("")  1 2 3  4 N  !(#) …   !($)  Fig. 2. Multihop queueing network and queues of node 3. Transmission rate µij(t)is affected by random link states S(t)and resource allocation decisions I(t)such that µij(t) = ˆµij(S(t),I(t)),S(t)∈S,I(t)∈I (1) whereSis the ﬁnite space of link states and Iis the ﬁnite space of resource allocation decisions. We assume that theoutgoing transmission rate and incoming transmission rate of all nodes are upper bounded µout max= max i,s∈S,I∈I/summationdisplay jˆµij(s,I) (2) µin max= max i,s∈S,I∈I/summationdisplay kˆµki(s,I) (3) The amount of packets generated by each node at each slot t is also upper bounded by a positive constant Amax such that max iE/braceleftBig/bracketleftBig/summationdisplay cA(c) i(t)/bracketrightBig2/bracerightBig ≤A2 max (4) AfterKtime slots (called convergence interval in [12]), the queueing network arrives at steady state such that packe t generating processes A(c) i(t)and link states S(t)converge as follows /vextendsingle/vextendsingle/vextendsingle1 Kt0+K−1/summationdisplay τ=t0E/braceleftbig A(c) i(t)/bracerightbig −λ(c) i/vextendsingle/vextendsingle/vextendsingle≤δ1 (5) /summationdisplay s∈S/vextendsingle/vextendsingle/vextendsingle1 Kt0+K−1/summationdisplay τ=t0E/braceleftbig 1[S(t)=s]/bracerightbig −πs/vextendsingle/vextendsingle/vextendsingle≤δ2 (6) where1[statement ]is an indicator function that returns value 1ifstatement is true and 0otherwise, λ(c) iis the average rate of packet generating process A(c) i(t),πsis the rate of link states S(t)being at state s∈S,δ1andδ2are two small positive numbers.3 Queue length U(c) i(t)for two adjacent slots satisﬁes the following relationship U(c) i(t+1)≤max/braceleftBig U(c) i(t)−/summationdisplay jµ(c) ij(t),0/bracerightBig +/summationdisplay kµ(c) ki(t)+A(c) i(t) (7) becauseµ(c) ki(t)is the offered transmission rate to commodity cover link (k,i)at slott, however, node kmay not have enough packets to transmit to node iat slott. III. M ULTI AGENT QL EARNING AIDED BACKPRESSURE ROUTING ALGORITHM In this section we introduce in details our multiagent Q learning aided backpressure routing algorithm (QLBP). Fi rst, we propose a bias based general framework for delay reductio n in backpressure routing algorithm. Then, we build QLBP algorithm based on this general framework. A. Bias Based General Framework 1. collect information   2. extract bias 3. backpressure         routing  heuristics,  machine learning queue length,  shortest path,  packet delay, etc. based on bias   and local queue  Fig. 3. Bias based framework in backpressure routing algori thm. The whole bias based general framework consists of three stages: information collection, bias extraction and backp res sure routing, as illustrated in Fig. 3 and summarized in Algorithm 1. At stage of information collection, our frame work (referred to as BPBias) collects useful (local or globa l) information H(t), like queue length, shortest path and packet delay, for delay reduction. At stage of bias extraction, BPB ias framework extracts useful features (e.g., route congestio n estimate) from H(t)as matrix of bias B(t) = (B(c) i(t)), whereB(c) i(t)is the bias for queue U(c) iat slottand is a function of H(t)and upper bounded by a positive constant Bmax, B(c) i(t) =B(c) i(H(t)) (12) 0≤B(c) i(t)≤Bmax,for alli,c (13) B(i) i(t) = 0,for alli (14) At the ﬁnal stage of backpressure routing, BPBias framework programs extracted bias B(t)into backpressuring routing algorithm, enabling the algorithm to adaptively change pac ket routes for delay reduction. Speciﬁcally, bias B(c) i(t)for dif ferent queue U(c) ican be dynamically adjusted according toAlgorithm 1 Bias Based General Framework for Delay Re duction in Backpressure Routing (BPBias) Information collection: At every time slot t, network con troller observes link states S(t)and collects information H(t), such as information of (local or global) queue length, shortest path for all node pairs, packet delay for all queues. Bias extraction: Network controller extracts bias B(t)from H(t)for delay reduction. Various bias extracting methods can be adopted here, such as heuristic and machine learning methods. Bias Based Backpressure routing: 1:For all links (i,j), ﬁnd the optimal commodity c∗ ij(t)such that c∗ ij(t)=argmax c∈N/braceleftBig /parenleftBig U(c) i(t)+B(c) i(t)/parenrightBig −/parenleftBig U(c) j(t)+B(c) j(t)/parenrightBig/bracerightBig (8) Calculate pressure gradients W∗ ij(t)for all links (i,j) W∗ ij(t) = max/braceleftBig/parenleftBig U(c∗ ij(t)) i(t)+B(c∗ ij(t)) i(t)/parenrightBig −/parenleftBig U(c∗ ij(t)) j(t)+B(c∗ ij(t)) j(t)/parenrightBig ,0/bracerightBig (9) Make resource allocation decision IBPBias(t)such that IBPBias(t) = argmax I∈I/summationdisplay (i,j)∈Lˆµij/parenleftbig S(t),I/parenrightbig ·W∗ ij(t) (10) 2:UnderIBPBias(t)andS(t), for each link (i,j)and commodity c, transmit packets with rates as follows µ(c)BPBias ij (t)=  ˆµij/parenleftbig S(t),IBPBias(t)/parenrightbig ifc=c∗ ij(t), W∗ ij(t)>0; 0 otherwise. (11) realtime information H(t), so that packets can be directed to better routes. The methods for extracting bias B(t)fromH(t)can be either heuristic based methods [1], [2], [7]–[11] or machin e learning based methods, like Qlearning [13]. This ﬂexibil ity enables our framework to be very general and cover many bias based backpressure routing algorithms as special case s as listed in Table II. B. QLBP Algorithm Based on this general BPBias framework, we propose multi agent Qlearning aided backpressure routing algorithm (QL  BP), where Qlearning agents are responsible for extractin g route congestion estimate from collected information, whi ch is used as bias to aid backpressure routing algorithm to redu ce packet delay. From now on, we focus on queueing networks with inde pendent links (e.g., wireline networks or wireless network s with orthogonal links). Under our QLBP algorithm, each nodeimaintains multiple Qlearning agents, where each agent4 TABLE II SPECIAL CASES OF OURFRAMEWORK Special Case Condition [7] B(c) i(t)varies with realtime queue length and packet delay [1] B(c) i(t)is set to be bias functions in [1] [8] B(c) i(t)−B(c) j(t) =−Mfor all links (i,j) [9] B(c) i(t)is the shortest distance between node iand node c [10] B(c) i(t)contains information of constrains on route length [2] B(c) i(t)is a constant calculated as in [2] [11] B(c) i(t)is a function of packet delay information QLA(c) ijis associated with one commodity cand one neighbor jof nodei, responsible for estimating the route congestion Q(c) ijfor routes of commodity cand by the way of node i’s neighbor j. Thus, each node imaintains a table Qi= (Q(c) ij) storing route congestion estimates. At stage of information collection, each node iobserves local link states Sij(t)and collects local information by exchanging its own queue length U(c) i(t)and table Qiof route congestion estimates with its neighboring nodes. At s tage of bias extraction, each Qlearning agent QLA(c) ijof nodei updates its route congestion estimate Q(c) ijas follows: Q(c) ij←(1−α)Q(c) ij+α/bracketleftbig U(c) j(t)+γmin kQ(c) jk/bracketrightbig (15) whereαandγare Qlearning parameters, 0< α,γ≤1. If Q(c) ij> Bmax, setQ(c) ij=Bmax. Each node icalculates bias B(c) i(t)for commodity cas B(c) i(t) = min jQ(c) ij (16) Finally, at stage of backpressure routing, based on extract ed biasB(c) i(t)and observed link states Sij(t)each node imakes resource allocation and routing decisions as in BPBias. From the description of QLBP algorithm, we see that QL BP algorithm is a special case of BPBias framework. For queueing networks with independent links, transmission ra tes µij(t)of all links are also independent of each other. Thus, the maximum of the weighted sum of (10) can be achieved by each node independently maximizing corresponding terms as follows: max I∈I/summationdisplay (i,j)∈Lˆµij/parenleftbig S(t),I/parenrightbig ·W∗ ij(t) (17) =/summationdisplay i/bracketleftBig max Iij/summationdisplay j:(i,j)∈Lˆµij/parenleftbig Sij(t),Iij/parenrightbig ·W∗ ij(t)/bracketrightBig whereIijdenotes the available resource allocation decision for link(i,j). Therefore, our QLBP algorithm can be imple mented in a distributed way. Furthermore, each node under QLBP algorithm only needs to exchange information with neighboring nodes and maximizes weighted sum locally, the computation complexity of QLBP algorithm is low as com pared to algorithms globally maximizing the weighted sum of (10).Remark 1: Our QLBP algorithm can be further improved by considering shortest path information (referred to as QL SP BP). Under QLSPBP algorithm, each node icalculates bias for commodity cas B(c) i(t) = min jQ(c) ij+P(c) i (18) whereP(c) iis the length of the shortest path from node ito nodec. The rest of QLSPBP is the same with QLBP. IV. A LGORITHM PERFORMANCE ANALYSIS In this section, we show that our QLBP algorithm is also throughputoptimal. First, we introduce the following deﬁnitions concerning queueing network stability, queueing network stability re gion and throughput optimality. Deﬁnition 1 (Network Stability [12]): A single queue U(c) i is said to be stable if g(V)→0asV→∞ , where g(V) = limsup t→∞E/braceleftBig1 t/integraldisplayt 01[U(c) i(t)>V]dt/bracerightBig (19) A queueing network is said to be stable if all queues are stabl e. Deﬁnition 2 (Network Stability Region): Packet generating rates/parenleftbig λ(c) i/parenrightbig are said to be supported by a queueing network if the queueing network can be stabilized by some routing algorithm under/parenleftbig λ(c) i/parenrightbig . The network stability region Λis the closure of the set of all packet generating rates/parenleftbig λ(c) i/parenrightbig that can be supported by the queueing network. Deﬁnition 3 (Throughput Optimality): An algorithm is said to be throughput optimal if it can stabilize the queueing network for all packet generating rates/parenleftbig λ(c) i/parenrightbig that are within network stability region Λ, i.e.,/parenleftbig λ(c) i+ǫ/parenrightbig ∈Λ,ǫ >0. Then, we establish the throughputoptimality of our QLBP algorithm. Theorem 1 (QLBP ThroughputOptimality): For a queueing networkG= (N,L)with stability region Λ, our QLBP algorithm is throughput optimal. Proof: Since QLBP algorithm is a special case of BPBias framework, if we can prove that the general BPBias is through  put optimal, then QLBP algorithm is also throughput optima l. According to the deﬁnition of throughputoptimality, we need to prove that for any packet generating rates/parenleftbig λ(c) i/parenrightbig within network stability region Λ, i.e.,/parenleftbig λ(c) i+ǫ/parenrightbig ∈Λ,ǫ >0, our framework BPBias can stabilize the queueing network. Some steps of the following proof are similar to that of [12], whic h are included here for completeness. Recall that Kis the convergence interval of queueing networkG. For any routing algorithm and time interval [t0,t0+K−1], queue length U(c) i(t0+K),i/ne}ationslash=c,satisﬁes the following relationship U(c) i(t0+K)≤max/braceleftBig U(c) i(t0)−K/summationdisplay jµ(c) ij,0/bracerightBig +K/summationdisplay kµ(c) ki+KA(c) i (20)5 where µ(c) ij=1 Kt0+K−1/summationdisplay τ=t0µ(c) ij(τ) (21) A(c) i=1 Kt0+K−1/summationdisplay τ=t0A(c) i(τ) (22) Refer to Appendix B for its derivation. Since bias B(c) i(t0)≥0 from(13), we have U(c) i(t0+K)≤max/braceleftBig U(c) i(t0)+B(c) i(t0)−K/summationdisplay jµ(c) ij,0/bracerightBig +K/summationdisplay kµ(c) ki+KA(c) i (23) After squaring both sides of (23) and basic algebraic manip ulations, we get /bracketleftbig U(c) i(t0+K)/bracketrightbig2−/bracketleftbig U(c) i(t0)/bracketrightbig2 ≤/bracketleftbig B(c) i(t0)/bracketrightbig2+K2/bracketleftbigg/parenleftBig/summationdisplay jµ(c) ij/parenrightBig2 +/parenleftBig/summationdisplay kµ(c) ki/parenrightBig2 +2/parenleftBig/summationdisplay kµ(c) ki/parenrightBig A(c) i+/parenleftBig A(c) i/parenrightBig2/bracketrightbigg +2U(c) i(t0)B(c) i(t0) −2K/bracketleftBig U(c) i(t0)+B(c) i(t0)/bracketrightBig/bracketleftBig/summationdisplay jµ(c) ij−/summationdisplay kµ(c) ki−A(c) i/bracketrightBig (24) Deﬁne Lyapunov function L(U(t)) =/summationtext i/negationslash=c[U(c) i(t)]2. By summing (24) over all nodes iand commodities c/ne}ationslash=iand taking conditional expectations, we get the Kstep Lyapunov drift∆/parenleftbig U(t0),B(t0)/parenrightbig as follows: ∆/parenleftbig U(t0),B(t0)/parenrightbig =E/braceleftBig L/parenleftbig U(t0+K)/parenrightbig −L/parenleftbig U(t0)/parenrightbig/vextendsingle/vextendsingle/vextendsingleU(t0),B(t0)/bracerightBig ≤C1+2/summationdisplay i/negationslash=cU(c) i(t0)B(c) i(t0) −2K/summationdisplay i/negationslash=c/bracketleftBig U(c) i(t0)+B(c) i(t0)/bracketrightBig ·E/braceleftBig/summationdisplay jµ(c) ij−/summationdisplay kµ(c) ki−A(c) i/vextendsingle/vextendsingle/vextendsingleU(t0),B(t0)/bracerightBig (25) whereC1is a constant given by C1=K2N/bracketleftbig (µout max)2+/parenleftbig µin max+Amax)2/bracketrightbig +N(N−1)B2 max (26) and the expectation is with respect to random link states S(t), packet generating processes A(c) i(t)and resource allocation decisions I(t). Inequality (25) can also be written alternatively as ∆/parenleftbig U(t0),B(t0)/parenrightbig ≤C1+2/summationdisplay i/negationslash=cU(c) i(t0)B(c) i(t0) −2K/bracketleftBig Φ/parenleftbig U(t0),B(t0)/parenrightbig −β/parenleftbig U(t0),B(t0)/parenrightbig/bracketrightBig (27)where Φ/parenleftbig U(t0),B(t0)/parenrightbig =1 Kt0+K−1/summationdisplay τ=t0E/braceleftBig/summationdisplay i/negationslash=c/bracketleftBig U(c) i(t0)+B(c) i(t0)/bracketrightBig ·/bracketleftBig/summationdisplay jµ(c) ij(τ)−/summationdisplay kµ(c) ki(τ)/bracketrightBig/vextendsingle/vextendsingle/vextendsingleU(t0),B(t0)/bracerightBig (28) β/parenleftbig U(t0),B(t0)/parenrightbig =1 Kt0+K−1/summationdisplay τ=t0E/braceleftBig/summationdisplay i/negationslash=c/bracketleftBig U(c) i(t0)+B(c) i(t0)/bracketrightBig ·A(c) i(τ)/vextendsingle/vextendsingle/vextendsingleU(t0),B(t0)/bracerightBig (29) Next, we show that for any/parenleftbig λ(c) i/parenrightbig such that/parenleftbig λ(c) i+ǫ/parenrightbig ∈ Λ,ǫ >0, our framework BPBias stabilizes the queueing network and thus our framework is throughputoptimal. LetΦBPBias/parenleftbig U(t0),B(t0)/parenrightbig andΦX/parenleftbig U(t0),B(t0)/parenrightbig be the quantity Φ/parenleftbig U(t0),B(t0)/parenrightbig under BPBias and under any otherXalgorithm, respectively. Then, we have the following relationship ΦBPBias/parenleftbig U(t0),B(t0)/parenrightbig ≥ΦX/parenleftbig U(t0),B(t0)/parenrightbig −C2(30) whereC2is given in (66). Refer to Appendix B for its derivation. Thus, the Kstep Lyapunov drift ∆/parenleftbig U(t0),B(t0)/parenrightbig under BPBias algorithm ∆/parenleftbig U(t0),B(t0)/parenrightbig ≤C1+2/summationdisplay i/negationslash=cU(c) i(t0)B(c) i(t0) −2K/bracketleftBig ΦBPBias/parenleftbig U(t0),B(t0)/parenrightbig −β/parenleftbig U(t0),B(t0)/parenrightbig/bracketrightBig (31) ≤C1+2KC2+2/summationdisplay i/negationslash=cU(c) i(t0)B(c) i(t0) −2K/bracketleftBig ΦX/parenleftbig U(t0),B(t0)/parenrightbig −β/parenleftbig U(t0),B(t0)/parenrightbig/bracketrightBig (32) =C1+2KC2+2/summationdisplay i/negationslash=cU(c) i(t0)B(c) i(t0) −2K/summationdisplay i/negationslash=c/bracketleftBig U(c) i(t0)+B(c) i(t0)/bracketrightBig1 Kt0+K−1/summationdisplay τ=t0E/braceleftbigg/summationdisplay jµ(c)X ij(τ) −/summationdisplay kµ(c)X ki(τ)−A(c) i(τ)/vextendsingle/vextendsingle/vextendsingleU(t0),B(t0)/bracerightbigg (33) According to Theorem 6 [12], we know that for any/parenleftbig λ(c) i/parenrightbig such that/parenleftbig λ(c) i+ǫ/parenrightbig ∈Λ,ǫ >0, there exists a stationary randomized routing algorithm STAT , which makes resource allocation and routing decisions independent of U(t0)and B(t0), such that 1 Kt0+K−1/summationdisplay τ=t0E/braceleftbigg/summationdisplay jµ(c)STAT ij(τ)−/summationdisplay kµ(c)STAT ki(τ) −A(c) i(τ)/vextendsingle/vextendsingle/vextendsingleU(t0),B(t0)/bracerightbigg ≥ǫ 2(34)6 Substitute (34) into(33), we get ∆/parenleftbig U(t0),B(t0)/parenrightbig ≤C1+2KC2+2/summationdisplay i/negationslash=cU(c) i(t0)B(c) i(t0) −Kǫ/summationdisplay i/negationslash=c/bracketleftBig U(c) i(t0)+B(c) i(t0)/bracketrightBig (35) ≤C1+2KC2+2/summationdisplay i/negationslash=cU(c) i(t0)Bmax−Kǫ/summationdisplay i/negationslash=cU(c) i(t0) (36) =C−(Kǫ−2Bmax)/summationdisplay i/negationslash=cU(c) i(t0) (37) whereC=C1+2KC2. SinceKis the convergence interval of the queueing net work, it is easy to determine the value of Ksuch that Kǫ−2Bmax>0, i.e.,K >2Bmax/ǫ. From the Kstep Lyapunov drift bound (37) and Lemma 2 [12], we know that our BPBias framework stabilizes the queueing network for any/parenleftbig λ(c) i/parenrightbig such that/parenleftbig λ(c) i+ǫ/parenrightbig ∈Λ,ǫ >0, and thus it is throughput optimal. Therefore, QLBP algorithm is also throughput optimal. This completes the proof. V. S IMULATION In this section, we evaluate the delay performance of our QLBP algorithm by simulations and compare it to other variants of backpressure routing algorithms. A. Simulation Setup ( , )   (!, )  ( ,!)   (!,!)   Fig. 4. Network topology for simulation. We consider the network topology as shown in Fig. 4, which consists of 64nodes, indexed by a pair of coor dinates. All links are bidirectional and the maximum data transmission rates for all links are 1 packet/slot. We as sume all links can transmit packets simultaneously with out interfering with each other, such as wireline network or wireless network with orthogonal channels. We con sider trafﬁc ﬂows with the following sourcedestination pairs: ((1,3),(2,5)), ((2,3),(2,7)), ((2,2),(1,6)), ((3 ,4),(2,7)),((1,1),(1,7)), ((4,3),(5,4)), ((4,6),(6,6)), and ((5,3) ,(5,6)). All source nodes generate packets according to Poisson distri bution with rate λpackets/slot. We implemented by Python our QLBP algorithm, QLSPBP algorithm, traditional back pressure routing algorithm (BP) [9], [12], shortest path ba sed backpressure routing algorithm (SPBP) [9], [12] and state  oftheart BPmin algorithm [1]. For our QLBP algorithm and QLSPBP algorithm, we set Qlearning parameters λ= 1,γ= 1to enable agents to quickly update their route congestion estimates. We run simulations for 105slots for each simulation setting and calculate the average delay of packets received by destinations under different algorithms. B. Simulation Results /s48/s46/s49 /s48/s46/s51 /s48/s46/s53 /s48/s46/s50 /s48/s46/s52 /s48/s46/s54/s48/s50/s48/s48/s52/s48/s48/s54/s48/s48/s56/s48/s48/s49/s48/s48/s48/s65/s118/s101/s114/s97/s103/s101/s32/s112/s97/s99/s107/s101/s116/s32/s100/s101/s108/s97/s121/s32/s40/s115/s108/s111/s116/s115/s41 /s80/s97/s99/s107/s101/s116/s32/s97/s114/s114/s105/s118/s97/s108/s32/s114/s97/s116/s101/s32 /s32/s40/s112/s97/s99/s107/s101/s116/s115/s47/s115/s108/s111/s116/s41/s32/s66/s80 /s32/s83/s80/s45/s66/s80 /s32/s66/s80/s109/s105/s110 /s32/s81/s76/s45/s66/s80 /s32/s81/s76/s83/s80/s45/s66/s80 Fig. 5. Average packet delay under different backpressure r outing algorithms. From Fig. 5, we can observe that our QLBP algorithm reduces average packet delay by 71% when compared to tradi tional BP algorithm under light trafﬁc loads with λ= 0.1and by82% under moderate trafﬁc loads with λ= 0.4, indicating that QLBP algorithm effectively learns route congestion a nd adaptively directs packets to better routes. However, QLB P algorithm results in higher packet delay than stateofthe art BPmin algorithm. This is because nodes of BPmin algorithm know perfect realtime global queue length information and thus can accurately estimate congestion of different route s and direct packets to the least congested routes. Nodes of QLBP algorithm only know local information of neighboring nodes, thus can only loosely estimate congestion of differe nt routes, which may lead to directing packets to suboptimal routes. However, BPmin algorithm is not realistic since rea l time global queue length information is hard to collect by nodes in real world. Our QLBP algorithm trades off some packet delay for distributed algorithm implementation and low computation complexity, thus can be easily deployed in real queueing networks. Our QLBP algorithm can be greatly improved by con sidering shortest path information. From Fig. 5, we see that7 QLSPBP algorithm outperforms all variants of backpressur e routing algorithms including stateoftheart BPmin algo rithm: reducing average packet delay by 95% for light trafﬁc loads withλ= 0.1and by41% for moderate trafﬁc loads with λ= 0.4when compared to BPmin algorithm. In summary, our algorithm can be easily deployed in real queueing networks, but also achieves the best delay performance when compared to other variants of backpressure routing algorithms. VI. R ELATED WORK "
362,Timed Analysis of Security Protocols.txt,"We propose a method for engineering security protocols that are aware of
timing aspects. We study a simplified version of the well-known Needham
Schroeder protocol and the complete Yahalom protocol, where timing information
allows the study of different attack scenarios. We model check the protocols
using UPPAAL. Further, a taxonomy is obtained by studying and categorising
protocols from the well known Clark Jacob library and the Security Protocol
Open Repository (SPORE) library. Finally, we present some new challenges and
threats that arise when considering time in the analysis, by providing a novel
protocol that uses time challenges and exposing a timing attack over an
implementation of an existing security protocol.","The communication via a shared medium, like the Internet, is inherent ly insecure: anyone has access to en route messages and can potentially eavesdrop or eve n manipulate the ongoing com munication. Security protocols are distributed programs speciﬁca lly designed to achieve secure communication over such media, typically exchanging messages built c onstructed using crypto graphic operations (e.g. message encryption). Security protocolsare diﬃcult to design correctly, hence their ana lysis is critical. A particularly successful model to analyze security protocols is the Dolev Yao mo del [16], in which the attacker is assumed to have complete control over the network. Also, the mo del assumes ideal cryptography, where cryptographic operations are assumed to be perfect. The Dolev Yao model is attractive because it can be easily formalized using languages and tools based on formal methods. More over, the model has an appropriate level of abstraction, as many attacks are independent of the underlying details of the cryptographic operations and are based o nly on combinations of message exchanges plus knowledge gathered by the attacker during the ex ecution. Typically, Dolev Yao methods for formal veriﬁcation of security pro tocols (among the propos als [27, 14, 10]) do not take timeinto account, and this choice simpliﬁes the analysis. However, security protocols, like distributed programs in general, are sensit ive to the passage of time. Re cently, consideration of time in the analysis of security protocols ha s received some attention (see Related Work below), but this attention has been focused mostly on timestamps. In this paper1we develop an analysis model for security protocols that explicitly ta kes into ac counttimeﬂowingduringthe executionofa protocol. In general, in the designa nd implementation of a security protocol two aspects of timing must be considered at some stage: 1. Time can inﬂuence the ﬂow of messages. For instance, when a mes sage does not arrive in a timely fashion (i.e. timeouts), retransmissions or other actions have to be considered. 2. Time information can be included within protocol messages (e.g. tim estamps). ∗Contact author’s email is ricardo.corin@utwente.nl . 1An earlier version appeared in [11]. 1Consider ﬁrst (1) above. In general, the inﬂuence of time on the ﬂo w of messages is not usually considered by current state of the art methods for analysing pro tocols. However, we believe it to be crucial because (i) Even if the abstract protocol does not decide what action to take at a particular moment of the execution (e.g. in the case of timeouts), the actual implementation will eventually havetoconsiderthese issuesanyway;(ii) The eﬃciencyandsecurit yoftheimplementation depends critically on these speciﬁc decisions; and (iii) The timing of message ﬂow s in a protocol can be exploited by an attacker. Now consideritem (2) above. There, webelieve that makingjudicious use oftiming information in a protocol has received attention but mostly in the limited setting o f using time stamps as opposed to nonces. However, time information can be used to inﬂue nce message ﬂows as well, as we illustrate in Section 6. Contributions Our study covers several issues in the study of time in security pro tocols. •Firstly, in Section 2 we study which kinds of timing issues, like timeouts a nd retransmissions, may arise in the study of security protocols. We then proceed in Sec tion 3 to present a method for the design and analysis of security protocols that cons ider these timing issues. The method is based on modelling security protocols using timed autom ata [3]. In support of the method we use UPPAAL [4] as a tool to simulate, debug and ve rify security proto cols against classical safety goals like secrecy and authentication, in a real time scenario , using reachability properties. As examples, we analyse a simpliﬁed ver sion of the Needham Schroeder protocol [26] and the full Yahalom protocol [9] in Sectio n 4. •Secondly, in Section 5, we categorize all the protocols from the Clar k and Jacob library and the SPORE library into diﬀerent (more abstract) patterns of mess age ﬂows with timeouts. We then analyse each abstract pattern, independently of the act ual protocols, and establish their timing eﬃciency and security. •Finally, in Section 6 we illustrate some novel opportunities and diﬃcultie s that appear when considering time in the design and analysis of security protocols: –In Section 6.1 we give an example protocol that accomplishes authen tication by exploit ing thetimeliness of messages. The protocol uses time in a conceptually new way, by employing time challenges as a replacement for nonces. –As a second example of a novel diﬃculty in Section 6.2, we describe how timing at tacks [17] can be applied to security protocols, by describing an att ack over Abadi’s private authentication protocol [2]. Although these protocols ca n be modelled as timed automata, thus permitting general veriﬁcation, we leave the deta iled veriﬁcation as fu ture work since for this we need a model checker that is also probabilistic (like [13] or [24]): our nondeterministic intruder of UPPAAL is too powerful, since it can always guess correctly times and values even if the probability of guessing is negligible. 2 Timeouts and Retransmissions To illustrate how time inﬂuences the analysis of security protocols (e ven when it does not explicitly use timing information), consider the following protocol written in th e usual notation. 1. A→B:MAB 2. B→A:MBA Here, ﬁrst Asends message MABtoB, and later Bsends message MBAtoA. This highlevel view does not consider timing. To consider time, we ﬁrst need to assu me that both AandBhave 2(iv)A BMAB tAsAMBAA BMAB MBAMAS abort! tAtSS A B MAB MBA tAsA tAA M AB MBAB (i) ( ii) ( iii) Figure 1: Left: Timeouts (i) typical (ii) windowed; Right: timeout actions (iii) chained abort and (iv) retransmission timers. In this paper, we do not require timers between parties to be sync hronised (see below for a discussion). The next step consists in distinguishing the diﬀerent o perations that occur, with their respective times. In Step 1, it takes some time to create MAB. The other operation that takes time is the actual sending of the message, ie. the time it takes MABto travel from AtoB. This transmission time is unbounded, since the message may be lost or intercepted, and therefore Amay need to timeout: AfterAsendsMAB, she starts a timer that will timeout if MBA(Step 2 of the above protocol) is not received after some waiting, say tA(Figure 1 ( i)). Clearly, tAshould be greater than the time of creating MBA, plus the average time of sending both MABandMBA. In general, Adoes not need to start waiting for a response immediately after sen ding a message; for instance, Acould hibernate (or start doing another task) for some time sAbefore beginning to expect the response MBA. This results in a windowed timeout (Figure 1 ( ii)). Typically, the values for sAandtAdepend on implementation details. However, an implementation indepe ndent quantitative analysis could already give an early indication of what att acks can be mounted for some values that are no longer possible for others (eg. a smaller tAand a larger sA). Another issue that is not considered either in previous approaches is that the actionto be taken when a timeout occurs is sensitive. Typically, the implicit assump tion is that the protocol should abort, as it is the case in Figure 1 ( i). This means that the protocol party that reaches the timeout deduces that a fault has happened. However, aborting ma y not consist only of stopping execution altogether. For example, if we consider protocols with se veral parties, we may wish that when a party timeouts it also communicates its decision to abort to ot her, still active parties. For instance, consider the following protocol: 1. A→B:MABAstarts timer expecting MBA 2. A→S:MASSstarts session timer 3. B→A:MBA Here, ifAtimes out on Step 2, she could communicate the abort decision to S, as shown in in Figure 1 ( iii). Aborting execution is not the only feasible action to perform after a timeout [25], and in principle protocols could successfully execute when messages do notarrive at certain moments. Even if we do assume that a fault occurred, aborting may not be the best choice: sometimes, message retransmission is a better, more eﬃcient and also more rea listic option, as depicted in Figure 1 ( iv). In this case, a question which arises is whether to retransmit the original message (MABfor Figure 1 ( iv)), or to recompute some parts before resending the message. H ere, the tradeoﬀ is, as usual, between eﬃciency versus security. Time information can also be included in the contents of MABandMBA. A typical value to include is a timestamp, to prevent replay attacks. However, this re quiressecureclock synchroni sation of AandB, which is expensive (see Mills [29] for a security protocol to achieve t his). In fact, this is the reason for which Bellovin et al. recommend to switch t o nonces in the Kerberos protocol [7]. Recently, the analysis of security protocols using time stamps has received consider 3able attention from the research community (see Related Work in Se ction 7). Therefore, in this paper we do not pursue this direction. 3 A Method for Analysing Security Protocols We use timed automata[3] to model protocolparticipants, and this has severaladvantages. Firstly, our method requires the designer to provide a precise and relatively detailed protocol speciﬁcation, which helps to disambiguate the protocol behaviour. Secondly, timin g values like timeouts need to be set at each state, while retransmissions can be speciﬁed as tran sitions to other protocol states. Once modelled as timed automata, the protocol can be fed to the re al time model checker UPPAAL, which allows the protocol to be simulated and veriﬁed. The s imulation provides the designer with a good insight of the inner workings of protocol, and alr eady at this stage speciﬁc timing values like timeouts can be tuned. Then the designer can proce ed with veriﬁcation of speciﬁc properties. As usual in model checking, the veriﬁcation of the protocol with UPPAAL is automatic. The resulting timed automata model is an informative and precise des cription of the secu rity protocol, and thus, it provides a practical way to strengthen implementations while keeping eﬃciency in mind. As a third and ﬁnal step we propose to transfer timing information b ack to the high level protocol description. This serves to highlight the role of time in the im plementation, but also (as we will demonstrate in Section 6.1), to make timing an integral aspect of the protocol design. 3.1 Timed Automata and UPPAAL In this paper, the timed automata of Alur and Dill are used for modellin g [3]. In general, timed automata models have an inﬁnite state space. The region automato n construction, however, shows that this inﬁnite state space can be mapped to an automaton with a ﬁ nite number of equivalence classes (regions or zones) as states [3]. Finitestate model chec king techniques can then be applied to the reduced, ﬁnite region automaton. A number of model check ers for timed automata is available, for instance, Kronos [31] and UPPAAL [4]. Parallel composition of automata is one of the main sources for expr essiveness. This operation allows to decompose complex behaviour, thus supporting transpar ent modelling. When compos ing automata in parallel, we need also to provide some form of communic ation. For the timed automata we use in this paper, communication comes in form of hand shake synchronisation. Two parallel automata can share a synchronisation channel, i.e. both ha ve a transition labelled with a complementing channel name, e.g. synchronise! in the example of Figure 2. These transitions may only be taken together, at the same moment. In Figure 2 we see an example for a transition, labelled by a guard that has to be true when the transition is taken, a synchronisation channel, and a variable update. Data transmission is typically modelled by a synchronisation, where glo bal variables are up dated. These global variables contain the data that are transmitt ed. var_v>const_c synchronise! var_w:=var_w+1 Figure 2: Example transition with guard, synchronisation and updat e 4✂✄ ✁"
331,M-GEAR: Gateway-Based Energy-Aware Multi-Hop Routing Protocol for WSNs.txt,"In this research work, we advise gateway based energy-efficient routing
protocol (M-GEAR) for Wireless Sensor Networks (WSNs). We divide the sensor
nodes into four logical regions on the basis of their location in the sensing
field. We install Base Station (BS) out of the sensing area and a gateway node
at the centre of the sensing area. If the distance of a sensor node from BS or
gateway is less than predefined distance threshold, the node uses direct
communication. We divide the rest of nodes into two equal regions whose
distance is beyond the threshold distance. We select cluster heads (CHs)in each
region which are independent of the other region. These CHs are selected on the
basis of a probability. We compare performance of our protocol with LEACH (Low
Energy Adaptive Clustering Hierarchy). Performance analysis and compared
statistic results show that our proposed protocol perform well in terms of
energy consumption and network lifetime.","A key concern in WSN technology is to enhance the network lifetime and to reduce the energy consumption of the sensor network. Wireless sensor nodes are dispersed typica lly in sensing area to monitor earthquake, battle ﬁeld, industr ial environment, habitant monitoring [1], agriculture ﬁeld [2 ], physical atmosphere conditions and smart homes. Sensor nodes sense the environment, gather information and transm it to BS through wireless link. Due to escalating in MicroElectroMechanical System technology, now it is possible to set up thousands or million s of sensor nodes. The intense deployment of WSN makes it quite difﬁcult to recharge node batteries. Therefore, a key subject for WSNs is to curtail power expenditure of sensor nodes to prolong network lifetime. Many clustering based algorithms [3] [4] are proposed. Clustering is a technique in which network energy consumption is well managed by minimizing the transmission range of the sensors. In this modus operandi, CH manages the group communication with the BS. Sensor nodes no longer transmit data directly to the BS instead CHs receive the whole group messages, aggregates and forwards to the BS. All nodes in cluster transmit their data to corresponding CH. The CH issues a Time Division Multiple Access (TDMA) schedule for its member nodes to avoid collision. Each mem ber node transmits its data to CH only in deﬁned allocatedtime slot therefore, sensor nodes turn off their transceive rs otherwise. TDMA scheduling encourages saving energy of sensor nodes and these nodes stay alive for longer period. As a rule, each member node transmits its data to nearby CH therefore; sensor nodes require minimum energy for data transmission. CHs perform computation on collected data an d ﬁlter out the redundant bits, it reduces the amount of data th at has to forward to the BS. Consequently, transmission energy of sensors reduce to signiﬁcant amount. In this research wor k, we design a gateway based energyaware multihop routing protocol. The impulse behind this work is to trim down the energy consumptionofsensornodesbylogicallydividingthe netwo rk intofourregions.We usedifferentcommunicationhierarch yin differentregions.Nodesin oneregioncommunicatedirectl yto BS while nodes in region 2 communicate directly to gateway node. Nodes in other two regions use clustering hierarchy an d sensor nodes transmit their data to gateway node through the ir CHs. Gateway node assists in deﬁning clusters and issues a TDMA schedule for CHs. Each CH issues its own TDMA schedule for its member nodes. The rest of the paper is ordered as follows: section 2 brieﬂy review the related work. In section 3, we describe motivatio n forthiswork.Section4describesthenetworkmodel.Propos ed algorithm is explained in section 5. In section 6, we deﬁne the performance parameters and show the performance of our proposed protocol by simulations and compare it with LEACH. Finally, section 7 gives conclusion. II. RELATED WORK "
180,Routing Towards Discriminative Power of Class Capsules.txt,"Capsule networks are recently proposed as an alternative to modern neural
network architectures. Neurons are replaced with capsule units that represent
specific features or entities with normalized vectors or matrices. The
activation of lower layer capsules affects the behavior of the following
capsules via routing links that are constructed during training via certain
routing algorithms. We discuss the routing-by-agreement scheme in dynamic
routing algorithm which, in certain cases, leads the networks away from
optimality. To obtain better and faster convergence, we propose a routing
algorithm that incorporates a regularized quadratic programming problem which
can be solved efficiently. Particularly, the proposed routing algorithm targets
directly on the discriminative power of class capsules making the correct
decision on input instances. We conduct experiments on MNIST, MNIST-Fashion,
and CIFAR-10 and show competitive classification results compared to existing
capsule networks.","Convolutional neural networks have been deeply studied in recent years. Its variations are successfully and widely applied in different tasks including classiﬁcation [1], generation [2], segmentation [3], and so on. Convolution layers abstract common features hierarchically by scanning the object with shared kernels that decomposes the original images into small and simple instances which are hence used for classiﬁcation task. However, the process to some extent violates the nature of recognizing objects, that the visual system resembles parse treelike [4] structures on ﬁxation points adopted by human vision. In each layer of a parse tree, neurons are grouped together representing certain objects, which are known as capsules. Capsule networks are recently proposed as an alternative of modern convolutional neural network architectures that changes the way neural networks are trained and features are represented, and, as a result, it also brings robustness to adversarial attacks and overlapped objects [5]. A capsule is a group of neurons that represent a feature or an entity. The capsule length reﬂects by how much the capsule is activated or the probability a corresponding entity exists in a given image. Capsules in adjacent layers are densely connected via traditional neuron links with their weights learned through routingbyagreement algorithms, as shown in Figure 1. Another characteristic of capsule networks is that lower level features are constructing higher level entities as layer goes deeper, compared to convolutional neural networks that perform feature abstraction layer by layer. … …………CAP1CAP2CAP3CAPN…………OCAP1OCAP2OCAP10Fig. 1 Visualization of capsule layers with 10 capsules in the output layer that represent the existence of 10 classes. Two recent capsule routing algorithms are dynamic routing [5] and EM routing [6]. Dynamic routing quantiﬁes the agree ment between capsules via their innerproduct. The greater innerproduct value indicates two capsules agree more with each other and the dynamic routing aims to amplify the agreement. EM routing models each higher level capsule as a Gaussian and the posterior probability of previous layer capsules determines in which level they are connected to higher level capsules. In both routing algorithms, capsules are coupled to higher level capsules according to certain agreement metrics without considering the prediction results. In this work, we discuss and analyze the routingby agreement mechanisms in capsule networks and propose a routing algorithm that can achieve faster convergence and bet ter discrimination results in classiﬁcation tasks. The algorithm is inspired by two observations: (1) the ultimate objective of training capsule networks is to make the correctly activated output capsules have the largest lengths and (2) the feature capsules (capsules before the output layer) are reasonable to have negative effects on capsules in the following layers. We also propose several training tricks to enlarge the solution space that can result in higher classiﬁcation accuracy on several datasets. We pick the capsule network architecture used in [5] as a case study to show how our methods beneﬁt the training of capsule networks. II. R ELATED WORKS "
439,A Percolation based M2M Networking Architecture for Data Transmission and Routing.txt,"We propose a percolation based M2M networking architecture and its data
transmission method. The proposed network architecture can be server-free and
router-free, which allows us to operate routing efficiently with percolations
based on six degrees of separation theory in small world network modeling. The
data transmission can be divided into two phases: routing and data transmission
phases. In the routing phase, probe packets will be transmitted and forwarded
in the network thus multiple paths are selected and performed based on the
constriction of the maximum hop number. In the second phase, the information
will be encoded, say, with the fountain codes, and transmitted using the paths
generated in the first phase. In such a way, an efficient routing and data
transmission mechanism can be built, which allow us to construct a low-cost,
flexible and ubiquitous network. Such a networking architecture and data
transmission can be used in many M2M communications, such as the stub network
of internet of things, and deep space networking, and so on.","The stub network of internet of things ( IoT) may have a lot of subnetwoks buliding with  machineto machine (M2M) communication systems, which are usually highly dynamic.  That is,  networking nodes and links may frequently join to the network and exit from the  network . In addition, such networks  are often composed using relatively inexpensive nodes  that have low power consupmtion, low processing power, and bandwidth. The conventional  internet architecture and TCP/IP are not suitable for the the applications of M2M networks  because such convention al networks require a lot of servers and routers, and the high  overhead in their protocols result in high bandwidth needs  which is not reasonable for  bandwidth limited communications. Therefore, i t is necessary to examine the efficient  network architecture and effective data transmission method to achieve better performance  with low cost for  the M2M communications.   The rest of the paper is organized  as follows. In Section 2, we review the previous work in  networking, routing and data transmission of M2M communications . Section 3 addresses the   M2M network architecture based on six degree separation  principle, including t he brief  introduction of network topology, routing table and network initialization.  Section 4 details  the efficient percolation routing and data transmission process with their applications . And  finally, we conclude our  work  in Section 6 .  2. Related Work  "
10,Comparative Analysis of Routing Protocols for Under Water Wireless Sensor Networks.txt,"Underwater Wireless Sensor Networks are significantly different from
terrestrial sensor networks due to peculiar characteristics of low bandwidth,
high latency, limited energy, node float mobility and high error probability.
These features bring many challenges to the network protocol design of UWSNs.
Several routing protocols have been developed in recent years for these
networks. One of the major difficulties in comparison and validation of the
performance of these proposals is the lack of a common standard to model the
acoustic propagation in the harsh underwater environment. In this paper we
analyze the evolution of certain underwater routing protocols like VBF, DBR,
H2-DAB, QELAR etc. in terms of their localization techniques, energy
minimization characteristics and holding time calculations. The design of each
protocol follows certain goals i.e. reduction of energy consumption,
improvement of communication latency, achievement of robustness and scalability
etc. This paper examines the main approaches and challenges in the design and
implementation of underwater sensor networks. The detailed descriptions of the
selected protocols contribute in understanding the direction of the current
research on routing layer in UWSN.","Underwater Wireless Sensor Networks (UWSN) provide a promising solution for discovering  aqueous environment efficiently for military, emergency and commercial purposes. Unmanned or  Autonomous Underwater Vehicles (UUVs, AUVs), equipped with underwater senso rs, are also  envisioned to find application in exploration of natural undersea resources and gathering of scientific  data in collaborative monitoring missions.   The underwater environment is much different from terrestrial and a number of issues need to  be addressed while using sensor networks as an effective technology for underwater systems. Due to  the high dense salty water, electromagnetic and optical signals cannot be transmitted for long  distances in ocean because of scattering, high attenuation and absorption effect. Acoustic  communication can be used to overcome this problem which provides a better means of data transfer  in such an environment.  Hence, available propagation speed is shifted from the speed of light to speed of sound which is five orde rs of magnitude slower i.e 1500 m/sec, which brings long  propagation latency and end toend delay. Available bandwidth is severely limited (i.e. <100 kHz).  Sensor nodes are generally considered as static but underwater sensors can move upto 1 to 3 m/sec  due to underwater activities. Also, underwater nodes are larger in size so they consume more power  and replacement of nodes or batteries is not so easy. Underwater applications require multi hop  networks where nodes transmit data to one of more sinks located  at the surface level. Sinks then  forward the received information to onshore control stations via RF transmissions.  Ahmed  et al., 2013    The routing protocols that require higher bandwidth result in large end toend delays and are  not suitable for these environments. Some of  the challenges in under water communication are  propagation delay, high bit error rate and limited bandwidth.   Due to the unique challenges of underwater environment, the communication protocols  proposed for terrestrial networks cannot be directly applied  to UWSNs. Many protocols have been  proposed for UWSNs taking into account the unique features of underwater networks, including  media access control, network and transport protocols. The routing protocols for UWSNs can be  classified into localization based and localization free routing protocols. The routing protocols can  take advantage of the localization of sensor nodes; however, the localization is not perfect because of  the mobility of sensor nodes, and harsh environment. Rather localization free routi ng protocols are  highly demanded by research communities.   Recently, many routing protocols have been proposed for UWSNs. In this survey, we present  some well known routing protocols proposed for UWSNs, which can be broadly classified into two  sections, loc alization based and localization free routing protocols.   • LOCALIZATION BASED ROUTING PROTOCOLS   These routing protocols are based on the assumption of the localization of sensor nodes in  UWSNs. In [1], the vector based forwarding (VBF) protocol was proposed,  in which a source node  computes a vector from itself towards the sink and the neighboring nodes, around the computed vector  up (called routing pipe), participate in forwarding the data packets. However, VBF has certain  limitations, of hard assumption of localization of sensors and the unavailability of sensor nodes in the  routing pipe.   Hopbyhop vector based forwarding (HHVBF) [13] is a successor of VBF and it employs the  technique of computing the routing vector at each hop starting from each sender towa rds the sink. The  recomputation at each hop reduces the effect of sparse density but inherits the assumption of the  localization.   In [14], focused beam routing (FBR) utilizes different transmission power levels (i.e. ranging  from P1 to PN) during the selec tion of next relay node, by broadcasting an ready to send (RTS)  packet, and the receiving nodes reply with a clear to send (CTS) packet. The limitation of the FBR  protocol lies in the use of RTS/CTS during the forwarding of the data packets causing increas ed delay  and excessive energy consumption.   In [15], directional flooding based routing (DFR) uses scoped flooding where a limited number  of nodes are allowed to participate in forwarding data. The flooding zone is decided based on the  angle among the sourc e, current forwarder and the sink node, and the link quality of the neighboring  nodes. DFR tries to limit the number of forwarding nodes. However, redundant packet’s transmission  cannot be avoided and the localization assumption limits its applicability.   • LOCALIZATION FREE ROUTING PROTOCOLS   An overview of the routing protocols that do not assume any kind of localization are also  presented. In [4], a novel routing protocol called depth based routing (DBR) uses the depth of the  sensor nodes as a routing metric  and assumes that each node has a depth sensor. DBR suffers from  redundant packet transmissions and excessive energy consumptions, because of the long propagation delay in UWSNs.  In H2 DAB [7], hop byhop dynamic addressing based routing protocol, the rout ing  is performed based on an address (called HopID) assigned to each sensor node, based on the hop  count from the sink node. The sink node broadcasts a Hello packet. The receiving nodes are assigned  a HopID. These nodes then rebroadcast the Hello packet af ter an increment of one in the HopID.  However, only the hop count value for the selection of the next hop node is not suitable in stringent UWS network. In addition, the use of inquiry request and inquiry reply augments the already long  endtoend delay an d consumes extra energy.   All these routing protocols [1] to [15] are compared on the basis of their localization  techniques, mechanisms for energy minimization and holding time calculations, and a comparative study is conducted to evaluate their performances in different scenarios which can be quite helpful in  the design of an efficient routing protocol.   II. RELATED WORK  AND MOTIVATION   "
366,Scalable Routing on Flat Names.txt,"We introduce a protocol which routes on flat, location-independent
identifiers with guaranteed scalability and low stretch. Our design builds on
theoretical advances in the area of compact routing, and is the first to
realize these guarantees in a dynamic distributed setting.","Routing scalability is highly desirable for very large, dynamic, and resourceconstrained networks, including many peertopeer systems and the Internet. Shortest path routing algorithms (link state, distance vector, path vector, etc.) all [16] require  ( n) memory at each router for a network with ndestinations, and at least as much communication and computation to build the routing tables. One way to scale routing is to use a structured net work topology that makes routing easy. Examples range from torus networks in supercomputers [25] to planar networks which permit greedy geographic routing [23] to hypercubes, small world networks, and other topolo gies in distributed hash tables [39,43,50]. But requiring a particular highly structured topology is not feasible for generalpurpose networks. For general networks, the common scaling technique ishierarchy : routing is performed over highlevel ag gregate units until it reaches the destination's unit, at which point routing proceeds at a ner granularity. For example, the Internet routes at the level of IP prexes to a destination domain, and then over an intradomain routing protocol to a subnet. Hierarchy has two main problems. First, it can have arbitrarily high stretch , dened as the ratio of route length to the shortest path length. Simultaneously guaranteeing scalability and low stretch on arbitrary networks is a nontrivial problem which no deployed routing protocols achieve. Second, hierarchy requires locationdependent addresses , com plicating management, mobility, and multihoming. In response, numerous recent proposals suggest rout ing on locationindependent  at names [5, 12, 13, 20, This technical report extends our ACM CoNEXT 2010 pa per [41] by including the proofs for the theoretical results.21,28,42]. Flat names are a paradigm shift for the net work layer: rather than requiring a locationdependent IP address to serve the needs of the routing protocol, a name is an arbitrary bit string that can serve the needs of the application layer. For example, a name could be a DNS name, a MAC address, or a secure selfcertifying identier [21,28,42]. But no previously proposed proto cols exist for scalable, lowstretch routing on  at names. This paper introduces a new routing protocol: Dis tributed Compact Routing, or \Disco"". Disco builds on theoretical advances in centralized, static compact rout ing algorithms [3,44] and is the rst dynamic distributed protocol to guarantee the following properties: Scalability: A Disco router needs just ~O(pn) routing table entries1regardless of network topology. Low stretch: Disco has worstcase stretch 7 on a  ow's rst packet, worstcase stretch 3 on subsequent packets, and much lower average stretch. Flat names: Disco routes on arbitrary \ at"" names rather than hierarchical addresses. Disco's guarantee of ~O(pn) routing table entries trans lates to ~O(rpn)bitsof state where ris the size of a partial route; see discussion in x2. Recently, several papers have introduced techniques which approach the above properties. In particular, citing the lack of a distributed compact routing pro tocol, VRR [9] introduced a novel DHTinspired ap proach to route on  at names, but as we will see, VRR does not guarantee scalability and low stretch. S4 [34] is a distributed implementation of a compact routing algorithm of [44], but it does not route on  at names and as we will show, it breaks the state bound of [44] causing high pernode state on realistic topologies. Dis tributed compact routing was listed as an open problem by Gavoille [17]. We nd, however, that guaranteed scalable, ecient routing on  at names is achievable. Disco is a careful synthesis of compact routing theory with wellunderstood 1The standard notation ~O() hides polylogarithmic factors to aid readability. Disco actually has O(pnlogn) entries. 1arXiv:1302.6156v1  [cs.NI]  25 Feb 2013systems techniques and a novel, lowoverhead overlay network for disseminating routing state. That synthe sis is the primary contribution of this paper. Disco thus represents a step towards closing the gap between the oretical and applied work on scalable routing. The rest of this paper proceeds as follows. Sec. 2 dis cusses the need for our three requirements of scalability, low stretch, and  at names. We describe how past work has fallen short of these requirements in Sec. 3. Sec. 4 presents our protocol and Sec. 5 evaluates it. We con clude with a discussion of future work in Sec. 6. 2. REQUIREMENTS This paper is guided by three key requirements. Guaranteed scalability: The routing protocol should use little space and messaging regardless of the network topology. In particular, we wish to reduce state require ments from the  ( n) bits at each node used by tradi tional routing protocols in an nnode network, to some thing asymptotically smaller, e.g., ~O(pn) per node. Guar anteeing scalability on any topology helps ensure that the protocol will continue to function smoothly despite future growth, higher dynamics, and new environments. Disco meets this requirement for graphs in which we have a bound on the size of \explicit routes"" within the local vicinity of each node. In particular, Disco has ~O(pn) routing table entries for a total of ~O(rpn) bits of state where ris the maximum size of an explicit route, since these routes are embedded in nodes' addresses. (For example, we might have r=O(logn).) Inx4.2, we discuss the need for this assumption and argue that it is reasonable. While in the worst case r=~O(pn), in a routerlevel Internet map our addresses are shorter than IPv6 addresses. Guaranteed low stretch: The protocol should nd paths that are close to the shortest possible. Stretch is the ratio of the protocol's route length to the shortest path length. Since it is not possible to route on short est paths using o(n) state per node [16], some stretch is unavoidable given our scaling goal. However, we de sire stretch to be bounded by a small constant in the worst case, so that local communication stays local and performance does not degrade regardless of the trac demands. Flat names: The protocol should route on arbitrary node names which may have no relationship with a node's location. In particular, this service should op erate while preserving the stretch guarantee. Flat names are widely recognized as a useful primi tive. The locationindependence of  at names aids mo bility and eliminates the management burden of location based address assignment. Numerous proposed redesigns of Internet routing use  at names to cleanly separate location from identity, including TRIAD [20], i3 [42],FARA [12], HIP [21], and LISP [13]. Flat names can also be selfcertifying [28, 35, 46], where the name is a public key or a hash of a public key. This provides se curity without a public key infrastructure to associate keys with objects. Selfcertifying names have been pro posed for data objects in contentcentric networks [28, 40], for a persistent and contentionfree replacement for URLs [46], and for nodes in an accountable Internet architecture [5]. If low stretch were not a goal, supporting  at names would be straightforward. In particular, the routing system could resolve names into addresses|using DNS, a consistent hashing database over a set of wellknown nodes [14, 26, 34], or a DHT [15]|and then route over addresses. But these solutions violate our stretch re quirement: the resolution step might travel across the world even if the destination is next door.2Even though the resolution step may be needed for only the rst packet of a  ow, this latency may dominate for short  ows; indeed, subsecond delays make a dierence to users in web services such as Google [8]. Moreover, these solutions lack fate sharing [11]: a failure far from the sourcedestination path can disrupt communication. Similarly, an attacker far from the path could disrupt, redirect, or eavesdrop on communication. Despite its desirability, scalable lowstretch routing on  at names has remained elusive. Indeed, satisfying all three requirements is an algorithmically challenging goal which remained essentially unsolved from the 1989 introduction of the problem [7] until 2003 [6], even in the static centralized case. And as we shall see in the next section, no distributed solution has been developed. 3. RELATED WORK "
143,Performance Evaluation of Enhanced Interior Gateway Routing Protocol in IPv6 Network.txt,"With the explosive growth in communication and network technologies, there is
a great demand of IPv6 addressing scheme. However, the modern operating systems
has option for this and with the development of IPv6 which removes the
limitations imposed by IPv4 and provides the large number of address space. In
this paper, authors have considered the Enhanced Interior Gateway Routing
Protocol and presented a scenario for its performance evaluation in IPv6
networks and obtained results are highly considerable for the short distance of
communication and don't represent any problem of performance degradation while
sending or receiving the data.","Recently, a lot of developments have been taken place in  computer networks and now it is the necessity that the  computer in one geographical location must communicate  with another computer located at different geographical  location. For doing so, though there are various available  alternatives but almost all alternatives require use of Internet  Protocol (IP) address to uniquely identify the machine over  the network. If the two different computers are in the same   location then they can communicate via Local Area Network  (LAN), if not, then different available alternatives can be used  for connectivity and communication over the networks and  Wide Area Network (WAN) is one of them. To communicate  over networks , numbe rs of devices are required and router is  one of them and the routing protocol must be configured  properly on each router. This routing protocol maintains the  routing table which further maintains the shortest path of  communication from source to destinatio n. Commonly , this  routing protocol is in IPv4 but nowadays IPv4 addresses are  depleting so these protocols are now using IPv6 addresses.  There are number of d ynamic routing protocols (DRP)  supported by IPv6 such as  RIPng, EIGRP, OSPFv3, IS IS,  and Multipro tocol BGP etc.   In this paper, authors  have considered the Enhanced Interior  Gateway Routing Protocol (EIGRP) [1, 2, 3] for IPv6 as a  routing protocol , which is a Cisco proprietary protocol and  uses classless routing schemes based on diffusion update  algor ithm (DUAL) for calculating a shortest path from source  to destination. It also supports unequal path load balancing  that is the main reason  of its fastest protocol. Its  administrative distance is 90 that represent the trustworthiness  of protocol.  EIGRP s elects fastest path based on delay,  bandwidth, reliability, and load. For this, smaller size of packets is  transmitted after every 5 seconds to see whether  neighbou r router is up or not. These packets are sent for  various different reasons like :   a) For discovering neighbour,    b) For forming relation with neighbour,   c) For maintaining relation with neighbour.   DUAL algorithm used, includes Successor(S), Feasible  Successor (FS), Feasibility Condition (FC), Feasible Distance  (FD), and reported dist ance (RD) [4] .   2. RELATED WORK   "
417,DiffFlow: Differentiating Short and Long Flows for Load Balancing in Data Center Networks.txt,"In current Data Center Networks (DCNs), Equal- Cost MultiPath (ECMP) is used
as the de-facto routing protocol. However, ECMP does not differentiate between
short and long flows, the two main categories of flows depending on their
duration (lifetime). This issue causes hot-spots in the network, affecting
negatively the Flow Completion Time (FCT) and the throughput, the two key
performance metrics in data center networks. Previous work on load balancing
proposed solutions such as splitting long flows into short flows, using
per-packet forwarding approaches, and isolating the paths of short and long
flows. We propose DiffFlow, a new load balancing solution which detects long
flows and forwards packets using Random Packet Spraying (RPS) with help of SDN,
whereas the flows with small duration are forwarded with ECMP by default. The
use of ECMP for short flows is reasonable, as it does not create the
out-of-order problem; at the same time, RPS for long flows can efficiently help
to load balancing the entire network, given that long flows represent most of
the traffic in DCNs. The results show that our DiffFlow solution outperforms
both the individual usage of either RPS or ECMP, while the overall throughput
achieved is maintained at the level comparable to RPS.","In recent years, the number of Internet applications hosted in Data Centers has been fast growing, making the Data Center Network (DCN) operation ever more complex. Generally, two different categories of trafﬁc can be found in DCN: (1) those associated with user tasks, e.g., web browsing or search queries, and, (2) those generated by virtual machine migration, data backup, or MapReduce operations. The ﬁrst category, referred to as short ﬂows, includes ﬂows generated by user tasks that have short duration and need to be transmitted before the socalled Flow Completion Time (FCT) , speciﬁed in the Service Level Agreement (SLA) with users. The second category of ﬂows, referred to as long ﬂows, are generated by applications with long duration and typically require an adequate throughput , i.e., higher than the minimum acceptable, however without stringent temporal constraints. Mixing these two types of ﬂows over the same network with their contradictory requirements for fast FCT and high throughput has already been identiﬁed as a challenge. Tradi tionally, Equal Cost Multi Path (ECMP) is used as default routing algorithm in data centers, where an individual ﬂow between a pair of servers is routed over one possible shortest path, which is selected calculating the hash value of the 5tuple header ﬁelds. With ECMP, two long ﬂows can end up being routed over the same path causing hotspots in the network, as illustrated in Fig. 1a. As a consequence, the throughput decreases and the path latency traversing the congested link increases, increasing the FCT. This in turn affects the userexperience when short ﬂows associated to user tasks are routed over congested paths. Previous work has proposed three general categories of solutions: (1) sacriﬁcing one of the two constraints to optimize the other, (2) increasing the complexity of trafﬁc engineering with priority scheduling, and (3) modify ing the current DCN architectures, e.g., modiﬁcations of TCP stack, using OpenFlow switches. In this paper, we present a new, hybrid category of solutions for mixed short and long ﬂows in data center networks called DiffFlow, capable of achieving the desired tradeoff between low latency (fast FCT) and high throughput. In our approach, we propose to use traditional ECMP for short ﬂows, minimiz ing the FCT with a negligible outoforder problem typically present in perpacket basis approaches, while for long ﬂows, we propose to use Random Packet Switching (RPS), capable of load balancing without affecting the path latencies of short ﬂows, as shown in Fig. 1b. Since long ﬂows typically constitute 8090% of total DCN trafﬁc, while 80% of all ﬂows are short, and smaller than 10KB in size [1], this means, that with our method, 80% of ﬂows are routed with ECMP by default, while the remaining 20% of ﬂows with a long duration use RPS. For our idea to work, we propose the use of packet sampling technique on OpenFlow switches to detect long ﬂows and the SDN controller to advertise about the presence of long ﬂows and apply RPS rules on the switches. We show analytically and with simulations, that the proposed method can effectively load balance the network, while keeping FCT and throughput within the predeﬁned ranges. The remainder of this paper is organized as follows. Section II presents related work. Section III presents the design of our hybrid method. In Section IV , the theoretical analysis is presented. In Section V , we discuss the performance evaluation, and ﬁnally in Section VI we present the conclusions. II. R ELATED WORK "
421,Formalising the Optimised Link State Routing Protocol.txt,"Routing protocol specifications are traditionally written in plain English.
Often this yields ambiguities, inaccuracies or even contradictions. Formal
methods techniques, such as process algebras, avoid these problems, thus
leading to more precise and verifiable descriptions of protocols. In this paper
we use the timed process algebra T-AWN for modelling the Optimised Link State
Routing protocol (OLSR) version 2.","Wireless Mesh Networks (WMNs) are a promising technology, having seen recent successes in the area of wireless communication. These multihop networks are designed to operate in a decentralised manner, with the responsibility of route discovery and packet forwarding being placed upon the nodes comprising a network. This necessitates the exchange of control messages in order to determine routes to available destinations. A subset of WMNs known as Mobile Ad hoc Networks (MANETs) have received considerable attention for their use in vehicular communication1, disaster relief and other emerging ﬁelds. Nodes in a MANET are distinguished by their high mobility when compared to other types of mesh networks. As a consequence of link breakages and ﬂuctuations in signal quality, routes through these networks are subject to frequent changes. To further complicate matters, MANETs often require restrictions on bandwidth and power consumption due to the limitations of physical devices. To address the challenges associated with ad hoc routing, a number of protocols speciﬁcally tailored to MANETs have been proposed in the literature. Of these protocols, recent research and development efforts by the Internet Engineering Task Force (IETF) have primarily targeted the Optimised Link State Routing protocol (OLSR) [9]. Originally speciﬁed in 2003, the protocol received numerous design mod iﬁcations over the next decade which culminated in OLSR version 2 (OLSRv2) [8]. Despite its status as an IETF proposed standard, analyses of OLSRv2 have thus far been limited to simulations and testbed experiments. These techniques, although instrumental to the development of MANET protocols, cannot guarantee certain desirable properties, or the absence of certain undesirable 1Here, MANETs are often called Vehicular Ad hoc Networks (V ANETs).R. Barry, R.J. van Glabbeek & P. H ¨ofner 41 properties, in a system. Given that MANETs are increasingly deployed in safetycritical applications, stronger correctness guarantees ought to be made about the protocol. Due to the ambiguous nature of natural languages, protocol speciﬁcations are often ﬁlled with am biguities and contradictions that give rise to conﬂicting interpretations. To avoid such issues, we model OLSRv2 in a formalism known as the Timed Algebra for Wireless Networks (TAWN) [6, 5]. TAWN, and its untimed fragment AWN [12], have been used previously to formalise the routing protocol AODV [20]—see [15, 5]. This turned out to be a solid basis for analysing the protocol by means of model checking [11]. Additionally, based on this formalisation, crucial correctness properties of the protocol, including loop freedom, route correctness and route discovery, have been proven [15, 4, 5] or disproven [16, 13, 5], manually and with the support of interactive proof assistants. We expect the present formalisation of OLSRv2 to be equally useful for establishing correctness properties. 2 The Optimised Link State Routing Protocol The Optimised Link State Routing protocol version 2 (OLSRv2) [8] is a linkstate protocol tailored speciﬁcally to MANETs. In contrast to its 2003 counterpart, OLSRv1 [9], OLSRv2’s offering of im proved security, ﬂexibility and scalability has solidiﬁed its status as the sole IETF “proposed standard” among MANET routing protocols. Before describing the protocol’s operation, we clarify some basic terminology. Symmetric path: A sequence of nodes in a graph ip0:::ipnis a symmetric path iff for each pair of nodes (ipi;ipi+1)there exists an edge from ipitoipi+1and viceversa. Symmetric nhop neighbour: A node ipis a symmetric nhop neighbour of another node ip0iffip6=ip0 and there exists a symmetric path of exactly nedges between ipandip0. (So, a symmetric nhop neighbour is also a symmetric n+2hop neighbour.) OLSRv2 is based on traditional linkstate routing, and so inherits its basic characteristics. Each node maintains a graph representing the network topology, with each edge representing a pair of symmetric 1hop neighbours. Optimal routes to all reachable destinations are then determined by applying some shortest path algorithm to this graph. Rather than waiting for data packets to arrive, the topology graph is proactively assembled by exchanging linkstate information with neighbouring routers in the network, through broadcasts. These advertisements are scheduled periodically by each node using local timers. Motivated by the strict limits on power and bandwidth consumption in MANETs, the designers of OLSR pioneered a number of optimisations to control trafﬁc generation. The most signiﬁcant optimisa tions come in the form of ﬂooding reduction, where the number of broadcasts is reduced, and topology reduction, where the number of advertised links is minimised. Each router designates a subset of its sym metric 1hop neighbours with one or both of these tasks in a process known as multipoint relay (MPR) selection. MPR: A router (node) ipis an MPR of another router ip0iffiphas been designated the task of ﬂooding reduction or topology reduction on behalf of ip0. MPR selector: A router ip0is an MPR selector of another router ipiffipis an MPR of ip0. Routers in OLSRv2 maintain two sets of MPRs for ﬂooding reduction and topology reduction, re spectively. Flooding MPRs are responsible for forwarding link advertisements received from their ﬂood ing MPR selectors. To ensure that all routers receive link advertisements, each router must guarantee that all of its symmetric 2hop neighbours are symmetric 1hop neighbours of a ﬂooding MPR, or sym metric 1hop neighbours themselves. Figure 1 demonstrates this ﬂooding reduction in practice. Just42 Formalising OLSR A B C D E F G H IA B C D E F G H I a) Flooding reduction with an optimal MPR set b) Flooding without the use of MPRs Figure 1: Flooding reduction three broadcasts are needed to disseminate E’s link advertisements when using optimal ﬂooding MPR sets, whereas all nine nodes must perform a broadcast when ﬂooding reduction is disabled. By contrast, routing MPRs are responsible for advertising links between themselves and their routing MPR selectors. Routing MPRs are chosen such that all symmetric 2hop neighbours are accessible via a routing MPR in a minimal distance 1hop or 2hop route. In theory, the links advertised by routing MPRs are sufﬁcient for all routers to construct shortest paths through the network. Before links between routers can be advertised, each router must identify all of its symmetric 1hop and 2hop neighbours. The Neighbourhood Discovery Protocol (NHDP) formalised in RFC 6130 [7] is incorporated into and extended by OLSRv2 for this purpose. At a speciﬁc interval, a router will broadcast a HELLO message containing the addresses and statuses of its 1hop neighbours. On the receiving end, the sending router is assigned a status of either symmetric, indicating a bidirectional link, or heard, indicating a unidirectional link. This status is determined by the receiver’s inclusion in the HELLO message. Once symmetric links between routers are established, symmetric 2hop neighbours can be inferred from the contents of current and future HELLO messages. All HELLO messages contain a validity time which determines when this information must be discarded, so care should be taken to avoid premature timeouts while links still exist. A simpliﬁed HELLO message exchange is detailed in Figure 2. OLSRv2 extends NHDP with the inclusion of link metrics and MPR sets in its HELLO messages. Link metrics are assessed at the receiving end, and must therefore be propagated backwards to the send ing router. Meanwhile, the ﬂooding and routing MPR sets included in these messages indicate to the receiving routers whether or not they should engage in link advertisement on behalf of the sender. After a node has identiﬁed its routing MPR selectors, it advertises all links between itself and these routers. The dissemination of this linkstate information, when used in tandem with links discovered by NHDP, allows routers to establish shortest paths to all reachable destinations. The messages used to prop agate advertised links are referred to as Topology Control (TC) messages. These messages are generated periodically and ﬂooded through the network so that all reachable destinations may receive them. TC messages contain a set of links to advertised routers, in addition to an advertising neighbour se quence number indicating how recent the message is. Unlike HELLO messages, which are processed but never forwarded, TC messages are ﬂooded through the network by the ﬂooding MPRs of each broad casting router. When a router receives a TC message, it updates its topology graph with the advertised links provided that the advertising neighbour sequence number included in the message does not indicate outofdate information. The message is then forwarded if it was received from a ﬂooding MPR selector and was not forwarded in the past. Like HELLO messages, TC messages are prone to expiration if not received frequently.R. Barry, R.J. van Glabbeek & P. H ¨ofner 43 Afg fgBfg fgCfg fgAfg fgBf(A,!)g fgCfg fgf g a) The initial state of the network. Top sets contain tuples of 1hop neighbours. Bottom sets contain tuples of symmetric 2hop neighbours.b) A sends the ﬁrst HELLO message, advertising its presence. B creates a heard tuple for A since A has not yet heard from B. Af(B,$)g fgBf(A,!)g fgCf(B,!)g fgf(A,!)g f(A,!)g Af(B,$)g fgBf(A,!),(C,$)g fgCf(B,!)g fgf(B,!)g c) B sends a HELLO message. A creates a symmetric tuple for B since B has already heard from A. C creates a heard tuple for B.d) C sends a HELLO message. B creates a symmetric tuple for C. Af(B,$)g fgBf(A,$),(C,$)g fgCf(B,!)g fgf(B,$)g Af(B,$)g f(C, B)gBf(A,$),(C,$)g fgCf(B,$)g f(A, B)gf(A,$),(C,$)g f(A,$),(C,$)g e) After a certain amount of time has passed, A sends its second HELLO message. B creates a symmetric tuple for A.f) B sends its second HELLO message. C creates a symmetric tuple for B. Since they are both accessible via B, A and C create 2hop tuples for each other. Neighbourhood discovery completes. Figure 2: A simple Hello message exchange 3 The Speciﬁcation Language TA WN One of the standard tools for describing interactions, communications and synchronisations between a collection of agents, processes or network nodes is provided by process algebras. Process algebras are a family of approaches to modelling concurrent systems, as well as formally analysing said systems through algebraic laws. We choose to model OLSRv2 using TAWN [6, 5], a timed process algebra designed for wireless networks in general and routing protocols in particular. The reason for choosing TAWN is twofold: on the one hand, it is tailored to wireless protocols and therefore offers primitives such as broadcast ; on the other hand, it deﬁnes the protocol in pseudocode that is easily readable by any network or software researcher/engineer. The language itself is implemen tation independent. The timed process algebra TAWN is based on the (untimed) process algebra AWN (Algebra of Wire less Networks) [12, 13]. (T)AWN’s key operators are conditional unicast —allowing error handling in response to failed communications while abstracting from link layer implementations of the communica tion handling—and local broadcast —allowing a node to send messages to all its immediate neighbours as implemented by the physical and data link layer, i.e. to all neighbours within transmission range. Every process algebra such as (T)AWN is equipped with an operational semantics [12, 6]: once a model has been given, its (timed) behaviour is governed by the transitions allowed by the algebra’s semantics. In this paper we abstain from a formal deﬁnition of the operational semantics. Instead, we employ a correspondence between the transitions of (T)AWN processes and the execution of actions — subexpressions as occur in Entries 3–10 of Table 1—identiﬁed by line numbers in protocol speciﬁcations in (T)AWN. We use an underlying data structure (sketched in Section 4 and described in detail in Section A.1)44 Formalising OLSR Table 1: process expressions [15] X(exp1;:::; expn) process name with arguments P+Q choice between processes PandQ [j]P conditional process (ifstatement) [ [var:=exp] ]P assignment followed by process P broadcast (ms):P broadcast of message msfollowed by P groupcast (dests ;ms):P iterative unicast or multicast to all destinations dests unicast (dest;ms):PIQunicast mstodest; if successful proceed with P; otherwise with Q send(ms):P synchronously transmit msto parallel process on same node deliver (data):P deliver data to application layer receive (msg):P receive a message x;P process with valuation PhhQ parallel processes on the same node a:P:R node arunning process Pwith range R NkM parallel composition of nodes [N] encapsulation with several types, variables ranging over these types, operators and predicates. First order predicate logic yields terms (or data expressions ) and formulas to denote data values and statements about them. The (T)AWN data structure must contain the types DATA ,MSG,IPandP(IP)ofapplication data , messages ,IP addresses —or any other node identiﬁers—and sets of IP addresses , respectively; in the case of TAWN, the data structure also features the type TIME of time values. The rest of the data structure is customisable for any application of (T)AWN. In the process algebra at hand an entire network is modelled as an encapsulated parallel composition of network nodes; several processes can be executed on the same node. Nodes can only communicate with their direct neighbours, i.e. with nodes that are currently within transmission range. There are three different ways for nodes to perform internode communication: broadcast, unicast, or an iterative unicast/multicast (called groupcast in (T)AWN). Theprocess expressions are given in Table 1. A process name Xcomes with a deﬁning equation X(var 1;:::;var n)def=P; where Pis a process expression, and the var iare data variables maintained by process X. Furthermore, jis a condition, var:=expan assignment of a data expression expto a variable varof the same type, dest,dests ,data andmsdata expressions of types IP,P(IP),DATA andMSG, respectively, and msg a data variable of type MSG. Given a valuation of the data variables by concrete data values, the process [j]Pacts as Pifj evaluates to true , and deadlocks if jevaluates to false .2In case jcontains free variables that are not yet interpreted as data values, values are assigned to these variables in any way that satisﬁes j, if possible. The process [ [var:=exp] ]Pacts as P, but under an updated valuation of the data variables. The process P+Qacts either as Por as Q, depending on which of the two processes is able to act at all. In case both are able to act, the choice is nondeterministic. The process broadcast (ms):Pbroadcasts (the data value bound to the expression) msto all nodes within transmission range, and subsequently acts as P, whereas the process unicast (dest;ms):PIQtries to unicast the message msto the destination dest; if 2As operators we also allow partial functions with the convention that any atomic formula containing an undeﬁned subterm evaluates to false .R. Barry, R.J. van Glabbeek & P. H ¨ofner 45 successful it continues to act as Pand otherwise as Q. The unicast is unsuccessful if the destination dest is out of transmission range of the node ipperforming the unicast. The latter models an abstraction of an acknowledgmentofreceipt mechanism that is typical for unicast communication but absent in broadcast communication, as implemented by the link layer of wireless standards such as IEEE 802.11 [17]. The process groupcast (dests ;ms):Ptries to transmit msto all destinations dests , and proceeds as Pregardless of whether any of the transmissions is successful. The process send(ms):Psynchronously transmits a message to another process running on the same network node; this action can occur only when the other process is ready to receive the message. The process receive (msg):Preceives a message m(of type MSG); the value mis then bound to the variable msgand the process proceeds as P. The received message stems either from another node, from another process running on the same node or from the application layer process on the local node. The latter is used to model the injection of data to the network, using the process receive (newpkt (data;dip)), where the function newpkt generates a message containing the application layer data and the intended destination address dip. Data is delivered back to the application layer by deliver (data). A state of a network node is modelled as a valuated process given as a pair (x;P)of a process expression Pbuilt from the above syntax, together with a (partial) valuation function xthat speciﬁes values of the data variables maintained by P. Finally, PhhQdenotes a parallel composition of processes PandQ, with information piped from right to left; in our application Qwill be a message queue. In the full process algebras AWN [12] and TAWN [6], node expressions a :P:Rare given by process expressions P, annotated with an address a and a set of nodes Rthat are within transmission range ofa. A partial network is then modelled as a parallel composition of node expressions, using the operator k, and a complete network is obtained by placing this composition in the scope of an encapsulation operator []. The main purpose of the encapsulation operator is to prevent the receipt of messages that have never been sent by other nodes in the network—with the exception of messages newpkt (data;dip)stemming from the application layer of a node. When designing or formalising a protocol in (T)AWN, an engineer should not be bothered with timing aspects, except for functions and procedures that schedule tasks depending on the current time. Because of this, the only difference between the syntax of AWN and the one of TAWN is that the latter is equipped with a local timer now, which is of type TIME . TAWN assumes a discrete model of time, where each sequential process maintains the local variable nowholding its local clock value—an integer. Only one clock for each sequential process is employed. All (sequential) processes in a network synchronise in taking time steps, and at each time step all local clocks are incremented by one time unit. For the rest, the variable now behaves as any other variable maintained by a process: its value can be read when evaluating guards, thereby making progress time dependent, and any value can be assigned to it, thereby resetting the local clock. Before describing our TAWNspeciﬁcation of OLSRv2, we want to point out two fundamental as sumptions of TAWN. (i) The underlying formal semantics of (T)AWN is that any broadcast message isreceived by all nodes within transmission range. This abstraction allows us to interpret a failure of route discovery of a protocol (or any other property) as an imperfection in the protocol, rather than as a result of a chosen formalism not ensuring guaranteed receipt. The same holds for groupcast and unicast messages in case the destinations are within range. (ii) Only internode communication, i.e. transferring a message from one node in the network to another, takes time. This is justiﬁed as in wireless networks sending a packet takes multiple microseconds; compared to these “slow” actions, time spent for internal (intranode) computations, such as variable assignments, is negligible.46 Formalising OLSR 4 Modelling OLSRv2 in TA WN In this section, we present parts of our TAWN model of OLSRv2. The model itself consists of ﬁve main processes implementing the OLSRv2 speciﬁcation and a queue process to receive packets from other routers: The process OLSR constitutes the main protocol loop. It is responsible for receiving packets from the input queue and processing these packets according to their type. It it also responsible for periodically generating new HELLO and TC messages. TheUPDATE INFO process ensures that the protocol’s information bases remain consistent with cer tain constraints. ThePROCESS HELLO andPROCESS TCprocesses are responsible for recording information obtained through HELLO messages and TC messages in the relevant information bases. TheFORWARD TCprocess forwards TC messages received from the router’s ﬂooding MPR selectors, subject to a few side conditions. TheQUEUE process receives packets from other routers in the network and delivers them to the OLSR process. Due to a lack of space we only present the process OLSR , including the necessary data structure; the full speciﬁcation of OLSRv2, including the full data structure and a detailed description can be found in Appendix A. 4.1 Data Structure We now describe the data structure needed and functions used in modelling the process OLSR . In the remainder, we use the notation x1::nas shorthand for the tuple (x1,x2,...,x n). We take the type TIME isomorphic to Z Z[f¥;"
340,Source-specific routing.txt,"Source-specific routing (not to be confused with source routing) is a routing
technique where routing decisions depend on both the source and the destination
address of a packet. Source-specific routing solves some difficult problems
related to multihoming, notably in edge networks, and is therefore a useful
addition to the multihoming toolbox. In this paper, we describe the semantics
of source-specific packet forwarding, and describe the design and
implementation of a source-specific extension to the Babel routing protocol as
well as its implementation - to our knowledge, the first complete
implementation of a source-specific dynamic routing protocol, including a
disambiguation algorithm that makes our implementation work over widely
available networking APIs. We further discuss interoperability between ordinary
next-hop and source-specific dynamic routing protocols. Our implementation has
seen a moderate amount of deployment, notably as a testbed for the IETF Homenet
working group.","The routing paradigm deployed on the Internet is nexthop routing. In nexthop routing, perpacket forwarding decisions are performed by examining a packet’s destination address only, and mapping it to a nexthop router. Nexthop routing is a simple, well understood paradigm that works satisfactorily in a large number of cases. The use of nexthop routing restricts the ﬂexibility of the routing system in two ways. First, since a router only controls the next hop, a route ABCZcan only be selected by the router Aif its sufﬁx BCZhas already been selected by a neighbouring router B, which makes some forms of optimisation difﬁcult or impossible. Other routing paradigms, such as circuit switching, label switching and source routing, do not have this limitation. (Source routing, in particular, has been proposed multiple times as a suitable routing paradigm for the Internet [11], but has been discouraged due to claimed security reasons [1]). Second, the only decision criterion used by a router is the destination address: two packets with the same destination are always routed in the same manner. Yet, there are other data in the IP header that can reasonably be used for making a routing decision — the TOS octet, the IPv6 ﬂowid, and, of course, the source address. We call sourcespeciﬁc routing the modest extension of classical nexthop routing where the forwarding decision is allowed to take into account the source of a packet in addition to its destination. Sourcespeciﬁc routing gives a modest amount of control over routing to the sending host, which can choose among different routes by picking different source addresses. The higher layers (transport or application) are therefore able to choose a route using standard networkingAPIs (collecting the host’s local addresses and binding a socket to a speciﬁc address). Unlike source routing, however, source speciﬁc routing remains a hopbyhop mechanism, and there fore leaves local forwarding decisions ﬁrmly in the control of the routers. Two things are needed in order to make sourcespeciﬁc rout ing practical: a forwarding mechanism that can discriminate on both source and destination addresses, and a dynamic routing protocol that is able to distribute sourcespeciﬁc routes. In this paper, we describe our experiences with the design and implementation of a sourcespeciﬁc extension to the Babel routing protocol [6], including a disambiguation algorithm that allows implementing sourcespeciﬁc routing over existing forwarding mechanisms. II. A PPLICATIONS The main application of sourcespeciﬁc routing is the im plementation of multihoming . A. Classical multihoming A multihomed network is one that is connected to the Internet through two or more physical links. This is usually done in order to improve a network’s fault tolerance, but can also be done in order to improve throughput or reduce cost. Classically, multihoming is performed by assigning Pro viderIndependent addresses to the multihomed network and announcing them globally (in the DefaultFree Zone (DFZ)) over the routing protocol. The dynamic nature of the routing protocol automatically provides for faulttolerance; improve ments in throughput and reductions in cost can be achieved by careful engineering of the routing protocol. While classical multihoming works reasonably well in the network core, it does not apply to the edge. In order to perform classical multihoming, a network needs to be allocated a “ProviderIndependent” preﬁx that is reannounced by some or all of a network’s peers. This setup is usually impossible to achieve for home and small business networks. Note that it is not in general possible to implement classical multihoming using a single “ProviderDependent” preﬁx. If a network is connected to two providers AandB, a packet with a source address in an address range allocated to Awill usually not be accepted by B, which will treat it as a packet with a spoofed source address and discard it [8]. What is more, A’s preﬁx will not be reannounced by B, and hence destinations inA’s preﬁx will not be reachable over the link to B. There is some concern that classical multihoming, even when restricted to the large networks of the core, is causingarXiv:1403.0445v4  [cs.NI]  30 Mar 2015uncontrolled growth of the “defaultfree routing table”. Since we have only experimented with sourcespeciﬁc routing in edge networks, we hold no opinion on the usefulness of our techniques in the network core, and in particular on the desirability of adding it to the BGP external routing protocol. B. Multihoming with multiple source addresses Since announcing the same ProviderDependent (PD) preﬁx to multiple ISPs is not always possible, it is a natural propo sition to announce multiple PD preﬁxes, one per provider. In this approach, every host is assigned multiple addresses, one per provider, and extra mechanisms are needed (i) to choose a suitable source and destination address for each packet, and (ii) to properly route each outgoing packet according to both its source and its destination. In a sense, using multiple addresses splits the difﬁcult problem of multihoming into two simpler problems that are handled at different layers of the network stack. 1) Choosing addresses: The choice of source and desti nation addresses is typically left to the application layer. All destination addresses are stored within the DNS (or explicitly carried by the application protocol), and the sending host tries them all, either in turn [7] or in parallel [12]; similarly, all possible source addresses are tried in turn. Once a ﬂow is established, it is no longer possible to change the source and destination addresses — from the user’s point of view, all TCP connections are broken whenever a link outage forces a change of address. Address selection can be implemented in the operating system’s kernel and libraries, or by the application itself, which is notably done by most modern web browsers. A different approach is to use a transport layer that has builtin support for multiple addresses and for dynamically renegotiating the set of source and destination addresses. One such transport layer is MPTCP [10]; we describe our experience with MPTCP in Section VIIB. 2) Sourcespeciﬁc routing: As mentioned above, a provider will discard packets with a source address that is in a different provider’s preﬁx. In a network that is connected to multiple providers, each outgoing packet must therefore be routed through the link corresponding to its source address. When the outgoing links are all connected to a single router, it is feasible to set up trafﬁc engineering rules to ensure that this happens. There can be good reasons, however, why it is desirable to connect each provider to a different router (Figure 1): avoiding a single point of failure, load balancing, or simply that the various links use different link technologies that are not available in a single piece of hardware. In a home networking environment, the edge routers might be provided by the different service providers, with no possibility to consolidate their functionality in a single device. With multiple edge routers, it is necessary that the routing protocol itself be able to route according to source addresses. We say that a routing protocol performs sourcespeciﬁc routing when it is able to take both source and destination addresses into account in its routing decisions.ISP 1 ISP 2 Fig. 1. A network connected to two providers C. Other applications In addition to multihoming with multiple addresses, we are aware of two problematic networking problems that source speciﬁc routing solves cleanly and elegantly. 1) Overlay networks: Tunnels and VPNs are commonly used to establish a networklayer topology that is different from the physical topology, notably for security reasons. In many tunnel or VPN deployments, the end network uses its native default route, and only routes some set of preﬁxes through the tunnel or VPN. In some deployments, however, the default route points at the tunnel. If this is done naively, the network stack attempts to route the encapsulated packets through the tunnel itself, which causes the tunnel to break. Many workarounds are possible, the simplest being to point a host route towards the tunnel endpoint through the native interface. Sourcespeciﬁc routing provides a clean solution to that problem. The native default route is kept unchanged, while a sourcespeciﬁc default route is installed through the tunnel. The sourcespeciﬁc route being more speciﬁc than the native default route, packets from the user network are routed through the tunnel, while the encapsulated packets sourced at the edge router follow the native, nonspeciﬁc route. 2) Controlled anycast: Anycast is a technique by which a single destination address is used to represent multiple network endpoints. A packet destined to an anycast address is routed to whichever endpoint is nearest to the source according to the routing protocol’s metric. Anycast is useful for load balancing — for example, the DNS root servers are each multiple physical servers, represented by a single anycast address. For most applications of anycast, all of the endpoints are equivalent and it does not matter which endpoint is accessed by a given client. Some applications, however, require that a given user population access a welldeﬁned endpoint — for example, in a Content Distribution Network (CDN), a provider might not want to serve nodes that are not its customers. Ensuring that this is the case by tweaking the routing protocol’s metric (or “prepending” in BGP parlance) is fragile and errorprone. Sourcespeciﬁc routing provides an elegant solution to this problem. With sourcespeciﬁc routing, each instance of the distributed server is announced using a sourcespeciﬁc route, and will therefore only receive packets from a given network preﬁx. III. R ELATED WORK "
78,Privacy-Preserving Shortest Path Computation.txt,"Navigation is one of the most popular cloud computing services. But in
virtually all cloud-based navigation systems, the client must reveal her
location and destination to the cloud service provider in order to learn the
fastest route. In this work, we present a cryptographic protocol for navigation
on city streets that provides privacy for both the client's location and the
service provider's routing data. Our key ingredient is a novel method for
compressing the next-hop routing matrices in networks such as city street maps.
Applying our compression method to the map of Los Angeles, for example, we
achieve over tenfold reduction in the representation size. In conjunction with
other cryptographic techniques, this compressed representation results in an
efficient protocol suitable for fully-private real-time navigation on city
streets. We demonstrate the practicality of our protocol by benchmarking it on
real street map data for major cities such as San Francisco and Washington,
D.C.","Location privacy is a major concern among smartphone users, and there have been numerous controversies due to companies tracking users' locations [AVD11, Che11]. Among the various applications that require location information, navigation is one of the most popular. For example, companies such as Google, Apple, and Waze have built tracaware navigation apps to provide users with the most uptodate routing information. But to use these services, users must reveal their location and destination to the cloud service provider. In doing so, they may also reveal other sensitive information about their personal lives, such as their health condition, their social and political aliations, and more. One way to provide location privacy is for the user to download the entire map from the cloud service provider and then compute the best route locally on her own mobile device. Unfortunately, since service providers invest signicant resources to maintain uptodate routing information, they are not incentivized to publish their entire routing database in realtime. Even in the case of a paid premium service, in which the service provider does not derive compensation from learning the user's location data, it is not obvious how to achieve fullyprivate navigation. The user does not trust the cloud provider with her location data, and the cloud provider does not trust the user with its uptodate routing information, so neither party has This is the extended version of a paper by the same name that appeared at the Network and Distributed System Security Symposium (NDSS) in February, 2016. Permission to freely reproduce all or part of this paper for noncommercial purposes is granted provided that copies bear this notice and the full citation on the rst page. Reproduction for commercial purposes is strictly prohibited without the prior written consent of the Internet Society, the rstnamed author (for reproduction of an entire paper only), and the author's employer if the paper was prepared within the scope of employment. NDSS '16, 2124 February 2016, San Diego, CA, USA Copyright 2016 Internet Society, ISBN 189156241X http://dx.doi.org/10.14722/ndss.2016.23052 1arXiv:1601.02281v1  [cs.CR]  10 Jan 2016all of the data to perform the computation. While generalpurpose cryptographic tools such as multiparty computation solve this problem in theory (see Section 7), these protocols are prohibitively expensive in practice for applications such as realtime navigation. Our results. In this work, we present an ecient cryptographic protocol for fullyprivate navigation: the user keeps private her location and destination, and the service provider keeps private its proprietary routing information (except for the routing information associated with the specic path requested by the user and a few generic parameters pertaining to the network). We give a complete implementation of our protocol and benchmark its performance on real street map data (Section 5.3). Since our protocol is realtime (the user continues receiving directions throughout the route), we benchmark the performance \per hop"", where each hop roughly corresponds to an intersection between streets.1For cities such as San Francisco and Washington, D.C., each hop in our protocol requires about 1.5 seconds and less than 100 KB of bandwidth. In addition, before the protocol begins, we execute a preprocessing step that requires bandwidth in the tens of megabytes. Since this preprocessing step can be performed at any time, in practice it would likely be run via a fast WiFi connection, before the mobile user needs the realtime navigation service, and thus the additional cost is very modest. To our knowledge, ours is the rst fullyprivate navigation protocol ecient enough to be feasible in practice. Our technical contributions. In our work, we model streetmap networks as graphs, in which the nodes correspond to street intersections, and edges correspond to streets. In our model, we assume that the network topology is public (i.e., in the case of navigation on city streets, the layout of the streets is publicly known). However, only the service provider knows the uptodate trac conditions, and thus the shortest path information. In this case, the server's \routing information"" consists of the weights (that is, travel times) on the edges in the network. By modeling streetmaps as graphs, we can easily construct a strawman private navigation protocol based on symmetric private information retrieval (SPIR) [GIKM00, KO97, NP05]. Given a graph Gwith nnodes, the server rst constructs a database with n2records, each indexed by a sourcedestination pair (s;t). The record indexed ( s;t) contains the shortest path from stot. To learn the shortest path from stot, the client engages in SPIR with the server for the record indexed ( s;t). Security of SPIR implies that the client just learns the shortest path and the server learns nothing. While this method satises the basic security requirements, its complexity scales quadratically in the number of nodes in the graph. Due to the computational cost of SPIR, this solution quickly becomes infeasible in the size of the graph. Instead, we propose a novel method to compress the routing information in streetmap networks. Specically, given a graph Gwithnnodes, we dene the nexthop routing matrix M2ZnnforGto be the matrix where each entry Mstgives the index of the rst node on the shortest path from node s to nodet. To apply our compression method, we rst preprocess the graph (Section 3) such that each entry in the nexthop routing matrix Mcan be specied by two bits: Mst= (M(ne) st; M(nw) st) where M(ne);M(nw)2f"
194,Performance Comparisons of Routing Protocols in Mobile Ad Hoc Networks.txt,"Mobile Ad hoc Network (MANET) is a collection of wireless mobile nodes that
dynamically form a network temporarily without any support of central
administration. Moreover, Every node in MANET moves arbitrarily making the
multi-hop network topology to change randomly at unpredictable times. There are
several familiar routing protocols like DSDV, AODV, DSR, etc...which have been
proposed for providing communication among all the nodes in the network. This
paper presents a performance comparison of proactive and reactive protocols
DSDV, AODV and DSR based on metrics such as throughput, packet delivery ratio
and average end-to-end delay by using the NS-2 simulator.","A mobile ad hoc network is a collection of wireless  mobile nodes that dynamically establishes  the network in the absence of fixed infrastructure [1]. One of the distinctive features of MANET  is, each node must be able to act as a router to fi nd out the optimal path to forward a packet. As  nodes may be mobile, entering and leaving the netwo rk, the topology of the network will  change continuously. MANETs provide an emerging tec hnology for civilian and military  applications. Since the medium of the communication  is wireless, only limited bandwidth is  available. Another important constraint is energy d ue to the mobility of the nodes in nature.    One of the important research areas in MANET is est ablishing and maintaining the ad hoc  network through the use of routing protocols. Thoug h there are so many routing protocols  available, this paper considers DSDV, AODV and DSR for performance comparisons due to its  familiarity among all other protocols. These protoc ols are analyzed based on the important  metrics such as throughput, packet delivery ratio a nd average endtoend delay and is presented  with the simulation results obtained by NS2 simula tor.    In particular, Section 2 presents the related works  with a focus on the evaluation of the routing  protocols. Section 3 briefly discusses the MANET ro uting protocols classification and the  functionality of the three familiar routing protoco ls DSDV, AODV and DSR. The simulation  results and performance comparison of the three abo ve said routing protocols are discussed in  Section 4. Finally, Section 5 concludes with the co mparisons of the overall performance of the  three protocols DSDV, AODV and DSR based on the thr oughput, packet delivery ratio and  average endtoend delay metrics.         International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 3, No. 1, February 2011   99   2.  RELATED WORK   "
418,Optimized Graph Based Routing Algorithm for the Angara Interconnect.txt,"JSC NICEVT has developed the Angara high-speed interconnect with 4D torus
topology. The Angara interconnect router implements deterministic routing based
on the bubble flow control, a direction order routing (DOR) and direction bits
rules. The router chip also supports non standard First Step / Last Step for
bypassing failed nodes and links, these steps can violate the DOR rule. In the
previous work we have proposed an algorithm for generation and analysis of
routing tables that guarantees no deadlocks in the Angara interconnect. It is
based on a breadth-first search algorithm in a graph and it practically does
not take into consideration communication channel load. Also we have never
evaluated the influence of routing table generation algorithm on the
performance of a real-world Angara based cluster. In this paper we present a
routing graph notation that provides a possibility to build routes in the torus
topology of the Angara interconnect. We propose a deadlock-free routing
algorithm based on a fast single-source shortest path algorithm for the
deterministic Angara routing with a single virtual channel. We evaluated the
considered routing algorithms on a 32-node Desmos cluster system and
benchmarked the proposed algorithm performance improvement of 11.1% for the
Alltoall communication pattern and of more than 5% for the FT and IS
application kernels.","High performance computing (HPC) systems are costly hardware and optimization of application performance is a very challenging problem. The critical component of HPC system is an interconnect that properties stand behind the scalability of any MPI based parallel algorithm. The inter connect is largely controlled by routing algorithms which determine how to move packets through an interconnect topology. We consider the Angara interconnect [1] that was devel oped at JSC NICEVT in Russia. Angara is the lowlatency, high bandwidth interconnect with 4D torus topology, the minimum obtained MPIlatency between 2 adjacent nodes is 850 ns. The AngaraC1 [2] and Desmos [3] cluster systems are based on the Angara interconnect. Many authors have obtained results with use of the Angara interconnect [4], [5],[6], [7], [8], [9]. Now the maximum node number of Angara based high performance computing systems is 96 nodes. Deterministic routing in the Angara interconnect is based on the direction order routing (DOR) [10], [11] imple mented using direction bits [11] and additional First and Last Steps [11] for bypassing failed nodes and links. Implemen tation of the First and Last Steps method allows to violate the DOR rule. In the previous work [12] we have proposed an algorithm for generation and analysis of routing tables that guarantees no deadlocks in the Angara interconnect. The proposed algorithm increases the number of different routable systems and improves fault tolerance, the algorithm is based on a breadthﬁrst search algorithm in a graph and practically does not take into consideration a communication channel load. Also we have never evaluated the inﬂuence of a routing table generation algorithm on the performance of a realworld Angara based cluster. In this work we focus on development of an advanced routing table generation algorithm and on the routing algo rithm evaluation on the Desmos Angara based cluster. 1.1. Related Work "
71,Distributed SDN-based Load-balanced Routing for Low Earth Orbit Satellite Constellation Networks.txt,"With the current trend towards low Earth orbit mega-constellations with
inter-satellite links, efficient routing in such highly dynamic space-borne
networks is becoming increasingly important. Due to the distinct network
topology, specifically tailored solutions are required. Firstly, the relative
movement of the constellation causes frequent handover events between the
satellites and the terminals on ground. Furthermore, unevenly distributed
traffic demands lead to geographical hot spots. The physical size of the
network also implies significant propagation delays. Therefore, monitoring the
dynamic topology changes and link loads on a network-wide basis for routing
purposes is typically impractical with massive signaling overhead. To address
these issues, we propose a distributed load-balanced routing scheme based on
Software Defined Networking. The approach divides the large-scale network into
sub-sections, called clusters. In order to minimize signaling overhead, packets
are forwarded between these clusters according to geographical heuristics.
Within each cluster active Quality of Service-aware load-balancing is applied.
The responsible on-board network controller forwards routing instructions based
on the network state information in its cluster. We also analyze specific
design choices for the clusters and the interfaces between them. The protocol
has been implemented in a system-level simulator and compared to a
source-routed benchmark solution.","In recent years, there has been increased interest into non terrestrial networks capable of providing global broadband access. Large Low Earth Orbit (LEO) Satellite Constellation Networks (SCNs) in particular are gaining more attention, most notably because of their proximity to Earth, which results in reduced propagation delays in comparison to Geo stationary Orbit (GEO) satellites. Prominent examples for such constellations using circular orbits include OneWeb, and Starlink by SpaceX, among others [1]. Moreover, current initiatives for future telecommunication standards, such as 5G [2], consider the integration of such Low Earth Orbit (LEO) Satellite Constellation Networks (SCNs). In order to reduce the required number of Gateway stations (GWs) on ground, most designs consider Intersatellite Links (ISLs). In this work, we assume that broadband multimedia voice and data trafﬁc, all based upon IP, will be routed via a single layer SCN. This work has been supported by the Advanced Research in Telecommu nications Systems Programme of the European Space Agency (ESA), activity code 3A.117. Responsibility for the contents of this publication rests with the authors.The connectivity for private end users is provided via an IP interface attached to a User Terminal (UT) on ground. GWs act as interfaces to the terrestrial Internet. The considered SCN needs to provide bidirectional connectivity at IP layer. Internally, the SCN may use other protocols (e.g. on layer 2) for routing and switching. The SCN network topology differs from terrestrial networks in multiple aspects. Firstly, the network topology is highly dynamic, but deterministic. The connectivity between satellites changes depending on the constellation design pattern. These changes in the ISL connectivity are typically predictable. In addition, there are frequent handover events with the terminals on the ground. Due to the movement speed of the satellites rel ative to the Earth in LEO, their visibility is limited. Therefore, a terminal on ground has to establish a connection to a new satellite in order to maintain its connection to the SCN. It is only possible to predict to which satellite a new EarthSatellite Links (ESLs) is established, if a stringent handover strategy is used. However, we intend to include handover schemes which also consider the current load on the satellites in the future. Thus, we assume that these ESL handovers are not fully predictable. In general, the location of UTs on ground depends on geo graphical and demographic factors. Therefore, resulting trafﬁc is nonuniformly distributed. Trafﬁc hotspots are geographical rather than topological, due to the relative movement of the space segment. As we consider large constellations, commu nicating current link states to all relevant nodes is very costly in terms of signaling overhead. Due to the physical size of the network, the signaling also experiences signiﬁcant propagation delays. In addition, processing resources onboard the satellites are scarce. Thus, LEO SCNs with ISLs need specialized routing and network management protocols to make the best use of the available network resources. While the topological changes of the constellations are highly predictable, the trafﬁc demands are not. Therefore, we focus on routing protocols with loadbalancing capabilities. Based on these considerations and related research we propose a distributed routing scheme which proactively bal ances the network load. The approach utilizes distributed on board Software Deﬁned Networking (SDN) controllers, which enable loadbalanced routing and network management within their respective clusters. The routing between clusters follows geographic heuristics in order to minimize signaling overhead.arXiv:2209.05984v1  [cs.NI]  13 Sep 2022The main contributions of this paper include: A distributed loadbalancing routing scheme based on SDN is proposed. It was designed to reduce signaling overhead, while providing locally centralized congestion control and low endtoend latency. Relevant speciﬁc design choices for a realistic system setup for polar LEO SCNs are discussed. The proposed scheme is implemented in a systemlevel simulator and compared to a sourcebased routing proto col. The speciﬁc advantages of the proposed protocol are illustrated. The rest of the paper is organized as follows. In Section II, we shortly cover related works. Then, in Section III the con sidered reference system is presented. The proposed routing protocol is described in detail in Section IV. In Section V, we provide simulation results and comparisons to benchmark solutions. Lastly, Section VI concludes the paper. II. R ELATED WORKS "
294,T-ROME: A Simple and Energy Efficient Tree Routing Protocol for Low-Power Wake-up Receivers.txt,"Wireless sensor networks are deployed in many monitoring applications but
still suffer from short lifetimes originating from limited energy sources and
storages. Due to their low-power consumption and their on-demand communication
ability, wake-up receivers represent an energy efficient and simple enhancement
to wireless sensor nodes and wireless sensor network protocols. In this
context, wake-up receivers have the ability to increase the network lifetime.
In this article, we present T-ROME, a simple and energy efficient cross-layer
routing protocol for wireless sensor nodes containing wake-up receivers. The
protocol makes use of the different transmission ranges of wake-up and main
radios in order to save energy by skipping nodes during data transfer. With
respect to energy consumption and latency, T-ROME outperforms existing
protocols in many scenarios. Here, we describe and analyze the cross layer
multi-hop protocol by means of a Markov chain model that we verify using a
laboratory test setup.","Wireless sensor networks are used in many appli cations like environmental monitoring, home automa tion, smart manufacturing, infrastructure monitoring and many others. In this context, a wireless sensor net work usually consists of many small selfpowered sen sor nodes that measure their environment, process data and communicate it to other nodes or to a base station [1]. Message transmission can be done via singlehop transmissions or via multihop communication resulting in complex network topologies. The most critical parameter of a wireless sensor node is its energy requirement [2] which is vastly dominated by the power required for communication. A lot of re search was already done on efﬁcient MAC protocols to reduce power consumption and collisions and to in crease the throughput of a wireless network [3]. The au thors of [3] categorize MAC protocols into four groups: asynchronous, synchronous, frameslotted, and multi channel protocols. Asynchronous and synchronous pro tocols are based on dutycycling, where nodes switch Corresponding author. Tel.: +49 761 203 7243. Email address: timo.kumberg@imtek.de (T. Kumberg)between sleep and active states in order to save energy. To establish a communication link in synchronous pro tocols like SMAC or TMAC, each participating node has to be awake at the same time. This necessitates clock synchronization messages. Asynchronous pro tocols like BMAC or WiseMAC nodes use preamble sampling in combination with dutycycling to detect the beginning of a communication. To minimize col lisions frameslotted protocols allocate different time slots to nearby nodes. Multichannel protocols use crosschannel communication to realize higher through put. All these MAC protocols have in common that their energy requirement is linked to the duration of their sleep periods. Longer sleep periods result in lower energy consumption but also in communication laten cies. In addition, these MAC protocols require a certain amount of overhead to organize themselves [2]. Recently, wireless sensor networks [4, 5, 6, 7, 8] have been upgraded with lowpower wakeup receivers. These wakeup receivers have marginal power con sumption and wake up the sensor node if a dedicated signal has been received. So, lowpower wakeup re ceivers can greatly reduce the power consumption of wireless sensor nodes, by eliminating the idle listening time and at the same time reduce communication delays Preprint submitted to Journal of Ad Hoc Networks February 14, 2017arXiv:1702.03880v1  [cs.NI]  13 Feb 2017to achieve an almost latency free communication [9]. According to [2], wakeup radios can be categorized into two groups, active and passive wakeup receivers. Passive wakeup receivers harvest their wakeup energy directly from the wakeup message itself, whereas ac tive wakeup receivers require a permanent, yet very low, power supply. In this approach, a wireless sensor node usually incorporates two radio receivers, the main radio for data communication and a second one for re ceiving wakeup messages [2]. A sensor node wakes up only when it receives a wakeup message and then it turns on its communication radio. Another advantage of wireless sensor nodes with wakeup receivers is their enhanced robustness. Clock synchronization is obsolete and nodes may be reset at any time, for example, if a fatal software error occurred. Existing networks can be easily enhanced by new nodes, even if the network is running on low duty cycle periods [6]. Furthermore, extracting data from the network can be done without much delay, as messages are transmit ted almost instantly. Although [10] speak of a paradigm shift for wireless sensor protocols with integrated wakeup transceivers, there exist two major challenges [2, 10]: First, ac tive wakeup receivers show a higher sensitivity com pared to passive ones [2], but their sensitivity is still lower compared to that of stateoftheart main commu nication radio transceivers. Secondly, sending wakeup messages may cost more energy than sending of com munication messages. Table 1 shows the typical sen sitivity of some commonly used radio transmitters and their current consumption during transmit state. In Ta ble 2 sensitivity and power consumption of some state oftheart wakeup receivers are shown. The discrep ancy between main radio and wakeup receiver sensi tivity is clearly obvious as is the power consumption. Table 1: Receiver (RX) Sensitivity at 868 MHz and transmit (TX) currents at +10 dBm for some typical RF transmitters. RF TransceiverRX Sensitivity [dBm]TX current [mA] Si4468 104 19.7 CC1200 107 36 CC1101 95 30 SPIRIT1 105 21 Here, we present a crosslayer multihop wakeup routing protocol that combines wakeup and commu nication radios. The wireless sensor nodes are based on the works of [13, 15]. Due to the smaller transmisTable 2: Nonexhaustive list of wakeup receivers, their sensitivity and power consumption. Wakeup receiver Sensitivity [dBm]Power [µW] Magno and Benini [11] 55 1.3 Nilsson and Svensson [12] 47 2.3 Gamm et al. [13] 52 5.6 Hambeck et al. [14] 71 2.4 sion range of wakeup receivers compared to that of the main radio, data and wakeup transmissions are realized by a multihop routing protocol that supports sending wakeup messages and data. The protocol stack con sists of several layers. The lowest layer is responsible for the waking up of neighboring nodes. The second layer handles singlehop message transmissions and the top layer routes messages and forwards wakeup signals along multiple hops. The presented work in this paper is organized as fol lows. In Section 2 we review existing network proto cols that support the use of wakeup receivers. In Sec tion 3 we take a look at current wakeup receiver de signs and present the wireless sensor node that is used in this research. In Section 4 we introduce the proposed multihop wakeup routing protocol in detail and ana lyze its current consumption as well as the occurrence of false wakeups in Section 5. In Section 6, we in troduce Markov models of the proposed algorithm as well as for CTPWUR and a naive communication algo rithm. The models are veriﬁed and performance and en ergy requirements of the aforementioned protocols are compared and analyzed in Section 7. Finally, outlook and conclusions can be found in Section 8. 2. Related Work "
129,Towards Machine Learning-Enabled Context Adaption for Reliable Aerial Mesh Routing.txt,"In this paper, we present Context-Adaptive PARRoT (CA-PARRoT) as an extension
of our previous work Predictive Ad-hoc Routing fueled by Reinforcement learning
and Trajectory knowledge (PARRoT). Short-term effects, as occurring in urban
surroundings, have shown to have a negative impact on the Reinforcement
Learning (RL)-based routing process. Therefore, we add a timer-based
compensation mechanism to the update process and introduce a hybrid Machine
Learning (ML) approach to classify Radio Environment Prototypes (REPs) with a
dedicated ML component and enable the protocol for autonomous context adaption.
The performance of the novel protocol is evaluated in comprehensive network
simulations considering different REPs and is compared to well-known
established routing protocols for Mobile Ad-hoc Networks (MANETs). The results
show, that CA-PARRoT is capable to compensate the challenges confronted with in
different REPs and to improve its Key Performance Indicators (KPIs) up to 23%
compared to PARRoT, and outperform established routing protocols by up to 50 %.","Aerial mesh networks offer the ability to be deployed spon taneously for events or by emergency personnel to manage desaster situations. Although this enables wide application ranges, certain challenges arise throughout these scenarios. Besides high agent’s mobilities and hybrid vehicle types participating in the network, the agents must also be able to operate in different REPs. MultiREP scenarios (see Fig. 1) are considerably the most challenging situations for autonomous aerial mesh networks, as the mission cannot be interrupted to reconﬁgure the drones to ﬁt a new REP, especially if they have a high mobility and REP changes are frequent. However, even if the application is limited to a singleREP area, an autonomous context adaption is neccessary to enable a quick network deployment without preevaluation. Our previous work [1] has shown, that mobilitypredictive routing protocols, such as our proposed PARRoT, and B.A.T.Mobile [2] outperform the considered wellknown pro tocols in terms of robustness and reliability within different stress tests, channel conditions, and agent mobilities. Al though, the reinforcement learningbased PARRoT widely per formed best, a high impact of shortterm channel variations on the Packet Delivery Ratio (PDR) has been observed and mo tivated further enhancement. Thus, we present CAPARRoT, extending PARRoT with a compensation mechanism and in troducing a hybrid ML approach. The contributions are summarized as follows: RuralRSS Distance SubUrbanRSS Distance UrbanRSS DistanceFig. 1. Example of an application scenario, consisting of multiple radio environment prototypes (Map data: © OpenStreetMap Contributors, CC BY SA). Presentation of the enhanced CAPARRoT protocol and extension of our opensource C++ simulation framework for Objective Modular Testbed in C++ (OMNeT++) [3].1 Parameterization study for different REPs and proposal on a machine learningbased parameter selection . Performance analysis of CAPARRoT in compari son to wellestablished routing protocols, as well to our mobilitypredictive representatives B.A.T.Mobile and PARRoT. The remainder of the paper is structured as follows. After discussing the related work in Sec. II, we present the exten sions made to the CAPARRoT protocol, and an approach to autoadaptive parameterization in Sec. III. Afterwards, an overview about the methodological aspects is given in Sec. IV. Finally, detailed results are provided and discussed in Sec. V. II. R ELATED WORK "
90,Comparing the route-choice behavior of pedestrians around obstacles in a virtual experiment and a field study.txt,"Pedestrians often need to decide between different routes they can use to
reach their intended destinations, both during emergencies and in their daily
lives. This route-choice behavior is important in determining traffic
management, evacuation efficiency and building design. Here, we use field
observations and a virtual experiment to study the route choice behavior of
pedestrians around obstacles delimiting exit routes and examine the influence
of three factors, namely the local distance to route starting points and the
pedestrian density and walking speeds along routes. Crucially, both field study
and virtual experiment consider the same scenario which allows us to directly
assess the validity of testing pedestrian behavior in virtual environments. We
find that in both data sets the proportion of people who choose a closer exit
route increases as the difference in distance between exit route starting
points increases. Pedestrians' choices in our data also depend on pedestrian
density along routes, with people preferring less used routes. Our results thus
confirm previously established route choice mechanisms and we can predict over
74% of choices based on these factors. The qualitative agreement in results
between the field study and the virtual experiment suggests that in simple
route-choice scenarios, such as the one we investigate here, virtual
experiments can be a valid experimental technique for studying pedestrian
behavior. We therefore provide much-needed empirical support for the emerging
paradigm of experiments in virtual environments.","Pedestrians are a common sight in cities, transport hubs and at large public events  like concerts and soccer games. A sad but recurring reminder for the importance of  studying the movement of pedestrians are large scale accidents, such as at the Love  parade in Germany (Helbing and Mukerji, 2012)  and at the Mecca pilgrimage (Alaska  et al., 2017) . In additio n to understanding or even preventing such accidents, research  into pedestrian dynamics promises to inform the design of buildings or pedestrian  infrastructure and the implementation of traffic management approaches.   One crucial component of pedestrian beh avior is the decisions individuals make on  which route to use to reach their intended destinations. These decisions can cover  different spatial scales. On the one hand, pedestrians may decide on routes over long 3   distances, such as their commute to work, or  a shopping or sightseeing trip. On the other  hand, pedestrians also have to make decisions on much smaller spatial scales. For  example, pedestrians can choose between two routes to walk around a freestanding  obstacle (left or right in the direction of mov ement) and in confined indoor spaces,  pedestrians can often choose between several exits. Here, we focus on the latter scenario  and consider pedestrian choices on routes covering small spatial scales. These choices  may be simple and not require any conscio us decision making process.    Previous work identifies a large collection of factors that can influence route choice  even on the small spatial scales we are considering here. For example, factors that are  considered to be influential include: the informatio n about routes available to  individuals, the desire for maintaining cohesion in groups of friends or families,  visibility conditions, crowding of routes, social interactions including leadership by  some individuals, the distance to exits and the directness  of routes (Cao et al., 2018;  Haghani and Sarvi, 2016, 2017a; Liao et al., 2017; Lovreglio et al., 2016; Miller et al.,  2013; Shen et al., 2014; Srinivasan et al., 2017; Zhu and Shi, 2016) . A different line of  work focuses on more detailed aspects related to the motor control, steering, perception  and cognition of individual pedestrians avoiding stationary obstacles (Fajen and Warren,  2003; Fink et al., 2007; Gérin Lajoie et al., 2008; Gérin Lajoie et al., 2005, 2006; Patla,  1997; Patla et al., 2004; Vallis  and McFadyen, 2003, 2005) . Instead of considering all  of these aspects, we examine the relative influence of three different factors on  pedestrian route choice: the distance to be covered, the congestion along routes and the  walking speeds of other pedest rians using routes. We select these factors for two main  reasons. First, previous work on these factors suggests how they affect route choice, as  discussed below. This means they form an appropriate basis on which to perform a  validation of different resea rch methodologies, which is our primary contribution.  Second, even under normal conditions and without experimental manipulation, a broad  range of values describing the three factors can be expected to arise naturally in  appropriately designed pedestrian f acilities. This means a study, where the natural 4   behavior of pedestrians is observed without experimental instructions, as employed by  us here, is suitable for studying them.    Based on the literature, we expect the three factors we investigate to have the  following effects on the route choice of pedestrians around obstacles. In general, under  experimental conditions, pedestrians appear to prefer the route they expect to complete  in the shortest time (“quickest path ”, e.g. (Kemloh  Wagoum  et al., 2012) ). This  means  we can expect pedestrians to prefer shorter routes (Bovy and Stern, 2012; Guy, 1987;  Liao et al., 2017; Seneviratne and Morrall, 1985; Verlander and Heydecker, 1997)  and  it is thus plausible to expect that people preferentially choose exits that are  closer to  them or shorter routes around obstacles. Similarly, this suggests that pedestrians avoid  queues (Bode et al., 2014, 2015b; Bode and Codling, 2013; Haghani and Sarvi, 2016;  Liao et al., 2017; Zhang and He, 2014)  and we therefore expect that indiv iduals select  exits or routes around obstacles that are associated with a lower local density of  pedestrians. Finally, time dependent information, such as the speed at which other  pedestrians move in the local neighborhood of exits or obstacles can be indi cative of  how quickly different routes can be completed and pedestrians may thus be drawn  toward local areas of higher average walking speeds (Bode et al., 2015b) . We do not  aim to uncover fundamentally novel aspects of pedestrian route choice behavior here,  but a secondary contribution of our work is a confirmation of previous findings.   The main contribution and novelty of our work is a direct comparison of pedestr ian  route choice behavior based on the three factors discussed above between a natural  setting and a virtual environment setting. Virtual experiment s form  a promising  paradigm that can offer real time visualization of a wide variety of information  at  different levels of immersiveness . Virtual environments are gaining popularity as a  complementary experimental framework, as they are flexible, allow a high level of  experimental control, can be conducted remotely and allow simulating high pressure  situations t hat could be dangerous if conducted with many volunteers, for example  (Andrée et al., 2016; Bode et al., 2014, 2015b; Bode and Codling, 2013; Deb et al., 5   2017; Hartmann, 2010; Kinateder et al., 2014a; Kinateder et al., 2014b; Moussaid et al.,  2016; Ronchi et al., 2015) . To give examples of the scenarios that this emergent  technology can be used for, consider (Chu et al., 2017)  which calibrates a logistic  regression model for guidance compliance behavior based on a virtual reality  experiment.  (Kinateder et a l., 2014b)  studies the impact of social influence on route  choice behavior of pedestrians in a virtual reality tunnel fire. (Ye et al., 2018)  examines  daytoday route choice models based on a virtual route choice experiment. Despite  their evident populari ty, virtual experiments face one fundamental problem: it is not  clear to what extent the behavior observed in a virtual environment can be extrapolated  to the real world (Kinateder et al., 2014c) . In other words, the ecological validity of  virtual experime nts is often not established. Some studies have started to compare real  life pedestrian behavior to the behavior observed in virtual environments. For example,  several studies investigate whether virtual experiments can be used to capture the road  crossing  behavior of pedestrians in the presence of vehicles and generally find a good  match to real life behavior (Bhagavathula et al., 2018; Deb et al., 2017; Schwebel et al.,  2008) . Other research confirm s that simple avoidance maneuvers between pedestrians  can also be faithfully captured in virtual experiments (Iryo Asano et al., 2018;  Moussaid et al., 2016) . One study that finds a good match in avoidance behavior  between pedestrians in a real life and a virtual experimental setting also finds that  measures cap turing the flow of pedestrians through a bottleneck cannot be reproduced  accurately in the virtual environment (Moussaid et al., 2016) .  This research suggests that virtual experiments are capable of faithfully  reproducing pedestrian behavior. However, a co nfirmation that choices of pedestrians  on available routes based on multiple factors, such as the ones we discuss above, can  be reproduced in virtual experiments is missing to date. In addition, validation studies  for virtual experiments have so far focuse d on highly immersive virtual environments  that attempt to mimic the visual perception of pedestrians in three dimensions. However,  more abstract virtual experiments in which participants have a top down view on a 6   virtual environment have been proposed as a plausible research tool but remain  unvalidated to date (Bode et al., 2014, 2015b; Bode and Codling, 2013) . The only study  that starts to address these questions compares route choices in controlled experiments  with data from interviews in which participa nts stated their preferred routes for a static  topdown snapshot of a building floorplan that indicates the locations of other people  (Haghani and Sarvi, 2017b) . The authors find that factors, such as distance to exits and  congestion, have similar effects on route choices in both data sets. In contrast to this  approach of investigating stated exit choices based on static information, we consider  dynamically varying virtual environments that participants can interact with and  compare human route choice behav ior in a highly abstracted virtual experiment (unclear  ecological validity) to field observations (highest ecological validity).   To summarize, the two research questions of our work are as follows:   1. Can we confirm the effects of three factors (local distanc e to routes and the  pedestrian density and walking speeds along routes) on route choice of  pedestrians as predicted by the literature (nature of effects is discussed above)?  This will confirm previous findings in a novel context.   2. Are these effects qualitat ively the same in observational data of real pedestrian  behavior and in a virtual experiment with a nearly identical route choice setup?  This will provide empirical evidence on the similarity of human route choice  behavior in real pedestrians and of human participants in simple virtual  experiments on pedestrian behavior , an emerging technology that is rapidly  gaining popularity .  The remainder of this article is structured as follows. In section 2, we describe the  data collection procedure for the field study and the virtual experiment. In section 3, we  present the results from both studies including our statistical analysis of the data and in  section 4 we discuss our findings and draw conclusions.  7   2. Methods   "
59,Fractal Rosette: A Stable Space-Ground Network Structure in Mega-Constellation.txt,"We present F-Rosette, a stable space-ground network structure for low-earth
orbit (LEO) satellite mega-constellations at scale. Due to the dynamic
many-to-many space-ground mapping in high mobility, existing LEO
mega-constellations with IP protocol stack suffer from frequent user IP address
changes (every 133~510s per user) and network routing re-convergence (<20%
network usability). To provably stabilize the space-ground network under high
mobility and many-to-many dynamics, F-Rosette adopts a recursive structure over
the Rosette constellation, derives a hierarchical and time-invariant network
address space from a new geographical coordinate system, and ensures efficient
and stable routing via geographical-to-topological routing embedding without
re-convergence. Our hardware-in-the-loop, trace-driven emulations validate
F-Rosette's stability, near-optimal routing (<1.4% additional delays), and
marginal overhead (<1% CPU, <2MB memory) for resource-constrained satellites.","The future Internet is up in the sky. Since 2019, we have witnessed a rocketfast deployment of the lowearthorbit (LEO) satellite megaconstellations, including SpaceX Star link [ 1], Amazon Kuiper [ 2], Telesat [ 3], OneWeb [ 4], to name a few. Compared to the traditional satellite networks, these LEO megaconstellations promise ultralow network latency and high throughput that are competitive to the terrestrial networks. Moreover, with massive satellites, these mega constellations offer the global Internet coverage to users that were not easily reachable by terrestrial networks, such as those in rural areas and the ocean. This work asks a simple question: How to enable a usable network in megaconstellations to serve the terrestrial users? Despite the rapid deployments of LEO megaconstellations, interconnecting satellites for network services is still at early designs on a tiny scale (such as Starlink’s “Better Than Nothing” plan [ 5] and initial intersatellite link test [ 6,7]). With massive mobile LEO satellites and their relative motions to numerous terrestrial users on a rotating earth, it is open to question whether the traditional wisdom of satellite network designs are still suitable for the megaconstellations.A grand challenge for a usable spaceground network is to guarantee its stability under satellites and earth’s high mobility. Unlike the traditional satellite and terrestrial net works, the LEO network exhibits highly dynamic manyto many mapping between the moving satellites and terrestrial users. Each LEO satellite can cover ≈100,000 users, while each terrestrial user has visibility to ≈20 satellites in mega constellations [ 8]. The high satellite mobility and earth’s rotation force the terrestrial users to frequently reassociate to new satellites. Therefore, the network topology between the space and ground repetitively changes, which results in frequent network address changes and routing protocol re convergence. Our projection of megaconstellations running IP protocols shows that ( §2.2), every terrestrial user switches its IP address every 133–510s (with 2,082–7,961 users chang ing IP addresses every second), and the network usability decreases to≤20% with frequent routing reconvergence. Even worse, both stability issues are amplified as mega constellations scale to massive satellites. The fundamental cause of the above unstable spaceground network is the mismatch between the network in the virtual cyberspace and megaconstellations in the physical world. On one hand, classical megaconstellations primarily focus on offering good coverage, but neglects the demands of sta ble network topology, addressing, and routing. On the other hand, most satellite networks in the virtual cyberspace heav ily rely on the logical address and routing, which are vulner able to the high satellite mobility earth’s rotations in reality. Therefore, a stable spaceground network at scale calls for a coherent design between cyberspace and reality. We propose FRosette , a stable spaceground network structure in LEO megaconstellation. FRosette stabilizes the spaceground network in the virtual cyberspace by align ing it with the dynamic megaconstellations in the physical world. With the Rosette constellation as the basic building block, FRosette recursively constructs a provably stable network topology with intersatellite links. On top of this stable network topology, we derive a hierarchical network ad dress space for the satellites and terrestrial users. To prevent frequent address changes, we decouple this address space from mobility in FRosette ’s new geographical coordinate system. Routing with FRosette ’s network address is stable and efficient without requiring routing reconvergence, thusarXiv:2105.05560v1  [cs.NI]  12 May 2021satellite  subpointEarth LEO MEO H ER R  Figure 1: Satellites, constellations, and their coverages. Num. Num. Altitude Inclination Groundto satellites orbits 𝐻(km) angle𝜙 space RTT (ms) Starlink [1]1584/1584/ 720/348/17272/72/ 36/6/4550/540/ 570/560/56053/53/ 70/97/973.7/3.6/ 3.8/3.7/3.7 Kuiper [2] 1156/1296/784 34/36/28 630/610/590 52/42/33 4.2/4.07/3.93 Telesat [3] 351/1320 27/40 1015/1325 98.98/50.88 6.77/8.83 Iridium [9] 66 6 725 86.4 4.83 Table 1: Statistics of common LEO constellations. retaining high network usability. Routing between satellites follows the standard IPv6 prefix/wildcard matching with provable optimality and multipath support. To route traffic between terrestrial users, FRosette performs local geo graphical routing by embedding it into the topological rout ing between satellites over the stable network topology. For practical deployment, FRosette is backward compatible with IPv6, supports incremental expansion, and facilitates internetworking to external networks. We prototype FRosette ’s protocol suite and evaluate it with hardwareintheloop, tracedriven emulations. Com pared to existing megaconstellations, FRosette stabilizes network topology, addressing, and routing with nearoptimal data delivery (≤1.4% additional delay). FRosette incurs negligible CPU (<1%) and memory (<2MB) cost that is compa rable to standard IPv6, thus suitable for small LEO satellites. 2 SPACEGROUND NETWORK PRIMER This section introduces the LEO satellite megaconstellations today (§2.1), and analyzes why they cannot guarantee stable spaceground network services ( §2.2). 2.1 Satellites and MegaConstellations Satellites can be classified by their orbits’ altitude. A satellite can operate at lowearth orbit (LEO, ≤2,000 km), medium earth orbit (MEO, ≤35,786 km), or highearth orbit (HEO, >35,786 km). An orbit can be described by its altitude, incli nation to Equator, and right ascension angle1. Traditional communication satellites usually operate at MEO orbits, such as the geostationary orbit (GEO, 35,786 km). As shown in Figure 1, a higheraltitude satellite offers larger coverage (defined as its great circle range 𝑅on the earth) but at the cost of longer groundtospace roundtrip latency. 1In theory, 7 parameters are required to describe an orbit [ 10]. But real constellations need fewer degrees, e.g., circular orbit with zero eccentricity and same apogee/perigee. So we will use a simpler version in this paper.A small LEO satellite usually has very limited coverage, computation power, and storage. To enable ubiquitous net work services, one possible solution is to deploy an LEO megaconstellation . Table 1 summarizes the statistics of com mon megaconstellations today. The massive satellites help fully cover the areas of interest, while the LEO orbits en sure low groundtospace round trips. Each satellite uses its microwave radio link for data transfer from/to terres trial users. Satellites can interconnect with each other via freespace laser intersatellite links. Unlike the traditional communications satellites at link layer only, LEO satellites in the megaconstellations should route traffic at the network layer and interconnect to other terrestrial networks (e.g., via TCP/IP) for global Internet services at scale (acknowledged by Elon Musk [11] and recent work [12, 13]). 2.2 Unstable SpaceGround Network Today The LEO megaconstellations aim to enable usable and per formant network services for terrestrial users. Unfortunately, our analysis and tracedriven emulation project that, with thedynamic manytomany spaceground mapping in high mobility, existing megaconstellations running standard IP will suffer from frequent IP address changes for the users and routing reconvergence for the network (thus low usability). Why unstable: Dynamic manytomany mapping In LEO megaconstellations, the manytomany mapping be tween satellites and terrestrial users is a norm rather than an exception. Each LEO satellite can cover many users ( ≈100,000), while each terrestrial user has visibility to many satellites (≈20) in megaconstellations. This manytomany mapping is dynamic due to high mobility. Compared to the MEO/GEO satellites, LEO satellites at a much lower altitude (typically ≤2,000 km) exhibit high mobility2and relative motions. More over, terrestrial users also exhibit relative motions to the satellites due to the earth’s rotations. Both result in frequent changes of the network topology between space and ground. How (un)stable is the spaceground network: We next quantify the impact of dynamic manytomany mapping on the stability of the spaceground network. Since the LEO megaconstellations are still at their early deployments, their network designs are still underway and unfinished [ 5–7]. To this end, we conduct a tracedriven projection based on the operational megaconstellations in Table 1 over IPv6 in a hardwareintheloop emulator (detailed in §7). We consider two usage modes: (1) Direct access: A terrestrial user with a satellite phone directly accesses the satellite network. We follow the world population statistics from NASA in 2020 [14] and Starlink’s estimated customer numbers in the U.S. [15] to proportionally estimate the users that directly access 2According to Kepler’s third law, for all satellites of the earth, the ratio between their orbital altitude and period (𝑅𝐸+𝐻𝑠)3/𝑇2𝑠is a constant. 2Starlink T elesat Kuiper Iridium0100200300400500/uni0000002c/uni00000051/uni00000057/uni00000048/uni00000055/uni00000059/uni00000044/uni0000004f/uni00000003/uni00000045/uni00000048/uni00000057/uni0000005a/uni00000048/uni00000048/uni00000051/uni00000003 /uni00000003/uni0000002c/uni00000033/uni00000003/uni00000046/uni0000004b/uni00000044/uni00000051/uni0000004a/uni00000048/uni00000056/uni0000000b/uni00000056/uni00000048/uni00000046/uni0000000c(a) Interval between changes Starlink T elesat Kuiper Iridium050001000015000/uni00000031/uni00000058/uni00000050/uni00000045/uni00000048/uni00000055/uni00000003/uni00000052/uni00000049/uni00000003/uni00000058/uni00000056/uni00000048/uni00000055/uni00000056/uni00000003/uni00000057/uni0000004b/uni00000044/uni00000057/uni00000003 /uni00000046/uni0000004b/uni00000044/uni00000051/uni0000004a/uni00000048/uni00000003/uni0000002c/uni00000033/uni00000003/uni00000053/uni00000048/uni00000055/uni00000003/uni00000056/uni00000048/uni00000046/uni00000052/uni00000051/uni00000047 (b) IP changed users per second Figure 2: Projected users’ IP address change frequency in LEO megaconstellations in the direct access mode. satellite network at different locations. (2) Ground station assisted access: Terrestrial users associate to a ground station [16,17], which connects to a satellite for network access. We assume six ground stations in New York, Tokyo, Beijing, Hong Kong, Shanghai, and Singapore; the results for ground stations at other locations are similar. We assume each user or ground station will always associate to the physically nearest satellite for good coverage [ 18]. All network nodes run the IPv6 stack and OSPF. Figure 2 and Figure 3 show the projected impact on the users and the network, respectively. ◦Impact on users: Frequent IP address changes. In the direct access mode, a terrestrial user’s IP address belongs to the subnet of the corresponding satellite logical network inter face. With rapid satellite motions, the terrestrial user has to frequently handoff to new satellites (thus new network interfaces and addresses) to retain its Internet access. As shown in Figure 2, each user is forced to change its logical IP address every 133–510s, and every second we observe 2082–7961 global users per second should change their IP addresses. Such frequent address changes will repetitively disrupt the TCP connections and upperlayer applications, and will negatively impact the user experiences. ◦Impact on network: Frequent routing reconvergence and low usability. To prevent frequent user IP changes, one can adopt the ground stationassisted access mode. In this mode, the ground station is a gateway for a fixed IP subnet, so that all users associating with it retain the timeinvariant address. As the ground station reassociates to a new satellite, the spaceground logical network topology changes. Then the IP routing must reconverge to guarantee reachability to this ground station, before which the network cannot route traffic to the ground station. Note each LEO satellite can only pro vide very short coverage for a ground station (10 minutes in Iridium,≤3 minutes in Starlink). Frequent handoffs between satellites result in repetitive routing reconvergence and thus low network usability (i.e., 1−routing reconvergence duration each satellite’s service duration). Fig ure 3 shows that, all megaconstellations today suffer from ≤20% network usability even under small constellations. The network usability decreases with more satellites, which causes more frequent handoffs for ground stations. How megaconstellation amplifies instability: Both issues will worsen with more satellites in the megaconstellations. /uni0000001c/uni00000003/uni0000000d/uni00000003/uni00000014/uni0000001c/uni00000003/uni0000000d/uni00000003/uni00000018/uni00000014/uni0000001b/uni00000003/uni0000000d/uni00000003/uni00000018/uni00000014/uni0000001b/uni00000003/uni0000000d/uni00000003/uni00000014/uni00000014 /uni00000026/uni00000052/uni00000051/uni00000056/uni00000057/uni00000048/uni0000004f/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000036/uni00000046/uni00000044/uni0000004f/uni00000048/uni00000013/uni00000015/uni00000018/uni00000018/uni00000013/uni0000001a/uni00000018/uni00000014/uni00000013/uni00000013/uni00000031/uni00000048/uni00000057/uni0000005a/uni00000052/uni00000055/uni0000004e/uni00000003/uni00000038/uni00000056/uni0000004c/uni00000045/uni0000004c/uni0000004f/uni0000004c/uni00000057/uni0000005c/uni00000003/uni0000000b/uni00000008/uni0000000c/uni0000001c/uni00000015/uni00000011/uni00000016/uni0000001c /uni00000019/uni0000001b/uni00000011/uni00000017/uni00000015 /uni00000017/uni0000001a/uni00000011/uni00000013/uni00000016 /uni00000014/uni0000001a/uni00000011/uni00000014/uni0000001a(a) Starlink /uni0000001c/uni00000003/uni0000000d/uni00000003/uni00000014/uni0000001c/uni00000003/uni0000000d/uni00000003/uni00000018/uni00000014/uni0000001b/uni00000003/uni0000000d/uni00000003/uni00000018/uni00000014/uni0000001b/uni00000003/uni0000000d/uni00000003/uni00000014/uni00000014 /uni00000026/uni00000052/uni00000051/uni00000056/uni00000057/uni00000048/uni0000004f/uni0000004f/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000036/uni00000046/uni00000044/uni0000004f/uni00000048/uni00000013/uni00000015/uni00000018/uni00000018/uni00000013/uni0000001a/uni00000018/uni00000014/uni00000013/uni00000013/uni00000031/uni00000048/uni00000057/uni0000005a/uni00000052/uni00000055/uni0000004e/uni00000003/uni00000038/uni00000056/uni0000004c/uni00000045/uni0000004c/uni0000004f/uni0000004c/uni00000057/uni0000005c/uni00000003/uni0000000b/uni00000008/uni0000000c/uni0000001c/uni00000018/uni00000011/uni00000015/uni00000016 /uni00000019/uni0000001b/uni00000011/uni00000018/uni0000001a /uni00000017/uni0000001b/uni00000011/uni00000017/uni00000014 /uni00000014/uni00000018/uni00000011/uni00000017/uni0000001a (b) Kuiper Figure 3: Projected network usability in LEO mega constellations in ground stationassisted mode. Users in the direct access mode will experience more hand offs with more satellites, thus causing more frequent IP ad dress changes. For the network in the ground stationassisted mode, Figure 3 shows more satellites prolong the routing reconvergence on link change, thus lowering the network usability. Moreover, more satellites complicate the dynamic routing between the moving satellites and terrestrial users (due to the earth’s rotation). Solutions for small LEO net works decades ago (e.g., virtual topology [ 19,20] and virtual nodes [ 21,22]) cannot scale to the megaconstellations today due to their vulnerability to dynamic manytomany map ping, and expensive (pre)computation and storage for small LEO satellites. Motivated by this, we next design FRosette , a stable spaceground network structure for LEO megaconstellations. 3 THE FROSETTE NETWORK STRUCTURE We introduce FRosette ’s structure and its basic properties. 3.1 A Primer of Rosette Constellation The basic building block of FRosette is a Rosette constella tion, which was originally proposed in [ 23] to guarantee full coverage with as few satellites as possible. This section in troduces the necessary background of Rosette constellation forFRosette ; a complete description is available in [23]. Figure 4 exemplifies the Rosette constellation with 8 satel lites. Each orbit has one satellite, and all satellites move in circular orbits at the altitude of 𝐻(thus period 𝑇). A Rosette constellation is defined as a tuple (𝑁,𝑚), where𝑁is the number of satellites and 𝑚∈Nis a harmonic phase shift. All satellites are numbered from 0 to 𝑁−1. For satellite 𝑖, its runtime location can be described by three constant angles (𝛼𝑖,𝛽𝑖,𝛾𝑖)and one timevarying phase angle 𝑥𝑡at time𝑡: 𝛼𝑖=2𝜋𝑖 𝑁,𝑖=0,1,...,𝑁−1 (1) 𝛽𝑖≡𝛽,∀𝑖 (2) 𝛾𝑖=𝑚𝛼𝑖=𝑚·2𝜋𝑖 𝑁(3) 𝑥𝑡=2𝜋 𝑇𝑠𝑡 (4) 3ith point of right ascension αiβγiα=0(a) Physical constellation in space 01234567 (b) Logical topology in FRosette 0 Figure 4: A Rosette constellation with 𝑁=8,𝑚=6. where𝛼𝑖is satellite𝑖’s right ascension angle, 𝛽𝑖≡𝛽is the inclination angle for all orbits, 𝛾𝑖is𝑖’s initial phase angle in its orbit at time 𝑡=0, and𝑥𝑡is the timevarying phase angle ( identical for all satellites anytime ). Compared to other constellations, the Rosette constellation has two appealing properties for networking: Full coverage with fewer satellites: The Rosette con stellation usually needs fewer satellites than Walker (build ing block for Starlink and Kuiper) and polar orbits for full coverage (see [ 23] and§7.1 for the evaluations). Each satel lite’s coverage 𝑅in Figure 1 can be determined by its altitude 𝐻and elevation angle 𝜙: tan𝜙=cos𝑅−𝑅𝐸/(𝑅𝐸+𝐻) sin𝑅(5) For LEO satellites, given each satellite’s coverage 𝑅on the earth, the minimum number of satellites 𝑁𝑚𝑖𝑛needed to fully cover the earth is decided by the following relation: sec𝑅=√ 3 tan𝜋 6𝑁𝑚𝑖𝑛 𝑁𝑚𝑖𝑛−2 (6) Periodic groundtrack repeat orbits: Due to the earth rotation and high LEO satellite mobility, the satellite sub point in Figure 1 is timevarying and nonrepeatable in gen eral3(exemplified in Figure 10). This complicates locating and routing between the ground and space. Instead, the Rosette constellation allows LEO satellites to retain periodic satellite subpoints via groundtrack repeat orbits, i.e., every satellite willperiodically revisit its previous satellite subpoint. To do so, we configure the satellites’ orbital period 𝑇𝑠such that 𝑇=𝑇𝐸/(𝑁−𝑚) (7) where𝑇𝐸is the period of earth rotation. For each satellite 𝑖, the latitude 𝜑𝑖and longitude 𝜆𝑖of its subpoint is: sin𝜑𝑖=sin𝛽sin𝑚(𝜔𝐸𝑡−𝛼𝑖) (8) tan[𝜆𝑖+𝑚(𝜔𝐸𝑡−𝛼𝑖)]=cos𝛽tan𝑚(𝜔𝐸𝑡−𝛼𝑖)(9) where𝜔𝐸=2𝜋/𝑇𝐸is the earth’s angular rotation speed. Despite these merits, however, the original Rosette constel lation is not immediately applicable to networking. It was 3The geostationary satellites guarantee timeinvariant satellite subpoint, but at the altitude of 35,786km and thus suffer from long network latency.Algorithm 1 FRosette construction. Input: A Rosette constellation (𝑁,𝑁,𝑚), and a FRosette level𝑘≥0 Output: FRosette𝑘 1:FRosette 0=(𝑁,𝑁,𝑚)Rosette constellation; 2:forj=1 to k do 3: FRosette 𝑗={}; 4: fori= 0 to N1 do ⊲Step 1: Construct 𝑁FRosette𝑗−1s 5: FRosette𝑖 𝑗−1=Shift(FRosette 𝑗−1,2𝜋 𝑁𝑗); 6: FRosette 𝑗.append( FRosette𝑖 𝑗−1); 7: end for 8: fori=0 to N1 do ⊲Step 2: Interconnect FRosette𝑗−1s 9: foreach satellite 𝑆𝑖inFRosette𝑖 𝑗−1do 10: Connect𝑆𝑖to𝑆(𝑖+1 mod𝑁)inFRosette(𝑖+1 mod𝑁) 𝑗−1; 11: end for 12: end for 13: end for 14: return FRosette𝑘; primarily designed for full coverage rather than network routing. There was no specification on how to interconnect satellites, how to forward traffic among satellites, and how to route data among terrestrial users via satellites. This mo tivates us to restruct the Rosette constellation for stable spaceground network at scale. 3.2 FRosette Construction FRosette adopts the Rosette constellation as a base case, but extends it recursively with intersatellite links. Specifi cally, a FRosette 0is a(𝑁,𝑚)Rosette constellation in §3.1, with intersatellite links in adjacent satellites (exemplified in Figure 4b) and groundtrack repeat orbits for all satel lites. A FRosette 𝑘(𝑘≥1) is constructed recursively from 𝑁FRosette 𝑘−1s. Algorithm 1 shows FRosette construc tion. It takes two phases (exemplified in Figure 5): (1) Construct 𝑁FRosette 𝑘−1s: TheFRosette 𝑘−1s are numbered from 0 to 𝑁−1asFRosette0 𝑘−1,FRosette1 𝑘−1, ...,FRosette𝑁−1 𝑘−1. As shown in Figure 5a, FRosette𝑖 𝑘−1 is obtained by first duplicating a FRosette0 𝑘−1, and then shifting it by a time interval 𝑡𝑘=𝑇𝑆 𝑁𝑘(or equivalently a phase angle shift𝑥𝑘=2𝜋 𝑇𝑠·𝑡𝑘=2𝜋 𝑁𝑘according to Equation 4). Each satellite𝑆𝑗inFRosette0 𝑘−1is replicated 𝑁times on the same orbit, denoted as 𝑆0 𝑗,𝑆1 𝑗,...𝑆𝑁−1 𝑗. (2) Interconnect FRosette 𝑘−1s:The next step is to bridge FRosette 𝑘−1s with intraorbit intersatellite links only. As shown in Figure 5b and Figure 5c, each 𝑆𝑖inFRosette𝑖 𝑘−1 (𝑖=0,1,...,𝑁−1) adds a link to 𝑆(𝑖+1 mod𝑁)inFRosette(𝑖+1 mod𝑁) 𝑘−1. This creates a circle among satellites on the same orbit. 3.3 Basic Properties of FRosette FRosette inherits all good properties from the classical Rosette constellation in §3.1, and has additional appealing features for networking due to its recursive architecture. Network structure size: AFRosette 𝑘has𝑁𝑘+1satel lites and(𝑘+1)𝑁𝑘+1intersatellite links. Table 2 exemplifies 42shift angel=km N kTtN= 0t=(a)Shift( FRosette , t)in Algorithm 1 0.0 0.7 0.6 0.5 0.4 0.3 0.1 1.7 1.6 1.5 1.4 1.3 1.2 1.0 2.6 2.5 2.4 2.3 2.2 2.1 2.7 3.5 3.4 3.3 3.2 3.1 3.0 3.6 7.1 7.0 7.7 7.6 7.5 7.4 7.2 6.2 6.1 6.0 6.7 6.6 6.5 6.3 5.3 5.2 5.1 5.0 5.7 5.6 5.4 4.4 4.3 4.2 4.1 4.0 4.7 4.5 0.2 4.6  5.5  6.4  7.3 0 0 FRosette 1 0 FRosette 2 0 FRosette 3 0 FRosette 4 0 FRosette 5 0 FRosette 6 0 FRosette 7 0 FRosette (b) Logical network topology of FRosette 𝑘 —— Intersatellite links O Coverages —— Orbits (c) Physical constellation in 3D space —— Satellite subpoint trajectory  ◇  FRosette k 1 Cells  ◇ FRosette k Cells   O coverages (d) Hierarchical geographical cells by fixed satellite subpoint trajectories. Figure 5: Recursive construction of FRosette . the scale when 𝑁=8.Each satellite has 2(𝑘+1)intersatellite links, which is affordable even for small LEO satellites (typi cally 4–5 links [12, 13]). Full coverage: Each FRosette 𝑘is also a Rosette con stellation and thus can ensure full coverage. Specifically, we have the following theorem (proved in Appendix A): Theorem 1 (Full coverage) .AFRosette 𝑘guarantees full coverage if its satellites’ altitude 𝐻>𝐻𝑚𝑖𝑛, where 𝐻𝑚𝑖𝑛=𝑅𝐸1 cos𝑅−sin𝑅tan𝜙−1 𝑅=sec−1√ 3 tan𝜋 6𝑁𝑘+1 𝑁𝑘+1−2  With this full coverage guarantee, a satellite operator can customize the FRosette size to meet its demands. In Ap pendix B, we show how to select the size given the demand of groundtospace RTT and the minimum elevation angle. Stable network topology: FRosette guarantees time invariant network topology despite satellites’ high mobility and earth’s rotation. This is desirable to simplify the routing and ensure high network usability ( §2.2). FRosette guar antees the logical connection between any two satellites remains alwayson and unchanged. This can be achieved byTable 2: FRosette ’s satellites’ altitude with 𝑁=8/16, 𝑚=1, and the elevation angle 𝜙=25◦. Num. Minimun Groundto Avg. cell satellites altitude (km) space RTT (ms) size (km2)𝑁=8FRosette 0 8 11848.46 78.99 9,060,419 FRosette 1 64 1259.58 8.40 141,569 FRosette 2 512 335.33 2.23 2,212𝑁=16FRosette 0 16 4268.73 28.46 1,973,158 FRosette 1 256 504.83 3.36 7,707 FRosette 2 4096 107.62 0.72 30 specifying the minimum altitude of all satellites, as shown below (proved in Appendix C): Theorem 2 (Stable network topology) .The network topology of aFRosette 𝑘remains stable if its satellites’ altitude 𝐻> max{(1 𝑐𝑜𝑠𝑟𝑚𝑎𝑥 2−1)𝑅𝐸,𝐻𝑚𝑖𝑛}, where𝑟𝑚𝑎𝑥 is the max great circle range of interorbit links and 𝑅𝐸is the earth radius. Stable satellite subpoint trajectory: FRosette always adopts the Rosette constellations with groundtrack repeat orbits𝑇=𝑇𝐸/(𝑁−𝑚). As shown in Figure 5d, this results in stable and periodic satellite subpoint trajectory. As we will see in§4, these trajectories enable hierarchical spaceground network addresses and simplify routing. Propagation delay of an intersatellite link: Despite high satellite mobility, FRosette retains regular and pre dictable delay variations for each intersatellite link. For intra orbit links, FRosette guarantees fixed propagation delay 5between two satellites, due to their timeinvariant distances. For the interorbit links, its length (thus propagation delay) unavoidably varies over time. For any two satellites 𝑖and 𝑗in different orbits, its intersatellite link length 𝐿𝑖𝑗and propagation delay 𝜏𝑖𝑗: 𝐿𝑖𝑗(𝑡)=2(𝐻+𝑅𝐸)sin"
445,Blockchain for Economically Sustainable Wireless Mesh Networks.txt,"Decentralization, in the form of mesh networking and blockchain, two
promising technologies, is coming to the telecommunications industry. Mesh
networking allows wider low cost Internet access with infrastructures built
from routers contributed by diverse owners, while blockchain enables
transparency and accountability for investments, revenue or other forms of
economic compensations from sharing of network traffic, content and services.
Crowdsourcing network coverage, combined with crowdfunding costs, can create
economically sustainable yet decentralized Internet access. This means every
participant can invest in resources, and pay or be paid for usage to recover
the costs of network devices and maintenance. While mesh networks and mesh
routing protocols enable self-organized networks that expand organically,
cryptocurrencies and smart contracts enable the economic coordination among
network providers and consumers. We explore and evaluate two existing
blockchain software stacks, Hyperledger Fabric (HLF) and Ethereum geth with
Proof of Authority (PoA) intended as a local lightweight distributed ledger,
deployed in a real city-wide production mesh network and also in laboratory
network. We quantify the performance, bottlenecks and identify the current
limitations and opportunities for improvement to serve locally the needs of
wireless mesh networks, without the privacy and economic cost of relying on
public blockchains.","Networkinfrastructuresarecriticaltoprovidelocalandglobalconnectivitythatenablesaccesstoinformation,socialinclusion andparticipationforeveryone.Localconnectivitylargelyreliesonaccessnetworks.Wirelessmeshnetworks(WMNs)areakind of access networks comprising of wireless nodes namely wireless mesh routers, wireless mesh clients, and network gateways. A client (connected through WiFi or wired to a mesh router) can access the Internet across a WMN1. These are selforganized networks that can grow organically: new network links can expand the coverage of the network or increase the capacity when linksgetoverused.Theroutingprotocolrunsineveryrouterbymeasuringtheperformanceandqualityoflinksandcoordinates distributeddecisionsaboutthebestnetworkpathsperiodically.Asaresult,oncearoutingprotocolisadopted,thedevelopment and operation of the network only depends on pooling routers and links with local decisions, without any central planning or management.arXiv:1811.04078v4  [cs.NI]  2 Apr 20192 A R Kabbinale ET AL Thesedecentralizednetworksareessentialtodevelopcommunityaccessnetworks,networkinfrastructurecommons,builtby citizensandorganizationswhichpooltheirresourcesandcoordinatetheireﬀorts,characterizedbybeingopen,freeandneutral2. Thesedecentralizedaccessnetworkshavebeenidentiﬁedasonewaytoconnectthenextbillionpeoplethatarestillwithoutthe Internet access3. Guiﬁ.netais an example of such a community eﬀort which is one of the biggest community networks in the world, with more than 34;000participating routers, combining technologies including wireless mesh and ﬁbre. However the main challenge of these peertopeer sociotechnical structures are around trust among agreements between peers and how to ensure the economic sustainability of this collective eﬀort and the balance between contribution and consumption2. An example scenario and mechanism for economic sustainability is the economic compensation system used in Guiﬁ.net2. An answer to the lack of incentives to invest in network infrastructure, it was introduced in 2011 as a cost sharing mechanism. The idea of the compensation system is to balance between total resource contribution and its consumption. The economic costofanycontributionandconsumptionofnetworkresourcesbyeachparticipantinagivenlocalityarerecorded.Theoverall resultisazerosumcomputedperiodically,frommonthlytoquarterly,wheretheparticipantswithoverconsumptionornegative balances have to compensate those with overcontribution or positive balances. Currentlytheabovedescribedeconomiccompensationsystemisdonemanually:eachparticipantdeclaresitscostsandcon sumptionandthentheGuiﬁ.netfoundationbvalidatesthisclaimbycrosscheckingitwiththeirownnetworktraﬃcmeasurement dataandnetworkinventory,accordingtotheagreedlistofstandardcosts.Anydisparitiesbetweenthesetworecordsareﬂagged, clariﬁedorraisedtoaconﬂictresolutionmechanism.Thereis,however,roomforerrororintentionalfalseorexaggeratedclaims put forward by a participant, the recorded data being tampered with, or simply mistrust among the parties. The correct appli cation of the compensation system is critical for the economic sustainability of the network, ensuring its proper operation, as wellasfutureinvestments.Therefore,wearguethatthereisaneedforanautomatedsystemwherediverseparticipants,resource providersandconsumers,cantrustthattheconsumptionofresourcesisbeingaccountedinafairmanner,andthatthesecalcu lationsandmoneytransfersareautomated,irreversibleandsharedacrossdiﬀerentparticipants,toavoidthecost,delays,errors and potential mistrust from manual accounting and external payments. Blockchaintechnologyoﬀerssolutionsthatseemsapttomakethepeertopeernatureofaccessnetworkstrustedandeconom ically sustainable.Blockchain (moredetails inSection 2) isan immutableand distributeddata storage withoutthe provisionof retrospectivemutationindatarecords.However,mostblockchainnetworksareopenandpublic(permissionless)thatencourage the users to protect anonymity4. This implies that anyone, without revealing their true identity, can be part of such a network and make transactions with another similarly pseudonym peer of the network. In the perspective of community networks such as Guiﬁ.net, however, every participant who joins the network to contribute andbeneﬁtfromtheinfrastructuremustﬁrstregisteritsidentityandtheidentityoftheresourcesthatitcontributestothewider pool.Thisisparticularlyneededsothatanymaliciousentity,suchashiddennodesinGuiﬁ.netusedbyotherISPs,canbeﬁltered out5. Because of such registration process one also needs an eﬃcient identity mechanism on top of blockchain’s immutable recordkeeping. Permissionedblockhains arepartofsuchsolutions,mostlyenvisionedforbusinessnetworkswherethereisoften a stringent requirement of know your customer in addition to keeping the intra and interbusiness transactions conﬁdential. In this study, we extend our previous work6by exploring the plausibility of combining decentralized access networks with a permissioned blockchain running on servers inside the access network, that would result in a model for economically self sustainable decentralized mesh access networks, guaranteeing trust among participants, allowing economic proﬁtability, and enablingatthesametimeeasierInternetconnectivity.Westudytheviabilityofsuchanapproach,byevaluatingtwoofthemost prominent platforms for building local blockchain applications. These platforms are Hyperledger Fabric (HLF)c, an industry orientedmodular,andpermissioneddistributedledgerandtheEthereumd,ageneralpurposeplatformactingasapermissioned blockchain through the lighter PoA validators among a small set of replicas inside the network. We deploy the Hyperledger Fabric and Ethereum PoA platform in a local network in our laboratory, and well as in a decentralized production wireless mesh network that is part of Guiﬁ.net. Our key contributions are summarized as follows: First,weanalyzetheperformanceofbothplatformsintermsofmetricssuchastransactionlatency,CPUandmemoryuti lizationofHyperledgerFabricandEthereumPoAcomponents.Tothebestofourknowledge,thisistheﬁrstHyperledger Fabric and Ethereum PoA deployment made in a production wireless mesh network. Our results show that both Hyper ledgerFabricandgethEthereumPoAnetworkcanbedeployedonevenresourceconstraineddeviceslikeRPI3boardsor ahttps://guiﬁ.net/ bhttps://fundacio.guiﬁ.net/Foundation chttps://www.hyperledger.org/projects/fabric dhttps://www.ethereum.org/A R Kabbinale ET AL 3 routerboardswithlimitedcomputationalcapability.Boththeblockchainsoftwarestacksperformwellwithoutsaturation and much delays for a moderate load of up to 100 transactions ﬁred in the network at a time. In Hyperledger Fabric, our measurementsrevealthatendorsersarethebottleneckandcarehastobetakenindesigningendorsementpolicyforscal ing the network. In case of Ethereum PoA, our results show that a there is a limit on the number of requests a node can support and can only be scaled vertically i.e. by increasing computational capability of serving node. Second,drivenbytheﬁndingsinameshnetwork,weproposeaplacementschemeforHyperledgerFabricandEthereum PoA components that optimizes the performance of the blockchain components in mesh networks. The rest of the paper is organized as follows. In Section 2 we brieﬂy discuss the target blockchain platforms, Hyperledger Fabrics and Ethereum, and the way how their protocol works. In Section 3 we describe and characterize the performance of the QMPSU mesh network and testbed where our experiments are performed. In Section 4 the performance of Hyperledger Fabrics and Ethereum platform is presented and our main ﬁndings are discussed. Section 5 describes related work and section 6 concludes and discusses future research directions. 2BLOCKCHAIN: THE UNDERPINNING TECHNOLOGY Blockchain is an appendonly immutable data structure. Its ﬁrst incarnation was in the Bitcoin cryptocurrency network4. Blockchain was used to enable trust in ﬁnancial transactions among diﬀerent nontrusting parties in a pure peertopeer fash ion without the need for going through a third ﬁnancial party like e.g., a bank. Such trust is provided in terms of immutability of blockchain’s data structure. Each blockin blockchain contains information that is immutable. The immutability aspect is renderedtruebyincludingthehashofallthecontentsofablockintothenextblockwhichalsochainstheblockstogether.Tam pering with one block disturbs the contents of all the following blocks in the chain. Each block in the chain is appended after a consensus is reached among all the peers of the network. The same version of a blockchain is stored in a distributed manner at all the peers of the network. That is why it is sometimes referred to as distributed ledger as well. In this section, we brieﬂy discuss two blockchain platforms chosen for evaluation of economic compensations among con sumers and providers of connectivity in wireless mesh networks, as automated calculations with irreversible transactions and moneytransfers,sharedacrossseveralparticipants.TheseareHyperledgerFabricandEthereum,duetotheirpopularity,maturity and potential to be used in diﬀerent applications. 2.1Permissionless vs Permissioned, Public vs Private Bitcoin4andEthereum7,asvariousotherblockchains,areconsideredas permissionless ,meaningthatanyonehas""write""access to the blockchain. As a result anyone can be a part of the network, mining and performing transactions with other parties. The consensus in such an open environment is tackled with algorithms like the ProofofWork(PoW) protocol. A potential for anonymity and privacy is also at the heart of such platforms. A user (or in general an entity) usually uses the hash of its public key as pseudonym or a zeroknowledge protocol as opposed to using its realworld name or details. In the aspect of ""write"" openness, permissioned blockchains are in sharp contrast with public blockchains which we discuss next. Permissioned blockchains, a concept particularly popularized by the Linux Foundation’s Hyperledger, are usually con sidered for business applications. In such applications the identity of users, in addition to trusted and immutable data storage, is also important such as the stringent requirement of know your customers for many businesses. Hyperledger tries to leverage the best of both worlds by implementing a cryptographic membership service on top of blockchain’s trusted, immutable, and distributed record keeping. Another categorization can be done based on the openness of reading from the blockchain. In the case where a blockchain exposes its data publicly it is characterized as public. On the other hand, blockchains that prohibit access to its data are called asprivate. In our study, the requirement of both users’ identity and trusted record keeping is of paramount importance and that is why we decided to conduct our study using private permissioned blockchains. Hyperledger Fabric fulﬁlls by default these prop erties. On the other hand, while Ethereum is not primarily destined to serve these purposes, it can also be used as private permissionedblockchain.Nevertheless,executingresourcefullconsensusalgorithmsinapermissionedenvironmentwherethe4 A R Kabbinale ET AL participants are known has no application except experimentation with the protocols themselves. On the other hand, some pro tocols, like Ethereum, oﬀer inexpensive consensus algorithms, like the ProofofAuthority (POA) protocol, that are ideal for a private permissioned instances, as envisaged in our scenario. 2.2Hyperledger Fabric (HLF) Hyperledger Fabric (HLF)8is an open source implementation of a permissioned blockchain network that executes distributed applicationswritteningeneralpurposeprogramminglanguages(e.g.,Go,Javaetc).HLF’sapproachismodular,whichimplies that the platform is capable of supporting diﬀerent implementations of its diﬀerent components (such as diﬀerent consensus protocols) in a plugandplay fashion. The HLF architecture comprises of the following components: Peers:Peers can further be of two types namely endorsers andcommitters . A peer is called a committer when it maintains a local copy of the ledger by committing transactions into its blocks. A peer assumes the role of an endorser when it is also responsible for simulating the transactions by executing speciﬁc chaincodes and endorsing the result (see the next subsection 2.2.1). A peer can be an endorser for certain types of transactions and just a committer for others. Ordering service: The role of this component is to order the transactions chronologically by time stamping them to avoid the double spend problem4. The ordering service creates new blocks of transactions and broadcast them to the peers which then append these blocks to their local copy of the blockchain (or ledger). The ordering service can be implemented as a centralized or decentralized service9. It is at the ordering service level where the consensus (like proofofwork in Bitcoin4) related to the state of a blockchain takes place. Chaincode: Achaincodeora smartcontract isaprogramcodethatimplementstheapplicationlogic.Itisruninadistributed manner by the peers. It is installed and instantiated on the network of HLF peer nodes, enabling interaction with the network’s shared ledger (i.e., the state of a database modeled as a versioned key/value store). Channel: Achannelprovidesahigherlayerofconﬁdentialityabstraction.Achannelcanbeconsideredasasubnetontopofa largerblockchainnetwork.Eachchannelhasitsownsetofchaincodes,memberentities(peersandorderers),andadistinct versionofadistributedledger.Thisshouldnotbeconfusedwithasimilarterm,paymentchannels,usedtomakemultiple oﬀchain micropayments, multiple transactions, without committing all to a blockchain. Membership service provider (MSP): HLF makes use of a dedicated and exhaustive Membership Service Provider (MSP)e, whichisbasedonpublickeyinfrastructure(PKI)andhierarchicalcertiﬁcateauthorities(CAs),todeﬁnerolesandsecurity clearance(fordiﬀerentchannels)ofdiﬀerententitiesforaparticularusecase.ThegoalofsuchadedicatedMSPistoreal ize the concept of an organizationlikehierarchical security infrastructure in the form of a hierarchical and permissioned version of blockchain. 2.2.1HLF Protocol Figure1depictsthesequenceoftransactionexecutionstepsinHLF’senvironment.Thedescriptionoftheseexecutionstepsare as follows: 1. Transaction (Tx) proposal: In this step clients access the HLF blockchain to submit a proposal for a Tx to be included in one of the blocks of the HLF blockchain. Clients propose a transaction through an application that uses an SDK’s (Java, Python etc) API. This is shown as the ﬁrst step in Figure 1. 2. Endorsement and Tx simulation: The transaction proposal from the above step is then broadcasted to the endorsing peer nodes in the HLF blockchain network. Each endorsing peer veriﬁes the Tx proposal in terms of its correctness (i.e., its structure, the signatures that it contains, and the membership and permission status of the client that submits the transaction) and uniqueness (i.e., this proposal was not submitted in the past). After the above checks comes the transaction simulation step . Endorsing peers invoke a relevant chaincode (as speciﬁed in the Tx proposal by the submitting client). The execution (as per speciﬁc arguments speciﬁed in Tx proposal) of this ehttps://hyperledgerfabric.readthedocs.io/en/release1.3/membership/membership.htmlA R Kabbinale ET AL 5 Ordering Service ClientPeer 1Peer 2Peer 3Endorsing PeersOrdering  nodes Client generates a  Tx proposalSimulate/Execute Tx, endorse YES/NO Collect endorsementAssemble endorsement into a Tx. Send Tx to Ordering ServiceOrder Tx & create a block. Send  block to all peers in the channel Verify endorsement  and readsetNotify client whether Tx  was valid or invalid12 345 67 FIGURE 1 Hyperledger Fabric Protocol chaincode produces an output against the current state of the database (ledger). Without updating the ledger’s state, the output of the Tx simulation is sent back in the form of proposal response to the client through the SDK. In Figure 1 this is shown by the second step. 3. Inspection of proposal response: After the above step the clientside application collects the responses from the endorse mentstep.Afterwardsalltheresponsesarecrosschecked(intermsofthesignaturesoftheendorsingpeersandthecontent of the responses) to determine if there are any disparities among the content of the responses. If the content of all the responsesarethesameandaccordingtothepredeﬁned endorsementpolicy (i.e.,numberofpeerswhoseendorsements— intermsoftheirsignatures—arenecessary)thentheclientsubmitsthisTxtotheOrderingService(moreonitinthenext step) that will in turn ultimately update the ledger’s state as per the Tx simulation outcome in the last step. It can also happen that in the Tx proposal, made in the last step, only the current state of the ledger was queried. In this casetherewillbenoneedtoupdatealedger’sstateandhencethereisnosubmissiontotheOrderingServicebytheclient. In Figure 1 this is shown by step three. 4. Tx submission to the Ordering Service: TheOrderingServicecollectsvariousTxsafterthelaststepviavariouschannels. This is step four in Figure 1. 5. Tx ordering: OrderingService ordersvariousTxsaccordingtotheirreceivingtimes.ThisorderedsetofTxsisthenincluded inablock,speciﬁctoachannel,whichwilllaterbeappendedtothechannel’sledger.ThisiscoveredbystepﬁveinFigure 1. 6. Tx validation and committing: In this stage all the peers belonging to a particular channel receive a block containing Txs speciﬁc to this channel. Each peer then checks all the Txs in terms of their validity. Valid Txs are those that satisfy an endorsementpolicy.IftheTxspassthevaliditytestthentheyaretaggedasvalidotherwiseinvalidinablockandthenthis block is ﬁnally appended to the ledger maintained by the peers of this channel. This is covered by step six in Figure 1. 7. Ledger update notiﬁcation: Finally, after the ledger update in the last step the client of the submitting Tx is notiﬁed about the validity or invalidity of the Tx that was included in the latest block of the channel’s distributed ledger. This is step seven in Figure 1. 2.3Ethereum Ethereumisanopensourceblockchainplatformthatcanbeusedinapublicorprivatesettingandaddstheprovisionofbuilding decentralized valuetransfer applications (DApps). Ethereum builds upon the Bitcoin system and introduces the concept of EthereumVirtualMachine(EVM).EVMimplementstheEthereumprotocol(discussednext)whichisresponsibleforhandling6 A R Kabbinale ET AL the state transitions and associated computations without the involvement of third party intermediaries. The logic that powers a DApp is written in the form of a set of computer programs, so called smart contracts , that are being executed by the EVM. Theconceptofasmartcontractcanbeunderstoodasthealgorithmicenforcementofpolicyagreementsamong,oftenmutually nontrusting,peersofaconsortium7.AsetofsmartcontractsforaDApp,inturn,canbeconsideredasastatemachine,whichis executedbytheEVMofalltheparticipatingnodes.WhilethemainEthereumplatformisapublicblockchainnetwork,thecore platformsoftwareisopensourceandallowsdeveloperstoconﬁgureanddeployaprivateandpermissionedblockchainnetwork (test networks) where only authorized nodes are allowed to participate. 2.3.1Ethereum Protocol In Ethereum’s ecosystem, there are two main types of entities namely: i) an externally owned account (EOA) with an address and a ii) smart contract written in a contractspeciﬁc programming language, such as Solidity, and is compiled into byte code which gets executed by an EVMf. In addition to an EOA, a smart contract is also assigned an address when it is deployed on theblockchain,however,itisusedinanuancedmannerwhencomparedtotheaddressusageofanEOA.Anyoneinpossession of an EOA’s address credentials can make a valuetransfer transaction with another EOA by specifying its blockchain address. In such transfers the overall systems’ state remains unchanged. However, in contrast, it is also possible for an EOA to make a transaction with a smart contract. In these types of transactions a speciﬁc function of a smart contract is invoked that usually triggersastatechangeintheoverallEVM.Itisalsopossiblethatonesmartcontractinvokesafunctionofanothersmartcontract possibly executing another associated EVM. It should be noted here that in Ethereum, each time a piece of code is invoked for execution(suchasasmartcontract’sfunction)allthenodesofthenetworkexecutethesamepieceofcodeensuringthecorrect executionofaprogram’slogic.Thestatechange,inturn,isthenrecordedinadecentralizedmannerintheformofmined(more on mining later), which are mutually agreedupon, blocks ensuring immutability of such records. This way Ethereum enables a trusted and decentralized environment to automate a consortiumbased application with trusted valuetransfer transactions among the (potentially mutually nontrusting) peers of such a consortium. Looking closely, a transactionbased state change in Ethereum’s ecosystem can be understood with the help of Eq. 17. t+1"
396,Enhanced Cluster Based Routing Protocol for MANETS.txt,"Mobile ad-hoc networks (MANETs) are a set of self organized wireless mobile
nodes that works without any predefined infrastructure. For routing data in
MANETs, the routing protocols relay on mobile wireless nodes. In general, any
routing protocol performance suffers i) with resource constraints and ii) due
to the mobility of the nodes. Due to existing routing challenges in MANETs
clustering based protocols suffers frequently with cluster head failure
problem, which degrades the cluster stability. This paper proposes, Enhanced
CBRP, a schema to improve the cluster stability and in-turn improves the
performance of traditional cluster based routing protocol (CBRP), by electing
better cluster head using weighted clustering algorithm and considering some
crucial routing challenges. Moreover, proposed protocol suggests a secondary
cluster head for each cluster, to increase the stability of the cluster and
implicitly the network infrastructure in case of sudden failure of cluster
head.","Mobile ad hoc networks (hereinafter, MANETs) are infrastructure less self organizing  networks, formed arbitrarily by mobile hosts using wireless links, and the union of  which forms a communication network. Routing protocol provides communication  beyond the physical w ireless range of nodes by relaying on intermediary nodes [1].   Due to the mobility of nodes, the network topology changes frequently, hence, nodes  do not familiar with topology of their network.  Each node learns about neighbor   nodes by listening announcem ents (using broadcasting of packets) of other nodes [2].  Due to the existing constraints of MANETs, routing should be resource saving.  Clustering is one approach to reduce traffic during the routing process, and several  authors proposed cluster based routi ng protocols [1, 3 5]. All the nodes are grouped  into clusters and each cluster has one cluster head in addition to many gateways; the  cluster head is responsible for its cluster member, whose rebroadcast can cover all  nodes in that cluster.   One of the lea ding protocols in MANET is Cluster Based Routing Protocol  (CBRP), proposed by [3]. CBRP is an on demand routing protocol, where nodes are divided into clusters. Initially each node in the network has undecided state. Node  starts timer and broadcasts HELLO packet. If it receives a Hello reply from any  cluster head then sets it state as cluster member else it makes itself as cluster head but  only when it has bidirectional links with one or more neighbor  nodes. Otherwise it  repeats the procedure with sending H ELLO packets.   Clustering is the process that divides the network into interconnected substructures,  called clusters. Each cluster has a cluster head and act as a coordinator within the  substructure. Each cluster head, in other terms acts as a temporary bas e station within  its zone or cluster and communicates with its peers. Clustering algorithm used in  CBRP is a variation of simple “lowest ID ” clustering algorithm in which the node  with a lowest ID among its neighbors  is elected as the Cluster head. Each No de  maintains neighbor  table and cluster adjacency table which help to has knowledge of  network topology.   This paper proposes a new schema for electing cluster heads by considering factors  viz., node mobility, power, transmission range and degree of node, a nd also suggests  a secondary cluster head which improves the performance of CBRP, to make the  system fault tolerant.   The rest of paper is organized as follows: section 2 presents related work on  routing protocols. Section 3 describes the proposed Enhanced CBRP (hereinafter,  ECBRP) algorithm and section 4 presents ECBRP evaluation and results analysis.  Finally section 5 concludes and directs for future study.   2   Related Work   "
113,An Optimal Game Theoretical Framework for Mobility Aware Routing in Mobile Ad hoc Networks.txt,"Selfish behaviors are common in self-organized Mobile Ad hoc Networks
(MANETs) where nodes belong to different authorities. Since cooperation of
nodes is essential for routing protocols, various methods have been proposed to
stimulate cooperation among selfish nodes. In order to provide sufficient
incentives, most of these methods pay nodes a premium over their actual costs
of participation. However, they lead to considerably large overpayments.
Moreover, existing methods ignore mobility of nodes, for simplicity. However,
owing to the mobile nature of MANETs, this assumption seems unrealistic. In
this paper, we propose an optimal game theoretical framework to ensure the
proper cooperation in mobility aware routing for MANETs. The proposed method is
based on the multi-dimensional optimal auctions which allows us to consider
path durations, in addition to the route costs. Path duration is a metric that
best reflects changes in topology caused by mobility of nodes and, it is widely
used in mobility aware routing protocols. Furthermore, the proposed mechanism
is optimal in that it minimizes the total expected payments. We provide
theoretical analysis to support our claims. In addition, simulation results
show significant improvements in terms of payments compared to the most popular
existing methods.","Mobile Ad hoc Networks (MANETs) are dynamically reconﬁgura ble wireless networks in which mobile nodes communicate with each other without th e need for any ﬁxed infrastructure. In recent years, with proliferation of mob ile communicating devices, MANETs have attracted a lot of attention. In these networks, each node can transmit data directly to nodes within its transmission range. To com municate with distant nodes, cooperation of intermediate nodes is essential. Many existing protocols have taken it for granted that all no des are cooperative. This assumption, however, is reasonable only in situations that all mobile nodes belong to the same authority and share a common goal (such as militar y situations). Since cooperation will incur costs to a node, in many applications nodes are not willing to cooperate unless they beneﬁt from participation. These nod es, who seek to maximize their proﬁt, are called selﬁsh nodes. In ad hoc routing, for instance, a selﬁsh node may choose not to forward packets for other nodes so as to save lim ited resources, such as battery power. To cope with the selﬁsh behaviors, two general approaches ha ve been proposed; namely reputation based methods and pricing based methods. In reputation based methods [1]–[3], the behavior of nodes are monitored in orde r to punish noncooperative nodes. Pricing based methods [4]–[15], however, take a proa ctive approach. They pro vide incentive for selﬁsh nodes to act cooperatively by payi ng them in compensation. Although these approaches have been studied widely, there a re several key issues to be considered. One critical issue which has been neglected in existing meth ods, is the mobility of nodes. In MANETs, as its name suggests, nodes are mobile. The refore, link breakage •Mehrdad Khaledi is with Computer and Systems Engineering De partment, Rensselaer Polytechnic Institute. Email: khalem@rpi.edu. •Mojgan Khaledi is with School of Computing, University of Ut ah. Email:mojgankh@cs.utah.edu. •Hamid R. Rabiee is with Department of Computer Engineering, Sharif University of Technology, Tehran, Iran. Email: rabiee@sharif.edu August 22, 2018 DRAFT3 between neighbors occurs repeatedly, which in turn may lead to signiﬁcant performance degradation in such protocols [16], [17]. To cope with this, several mobility aware protocols have been proposed [18]–[20]. In these protocols , mobility prediction methods are utilized to predict durations of each route. In this way, the adverse effects of node mobility can be minimized. For example, in ad hoc routing, by predicting path dura tions, more stable routes can be chosen for data transmissio n. Consequently, number of route discoveries, which are accompanied by some delay and o verhead, are reduced. However, none of these protocols consider selﬁsh behaviors . In fact, they assume that all nodes act cooperatively. Furthermore, most current pricing based methods pay selﬁsh nodes considerably more than their actual costs of participation. In order to st imulate nodes to cooperate, paying premiums over their actual costs is inevitable. Howe ver, the sum of these pre miums, called overpayments , can raise uncontrollably. Therefore, it is desirable to re duce overpayments as much as possible. Motivated by the abovementioned issues, in this paper we pr opose a pricing based method for mobility aware routing in MANETs. Our method is ba sed on the multi dimensional optimal auctions [21] which allows us to consid er path durations in addi tion to route costs, when selecting the winner route. Moreov er, the proposed mechanism minimizes the total expected payment over all mechanisms. The contributions of this paper are as follows. First, we int roduce a multidimensional auction to stimulate cooperation among the selﬁsh nodes. Th e proposed auction uses Bayesian Nash equilibrium which ensures truthful bidding. In this auction, each bid consists of two values: predicted path duration of the route and its cost of forwarding packets. Since the auctioneer (destination node) knows the path duration of the winner route, it can hold the auction again just before the current r oute breaks. Therefore, by using the predicted path durations in adaptive holding of au ctions, the unpleasant effects of mobility can be reduced. Furthermore, holding au ction between different routes helps us to pay fewer premiums. To the best of our knowl edge, this is the ﬁrst multidimensional mechanism introduced to provide incent ive in MANETs. Moreover, none of the pricing based methods have considered mobility a ware routing. Second, the proposed mechanism is optimal with regard to the payments [2 2]. Owing to the selﬁsh August 22, 2018 DRAFT4 nature of nodes, providing incentives will cost more than ac tual costs incurred by the packet forwarding. We optimize the total expected payments in our proposed auction. In other words, the sum that auctioneer has to pay is minimize d. Third, a proﬁt sharing mechanism is proposed to ensure cooperation among the nodes of the winner route. The rest of this paper is organized as follows. Section 2 prov ides a categorization along with the review of existing methods. In addition, we present some relevant concepts in this section. Section 3 is devoted to the system model used in this paper. In section 4, we present the proposed method in detail. Simulation result s are reported in section 5. Finally, the concluding remarks are provided in section 6. 2 RELATED WORK "
217,Papillon: Greedy Routing in Rings.txt,"We study {\sc greedy} routing over $n$ nodes placed in a ring, with the
\emph{distance} between two nodes defined to be the clockwise or the absolute
distance between them along the ring. Such graphs arise in the context of
modeling social networks and in routing networks for peer-to-peer systems. We
construct the first network over $n$ nodes in which {\sc greedy} routing takes
$O(\log n / \log d)$ hops in the worst-case, with $d$ out-going links per node.
Our result has the first asymptotically optimal greedy routing complexity.
Previous constructions required $O(\frac{\log^2 n}{d})$ hops.","We study greedy routing over unidimensional metrics1deﬁned over nnodes lying in a ring. greedy routing is the strategy of forwarding a message along that ou tgoing edge that minimizes the distance remaining to the destination: Definition (Greedy Routing) .In a graph (V,E)with a given distance function δ:V×V→ R+, greedy routing entails the following decision: Given a target node t, a node uwith neighbors N(u)forwards a message to its neighbor v∈N(u)such that δ(v,t) = min x∈N(u)δ(x,t). Twonaturaldistance metrics over nnodes placed in a circle are the clockwisedistance and the a bsolute distance between pairs of nodes: δclockwise(u,v) =/braceleftBigg v−u v ≥u n+v−uotherwise δabsolute(u,v) =/braceleftBigg min{v−u,n+u−v}v≥u min{u−v,n+v−u}otherwise In this paper, we study the following related problems for th e above distance metrics: I. Given integers dand∆, what is the largest graph that satisﬁes two constraints: th e outdegree of any node is at most d, and the length of the longest greedy route is at most ∆hops? II. Given integers dandn, design a network in which each node has outdegree at most dsuch that the length of the longest greedy route is minimized. ∗School of Computer Science and Engineering, Hebrew Univers ity of Jerusalem, Israel. EMail: ittaia@cs.huji.ac.il †Microsoft Research, Silicon Valley and School of Computer S cience and Engineering, Hebrew University of Jerusalem, Israel. EMail: dalia@microsoft.com ‡Google Inc., USA. Email: manku@google.com 1The principles of this work can be extended to higher dimensi onal spaces. We focus on onedimension for simplicity. 1Summary of results 1. We construct a family of network topologies, the Papillon2, in which greedy routes are asymp totically optimal. For both δclockwise andδabsolute, Papillon has greedy routes of length ∆ = Θ(logn/logd) hops in the worstcase when each node has doutgoing links. Papillon is the ﬁrst construction that achieves asymptotically optimal worst casegreedy routes. 2. Upon further investigation:, two properties of Papillon emerge: (a) greedy routing does not send messages along shortest paths, and (b) Edge congestion with greedy routing is not uniform – some edges are used more often than others. We exhibit the ﬁrs t property by identifying routing strategies that result in paths shorter than those achieved bygreedy routing. In fact, one of these strategies guarantees uniform edgecongestion. 3. Finally, we consider another distance function δxor(u,v), deﬁned as the number of bitpositions in which uandvdiﬀer.δxoroccurs naturally, e.g., in hypercubes, and greedy routing with δxor routesalongshortestpathsinthem. Weconstructavarianto fPapillonthatsupportsasymptotically optimal routesof length Θ(log n/logd) intheworstcase, for greedy routingwithdistancefunction δxor. 2 Related Work "
227,Geographic Routing Around Obstacles in Wireless Sensor Networks.txt,"Geographic routing is becoming the protocol of choice for many sensor network
applications. The current state of the art is unsatisfactory: some algorithms
are very efficient, however they require a preliminary planarization of the
communication graph. Planarization induces overhead and is not realistic in
many scenarios. On the otherhand, georouting algorithms which do not rely on
planarization have fairly low success rates and either fail to route messages
around all but the simplest obstacles or have a high topology control overhead
(e.g. contour detection algorithms). To overcome these limitations, we propose
GRIC, the first lightweight and efficient on demand (i.e. all-to-all)
geographic routing algorithm which does not require planarization and has
almost 100% delivery rates (when no obstacles are added). Furthermore, the
excellent behavior of our algorithm is maintained even in the presence of large
convex obstacles. The case of hard concave obstacles is also studied; such
obstacles are hard instances for which performance diminishes.",1.1 Background on Sensor Networks and Geographic Routing . . . . . . . . . . . . . . . 1 1.2 Localization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3 Our approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.3.1 Methodology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 
416,CoSec-RPL: detection of copycat attacks in RPL based 6LoWPANs using outlier analysis.txt,"The IPv6 routing protocol for low-power and lossy networks (RPL) is the
standard routing protocol for IPv6 based low-power wireless personal area
networks (6LoWPANs). In RPL protocol, DODAG information object (DIO) messages
are used to disseminate routing information to other nodes in the network. A
malicious node may eavesdrop DIO messages of its neighbor nodes and later
replay the captured DIO many times with fixed intervals. In this paper, we
present and investigate one of the severe attacks named as a non-spoofed
copycat attack, a type of replay based DoS attack against RPL protocol. It is
shown that the non-spoofed copycat attack increases the average end-to-end
delay (AE2ED) and packet delivery ratio of the network. Thus, to address this
problem, an intrusion detection system (IDS) named CoSec-RPL is proposed in
this paper. The attack detection logic of CoSec-RPL is primarily based on the
idea of outlier detection (OD). CoSec-RPL significantly mitigates the effects
of the non-spoofed copycat attack on the network's performance. The
effectiveness of the proposed IDS is compared with the standard RPL protocol.
The experimental results indicate that CoSec-RPL detects and mitigates
non-spoofed copycat attack efficiently in both static and mobile network
scenarios without adding any significant overhead to the nodes. To the best of
our knowledge, CoSec-RPL is the first RPL specific IDS that utilizes OD for
intrusion detection in 6LoWPANs.","In the recent years, Internet of Things (IoT) has been a major player among various evolving networking paradigms [8, 69, 6]. Internat ional Data Corporation 1Department of Computer Engineering, National Institute of Technology Kurukshetra, India Email:∗abhiverma866@gmail.com Email: virender.ranga@nitkkr.ac.in 1The ﬁnal publication is available at https://link.springe r.com/article/10.1007/s11235020 00674w2 Abhishek Verma1,∗, Virender Ranga1 (IDC) predicted that there will be 41.6 billion connected Io T devices worldwide by 2025 [24]. While, worldwide spending on IoT is expected to cross the $1 trillion mark in 2022 [23]. With this much expansion of IoT, the securi ty issues related to it are also expanding. The increase in the number of IoT dev ices also increases the number of incredible risks. These risks primarily inclu de users’ security and privacy getting exposed to cyber attacks [45, 5, 3, 72, 70]. I n the present scenario, many IoT applications are deployed on IPv6 over LowPower Wi reless Personal Area Networks (6LoWPANs). The 6LoPWAN concept enables Inte rnet Protocol (IP) on tiny devices, i.e., embedded devices with limited pr ocessing power, small onboard memory, and limited energy resources. 6LoWPAN is ba sed on Low Power and Lossy Networks (LLNs), which have high packet loss and lo w throughput communication links [41, 67]. LLNs are realized by resource constrained devices which operate on very low power, to support longer network li fetime [40]. The characteristics of LLNs like resource constrained nature, high packet loss, and low network throughput make traditional routing protocols unsuitable for LLN [54]. To solve this issue, the IPv6 Routing Protocol for Low Power and Lossy Networks (RPL) was standardized (RFC 6550) [67]. The RPL pro tocol provides energy eﬃcient routing in LLNs. However, the RPL protocol re mains exposed to various cyber attacks,which may jeopardizeusers’ securit yand privacy [50, 60, 59, 58]. The critical applications like healthcare and smart gr id, when becoming the targetofsuchthreats,mayresultinlifethreateninginci dents.Thismotivatedusto explore and perform an indepth analysis of one such threat ( i.e., copycat attack) and design a defense mechanism to detect and mitigate it. The vulnerabilities and threats associated with the RPL protocol have been rigorous ly studied by cyber security researchers [62, 2]. In this paper, the main focus i s on a replay mechanism based routing attack which is known as copycat attack, that a ﬀects the Quality of Service (QoS) of realtime wireless networks. According to standard RPL speciﬁcation (RFC 6550), the RPL p rotocol sup ports a secure mode to provide integrity and conﬁdentiality to data and control packets. The secure mode incorporates traditional cryptog raphy mechanisms to enable security and privacy [16]. However, the standard RPL speciﬁcation does not specify any details of secure key management, which rest ricts the usage of cryptography in resource constrained devices [32, 49, 44]. Moreover, the tradi tional cryptography based security methods (e.g., Public key and Symmetrickey cryptography) consume a lot of computing resources, degrad e the network’s per formance, and reduce the lifetime of IoT networks [51]. The R PL protocol is un protected from cyber attacks (e.g., routing attacks), wher e an attacker node can exploit its vulnerabilities to compromise the legitimate n odes. The attacks may degrade the network’s overall performance signiﬁcantly, w hich consequently, af fects the operation of IoT applications. One such destructi ve attack is termed a copycat attack, a type of replay mechanism based direct atta ck that targets the legitimate node’s resources. It is a DenialofService (Do S) attack, which has the ability to severely degrade the performance of 6LoWPANs. To launch this attack, an attackernode eavesdrops DODAG InformationObject (DIO) messages of legit imates neighbor nodes, and later sends the previouslyeaves dropped DIO messages many times with ﬁxed replay interval. In this manner, the att acker introduces a high level of congestion and interference in the network, wh ich leads to the cre ation of suboptimized routes. Moreover, the attack also fo rces nodes to transmit DIO messages unnecessarily and performs unessential routi ng related operations.Detection of nonspoofed copycat attacks 3 The copycat attack can be achieved even without stealing cry ptography keys of legitimate nodes, which gives a signiﬁcant advantage to the attacker (outsider at tack scenario). Moreover, an attacker does not need to have a ny high range radio antenna or any other specialized hardware to perform copyca t attacks. The major problem with 6LoWPANs is that the resource constra ined devices lack builtin security. Moreover, the RPL protocol does not have any inbuilt Intru sion Detection System (IDS) to provide any defense against c yber attacks. Most importantly, there is no builtin security mechanism to pro vide defense against routing attacks, which are very common in wireless networks . Therefore, in this research paper, a new Outlier Detection (OD) [28, 25] based I DS named as CoSec RPL (abbreviation of “copycat secured RPL protocol”) is pro posed to detect copycat attack. CoSecRPL detects the malicious neighbors and blocks all fur ther communications from it. The main idea behind our propos ed IDS is to use the OD mechanism to detect neighbors with abnormal behavior . CoSecRPL has ﬁve majoradvantages. Firstly,it does not introduce any com municationoverhead. Secondly, it does not require any good network trace for mode l training. Thirdly, its performance improves with time. Fourthly, it does not im pose any signiﬁcant memory overhead on the nodes. Fifthly, it can be easily exten ded to detect other RPL speciﬁc routingattacks.Major contributionsof the pap er can be summarized as: 1. The impact of copycat attacks on RPL is analyzed through si mulations. 2. AnIDS,namedCoSecRPL,targetingnonspoofedcopycata ttacksispresented and veriﬁed through simulations. The next section of this paper presents a brief overview of RP L protocol, copy cat attack, and outlier detection. In Section 3, relevant wo rks are discussed. The proposed solution is described in Section 4. A discussion on performance evalua tion of the proposed solution is presented in Section 5. Some possible extensions of proposed solution are discussed in Section 6, and ﬁnally w e conclude the paper in Section 7. 2 Background In this Section, we describe the RPL protocol, copycat attac k, and outlier detec tion. 2.1 Overview of RPL Protocol In this section, building elements, control messages, and f ault tolerance mecha nisms of the RPL protocol are discussed. 2.1.1 Building Elements of RPL –DODAG: RPL is founded on the idea of Directed Acyclic Graphs( DAGs) [13]. InRPL,theIoTdevicesarelogicallyinterconnectedwithea chotherusingmesh and tree topology.In DestinationOriented Directed Acycli c Graph (DODAG), the root node (gateway)acts as an interface between 6LoWPAN nodes and the4 Abhishek Verma1,∗, Virender Ranga1 Border router (6BR)  aaaa::1   aaaa::2  aaaa::3   aaaa::4  aaaa::5  aaaa::6  aaaa::7   aaaa::N3 Sensor node  aaaa::N2 aaaa::N1  aaaa::N  User Internet  6LoWPAN network  Fig. 1: An example of RPL DODAG with N nodes Internet. A network may contain more than one DODAG, which co llectively forms an RPL Instance and uniquely identiﬁed by RPL Instance ID. In a net work, more than one RPL Instance may run at a time. An RPL node m ay be associated with only one DODAG per RPL Instance. Each node of a DODAG is assigned a rank which represents “the node’s individual p osition relative to other nodes with respect to a DODAG root” [67]. The rank conce pt is imple mented in RPL: (1) to detect and avoid routing loops; (2) to bu ild parentchild relationships; (3) to provide a mechanism for nodes to diﬀer entiate between parent and siblings; (4) to enable nodes to store a list of pre ferred parents and siblings which can be utilized during link repair. DODAG is built during the network topology setup phase, during which each node use s RPL control messages to ﬁnd the optimal set of parents towards the root an d link itself with the preferred parent. The selection of preferred paren ts is based on an Objective Function (OF). The OF deﬁnes the procedure for ran k computation from routing metrics and selection of optimal routes in DODA G. RPL may use diﬀerent OF as per the application’s requirement. Some c ommon OF are ETX Objective function [17], Minimum Rank with Hysteresis O bjective Func tion (MRHOF) [18], and Objective Function Zero (OF0) [52]. R PL supports MultiPointtoPoint,PointtoMultipoint,and Pointt oPoint[13, 38] network topologies. An example of RPL DODAG with N Nodes having IPv6 a ddresses range from aaaa::1 to aaaa::N is shown in Fig. 1. –Control Messages: RPL deﬁnes a new category of ICMPv6 contro l messages known under Type 155 and deﬁned in [67, 1]. RPL control messag es include DODAG Information Object (DIO), DODAG Information Solicit ation (DIS), DestinationAdvertisementObject(DAO),and DestinationA dvertisementOb ject Acknowledgment (DAOACK). DIO message carries routin g information relevant to existing DODAG and allows other nodes to ﬁnd an RP L instanceDetection of nonspoofed copycat attacks 5 and its conﬁguration parameters. Also, it enables a node to s elect its preferred parent set and performs DODAG maintenance. DIS message is us ed to solicit a DIO message from an RPL node. It is used by the new or existing node to search for a nearby DODAG. DAO message is used to forward down wardroute information in the upward direction along the DODAG, ﬁnally reaching the root node. DAOACK message is a unicast packet send an acknow ledgmentby a DAO parent or DODAG root, in reply to a unicast DAO message [1 3]. –TrickleTimer:RPLusesanadaptivetimermechanismcalleda s“Trickletimer” in order to limit control traﬃc in the network [31]. RPL uses a dynamic mech anism to control the number of DIO messages sent by the resour ceconstrained nodes for minimizing energy consumption. Trickle timer dec ides when a node should multicast the DIO messages, and it gets reset in case o f inconsistency detectionin the network,i.e., loops and link loss, change i n parent set, etc. The interval of the trickle timer is increased, decreased in cas e of a stable network and inconsistency detection, respectively. In the case of a stable topology, the trickle timer interval is increased. Thus, the number of DIO sent are decreased, and when this interval is decreased, the number of DIO sent ar e increased in order to ﬁx the inconsistency issue [57]. 2.1.2 Fault Tolerance Mechanisms RPL deﬁnes some important network management mechanisms. I t fulﬁlls self healing characteristics by incorporating a DODAG repair me chanism (global and local), which are triggered during inconsistency detectio n, loop detection, and avoidance mechanisms to handle routing loops. Inconsisten cies include node fail ure, linkfailures,change in parentset,and routingloops. A loopmayoccur when a node, after losing all its parent, joins another node (makes parent) that was earlier in its subDODAG. Loop avoidance and loop detection mechani sms of RPL are contrary to those applied in traditional IP networks [68]. I n this section, various fault tolerance mechanisms are discussed. –Loop Avoidance: RPL deﬁnes two strict rules based on a rank pr operty for avoiding loops in the network. The ﬁrst rule is termed as “max depth rule”. It states that a node must not select a neighboring node as its parent whose rank is higher than its own rank. The second rule states that a node must not increase its rank by selecting nodes of higher rank as their p referred parent in order to increase its parent set size. –Loop Detection: Since loops are unavoidable in LLNs, hence t he need for loop detection mechanisms arises. RPL deﬁnes a mechanism to dete ct routing loops whenever they occur. A data path validation mechanism is use d by RPL to resolve routing loops. It involves setting and processing s ome speciﬁc bits con tained in the RPL routing header. RPL ensures that the packet s moving in the wrong direction are detected as a part of some loop. Loop reco very mechanism further involves resetting of trickle timer for repairing n etwork topology while discarding packets being received at that time. –Local Repair: RPL triggers the DODAG local repair mechanism in case of a node failure, link failure, and loop detection. Local repai r aims to rapidly ﬁnd an alternate parent/path (may not be optimal) without putti ng any global implication on entire DODAG.6 Abhishek Verma1,∗, Virender Ranga1 –Global Repair: When local repairs are found to be ineﬃcient w hile performing network recovery as they start diverging DODAG to a nonopti mal state due to the presence of many inconsistencies, then the whole DODA G needs to be rebuilt from scratch. Global repair is performed by incre menting DODAG versionnumber,which leads to the reconstructionof the who leDODAG,where nodes recompute their rank to form an optimal topology [22]. 2.1.3 RPL Modes Two modes of operations are supported by the RPL protocol in o rder to main tain downward routes. In this section, storing and nonstor ing mode of the RPL protocol [67, 13] are highlighted. –Storing mode: In the storing mode, downward routes start to p ropagate from leaf nodes to root node through intermediate router nodes. E very child node sends DAO message to its parent who initially stores informa tion contained in that message and later sends a new DAO message containing a ggregated reachability information to its parent. Thus, each node kno ws the path to every other node in the RPL network. –Nonstoring mode: In the nonstoring mode, leaf nodes unica st DAO message to the DODAG root node. Unlike storing mode, intermediate ro uter nodes do not store any information from DAO message; instead, they on ly append their address to it and forward to the parent. It is done to form a rev erse routing path. Thus, only the DODAG root knows a path to every node in th e network. 2.2 Copycat Attack The main target of the copycat attack is to degrade the routin g performance of RPL based 6LoWPANs so that the QoS of realtime applications gets aﬀected. In this, an attacker may compromise a legitimate internal node and reprogram it to introducethe highlevelofcongestionandinterferencein t henetwork.The attacker can also choose an outsider attack strategy to perform this a ttack. To launch a copycat attack, an attacker eavesdrops the DIO messages of n earby nodes, and later sends (multicast) the captured DIO message (with or wi thout modiﬁcation) many times with a ﬁxed replay interval. The copycat attack ca n be of two types: 1) nonspoofed; 2) spoofed. In “nonspoofed copycat attack ”, the eavesdropped DIO is sent after modifying the source IP of the ICMPv6 packet containing DIO message. The attacker sends the unmodiﬁed captured DIO with its own IP ad dress in the ICMPv6 packet, which forces the receiving (vict im neighbors) nodes to believe that the packet is from a legitimate sender and mak es them perform unnecessary routing related operations.Therefore, an att acker is able to drain vic tim’s resources and disrupts its normal packet forwarding b ehavior. The second type of copycat attack is termed as “spoofed copycat attack” . In this attack, the eavesdropped DIO is sent to neighbor nodes after replacing t he source IP address of encapsulating IPv6 packet with the IP address of legitima te DIO sender, i.e., the sender of eavesdropped DIO message. This makes the recei ver believe that the sender of DIO is its inrange neighbor. The victim nodes may e ven try to add the out of range neighbor, assuming that it leads to the optimal r oute to the gateway.Detection of nonspoofed copycat attacks 7 In simplewords,in nonspoofedcopycatattackthe adversar yuses itsIP addressas the source, and in spoofed copycat attack the adversary uses the source IP address of a legitimate node as a source. Both types of attacks introd uce heavy congestion and interference in their attack region, which consequentl y, decreases the Packet Delivery Ratio (PDR) and increases the Average EndtoEnd D elay (AE2ED) of the underlying network. The main diﬀerence between copycat attack and other replay attack variants (i.e., routing information replay a nd neighbor attack) lies in the frequency of replaying the packets and the packet ﬁeld being modiﬁed. In other RPL speciﬁc replay attacks,the attackerprimarilyai ms to introduce the un optimized or nonexisting paths in the network by merely rep laying the previously eavesdropped DIO packet after a certain period of time. In co ntrast, the copycat attacker focuses on the combination of the replay and interf erence method. The attack also forces legitimate nodes to make unnecessary DIO transmissions, which consequently, increases the control packet overhead of the network. Legitimate  Node XCopycat Attacker  Node Y Time DIO [source IP=X]Legtitmate  Node Z DIO [source IP=Y] DIO [source IP=Y] DIO [source IP=Y] DIO [source IP=Y] DIO [source IP=Y] DIO [source IP=Y] DIO [source IP=Y] DIO [source IP=Y]Eavesdrop  period Induces unnecessary  routing operations  at Node ZNonspoofed Copycat Attack Fig. 2: Attacker’s approach for launching nonspoofed copy cat attack Moreover,the standard RPL speciﬁcationstates that the lin k quality(e.g.,Ex pected Transmission Count) must be computed before adding a new node in the candidate parent set when MRHOF is used. Upon receiving the r eplayed DODAG Information Object (DIO) messages, a probing mechanism is i nitiated to asses the link quality. In this case, the probing fails because the rep layed source is not in the communication range of the node, hence the path is assume d to be bad and consequently, discarded [64]. Thus, the neighbor attack is ineﬀective if the nodes use ETXOF or MRHOF. Moreover, when an eavesdropped packet is frequently replayed multiple times with a ﬁxed interval, a heavy interf erence is introduced in the network region, i.e., an attacker’s communication rang e. Also, copycat attack with ﬁxed time interval keeps node busy continuously and con sequently, degrades the network’s performance. It is to be noted that a copycat at tack can also be performed with random intervals. However, the interval nee ds to be short in order to perform maximum damage to the network. Also, adding a mech anism to com pute random interval very frequently will impose computati onal overhead to the attacker node, thereby decreasing attacker node’s lifetim e. Considering the fact8 Abhishek Verma1,∗, Virender Ranga1 that the attacker’s primary target is to cause maximum damag e to the network, it will simply choose a shorter interval (ﬁxed value) and per form attack for longer time. In this study, we have considered the attack with ﬁxed i ntervals. Analysis and detection of copycat attack with random intervals will b e considered in our future work.” The copycat attacker node is programmed in suc h a way that it remains isolated (neither makes a parent nor becomes a paren t) from the network while only performing a replay attack. In this way, an attack er is able to reduce its own energy consumption rate for performing a longlasti ng attack. In case of spoofed copycat attack where an attacker uses source IP of on e or more legitimate nodes (i.e., like Sybil attack), the attack will be ineﬀecti ve if RPL is conﬁgured with MRHOF. Whereas in case the RPL is conﬁgured with OF0, the n the attacker will succeed in persuading legitimate nodes that it is a pote ntial parent. This is because the nodes do not check for neighbor reachability in case of OF0. In this paper, we have focused on nonspoofed copycat attack, and pr oposed an IDS to detect such attacks in RPL based 6LoWPANs. The nonspoofed c opycat attack is illustrated in Fig. 2. 2.3 Outlier Detection An outlier is deﬁned as “an observation (or subset of observa tions) which appears to be inconsistent with the remainder of that set of data” [9] . OD involves the detection and removal of outliers from the data. OD has been c ommonly used for a long time to detect anomalies present in the data. Outliers can arise in data due to intentional or unintentional software and hardware e rrors, e.g., data entry error. In machine learning, removing outliers is one of the p rimary tasks in data preprocessingtoleveragethequalityofapredictionorcla ssiﬁcationmodel.Indeed, OD is important to any quantitative discipline that needs a g ood quality of data. There are many OD methods available in the literature, and th e most popular one is known as the Interquartile Range (IQR). The standard devi ation around the mean can be used to detect outliers. However, mean and standa rd deviation are sensitive to outliers and may lead to incorrect results. Thi s problem is solved by the IQR method as it uses the median instead of the mean. The IQR is a measure of statistical dispersion based on divid ing data into quartiles. The value of IQR represents the middle 50% of sort ed data (ascend ing). IQR is calculated as in Eq. 1, where Q3,Q1 are third and the ﬁrst quartile, respectively. IQR=Q3−Q1 (1) To determine the IQR, ﬁrstly, the median (˜ x) of the data is computed. Then, the ﬁrst quartile ( Q1) and third quartile ( Q3) are computed. Q1, Q3 are the me dian of the lower and upper half of the data. After the computa tion ofQ1 andQ3, the IQR is computed using Eq. 1. In order to visualize the dist ribution of data for better analysis, box plots are used. Fig. 3 illustrates a n example of a box plot and probability density function of a normal distribution. The illustration visual izes the minimum, Q1, ˜x,Q3, and maximum value. Tukey et al.proposed to use 1.5×IQR (Tukey fences) as a demarkation line for outliers [21]. A s per 1.5 ×IQR rule, points below Lower limit , and points above Upper limit are considered asDetection of nonspoofed copycat attacks 9 outliers. The Lower limit ,Upper limit are calculated as in Eqs. 2 and 3, respec tively. The OD problem can be mapped to the intrusion detecti on problem of RPL based 6LoPWANs. Where, an outlier can be a node with abnormal behavior (i.e., malicious node) which needs to be identiﬁed and eliminated f or achieving better network performance. Lower limit =Q1−1.5×IQR (2) Upper limit =Q3+1.5×IQR (3) Q1 Q3IQR MedianQ3 + 1.5 × IQR Q1  1.5 × IQR"
316,QoS Routing and Performance Evaluation for Mobile Ad Hoc Networks using OLSR Protocol.txt,"Mobile Ad-Hoc network is a collection of mobile nodes in communication
without using infrastructure. As the real-time applications used in today's
wireless network grow, we need some schemes to provide more suitable service
for them. We know that most of actual schemes do not perform well on traffic
which is not strictly CBR. Therefore, in this paper we have studied the impact,
respectively, of mobility models and the density of nodes on the performances
(End-to-End Delay, Throughput and Packet Delivery ratio) of routing protocol
(Optimized Link State Routing) OLSR by using in the first a real-time VBR
(MPEG-4) and secondly the Constant Bit Rate (CBR) traffic. Finally we compare
the performance on both cases. Experimentally, we considered the three mobility
models as follows Random Waypoint, Random Direction and Mobgen Steady State.
The experimental results illustrate that the behavior of OLSR change according
to the model and the used traffics.","Mobile AdHoc Network (MANET) is a selfconfiguring  network of mobile nodes connected  using wireless links, forming a random topology. Th e nodes move freely and randomly. The  network's wireless topology may be unpredictable. T he minimal configuration, the quick  deployment and the absence of a central governing a uthority make ad hoc networks suitable for  several positions as the multimedia teleconferences , construction site, network residence and  military conflicts etc [1][4].  The Mobility models define nodes movement pattern i n ad hoc networks. The random  behaviour of these models as well as their implemen tations on the final ones (computer,  phone…), requires some researches on the evaluation  of routing protocols based on simulations.  The aim of a routing protocol is to discover the be st route that links up two nodes while  guarantying a QoS in communication [5]. The quick c hange and unpredictable of the topology      International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.2, No.2, June 2011  13   of MANET network according to the random mobility o f nodes, makes route research difficult  to the routing protocol.  It is clear that the service quality QoS [6] in MAN ET is not guaranteed because of the inherent  dynamic nature of a mobile ad hoc environment. In g eneral, the performances depend on the  routing mechanism and nature of mobility. In order to guarantee the QoS we should process to  deepened studies of evaluation regarding to find th e routing protocol and the mobility model  that are more adapted to an application. The QoS ca ll for some of the performance metrics as  the throughput, the endtoend delay and the jitter  etc.  Therefore many researches were carried  out on evaluation performances of the MANETs as, th e performance analysis of the different  routing protocols and the effect of the random mobi lity models on Ad Hoc networks [7][12].  The rest of this paper is organized as follows: In the next section, we survey related work. The  problem formulation is discussed in section 3, foll owed by the simulation environment used in  this study. The results obtained in this simulation  are also discussed in section 5. In the end,  section 6 completes the paper.  2.  Related Work   "
164,A Rigorous Analysis of AODV and its Variants.txt,"In this paper we present a rigorous analysis of the Ad hoc On-Demand Distance
Vector (AODV) routing protocol using a formal specification in AWN (Algebra for
Wireless Networks), a process algebra which has been specifically tailored for
the modelling of Mobile Ad Hoc Networks and Wireless Mesh Network protocols.
Our formalisation models the exact details of the core functionality of AODV,
such as route discovery, route maintenance and error handling. We demonstrate
how AWN can be used to reason about critical protocol correctness properties by
providing a detailed proof of loop freedom. In contrast to evaluations using
simulation or other formal methods such as model checking, our proof is generic
and holds for any possible network scenario in terms of network topology, node
mobility, traffic pattern, etc. A key contribution of this paper is the
demonstration of how the reasoning and proofs can relatively easily be adapted
to protocol variants.","Routing protocols are crucial to the dissemination of data packets between nodes in Wireless Mesh Networks (WMNs) and Mobile Ad Hoc Networks (MANETs). One of the most popular routing protocols that is widely used in WMNs and MANETs is the Ad hoc OnDemand Distance Vec tor (AODV) routing protocol [13]. AODV is one of the four protocols currently standardised by the IETF MANET working group, and it also forms the basis of new WMN routing protocols, including HWMP in the upcoming IEEE 802.11s wireless mesh network standard [10]. The details of the AODV protocol are laid out in the RFC 3561 [13]. However, due to the use of English prose, this speciﬁcation contains ambiguities and contradictions. This can lead to signiﬁcantly diﬀerent implementations of the AODV rout ing protocol, depending on the developer’s understanding and reading of the AODV RFC. In the worst case scenario, an AODV implementation may contain serious ﬂaws, such as routing loops. TraditionalapproachestotheanalysisofAODVandmany other AODVbasedprotocols [5,10,16,18,15] are simulatio n and testbed experiments. While these are important and validmethodsfor protocol evaluation, inparticularfor qu an titative performance evaluation, there are limitations in re gards to the evaluation of basic protocol correctness prope r ties. Experimental evaluation is resource intensiveand ti me consuming, and, even after a very long time of evaluation, only a ﬁnite set of network scenarios can be considered—no general guarantee can be given about correct protocol be haviour for a wide range of unpredictable deployment sce narios [3]. This problem is illustrated by recent discoveri es of limitations in AODVlike protocols that have been under intense scrutiny over many years [12]. We believe that for mal methods can help in this regard; they complement sim ulation and testbed experiments as methods for protocol evaluation and veriﬁcation, and provide stronger and more general assurances about protocol properties and behaviou r. This paper is based on a complete and accurate formal speciﬁcation of the core functionality of the AODV rout ing protocol using the speciﬁcation language AWN (Algebra of Wireless Networks) [7]. AWN provides the right level of abstraction to model key features such as unicast and broad cast, while abstracting from implementationrelated deta ils. As its semantics is completely unambiguous, specifying a 1protocol in such a framework enforces total precision and the removal of any ambiguities. A key contribution is to demonstrate how AWN can be used to support reasoning about protocol behaviour and to provide a rigorous proof of key protocol properties, using the example of loop freedom. In contrast to what can be achieved, e.g., by model check ing, our proofs apply to all conceivable dynamic network topologies. We analyse diﬀerent readings of the AODV RFC, and show which interpretations do satisfy the loop freedom cri terion, and which do not. We also discuss two limitations of the AODV protocol and propose solutions to them. We show how our formal speciﬁcation can be used to analyse the proposed modiﬁcations and show that these AODV variants are loop free. The rigorous protocol analysis discussed in this paper has the potential to save a signiﬁcant amount of time in the development and evaluation of new network protocols, can provide increased levels of assurance of protocol correctn ess, and complements simulation and other experimental proto col evaluation approaches. The remainder of this paper is organised as follows. We brieﬂy describe AWN in Section 2, and use it to formally specify AODV in Section 3. We discuss one of several ambi guities and contradictions in the AODV RFC, and propose potential resolutions in Section 4. We then summarise the key points of a detailed proof of loop freedom of AODV in Section 5, and demonstrate how the reasoning and proof can relatively easily be adapted to variants of the AODV proto col in Section 6. We discuss related work in Section 7, and summarise our work in Section 8. 2. AWN—AN ALGEBRA FOR WIRELESS NETWORKS Process algebras are standard tools to describe interac tions, communications and synchronisations between a col lection of independent agents, processes or network nodes. Theyprovidealgebraic laws thatallowformal reasoning. Fo r the speciﬁcation of and for formal reasoning about AODV, we use AWN [7, 8], a process algebra speciﬁcally tailored for WMNs. AWN allows us to write a protocol speciﬁcation in a simple language, which makes it easy to read and to use. Its key operators are conditional unicast —allowing error han dling in response to failed communications while abstract ing from link layer implementations of the communication handling—and local broadcast —allowing anodetosendmes sages to all its immediate neighbours as implemented by the physical and data link layer. In this section we only give an overview of the main oper ations (Table 1) and illustrate the use of AWN with a simple example. Additional explanations and a full description ca n be found in [7, 8]. The example considers a network of two nodes on which the same process is running. Onenode broadcasts an integer value. A received message will be delivered to the applica tion layer if its value is 1. Otherwise the node decrements the value and broadcasts the new value. The behaviour of each node can be modelled by: X(n)def=broadcast (n).Y() Y()def=receive(m).([m=1]deliver(m).Y() + [m/negationslash=1]X(m−1)) If a node is in a state X(n) it will broadcast nand continueX(exp1,...,expn) process name with arguments P+Q choice between processes PandQ [ϕ]P conditional process; execute Ponly if condition ϕholds [[var:=exp]]P assignment followed by process P broadcast (ms).P broadcast message msfollowed by P groupcast (dests,ms).Piterative unicast to all destinations dests(if broadcast is inappropriate) unicast (dest,ms).P◮Qunicastmstodest; if successful pro ceed with P; otherwise with Q deliver(data).P deliver data to application layer receive(msg).P receive a message P/bardblQ parallel composition of nodes Table 1: Process expressions in stateY(). If a node is in state Y(), and it receives m, it has two ways to continue. Process [ m=1]deliver(m).Y() is enabled if m=1. In that case mwill be delivered to the appli cation layer, and the process returns to Y(). Alternatively, ifm/negationslash=1, the process continues as X(m−1). Note that calls to processes use expressions as parameters, in this case m−1. Assumethatthenodes AandBarewithincommunication range of each other; node Ain stateX(2), and node BinY(). Then, node Abroadcasts 2 and continues as Y(). Node B receives 2, and continues as X(1). Next Bbroadcasts 1, and continues as Y(), while node Areceives 1, and, since the condition m=1 is satisﬁed, delivers 1 and continues as Y(). This gives rise to transitions from one state to the other: X(2)/bardblY()A:broadcast (2)− −−−−−−−−− → Y()/bardblX(1)B:broadcast (1)− −−−−−−−−− → A:deliver (1)− −−−−−−− → Y()/bardblY() In stateY()/bardblY() no further activity is possible; the network has reached a deadlock. 3. A FORMALSPECIFICATIONOFAODV AODV is a reactive protocol, which means that routes are only established on demand. If a node Swants to send a data packet to node D, but currently does not know a route, it buﬀers the packet and initiates a route discovery process by broadcasting a route request (RREQ) message in the network. An intermediate node Athat receives this message creates a routing table entry for a route towards S, referred to as a reverse route , and rebroadcasts the RREQ. This is repeated until the RREQ reaches the destination D, or alternatively a node with a route to D. In both cases, the node replies by unicasting a route reply (RREP) back to the source S, via the previously established reverse route. When forwarding RREP messages, a node creates a routing table entry for node D, called the forward route . When the RREP reaches S, a route between SandDis established and data packets can start to ﬂow. In the event of link and route breaks, AODV uses route error messages (RERR) to notify the aﬀected nodes. AODV uses sequence numbers to indicate the freshness of routes and to avoid routing loops. Full details are given in [13]. 3.1 Modelling AODV We present a model of AODV using AWN. The formal isation is a faithful representation of the core functional ity of AODV as deﬁned in [13]. We currently do not model optional features such as local route repair, expanding rin g search, gratuitous route reply and multicast. We also ab stract from all timing issues, since AWN currently does not 2Process 1 The basic routine AODV(ip,sn,rt,rreqs,store)def= 1.receive (msg) . 2./*depending on the message, diﬀerent processes are called* / 3.( 4.[msg=newpkt(data,dip)]/*new DATA packet*/ 5. PKT(data,dip,ip,ip,sn,rt,rreqs,store) 6.+[msg=pkt(data,dip,oip)]/*incoming DATA packet*/ 7. PKT(data,dip,oip,ip,sn,rt,rreqs,store) 8.+[msg=rreq(hops,rreqid,dip,dsn,oip,osn,sip)]/*RREQ*/ 9. /*update the route to sipinrt*/ 10. [[rt:=update(rt,(sip,0,val,1,sip,∅))]] 11. RREQ(hops,rreqid,dip,dsn,oip,osn,sip,ip,sn,rt,rreqs,store) 12.+[msg=rrep(hops,dip,dsn,oip,sip)]/*RREP*/ 13. /*update the route to sipinrt*/ 14. [[rt:=update(rt,(sip,0,val,1,sip,∅))]] 15. RREP(hops,dip,dsn,oip,sip,ip,sn,rt,rreqs,store) 16.+[msg=rerr(dests,sip)]/*RERR*/ 17. /*update the route to sipinrt*/ 18. [[rt:=update(rt,(sip,0,val,1,sip,∅))]] 19. RERR(dests,sip,ip,rt,sn,rreqs,store) 20.) 21.+[Letdip∈qD(store)∩vD(rt)]/*send a queued data packet*/ 22.... support time. In concrete terms, this means that the AODV timing parameters ACTIVE_ROUTE_TIMEOUT ,DELETE_PERIOD andPATH_DISCOVERY_TIME are set to inﬁnity. In addition to modelling the complete set of core func tionalities of the AODV protocol, our model also covers the interface to higher protocol layers via the injection and de  livery of application layer data, as well as the forwarding o f data packets at intermediate nodes. Although this is not part of the AODV protocol speciﬁcation, it is necessary for a practical model of any reactive routing protocol, where protocol activity is triggered via the sending and forwardi ng of data packets. Our AODV model consists of the following six processes: •AODV, the main process, reads a message from the mes sage queue (Line 1 of Process 1) and calls the appro priate process PKT,RREQ,RREP, orRERRto handle it (Lines 4–19). The process also handles the forwarding of any queued data packets if a valid route to their destination is known (Lines 21 ﬀ.). •PKTdeals with received data packets, including for warding if a route exists, and sending an error message if the route is broken. If the data packet originates at the local node and no route to the destination exists, the process buﬀers the data packet and initiates a new route discovery process. •RREQdeals with received RREQ messages, and will be discussed in detail below. •RREPdeals with received RREP messages, including the updating of routing tables and handling of errors. •RERRmodels the processing of AODV error messages. •QMSGdescribesthegeneralhandlingofincomingAODV messages: whenever a message is received, it is ﬁrst stored in a FIFO queue. As soon as the corresponding node is able to handle a message it retrieves the oldest message from the queue and handles it. Each node in an AODV network maintains a routing table to keep track of the node’s routing information collected so far. A routing table consists of sets of entries of the form(dip,dsn,ﬂag,hops,nhip,pre), withdipbeing the node iden tiﬁer (typically IP address) of the ultimate destination no de, anddsnthe destination sequence number, which represents the“freshness”of this routing table entry. The ﬂagparam eter indicates whether an entry is valid or invalid, and hops represents the distance to the destination node dipin num ber of hops. nhipidentiﬁes the next hop node along the route to node dip, andpreis the set of precursors —nodes that“rely”on this routing table entry for their own routes. Following [13], a routing table entry would also contain a sequencenumberstatus ﬂag . In the present paper we ab stract from this ﬂag, since (a) the main results are indepen dent of the existence of the ﬂag, and(b) none of the common implementations (AODVUU[2], KernelAODV[1], AODV UIUC [11], AODVUCSB [6], AODVns21) maintains this ﬂag.2Hence the speciﬁcation here follows the implementa tions available. In a routing table rtthere is at most one entry for each destination dip;sqn(rt,dip) denotes the sequence number of that entry and flag(rt,dip),dhops(rt,dip) andnhop(rt,dip) its validity, hop count and next hop. Furthermore the sets kD(rt) andvD(rt) of destinations contain all entries of rtfor whichthereisan(arbitrary)entryoravalidentry, resp. Th e function updateupdates a routing table rtwith an entry r, which is one of the major activities of AODV: update(rt,r):=  rt∪{r}ifπ1(r)/ne}ationslash∈kD(rt) //r is new nrt∪{nr}ifsqn(rt,π1(r))<π2(r)//fresher nrt∪{nr}ifsqn(rt,π1(r))=π2(r) ∧dhops(rt,π1(r))>π4(r)//shorter nrt∪{nr}ifsqn(rt,π1(r))=π2(r)//replaces ∧flag(rt,π1(r))=inv invalid nrt∪{nr′}ifπ2(r)=0 //unk. sqn nrt∪{ns}otherwise , where the projections π1,π2andπ4select the respective component from an entry, namely the destination, the des tinationsequencenumberandthehopcount. sisthecurrent entry inrtfor destination π1(r) (if it exists); and nrt:=rt−s removes sfromrt. The entry nris identical to rexcept that the precursors from the corresponding routing table entry are added and nsis generated from sby adding the precur sors ofr. The entry nr′is identical to nrexcept that the sequence number is replaced by the one from the routing table (route s). If a route is not valid any longer, instead of deleting it, AODV sets its validity ﬂag to invalid. This way, the stored information on the route, such as the sequence number and hop count, remains accessible. We model route invalidation by a function invalidate whose arguments are a routing ta ble and a set destsof pairs ( rip,rsn) of a destination ripto be invalidated, and the sequence number of the invalidated routing table entry. Normally, rsnis obtained by increment ing the last known sequence number of the route. In our formalisation, a route request message has the form rreq(hops,rreqid,dip,dsn,oip,osn,sip), where hopsis the number of hops the RREQ has already travelled from its originoip, andrreqid(in combination with oip) is a unique identiﬁer of the message. dipis the destination node identi ﬁer (IP address) of the route request and dsnthe last known corresponding sequence number. The parameter oipis the 1www.autonomos.de/ns2doku/aodv_8ccsource.html 2KernelAODV implements the ﬂag, but does not use it. 3address of the originator of the route request and osnis its sequence number. Finally, siprepresents the sender IP ad dress, i.e., the address of the intermediate node from which the request was received. Any node forwarding such a mes sage updates sipwith its own address, increments hops, and retains all other parameters. A reply to such a message has the form rrep(hops,dip,dsn,oip,sip), where dipandoipare copied from the corresponding RREQ message and hopsis the distance from diptosip. The processes RREQandRREP that handle incoming RREQ and RREP messages maintain variables dip,oip, etc. to store the values of the parameters of these messages, as summarised below. Variables Used for ipaddress of current node dip destination address oip originator of a route request or data packet rip destination of invalid route sip sender of AODV control message nhip next hop towards some destination The process AODV, speciﬁed by Process 1, deals with the message handling of the node. It stores its own address in the variable ip, its own sequence number in sn, manages its routing table rt, records all route requests seen so far inrreqsand maintains in storedata packets to be sent. Initially, rt,rreqsandstoreare set to empty, and snto 1. 3.2 Route Request Handling In this paper, we discuss only the model of the RREQ process; see [8]for acompletemodel ofall AODVprocesses.3 A route discovery in AODV is initiated by a source node broadcasting a RREQ message. Process 2 shows our process algebra speciﬁcation of the handling of a RREQ message received by a node ip. If the RREQ with the same oipandrreqidhas been seen previously by the node, it is ignored, and we go back to the main AODV process (Lines 1–2). If the RREQ is new (Line 3), we update the routing table by adding a “reverse route” entry to oip, the originator of the RREQ, via node sip, with distance hops+1 (Line 5). If there already is a route to oipin the node’s routing table rt, it is only up dated with the new route, if the new route is “better”, i.e., fresher and/or shorter and/or replacing an invalid route (c f. Section 3.1). The process also adds the message to the list of known RREQs (Line 7). Lines 9–20 deal with the case where the node receiving the RREQ is the intended destination, i.e., dip=ip(Line 9). In this case, a RREP message needs to be sent to the origi nating node oip. According to the AODV RFC, the node’s sequence number is set to the maximum of the node’s cur rent sequence number and the destination sequence number (dsn) in the RREQ message (Line 10). The RREP message is initialised as follows: hop count (hops) is set to 0, the destination ( dip) and originator ( oip) are copied from the corresponding RREQ message and the destination’s sequence number is the node’s sequence num bersn. Of course, the sender’s IP address ( sip) is set to the node’s ip (Line 12). The RREP message is unicast to the next hop along the reverse route back to the originator of the corresponding RREQ message, and if this is successful, the process goes back to the AODV process (Line 13). 3There, the sequencenumberstatusﬂag is modelled as well.Process 2 RREQ handling RREQ(hops,rreqid,dip,dsn,oip,osn,sip,ip,sn,rt,rreqs,store)def= 1.[(oip,rreqid)∈rreqs]/*the RREQ has been handled before*/ 2.AODV(ip,sn,rt,rreqs,store)/*silently ignore RREQ*/ 3.+[(oip,rreqid)/ne}ationslash∈rreqs]/*the RREQ is new to this node*/ 4./*update the route to oipinrt*/ 5.[[rt:=update(rt,(oip,osn,val,hops+ 1,sip,∅))]] 6./*update rreqsby adding ( oip,rreqid)*/ 7.[[rreqs:=rreqs∪ {(oip,rreqid)}]] 8.( 9.[dip=ip]/*this node is the destination node*/ 10. [[sn:= max( sn,dsn)]]/*update the sqn of ip*/ 11. /*unicast a RREP towards oipof the RREQ*/ 12. unicast (nhop(rt,oip),rrep(0,dip,sn,oip,ip)). 13. AODV(ip,sn,rt,rreqs,store) 14. ◮/*if transmission fails, a RERR is generated*/ 15. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧ nhop(rt,rip) =nhop(rt,oip)}]] 16. [[rt:=invalidate (rt,dests)]] 17. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 18. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧ precs(rt,rip)/ne}ationslash=∅]] 19. groupcast (pre,rerr(dests,ip)). 20. AODV(ip,sn,rt,rreqs,store) 21.+[dip/ne}ationslash=ip]/*this node is not the destination node*/ 22. ( 23. /*valid route to dipthat is fresh enough*/ 24. [dip∈vD(rt)∧dsn≤sqn(rt,dip)∧sqn(rt,dip)/ne}ationslash= 0] 25. /*update rtby adding precursors*/ 26. [[rt:=addpreRT (rt,dip,{sip})]] 27. [[rt:=addpreRT (rt,oip,{nhop(rt,dip)})]] 28. /*unicast a RREP towards the oipof the RREQ*/ 29. unicast (nhop(rt,oip), rrep(dhops(rt,dip),dip,sqn(rt,dip),oip,ip)). 30. AODV(ip,sn,rt,rreqs,store) 31. ◮/*if transmission fails, a RERR is generated*/ 32. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧ nhop(rt,rip) =nhop(rt,oip)}]] 33. [[rt:=invalidate (rt,dests)]] 34. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 35. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧ precs(rt,rip)/ne}ationslash=∅]] 36. groupcast (pre,rerr(dests,ip)). 37. AODV(ip,sn,rt,rreqs,store) 38. /*no valid route that is fresh enough*/ 39. +[dip/ne}ationslash∈vD(rt)∨sqn(rt,dip)<dsn∨sqn(rt,dip) = 0] 40. /*no further update of rt*/ 41. broadcast (rreq(hops+ 1,rreqid,dip, max(sqn(rt,dip),dsn),oip,osn,ip)). 42. AODV(ip,sn,rt,rreqs,store) 43. ) 44.) IftheunicastoftheRREPfails, weproceedwithLines14– 20, in which a route error (RERR) message is generated and sent. This conditional unicast is implemented in our model with the AWN construct unicast(dest,ms).P◮Q (Lines 12ﬀ.) We assume that, as is the case for relevant wireless technologies such as IEEE 802.11, unicast message s are acknowledged, and we therefore can determine whether the transmission was unsuccessful and the link to the next node towards oipis broken. In this case, the node sends a RERR message to all nodes that rely on the broken link for one of their routes. For this, we ﬁrst determine which destination nodes are aﬀected by the broken link, i.e., the nodes that have this unreachable node listed as a next hop in the routing table (Line 15). Here, the operator incin crements the sequence numbers of those entries. Then, we invalidate any aﬀected routing table entries (Line 16), and determine the list of precursors , which are the neighbouring nodes that have a route to one of the aﬀected destination nodes via the broken link (Line 17). Finally, using the AWN groupcast primitive, aRERRmessage is sentviaunicastto all these precursors (Line 19), listing only those invalida ted 4destinations with a nonempty set of precursors (Line 18). Lines 21–42 deal with the case where the node receiving theRREQis notthedestination, i.e., dip/negationslash=ip(Line21). The node can respond to the RREQ with a corresponding RREP on behalf of the destination node dip, if its route to dipis “fresh enough”(Line 24). This means that (a) the node has a valid route to dip, (b) the destination sequence number in the node’s current routing table entry ( sqn(rt,dip)) is greater than or equal tothe requestedsequence numberto dipin the RREQ message, and (c) the sequence number is valid, i.e., it is not unknown ( sqn(rt,dip)/negationslash=0). If these three conditions are met (Line 24), the node generates a RREP message and unicasts it back to the originator node oipvia the reverse route. To this end, it copies the sequence number for the destination dipfrom the routing table rtinto the destination sequence number ﬁeld of the RREP message and it places its distance in hops from the destination ( dhops(rt,dip)) in the corresponding ﬁeld of the new reply (Line 29). As usual, the unicast might fail, which causes the same error handling (Lines 32–35). Just before unicasting the RREP message, the intermediate node updates the forward routing table entry to dipby placing the last hop node ( sip) into the precursor list for that entry (Line 26). Likewise, it update s the reverse routing table entry to oipby placing the ﬁrst hopnhop(rt,dip) towards dipin the precursor list for that entry (Line 27). If the node is not the destination and there is either no route to the destination dipinside the routing table or the route is not fresh enough, the route request received has to be forwarded. This happens in Line 41. The information inside the forwarded request is mostly copied from the re quest received. Only the hop count is increased by 1 and the destination sequence number is set to the maximum of destination sequence number in the RREQ packet and the the current sequence number for dipin the routing table. In casedipis an unknown destination, sqn(rt,dip) returns the unknown sequence number 0. 4. AMBIGUITIESIN THERFC The formal speciﬁcation of AODV, outlined above and given in full detail in [8], closely follows the RFC 3561 [13] , the oﬃcial speciﬁcation of the protocol. However, the RFC contains several ambiguities and contradictions; an inven  tory is presented in [8], and for each ambiguity or contradic  tion a number of ways to resolve them is listed. An interpre tationof the RFC is given by the allocation of a resolution to each of the ambiguities and contradictions. Each reading , implementation, or formal analysis of AODV must pertain to one of its interpretations. The formal speciﬁcation of AODV in [8] constitutes one interpretation; the inventory o f ambiguities and contradictions is formalised by specifyin g each resolution of each of the ambiguities and contradic tions as a modiﬁcation of this formal speciﬁcation, typical ly involving a rewrite of a few lines of code only. A crucial contradiction in the RFC concerns the question of what would happen if a node has a valid routing table entry for a destination D, with destination sequence num bern, and an error message is received from the next hop towards D, saying that the route to Dis broken, and stating for this route a destination sequence number m, which may be smaller than n. Section 6.11 of the RFC unambiguously states that in such a case the node updates its routing table entry to Dby marking the route as invalid, and copyingthedestination sequence number from the incoming route error message. However, Section 6.1 of the RFC states that if m < n, any information related to Din the AODV message must be discarded. One can show [8] that in case no node will ever store a routing table entry to itself (a selfentry), the above situ a tion will never occur. However, the RFC does not explicitly exclude selfentries4, and they can in fact occur [8] in re sponse to the standard handling of RREP messages. The following ways to resolve this contradiction have been listed in [8]: (a) Follow Section 6.11 of the RFC, in deﬁance of 6.1, i.e., alwaysinvalidate the routing table entry, and copy the destination sequence number from the error message to the corresponding entry in the routing table.5 (b) Follow Section 6.11 only where it does not contradict 6.1, i.e., invalidate the routing table entry and copy the destination sequence number onlyifm≥n. (c) Always invalidate the routing table entry, but update the destination sequence number to max( m,n). (d) Always invalidate the routing table entry, but update the destination sequence number to max( m,n+1). (e) Invalidate the routing table entry and update the desti nationsequencenumbertomax( m,n+1)onlyif m≥n.6 (f) Invalidate the routing table entry only if m > n.7 (g) Forbid selfentries; if an incoming RREP message would create a selfentry, discard that message. (h) Forbid selfentries; if an incoming RREP message would create a selfentry, forward that message without updat ing the node’s routing table. It should be noted that only resolutions (a) and (b) are compliant with the RFC. However, in [9] we have shown that any interpretation based on resolutions (a) or (b) give s rise to routing loops, so in order to arrive at a loopfree version of AODV, one has to deviate from the RFC. Here, as in [8], we do so by choosing resolution (f). The above is only one of many ambiguities; another one is presented in Section 6.1. 5. LOOP FREEDOM We now formalise loop freedom and sketch a proof that our detailed speciﬁcation of AODV cannot create routing loops. We also show how such a formal proof can form a baseline for evaluating variants of AODV—some of them will be loop free, others can yield loops. First we formalise what it means for the routing tables established by AODV (our speciﬁcation) to be free of loops. LetIPbe the set of network nodes and dip∈IPa particular destination; let Nbe a state of the network, encompassing the current values of all variables maintained by all nodes. 4The KernelAODV, AODVUIUC, AODVUCSB and AODVns2 implementations allow selfentries to occur. 5It could be argued that this is not a reasonable interpreta tion of the RFC, since Section 6.1 should have priority over 6.11. However, this priority is not explicitly stated. 6The case max( m,n) ifm≥nneed no separate considera tion, since it is equivalent to (b). 7Here, it does not matter whether we copy, take max( m,n) or max(m,n+1); they are all equivalent. 5Therouting graph RN(dip) for destination dipin stateNis the directed graph ( IP,E) with set of vertices IPand set of edgesE⊆IP×IPconsisting of the pairs ( ip,ip′) such that ip/negationslash=dipand (dip,∗,val,∗,ip′,∗) occurs in the routing table ofipin stateN. Thus, there is an edge ( ip,ip′) if node ipis not the destination dip, but has a valid entry for dip, andip′ is the next hop according to that entry. Loops in directed graphs are deﬁned to be paths following edges which return to a vertex. A (network) state Nisloop free if the routing graphs RN(dip) are loop free for all dip∈IP. The speciﬁcation of AODV is loop free iﬀ all reachable states are loop free. LetusnowturntowardsaproofofloopfreedomforAODV. It relies on a numberof invariants —statements that hold for all reachablestates ofourmodel. Aninvariantis usuallyve r iﬁed by showing that it holds for all possible initial states , and that, for any transition Nℓ− →N′derived by our opera tional semantics [8], if it holds for state Nthen it also holds for state N′, reached after performing some action ℓ. These transitions can be traced back to the line numbers in our process declarations AODV,PKT,RREQ,RREP,RERRandQMSG. A proof of AODV’s loop freedom using invariants has ﬁrst beenproposed in [4].8The main invariantof[4] states that if node ip has a routing table entry for destination dip with nex t hop nhip, then also node nhip has a routing table entry for dip, and the latter has a larger destination sequence number , or an equal one with a strictly smaller hop count. This invariant is claimed to hold regardless whether the routing table entries for dipatipandnhipare marked as valid or invalid. Nevertheless, the following example show s that it does not hold for the current version of AODV. S 2(A,0,inv,1,A) (D,2,inv,2,A) A 1(D,1,val,1,D) (S,2,val,1,S) D 1(A,0,val,1,A) (S,2,val,2,A) Figure 1: Sequence numbers can go down9 ThenetworkstatedepictedinFigure1canoccurwhen, af ter a standard RREQRREP cycle, a link break is detected. We assume a simple linear topology of 3 nodes. Below the node names, the circles list the nodes’ own sequence num bers, whichwe assume tobe1at theinitial state. Theexam ple starts with empty routing tables and node Ssearching for a route to node D. Before broadcasting a RREQ mes sage, node Sincrements its sequence number by 1. Due to the successful exchange of RREQRREP messages, all rout ing tables are updated. After that, the link between nodes SandAgoes down, Sdetects the link break and updates its routing table: it sets all entries in its routing table with n ext hopAtoinvalidandincreases thedestinationsequencenum ber of the route to Dto 2; the destination sequence number in the route to Ais unknown (0) and hence not incremented. Now the destination sequence number on the route to node Dis 2 in the routing table of Sand 1 inside A’s routing table, hence this number can go down. 8In fact, the same idea occurs already in [14], but without the formalisation in terms of invariants. However, that pro of fails to consider some cases that do occur in AODV and might yield routing loops [9]. 9We omit the precursor set; the routing table entries in each node are represented as ( dip,dsn,ﬂag,hops,nhip), described in Section 3.1.One way to avoid this problem is to claim the invariant only for the case that the routing table entries at ipand nhipare both marked as valid. This is what we do in The orem 5.4 below, and it suﬃces to obtain loop freedom of AODV. However, in order to prove Theorem 5.4, we need an invariant that also takes invalid routing table entries i nto account (cf. Proposition 5.3), so it is not possible to avoid the above problem altogether. To compensate for the increase of a sequence number in case of route invalidation, we introduce the concept of a net sequence number of a route to dipaccording to the routing table of node ipin stateN, which combines“freshness”and validity: nsqnip N(dip):=/braceleftBigg sqnip N(dip) ifflagip N(dip)=val∨sqnip N(dip)=0 sqnip N(dip)−1 otherwise . Here, we write sqnip N(dip) forsqn(rt,dip) in case rthappens to be the routing table maintained by a node with IP ad dressipin state Nof the network. Likewise flagip N(dip) denotes the validity of the route from iptodipaccording to the routing table of ipin state N,dhopsip N(dip) its hop count, and nhopip N(dip) its next hop. Furthermore kDip N, ab breviating kD(rt), is the set of destinations for which there is a valid entry in the routing table of ip. In this section we state the key theorems and sketch some of the proofs; all details can be found in [8]. In particular, we show only proofs w.r.t. Process 2, the RREQ handling, and the displayed portion of Process 1. Proposition 5.1.If a route request is sent (forwarded) by a node ipcdiﬀerent from the originator of the request then the content of ipc’s routing table must be fresher or at least as good as the information inside the message. NR:broadcast (rreq(hopsc,∗,∗,∗,oipc,osnc,ipc))− −−−−−−−−−−−−−−−−−−−−−−−−−−− → N′∧ipc/negationslash=oipc ⇒oipc∈kDipc N∧/parenleftbig sqnipc N(oipc)>osnc∨(sqnipc N(oipc)=osnc ∧dhopsipc N(oipc)≤hopsc∧flagipc N(oipc)=val)/parenrightbig The next proposition says that in the routing table of a node ip, an entry to a destination dipwill never be deleted, and the net sequence number of the entry will never go down. Proposition 5.2.Let ip,dip∈IP, and assume Nℓ− →N′, i.e. the network proceeds from state Nto state N′by the occurrence of some action ℓ. If dip∈kDip Nthen dip ∈kDip N′ andnsqnip N(dip)≤nsqnip N′(dip). Proof. In our model of AODV, the only way to change a routingtableisbymeansoftheoperations update,addpreRT andinvalidate . None of them ever deletes an entry alto gether, or decreases its net sequence number. In this proof it is essential that we use resolution (f) of the ambiguity in the RFC presented in Section 4. Proposi tion 5.2 would not hold under resolutions (a), (b) or (c). Proposition 5.3.If, in a reachable network state N, a node ip∈IPhas a routing table entry to dip, then also the next hop nhip towards dip, if not dip itself, has a routing table entry to dip, and the net sequence number of the latter entry is at least as large as that of the former. dip∈kDip N∧nhip/negationslash=dip ⇒dip∈kDnhip N∧nsqnip N(dip)≤nsqnnhip N(dip), where nhip :=nhopip N(dip)is the IP address of the next hop. 6Proof. In the initial state, the invariant holds since all routing tables are empty (cf. Section 3.1). Next we assume that the property holds and check each line in Pro. 1 and Pro. 2 which could invalidate it. A modiﬁcation of the routing table of nhipis harmless, as it can only increase kDnhip Nas well as nsqnnhip N(dip) (cf. Proposition 5.2). Adding precursors to routes of ipdoes not harm since the invariant does not depend on precursors. It remains to examine all calls of updateandinvalidate to the rout ing table of ip. Without loss of generality we restrict at tention to those applications of updateorinvalidate that actually modify the entry for dip, beyond its precursors; if updateonly adds some precursors in the routing table, the invariant—which is assumed to hold before—is maintained. Pro. 1, Lines 10, 14, 18: Theentry( sip,0,val,1,sip,∅) is usedfor theupdate; its destinationis dip:=sip. We assume this entry is actually inserted in the routing ta ble ofip. Sincedip=sip=nhopip N(dip) =nhip, the antecedentoftheinvarianttobeprovenisnotsatisﬁed. Pro. 2, Line 5: Theentry( oip,osn,val,hops+1,sip,∗)is used for the update; again we assume it is inserted into the routing table of node ip. Sodip:=oip,nhip:= sip,nsqnip N(dip) :=osnanddhopsip N(dip) :=hops+1. This information is distilled from a received route re quest message (cf. Lines 1 and 8 of Pro. 1). By Propo sition 7.1 of [8], this message was sent before, say in stateN′; by Proposition 7.8 of [8], the sender of this message has identiﬁed itself correctly, and is sip. By Proposition 5.1, with ipc:=sip=nhip,oipc:=oip= dip,osnc:=osnandhopsc:=hops, and using that ipc=nhip/negationslash=dip=oipc, we get that dip∈kDnhip N′and sqnnhip N′(dip) =sqnipc N′(oipc)>osnc=osn,or sqnnhip N′(dip) =osn∧flagnhip N′(dip) =val. We ﬁrst assume that the ﬁrst line holds. Then, by Proposition 5.2, nsqnnhip N(dip)≥nsqnnhip N′(dip)≥sqnnhip N′(dip)−1 ≥osn=nsqnip N(dip). We now assume the second line to be valid. From this we conclude nsqnnhip N(dip)≥nsqnnhip N′(dip) =sqnnhip N′(dip) =osn=nsqnip N(dip). Pro. 2, Lines 16, 33: Intheseapplicationsof invalidate , the next hop nhipis not changed. Since the invari ant has to hold before the execution, it follows that dip∈kDnhip Nalso holds after execution. Furthermore, in view of Lines 15 and 32, the route is invalidated while the destination sequence number is incremented. For this reason the net sequence number stays the same, and the invariant is maintained. Theorem 5.4.If, in a state N, a node ip ∈IPhas a valid entry to dip, and the next hop is not dip and has a valid dip entry as well, then the latter entry has a larger destination sequence number or an equal one with a smaller hop count. dip∈vDip N∩vDnhip N∧nhip/negationslash=dip ⇒sqnnhip N(dip)>sqnip N(dip)∨/parenleftbig sqnnhip N(dip)=sqnip N(dip)∧ dhopsnhip N(dip)<dhopsip N(dip)/parenrightbig ,where nhip :=nhopip N(dip), the next hop in the routing table entry at ip for the route to dip. The proof [8] is similar to the previous one, but makes use of Proposition 5.3—including the case where dip/∈vDnhip N—in an essential way. From Theorem 5.4, we can conclude Theorem 5.5.AODV is loop free. Proof. If there were a loop in a routing graph RN(dip), then for any edge ( ip,nhip) on that loop one would have sqnip N(dip)≤sqnnhip N(dip), by Theorem 5.4. Hence the value ofsqnip N(dip) is the same for all nodes ipon the loop. Thus, byTheorem 5.4, thesequencenumberskeepdecreasingwhen travelling around the loop, which is impossible. 6. ANALYSING VARIANTSOFAODV In this section, we use AWN to model interpretations and variants of the AODV protocol. Interpretations are just dif  ferent readings of the RFC, variants are the result of modi ﬁcations to address existing limitations. Thanks to the use of process algebra, we can easily adapt the proofs of estab lished correctness properties of the protocol, such as loop freedom. This is in contrast to the analysis of variants of existing protocols via simulations and testbed experiment s, where all the work typically has to be redone from scratch (and even then cannot provide the same level of assurance). 6.1 Interpretations In this section we brieﬂy discuss two ambiguities of the RFC together with possible interpretations. More can be found in [8]. Of course each interpretation may possibly create routing loops and hence has to be examined sepa rately. The speciﬁcation and the proofs formalised in AWN can easily be adapted. 6.1.1 Invalidating RoutingTableEntries WehavealreadypresentedonecontradictionoftheAODV RFC in Section 4. It was based on the question of what would happen if a node that has a valid routing table entry for a destination Dreceives an error message and invalidates the corresponding routing table entry. In the same section we also list eight possible resolutions. The ﬁrst two, the only interpretations compliant with the RFC, violate The orem 5.4, and yield routing loops [9]. The same holds for Interpretation (c). As stated before, to guarantee loop fre e dom one has to create an interpretation of AODV that is (literally speaking) not compliant with the RFC. Interpre tations (d) and(e) are loop free—the proofis identical toth e one of (f), given in Section 5. The remaining two resolutions can be proven to be loop free as well [8]. 6.1.2 UpdatingwiththeUnknownSequenceNumber The AODVRFC[13] states that whenever a node receives a forwarded AODV control message from a neighbour (i.e., the neighbour is not the originator of the message), it cre ates a new or updates an existing routing table entry to that neighbour. In the presented speciﬁcation, this update is modelled in Lines 10, 14 and 18 of Process 1. In the event a new routing table entry is created, the sequencenumber status ﬂag is set to false to signify that the sequence number corresponding to the neighbour is unknown. This interpre tation is modelled in [8] and is compliant with the RFC. 7However, in most implementations of AODV (e.g. [2, 6]), an unknown sequence number is simply represented by the value 0, rather than by setting a ﬂag. In the speciﬁcation of Section 3 we follow this approach of using the value 0. SincetheRFCdoesnotmaketheupdatemechanismclear, diﬀerent interpretations arise when an existing valid rout ing table entry for the neighbour has to be updated. While it is clear that expiry values for timers associated with the routing table entry will be updated, it is not clear if a valid sequence number with value n(>0) will remain unmodiﬁed as it is, or be updated to the value 0. In order to verify which interpretations are reasonable, we check which ones satisfy the invariants speciﬁed before (e.g., Theorem 5.4) . If we assume that an entry ( dip,0,val,hops′,∗,∗) replaces an entry ( dip,dsn,val,hops,∗,∗) (where dsn>0) in a routing table, itiseasytosee thatTheorem5.4isviolated. Infact, it is nothardtoexploit thistocreate aroutingloop, since it a l lows the possibility of decreasing destination sequence nu m bers [8, Sect. 9.1]. This is the interpretation that is imple  mented byAODVUIUCand AODVUCSB.Our interpreta tion follows AODVUU:anentry( dip,dsn,val,hops,nhip,∗) is replaced by ( dip,dsn,val,1,sip,∗), i.e., in the existing en try only the next hop and the hop count is updated—the sequence number stays the same. This interpretation is not in line with the RFC—the RFC never merges information of two routes. However, it is loop free (cf. Section 5). AODV ns2 does not perform an update if a routing table entry already exists, i.e., it uses a version of updateas in Sec tion 3.1, but without the ﬁfth clause. This interpretation i s also loop free; the proof is identical to the one presented in the previous section. There are more interpretations possible if the sequence numberstatus ﬂag (the ﬂag indicating whether a sequence number is known or unknown) is modelled. (a) Set the ﬂag to unknown and the sequence number to 0. Using the same argument as before, this can yield rout ing loops. (b) Set the ﬂag to unknown, but keep the destination se quence number stored in the routing table. This in terpretation is indeed loop free and is most likely the intention of the AODV RFC. Detailed proofs can be found in [8]. 6.2 Variants Let us now turn to variants of AODV and look at (known) shortcomings of the AODV protocol, present possible im provements and then use AWN to verify that the modiﬁed AODV is still loop free. 6.2.1 NonOptimalRouteSelection In AODV’s route discovery process, a destination node (or an intermediate node with an active route to the des tination node) will generate a RREP message in response to a received RREQ message. The RREQ message is then discarded and not forwarded. This termination of the route discovery process at the destination can lead to other nodes inadvertentlycreatingnonoptimalroutes tothesourceno de [12], where route optimality is deﬁned in terms of a met ric, for example hop count. In [12] it is shown that during the route discovery process in AODV, the only nodes that generally discover optimal routes to the source and desti nation nodes are those lying on the selected route betweenBS D ARREQRREQ Figure 2: Nonoptimal route selection the source node and the destination node (or the interme diate node) generating the reply. All other network nodes receiving the RREQ message (in particular those located “downstream”of the destination node) may inadvertently be creating nonoptimal routes to the source node due to the unavoidable receipt of RREQ messages over other routes. We illustrate this bythe example in Figure 2. There, node Swants to ﬁnd a route to node D. It generates and broad casts a RREQ message that is received by its neighbours D andB. SinceDis the destination, it responds with a RREP message. The received RREQ message is discarded and not forwarded. On the other hand, Bcontinues to forward its received RREQ message, which eventually arrives at A. At nodeA, a routing table entry is created for the source S, with a hop count of six. This is clearly not optimal, as A is only two hops away from S. Due to the discarding of the RREQ message at D,Ais prevented from discovering its optimal route to S. A possible modiﬁcation to AODV to solve this problem is to allow the destination node to continue to forward the RREQ message. This will then enable Ain Figure 2 to discover its optimal route to S. In addition, the forwarded RREQ message from the destination node is modiﬁed to include a ﬂag that indicates a RREP message has already been generated and sent in response to the former message. This is to prevent other nodes (with active routes to the destination) from sending a RREP message in response to their reception of the forwarded RREQ message. The entire speciﬁcation of this variant (in [8]) diﬀers only in ﬁve lines from the original—all of which are contained in the process RREQ; the other processes remain unchanged. The changes introduce the new ﬂag and a case distinction based on that, as well as three new broadcasts. For example, after initiating a route reply at the destination (Process 2 , Line 12), the route request message is forwarded: broadcast (rreq(hops+1,rreqid,dip,dsn,oip,osn,ip,true)) , where the last component ofthe RREQmessage is the newly introduced ﬂag. The proofs of important properties (e.g., loop freedom) are still valid. The proofs of the invariants proceed by examining lines in our processes where the in variant might be invalidated: The proof of Proposition 5.1, which can be found in [8], checks all occurrences of sendinga RREQ message, and the proofs of Proposition 5.3 and The orem 5.4 check all occurrences of updateandinvalidate . For the former, three new broadcast commands have to be examined; however these cases are similar to the broadcast already implemented in the original process RREQ(Line 41). For the latter, no extra eﬀort is needed, as the modiﬁcation does not involve occurrences of updateandinvalidate . 6.2.2 FailureofRouteDiscoveryProcess InAODV’sroutediscoveryprocess, aRREPmessage from the destination node is unicast back along the selected rout e 8D 1 T 1S 2 A 1(S,2,val,1,S)RREQS/shortrightarrowD (a)Sbroadcasts a RREQ to DD 1 T 2S 2 A 1(S,2,val,1,S) (T,2,val,1,T) RREQT/shortrightarrowD (b)Tbroadcasts a RREQ to D.D 1(A,0,val,1,A) (S,2,val,2,A) T 2 (A,0,val,1,A) (S,2,val,2,A)S 2(A,0,val,1,A) A 1(S,2,val,1,S) (T,2,val,1,T) RREQS/shortrightarrowD RREQS/shortrightarrowDRREQS/shortrightarrowD (c)Arebroadcasts RREQ S/shortrightarrowD D 1(A,0,val,1,A) (S,2,val,2,A) (T,2,val,2,A) T 2 (A,0,val,1,A) (S,2,val,2,A)S 2(A,0,val,1,A) (T,2,val,2,A) A 1(S,2,val,1,S) (T,2,val,1,T) RREQT/shortrightarrowDRREQT/shortrightarrowDRREQT/shortrightarrowD (d)Arebroadcasts RREQ T/shortrightarrowDD 1(A,0,val,1,A) (S,2,val,2,A) (T,2,val,2,A) T 2 (A,0,val,1,A) (S,2,val,2,A)S 2(A,0,val,1,A) (D,1,val,2,A) (T,2,val,2,A) A 1(D,1,val,1,D) (S,2,val,1,S) (T,2,val,1,T) RREPS/shortrightarrowDRREPS/shortrightarrowD (e)Dunicasts RREP S/shortrightarrowDtoA; Aforwards to SD 1(A,0,val,1,A) (S,2,val,2,A) (T,2,val,2,A) T 2 (A,0,val,1,A) (S,2,val,2,A)S 2(A,0,val,1,A) (D,1,val,2,A) (T,2,val,2,A) A 1(D,1,val,1,D) (S,2,val,1,S) (T,2,val,1,T) RREPT/shortrightarrowD (f)Dunicasts RREP T/shortrightarrowDtoA; Adrops RREP T/shortrightarrowD Figure 3: Failure of route discovery process towards the originator of the RREQ message. Every inter mediate node on the selected route will process the RREP message and, in most cases, forwards it towards the origina tornode. However, thereisapossibilitythattheRREPmes sage is discarded at an intermediate node and hence results in the originator node not receiving a reply. The discard ing of the RREP message is due to the RFC speciﬁcation of AODV [13] stating that an intermediate node only forwards the RREP message if it is not the originator node andit has created or updated a routing table entry to the desti nation node described in the RREP message. The latter requirement means that if a valid routing table entry to the destination node already exists, and is not updated when processing the RREP message, then the intermediate node will not forward the message. We illustrate this problem with an example.10 Figure 3 shows a fournode topology. In Figures 3(a) and 3(b), source nodes SandT, respectively, initiate a route dis covery process to search for a route to D. When generating a RREQ message, the source node increments its sequence number before inserting it into the message. In processing the RREQ messages from SandT, nodeAcreates routing table entries in its routing table. In Figures 3(c) and 3(d), node Arebroadcasts the RREQ messages that it received previously. The destination node Dreceives the RREQ messages, and creates corresponding entries in its routing table. In Figure 3(e), Dreplies with a RREP message in response to theRREQmessage from node S. Since the RREQ message from Sdoes not contain any information on the destination sequence number for D, node Dinserts its sequence number of 1 into the RREP message. This message is then processed by A(a routing table entry toDis created) and forwarded to S. Similarly, in Figure 3(f), node Dreplies with a RREP message in response to the RREQ message from node T. Since the RREQ message from node Tdoes not contain any 10A slightly diﬀerent example was given on the MANET mailing list http://www.ietf.org/mailarchive/web/ manet/current/msg05702.htmlinformation on the destination sequence number for node D, nodeDagain inserts its sequence number of 1 into its RREP message. When the intermediate node Areceives the RREP message, it processes the message. However, the existing routing table entry that node Aalready has for destination node Dcontains the same information (same destination sequence number and same hop count) as in the received RREPmessage. Therefore, node Adoes notupdate its routing table entry for node Dand thus, according to the RFC speciﬁcation, will not forward the RREP message to the source node T. This then leads to an unsuccessful route discovery process for node T. Asolution tothis problemis torequire intermediate nodes to forward allRREP messages that they receive using the newest available information on the route to the destinatio n node: if the node’s routing table contains an entry for the destination node that is valid and“fresher”than that in the RREP message, the intermediate node updates the contents of the RREP message to reﬂect this. The intermediate node Awill then forward a RREP message containing uptodate information on the destination node D. As in Section 6.2.1, this solution does not violate any of the invariants; again this follows by adapting the original proofs [8]. 7. RELATED WORK "
263,Reliable Restricted Process Theory.txt,"Malfunctions of a mobile ad hoc network (MANET) protocol caused by a
conceptual mistake in the protocol design, rather than unreliable
communication, can often be detected only by considering communication among
the nodes in the network to be reliable. In Restricted Broadcast Process
Theory, which was developed for the specification and verification of MANET
protocols, the communication operator is lossy. Replacing unreliable with
reliable communication invalidates existing results for this process theory. We
examine the effects of this adaptation on the semantics of the framework with
regard to the non-blocking property of communication in MANETs, the notion of
behavioral equivalence relation and its axiomatization. We illustrate the
applicability of our framework through a simple routing protocol. To prove its
correctness, we introduce a novel proof process, based on a precongruence
relation.","The applicability of wireless communication is growing rap idly in areas like home networks and satellite transmissions, due to their broadcasting nature . Mobile ad hoc networks (MANETs) consist of several portable hosts with no preexisting infrastructur e, such as routers in wired networks or access points in managed (infrastructure) wireless networks. The design of MANET protocols is complicated, because due to mobility of nodes the topology of communicati on links is dynamic. Important MANET2 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y protocols such as the Ad hoc On Demand Distance Vector (AODV) routing protocol [1] contained ﬂaws in their original design and have been revised accordin gly. Formal methods can be applied in the early phases of the protocol development to analyze and c apture conceptual errors before their implementation. For instance, some errors in the design of A ODV were found in [2, 3, 4, 5] using formal techniques. There are numerous applications of existing formal framewo rks such as SPIN [6, 7, 2] and UP PAAL [7, 8, 9, 10, 11, 12] for the analysis of MANET protocols. Lack of support for compositional modeling and arbitrary topology changes motivates develop ing a new approach, tailored to the domain of MANETs, with a primitive for local broadcast and supporti ng the veriﬁcation of MANET proto cols against changes of the underlying topology. The tailor ed formal modeling framework should provide some form of wireless communication which varies at the different layers of the Open Sys tems Interconnection (OSI) model: physical, data link, net work, transport, session, presentation, and application. For instance, the data link layer is responsib le for transferring data across the physical link and handling conﬂicts due to simultaneous accesses to t he shared media. In contrast, commu nication at the network layer provides pointtopoint comm unication between two nodes that are not directly connected through appropriate routing of mess ages by using the communication ser vice of the data link layer. Most frameworks for the formal an alysis of MANET protocols, such as [13, 14, 15, 16, 17, 18, 19, 20, 21, 5], focus on protocols abov e the data link layer; hence they support the core services of this layer, which means that local broad cast is the primitive means of communica tion. Wireless communication at this layer is nonblocking , i.e., the sender broadcasts irrespective of the readiness of its receivers, and is asynchronous , i.e., received packets are buffered at the receiver. The data link layer of a node processes the packet if it is an in tended destination. While a node is busy processing a message, it can still receive messages, buffer them and process them later. However, if two different nodes broadcast simultaneously with a comm on node in their range, the latter node cannot receive both messages and drops one of them, which is c alled the hidden node problem. We say that wireless communication is reliable if the intended receivers successfully receive the packet. In other words, message delivery is guaranteed to all connec ted neighbors. Although lossy communication is an integral part of MANETs, mimicking it faithfully in a formal framework can hamper the formal analysis of MANET protocols . To obtain a deeper understanding of a malfunctioning of such a protocol due to a conceptual mis takes in its design rather than unreliable communication, it may be helpful to consider communication reliable, meaning that the possibility of the hidden node problem is omitted from the framework. The refore we introduced the process al gebra Reliable Restricted Broadcast Process Theory (RRBPT) in [22], to perform model checking of MANET protocols in a setting where communication is reliabl e. It is a variant of Restricted Broad cast Process Theory (RBPT) that we introduced previously in [23] for the modeling and an alysis of protocols above the data link layer. The underlying semanti c model of RBPT , a socalled constrained labeled transition system (CLTS), implicitly considers mo bility of nodes with the novel notion of a network constraint, which abstractly deﬁnes a set of topolo gies: those satisfying the given connec tivity constraints. The transitions of a CLTS are annotated with appropriate network constraints to restrict the behavior to MANETs with a topology of the speciﬁ ed ones. RBPT was extended with a set of auxiliary operators to reason about MANETs by equatio nal reasoning, socalled Computed Net work Process Theory ( CNT ) [24]. We provided a sound and complete axiomatization for CNT terms with ﬁnitestate behaviors, modulo socalled rooted branc hing computed network bisimilarity. This axiomatization enables linearization of processes at the s yntactic level to take advantage of symbolic veriﬁcation [25, 26], especially when the network is compos ed of similar nodes [27, 28].F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 3 Somewhat surprisingly, all these results do not carry over i n a straightforward fashion from RBPT toRRBPT . To put the model checking approach presented in [22] on a ﬁrm basis, the current paper develops the formal foundations for RRBPT and modiﬁes the core of CNT . In a lossy setting, the non blocking property of local broadcast communication is an im mediate consequence of the rule Par and its counterpart for the parallel composition:t1a− →t′ 1 t1/bardblt2a− →t′ 1/bardblt2, which expresses that if a node is not ready to participate in a communication, then we can assume t hat either it was disconnected from the sender or it was connected but has lost the message. However, in the reliable setting, to guarantee the nonblocking property, nodes should always be inputen abled. RRBPT provides a sensing operator which allows to change the control ﬂow of a process depending on the status of node connectivity with other nodes. The inputenabledness feature is ensured thro ugh the RRBPT operational rules, where the main difference between RRBPT andRBPT is: in RRBPT , nodes lose a communication only when they are disconnected and are always inputenabled. We recap challenges of bringing input enabledness feature in the semantics of RRBPT in the presence of the sensing operator. Furthermore, the behavioral equivalence relation of CNT setting is not a congruence with respect to parallel compo sition anymore. To support the desired distinguishing powe r, we provide a new bisimulation relation which guarantees the congruence property for MANETs. RRBPT can be extended in the same way asRBPT with computed network terms and the auxiliary operators left merge () and communication merge (|) to provide a sound and complete axiomatization for the para llel composition. However, the inputenabledness feature and the new sensing operator req uire new auxiliary operators to assist their axiomatization. To this aim, we discuss the appropriate axi oms of RRBPT . We utilize our axioms to analyze the correctness of protocols at the syntactic level . To this aim, we facilitate the speciﬁcation of the protocol behaviors preconditioned to multihop const raints and then introduce a new notion of reﬁnement among protocol implementations and their speciﬁ cations. We demonstrate the applicability of our framework by analyzing and proving the correctness of a simple routing protocol inspired by the AODV protocol. This paper is organized as follows. Sections 2 and 4 introduc e our semantic model and explain how it is helpful in giving semantics to reliable communicat ion. Section 3 introduces the syntax of RRBPT . Sections 5 and 6 provide the appropriate notion of behavior al equivalence and axioms in the reliable setting, respectively. We demonstrate the applic ability of our new framework by analyzing a simple routing protocol in Section 7. We review and compare t he related process algebraic frameworks in depth in Section 8 before concluding the paper. 2. Constrained Labeled Transition Systems LetLocdenote a set of network addresses, ranged over by ℓ. Viewing a network topology as a directed graph, it can be deﬁned as γ:Loc→I P(Loc), whereγ(A)expresses the set of nodes that are directly connected to A, and hence, can receive message from A. A network constraint Cis a set of connectivity pairs /squiggleright:Loc×Loc and disconnectivity pairs /\e}a⊔io\slash/squiggleright:Loc×Loc. In this setting, non existence of (dis)connectivity information between two ad dresses implies lack of information about this link (which can e.g. be helpful when the link has no effec t on the evolution of the network). For instance, B/squigglerightAdenotes that Ais connected to Bdirectly and consequently Acan receive data sent byBas before, while B/\e}a⊔io\slash/squigglerightAdenotes that Ais not connected to Bdirectly and consequently cannot receive any message from B. The direction of an arrow shows the direction of informatio n ﬂow. We4 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y write{B/squigglerightA,C, B /\e}a⊔io\slash/squigglerightD,E}instead of {B/squigglerightA, B/squigglerightC, B/\e}a⊔io\slash/squigglerightD, B/\e}a⊔io\slash/squigglerightE}. The set Loc is extended with the unknown address ?to represent the address of a node which is still not known or concealed from an external observer. For instance, the lead er address of a node can be initialized to this value. Furthermore, to deﬁne the semantics of commun icating nodes in terms of restrictions over the topology in a compositional way, the semantics of re ceive actions can be deﬁned through an unknown sender, which will be replaced by a known address whe n the receive actions are composed with the corresponding send action at a speciﬁc node (see Sec tion 4). A network constraint Cis said to be wellformed if∀ℓ,ℓ′∈Loc(ℓ/squigglerightℓ′/\e}a⊔io\slash∈ C ∨ℓ/\e}a⊔io\slash/squigglerightℓ′/\e}a⊔io\slash∈ C). LetCv(Loc)denote the set of wellformed network constraints that can b e deﬁned over the network addresses in Loc. We deﬁne an ordering on network constraints. We say that C1/precedesorcurlyC2iffC2⊆ C1 or∃ℓ∈Loc(C2[ℓ/?]⊆ C1), whered[d1/d2]denotes the substitution of d1ford2ind; this can be extended to process terms. For instance, {B/squigglerightA}/precedesorcurly{?/squigglerightA}and{B/squigglerightA, B/squigglerightC}/precedesorcurly{B/squiggleright A}. Each wellformed network constraint Crepresents the set of network topologies that satisfy the (dis)connectivity pairs in C, i.e.,Γ(C) ={γ| CΓ(γ)/precedesorcurlyC}whereCΓ(γ) ={ℓ/squigglerightℓ′|ℓ′∈γ(ℓ)}∪{ℓ/\e}a⊔io\slash/squiggleright ℓ′|ℓ′/\e}a⊔io\slash∈γ(ℓ)}extracts all onehop (dis)connectivity information from γ. So the empty network constraint {}still denotes all possible topologies over Loc. The negation ¬Cof network constraint C is obtained by negating all its (dis)connectivity pairs. Cl early, ifCis wellformed then so is ¬C. Constrained labeled transition system s (CLTSs) provide a semantic model for the operational behavior of MANETs. Let Msg denote a set of messages communicated over a network and rang ed over bym. LetActbe the network send and receive actions with signatures nsnd:Msg×Locand nrcv:Msg, respectively. The send action nsnd(m,ℓ)denotes that the message mis transmitted from a node with the address ℓ, while the receive action nrcv(m)denotes that the message mis ready to be received. Let Actτ=Act∪{τ}, ranged over by η. Deﬁnition 2.1. ACLTS is a tuple /a\}bracke⊔le{⊔S,Λ,→,s0/a\}bracke⊔ri}h⊔, withSa set of states, Λ⊆Cv(Loc)×Actτ,→⊆ S×Λ×Sa transition relation, and s0∈Sthe initial state. A transition (s,(C,η),s′)∈→ is denoted bys(C,η)− −−− →s′. Generally speaking, the transition s(C,η)− −−− →s′expresses that a MANET protocol in state swith an underlying topology γ∈Γ(C)can perform action ηto evolve to state s′. The semantics of broadcast communication is deﬁned to be rel iable if and if only the nodes that are connected to the sender, as deﬁned by its corresponding netw ork constraint, receive the message. We remark that the status of the links from the receivers to the s ender or between two arbitrary receivers are not of importance and hence, they are abstracted away. Th erefore, by constructing such network constraints through the semantic rules, reliable communic ation is brought into our framework. 3. Syntax of RRBPT LetAdenotes a countably inﬁnite set of process names which are us ed as recursion variables in recursive speciﬁcations. Besides network send andreceive actions, i.e., nsnd(m,ℓ)andnrcv(m), we assume protocol send andreceive actions, denoted by snd,rcv:Msg, i.e., parametrized by messages. Furthermore, let IAct be a set of internal actions. The syntax of RRBPT is given by the following grammar: t::= 0|α.t|t+t|[[t]]ℓ|t/bardblt|A,Adef=t|sense(ℓ,t,t)|(νℓ)t|τm(t)|∂m(t)F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 5 The deadlock process is modeled by 0. The process α.tperforms action αand then behaves as process t, whereαis either an internal action or a protocol send/receive acti onsnd(m)/rcv(m). Internal actions are useful in modeling the interactions of a process with other applications running on the same node. Protocol send/receive actions specify the inter action of a process with its datalink layer protocols: these protocols are responsible for transferri ng messages reliably throughout the network. These actions are turned into their corresponding network o nes via the semantics (see Section 4). The processt1+t1behaves nondeterministically as t1ort2. The simplest form of a MANET is a node, represented by the network deployment operator [[t]]ℓ, denoting process tdeployed on a node with the known network address ℓ/\e}a⊔io\slash=?(where?denotes the unknown address). A MANET can be composed by putting MANETs in parallel using /bardbl; the nodes communicate with each other by reliable restrict ed broadcast. A process name is speciﬁed by a recursive equatio nAdef=twhereA∈ A is a name. MANET protocols may behave based on the (non)existence of a link. A neighbor discovery ser vice can be implemented at the data link layer, by periodical ly sending hello messages and acknowl edging such messages received from a neighbor. The sensing o peratorsense(ℓ′,t1,t2)examines the status of the link from the node, say with address ℓ, that the sensing is executed on to the node with the address ℓ′; in case of its existence it behaves as t1, and otherwise as t2. For instance, the term [[sense(ℓ′,t1,t2)]]ℓexamines the existence of the link ℓ/squigglerightℓ′, and then behaves accordingly. As a running example, Pdef=sense(B,snd(dataB).P,0)denotes a process that recursively broadcasts a data message dataBas long as it is connected to B; andQdef=rcv(dataB).deliver.Qa process that recursively receives a data message data and then the internal action deliver upon successful receipt of data. The network process [[P]]A/bardbl[[Q]]Bspeciﬁes an ad hoc network composed of two nodes with the network addresses AandBdeploying processes PandQ, respectively. The hide operator (νℓ)tconceals the address ℓin the process t, by renaming this address to ?in network send/receive actions. For each message m∈Msg, the abstraction operator τm(t)renames network send/receive actions over messages of type mtoτ, and the encapsulation operator ∂m(t)for bids receiving messages of type m. Letτ{m1,...,mn}(t)and∂{m1,...,mn}(t)denoteτm1(...(τmn(t))...) and∂m1(...(∂mn(t))...). For example, τMsg(∂Msg([[P]]A/bardbl[[Q]]B))speciﬁes an isolated MANET that cannot receive any message from the environment, while its communications (i. e., send actions) are abstracted away. Terms should be grammatically welldeﬁned, meaning that pr ocesses deployed at a network ad dress are only deﬁned by action preﬁx, choice, sense and proc ess names. Furthermore, the application of action preﬁx, choice, sense and process names is restrict ed to the deployment operator. 4. Semantics of RRBPT The operational rules in Table 1 induce a CLTS with transitio ns of the form tβ− →t′, whereβ∈ Cv(Loc)×ActτwhereAct={NAct∪IAct},NAct denotes the set of network send and receive actions, and IAct the set of internal actions ranged over by i. Assume that αdenotes actions of the form{rcv(m),snd(m)|m∈Msg}. In these rules, t/\e}a⊔io\slash(C,nrcv(m))− −−−−−−−−− → denotes that there exists no t′ such that t(C′,nrcv(m))− −−−−−−−−− → t′andC′/precedesorcurlyC. The symmetric counterparts of the rules Choice ,Bro, and Par hold, but have been omitted for the brevity. RulePreﬁx assigns an empty network constraint to each preﬁxed action, which may be accumu lated by further constraints through application of rules Rcv1orSen1,2. The rule Intindicates that a6 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y Table 1. Semantics of RRBPT operators. t1(C,α)− −−− →t′ 1 sense(ℓ,t1,t2)({ℓ/squiggleright?}∪C,α)− −−−−−−−−−−− → t′ 1:Sen1 α.t({},α)−−−−→t:Preﬁx t2(C,α)− −−− →t′ 2 sense(ℓ,t1,t2)({ℓ/ne}ationslash/squiggleright?}∪C,α)− −−−−−−−−−−− → t′ 2:Sen2tβ− →t′ (νℓ)tβ[?/ℓ]− −−− →(νℓ)t′:Hid t(C,snd(m))− −−−−−−−− → t′ [[t]]ℓ(C[ℓ/?],nsnd(m,ℓ))− −−−−−−−−−−−−−− → [[t′]]ℓ:Sndt(C,rcv(m))− −−−−−−− → t′ [[t]]ℓ(C[ℓ/?]∪{?/squigglerightℓ},nrcv(m))− −−−−−−−−−−−−−−−−−−−− → [[t′]]ℓ:Rcv1 [[t]]ℓ/\e}a⊔io\slash(C,nrcv(m))− −−−−−−−−− → ∄C′([[t]]ℓ/\e}a⊔io\slash(C′,nrcv(m)− −−−−−−−−− → ∧C /precedesorcurlyC′) [[t]]ℓ(C,nrcv(m))− −−−−−−−− → [[t]]ℓ:Rcv2 t1β− →t′ 1 t1+t2β− →t′ 1:Choicet1(C1,nsnd(m,ℓ))− −−−−−−−−−−− → t′ 1t2i(C2,nrcv(m))− −−−−−−−−− → t′ 2 t1/bardblt2(C1∪C2[ℓ/?],nsnd(m,ℓ))−−−−−−−−−−−−−−−−−−−→ t′ 1/bardblt′ 2:Bro tβ− →t′ Aβ− →t′:Inv,Adef=tt1(C1,nrcv(m))− −−−−−−−−− → t′ 1t2(C2,nrcv(m))− −−−−−−−−− → t′ 2 t1/bardblt2(C1∪C2,nrcv(m))− −−−−−−−−−−−− → t′ 1/bardblt′ 2:Recv t(C,η)− −−− →t′ t(C′,η)− −−− →t′:Exe,C′/precedesorcurlyCt(C, i)− −−− →t′ [[t]]ℓ(C, i)− −−− →[[t′]]ℓ:Intt1(C,η)− −−− →t′ 1η∈IAct∪{τ} t1/bardblt2(C,η)− −−− →t′ 1/bardblt2:Par t(C,η)− −−− →t′η/\e}a⊔io\slash=nrcv(m) ∂m(t)(C,η)− −−− →∂m(t′):Encapt(C,η)− −−− →t′ τm(t)(C,τm(η))− −−−−−− → τm(t′):AbsF . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 7 node progresses when the deployed process on the node perfor ms an internal action. Interaction be tween the process tand its datalink layer is speciﬁed by the rules Snd andRcv1,2: whentbroadcasts a message, it is delivered to the nodes in its transmission ra nge, disregarding their readiness. Rcv1 speciﬁes that a process twith an enabled receive action can perform it successfully i f it has a link to a sender (not currently known). If a node does not have any e nabled receive action nrcv(m)for the network constraint C, then receiving the message has no effect on the node behavio r, as explained byRcv2. This rule also implicitly implies that an enabled receive a ction cannot be performed when the node is disconnected from the sender (not currently know n). Consequently, this rule makes nodes inputenabled , meaning that a node not ready to receive a message will drop i t. RuleRcv2adds a network receive action (C,nrcv(m))to the behavior of a network node, speciﬁed by [[t]]ℓ, if it has no transition (C′,nrcv(m))such that C′/precedesorcurlyC. Furthermore, this rule ensures that a most general Cis selected, and hence, the receive action nrcv(m)is deﬁned for all possible network constraints (when combined with rule Exe). Therefore, [[P]]Ahas a({},nrcv(dataB))transition by application of this rule. RulesSen1,2explain the behavior of the sense operator. In case there is a link to the node with the address ℓfrom the node that is running the sense operator, and current ly its address is unknown, then it behaves like t1; in case this link is not present, it behaves like t2. Therefore, the link status is combined with the network constraint Cgenerated by its ﬁrst or second term argument, as given by Sen1,2respectively. For instance, by Preﬁx andSen1,Ponly generates a ({?/squigglerightB},snd(dataB)) transition. In rulesSnd andRcv1, the network constraint Cmay have the unknown address due to sensing operators, which is replaced by the address of the deploymen t operator, i.e., C[ℓ/?]. Therefore, by applying Snd to the only transition of P,[[P]]Agenerates a ({A/squigglerightB},nsnd(dataB))transition. RuleRecv synchronizes the receive actions of processes t1andt2on message m, while combining together their (dis)connectivity information in network c onstraints C1andC2. RuleBro speciﬁes how a communication occurs between a receiving and a sending pro cess. This rule combines the network constraints, while the unknown location (in the network con straint of the receiving process) is replaced by the concrete address of the sender. In Bro andRecv it is required that the union of network constraints on the transition in the conclusion be wellfor med. The rulePar prevents evolution of subnetworks on network actions, in c ontrast to lossy settings, and enforces all nodes to specify their localities with resp ect to the sender before evolving the whole network via Recv orBro rules. It only allows a process to evolve by performing an int ernal or silent action.Exe explains that a behavior that is possible for a network const raint, is also possible for a more restrictive network constraint. For instance, the MANET [[P]]A/bardbl[[Q]]Bcan generate the ({B/squigglerightA},nsnd(dataB,A))transition induced by the deduction tree below, where y≡deliver.Q: :Preﬁx P({},snd(dataB))− −−−−−−−−−−−− → P:Sen1 P({?/squigglerightB},snd(dataB))− −−−−−−−−−−−−−−−−− → P:Snd [[P]]A({A/squigglerightB},nsnd(dataB,A))− −−−−−−−−−−−−−−−−−−−−− → [[P]]A:Preﬁx Q({},rcv(dataB))−−−−−−−−−−−−→ y:Rcv1 [[Q]]B({?/squigglerightB},nrcv(dataB))− −−−−−−−−−−−−−−−−−− → [[y]]B:Bro [[P]]A/bardbl[[Q]]B({B/squigglerightA},nsnd(dataB,A))− −−−−−−−−−−−−−−−−−−−−− → [[P]]A/bardbl[[y]]B RuleHid replaces every occurrence of ℓin the network constraint and action of βby?, and hence hides activities of a node with address ℓfrom external observers. According to Abs, the abstraction operatorτmconverts all network send and receive actions with a message of typemtoτand leaves8 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y other actions unaffected, as deﬁned by the function τm(η). The encapsulation operator ∂mdisallows all network receive actions on messages of type m, as speciﬁed by Encap . The semantics of RRBPT was ﬁrst introduced in [22] with the aim of deﬁning CLTSs with negative connectivity pairs to illustrate their beneﬁt for model che cking MANET protocols. In this research, we modify its semantics to properly deﬁne the behavior of MAN ETs in the reliable setting. To this end, two groups of rules have been modiﬁed substantially: th ose of receive actions and the sensing operator. More speciﬁcally, the operational semantics of r eceive action in [22] explicitly speciﬁes the locality of the receiver node with respect to the sender ( that could be connected, disconnected, or unknown) through three semantic rules. Furthermore, the se mantics of the sensing operator in [22] makes[[P]]Amove by({B/\e}a⊔io\slash/squigglerightA,?/squigglerightA},nrcv(dataB))and({B/\e}a⊔io\slash/squigglerightA,?/\e}a⊔io\slash/squigglerightA},nrcv(dataB))to[[0]]A while here it has a selfloop with the label of ({B/\e}a⊔io\slash/squigglerightA},nrcv(dataB)). In other words, the chance of sending dataBis lost after dropping a received message of dataB. Such a drawback is resolved by the newly introduced rule Rcv2and removing two previous rules of the sensing operator. 5. Rooted Branching Reliable Computed Network Bisimilarit y Terms of the lossy framework RBPT are considered modulo rooted branching computed network bisimilarity [24]. This equivalence relation is deﬁned usi ng the following notations: • ⇒ denotes the reﬂexive and transitive closure of unobservabl e actions: –t⇒t; –ift(C,τ)− −−− →t′for some arbitrary network constraint Candt′⇒t′′, thent⇒t′′. •t/an}bracketle{t(C,η)/an}bracketri}ht− −−−− →t′ifft(C,η)− −−− →t′ort(C[ℓ/?],η[ℓ/?])− −−−−−−−−−− → t′andηis of the form nsnd(m,?)for some m. Intuitively t⇒t′expresses that after a number of communications, tcan behave like t′. Furthermore, an action like ({?/squigglerightB},nsnd(req(?),?))can be matched to an action like ({A/squigglerightB},nsnd(req(A),A)), which is its /a\}bracke⊔le{⊔−/a\}bracke⊔ri}h⊔counterpart. Deﬁnition 5.1. A binary relation RonRBPT terms is a branching computed network simulation if t1Rt2andt1(C,η)− −−− →t′ 1implies that either: •ηis of the form nrcv(m)orτ, andt′ 1Rt2; or •there aret′ 2andt′′ 2such that t2⇒t′′ 2/an}bracketle{t(C,η)/an}bracketri}ht− −−−− →t′ 2, wheret1Rt′′ 2andt′ 1Rt′ 2. Ris a branching computed network bisimulation if RandR−1are branching computed network simulations. Two terms t1andt2are branching computed network bisimilar, denoted by t1≃bt2, if t1Rt2for some branching computed network bisimulation relation R. This deﬁnition distinguishes process terms according to th eir abilities to broadcast messages, and therefore, MANET protocols that can only receive are treate d as deadlock as they cannot send any observable message. Deﬁnition 5.2. Two terms t1andtarerooted branching computed network bisimilar , writtent1≃rb t2, if:F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 9 •t1(C,η)− −−− →t′ 1implies there is a t′ 2such that t2/an}bracketle{t(C,η)/an}bracketri}ht− −−−− →t′ 2andt′ 1≃bt′ 2; •t2(C,η)− −−− →t′ 2implies there is a t′ 1such that t1/an}bracketle{t(C,η)/an}bracketri}ht− −−−− →t′ 1andt′ 1≃bt′ 2. Rooted branching computed network bisimilarity does not co nstitute a congruence with respect to the RRBPT operators. We still want that a receiving MANET (after its ﬁr st action) be equivalent to deadlock. In this setting, still [[0]]A≃b[[rcv(m).0]]A, but[[0]]A/bardbl[[snd(m).0]]B/\e}a⊔io\slash≃b[[rcv(m).0]]A/bardbl [[snd(m).0]]B, since by application of Rcv1,2,Snd, andBro: [[rcv(m).0]]A/bardbl[[snd(m).0]]B({B/ne}ationslash/squigglerightA},nsnd(m,B))− −−−−−−−−−−−−−−−− → [[rcv(m).0]]A/bardbl[[0]]B [[rcv(m).0]]A/bardbl[[snd(m).0]]B({B/squigglerightA},nsnd(m,B))− −−−−−−−−−−−−−−−− → [[0]]A/bardbl[[0]]B while by application of Rcv2,Snd,Bro: [[0]]A/bardbl[[snd(m).0]]B({},nsnd(m,B))− −−−−−−−−−−− → [[0]]A/bardbl[[0]]B which cannot be matched to any transition of [[rcv(m).0]]A/bardbl[[snd(m).0]]Baccording to the second condition of Deﬁnition 5.1. However, we observe that the ({},nsnd(m,B))transition can be matched to the transition sets of actions ({B/\e}a⊔io\slash/squigglerightA},nsnd(m,B))and({B/squigglerightA},nsnd(m,B)), as the network constraints {B/\e}a⊔io\slash/squigglerightA}and{B/squigglerightA}provide a partitioning of {}while the resulting states of their corresponding transitions are equivalent. Thus, we revise our Deﬁnition 5.1 by generalizing its second condition. Intuitively, two MANETs are equivalent if they have the same observable behaviors for all possi ble underlying topologies. In the lossy setting, the observ able behaviors exclude receive actions, as the node [[rcv(a).snd(a).0]]Acan be distinguished from [[rcv(a).0]]Adue to its capability to send a after its receipt. However, the capability of receiving mes sages implicitly deﬁnes a restriction on the underlying topology. For instance, the sending action snd(a)in[[rcv(a).snd(a).0]]Ais only possible if the node in question was previously connected to a sender a nd successfully received a. Thus to distinguish [[rcv(a).snd(a).0]]Afrom[[snd(a).0]]A, receive actions are included in the observables in the reliable setting. Furthermore, as dropping a message ma y have the same effect as its process ing (as explained above), a transition cannot be matched in t he same way as in Deﬁnition 5.1 and it may be matched to multiple transitions. A partitioning of a n etwork constraint Cconsists of network constraints C1,...,Cnsuch that ∀i,j≤n(i/\e}a⊔io\slash=j⇒Γ(Ci)∩Γ(Cj) =∅)∧/uniontextn k=1Γ(Ck) = Γ(C). Deﬁnition 5.3. A binary relation RonRRBPT terms is a branching reliable computed network sim ulation if t1Rt2andt1(C,η)− −−− →t′ 1imply that either: •ηis aτaction, and t′ 1Rt2; or •there ares′′ 1,...,s′′ kands′ 1,...,s′ kfor some k >0such that ∀i≤k(t2⇒s′′ i/an}bracketle{t(Ci,η)/an}bracketri}ht− −−−− → s′ i, with t1Rs′′ iandt′ 1Rs′ i), and/a\}bracke⊔le{⊔C1/a\}bracke⊔ri}h⊔,...,/a\}bracke⊔le{⊔Ck/a\}bracke⊔ri}h⊔constitute a partitioning of /a\}bracke⊔le{⊔C/a\}bracke⊔ri}h⊔. Ris a branching reliable computed network bisimulation if RandR−1are branching reliable com puted network simulations. Two terms t1andt2are branching reliable computed network bisimilar, denoted by t1≃brt2, ift1Rt2for some branching reliable computed network bisimulation relation R.10 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y Trivially(t1≃bt2)⇒(t1≃brt2). Theorem 5.4. Branching reliable computed network bisimilarity is an equ ivalence. See Section A for the proof of this theorem. Deﬁnition 5.5. Two terms t1andtarerooted branching reliable computed network bisimilar , written t1≃rbrt2, if: •t1(C,η)− −−− →t′ 1implies there is a t′ 2such that t2/an}bracketle{t(C,η)/an}bracketri}ht− −−−− →t′ 2andt′ 1≃brt′ 2; •t2(C,η)− −−− →t′ 2implies there is a t′ 1such that t1/an}bracketle{t(C,η)/an}bracketri}ht− −−−− →t′ 1andt′ 1≃brt′ 2. Corollary 5.6. Rooted branching reliable computed network bisimilarity i s an equivalence. Corollary 5.6 is an immediate consequence of Theorem 5.4 and Deﬁnition 5.5. Theorem 5.7. Rooted branching reliable computed network bisimilarity i s a congruence for RRBPT operators. See Section B for the proof. 6. Axiomatization for RRBPT To provide a sound and complete axiomatization for closed RRBPT terms with respect to rooted branching reliable computed network bisimilarity, the fra mework should be extended with the com puted network terms, i.e., (C,η).twhich expresses that action ηis possible for topologies belonging to C, in the same way as [24]. This preﬁx operator is helpful to tra nsform protocol send/receive actions into their corresponding network ones. Furthermore, it bor rows the operators left merge () and com munication merge from the process algebra ACP [29] to axiomatize parallel composition. Note that the interleaving semantics for parallel composition is onl y valid for internal and unobservable actions (see rule Par). To axiomatize the behavior of nodes while being inputena bled, we also exploit two novel auxiliary operators. RRBPT is extended with new operators and called Reliable Computed Network Process Theory (RCNT ). Its syntax contains: t::= 0|β.t|t+t|A,Adef=t|t|t|tt|t/bardblt|recA·t sense(ℓ,t,t)|(νℓ)t|τm(t)|∂m(t)|ℓ:t:t| C⊲t|[[t]]ℓ The preﬁx operator in β.tagain denotes a process which performs βand then behaves as t. The actionβcan now be of two types: either an internal action or a send/re ceive action snd(m)/rcv(m), denoted by α, or actions of the form (C,nrcv(m)),(C,nsnd(m,ℓ))and(C,τ), denoted by (C,η), where the ﬁrst two actions are called the network receive and send actions, respectively. The new operatorℓ:t1:t2, socalled local deployment , deﬁnes the behavior of process t2deployed at the network address ℓwhile it only considers the inputenabledness feature with regard to the behavior of t2. In cases that it should drop a message (i.e., processing the message has not been deﬁned by t2), it behaves as t1. This operator is helpful to axiomatize the behavior of the d eployment operator in theF . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 11 reliable setting. To axiomatize the behavior of the sense operator, the framework is extended with the topology restriction operatorC⊲twhich restricts the behavior of tby taking restrictions of Cinto account. Due to the inputenabledness feature of nodes, their behavi or is recursive: upon receiving a mes sage for which no receive action has been deﬁned, a node drops the message. To this aim, we exploit the recursion operator recA·t, which speciﬁes the solution of the process name A, deﬁned by the equation Adef=t. The process term tAis a solution of the equation Adef=tif the replacement of A bytAon both sides of the equation results in equal terms, i.e. tA≃rbt[tA/A]. As we are interested in equations with exactly one solution, we deﬁne a guardedne ss criterion for network names, in the same way as [24]. A free occurrence of a network name Aintis called guarded if this occurrence is in the scope of an action preﬁx operator (not (C,τ)preﬁx) and not in the scope of an abstraction operator [30]; in other words, there is a subterm (C,η).t′intsuch that η/\e}a⊔io\slash=τ, andAoccurs in t′.A is(un)guarded intif (not) every free occurrence of Aintis guarded. A RCNT termtisguarded if for every subterm recA·t′,Ais guarded in t′. This guardedness criterion ensures that any guarded recursive term has a unique solution. A term is grammatically welldeﬁned if its processes deploy ed at a network address through either a network or local deployment operator, are only deﬁned by ac tion preﬁx, choice, sense, and process names. The operational semantic rules of the new operators are give n in Table 2 while the counterpart of Sync2holds. In these rules, t/\e}a⊔io\slashrcv(m)− −−−− → denotes that there exists no t′such that t(C′,rcv(m))− −−−−−−−− → t′for some network constraint C′. The behavior of the local deployment operator is almost sim ilar to the de ployment operator. Its rules Inter′ 1andInter′ 2are the same as Snd andRcv1, respectively. However, it substitutes Inter′ 3forRcv2by which it only adds transitions containing the disconnect ivity pair ?/\e}a⊔io\slash/squigglerightℓfor those possible receive actions of t2(generated by Rcv1). RulesSen3,4make the behavior of sense(ℓ′,t1,t2)inputenabled toward receive actions that are possible by t1but nott2and vice versa. The constraints of the topology restriction operator C⊲tis added to the behaviors of tas explained by the rule TR. The main differences of extended RCNT with CNT are that its deployed nodes are inputenabled and its communication primitive is reliable. We use the nota tion/summationtext m∈Mtto deﬁnet[m1/m]+...+ t[mk/m], whereM={m1,...,m k}. Furthermore, if(b,t1,t2)behaves as t1if the condition bholds and otherwise as t2. The axioms regarding the choice, deployment, left and commu nication merge, and parallel op erators are given in Table 3. The axioms Ch1−4,Br,LM2,3andS1−4are standard (cf. [31]). The axiomCh5denotes that a network send action whose sender address is un known can be removed if its counterpart action exists. The axiom Ch6explains that a more liberal network constraint allows more behavior. Axioms Dep0−7,LM′ 1,2, andTRes1−5are new in comparison with the lossy setting of [24]. The axiom (C,η).t1t2= (C,η).(t1/bardblt2)has been replaced by LM′ 1,2which only allow internal or unobservable actions of the left operand to be pe rformed. To axiomatize the behavior of a node considering the inpute nabledness feature, we need to ﬁnd the messages that it cannot currently respond to and then add a su mmand which receives those message without processing them. To this aim, axiom Dep0expresses the behavior of [[t]]ℓas a recursive speciﬁcation which drops messages that it does not handle wi th the help of the auxiliary function Message(t,S), and the behavior of twith the help of the local deployment operator ℓ:Q:t. The functionMessage(t,S)returns the set of messages that can be currently processed b ytand is deﬁned12 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y Table 2. Semantics of the new operators of RCNT t2(C,snd(m))− −−−−−−−− → t′ 2 ℓ:t1:t2(C[ℓ/?],nsnd(m,ℓ))− −−−−−−−−−−−−−− → [[t′ 2]]ℓ:Inter′ 1t[recA·t/A](C,η)− −−− →t′ recA·t(C,η)− −−− →t′:Rec t2(C,rcv(m))− −−−−−−− → t′ 2 ℓ:t1:t2(C[ℓ/?]∪{?/squigglerightℓ},nrcv(m))− −−−−−−−−−−−−−−−−−−−− → [[t′ 2]]ℓ:Inter′ 2 t2(C,rcv(m))− −−−−−−− → t′ 2 ℓ:t1:t2(C[ℓ/?]∪{?/ne}ationslash/squigglerightℓ},nrcv(m))− −−−−−−−−−−−−−−−−−−−− → t1:Inter′ 3t(C′,η)− −−− →t′ C⊲t(C′∪C,η)− −−−−−− → t′:TR t1/\e}a⊔io\slashrcv(m)− −−−− → t2(C,rcv(m))− −−−−−−− → t′ 2 ℓ:t3:sense(ℓ′,t1,t2)({?/squigglerightℓ′}∪C,nrcv(m))− −−−−−−−−−−−−−−−−− → t3:Sen3 t1(C,rcv(m))− −−−−−−− → t′ 1t2/\e}a⊔io\slashrcv(m)− −−−− → ℓ:t3:sense(ℓ′,t1,t2)({?/ne}ationslash/squigglerightℓ′}∪C,nrcv(m))− −−−−−−−−−−−−−−−−− → t3:Sen4t1β− →t′ 1 t1t2β− →t′ 1/bardblt2:LExe t1(C1,nrcv(m))− −−−−−−−−− → t′ 1t2(C2,nrcv(m))− −−−−−−−−− → t′ 2 t1|t2(C1∪C2,nrcv(m))− −−−−−−−−−−−− → t′ 1/bardblt′ 2:Sync1 t1(C1,nsnd(m,ℓ))−−−−−−−−−−−→ t′ 1t2(C2,nrcv(m))− −−−−−−−−− → t′ 2 t1|t2(C1∪C2[ℓ/?],nsnd(m,ℓ))− −−−−−−−−−−−−−−−−−− → t′ 1/bardblt′ 2:Sync2F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 13 using structural induction: Message(0,S) =∅ Message(i.t,S) =∅, i∈IAct Message(snd(m).t,S) =∅ Message(rcv(m).t,S) ={m} Message(t1+t2,S) =Message(t1,S)∪Message(t2,S) Message(sense(ℓ,t1,t2),S) =Message(t1,S)∪Message(t2,S) Message(A,S) =Message(t,S ∪{A}),A/\e}a⊔io\slash∈ S,Adef=t Message(A,S) =∅,A∈ S whereSkeeps track of process names whose righthand deﬁnitions ha ve been examined. We remark thatDep0extends the deployment behavior of the lossy setting with th e input enabledness feature with the help of operator ℓ:Q:t. The axioms Dep1−7specify the behavior of the operator ℓ: t1:t2. Axiom Dep1deﬁnes the interaction between the network and data link lay ers. The protocol send action (at the network layer) is transformed into its ne twork version (at the data link layer). AxiomDep2indicates that when ℓis connected to a sender (which is unknown yet), the receive action is successful and its behavior proceeds as [[t]]ℓ. Otherwise, the receive action is unsuccessful and its behavior is deﬁned by t′. Axioms Dep3,4,5express the effect of the local deployment on choice, deadlock, and process names, respectively while ax iomsDep6,7deﬁne its effect on the preﬁxed internal actions and sense operator, respectively. The behavior of the topology restriction operator is deﬁned by the axioms TRes1−5in Table 3. AxiomTRes1considers the restrictions of C1by integrating its restrictions with C2in the computed network term (C2,η).tifC1∪C2is wellformed. Axiom TRes2deﬁnes that topology restriction can be distributed over the choice operator. Axiom TRes3expresses that the topology restriction operator can be moved inside and outside of a recursion operator. Axio msTRes4,5explain that the topology restriction operator has no effect on a process name and dead lock, respectively. For instance, the behavior of the MANET [[P]]A, wherePdef=sense(B,snd(dataB).P,0),Msg= {dataB}, is simpliﬁed as: [[P]]A=Dep0,5 recQ·({},nrcv(dataB)).Q+A:Q:sense(B,snd(dataB).P,0) =Dep7 recQ·({},nrcv(dataB)).Q+{A/squigglerightB}⊲A:Q:snd(dataB).P+{A/\e}a⊔io\slash/squigglerightB}⊲A:Q: 0 =Dep1,4 recQ·({},nrcv(dataB)).Q+{A/squigglerightB}⊲({},nsnd(dataB,A)).Q+{B/\e}a⊔io\slash/squigglerightA}⊲0 =TRes1,5 recQ·({},nrcv(dataB)).Q+({A/squigglerightB},nsnd(dataB,A)).Q The behavior of [[Q]]B, whereQdef=rcv(dataB).deliver.Q, is equated to: [[Q]]B=Dep0,5 recQ·A:Q:rcv(dataB).deliver.Q=Dep2 recQ·({?/squigglerightB},nrcv(dataB)).[[deliver.Q]]A+({?/\e}a⊔io\slash/squigglerightB},nrcv(dataB)).Q14 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y Table 3. Axioms for the choice, deployment, left and communi cation merge, and parallel operators. The sets M1andM2denoteMessage(t2,∅)\Message(t1,∅)andMessage(t1,∅)\Message(t2,∅)respectively. Ch10+t=t Ch2t1+t2=t2+t1 Ch3t1+(t2+t3) = (t1+t2)+t3 Ch4t+t=t Ch5(C,nsnd(m,?)).t+/a\}bracke⊔le{⊔(C,nsnd(m,?))/a\}bracke⊔ri}h⊔.t=/a\}bracke⊔le{⊔(C,nsnd(m,?))/a\}bracke⊔ri}h⊔.t Ch6(C1,η).t+(C2,η).t= (C1,η).t,C2/precedesorcurlyC1 Dep0[[t]]ℓ=recQ·/summationtext m′/ne}ationslash∈Message (t,∅)({},nrcv(m′)).Q+ℓ:Q:t Dep2ℓ:t′:rcv(m).t= ({?/\e}a⊔io\slash/squigglerightℓ},nrcv(m)).t′+({?/squigglerightℓ},nrcv(m)).[[t]]ℓ Dep7ℓ:t3:sense(ℓ′,t1,t2) =/summationtext m′∈M1({ℓ/squigglerightℓ′},nrcv(m′)).t3 +/summationtext m′∈M2({ℓ/\e}a⊔io\slash/squigglerightℓ′},nrcv(m′)).t3+{ℓ/squigglerightℓ′}⊲ℓ:t3:t1+{ℓ/\e}a⊔io\slash/squigglerightℓ′}⊲ℓ:t3:t2 Dep1ℓ:t′:snd(m).t= ({},nsnd(m,ℓ)).[[t]]ℓDep6ℓ:t′:i.t= ({},i).[[t]]ℓ Dep3ℓ:t3:t1+t2=ℓ:t3:t1+ℓ:t3:t2Dep4ℓ:t: 0 = 0 Dep5ℓ:t′:A=ℓ:t′:t,Adef=t TRes1C1⊲(C2,η).t= (C1∪C2,η).t, ifC1∪C2∈Cv(Loc) TRes2C⊲(t1+t2) = (C⊲t1)+(C⊲t2) TRes3C⊲recA·t=recA·(C⊲t) TRes4C⊲A=A TRes5C⊲0 = 0 Br t1/bardblt2=t1t2+t2t1+t1|t2S1t1|t2=t2|t1 LM′ 1(C,η).t1t2= 0, η/\e}a⊔io\slash∈IAct∪{τ}S2(t1+t2)|t3=t1|t3+t2|t3 LM2(t1+t2)t3=t1t3+t2t3S30|t= 0 LM30t= 0 S4(C,η).t1|t2= 0, η∈IAct∪{τ} LM′ 2(C,η).t1t2= (C,η).(t1/bardblt2), η∈IAct∪{τ} Sync1(C1,nsnd(m1,ℓ)).t1|(C2,nrcv(m2)).t2= if((m1=m2),(C1∪C2[ℓ/?],nsnd(m1,ℓ)).t1/bardblt2,0) Sync2(C1,nrcv(m1)).t1|(C2,nrcv(m2)).t2=if((m1=m2),(C1∪C2,nrcv(m1)).t1/bardblt2,0) Sync3(C1,nsnd(m1,ℓ1)).t1|(C2,nsnd(m2,ℓ2)).t2= 0F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 15 Table 4. Axiomatization of hiding, abstraction and encapsu lation operators. Res1(νℓ)(t1+t2) = (νℓ)t1+(νℓ)t2 Res3(νℓ)0 = 0 Res2(νℓ)(C,η).t= (C[?/ℓ],η[?/ℓ]).(νℓ)t Ecp1∂m((C,nsnd(m,ℓ)).t) = (C,nsnd(m,ℓ)).∂m(t) Ecp2∂m((C,nrcv(m)).t) =if((m/\e}a⊔io\slash=m),(C,nrcv(m)).∂m(t),0) Abs1τm((C,nrcv(m)).t) =if((m=m),(C,τ).τm(t),(C,nrcv(m)).τm(t)) Abs2τm((C,nsnd(m,ℓ)).t) =if((m=m),(C,τ).τm(t),(C,nsnd(m,ℓ)).τm(t)) Abs3τm(t1+t2) =τm(t1)+τm(t2) Ecp3∂m(t1+t2) =∂m(t1)+∂m(t2) Abs4τm(0) = 0 Ecp4∂m(0) = 0 T1(C′,η).((C1,η).t+(C2,η).t+t′) = (C′,η).((C,η).t+t′) iff∃ℓ,ℓ′∈Loc,∃C ∈Cv(Loc)·(C1=C ∪{ℓ/squigglerightℓ′} ∧ C2=C ∪{ℓ/\e}a⊔io\slash/squigglerightℓ′} T2(C,η).((C′,τ).(t1+t2)+t2) = (C,η).(t1+t2) The axioms of hiding and encapsulation are given in Table 4. A xiomT1accumulates the network constraints that constitute a partitioning while T2removes a τaction which preserves the behavior of a network after some topology changes. The remaining axioms in this table are similar to the lossy setting. Axioms for process names are given in Table 5. Unfold andFold express existence and uniqueness of a solution for the equation Adef=t, which correspond to Milner’s standard axioms, and the Recursive Deﬁnition Principle (RDP ) and Recursive Speciﬁcation Principle (RSP) inACP.Unfold states that each recursive operator has a solution (whether it is guarde d or not), while Fold states that each guarded recursive operator has at most one solution. The behavior of τMsg(∂Msg([[P]]A/bardbl[[Q]]B))by using the axioms of Table 5 is expressed by: τMsg(∂Msg([[P]]B/bardbl[[Q]]B)) = recQ·({A/squigglerightB},τ).({},deliver).Q+({A/\e}a⊔io\slash/squigglerightB},τ).0 which explains that in case Ais connected to B, each sending of dataBis followed by the internal actiondeliver It is not hard to see that the axioms of Table 3, Table 4 and Tabl e 5 provide a sound axiomatization ofRCNT . This can be checked by verifying soundness for each axiom in dividually. Theorem 6.1. The axiomatization is sound, i.e. for all closed RCNT termst1andt2, ift1=t2then t1≃rbt2. Our axiomatization is also groundcomplete for terms with a ﬁnitestate CLTS, but not for inﬁnite state CLTSs. For example, recW·({},nsnd(req(A),A)).W/bardbl/summationtext lx:Loc({?/squigglerightB},nrcv(req(lx))).W produces an inﬁnitestate CLTS, since at each recursive cal l a new parallel operator is generated. Its equality to recH·({},nsnd(req(A),A)).Hcannot be proved by our axiomatization.16 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y Table 5. Axioms for process names. recA·t=t{recA·t/A} Unfold t1=t2{t1/A} ⇒t1=recA·t2,ifAis guarded in t2Fold recA·(A+t) =recA·t Ung recA·((C,τ).((C′,τ).t′+t)+s) = WUng1 recA·((C,τ).(t′+t)+s),ifAis unguarded in t′ recA·((C,τ).(A+t)+s) =recA·((C,τ).(t+s)+s)WUng2 τm(recA·t) =recA·τm(t),ifAis serial in t Hid Theorem 6.2. The axiomatization is groundcomplete, i.e., for all close d ﬁnitestate reliable com puted network terms t1andt2,t1≃rbt2impliest1=t2. See sections C and D for the proofs of theorems 6.1 and 6.2, res pectively. 7. Case Study In MANETs, nodes communicate through others via a multihop communication. Hence, nodes act as routers to make the communication possible among not dire ctly connected nodes. We illustrate the applicability of our axioms in the analysis of MANET protoco ls through a simple routing protocol inspired by the AODV protocol. 7.1. Protocol Speciﬁcation The protocol consists of three processes P,M, andQ, each specifying the behavior of a node as the source (that ﬁnds a route to a speciﬁc destination), middle n ode (that relays messages from the source to the destination), and destination. The description of th ese process are given in Figure 1. Pdef=sense(B,snd(dataB).P,snd(req).P1) P1def= [rcv(repC).P2+rcv(repB).P+snd(req).P1] P2def=sense(C,rcv(error).P+snd(dataC).P2,snd(req).P1) Mdef=rcv(req).snd(req).M1 M1def=rcv(repB).snd(repC).M2+snd(req).M1 M2def=sense(B,rcv(dataC).snd(dataB).M2,snd(error).snd(req).M1) Qdef=rcv(req).snd(repB).Q+rcv(dataB).deliver.Q Figure 1. The speciﬁcation of processes P,M, andQas a part of our simple routing protocol. ProcessP, deployed at the address A, uses the neighbor discovery service of the data link layer t o examine if it has a direct link to the destination with the add ressB. If it is connected, then it sends itsF . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 17 data directly by broadcasting the message dataB; otherwise, it initiates the route discovery procedure by sending the message req, then behaving as P1. This process waits until it receives a reply from a middle name with the address CorB. In the former case, it behaves as P2which indicates that Asends it data through Cas long as Cis connected to A. In the latter case, it behaves as Pwhich indicates that Asends it data as long as Bis directly connected to A. ProcessMrelaysreqmessages to ﬁnd a route to Band then behaves as M1. This process waits until it receives a reply. To model waits with a timeout, it no ndeterministically sends a request again. Upon receiving a reply from Cit behaves as M2, indicating that it relays data messages of Aas long as it has a link to C. Finally, process Qsends a reply upon receiving a request message and receives data messages. To simplify the route maintenance procedure of AODV , the mid dle node takes advantage of the sensing operator when it behaves as M2. Whenever it ﬁnds out that it has no link to C, it sends an error message to its upstream node, i.e., A, to inform it that its route to BthroughCis not valid. Afterwards, they both execute the route discovery procedur e by sending a request message. The network with the three nodes of a source, middle, and dest ination is speciﬁed by N ≡τMsg(∂Msg([[P]]A/bardbl[[M]]C/bardbl[[Q]]B)). Analyzing (νA)(νB)(νC)N, whose network addresses have been abstracted away, reveal s that it is rooted branching bisimilar to recX·τ.deliver.X+τ.0. Thus, possibly a deadlock occurs where data is not delivered to B. Such behavior may be the result of a conceptual mistake in th e protocol design or lossy communication between AandB. However, the latter one does not exist in our reliable setting. We propose a technique in Section 7.2 to discover on ly those faulty behaviors that are due to an incorrect protocol design. The network ∂Msg([[P]]A/bardbl[[M]]C/bardbl[[Q]]B)can be simpliﬁed as: ∂Msg([[P]]A/bardbl[[M]]C/bardbl[[Q]]B) = (1) ({A/squigglerightB},nsnd(dataB,A)).∂Msg([[P]]A/bardbl[[M]]C/bardbl[[deliver.Q]]B)+ ({A/\e}a⊔io\slash/squigglerightB,A/squigglerightC},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B)+ ({A/\e}a⊔io\slash/squigglerightB,A/\e}a⊔io\slash/squigglerightC},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[M]]C/bardbl[[Q]]B). Next, we simplify ∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B)as ∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B) = (2) ({A/squigglerightB},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[snd(repB).Q]]B)+ ({A/\e}a⊔io\slash/squigglerightB},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B)+ ({C/squigglerightB},nsnd(req,C)).∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B)+ ({C/\e}a⊔io\slash/squigglerightB},nsnd(req,C)).∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[Q]]B). Now, we continue by extending ∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B): ∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B) = ({},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B)+ ({},nsnd(req,C)).∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B)+ ({B/squigglerightA,C},nsnd(repB,B)).∂Msg([[P]]A/bardbl[[snd(repC).M2]]C/bardbl[[Q]]B)+18 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y ({B/squigglerightA,B/\e}a⊔io\slash/squigglerightC},nsnd(repB,B)).∂Msg([[P]]A/bardbl[[M1]]C/bardbl[[Q]]B)+ ({B/\e}a⊔io\slash/squigglerightA,B/squigglerightC},nsnd(repB,B)).∂Msg([[P1]]A/bardbl[[snd(repC).M2]]C/bardbl[[Q]]B). By simplifying the term ∂Msg([[P]]A/bardbl[[snd(repC).M2]]C/bardbl[[Q]]B), which indicates that AandC have found a direct route to B, we reach ∂Msg([[P]]A/bardbl[[M2]]C/bardbl[[Q]]B): ∂Msg([[P]]A/bardbl[[snd(repC).M2]]C/bardbl[[Q]]B) = ({},nsnd(repC,C)).∂Msg([[P]]A/bardbl[[M2]]C/bardbl[[Q]]B)+ ({A/squigglerightB},nsnd(dataB,A)).∂Msg([[P]]A/bardbl[[snd(repC).M2]]C/bardbl[[deliver.Q]]B)+ ({A/\e}a⊔io\slash/squigglerightB},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[snd(repC).M2]]C/bardbl[[Q]]B). By extending ∂Msg([[P]]A/bardbl[[M2]]C/bardbl[[Q]]B), we have: ∂Msg([[P]]A/bardbl[[M2]]C/bardbl[[Q]]B) = ({A/squigglerightB},nsnd(dataB,A)).∂Msg([[P]]A/bardbl[[M2]]C/bardbl[[deliver.Q]]B)+ ({A/\e}a⊔io\slash/squigglerightB},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[Q]]B). Finally extending ∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[Q]]B)results: ∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[Q]]B) = ({A/squigglerightB},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[snd(repB).Q]]B)+ ({A/\e}a⊔io\slash/squigglerightB},nsnd(req,A)).∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[Q]]B)+ ({C/\e}a⊔io\slash/squigglerightB},nsnd(error,C)).∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B). The following scenario, found by above equations, is valid f or a topology in which Ahas only a multihop link to BviaC, butBhas a direct link to A: ∂Msg([[P]]A/bardbl[[M]]C/bardbl[[Q]]B) ({A/ne}ationslash/squigglerightB,A/squigglerightC},nsnd(req,A))− −−−−−−−−−−−−−−−−−−−−−−− → ∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B) ({C/squigglerightB},nsnd(req,C))− −−−−−−−−−−−−−−−−− → ∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B) ({B/squigglerightA,C},nsnd(repB,B))− −−−−−−−−−−−−−−−−−−−−− → ∂Msg([[P]]A/bardbl[[snd(repC).M2]]C/bardbl[[Q]]B) ({ },nsnd(repC,C))− −−−−−−−−−−−−−− → ∂Msg([[P]]A/bardbl[[M2]]C/bardbl[[Q]]B) ({A/ne}ationslash/squigglerightB},nsnd(req,A))− −−−−−−−−−−−−−−−−− → ∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[Q]]B) ({A/ne}ationslash/squigglerightB},nsnd(req,A))− −−−−−−−−−−−−−−−−− → ∂Msg([[P1]]A/bardbl[[M2]]C/bardbl[[Q]]B) ... The reason is found in the speciﬁcation of M2which does not handle request messages, and hence, for such a topology no data will be received by Balthough there is a path form AtoBand from Bto A. Therefore, we revise M2as: M2def=sense(B,rcv(dataC).snd(dataB).M2+rcv(req).snd(repC).M2, snd(error).snd(req).M1)F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 19 The path above also exists in the lossy setting, but with all d isconnectivity pairs removed from the network constraints. However, an exhaustive and theref ore expensive inspection of this path is needed to determine that it is due to a design error. The ﬁrst t ransition carries the label ({A/\e}a⊔io\slash/squiggleright B,A/squigglerightC},nsnd(req,A))in the reliable setting, meaning that Bis not ready to receive, and the label ({A/squigglerightC},nsnd(req,A))in the lossy setting. The latter label indicates that either Bwas not ready to receive or it was not connected to A. So in the lossy setting one has to examine the origin state to ﬁnd out if Bhad an enabled receive action or not. The concept of not being ready to receive is treated in the same way as a lossy communication. Since only the forme r may be due to a conceptual design in the protocol, ﬁnding design errors is not straightforwar d in the lossy setting. In general the lossy setting will produce a large number of possible error traces that all need to be examined exhaustively, while the reliable setting will produce no spurious error tr aces. 7.2. Protocol Analysis The properties of wireless protocols, specially MANETs, te nds to be weaker in comparison with wired protocols. For instance, the simple property of packet deli very from node AtoBis speciﬁed as “if there is a path from AtoBfor a long enough period of time, any packet sent by A, will be received by B” [21]. The topologydependent behavior of communication, and consequently the need for multi hop communication between nodes, make their properties pre conditioned by the existence of some paths among nodes. To investigate the topologydependent properties of MANET s by equational reasoning, it is nec essary to enrich our process theory RCNT to specify behaviors constrained by multihop constraints . To this aim, we extend the action preﬁx operator of RCNT with actions that are paired with multihop constraints, ﬁrst introduced in [22] and here extended by ne gative multihop connectivity pairs. View ing a network topology as a directed graph, a multihop const raint is represented as a set of multihop (dis)connectivity pairs /axisshort/axisshort/arrowaxisright:Loc×Loc and/\e}a⊔io\slash/axisshort/axisshort/arrowaxisright:Loc×Loc. For instance, A/axisshort/axisshort/arrowaxisrightCdenotes there exists a multihop connection from AtoC, and consequently Ccan indirectly receive data from A. LetM(Loc)denote the set of multihop constraints that can be deﬁned ov er network addresses in Loc, ranged over by M. Term(M,ι).t, whereι∈IAct∪ {τ}, denotes that the action ιis possible if the underlying topology satisﬁes the multihop network con straintM. Formally, a topology like γ satisﬁes the multihop network constraint M, denoted by γ|=Miff for each ℓ/axisshort/axisshort/arrowaxisrightℓ′inM, there is a multihop connection from ℓtoℓ′inγ, and for each ℓ/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightℓ′inM, there is no multihop connection fromℓtoℓ′inγ. To deﬁne a wellformed RCNT term, the rule which restricts the application of the new preﬁxedactions to sequential processes, is added t o the previous ones. Furthermore, a term cannot have two summands such that one is preﬁxed by an action of the form (C,η)and the other by an action of the form (M,ι). So terms with an action of the form (M,ι)only contain action preﬁx (with multihop constraints), choice and recursion operat ors. To reason about the correctness of a MANET protocol, its beha vior can be abstractly speciﬁed by observable internal actions with the required condition s on the underlying topology, i.e., ιactions with multihop constraints. Intuitively, each communicat ion of a protocol implementation triggers an internal action. Such communications are abstracted away b yτtransitions. Therefore, we deﬁne a novel preorder relation to examine if a protocol reﬁnes its s peciﬁcation. To this aim, a sequence of τtransitions is allowed to precede an action that is matched to an action of the speciﬁcation, as long as the accumulated network constraints of the τtransitions satisfy the multihop network constraint of the matched action. Hence our preorder relation is parame trized by a network constraint to reﬂect20 F . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y such accumulated network constraints. To provide such a relation, we use the notationC=⇒which is the reﬂexive and transitive closure of τrelations while their network constraints are accumulate d: •t{ }= =⇒t; •ift(C,τ)− −−− →t′for some arbitrary network constraint Candt′C′ =⇒t′′, thentC′∪C= ==⇒t′′, whereC′∪C is wellformed. Furthermore, the network constraint Csatisﬁes the multihop constraint C, denoted by C |=Miff ∃γ∈Γ(C)(γ|=M). We remark that a network constraint like {A/\e}a⊔io\slash/squigglerightB}may satisfy both {A/axisshort/axisshort/arrowaxisright B}and{A/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightB}, but{A/squigglerightB}only satisﬁes {A/axisshort/axisshort/arrowaxisrightB}. Deﬁnition 7.1. A binary relation RConRCNT terms is a reﬁnement relation if tRCsimplies: •ift(C′,η)− −−− →t′, whereC ∪C′∈Cv(Loc), then –η=τandt′RC∪C′swithC ∪C′|=M, or –there is an s′such that s(C,η)− −−− →s′, andt′RC∪C′s′, andC ∪C′|=M, or –η=ιfor some ι∈IAct∪{τ}and there is an s′such that s(M,ι)− −−− →s′witht′RC∪C′s′; •ifs(M,ι)− −−− →s′, then there are t′′andt′such that tC′ =⇒t′′(C′′,ι)− −−− →t′witht′′RC∪C′sand t′RC∪C′∪C′′s′; •ifs(C,η)− −−− →s′, then there is a t′such that t(C′,η)− −−− →t′witht′RC∪C′s′. The protocol treﬁnes the speciﬁcation s, denoted by t⊑s, iftR{ }sfor some reﬁnement relation R{ }. Theorem 7.2. Reﬁnement is a preorder relation and has the precongruence p roperty. See Section E for its proof. To analyze the correctness of our simple routing protocol, we investigate if it has the packet delivery property. To this end, we verify whetherτMsg(∂Msg([[P]]A/bardbl[[M]]C/bardbl [[Q]]B))reﬁnesS, whereSdef= ({A/axisshort/axisshort/arrowaxisrightB,B/axisshort/axisshort/arrowaxisrightA},deliver).S+({A/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightB},τ).0 +({A/axisshort/axisshort/arrowaxisright B,B/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightA},τ).0. To this aim, we match all the resulting terms of τtransitions to Sas long as their accumulated network constraints satisfy {A/axisshort/axisshort/arrowaxisrightB,B/axisshort/axisshort/arrowaxisrightA}. If aτtransition violates {A/axisshort/axisshort/arrowaxisright B,B/axisshort/axisshort/arrowaxisrightA}but satisﬁes {A/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightB}, then it will be matched to the transition ({A/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightB},τ). Otherwise, it will be matched to the transition ({A/axisshort/axisshort/arrowaxisrightB,B/\e}a⊔io\slash/axisshort/axisshort/arrowaxisrightA},τ). Therefore, we exploit the provided equations together with the precongruence proper ty of our reﬁnement for the choice operator and the rules of Proposition 7.3. Proposition 7.3. Supposeι∈IAct . The following rules holds (C,τ).t⊑(M,ι).s⇔ C⊲t⊑(M,ι).s∧ C |=M (C,ι).t⊑(M,ι).s⇔ C⊲t⊑sF . Ghassemi, W. Fokkink / Reliable Restricted Process Theor y 21 These rules correspond to the transfer conditions of Deﬁnit ion 7.1, and their proofs are discussed in Section E. Thus, we use Equation 1 to show that: τMsg(∂Msg([[P]]A/bardbl[[M]]C/bardbl[[Q]]B))⊑S⇔ {A/squigglerightB}⊲τMsg(∂Msg([[P]]A/bardbl[[M]]C/bardbl[[deliver.Q]]B))⊑S∧ {A/\e}a⊔io\slash/squigglerightB,A/squigglerightC}⊲τMsg(∂Msg([[P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B))⊑S∧ (3) {A/\e}a⊔io\slash/squigglerightB,A/\e}a⊔io\slash/squigglerightC}⊲τMsg(∂Msg([[P1]]A/bardbl[[M]]C/bardbl[[Q]]B))⊑0 To prove the reﬁnement relation 3, we use the Equation 2 to sho w that {A/\e}a⊔io\slash/squigglerightB,A/squigglerightC}⊲τMsg(∂Msg(P1]]A/bardbl[[snd(req).M1]]C/bardbl[[Q]]B))⊑S⇔ {A/\e}a⊔io\slash/squigglerightB,A/squigglerightC,C/squigglerightB}⊲τMsg(∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[snd(repB).Q]]B))⊑S∧ {A/\e}a⊔io\slash/squigglerightB,A/squigglerightC,C/\e}a⊔io\slash/squigglerightB}⊲τMsg(∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[Q]]B))⊑0 (4) This proof process stops when we reach to the predicate C⊲t⊑(M,ι).sto prove for which either we have previously examined C′⊲t⊑(M,ι).swhereC/precedesorcurlyC′, or it holds trivially. For instance, the reﬁnement relation (4) trivially holds as it can be proved wi th the help of our axiomatization, especially the rulesFold andTRes1,2, that{A/\e}a⊔io\slash/squigglerightB,A/squigglerightC,C/\e}a⊔io\slash/squigglerightB}⊲τMsg(∂Msg([[P1]]A/bardbl[[M1]]C/bardbl[[Q]]B))is the answer to the equation Qdef= ({A/\e}a⊔io\slash/squigglerightB,A/squigglerightC,C/\e}a⊔io\slash/squigglerightB},τ).Q, and trivially recQ·({A/\e}a⊔io\slash/squigglerightB,A/squigglerightC,C/\e}a⊔io\slash/squigglerightB},τ).Q⊑0. So, it can be easily proved that τMsg(∂Msg([[P]]A/bardbl[[M]]C/bardbl[[Q]]B))⊑S. 8. Related Work "
102,The impact of copycat attack on RPL based 6LoWPAN networks in Internet of Things.txt,"IPv6 Routing Protocol for Low-Power and Lossy Networks (RPL) is the standard
network layer protocol for achieving efficient routing in IPv6 over Low-Power
Wireless Personal Area Networks (6LoWPAN). Resource-constrained and non-tamper
resistant nature of smart sensor nodes makes RPL protocol susceptible to
different threats. An attacker may use insider or outsider attack strategy to
perform Denial-of-Service (DoS) attacks against RPL based networks. Security
and Privacy risks associated with RPL protocol may limit its global adoption
and worldwide acceptance. A proper investigation of RPL specific attacks and
their impacts on an underlying network needs to be done. In this paper, we
present and investigate one of the catastrophic attacks named as a copycat
attack, a type of replay based DoS attack against the RPL protocol. An in-depth
experimental study for analyzing the impacts of the copycat attack on RPL has
been done. The experimental results show that the copycat attack can
significantly degrade network performance in terms of packet delivery ratio,
average end-to-end delay, and average power consumption. To the best of our
knowledge, this is the first paper that extensively studies the impact of RPL
specific replay mechanism based DoS attack on 6LoWPAN networks.","Drastic growth in the development of Internetbased techno logies has been ob served in recent decades. With the start of the era when huge s ized computers re 1Department of Computer Engineering and Applications, Inst itute of Engineering & Technol ogy, GLA University, Mathura, India 2Department of Computer Engineering, National Institute of Technology Kurukshetra, India Email:∗abhiverma866@gmail.com Email: virender.ranga@nitkkr.ac.in 1The ﬁnal publication is available at https://link.springe r.com/article/10.1007/s00607020 0086212 Abhishek Verma1,2,∗, Virender Ranga2 quired too much of human intervention to the era where small sized smart devices that operate without any human intervention show that there has been a signif icant development in computer and Internetbased technolo gies. In recent years, a new networking paradigm termed as the Internet of Things (I oT) [1, 2, 3, 4] has evolved. IoT is currently seen as a fastevolving networ king paradigm that consists of smart devices that communicate to control the ph ysical surroundings. Ericcson is expecting 3 .5 Billion cellular IoT connections by 2023 and Global Data forecasts the global market for IoT technology to reach $318 Billion by 2023 [5]. A broad range of applications is being developed worldwide t o make human life safer and comfortable,e.g., ehealth, smart home, smart gr id, and smart city. Such applications are changing human lives and making it easier t o live. A drastic in crease in the number of smart devices has lead to severe cyber security risks for smart applications. These risks expose users’ security and privacy to attackers [1, 4, 6, 7, 8, 9, 10, 11]. Moreover, when healthcare and smart grid applications are exposed to attackers, such situations may even lead to li feendangering cases for human beings [12]. Most of the IoT applications are enabled by a large scale depl oyment of IPv6 over LowPowerWireless Personal Area Networks (6LoWPAN), i.e., a type of Low Power and Lossy Networks (LLNs). LLNs have lossy and low thro ughput commu nicationlinks.These networksare enabled by resourcecons traineddevices [13, 14]. Theresourceconstraineddevices(nodes)operateonlowpow er,requirelessenergy, have small onboard memory, and low computationalcapabili ties[15]. The charac teristics of LLNs make traditionalrouting protocols,incl uding Adhoc OnDemand Distance Vector (AODV), Dynamic Source Routing (DSR), Open Shortest Path First (OSPF) are unsuitable for LLNs [16]. The IPv6 Routing P rotocol for Low Power and Lossy Networks (RPL) was standardized (RFC 6550) i n 2012 [14], and it enables energy eﬃcient routing in LLNs. However, the char acteristics like self organization, selfhealing, open nature, and resource con strained nature expose RPL to a diﬀerent type of routing attacks, which may compromi se users’ security and privacy [17, 18, 19, 20]. In recent years, vulnerabiliti es and threats associated with RPL have been rigorously explored by the researchers. I n this paper, the main focus is on packet replay attacks, which may aﬀect the Qu ality of Service (QoS) of realtime wireless networks. In wireless network based replay attacks [21, 22], an attack er node eavesdrops on broadcast messages of legitimate nodes and later sends th e previously eaves droppedmessagetoitsneighbornodes.Thus,thevictimnode sareforcedtobelieve thatthe informationthey received is fresh, whichis not.Th is situationmaylead to undesirable consequences like packet loss and degraded net work performance. In RPL, the replay attack is mainly performed by replaying cont rol messages rather than data messages. Thus, the victim nodes are forced to upda te their routing tables with obsolete routing information that leads to the c reation of nonoptimal topology and degraded routing performance. In this paper, an RPL protocol speciﬁc replay attack named as the copycat attack is presented, and its impact on the underlying networ k is analyzed. The copycat attack is a DenialofService (DoS) attack, which c an catastrophically de grade the performance of RPL based networks in terms of Packe t Delivery Ratio (PDR), Average EndtoEnd Delay (AE2ED), and Average Power Consumption (APC). To launch this attack, an attacker node eavesdrops DO DAG Information Object (DIO) control messages of legitimates nodes, and lat er sends the previImpact of Copycat Attack on RPL protocol 3 ously eavesdropped DIO messages many times with ﬁxed replay interval. In this manner, an attacker induces victim nodes to choose nonopti mal parents, which consequently leads to the creation of nonoptimal routes. A lso, an attacker does not need to have any high range radio antenna or any other spec ialized hardware to perform copycat attacks. The novelty of this paper is that it presents a novel routing attack that targets RPL protocol and analyzes the at tack impact in terms of prominent performance evaluation metrics. In addition, this paper also suggests some possible solutions that can be used to mitigate the prop osed routing attack. The remaining paper is structured in the following way. Sect ion 2 presents the background of this study. In Section 3, some relevant resear ch works are described. The copycat attack is presented in Section 4. A detailed disc ussion of the exper imental evaluation of the copycat attack is presented in Sec tion 5. Some possible solutions for addressing copycat attacks are discussed in S ection 6. The paper is concluded in Section 7. 1.1 Motivation There are several works that have suggested replay attacks w ith respect to RPL protocol [6, 23, 24]. However, none of the works has performe d an indepth study on how such attacks take place in the RPL based networks and no t analyzed the impacts of such attacks. This motivated us to pursue the curr ent research work in order to fulﬁll this research gap. 1.2 Major Contributions The major contributions of the paper are mentioned below: 1. An RPL speciﬁc replay mechanism based DoS attack named as t he copycat attack is presented. 2. Anindepthexperimentalstudyforanalyzingtheimpacts ofthecopycatattack on RPL based 6LoWPAN networks is carried out. 3. Possible solutions to address copycat attacks have been s uggested to motivate future research towards the development of defense solutio ns. 2 Background This section provides brief overview of 6LoWPAN and RPL prot ocol. 2.1 6LoWPAN 6LoWPAN[25,26]combinesIPv6andLowPowerWirelessPerso nalAreaNetwork (LoWPAN). It allows resource constrained (power, memory, a nd processing) de vices to communicate and share data wirelessly using IPv6. I t enables the smallest devices to be a part of the global IoT network. Devices in 6LoW PAN can commu nicate with other 802 .15.4based devices, and the devices operatingon the Internet4 Abhishek Verma1,2,∗, Virender Ranga2 connected through various wireless communication technol ogies like WiFi, black tooth, and Nearﬁeld Communication[27]. IPv6 is used in IoT because of its large address space and its capability to provide global connecti vity to nodes. However, it cannot be directly applied in IoT because of resource cons trained devices. For this purpose, 6LoWPAN deﬁnes a compressed version of IPv6 th at is well suited for IoT. It speciﬁes mechanisms for shortening IPv6 128bit address, header com pression to reduce transmission overhead, packet fragment ation for meeting the needs of IEEE 802 .15.4 127 byte Maximum Transmission Unit limit, and sup port for multihop packet delivery. 6LoWPAN acts as an adapt ation layer in IoT communication protocol stack. 2.2 RPL Routing Protocol RPL is among popular routing protocols due to its ﬂexible nat ure, QoS support, and energyeﬃcientrouting capability[28, 29, 30, 31]. It h as been standardized for 6LoWPAN [32], and its speciﬁcations are depicted in RFC 6550 [14]. RPL is based on distancevector and source routing protocols. It operat es above IEEE 802 .15.4 MAC layerprotocol.RPL supports pointtopoint,multipoi nttopoint,and point tomultipoint topologies. RPL virtually creates a Destina tion Oriented Directed Acyclic Graph (DODAG) topologicalstructure from nodes. DO DAG is a loopfree and treelike topological structure. A single IoT network c ontains multiple paral lelRPLInstance running at a single time, and a single RPLInstance may contain multiple DODAGs. RPLInstance is identiﬁed by RPLInstanceID while DODAG is identiﬁed by DODAG ID which is a unique IPv6 address. The pr imary charac teristics of the RPL are autoconﬁguration,selfhealing, loop avoidance and detec tion, transparency, and support for multiple sinks. RPL use s four types of control messages for creating and maintaining DODAG: (i) DIO, (ii) D ODAG Informa tion Solicitation (DIS), (iii) Destination Advertisement Object (DAO), and (iv) Destination Advertisement Object Acknowledgment (DAOAC K). An Objective function (OF) is an important part of RPL, which is responsib le for the selection and optimization of routes between DODAG nodes. OF utilizes diﬀerent metrics and constraints for choosing optimal parent among various p referred choices, i.e., preferred parents. ETX Objective function (ETXOF) [33], Mi nimum Rank with Hysteresis ObjectiveFunction (MRHOF) [34], Objective Fun ction Zero (OF0) [35] are prominent OF of RPL. Each DODAG node is assigned a rank, wh ich serves a signiﬁcant role in DODAG management. Rank represents the n ode’s position with respect to the DODAG root. RPL speciﬁes a strict rank rul e. According to the rank rule, the rank value increases in DODAG’s downward d irection (root to leaves) and viceversa. RPL’s rank concept is used in RPL: (1) detection and resolving of routing loops; (2) to maintain a parentchild r elationship; (3) to dis tinguish between parents and siblings; (4) to restore broke n links. DIO message contains routing informationthat is needed by nodes to ﬁnd e xistingRPLInstance and RPL conﬁguration parameters. DODAG node uses routing in formation con tained in the DIO message to choose its preferred parent set. DIS message is used by a node to solicit a DIO message from an existing DODAG node. DIS message is primarily used when a new node wants to ﬁnd nearby DODAG. DA O messages are used to create downward routes. DAOACK message is used b y the root node to send an acknowledgment of the DAO message [36]. RPL uses “T rickle timer”Impact of Copycat Attack on RPL protocol 5 to limit the transmission of control messages in the network [37] and minimize energy consumption. The trickle timer is reset in case of inc onsistency detection, i.e., loops and link loss, change in parent set. The trickle t imer interval is increased or decreased in case of a stable network and inconsistency de tection, respectively. In the case of a stable network, the interval is increased in o rder to decrease the number of DIO’s been transmitted in the network. Whereas, up on detection of topological inconsistency, the interval is reduced to incr ease the number of DIO’s to ﬁx the inconsistency quickly [38]. 3 Related Work "
2,A QoS Routing Protocol based on Available Bandwidth Estimation for Wireless Ad Hoc Networks.txt,"At the same time as the emergence of multimedia in mobile Ad hoc networks,
research for the introduction of the quality of service (QoS) has received much
attention. However, when designing a QoS solution, the estimation of the
available resources still represents one of the main issues. This paper
suggests an approach to estimate available resources on a node. This approach
is based on the estimation of the busy ratio of the shared canal. We consider
in our estimation the several constraints related to the Ad hoc transmission
mode such as Interference phenomena. This approach is implemented on the AODV
routing protocol. We call AODVwithQOS our new routing protocol. We also
performed a performance evaluation by simulations using NS2 simulator. The
results confirm that AODVwithQoS provides QoS support in ad hoc wireless
networks with good performance and low overhead.","solution, the estimation of the available resources  still represents one of the main issues. This pape r  suggests an approach to estimate available resource s on a node. This approach is based on the  estimation of the busy ratio of the shared canal. W e consider in our estimation the several constraint s  related to the Ad hoc transmission mode such as Int erference phenomena. This approach is implemented  on the AODV routing protocol. We call AODVwithQOS o ur new routing protocol. We also performed a  performance evaluation by simulations using NS2 sim ulator. The results confirm that AODVwithQoS  provides QoS support in ad hoc wireless networks wi th good performance and low overhead.  KEYWORDS    Mobile Ad hoc networks, QoS, Available resources, E stimation, Constraints, Shared canal, Interference  phenomena.    1.  INTRODUCTION   Ad hoc mobile networks, employing the IEEE 802.11 p rotocol in Distributed Coordination  Function (DCF) mode, are becoming increasingly popu lar. In DCF mode, the 802.11 protocol  does not require any centralized entity to coordina te user’s transmissions. Nodes are free to  move around, join and leave the network as needed. As this happens, new links form as nodes  come within range of each other, and existing links  break as two nodes move out of range of  each other. These constant changes in topology impo se a significant challenge for the  communication protocols to continue to provide mult ihop communication between nodes. In  fact, a key issue in MANETs is the necessity to est ablish an efficient and correct route between  a pair of nodes so that messages may be delivered i n a timely manner that what we calls the  routing techniques. Several routing protocols have been developed. Such solutions must deal  with the typical limitations of these networks, whi ch include high power consumption, low  bandwidth. However, most of theme considers the bes t effort data traffic and neglect  connections with qualityofservice (QoS) requireme nts, such as voice channels with delay and  bandwidth constraints.  Bandwidth is a crucial component of qualityofserv ice (QoS) in MANETs because the network  topology may change constantly, and the available s tate information (such as the bandwidth)  for routing is inherently imprecise. Recent years h ave seen a strong interest in techniques for  estimating available bandwidth along a path in Ad h oc Networks. The available bandwidth International Journal of Computer Networks & Commun ications (IJCNC) Vol.3, No.1, January 2011    220   between two neighbour nodes is defined as the maxim um throughput that can be transmitted  between these two peers without disrupting any ongo ing flow in the network [1]. In fact,  available bandwidth estimation is useful for path s election in Ad hoc networks.   Actually, our goal is to compute estimations in ord er to provide accurate guarantees to  applications and ensuring that guarantees offered t o ongoing applications in the network still  hold if a new flow is accepted and shaped according  to our estimation. To compute the value of  this remaining bandwidth, each node uses only its l ocal perception to evaluate the proportion of  time the medium is free. This measurement can give indications on the remaining bandwidth.  Our scheme does not modify the CSMA/CA MAC protocol  in any manner, but gauges the  effect of phenomena such as medium shared, RTS/CTS mechanism, interference, which  influence the available bandwidth, on it.  We propose, in this paper, a new model to estimate available bandwidth estimation. Section 2  briefly discusses some related works in the area . We expose the constraints that effect the  estimation of available bandwidth in section 3. Tho se constraints are obtained throw an  experimental and theoretical studies.  In section 4, we present the technique to calculate  the  foccup_bp that provides an accurate available bandw idth. We focus after that on the routing  strategy that employs the foccup_bp in section 5. A nd Section 6 shows some experimental  evaluations.   2.  RELATED WORKS   "
262,On the Complexity of Anonymous Communication Through Public Networks.txt,"Onion routing is the most widely used approach to anonymous communication
online. The idea is that Alice wraps her message to Bob in layers of encryption
to form an ""onion,"" and routes it through a series of intermediaries. Each
intermediary's job is to decrypt (""peel"") the onion it receives to obtain
instructions for where to send it next, and what to send. The intuition is
that, by the time it gets to Bob, the onion will have mixed with so many other
onions, that its origin will be hard to trace even for an adversary that
observes the entire network and controls a fraction of the participants,
possibly including Bob.
  In spite of its widespread use in practice, until now no onion routing
protocol was known that simultaneously achieved, in the presence of an active
adversary that observes all network traffic and controls a constant fraction of
the participants, (a) fault-tolerance, where even if a few of the onions are
dropped, the protocol still delivers the rest; (b) reasonable communication and
computational complexity as a function of the security parameter and the number
of participants; and (c) anonymity.
  In this paper, we give the first onion routing protocol that meets these
goals: our protocol (a) tolerates a polylogarithmic (in the security parameter)
number of dropped onions and still delivers the rest; (b) requires a
polylogarithmic number of rounds and a polylogarithmic number of onions sent
per participant per round; and (c) achieves anonymity. We also show that to
achieve anonymity in a fault-tolerant fashion via onion routing, this number of
onions and rounds is necessary.
  Of independent interest, our analysis introduces two new security properties
of onion routing -- mixing and equalizing -- and we show that together they
imply anonymity.","Suppose that Alice wishes to send a message anonymously to Bo b. Informally, by anonymously , we mean that no one (not even Bob) can distinguish the scenari o in which Alice sends a message to Bob from an alternative scenario in which it is Allison who sends a message to Bob. To begin with, Alice can encrypt the message and send the encrypted me ssage to Bob so that only Bob can read the message. However, an eavesdropper observing the se quence of bits coming out of Alice’s computer and the sequence of bits going into Bob’s computer c an still determine that Alice and Bob are communicating with each other if the sequences of bit s match. Thus, encryption is not enough. Onion routing [Cha81] is the most promising approach to anon ymous channels to date. In onion routing, messages are sent via intermediaries and wrapped i n layers of encryption, resulting in so called onions; each intermediary’s task is to “peel oﬀ” a lay er of encryption and send the resulting onion to the next intermediary or its ﬁnal destination. The o nion’s layers are unlinkable to each other, and so its route through the network cannot be traced f rom merely observing the sequences of bits that Alice transmits and Bob receives. However, even with Alice sending her message to Bob encoded as an onion, her communication can still be track ed by a resourceful eavesdropper with an extensive view of the network traﬃc (e.g., an ISPlev el or an ASlevel adversary) who can observe all Internet traﬃc. An adversary who can observe all network traﬃc is called a network adversary . An adversary who, in addition to observing all network traﬃc, controls a s ubset of the participants, is called the passive adversary if it follows the prescribed protocol, or activeif it does not. The three adversary models—thenetworkadversary, thepassiveadversary, andt heactive adversary—arestandardfor analyzing cryptographic protocols such as multiparty com putation (MPC) [GMW87]. The most desirable goal is to achieve security in the presence of the m ost powerful of these three adversaries, i.e., the active adversary, corrupting as large a fraction o f the participants as possible. It was known how to construct an onion routing protocol that i s both eﬃcient and anonymous from the passive adversary who corrupts a constant fraction of the parties; an example o f this is the protocol Π p[ALU18]. In Π p, each user forms an onion bearing his message to its recipien t; the users’ onions are routed independently and uniformly at ran dom through a network of servers. Π p is anonymous from the passive adversary provided that the on ions travel for a superlogarithmic (in the security parameter) number of rounds, and the averag e number of onions per server per round is also superlogarithmic [ALU18] . However, Π pisn’t anonymous from the active adversary who causes the parties under his control to deviate from the p rotocol. To see why this is the case, consider the following attack: Suppose that the adversary Asuspects that Alice is communicating with Bob. Because Ais active, he can disrupt Alice’s communication by dropping Alice’s outgoing onion in the event that Alice’s ﬁrst intermediary is corrupt (the probability of this event is identical to the fraction of parties that are under the adversary’s con trol). If Bob doesn’t receive an onion at the end of the protocol, then Acan infer that her suspicion was correct: Alice’s interlocu tor is Bob! So what can we do instead? Of course, we could use generalpur pose multiparty computation (MPC) [GMW87]. Every party will receive as input a message an d its destination, and every party will receive as output the messages that were meant for him/h er. In addition to perfect anonymity, this approach provides fault tolerance: in MPC that is secur e against the active adversary, the honest parties are guaranteed to receive their output no mat ter how much the adversary deviates from the protocol. The problem with this approach that relie s ongeneralpurpose MPC is that it is too ineﬃcient: the most eﬃcient general MPC protocol stil l requires that at least some of the participants send and receive Ω( N) bits, where Nis the number of participants. (See Cramer, 1Damg˚ ard, and Nielsen [CDN15].) Recently proposed protocols, Stadium [TGL+17] and Atom [KCDF17], are more eﬃcient. How ever, they are not faulttolerant: honest parties will abor t the protocol run whenever even a single message packet is dropped. Thus, while this approach provid es anonymity from the active ad versary, it is also extremely fragile: if just one message is dropped (which could be the result of an innocuous fault), the entire network suﬀers a catastrophi c failure. In contrast, we would like to design onion routing protocols that can tolerate faults. Thus, compared to MPC and Stadium Atomtype protocols, onion routingappears attractive fro m the eﬃciency and fault tolerance points of view. In this paper, we answer these fundamental questions: (1) Ca n an onion routing protocol be si multaneously anonymous, faulttolerant, and eﬃcient? (2) What is the communication complexity suﬃcient for anonymous and faulttolerant onion routing? (3) What is the communication com plexityrequired for this? We provide a lower bound and match it with a nearly op timal protocol. 1.1 Problem setting Before describing our results in detail, let us ﬁrst deﬁne ou r problem setting. Let Pdef= {P1,P2,...,P N}denote the set of Nparties, participating in an onion routing protocol. We assume that the protocol progresses in global rounds and tha t an onion sent at round rarrives at its destination prior to round r+ 1. Moreover, the adversary is modelled with rushing, i.e., the adversary receives onions sent in round rinstantaneously in round r.1We assume that the numberNof participants and every other quantity in the protocol is p olynomially bounded in the security parameter λ. Setup. We deﬁne an onion routing protocol to be a protocol in which the honest parties form and process only message packets that are cryptographic oni ons. To do this, the honest parties use a secure onion encryption scheme, which is a triple of alg orithms: ( Gen,FormOnion ,ProcOnion ). See Section 2.1 for more details and Camenisch and Lysyanska ya’s paper [CL05] and followup papers [KBS19,AL20] for formal deﬁnitions, including secu rity deﬁnitions. During setup of an onion routing protocol, each honest party Pgenerates a publickey pair (pk(P),sk(P))←Gen(1λ) using the onion encryption scheme’s key generation algori thmGen. Each partyPpublishes his/her public key pk(P) to a public directory so that everyone knows everyone else’s public keys. Inputs: the simple input/output setting. LetMbe the space of ﬁxedlength messages. An input σ= (σ1,...,σ N) to the protocol is a vector of inputs, where σiis a set of message recipient pairs for party Pi. Form∈MandPj∈P, the inclusion of a messagerecipient pair (m,Pj) in input σimeans that party Piis instructed to send message mto recipient Pj. In this paper, we consider the following “benchmark” input s pace, dubbed the simple in put/output setting (I/O) . An input σ= (σ1,...,σ N) is in the simple I/O setting if there exists a permutation function π:P/ma√sto→Psuch that each party P∈Pis instructed to send a message to partyπ(P) andnoothermessage, i.e., ∀P∈P,∃mP∈Ms.t.σP={(mP,π(P))}.2ThesimpleI/O 1We do not consider the asynchronous communication model [CR 93] in which Alice’s outgoing onions (including her onion to her recipient Bob) can be delayed indeﬁnitely. I n such a case, we cannot even guarantee correctness (i.e., message delivery when no party deviates from the prot ocol). 2Why do we need a benchmark? As the following shows, without ap propriately constraining the input space, the onion cost can be arbitrarily high: Suppose that the adversa ry observes the traﬃc (i.e., the onions) on all links but does not corrupt any of the parties. The adversary knows that each party will send a ﬁxedlength message to the 2setting is a superset of the spaces considered in prior works [vdHLZZ15,TGL+17,KCDF17,ALU18]. Adversary model. Unless stated otherwise, the adversary is active and can obs erve the traﬃc on all communication channels and, additionally, can nona daptively corruptand control a constant fraction of the parties. By nonadaptively , we mean that the corruptions are made independently of any protocol run.3Without loss of generality, this type of corruption is captu red by allowing the adversary to select the set Badof corrupted parties prior to the beginning of the protocol. Once the adversary corrupts a party, the adversary can observe th e internal state and computations of the corrupted party and arbitrarily alter the behavior of th e party. Views and outputs. ByVΠ,A(1λ,σ), we denote the adversary A’s view from interacting with protocol Π on input the security parameter 1λand the instructions σ. The view consists of all the observations that Amakes during the run: the values and positions of every onion at every round, the states and computations of every corrupted party between every pair of consecutive rounds, the randomness used by A, and the numbers of messages received by the honest parties. The view does not include the honest parties’ randomness. VΠ,A,Bad(1λ,σ) denotesA’s view given its choice Badfor the corrupted parties. At the end of the protocol run, eac h honest party Pi outputs the set OΠ,A i(1λ,σ) of (nonempty) messages from the message space MthatPireceives from interacting with adversary Ain a run of protocol Π on input σ. We deﬁne the output OΠ,A(1λ,σ) of protocol Π in an interaction with adversary Aon input σas theNparties’ outputs:4 OΠ,A(1λ,σ)def= (OΠ,A 1(1λ,σ),OΠ,A 2(1λ,σ),...,OΠ,A N(1λ,σ)). 1.2 Our results We now describe our results in more detail. Our construction pertains to the problem setting described in Section 1.1. Our lower bound applies more gener ally to any arbitrary input set (not necessarily constrained to the simple I/O setting). Anonymity, mixing, and equalizing. Following prior work [vdHLZZ15,TGL+17,KCDF17, ALU18], we use a natural gamebased deﬁnition of anonymity: A protocol is anonymous if the adversary cannot distinguish the scenario in which Alice se nds a message to Bob while Carol sends one to David, from one in which Alice’s message goes to David w hile Carol’s goes to Bob. (See Deﬁnition 3.) More precisely, for any pair of inputs ( σ0,σ1) that agree on the inputs and outputs for the adversarial participants, OΠ,A(1λ,σ0)≈OΠ,A(1λ,σ1), where “≈” denotes computational indistinguishability. We relate anonymity of an onion routing protocol to two new co ncepts: An onion routing proto colmixesif it suﬃciently shuﬄes the honest users’ onions making it in feasible for the adversary to trace a received message back to its sender. A protocol equalizes if the adversary cannot determine the input from the numbers of messages received by the partie s; in other words, the number of “central hub” H∈P(and no one else) but doesn’t know which party is H. A protocol that is anonymous in this setting necessarily incurs a large communication overhead . This is because a party who receives fewer than Nonions cannot be H, and so, all but one party must receive at least Ndummy onions. 3If we were to allow the adversary to adaptively corrupt parti es, then the adversary could easily block all of Alice’s onions. For every onion Osent by Alice, the adversary can corrupt the party Pwho receives Oin time to direct P to drop the onion obtained from processing Obefore the next round. 4Technically, the view and the output may depend on other para meters, such as the public parameters (denoted, pp) and the parties’ states (denoted, states). Thus, we could be more precise by denoting the view and the o utput as VΠ,A(1λ,pp,state,σ) andOΠ,A(1λ,pp,states,σ), but we will use the simpler notation for better readabilit y. 3messages output by each participant — or the fact that a parti cipant did not receive an output at all — are random variables that are computationally unrel ated to the input vector σ. (See Deﬁnitions 4 and 5.) We show that in many cases, mixing and equalizing implies ano nymity, i.e., an onion routing protocol thatmixesandequalizes isanonymous. (SeeTheore m1fortheformaltheoremstatement.) We use this to prove that our protocol is anonymous. Anonymit y also implies equalizing; this observation is useful for proving a lower bound that (almost ) matches our protocol. Eﬃcient, robust, and anonymous onion routing. As we just explained, our strategy is to construct a protocol that mixes and equalizes. Intuitively, mixing is the easier one to achieve: the onions need to suﬃciently shuﬄe with other onions traveling over the network to ensure that each of them is hard to trace. This intuition is essentially correct, with the caveat that an active adversa ry can strategically interfere with this process by dropping onions. To ensure that each onion shuﬄes with a suﬃciently large number of onions (formed by an honest party) a suﬃciently large numb er of times, our protocol uses checkpoint onions [ALU18] that each intermediary expects to receive, and if a c onstant fraction (e.g., onethird) of them don’t arrive because the adversar y dropped them, the protocol aborts. An active adversary who controls a fraction of the participa nts can try to “isolate” an honest party Alice from the rest of the network by dropping all of the messages/onions received directly from Alice. In a faulttolerant network protocol, the remai ning participants may still be able to get their messages through to their destinations. Thus, based o n who received an output, an adversary can infer who Alice’s intended recipient was. This attack ex plains why equalizing is diﬃcult to achieve. To overcome this attack, we introduce a new type of onions, ca lledmerging onions . When two merging onions belonging to the same pair arrive at some inte rmediary I,Irecognizes that they are from the same pair (although, other than their next layer and destination, Idoes not learn anything else about them). The protocol directs Ito discard one of them (chosen at random) while sending its mate along. If only one onion of the pair arrived a tIwhile its mate is missing (i.e. the adversary dropped it some time earlier in the protocol run), thenIsimply sends along the mate that survived, and there is nothing to discard. Why does this help? Suppose that both Alice and Allison creat ed 2hmerging onions; at rounds r1,r2,...,rheach of these onions (if it hasn’t been deleted yet) will meet a mate. Say, exactly one of Alice’s onions is dropped by the adversary at some point pr ior to round r1, so its mate (the onion it was supposed to pair with at round r1) was not dropped. Also, suppose that none of Allison’s onions were dropped. Then at round r1all but one of Alice’s remaining merging onions will meet a mate, and half of them will be dropped, so exactly 2h−1of Alice’s onions will remain in the system — which is exactly how many of Allison’s onions remain . Additional h−1 opportunities to merge account for the possibility that the adversary has dro pped a larger number of Alice’s onions. Merging onions ensure that the number of Alice’s onions that remain in the system at the end of the protocol is the same as the number of Allison’s onions, i. e., that the protocol equalizes. The fact that Alice was targeted and many of her onions had been dr opped doesn’t matter, because the protocol discards all but one of them anyway! (See Sectio n 4 for a more indepth description of merging onions and how to construct them.) Positive result: We construct an onion routing protocol Π ⊲⊳, pronounced “Pibutterﬂy,” be cause it uses a butterﬂy network. Π ⊲⊳takes advantage of the merging onions technique described above. It is (1) anonymous from the active adversary who can c orrupt up to a constant fraction κ <1 2of the parties and (2) robust, i.e. whenever the adversary dr ops at most logarithmic (in the 4security parameter) number of message packets (i.e. onions ), Π⊲⊳delivers the messages from honest senders with overwhelming probability. Moreover, (3) duri ng the execution of the protocol, every honest party transmits up to a polylog (in the security param eter) number of onions: speciﬁcally γ1logNlog3+γ2λonions, where Nis the number of participants, and λis the security parameter. γ1andγ2are parameters that can be set as desired: increasing them in creases the rate at which the maximum distance in the adversarial views for any two inp uts shrinks. (See Theorem 3 for the precise relationship.) Matching negative result. Our protocol is essentially optimal as far as both the round c om plexity and the number of onions each participant sends out a re concerned. For why anonymity requires superlogarithmic round complexity, we refer the r eader to prior work [DMMK20,Chr20]. In Section 7, we explain why a protocol that is robust and anon ymous in the presence of an active adversary that corrupts a constant fraction of participant s requires a polylogarithmic number of onions sent out per participant. 1.3 Related work "
223,Supervised Permutation Invariant Networks for Solving the CVRP with Bounded Fleet Size.txt,"Learning to solve combinatorial optimization problems, such as the vehicle
routing problem, offers great computational advantages over classical
operations research solvers and heuristics. The recently developed deep
reinforcement learning approaches either improve an initially given solution
iteratively or sequentially construct a set of individual tours. However, most
of the existing learning-based approaches are not able to work for a fixed
number of vehicles and thus bypass the complex assignment problem of the
customers onto an apriori given number of available vehicles. On the other
hand, this makes them less suitable for real applications, as many logistic
service providers rely on solutions provided for a specific bounded fleet size
and cannot accommodate short term changes to the number of vehicles. In
contrast we propose a powerful supervised deep learning framework that
constructs a complete tour plan from scratch while respecting an apriori fixed
number of available vehicles. In combination with an efficient post-processing
scheme, our supervised approach is not only much faster and easier to train but
also achieves competitive results that incorporate the practical aspect of
vehicle costs. In thorough controlled experiments we compare our method to
multiple state-of-the-art approaches where we demonstrate stable performance,
while utilizing less vehicles and shed some light on existent inconsistencies
in the experimentation protocols of the related work.","The recent progress in deep learning approaches for solving combinatorial optimization problems (COPs) has shown that speciﬁc subclasses of these problems can now be solved efﬁciently through training a parameterized model on a distribution of problem instances. This has most prominently been demonstrated for the vehicle routing problem (VRP) and its variants (Kool et al. (2019); Chen & Tian (2019); Xin et al. (2021)). The current leading approaches model the VRP either as a local search problem, where an initial solution is iteratively improved or as a sequential construction process successively adding customer nodes to individual tours until a solution is achieved. Both types of approaches bypass the implicit binpacking problem that assigns packages (the customers and their demands) to a predeﬁned maximum number of bins (the vehicles). We show that this assignment can be learned explicitly while also minimizing the main component of the vehicle routing objective, i.e. the total tour length. Furthermore, ﬁnding a tour plan for a ﬁxed ﬂeet size constitutes an essential requirement in many practical applications. To this end, many small or mediumsized service providers cannot accommodate ﬂeet size adjustments where they require additional drivers on short notice or where very high acquisition costs prohibit the dynamic extension of the ﬂeet. Figure 1 shows the variation of ﬂeet sizes for different problem sizes. For all problem sizes the baseline approaches (green, red, purple) employ more vehicles than our approach (blue, orange) and thereby inquire potentially more costs by requiring more vehicles. In contrast our vanilla approach (blue) guarantees to solve the respective problems with exactly the apriori available number of vehicles (4, 7, 11 for the VRP20, VRP50, VRP100 respectively) or less. Our approach of learning to construct a complete, valid tour plan that assigns all vehicles a set of customers at once has so far not been applied to the VRP. We amend and extend the Permutation Invariant Pooling Model (Kaempfer & Wolf 1arXiv:2201.01529v1  [cs.LG]  5 Jan 2022Under Review (2018)) that has been applied solely to the simpler multiple Traveling Salesmen Problem (mTSP), for which also multiple tours need to be constructed, but are albeit not subject to any capacity constraints. In this work we propose an endtoend learning framework that takes customercoordinates, their associated demands and the maximal number of available vehicles as inputs to output a bounded num ber of complete tours and show that the model not only learns how to optimally conjunct customers and adhere to capacity constraints, but that it also outperforms the learningbased reinforcement learning (RL) baselines when taking into account the total routing costs. By adopting a fullﬂedged supervised learning strategy, we contribute the ﬁrst framework of this kind for the capacitated VRP that is not only faster and less cumbersome to train, but also demonstrates that supervised methods are able, in particular under practical circumstances, to outperform stateoftheart RL models. 2 3 4 5 6 7 Fleet Size010002000300040005000600070008000Test InstancesOurs Ours** AM MDAM NLNS (a)VRP with 20 Customers 5 6 7 8 9 10 Fleet Size02000400060008000Test InstancesOurs Ours** AM MDAM NLNS (b)VRP with 50 Customers 8 9 10 11 12 13 14 15 Fleet Size0200040006000800010000Test InstancesOurs Ours** AM MDAM NLNS (c)VRP with 100 Customers Figure 1: Histograms over the ﬂeet sizes used for solving the VRP. Our approach (blue) is able to solve the VRP with 20, 50, 100 customers with 4, 7 and 11 vehicles respectively, while the baseline approaches (see section 5) utilize considerably more vehicles. Our approach (orange) refers to the setting of where we ensure a solution to be found (see section 4.3) The contributions of this work can be summarized as follows: •Tourplan construction approach for the capacitated VRP with ﬁxed Vehicle Costs : We propose a deep learning framework that learns to solve the NPhard capacitated VRP and constructs a complete tourplan for an speciﬁed ﬂeet size. In this way it ensures to solve the problem for an apriori ﬁxed number of vehicles. •Supervised learning for discrete optimization : The proposed approach is the ﬁrst MLbased construction approach for the VRP that relies entirely on supervised learning to output feasible tours for all available vehicles. •Competitiveness : We compare our model against prominent stateoftheart deep learning and OR solvers through a thorough and uniﬁed experimental evaluation protocol that ensures comparability amongst different MLbased approaches. We show that our approach delivers competitive results in comparison to approaches that work only for unbounded ﬂeet sizes and outperforms these methods when considering ﬁxed vehicle costs. 2 R ELATED WORK "
393,Secure Multipath Routing Scheme using Key Pre-Distribution in Wireless Sensor Networks.txt,"Multipath routing in WSN has been a long wish in security scenario where
nodes on next-hop may be targeted to compromise. Many proposals of Multipath
routing has been proposed in ADHOC Networks but under constrained from keying
environment most seems ignorant. In WSN where crucial data is reported by nodes
in deployment area to their securely located Sink, route security has to be
guaranteed. Under dynamic load and selective attacks, availability of multiple
secure paths is a boon and increases the attacker efforts by many folds. We
propose to build a subset of neighbors as our front towards destination node.
We also identified forwarders for query by base station. The front is optimally
calculated to maintain the security credential and avail multiple paths.
According to our knowledge ours is first secure multipath routing protocol for
WSN. We established effectiveness of our proposal with mathematical analysis","  WSN network evolved as monitoring tool in adverse, dynamically changing environment.  Besides being used for security critical applications it surfaced into daily life monitoring systems   ranging from mining applications to steel furnace reporting, from li braries to under water  monitoring, from moisture controlling to dam reservoir controller, from toll plaza to grocery  stores. Applications are in abundance and so are the issues. With increasing demands for  customized setups of WSNs new issues also surfaced . It needs custom solutions to demanding  situations. Many works has addressed the specific issues in WSN. We specifically limit ourselves  to problem of maintaining multiple routes not necessarily node disjoint through networks which  are equally secure and have qualified under a complex qualifying criterion in threat prone  deployment areas. Besides improving upon best effort delivery we tried to maintain high value of  protection keys in the links. We are working on the principle that route is as strong as th e weakest  link in the route. We have proposed a probabilistic model for selecting our front towards a  specific destination. Proposal has been generic and we specialized it to achieve security  requirements in the threat prone deployments. Probabilistic mode l can be specialized for other  requirements like distance, energy, throughput and delay. Section 2 discusses related work in the  area with section 3 and 4presenting network and probabilistic analytical model of proposal and  routing scheme. Section 5 we pre sent performance analysis. With Section 6 we finally conclude  and cite future directions.    International Journal in Foundations of Computer Science & Technology (IJFCST), Vol.4, No.4, July 20 14    50 ݊݋݅ݐܽ݊݅ݐݏ݁ܦ  ݁ܿݎݑ݋ܵ   ݒ݊ ݒ1  ݒ2 2. RELATED WORKS   "
174,Compressed Sensing based Protocol for Efficient Reconstruction of Sparse Superimposed Data in a Multi-Hop Wireless Sensor Network.txt,"We consider a multi-hop wireless sensor network that measures sparse events
and propose a simple forwarding protocol based on Compressed Sensing (CS) which
does not need any sophisticated Media Access Control (MAC) scheduling, neither
a routing protocol, thereby making significant overhead and energy savings. By
means of flooding, multiple packets with different superimposed measurements
are received simultaneously at any node. Thanks to our protocol, each node is
able to recover each measurement and forward it while avoiding cycles.
Numerical results show that our protocol achieves close to zero reconstruction
errors at the sink, while greatly reducing overhead. This initial research
reveals a new and promising approach to protocol design through CS for wireless
mesh and sensor networks.","Wireless sensor networks are used in large sensing areas where multihop routing is needed to forward the informatio n from the sensors to the sinks. When a sensor wakes up according to an event and then measures a physical value, it ﬁrst needs to schedule its transmission in an interferenc e free slot using a Media Access Control (MAC) layer scheme and then to use a speciﬁc routing protocol in order to ﬁx the next hop before reaching the ﬁnal sink. Those steps include heavy operationsforsmall sensors and consumea big quantit y of energy. However, they are mandatory in order to avoid collisions and to determine the best routes to reach sinks. Recently,thegroundbreakingtheoryofCompressedSensing (CS) was developed, which stipulates that a vector with correlated entries, i.e., that can be transformed into a spa rse vector through a transformation basis, can be recovered wit h high accuracy from a few random projections onto another, incoherent basis [1] [2] [3]. CS, which has been widely used in the domains of digital signal and image processing, is envisioned as a highly promising tool for improving the per formance of wireless communication networks. In particula r, based on the decentralized compression techniques present ed in [4], there has been a number of works exploiting CS in wireless sensor networks dealing with spacetime correlat ed data as in [5][6]. In these works, the underlying assumption isthat all sensor nodes have a data to send which are gathered at the sink and reconstructed with few observations using CS techniques. The transmission of each data follows some predetermined routes, such that packets are received witho ut errors.In [7], the CS techniqueis combinedto the wellknow n Network Coding (NC), which provides an efﬁcient method for data communication in wireless networks, as multiple packets aggregated in a single packet are decoded using prio r information. Introducing CS enabled to mitigate the proble m of exploding header size with NC where the header grew proportionally to the number of aggregated packets, since it became possible to decode the salient information from fewer number of packets. Note also that, as a consequence, CS enables to signiﬁcantly decrease the delay required by NC for gathering packets, as at least ndifferent combined packets were needed to decode npackets. However, in this work too, the transmissions follow predetermined routes in order to avoid any collision, i.e., packets are aggregated from node to node and not “overtheair”. By contrast, [8] considersa onehopsensornetworkwheremultiplenodesmay transmittheir measurementsimultaneouslyto the sinks. As the measured events are assumed to be sparse, i.e., the number of measurements simultaneously received at the sink is much smaller than the total number of sensors, the sink is able to recovereachmeasurementfromthesuperimposedsignalsfro m few observations, thanks to CS algorithms. Such an approach is also taken for developing new multiple access schemes for random data trafﬁc in [9], for channel reservation in [10], a nd for downlink scheduling in [11]. In this work, we consider a multihop wireless sensor network and take the approach of [8]–[11] where the events to be reported occur sparsely. Each sensor with a value to report combines it with its signature sequence giving its Identity(ID)andbroadcaststheresultingvectortoitsnei ghbor nodes. We develop a protocol based on CS and ﬂooding that enables the sink to obtain and reconstruct the sparse mea surement data with high accuracy without any heavy routing nor MAC protocol. In a onehop network, the simultaneouslyreceived measurements may be resolved by the CSbased algorithms in [8]–[11], but they pose major problems in a multihop network where every node forwards all received packets, as the number of interfering measurement packets may be increased drastically, thereby causing the CSbased algorithmsto performpoorlydueto lossofsparsity.Moreov er, if different measurements of a same source but generated at different times are contained in the same packet, they would be hardly resolvable. To alleviate the aforementione d issues, in our protocol,the length of the signature sequenc esis further increased so that each sequence can identify the sou rce node and time stamp, which allows to avoid cycles in the ﬂooding process as follows. When neighboring nodes receive the superimposedpackets,theyﬁrst recovereachmeasureme nt data from an underdetermined system of equations, using a CS algorithm based on ℓ1ℓ2optimization, commonly used in the case of noisy measurements [12]. After decoding each data, they check in their local tables if it was already sent, using the recovered origin node ID and time stamp from its sequence; if it is the case, they discard the data. If not, they again superimpose each data into a unique packet which is broadcasted to their neighbors. This process is repeated until reaching the sink. In addition to avoiding cycles, thi s process allows to maintain the ”sparsity” of the superimpos ed data by discarding superﬂuous packets, thereby guaranteei ng a good performance of the CS algorithms. Still, the length of these sequences is far below the total number of possible combinationsofIDsandtimestamps,whichwouldberequired in a CDMAbased protocol. Many advantages are offered by our new protocol: •Sensors do not need any MAC scheduling that consumes resources, energy and increase the delivery delays. •Sensors do not need any routing protocols that need manycontrolmessagesthat waste the bandwidthandalso increase the energy consumption. •Decoding in the sensors needs processing power and consumes energy. However, those operations represent a negligible consumption compared to the radio reception, listening, transmission used by the MAC scheduling. •The time stamp represents an additional overhead but is bounded by, e.g., the maximum number of hops in a network. We show that it represents a negligible part compared to the overhead induced by a routing protocol and even compared to a ﬂoodingbased protocol with CDMA. •While discarding packets that have already been for warded for keeping sparsity of the superimposed data and avoiding cycles, our protocol still offers diversity fo r each measurement data as a packet may reach the sink by many routes. Even if a packet is lost, the sink or the intermediate nodes may receive it by other routes. The paper is organized as follows: after giving some basic results in Compressed Sensing and presenting related works , we explain the system model and our proposed protocol. The simulation results show its effectiveness, while reducing theamount of overhead compared to conventional protocols. II. RESULTS FROM COMPRESSED SENSING Compressed Sensing is a newly developed mathematical theory that enables to solve underdetermined systems of equations under the sparsity prior of the solution, a proble m formulated as (P0) : min x/bardblx/bardbl0,subject to y=Ax,(1) wherex∈RN,y∈RM,A∈RM×NwithM < N, and /bardblx/bardbl0=card{i,xi/ne}ationslash= 0}, where sparsity of xis deﬁned by /bardblx/bardbl0=K << N . However,this isa nonconvexoptimization problem that requires combinatorial search over all possib le sparse combinations of columns of A, which rapidly becomes intractable. Therefore, convex relaxation of this problem has been considered by the following ℓ1minimization, (P1) : min x/bardblx/bardbl1,subject to y=Ax,(2) where/bardblx/bardbl1=/summationtextn i=1|xi|, for which various efﬁcient algo rithms have been developed, among which Pursuit algorithms and Iterative Shrinkage Algorithms [12]. Under the assumption of noisy observations, the optimiza tion problem may be reformulated as (Pǫ 1) : min x/bardblx/bardbl1,subject to /bardbly−Ax/bardbl2≤ǫ,(3) whichcanbeequivalentlyexpressedasan ℓ1−ℓ2minimization problem, (Pλ 1−2) : min xλ/bardblx/bardbl1+1 2/bardbly−Ax/bardbl2 2,(4) where the parameter λcan be viewed as a Lagrange Mul tiplier making a tradeoff between representation error an d sparsity of the solution. It was shown that random matrices Awhose entries are drawn from Gaussian or SubGaussian (e.g.,Bernouilli) distributions,guaranteestable recov eryin the noisy case, provided that the number of measurements obey M≥cKlog(N/K), (5) wherecis a constant (this condition guarantees that A will guarantee the Restricted Isometry Property (RIP) with high probability, enabling stable recovery by ℓ1minimization, see [12] and references therein). In our proposed protocol, we will employ the Iterative ShrinkageThresholding Algorit hm (ISTA) [13] as it efﬁciently solves the ℓ1−ℓ2minimization (Pλ 1−2)with very low complexity. III. RELATED WORK "
95,Performance Evaluation of Aodv&DSR with Varying Pause Time & Node Density Over TCP&CBR Connections in Vanet.txt,"Vehicular ad hoc network is formed by cars which are called nodes; allow them
to communicate with one another without using any fixed road side unit. It has
some unique characteristics which make it different from other ad hoc network
as well as difficult to define any exact mobility model and routing protocols
because of their high mobility and changing mobility pattern. Hence performance
of routing protocols can vary with the various parameters such as speed, pause
time, node density and traffic scenarios. In this research paper, the
performance of two on-demand routing protocols AODV & DSR has been analyzed by
means of packet delivery ratio, loss packet ratio & average end-to-end delay
with varying pause time and node density under TCP & CBR connection.","VANET (vehicular adhoc network) is an autonomous &  selforganizing wireless communication network. In this network the cars are called nodes which involve  themselves as servers and/or clients for exchanging &  sharing information. This is a new technology thus  government has taken huge attention on it. There are many  research projects around the world which are related with VANET such as COMCAR [1], DRIVE [2], FleetNet [3]  and NoW (Network on Wheels) [4], CarTALK 2000 [5], CarNet [6].    There are several VANET applications such as Vehicle collision warning, Security distance warning, Driver  assistance, Cooperative driving, Cooperative cruise control, Dissemination of road information, Internet  access, Map location, Automatic parking, and Driverless  vehicles. In this paper, we have evaluated performance of AODV  and DSR based on TCP and CBR connection with varying  pause time and also various network parameters and  measured performance metrics such as packet delivery  ratio, loss packet ratio and average endtoend delay of  this two routing protocol and compared their performance. The remainder of the paper is organized as follows:  Section 2 describes two unicast routing protocols AODV and DSR of VANET. Section 2 describes previous work  related to performance evaluation of AODV and DSR and  section 3 discusses about AODV and DSR. Section 4 describes connection types like TCP and CBR. Section 5  presents performance metrics and the network parameters.   Section 6 presents our implementation. We conclude in  Section 7 and section 8 for reference.  2. Related Work  "
104,Mobile Ad Hoc Networks: A Comparative Study of QoS Routing Protocols.txt,"This Article presents a thorough overview of QoS routing metrics, resources
and factors affecting performance of QoS routing protocols. The relative
strength, weakness, and applicability of existing QoS routing protocols are
also studied and compared. QoS routing protocols are classified according to
the QoS metrics used type of QoS guarantee assured.","Mobile Ad Hoc Networks (MANETs) is a class of wireless  networks that have been researched extensively over the recent  years [1]. MANETs do not require the support of wired access  points or base stations for inte rcommunication. A mobile ad hoc  network, unlike a static network, has no infrastructure. It is a  collection of mobile nodes where communication is established in the absence of any fixed foundation. The only possible direct  communication is between neighboring nodes. Therefore,  communication between remote nodes is based on multiplehop. These nodes are dynamically and arbitrarily located in such a manner that the interconnections between nodes are capable of  changing on a continual basis. MANE Ts are selfconfiguring; there  is no central management system with configuration  responsibilities. All the mobile  nodes can communicate each other  directly, if they are in other’s wireless links radio range. In order to  enable data transfer they either communicate through single hop or  through multiple hops with the help of intermediate nodes. Since MANETs allow ubiquitous service access, anywhere, anytime without any fixed infrastructure they can be widely used in military  battlefields, crisis management services, classrooms and conference  halls etc. MANETs adhoc fashion networking developments lead to development of enormous multimedia applications such as videoondemand, video conferencing etc. Routing in mobile ad  hoc networks and some fixed wireless networks use multiplehop  routing. Routing protocols for this kind of wireless network should  be able to maintain paths to other nodes and, in most cases, must be handle changes in paths due to mobility. However, most of the  existing Ad Hoc routing protocols do not consider the QoS problem. Quality of Service (QoS) is the performance level of a  service offered by the network to the user. Most of the multimedia  applications have stringent QoS requi rements that must be satisfied.  The goal of QoS provisioning is to achieve a more deterministic network behavior, so that information carried by the network can  be better delivered and network resources can be better utilized.  However, there still remains a significant challenge to provide QoS  solutions and maintain endtoend QoS with user mobility. Most of  the conventional routing protocols are designed either to minimize  the data traffic in the network or to minimize the average hops for  delivering a packet. [1]. Even some protocols such as Adhoc On  demand Distance Vector (AODV) [2], Dynamic Source Routing  (DSR) [3] and Ondemand Multicast Routing Protocol (ODMRP)  [4] are designed without explicitly considering QoS. When QoS is  considered, some protocols may be unsatisfactory or impractical due to the lack of resources and the excessive computation overhead. QoS routing usually involves two tasks: collecting and  maintaining uptodate state info rmation about the network and  finding feasible paths for a connection based on its QoS  requirements. [5] To support QoS, a service can be characterized  by a set of measurable pre specified service requirements such as  minimum bandwidth, maximum delay, maximum delay variance  and maximum packet loss rate. However many other metrics are  also used to quantify QoS and in this paper we cover most of them  in detail.  The remainder of this paper is organized as follows. In Section 2, we discuss related works in terms of QoS routing surveys and summarize their main points. Revi ew of the several challenges  faced by the provision of QoS on the MANET environment is given is section 3. In section 4, we analyze the QoS routing metrics commonly used by all applications and the tradeoffs involved in the protocol design. Section 5 and 6 presents the taxonomy of QoS  routing protocols based on their network architecture, type of QoS  guarantee assured and the interaction with the MAC layer. Following this, we summarize and compare the operations, key features and major advantages and drawbacks of a selection of QoS  routing protocols proposed in the literature. Finally we draw the  conclusions and discuss our findings  in the field of QoS routing.  We ask that authors follow some simple guidelines. In essence, we  ask you to make your paper look exactly like this document. The  easiest way to do this is simply to download the template, and  replace the content with your own material.     2. RELATED WORKS  "
292,Efficient and Secure Routing Protocol for Wireless Sensor Networks through SNR based Dynamic Clustering Mechanisms.txt,"Advances in Wireless Sensor Network Technology (WSN) have provided the
availability of small and low-cost sensor with capability of sensing various
types of physical and environmental conditions, data processing and wireless
communication. In WSN, the sensor nodes have a limited transmission range, and
their processing and storage capabilities as well as their energy resources are
limited. Triple Umpiring System (TUS) has already been proved its better
performance on Wireless Sensor Networks. Clustering technique provides an
effective way to prolong the lifetime of WSN. In this paper, we modified the Ad
hoc on demand Distance Vector Routing (AODV) by incorporating Signal to Noise
Ratio (SNR) based dynamic clustering. The proposed scheme Efficient and Secure
Routing Protocol for Wireless Sensor Networks through SNR based dynamic
Clustering mechanisms (ESRPSDC) can partition the nodes into clusters and
select the Cluster Head (CH) among the nodes based on the energy and Non
Cluster Head (NCH) nodes join with a specific CH based on SNR Values. Error
recovery has been implemented during Inter cluster routing itself in order to
avoid end-toend error recovery. Security has been achieved by isolating the
malicious nodes using sink based routing pattern analysis. Extensive
investigation studies using Global Mobile Simulator (GloMoSim) showed that this
Hybrid ESRP significantly improves the Energy efficiency and Packet Reception
Rate (PRR) compared to SNR unaware routing algorithms like Low Energy Aware
Adaptive Clustering Hierarchy (LEACH) and Power- Efficient Gathering in Sensor
Information Systems (PEGASIS).","  Sensor Network Wireless is widely considered as one of  the most important technologies for the twenty first  century.  The sensing electronics measure ambient  conditions related to the environment surrounding th e  sensors and transform them  in to an electrical signal. In  many WSN applications, the deployment of sensor nodes  is performed in an ad hoc fashion without careful  planning and engineering. In the past few years, an  intensive research that addresses the po tential of  collaboration among sensors in data gathering  and  processing and in the coordination and management of the  sensing activities were conducted.  However,  sensor  nodes are constrained in energy supply and bandwidth.      Energy conservation is critica l in Wireless Sensor  Networks. Replacing or  recharging batteries is not an  option for sensors deployed in hostile environments.   Generally,  communication electronics in the sensor  utilizes most energy. Stability is one of the major  concerns in advancement o f Wireless Sensor Networks  (WSN). A number of applications of WSN require  guaranteed sensing, coverage and connectivity throughout  its operational period. Death of the first node might cause  instability in the network. Therefore, all of the sensor  nodes in  the network must be alive to achieve the goal  during that period. One of the major obstacles to ensure  these phenomena is unbalanced energy consumption rate.  Numerous  techniques were proposed to improve energy  consumption rate such as clustering, efficien t routing, and  data aggregation.      In a typical WSN application, sensor nodes are scattered  in a region from where they collect data to achieve certain  goals. Data collection may be continuous, periodic or  event based process. WSN must be very stable in so me of  its applications like security monitoring and motion   tracking.   Death of only one sensor node may disrupt  coverage or  connectivity and thus may  reduce stability in this sort of  applications.  Therefore, all of the deployed sensor nodes  in WSN must be active during operational lifetime.  However, sensor nodes are generally equipped with one  time batteries and most of the batteries are of low energy.  For this reason, each sensor node must efficiently use its  available energy in order to improve the lifeti me of WSN.  Different techniques are used for efficient usage of this  low available energy in a sensor node. Clustering is one  of these most well known  techniques.     Li et al [1] have investigated the joint Power Allocation  (PA) issue in  a class of MIMO rela y systems.   By using  the capacity and the mean square error ( MSE ) as  optimization  criterion, two joint PA optimization  problems have  been formulated.  As the cost functions  derived directly from the  capacity and the MSE would  lead to nonconvex optimization,  two modified  cost  functions corresponding to a convex problem  of the  source and the relay power weighting coefficients have   been developed. The key contribution of the proposed  method  lies in the discovery of a tight bound for the  capacity and the  MSE tha t simplifies the joint source and  relay power allocation  into a convex problem. A distinct  feature of the new method is  that the power allocation  within the source and that within the  relay are jointly  optimal for any given power ratio of the two  units.     It was studied in [2] that the joint power allocation  problem for multicast systems can achieve better data  rate. To deal with the nonconvex optimization problem, a  highSNR approximation is employed to modify the  original cost  function in order to obtain a  convex  minimization problem,  where the approximation is shown  to be asymptotically optimal  at the high SNR regime. As  an alternative, an iterative  algorithm has been developed  by utilizing the convexity  property of the cost function  with respect to  a part  of the whole power  coefficients.  Considering the low complexity of the physical layer  network  coding in the multi cast system, the lattice based  network coding that uses the proposed joint power   allocation schemes has been suggested.     In this paper,  we ha ve developed a Hybrid Efficient and  Secure Routing Protocol through SNR  based dynamic  Clustering mechanisms  (ESRPSDC ), which is a  combination of SNR,  based dynamic Clustering and  routing pattern based  security mechanisms. We did a brief  comparison of ESRPS DC with LEACH  and PEGASIS ,  two of the popular routing protocols. The rest  of this  paper is organized as follows  In Section 2, the related  work is briefly reviewed and discussed. Then we describe  our network model, adversary model and notations used  through out in this paper in Section 3. Simulation Results are presented in Section 4. We conclude this paper in  Section 5 .  II. Related Work   "
44,Vehicle routing by learning from historical solutions.txt,"The goal of this paper is to investigate a decision support system for
vehicle routing, where the routing engine learns from the subjective decisions
that human planners have made in the past, rather than optimizing a
distance-based objective criterion. This is an alternative to the practice of
formulating a custom VRP for every company with its own routing requirements.
Instead, we assume the presence of past vehicle routing solutions over similar
sets of customers, and learn to make similar choices. The approach is based on
the concept of learning a first-order Markov model, which corresponds to a
probabilistic transition matrix, rather than a deterministic distance matrix.
This nevertheless allows us to use existing arc routing VRP software in
creating the actual route plans. For the learning, we explore different schemes
to construct the probabilistic transition matrix. Our results on a use-case
with a small transportation company show that our method is able to generate
results that are close to the manually created solutions, without needing to
characterize all constraints and sub-objectives explicitly. Even in the case of
changes in the client sets, our method is able to find solutions that are
closer to the actual route plans than when using distances, and hence,
solutions that would require fewer manual changes to transform into the actual
route plan.","Route planning at SME companies is constrained by the limited number of vehicles, the capacity of each delivery vehicle, and the scheduling horizon within which all deliveries have to be made. The objective, often implicitly, can include a wide range of company goals including reducing operational costs, minimizing fuel consumption and carbon emissions, as well as optimizing driver familiarity with the routes and maximizing fairness by assigning tours of similar duration to the drivers. Daily plans are often created in a route optimization software that is capable of producing plans that are optimal in terms of route length and travel time. We have observed, however, that in practice, route planners heavily modify the result given by the software, or simply pull out, modify, and reuse an old plan that has been used and known to work in the past. The planners, by performing these modications, are essentially optimizing with their own set of objectives and personal preferences.arXiv:1909.07893v1  [cs.AI]  17 Sep 20192 Rocsildes Canoy and Tias Guns The goal of this research is to learn the preferences of the planners when choosing one option over another and to more eectively reuse all of the knowl edge and eort that have been put into creating previous plans. Our focus is on intelligent tools that learn from historical data, and can hence manage and recommend similar routes as used in the past. In collaboration with a small transportation company, one of our initial steps was to analyze their historical data. Close data inspection has conrmed that the route planners often rely on historical data in constructing the daily plans, which is consistent with the observations gathered during company visits. To learn from historical data, we take inspiration from various machine learn ing research on route prediction for a single vehicle. Markov models developed from historical data have been applied to driver turn prediction, prediction of the remainder of the route by looking at the previous road segments taken by the driver, and predicting individual road choices given the origin and destination. These studies have produced positive and encouraging results for those tasks. Hence, in this work, we investigate the use of Markov models for predicting the route choices for an entire  eet, and how to use these choices to solve the VRP. With a rstorder Markov model, route optimization can be done by maxi mizing the product of the probabilities of the arcs taken by the vehicles, which corresponds to maximizing the sum of log likelihoods. Hence, a key property of our approach is that it can use any existing VRP solution method. This is a promising, novel approach to the vehicle routing problem. This paper's contributions are presented in the succeeding sections as follows. After a brief literature review, we present in Section 3 our transition probability matrix reformulation of the VRP. In Section 4, we introduce the algorithm for learning the transition matrix from historical data and its dierent variants. The comparison of the dierent construction schemes and the experimental results on actual company data are shown in Section 5. 2 Related Work "
365,One More Weight is Enough: Toward the Optimal Traffic Engineering with OSPF.txt,"Traffic Engineering (TE) leverages information of network traffic to generate
a routing scheme optimizing the traffic distribution so as to advance network
performance. However, optimize the link weights for OSPF to the offered traffic
is an known NP-hard problem. In this paper, motivated by the fairness concept
of congestion control, we firstly propose a new generic objective function,
where various interests of providers can be extracted with different parameter
settings. And then, we model the optimal TE as the utility maximization of
multi-commodity flows with the generic objective function and theoretically
show that any given set of optimal routes corresponding to a particular
objective function can be converted to shortest paths with respect to a set of
positive link weights. This can be directly configured on OSPF-based protocols.
On these bases, we employ the Network Entropy Maximization(NEM) framework and
develop a new OSPF-based routing protocol, SPEF, to realize a flexible way to
split traffic over shortest paths in a distributed fashion. Actually, comparing
to OSPF, SPEF only needs one more weight for each link and provably achieves
optimal TE. Numerical experiments have been done to compare SPEF with the
current version of OSPF, showing the effectiveness of SPEF in terms of link
utilization and network load distribution.","The primary role of Internet Service Providers (ISPs) is to guarantee service via deploying infrastructures, manag ing network connectivity and balancing trafﬁc load inside thei r networks [12]. The goal of Trafﬁc Engineering (TE) is to ensure efﬁcient routing to minimize network congestion, so that users can experience low packet loss, high throughput, and low latency. Trafﬁc Engineering leverages information from trafﬁc entering and leaving the network to generate a routing scheme that optimizes network performance. In particular, an ISP solves the TE problem by adjusting the routing conﬁguration to the prevailing trafﬁc. In this paper, we focus on trafﬁc engineering within a single Autonomous Systems (AS), in which we assume that the egress point of each external destination is known and ﬁxed.Trafﬁcengineeringthusdependsonasetofperformanc e objectives that guide path selection, as well as effective m ech anisms for routers to select paths that satisfy these object ives [15]. Open Shortest Path First (OSPF) is a commonly used intra domain routing protocol [24], which provides the network operators a way to control network routing by conﬁguringOSPF link weights. The quality of OSPFbased trafﬁc en gineering depends largely on the choice of weights. Link weights can have a reasonable default conﬁguration based on link capacity, e.g., Cisco’s InvCap [13] sets the weight of a link inversely proportional to its capacity, which can be explained by the M/M/1queuing model. Although fairly intuitiveandconvenient,thesesettingapproachesmightl eadto undesirable network load distribution, since they do not ta ke the expected trafﬁc demand into consideration. In practice , givennetworklinkcapacitiesandexpectedtrafﬁcdemands, the link weights can be optimized by ISPs according to a certain object function. However, computing the optimal link weigh ts under the evenly trafﬁc splitting scheme has been proven to be NPcomplete [16]. Challenges .Inthispaper,wetakeanimportantsteptowards building an OSPFbased routing protocol that can achieve th e optimal trafﬁc engineering. Although this optimization pr ob lem has attracted a great research interest and beenextensi vely studied (e.g., [18], [19], [23]), there are still several ch allenges to be further studied, including the following: 1.Can we design a generic objective function to meet various providers’ needs? Network providers are usually interested in various indicators to improve the network per  formance in different ways, e.g.,some of them might prefer to lower the maximum link utilization, while others might try to minimize path lengths. Accordingly, various objecti ve functions have been proposed to capture these demands. Un fortunately, a set of optimal link weights with one objectiv e function does not necessarily perform well with another ob jective function, or may be even worse. Are there common features existed among these different objective function s? Can we design a generic objective function to meet providers ’ needs? 2.Can we guarantee the universal existence of optimal link weights? Preceding researches showed that the optimal link weights existed with a certain kind of object functions . Although this outcome is encouraging to some extent, we stil l preferto ensurethe universalexistence ofoptimallink wei ghts under various objective functions. 3.Can we achieve the optimal TE for intradomain IP networks based on OSPF? As a distributed linkstate routingprotocol,OSPF usestheshortestpathroutingwith d es tinations based hopbyhop forwarding and EqualCost Mult i Path (ECMP) mechanism to evenly split the corresponding trafﬁc over all available equalcost paths. Many approache sareproposedattemptingtoachievethe“optimal”routingba sed on OSPF. Wang et al. [19] and Srivastava et al. [18] proposed ﬂexible solutions to efﬁciently split trafﬁc over shortest paths, but these centralizedsolutionswent againstthe distribut edfea ture of OSPF. A new linkstate protocolnamed PEFT, recently proposed by Xu et al. [20], successfully realized a ﬂexible trafﬁc splitting scheme in a distributed manner, whereas fa iled to maintain the shortest paths in packet forwarding thus sacriﬁcing a key beneﬁt of OSPF. Guaranteeing the crucial featuresof OSPF in terms of scalability and efﬁciencyare th us a great challenge in achieving the optimal trafﬁc engineeri ng goals based on OSPF. Our Approachand Contributions .Inspiredbythefairness criterion of congestion control [10], we ﬁrstly propose a generic objective function named (q,β)proportional load balance to consider various load balance demands in TE. Then we model the optimal TE as the utility maximization of multicommodity ﬂows and propose a distributed dual decomposition method to compute the optimal link weights. Based on these, we develop a new OSPFbased protocol, Shortest paths Penalizing Exponential Flowsplitting (SP EF). It has been proved able to achieve the optimal TE. Toward the optimal TE, in SPEF, we only need one more weight for each link. For simplicity, we hereafter refer to t he optimal and the additional link weights as the ﬁrst and secon d link weights, respectively. We use the Network Entropy Max imization (NEM) framework proposed in [20] to obtain the second link weights, aiming at maintaining the path diversi ty. In SPEF, packets forwarding is the same as OSPF: hopby hop along the shortest paths constructed based on destinati on according to the ﬁrst link weights. When there are multiple shortest paths for some source destination pairs in view of the ﬁrst link weights, the ﬂow split ratio over the multiple shortest paths can be independently computed by the routers from the second link weights. In particular, we address the above challenges as follows: 1. To capture various operators’ needs, we design a new generic objective function motivated by the fairness conce pt in congestion control [10], (q,β)proportional load balance, from which a family of load balance objective functions coul d be derived to meet various providers’ needs. E.g., (q,β) proportional load balance could converge to minmax load balance with the increase of β, making the MLU minimized. It can also reduce to proportional load balance with β= 1, corresponding to maximizing the product of unused capacity in networks. The generic objective function provides a chan ce to make a tradeoff by operators, since they can just simply vary parameter settings according to their special needs. 2.Toensuretheexistenceofoptimallinkweights,wemodel theoptimalTEastheutilitymaximizationofmulticommodi ty ﬂows with the generic objective function and theoretically show that any given set of optimal routes corresponding to a particular objective function can be converted to shortes t paths with respect to a set of positive link weights, which ca n be explicitly formulated using the spare network capacity a nd objective function.3. To achieve the optimal TE based on OSPF, we develop a new routing protocol, SPEF, proving that it can achieve the optimal TE for intradomain IP networks. Although we lever age the NEM frameworkproposedin PEFT, the key difference between them is in that: SPEF realizes a ﬂexible ﬂow splittin g over shortest paths in a distributed fashion, guaranteeing the crucial features of OSPF in terms of scalability and efﬁcien cy. Paper Organization. The rest of the paper is organized as follows. We propose a new generic objective function of load balance in trafﬁc engineering in Section II and theoretical ly prove the existence of the optimal link weights with the abov e generic function in Section III. The new OSPFbased protoco l isdevelopedinSectionIV,followingwhichistheperforman ce evaluation in Section V. Related work is summarized in Section VI, before we conclude with the achievements and extensions in Section VII. II. NETWORK MODEL AND LOAD BALANCE CRITERIA The notion of load balance characterizes how trafﬁc should be distributed to the links. In this section, we ﬁrst give the network model and then propose some new deﬁnition for load balance, which is motivated by the notion of fairness [6], [1 0]. A. Network Model We consider a directed network G= (N,J)with vertex setN, edge set J, andRsourcedestination vertex pairs {s1,t1},···,{sR,tR}. Each edge (i,j)has a capacity cij, which is a measure for the amount of trafﬁc ﬂow it can take. A demand (trafﬁc) for (sr,tr)isdr, which denotes the average intensity of trafﬁc entering the network at vertex sr and exiting at vertex tr. In the following, we use notations N,Jto denote the cardinalities of sets NandJrespectively andR={1,···,R}to denote the sourcedestination vertex pairs index set. The multicommodityﬂow problem is a network ﬂow prob lem with multiple commodities (or goods) ﬂowing through the network, with different source and sink nodes. The more customary way to treat routing in a network is to consider it as a multicommodity ﬂow problem. Denote the destination node set with D={t∈ N:∃r∈ Rs.t. tr=t}. The trafﬁc ﬂow to each destination t∈ Dcan be regarded as a commodity. The ﬂow of commodity talong edge (i,j)isft ij. Find an assignment of ﬂow satisfying the constraints: fij△=/summationdisplay t∈Dft ij≤cij,∀(i,j)∈ J (1a) /summationdisplay j:(s,j)∈Jft sj−/summationdisplay i:(i,s)∈Jft is=dt s,∀t∈ D,∀s∈ N\{t},(1b) ft ij≥0,∀t∈ D,(i,j)∈ J, (1c) where (1a) and (1b) are the capacity constraints and ﬂow conservation constraints, respectively, and dt s≥0is the expected trafﬁc entering the network at node sand destined to nodet. Setdt s=drif there exists r∈ Rsuch that sr=s andtr=t, or setdt s= 0otherwise. We say a trafﬁc distribution f= (fij,(i,j)∈ J)is feasible if there exists (ft,t∈ D)such that (f,ft,t∈ D)satisﬁes theFig. 1. An example illustrating the notions of load balance f or TE multicommodity ﬂow constraints (1). If fis feasible, the total load on and the utilization of the link (i,j)∈ Jarefijand fij cijrespectively, which depend on how the network decides to route the trafﬁc. Now, one main task is to ﬁnd a appropriate andfeasibletrafﬁc distribution f. An objective function enables quantitative comparisons be  tween different routing solutions in terms of load fijon the links.Trafﬁcengineeringusuallyconsidersalinkcostfu nction Φ(f,c)that is an increasing function of f.Optimal trafﬁc engineering [14] meansthat the TE cost functionis minimized over multicommodity ﬂow constraints (1). B. Load Balance Criteria In order to use the network resources efﬁciently, spare re source(suchasbandwidth)aremadetoensurehighprobabili ty of data arrival to its destinations. Now we will turn to discu ss the load balance criteria based on spare link capacity for li nk (i,j), which is sij=cij−fij. It is well known that minimizing MLU is over sensitive to individual bottleneck links that may be difﬁcult to avoid [1 5]. In addition, the maximum link utilization function does not penalize solutions that force trafﬁc to traverse very long p aths. We ﬁrst use an example to illustrate that MLU is not a well deﬁned objective function. Consider the topology in Fig. 1, there are four edges with capacities all being 1s. The nonzer o demands are 1 for sourcedestination pair (1,3)and 0.9 for sourcedestinationpair (3,4),respectively.Therearetwopaths for sourcedestination pairs (1,3), namely 13 and 123. There is a single path for sourcedestinationpair (3,4), i.e., 3 4.Thelinkutilizationsareshowninthelast columnofTABLE I. There is inﬁnite optimal trafﬁc distribution for minimiz ing MLU. How to evaluate these optimal trafﬁc distribution? A formal deﬁnition is minmax load balance. A trafﬁc distribution f∗is said to be minmax load balanced if it is feasible and for any other feasible trafﬁc distribut ionf, thefollowingconditionholds:if sij> s∗ ijforsome (i,j)∈ J, then there exists (u,v)∈ Jsuch thats∗ uv cuv≤s∗ ij cijandsuv< s∗ uv. We ﬁrst show that a minmax load balancing trafﬁc distri butionf∗makes MLU minimized. Minimizing MLU can be formulated with the spare capacity as minimize max (i,j)∈J/parenleftBig 1−sij cij/parenrightBig (2) Assume that f∗is minmax load balanced and does not solve the problem(2). Then there exists a feasible trafﬁc distrib ution fsuch that max (i,j)∈J/parenleftbigg 1−sij cij/parenrightbigg <max (i,j)∈J/parenleftbigg 1−s∗ ij cij/parenrightbigg .(3)Let(i,j) = argmax (i,j)∈J/parenleftBig 1−s∗ ij cij/parenrightBig . By (3), we have 1− sij cij<1−s∗ ij cij. Forf∗is minmax load balanced, there exists (u,v)∈ Jsuch that 1−s∗ uv cuv≥1−s∗ ij cijand1−suv cuv>1−s∗ uv cuv, which contradicts with (3). The minmax load balancing trafﬁc distribution for the topology in Fig. 1 is shown in TABLE I. It can be seen that the minmax load balance is not overly sensitive to individu al bottleneck links that may be difﬁcult to avoid. But similar with minimizing MLU, the minmax load balancing trafﬁc distribution does not penalize solutions that force trafﬁc to traverse very long paths. Consider path 123 and path 13 fo r the sourcedestination pair (1,3). If the capacities in Fig. 1 are ﬁve times bigger, then it would not be worthwhile sending the trafﬁc from 1through a detour over 2to 3. For it does not really matter that we reduce the second maximum link utilization from 20%to10%. A trafﬁc distribution f∗isproportional load balanced if it is feasible and for any other feasible trafﬁc distribution f, the aggregate of proportional changes of spare capacity is zero or negative:/summationdisplay (i,j)∈Jsij−s∗ ij s∗ ij≤0, wheresij=cij−fijis the spare capacity of link (i,j)∈ J for a feasible trafﬁc distribution f. A trafﬁc distribution f∗isweighting proportional load balanced if it is feasible, and if for any other feasible trafﬁc distribution f/summationdisplay (i,j)∈Jqijsij−s∗ ij s∗ ij≤0, whereqijis a nonnegative constant for all (i,j)∈ J. The following deﬁnition is a generalization of proportiona l load balance and minmax load balance. A trafﬁc distributio n f∗is(q,β)proportional load balanced if it is feasible and for any other feasible trafﬁc distribution f /summationdisplay (i,j)∈Jqijsij−s∗ ij (s∗ ij)β≤0, (4) wheresij=cij−fijandβis a nonnegative parameter. The given deﬁnition reduces to that of proportional balance withβ= 1. Asβgrows large, it convergesto that of minmax load balance. III. OPTIMALWEIGHTSEXISTENCE In this section, we ﬁrst resort to the utility maximization of multicommodity ﬂows to model the optimal TE. And then we theoretically prove that the optimal link weights always exist under the generic objective functions with different parameters. A. Utility Model of Trafﬁc Engineering For the offered trafﬁc, TE changes routing to minimize network congestion. Here we use the utility maximization solution to route trafﬁc which is equal to the multicommodi tyTABLE I WEIGHT AND LINK UTILIZATION FOR DIFFERENT OBJECTIVE FUNCTIO NS OFTE β= 0 β= 1 B. Fortz & M. Thorup [14] minmax MLU [19]Linkweights utilizations weights utilizations weights utilizations weights utilizations weights utilizations (1,3) 2 1 .00 3 0.67 4.6 0 .67 0.50 0a‡ (3,4) 1 0 .90 10 0 .90 40.0 0 .90 0.90 1 0.90 (1,2) 1 0 .00 1.5 0.33 2.3 0 .33 0.50 0 1−a (2,3) 0 0 .00 1.5 0.33 2.3 0 .33 0.50 0 1−a ‡ais a constant in interval [0.1,0.9] ﬂow solution. The reason is twofold: (a) it is optimal, i.e., it gives the routing with maximum spare capacity utility; (b) i t can be realized by routing protocols that use MPLS tuneling, or in a distributed fashion by OSPF routing. We associate link (i,j)with an operator, and assume that if a spare capacity sijis held by operator (i,j), which has utility Vij(sij)to the operator. We assume that the utility Vij(sij)is an increasing, concave and continuously differentiable fu nc tion ofsijover the range sij≥0, andV′ ij(sij)>0over the rangesij≥0.Assumefurtherthatutilitiesareadditive,so that the aggregate utility of spare capacity s= (sij,(i,j)∈ J)is/summationtext (i,j)∈JVij(sij). It is the concavity of the function Vijthat forces load balance among links. If Vijis a convex increasing function instead of a concave, then maximize the aggregate utility. Larger spare capacity sijshould be increased, since the rate of increase of Vij(sij)is increasing in sij. WhenVijis linear, the rate of increase of Vijis the same for all sij. WhenVij is concave, a smaller spare capacity sijis preferred, since V′ ij(x)> V′ ij(y)ifx < y. Now the optimal trafﬁc engineering can be formulated as maximizing the aggregated utility under the multicommodi ty ﬂow constraints (1). TE(V,G,c,D) maximize ft≥0/summationdisplay (i,j)∈JVij(sij) (5a) subject to c−/summationdisplay t∈Dft=s≥0 (5b) Bft=dt,∀t∈ D, (5c) whereB,anN×Jnodearcincidencematrixfornetwork G,is introduced to represent the multicommodity ﬂow constrain ts (1). Thejth column of Bcorresponding to link (u,v)∈ J is deﬁned as Bij=  1, i=u −1, i=v 0,otherwise , There is a unique optimum for the spare capacity vector s, since the objective function (5a) is a strictly concave func tion ofs. But there may be many values of the ﬂow vector (ft,t∈ D)satisfying relations (5b) and (5c). Say that s solves TE (V,G,c,D)if there exists (ft,t∈ D)such that (s,ft,t∈ D)solves the optimization problem (5).From the general theory of constrained convexoptimization [2]. It followsthat (s,ft,t∈ D)solves problem(5) if and only if there exist Lagrangian multiplier vectors wandνt,t∈ D that satisfy c−/summationdisplay t∈Dft=s,Bft=dt,∀t∈ D (6a) V′ ij(sij)−wij=0,ifsij>0 (6b) ≤0,ifsij= 0 (6c) νt j−νt i−wij=0,ifft ij>0 (6d) ≤0,ifft ij= 0. (6e) we deﬁne c′ ij=cij−sijas thetarget capacity for each link, which is no greater than the actual capacity cij(a “virtual” capacity). This is also desirable since it leads to an empty equilibrium. FromV′ ij(sij)>0,Eq.(6b) and(6c), we have wij>0. The Lagrangianmultipliervectors wandνthaveseveralsimplein terpretations. Let p:vj0vj1vj2···vjmvjm+1be a possible path of sourcedestination pair (s,t), wherej0=sandjm+1=t. For example, if yp= min k=1,2,···,m+1ft vjk−1vjk>0, we have/summationtext (i,j)∈pwij=νt t−νt s≤/summationtext (i,j)∈¯pwijfor any other path ¯p that connects the same sourcedestination pair (s,t)under the conditions(6d) and (6e). We may view wijas the implied cost of trafﬁc through link (i,j). Alternatively, wijis theshadow priceof additional capacity at link (i,j). We can also regard was the weight set by the operator and νtas the vector of node potentials (νt i:i∈ N)for destination t. Letw= (wij: (i,j)∈ J). And let (s,ft,t∈ D) be a solution of (5). We have shown that ftdetermines the shortest path for each sourcedestination pair (s,t)under the link weights w, which is determined explicitly by the utility functionVijand the spare capacity sijthrough Eq. (6b) and (6c). If link(i,j)is charged price of per unit spare capacity, and is to freely vary the spare capacity sij, then the utility maximization problem for link (i,j)becomes Linkij(Vij;wij) maximize Vij(sij)−wijsij subject to sij≥0.(7) If the network receives a revenue wijper unit spare capacity fromlink (i,j),andisallowedtofreelyvarythesparecapacity sij, then the revenue optimization problem for the network isas follows. Network(G,c,D;w) maximize ft≥0/summationtext (i,j)∈Jwijsij subject to c−/summationtext t∈Dft=s≥0 Bft=dt,∀t∈ D.(8) ssolves Network (G,c,D;w)if there exists (ft,t∈ D)such that(s,ft,t∈ D)solves the problem (8). Remark 1: Reducingthe sparecapacity sfrom(8),we have that Network (G,c,D;w)is a minimumcost multicommodity ﬂow problem [3], i.e. minimize ft≥0/summationtext (i,j)∈Jwij/summationtext t∈Dft ij subject to/summationtext t∈Dft ij≤cij,∀(i,j)∈ J Bft=dt,∀t∈ D.(9) B. Optimal Weights Existence Theorem 3.1 (weightsetting): There exists a weight vec torw= (wij,(i,j)∈ J)such that the vector s= (sij,(i,j)∈ J), formed from the unique solution sijto Linkij(Vij;wij), solves Network (G,c,D;w). The vector s also solves TE (V,G,c,D). Proof:Let(s,ft,t∈ D)be a solution of TE(V,G,c,D),w= (wij,(i,j)∈ J)and(νt,t∈ D) be the Lagrangian multiplier vectors, i.e., Eq. (6a)(6e) are satisﬁed. We have that sijis the unique solution sij to Link ij(Vij;wij)for each (i,j)∈ J. It can be check that(s,ft,t∈ D)is a KKT point of Network (G,c,D;w) with Lagrangian multiplier vectors (wij,(i,j)∈ J)and (νt,t∈D).(s,ft,t∈ D)solves Network (G,c,D;w), for which is a convex optimization problem. In addition, let a vector (wij,(i,j)∈ J)such that the vectors= (sij,(i,j)∈ J), formed from the unique solutionsijto Link ij(Vij;wij)for each (i,j)∈ J, solves Network(G,c,D;w). Then there exists ﬂow vector (ft,t∈ D) and Lagrangianmultiplier vector (pij,(i,j)∈ J)and(qt,t∈ D)such that c−/summationdisplay t∈Dft=s,Bft=dt,∀t∈ D (10a) wij−pij= 0,ifsij>0 (10b) ≤0,ifsij= 0 (10c) qt j−qt i−pij= 0,ifft ij>0 (10d) ≤0,ifft ij= 0. (10e) Furthermore, by that sijsolves Link ij(Vij;wij), we have V′ ij(sij) =wij,ifsij>0 and V′ ij(sij)≤wij,ifsij= 0. Replacing Eq. (10b) and (10c) by this condition, we have that(f,s)satisﬁes conditions (6a)(6e) by replacing wand νtbypandqtrespectively. This establishes that ssolves TE(V,G,c,D), and hence the ﬁnal part of the theorem.0 0.2 0.4 0.6 0.8 102468101214 LoadCost    FT β = 0 β = 1 β = 2 Fig. 2. Different link cost as a function of the load for a link capacity 1, where FT denotes the one proposed by Fortz and Thorp [14] and qij= 1in (4) We now examine the engineering implications of Theo rem 3.1. It is true that, the Lagrangian multiplier vector (wij,(i,j)∈ J)gives link weights such that all the traf ﬁc ﬂow will be forwarded along the minimum cost multi commodity problem solution. Meanwhile the link (i,j)max imizes it’s utility through retaining a proper spare capaci ty. Inversely, if there exists link weights (wij,(i,j)∈ J)such that the vector s= (sij,(i,j)∈ J), formed from the unique solutionsijto Link ij(Vij;wij)for each (i,j)∈ J, is the same with the solution of minimum cost multicommodity problem (9), then {wij,(i,j)∈J}is a set of link weights such that all the commodity ﬂow will be forwarded along the shortestpaths.Meanwhile, ssolvestrafﬁcengineeringproblem TE(V,G,c,D). Lemma 3.2: Letg(x)be continuously differentiable, i.e. ∂g ∂xiexists and continuesfor all i. It holds that g(x)is concave if and only if g(x)−g(x∗)≤ ∇g(x∗)T(x−x∗) holds for any xandx∗(see [2] and [4]). Theorem 3.3: A trafﬁc distribution f∗is(q,β)propor tional load balanced if and only if s∗=c−f∗solves TE(V,G,c,D), where the objective function in (5a) is given by Vij(sij) =/braceleftbiggqijlogsij ifβ= 1 qij(1−β)−1s1−β ijifβ/\e}atio\slash= 1.(11) Proof:Letg(s) =/summationtext (i,j)∈JVij(sij)ands∗be a solution of(5)withobjective g(s).Letf∗=c−s∗and(w∗ ij,(i,j)∈ J) be a Lagrangianmultiplier vector,i.e., satisfying (6a)( 6e). Let fbe any feasible trafﬁc distribution. Then s=c−f≥0. Multiplying Eq. (6b) and (6c) by sij−s∗ ijand summing over (i,j)∈ J, we ﬁnd (∇g(s∗))T(s−s∗)≤/summationtext (i,j)∈Jw∗ ij(sij− s∗ ij)≤0sinces∗solves Network (G,c,D;w∗)(known in the proof of Theorem 3.1). Therefore, (∇g(s∗))T(s−s∗)≤0. (12) By the deﬁnition of g(s), we have∂g ∂sij=qij sβ ij. So Eq. (12) reduces to Eq. (4). We have shown that f∗is(q,β) proportional load balance.0 1 2 3 4 50246810x 104Weight for arc (3,4) β   0 1 2 3 4 501020304050 Weights for arc (1, 3), (1, 2) and (2, 3)   arc (3,4) arc (1,3) arc (1,2) and (2,3) (a) Weight vs load balance parameter βwithqij= 10 1 2 3 4 500.20.40.60.81 βLink Utilization    arc (1,3) arc (3,4) arc (1,2) and (2,3) (b) Link utilization vs load balance parameter βwithqij= 1 Fig. 3. An example illustrating the notions of load balance f or TE For the converse, assume that f∗is(q,β)proportional load balance and s∗=c−f∗. So Eq. (4) holds with f∗, i.e., Eq. (12). For g(s)is concave, we have g(s)−g(s∗)≤0holds for any feasible trafﬁc distribution fsuch that s=c−fby Lemma 3.2. It follows that s∗solves TE (V,G,c,D), where the objective function in Eq. (5a) is deﬁned by Eq. (11). Based on Theorem 3.1 and Theorem 3.3, we can give the engineeringinterpretation of some speciﬁc (q,β)proportional load balance. Example 1: Proportional load balance. If a trafﬁc distribution fis proportionally load balancing, thenitsolvestheTEproblem(5)with Vij(sij) = logsij.From Eq. (6b) and (6c), we can get wij=1 cij−fij,i.e.the average packet delay on link (i,j)is based on the M/M/1queueing model [1], where fij=/summationtext t∈Dft ij. From the discussion above, we have that if path p∗for(s,t)bears positive trafﬁc yp∗>0, then/summationtext (i,j)∈p∗1 cij−fij≤/summationtext (i,j)∈p1 cij−fijfor any otherpath p for(s,t). The facts above show that the proportional balance vectorfnot onlyminimizes the average packet queueingdelay of(s,t)for alls,t∈ N,but alsominimizes the average delay over all the links. If a network is running with low utilization, then fij≪ cij, and therefore, the delay1 cij−fij≈1 cij. As such InvCap recommended by Cisco can be suitable. When the link load is nonnegligible as compared to its link capacity, we shoul d make some changes. Example 2: (c,2)proportional load balance. If a trafﬁc distribution fis(c,2)proportionallyload balanc ing, then it solves (5) with Vij(sij) =−cij cij−fij=−1−fij cij−fij. In this case, we can see that (5) tries to minimize the total average queueing delay by the M/M/1queueing model with respecttooptimallinkweights wij=cij (cij−fij)2for(i,j)∈ J. Example 3: (d,0)proportional load balance. Letdijbe the processing and propagation delay on link (i,j). If a trafﬁc distribution fis(d,0)proportional load balance, then it solves the TE problem (5) with Vij(sij) = dij(cij−fij) =dijcij−dijfij. In this case, we can see that (5) tries to minimize the total processing and propagat ion delay, and we have that the optimal link weights wij=dij for unsaturated link (i,j)∈ Jandwij≥dijfor saturated link(i,j). Ifdij= 1, we have the minimum hop routing. We use the network topology in Fig. 1 to illustrate thesenotions. In Fig.3, (a) and (b) are the link weights and the link utilization versus load balance parameter β, respectively. Detailed numerical results are shown in TABLE I. Remark 2: Consider TE (V,G,c,D)withVijdeﬁned in (11) with qij= 1,∀(i,j)∈ J, we obtain: the minimum hop routing for each sourcedestination pair with β= 0; the shortest average packet delay routing for each source destinationpair with β= 1; the shortest pathsfor each source destination pair which makes the trafﬁc distribution be min  max load balance when β→ ∞. C. Utility vs. Proportional Load Balance In this subsection, we discuss the relation between the proportional load balance and different utility functions . If link(i,j)can choose an amount to pay per unit time, nij, and receive in return a spare capacity sijproportionally to nij, saysij=nij wij, wherewijcould be regarded as a charge per unit ﬂow for link (i,j), the utility maximization problem for link(i,j)becomes Linkij(Vij;wij) maximize Vij(nij wij)−nij subject to nij≥0.(13) Letn= (nij,(i,j)∈ J),D(n) ={(i,j)∈ J:nij>0}. We deﬁne the optimization problem Network(G,c,D;n) maximize ft≥0/summationtext (i,j)∈D(n)nijlogsij subject to c−/summationtext t∈Dft=s≥0 Bft=dt,∀t∈ D.(14) Note that if nij= 1for(i,j)∈ J, then the solution to Network(G,c,D;n)is the proportional load balancing trafﬁc allocation. If nij,(i,j)∈ J, are all integers, then the solution toNetwork (G,c,D;n)canbeconstructedasfollows.Foreach (i,j)∈ J, replace the single link (i,j)bynijidentical sub links, calculate the proportional load balance allocation over the resulting/summationtext (i,j)∈Jnijtrafﬁc, and then provide link (i,j) the aggregate spare capacity allocated to its nijassociated sublinks. The load per unit charge are then proportional load balancing. Say thatssolves Network (G,c,D;n)if there exists (ft,t∈ D)such that (s,ft,t∈ D)solves the optimization problem(14). The corresponding Lagrangian is LNet(s,ft,t∈ D;w,νt,t∈ D) =/summationtext (i,j)∈D(n)nijlogsij+wT(c−/summationtext t∈Dft−s) −/summationtext t∈DνtT(Bft−dt) =/summationtext (i,j)∈D(n)(nijlogsij−wijsij)−/summationtext (i,j)/∈D(n)wijsij +/summationtext t∈D/summationtext (i,j)∈J(νt j−νt i−wij)ft ij +/summationtext (i,j)∈Jwijcij+/summationtext t∈DνtTdt. For the general theory of constrained convex optimization [ 2], it follows that (s,ft,t∈ D)solves problem (14) if and only if thereexist Lagrangianmultipliervectors νtandwthatsatisfy: c−/summationtext t∈Dft=s,Bft=dt,∀t∈ D nij sij−wij= 0,if (i,j)∈ D(n) −wij= 0,if (i,j)/∈ D(n),sij>0 −wij≤0,if (i,j)/∈ D(n),sij= 0 νt j−νt i−wij= 0,ifft ij>0 ≤0,ifft ij= 0. Theorem 3.4: There exist vectors n= (nij,(i,j)∈ J),w= (wij,(i,j)∈ J), ands= (sij,(i,j)∈ J)such that i)wij>0andnij=wijsij,for(i,j)∈ J; ii)nijsolves Link ij(Vij;wij)(13), for (i,j)∈ J; iii)ssolves Network (G,c,D;n)(14). Given any such triple (n,w,s), the vectors nandsare uniquely determined, and ssolves TE (V,G,c,D). Proof:Let(s,ft,t∈ D)be a solution of (5). Let w and(νt,t∈ D)be the Lagrangian multiplier vectors, i.e. the conditions of (6a)(6e) are satisﬁed. For V′(sij)>0, we have wij≥V′ ij(sij)>0from (6b) and (6c). Let nij=wijsij,(i,j)∈ J. Then i) of Theorem 3.4 holds. Aswij>0for all(i,j)∈ J, Link ij(Vij;nij)is well deﬁned. In addition, it is obvious that nij= 0if and only if sij= 0. We have that nijsolves Link ij(Vij;wij), for(i,j)∈ Jby (6b) and (6c). Then ii) of Theorem 3.4 holds. By i) of Theorem 3.4, we have the fact that D(n∗) = {(i,j)∈ J:nij>0}={(i,j)∈ J:sij>0}. Then the condition (IIIC) for Network (G,c,D;n)is disappear. By the deﬁnition of nandw, the conditions (IIIC) and (IIIC) hold. The other conditions follow from the conditions (6a), (6d) a nd (6e). We have the fact that ssolvesNetwork (G,c,D;n). Then iii) of Theorem 3.4 holds. Conversely, given n,wandssatisfying conditions i)iii) of Theorem 3.4, then by i), Link ij(Vij;wij)is well deﬁned for all(i,j)∈ J. In addition, we have that nij= 0if and only ifsij= 0. By ii) and sij=nij wij, the conditions (6b) and (6c) hold for given sandw. By iii), there exist ftandνtfor all t∈ Dsatisfying conditions(IIIC), (IIIC) and (IIIC). We can verify that (s,ft,t∈ D,w,νt,t∈ D)satisﬁes (6a)(6e). We conclude ssolves TE (V,G,c,D)and therefore sis uniquely determined. Since wij>0for all(i,j)∈ J,nis uniquely determined as well.Since Theorem 3.4 is straightforward, here we do not present the detailed proof. It shows that if each link operat or is able to choose a chargeper unit time preparesto pay.And if thenetworkallocatessparecapacitiessothatthesparecap acity per unit charge is proportional load balancing, then a syste m optimum is achieved when the link operator’s choices of charges and the network’s choice of allocated spare capacit ies are in equilibrium. IV. A N EW ROUTING PROTOCOL : SPEF We are now in a position to design a new routing protocol based on the above theoretical results. In the following, we ﬁrst present the distributed algorithms to achieve the opti mal link weights, also called the ﬁrst link weight. And then we derive the second link weights from the conceptual framewor k Network Entropy Maximization [20]. In the Shortest paths Penalizing Exponential Flowsplitti ng (SPEF), each router can construct the shortest paths for eac h destination based on the ﬁrst link weights and independentl y calculate the trafﬁc split ratio among all equalcost short est paths using only the second link wights, not onlyachieves the optimal trafﬁc engineering but alsoremains the path diversity. A. Obtaining the First Link Weights We now show a distributed algorithm to obtain the ﬁrst link weights, which in fact is the subgradient projection metho d [4] applied to the dual of TE (V,G,c,D). The algorithm comprises three parts: updating the weight vector, specify ing the spare capacity and modifying the routing variables, as described in Algorithm 1 . Algorithm 1 Dual decomposition for the ﬁrst link weights Given tolerance toland initial weight w(0)(such as w(0) ij= 1/cij),k= 0; forthe given weight w(k)do Each link (i,j)solves Link ij(Vij;w(k) ij)to ﬁnd the spare capacity s(k) ij; Each destination t∈Dsolves Route t(w(k);dt): minimize ft≥0/summationtext (i,j)∈Jw(k) ijft ij subject to Bft=dt(15) to ﬁnd the routing variable ft(k); Each link (i,j)∈Jupdates the link weight w(k+1) ij=/parenleftbig w(k) ij−γk(cij−/summationdisplay t∈Dft(k) ij−s(k) ij)/parenrightbig +;(16) k←k+1; Untilgap(w(k),s(k),f(k))< tol. end for Given the link weight w, the route problem (15) for each destination is a minimumcost network ﬂow problem [3]. In (16),γkis the step size and (z)+= max(0 ,z).And optimality measure is deﬁned as the dual gap, i.e. gap(w(k),s(k),f(k)) =/summationdisplay (i,j)∈Jw(k) ij(/summationdisplay t∈Dft(k) ij+s(k) ij−cij).Theorem 4.1: The link weight sequence {w(k)}generated by Algorithm 1 converges to the ﬁrst link weights w∗if/summationtext kγk=∞andγk→0. Furthermore, if there are no saturated links, i.e.s∗ ij>0,∀(i,j)∈ J, the ﬁrst link weights w∗is uniquely determined and the optimal trafﬁc distribution isf∗=c−s∗, wheres∗ ij=V′ ij−1(w∗ ij). We have proposed a link weight conﬁguration method that can achieve the optimal trafﬁc engineering. We can determin e the set of shortest paths ON ={ONt:t∈ D}(i.e., deciding which outgoing link should be chosen on the shortest path) based on the ﬁrst link weights, where ONtis the shortest path set for any node s∈ Nto destination t∈ D. Speciﬁcally, SPr denotes the shortest path set for (sr,tr). LetSP ={SPr:r∈ R}. When the ﬁrst link weights generate multiple equal cost paths for a sourcedestination pair or next hops for a given destination routing preﬁx, we need to split the trafﬁc among the multiple shortest paths or the next hops to keep paths diversity while achieving the optimal trafﬁc engineering. B. Obtaining the Second Link Weights Motivated by PEFT [20], we propose an Exponential weighted ﬂow split in the presence of multiple equal cost pathsfora giveningressandegresspair (sr,tr). The proposed method features that each router can independently compute the ﬂow split only based on alternative link weights, where routers can direct trafﬁc on the shortest paths determined b y the ﬁrst link weights. This method can achieve networkwide trafﬁc engineering objective through OSPF which still keep s the simplicity and scalability of linkstate routing proto cols. We maximize the relative entropy of the trafﬁc split vector among the multipath in SPrto maintain the path diversity. Maximizing the relative entropy [4] of the trafﬁc split vect or can be formulated as follows. NEM(SP,f,D): maximize −/summationdisplay r∈Rdrnr/summationdisplay k=1pr klogpr k (17a) subject to/summationdisplay r∈R/summationdisplay k:(i,j)∈SPr kdrpr k≤f∗ ij,∀(i,j)∈ J(17b) nr/summationdisplay k=1pr k= 1,∀r∈ R, (17c) wherenrdenotes the number of the shortest paths from srto tr.SPr kdenotes the kth shortest path from srtotr. We will connect the characterization of optimal solution to NEM that is realizable with hopbyhop forwarding to expo nential penalty. Let (pr,r∈ R)be a solution of (17). Then there exist Lagrangian multipliers vector v= (vij,(i,j)∈ J) and(νr,r∈ R)satisfying that (1+logpr k)+/summationtext (i,j)∈SPr kvij+ νr dr= 0,∀r∈ R,kand/summationtextnr k=1pr k= 1. Undertheseconditions, we have pr k=e−vr k/summationtextnr i=1e−vr i,∀r∈ R,k, (18) wherevr k=/summationtext (i,j)∈SPr kvij. In the following, we refer to Lagrange multipliers vector vas the second link weight. vr kisTABLE II FORWARDING TABLE FOR SPEFROUTING . Lengths of multiple equal cost shortest paths through Next hop link(s,next hop) totin view of the second link weights v1 (v(s,t) 11,···,v(s,t) 1n1) ...... vms (v(s,t) ms1,···,v(s,t) msnms) the length of path SPr kwith respect to the second weight v. Theorem 4.2: The optimal trafﬁc engineering for a given trafﬁc can be realized with the second link weights using exponential ﬂow split (18). To provide a foundation for the second link weight computation, we investigate the Lagrange dual problem of NEM(SP,f,D)andadualgradientbasedsolution.Denotethe dual variables for constraints (17b) as vijfor link(i,j)(orv as a vector). We ﬁrst write the Lagrangian L(p,v)associated with problem NEM (SP,f,D)as L(p,v) =−/summationdisplay r∈Rdrnr/summationdisplay k=1(pr klogpr k+vr kpr k)+/summationdisplay (i,j)∈Jvijf∗ ij, wherevr k=/summationtext (i,j)∈SPr kvij. The Lagrange dual function is d(v) = maximize L(p,v) subject to/summationtextnr k=1pr k= 1,∀r∈ R. The dual problem is then formulated as minimize d(v) subject to v≥0¯. (19) To solve the dual problem, we ﬁrst consider the maxi mization of the Lagrangian over p. Note that, the L(p,v) is separable for a given dual variable v,i.e., the trafﬁc split subproblem for each r∈ Ris independent of the others since they are not coupled together with link capacity constraint (17b). So we can solve a subproblem (20) below for each r∈ Rseparately: maximize −dr/summationtextnr k=1/parenleftbig pr klogpr k+vr kpr k/parenrightbig subject to/summationtextnr k=1pr k= 1.(20) Then, the dual problem (19) can be solved by using the gradient projection method as follows for iterations index ed byk, v(k+1) ij=/parenleftbig v(k) ij−γ(f∗ ij−/summationtext r∈Rdr/summationtext l:(i,j)∈SPr lpr l(k))/parenrightbig + =/parenleftbig v(k) ij−γ(f∗ ij−f(k) ij)/parenrightbig +(21) whereγ >0is a constant step size, (pr 1(k),···,pr nr(k))are solutionsof the trafﬁc split subproblem(20) for v(k), andf(k) ij is the total ﬂow on link (i,j)∈ J. It is important to note, from (21) in iteration k+ 1, the procedure of link weight updating needs f(k) ij, the aggregate bandwidth usage. We now show how to calculate it efﬁciently. First, we need to establish the forward table for node s to destination tas shown in Table II, where nkdenotes thenumber of shortest path from node sthrough node vkto node t,v(s,t) kjis the length of the jth path from node sthrough nodevkto nodet, andmsdenotes the number of next hop forsinONt. Then the trafﬁc to destination tcan be splited according to the following formula: Γt(s,vk) =/summationtextnk j=1e−v(s,t) kj /summationtextms i=1/summationtextni j=1e−v(s,t) ij, k= 1,···,ms.(22) Finally, the formal algorithm for the second link weights can be described as follows, in which Algorithm 3is needed to get the trafﬁc distribution matching to the current secon d link weights v(k). Algorithm 2 Dual decomposition for the second link weights Input the optimal trafﬁc distribution f∗and tolerance ǫ; Given the initial second link weights v(0)=0,k= 0; Forthe given weights v(k),do Get the trafﬁc distribution matching to v(k), i.e. f(k)←TraﬃcDistribution( v(k)). Each link (i,j)updates the second link weights v(k+1) ij←/parenleftbig v(k) ij−γ(f∗ ij−f(k) ij)/parenrightbig +; k←k+1; Untilf(k) ij≤f∗ ij+ǫfor all(i,j)∈J. Algorithm 3 TrafﬁcDistribution( v) InputON ={ONt:t∈D}; Compute the path length for each path in ON in view of the second link weights v; Compute the trafﬁc split Γt(i,j)according to (22); For each destination tdo Do sorting on the distance of node stot in view of the ﬁrst link weights Each source s/ne}ationslash=tin the decreasing distance order do ¯dst=dst+/summationtext (j,s)∈ONtft js; For alljsuch that (s,j)∈ONt ft sj=¯dstΓt(s,j); end for end for fij=/summationtext t∈Dft ijfor all(i,j)∈J; Return/* set of f*/ Here¯dstdenotes the total incoming ﬂow destined to node tat nodes(including trafﬁc originating at sas well as any trafﬁc arrived from other nodes). The following result can be proved with standard conver gence analysis for gradient projection algorithms [2]: Theorem 4.3: Let{v(i)}be the sequence generated by Algorithm 2. We have that {v(i)}converges to the optimal dual solutions v∗, and the corresponding primal variables p∗ according to (18) are the globally optimal solution of (17). We now present a new linkstate routing with hopbyhop forwarding, which can achieve the optimal trafﬁc engineeri ng.96 10 12 3 1 2 78r= 3: 3> 2, d3=4 r= 4: 1> 7, d4=4 1 2 3 4 5 6 75 11 13r= 1: 1> 2, d1=4 r= 2: 1> 3, d2=4 4 Fig. 4. A simple network topology and trafﬁc demands96 10 12 3 1 2 781 2 3 4 5 6 75 11 13 4                   Fig. 5. SPEF forwarding table for destination 2 Algorithm 4 SPEF routing Running Algorithm1toobtainthe ﬁrstlinkweights (wij,(i,j)∈J) and optimal trafﬁc distribution f∗. Foreach destination node t∈Ddo Run Dijkstra’s algorithm with the ﬁrst link weights to get all the shortest paths ON ={ONt:t∈D}. endfor. Running Algorithm 2 to obtain the second link weights (vij,(i,j)∈ J). Foreacht∈Ddo For each source node s: Establish the forward routing table shown in Table II. end For end For V. PERFORMANCE EVALUATION How well can the new routing protocol SPEF perform? In the ﬁrst part, we will illustrate its performance with a simp le example. In the second part, we demonstrate the performance of SPEF with numerical experiments over a real backbone network and several synthetic networks. Here we compare the results of SPEF with that of OSPF, which sets link weight inversely proportional to its capacity and evenly splits th e trafﬁc over multiple equalcost shortest paths. A. An Example Fig. 4 shows a simple network topology, as used in [19]. Each link has a capacity of 5 units and each demand needs a bandwidthof 4 units. For simplicity, we omit six links unuse d. The numbers on the links are the link indices. The link utilizations for optimal TE with a different param eterβare shown in Fig. 6. For the results of β= 0, link1is a bottle link. And the ﬁrst link weight is 3. The ﬁrst link weigh t of others are all 1. Considering link 1, the link utilization is decreasing in β. From Eq. (6b), the ﬁrst weight of links 2 and 3 are the same when β= 0,1or5, since all the spare capacities are equal to 1. For β= 1, from Fig.7 (b), it can be seen that all the second link weights are zero except for link 1 and link 5. The fact that the second weight of link 1 is increasing in βshows we route fewer trafﬁc through link 1 with larger β.1234567891011121300.511.522.53 LinksThe First Link Weights    SPEF0 SPEF1 SPEF5 (a) The ﬁrst link weights1234567891011121300.511.522.5 LinksThe Second Link Weights    SPEF0 SPEF1 SPEF5 (b) The second link weights Fig. 7. The ﬁrst and second link weights for the network topol ogy shown in Fig. 4 with different β 1234567891011121300.511.52 LinksLink Utilizations    OSPF SPEF0 SPEF1 SPEF5 Fig. 6. The link utilization for the topology shown in Fig.4 B. Simulation Environment The properties of the networks used are summarized in TABLE III. The real backbone network, the Abilene network and Cernet2 network shown in Fig.8. The ﬁrst network has 11 nodes and 28 directional links with 10Gbps capacity, and the latter has 20 nodes and 44 directional links with 10Gbps capacity for 4 backbone links and 2.5Gbps for others. The trafﬁc demands for Abilene network is generated as those in Fortz and Thorup [16]. The trafﬁc demands for Cernet2 network are generated by a gravity model with the link aggregatedloadextractedfromthesampleNetﬂowdata,whic h was captured during 2010/1/10 to 2010/1/16. To simulate networks with different congestion levels, we create diffe rent test cases by uniformly increasing the trafﬁc demands until the maximal link utilization almost reaches 100% with SPEF. We also test the algorithms proposed in this paper on the same topologies and trafﬁc matrices as in Fortz and Thorup [16]. The 2level hierarchical networks were generated usi ng GTITM, which consist of two kinds of links: local access links with 1 unit capacity and long distance links with 5 unit capacity. In the random topologies, the probability of having a link between two nodes is a constant parameter, and all link capacities are 1 unit. In these test cases, for each network, trafﬁc demands are proportionally increased to simulate different congestion levels. For SPEF, we employ the utility function with β= 1to determine the ﬁrst link weights. The utility is normalized, which means/summationtext (i,j)∈Jlog(1−uij), whereuijis the link (i,j)’s utilization. The utility is −∞if MLU is greater than 1, which is not shown in Fig. 10.TABLE III PROPERTIES FOR DIFFERENT NETWORKS Net. ID Topology Node # Link # Abilene Backbone 11 28 Cernet2 Backbone 20 44 Hier50a 2level 50 222 Hier50b 2level 50 152 Rand50a Random 50 242 Rand50b Random 50 230 Rand100 Random 100 392 C. Performance Comparison Against OSPF ThesortedlinkutilizationsforAbilenenetworkandCernet 2 network are shown in Fig. 9, where the network load is the ratio of total demand over the total capacity. Typical resul ts for different topologies are shown in Fig.10. From Fig. 9, it can be seen that some underutilized links in OSPF are used efﬁciently in SPEF. At the same time the trafﬁc on the overutilized links in OSPF is removed in SPEF. The results shown in Fig. 10 indicate that the utility differ ence betweenSPEF andOSPF becomesobviouswith theincreasing of network load. SPEF still works when MLU of OSPF is greater than 1. D. Performance Comparison Against PEFT In order to make a comparison between SPEF and PEFT in network environment, we resort to SSFnet, a highly efﬁcient simulation tool, to explore the protocol behaviors in netwo rks with different scales. In the simulation, both the simple ne t work in Fig. 4 and Cernet2 backbone network in Fig. 8(b) are used, and the trafﬁc demands are shown in TABLE IV. Accordingly, it can be divided into two parts. First, SPEF and PEFT separately run for 400s on the simple network with each link capacity set to be 5Mb/s. The mean trafﬁc load on each link is shown in Fig. 11(a), of which the X axis represents link index and the Y axis is the mean trafﬁc load in kbps. The result shows that in PEFT altogether 8 links are used for carrying trafﬁc, and the link loads vary severel y from 1000 kbps to near 3000 kbps. Comparing to PEFT, 4 more links are involved in SPEF and the trafﬁc load is more equally distributed among these links.1 810 711 395 624 (a) Abilene network1693 810G 2.5G 1820 1921456 10 11 12 13 14157 17 (b) Cernet2 network Fig. 8. Backbone network topologies 510 15 20 2500.20.40.60.81 LinksLink Utilizations    OSPF SPEF (a) Abilene with network load 0.1710 20 30 4000.20.40.60.81 LinksLink Utilizations    OSPF SPEF (b) Cernet2 with network load 0.21 Fig. 9. Comparison of SPEF and OSPF in terms of the sorted link utilization 0.120.130.140.150.160.170.18−18−16−14−12 Network LoadingUtility    OSPF SPEF (a) Abilene0.120.140.160.18 0.20.22−40−35−30−25−20−15 Network LoadingUtility    OSPF SPEF (b) Cernet20.010.020.030.040.050.06−50−45−40−35−30−25−20−15−10 Network LoadingUtility    OSPF SPEF (c) Hier50a0.01 0.02 0.03 0.04 0.05−60−50−40−30−20−10 Network LoadingUtility    OSPF SPEF (d) Hier50b 0.06 0.08 0.10.12 0.14 0.16−140−120−100−80−60−40 Network LoadingUtility    OSPF SPEF (e) Rand50a0.12 0.14 0.16 0.18−180−160−140−120−100−80 Network LoadingUtility    OSPF SPEF (f) Rand50b0.04 0.06 0.08 0.10.12 0.14−250−200−150−100 Network LoadingUtility    OSPF SPEF (g) Rand100 Fig. 10. Comparison of SPEF and OSPF in terms of utility Second, we run SPEF and PEFT for 400s on the Cernet2 backbone network, where the capacity of 4 links marked with bold lines is 10Gbps, four times larger than that of the rest links. The mean trafﬁc load on each link is shown in Fig. 11(b). The meaning of both X axis and Y axis are the same with those in Fig. 11(a), except that the link load is measure d in Mbps. Three more links is used in SPEF than that in PEFTand hence the variation of link load is lower. In the above simulation cases, SPEF always leverages more links for packet delivery than PEFT, which can be explained by looking deeply into the forwarding tables of each protoco l. Althoughin PEFT trafﬁccanbe intuitionallysplit overall p os sible paths between the source and destination, the penaliz ing exponential ﬂowsplitting mechanism prefers the shortest pathTABLE IV TRAFFIC DEMANDS IN COMPARISON BETWEEN SPEFANDPEFT Net.ID. Src.ID Dst.ID Demand # 1 2 4Mb Simple network 1 3 4Mb in Fig. 4 3 2 4Mb 1 7 4Mb 11 1 3Gb 11 2 2Gb Cernet2 Backbone 11 20 2Gb in Fig. 8(b) 13 6 1Gb 14 1 4Gb 14 8 2Gb TABLE V COMPARISON OF SPEFANDOSPFIN TERMS OF THE NUMBER OF EQUAL COST PATH FOR EACH INGRESS EGRESS PAIR Routing Network loading n1n2n3n4 OSPF 0.13, 0.17, 0.21 355 25 0 0 0.13 330 48 0 2 SPEF 0.17 325 53 0 2 0.21 321 54 3 2 while penalizing the longer paths. In SPEF, however, multip le equalcost shortest paths for the same sourcedestination pair are constructedwith a higherprobabilitybased onthe ﬁrst l ink weight, and then trafﬁc is split over these paths according t o the exponential ratios computed by the second link weight. The comparison result infers that SPEF outperforms PEFT in terms of load balance. E. Equal Cost Paths One of the key features of SPEF routing is the ability to balance trafﬁc across multiple equalcost paths. Intuitiv ely, SPEF routing is more likely to use multiple paths to balance trafﬁc at higher loads. Hence, we focus on a different utiliz a tion scenarios for Cernet2 network, for which we compute the number of equal cost paths used by SPEF routing. TABLE V shows the results, where nidenotes the number of ingress egress pairsthat have iequal cost paths. It can be seen that the equal cost paths for some ingressegress pairs are increasi ng with the increase of network load. But OSPF routing has not change with the network load. F. Convergence Behavior In Algorithm 1, the initial link weights w(0) ij=1 cijfor all link(i,j)∈ Jare a proper choose. The step sizes in Algorithm 1 can be constant or dynamically adjusted. We ﬁnd that setting the step size in Algorithm 1 to the reciprocal of the maximum link capacity1 max{cij:(i,j)∈J}performs well in practice. Fig. 12 (a) shows the evolution of dual objective value of TE obtained by Algorithm 1 with different step sizes , withintheﬁrst 2000iterationsforCernet2network.Itprov ides convergence behavior typically observed. The legends show the ratio of the step size over the default setting which is1 max{cij:(i,j)∈J}. It demonstrates that Algorithm 1 developed for the SPEF routing convergence very fast with default setting. Algorithm 1 reduces the dual objective value of TE t o 48after100iterationsand49after500iterations.Inadd ition, increasing step size a little will speed up the convergency, and as expected, too large a step size (e.g., 2 for Algorithm 1 in the aboveexample)would cause a little oscillation.Notice that there is a wide range of step size that can make convergence very fast. In Algorithm 2, the initial link weights v(0) ij= 0for all link(i,j)∈ Jare a proper choose. We ﬁnd that setting the step size in Algorithm 2 to the reciprocal of the maximum optimal trafﬁc distribution1 max{f∗ ij:(i,j)∈J}performs well in practice. Fig. 12 (b) shows evolution of dual objective valu e of NEM obtained by Algorithm 2 with different step sizes for Cernet2 network. It provides convergence behavior typical ly observed. The legends show the ratio of the step size over the default setting which is1 max{f∗ ij:(i,j)∈J}. It demonstrates that the initial link weights for Algorithm 2 are a good approximation solution for the dual problem of NEM. And Algorithm 2 developed for the SPEF routing also convergence very fast with default setting. Algorithm reduces the dual objective value of NEM to 0.6695 after 100 iterations and 0.66945 after 300 iterations. In addition, increasing step size a little will speed up the convergency. Notice that there is a wide range of step size that can make convergence very fast. G. Noninteger Link Weights We should point out that Algorithm 1 is not guaranteed to yield exact integer solutions for the ﬁrst link weights. In practice, routing protocols link OSPF and ISIS have a ﬁnite ﬁeld width for link weight information. To guarantee the weight for the link with maximum spare capacity is 1, we get the integer weights as following w′ ij= round wij(max{sij: (i,j)∈J}),∀(i,j)∈ J, whereround(x)means rounding xto the nearest integer and wijis the ﬁrst link weight obtained with Algorithm 1. This is because the modiﬁed link weights can result in routings that are different from the optimal routing. Hence it is importan t to study how errors in link weights inﬂuence performance. There are two factors that can introduce inaccuraciesin lin k weights. First of course is the precision in rounding off lin k weights. The second factor is the nonzero tolerance require d by Dijkstra’s algorithm. This implies that the optimal link weights (and path cost) are accurate only within a certain tolerance. For example, two path costs are treated to be equa l byDijkstra’salgorithmifthedifferenceincostsislessth anthe speciﬁedtolerance.We specifythetolerancesfortheDijks tra’s algorithm are 0.3 and 1 for noninteger weights and integer weights respectively. Fig.13 shows the impact of integer weights on utility for Abilene network and Cernet2 network. Observe that the integer weights has little impact on utility for the low netw ork loading. At higher network loadings, errors due to integer024681012141618050010001500200025003000linkload \ kbpsPEFT SPEF (a) Link load distribution over the simple network in Fig. 405101520253035400200400600800100012001400160018002000 Link IndexLink Load / MbpsPEFT SPEF (b) Link load distribution over the Cernet2 network in Fig. 8 (b) Fig. 11. Simulation results of SPEF and PEFT using SSFnet ove r different networks 0 500 1000 1500 2000−55−50−45−40−35 IterationThe Dual Objective Value of TE    2 1 0.5 0.1 (a) Evolution of dual objective value of Algorithm 10 200 400 600 800 10000.66940.66950.66960.66970.66980.66990.670.67010.6702 IterationThe Dual Objective Value of NEM2 1 0.5 0.25 (b) Evolution of dual objective value of Algorithm 2 Fig. 12. Evolution of dual objective value obtained by Algor ithm 1 and Algorithm 2 with different step sizes for Cernet2 n etwork tolerances comes into play so that the utility starts to devi ate signiﬁcantly. This is because, the ﬁrst link weights will be increasing with the link load while the tolerance for the Dijkstra’s algorithm is speciﬁed. In order to avoid problem s due to such errors, we use the different tolerance for the Dijkstra’s algorithm with the different network loading. VI. RELATED WORK "
318,SRPS: Secure Routing Protocol for Static Sensor Networks.txt,"In sensor networks, nodes cooperatively work to collect data and forward it
to the final destination. Many protocols have been proposed in the literature
to provide routing and secure routing for ad hoc and sensor networks, but these
protocols either very expensive to be used in very resource-limited
environments such as sensor networks, or suffer from the lack of one or more
security guarantees and vulnerable to attacks such as wormhole, Sinkhole,
Sybil, blackhole, selective forwarding, rushing, and fabricating attacks. In
this paper we propose a secure lightweight routing protocol called SRPS. SRPS
uses symmetric cryptographic entities within the capabilities of the sensors,
supports intermediate node authentication of the routing information in
addition to end-to-end authentication, provides secure multiple disjoint paths,
and thwarts all the known attacks against routing infrastructure against
Byzantine cooperative attack model. We analyze the security guarantees of SRPS
and use Ns-2 simulations to show the effectiveness of SRPS in counter-measuring
known attacks against the routing infrastructure. Overhead cost analysis is
conducted to prove the lightweight-ness of SRPS","The open nature of the communication media used in wireless ad hoc and sensor networks, the lack  of infrastructure, the fast deployment polices, and the hostile environments where they usually deployed in, make these networks vulnerable to a wide range of attacks. Of the many areas vulnerable to attacks in sensor and ad hoc networks are the routing protocols. Attacks on routing can be external as well as  internal, and this means that there is a need to come up with schemes to safeguard the routing process.    Authentication of the routing information by the nodes involved in the route is necessary to prevent this informati on from being fabricated or modified by compromised nodes. Internal attacks on the routing  infrastructure  include Wormhole attack, Rushing attack, Sybil attack, Selective forwarding, Sinkhole  attack, spoofing, and malicious forge or change of the routing i nformation.  Due to the constrained resources available to sensor networks , the application of known  countermeasures used in wired networks will not be applicable.  Also, while  wireless sensor networks  share similarities with ad hoc wireless networks, the d ominant communication method on both is multi  hop; there are several important distinctions. Firstly, ad hoc networks usually support routing between  any pair of nodes in the network, whereas sensor networks has a narrower communication pattern in  which the bulk of the traffic is between a centralized point (called sink or base station) and each sensor in  the network, and little traffic goes between sensors, usually within the same geographic vicinity for  coordination and data aggregation. Secondly, the res ources in sensor networks (energy, CPU, memory,  storage, and bandwidth) are far more limited than those of ad hoc networks. Finally, due to redundancy in  sensor networks, many neighboring sensors observe the same or correlated environmental events. If ever y  one of these events is going to be sent to the base station independently, then precious resources will be  wasted. Thus, there must be trust relationships among sensors beyond those typically found in ad hoc  networks, to cooperate in data aggregation and  duplicate elimination to optimize resource usage.   Contribution:  in this paper we present a secure routing protocol for static sensor networks, called  SRPS that:  1. Thwarts  the internal Byzantine attacks launched by compromised nodes  such as wormhole attack,  Sybil attack , and blackhole attack .  2. Presents a novel way to provide  perhop authentication of the routing information in addition to the  endtoend authentication.   3. Is lightweight and only uses symmetric key cryptography tools to the extent of sensors capabilities.   4. Does not require any special hardware (such as directional antennas or GPS).   5. Does not require any time synchronization among the nodes in the network  (neither tight nor loose) .  6. Provides an idea  to link short commitment sequences without the need t o provide a new commitment  key when the current commitment sequence is exhausted, this eliminates the need  for large  commitment sequences.   7. Support s secure multiple disjoint path discovery  between the two end points of communication.   Trivial Denial of Serv ice attacks based on interception and non cooperation exist in all ad hoc routing  protocols but they are not achieved through subversion of the routing protocols, so they will not be considered.   The rest of the paper is organized as follows. Section  2 presents the related work in the field of secure  routing protocols in wireless ad hoc and sensor networks. Section  3 describes the S RPS protocol. Section  4 presents security analysis of S RPS. Section  5 presents coverage and cost analysis of S RPS.  Section  6 presents simulation results. Finally, Section  7 concludes the paper.       2 Related Work   "
68,Zero Energy Network stack for Energy Harvested WSNs.txt,"We present our ``Zero Energy Network'' (ZEN) protocol stack for energy
harvesting wireless sensor networks applications. The novelty in our work is
$4$ fold: (1) Energy harvesting aware fully featured MAC layer. Carrier
sensing, Backoff algorithms, ARQ, RTS/CTS mechanisms, Adaptive Duty Cycling are
either auto configurable or available as tunable parameters to match the
available energy (b) Energy harvesting aware Routing Protocol. The multi-hop
network establishes routes to the base station using a modified version of
AODVjr routing protocol assisted by energy predictions. (c) Application of a
time series called ``Holt-Winters'' for predicting the incoming energy. (d) A
distributed smart application running over the ZEN stack which utilizes a multi
parameter optimized perturbation technique to optimally use the available
energy. The application is capable of programming the ZEN stack in an energy
efficient manner. The energy harvested distributed smart application runs on a
realistic solar energy trace with a three year seasonality database. We
implement a smart application, capable of modifying itself to suit its own as
well as the network's energy level. Our analytical results show a close match
with the measurements conducted over EHWSN testbed.","Several disruptive sensing and control algorithms propose d for wireless sensor networks (WSNs) have remained abeyant duetopowerrequirementsforthehardware.However,recent ly Energy Harvesting wireless Sensor network (EHS) applica tions are a reality due to their independencefromutility po wer and thus unleashing several interesting proposals in sensi ng and control. This possibility is because of advancements in nanoelectronics and materials, increased power efﬁciency of harvesting electronics and the rapid advancements in high integrated ultra low power microcontrollers and communica  tion radios. The “ZigBee Green” [1] is speciﬁcally meant for running out of energy harvesting sources. Recent advance ments in materials and MEMS research has made Thermo Energy Generators (TEGs) and vibration harvesters (unusab le till recently) as potential energy sources. Other contribu ting parameters include system operating voltage & frequency of the microcontroller and radio, and ﬁnally the system’s seve ral low power modes. Operating voltages of about 1.8 volts with operating frequencies of less than 1MHz and sleep currents of the order of 100nA are some of the recent technology trends for system parameters. Radio communication energie s of about 10nJ per bit [2] is fast becoming a reality. Also, energy storage in thin ﬁlm batteries [3][4] and low leakage supercapacitors[5][6]withseveralthousandchargedisc hargecycles offer efﬁcient energy storage. EHS ﬁnd attractive applications wherever remote monitor ing and control are required and cover a wide spectrum of scenarios. On the one end could lie an intrusion detection sy s tem deployed in a wireless tripwire paradigm for monitoring an international border, and the other end of the spectrum is a simple wireless switch application for home lighting syste ms. Whilethe formerapplicationrequiresan energystoragebuf fer, the latter application requires energy generation and its u sage on the ﬂy. Also, these applications work in multihop and singlehop settings respectively. Other applications und er this wide spectrum include intelligent transportation, smart b uild ings, pollution monitoring, agriculture and climate chang e, health care includingbody area networksand other similar a p plications. For outdoor applications, while photovoltaic panels offer signiﬁcantly higher power compared to other harvesti ng sources, often sensor nodes packaged with these small panel s could physically be placed where reﬂected light or even a partial shade might be present. This is especially true for intrusion detection where the purpose is to detect an intrud er under a camouﬂage of the sensor node so as to avoid attention from the intruder. Additionally, seasonal variation in sun light plays an important role in ensuring continuous and untether ed operation of solar powered EHS nodes. Thus, applications perhaps have to continuously adjust to varying instantaneo us power ﬂuctuations and yet accomplish their primary assigne d task. Since the EHS nodes are usually wide spread and the communication of these nodes are limited in range, multi hop network is requiredwith performancedeteriorationwit hin acceptable limits. Thus, designing a multihop EHS sensor network under harsh incoming energy condition is indeed a challenge. One key difference between battery driven WSNs and EHS networks concerns the optimization parameters such as: (a) energy consumption to increase the node’s battery life and ( b) A network wide policy such as support a network lifetime of about “X” (say) number of hours or support the largest partitioned network. A large body of work in WSN is limited to maximizing the policy subject to a given energy constrain t or minimizing energy consumption to satisfy a network pol icy requirement. In direct contrast, for an energy harveste d network, the objective is to maximize the network policies and also maximize the energy consumption. In other words, minimize the energy differential between the available andconsumed energy in each discrete time slot and maximize the network policy. Our work in this paper uses a multicriteria optimization approach to ﬁnd the optimal network policy and energy differential curve. The signiﬁcance of optimal netw ork policyenergydifferential curve is to show a tradeoff bet ween global perspective of network policy and energy differenti al. Also, whenthe requirementoneithernetworkpolicyorenerg y consumption varies, one can use the optimal network policy energy differential curve to locate the new optimal tradeo ff. Fig. 1. Energy Harvesting Sensor node stack. In this paper, the goal is to implement a distributed smart application for environmentmonitoringapplicationswher e the sensor and communication nodes are powered with harvested energy. We approach this goal by building a protocol stack called the “ZEN Stack” as shown in Fig. 1. At the application layer, we consider the application performance not only its own energy level, but also on its neighbour and parent for warding nodes. We use energy measurements and time series predictions to change the behaviour of our base application in a manner that energy utilization is a maximum in the time slot. At the routing layer, since each node in the network can harvest different energy magnitudes and thus have a varying energyproﬁle,ﬁndingnetworkwiderouteswhenenergylevel s on nodes vary continuously is a challenge. Hence, routing protocols have to consider the energy harvested to decide ho w to route packets to the base station. At the data link layer, w e propose several enhancements to the existing Medium Access Control (MAC) Layer. Our goal is to study the performance of this stack in its ability to exploit the available energy t o the maximum extent possible. Thus ensuring network wide “energy neutrality” condition. The analysis followed by im  plementation results are encouraging and also show that eve n “near real time” applications can perform reasonably well. II. RELATED WORK "
330,IRIS: A Low Duty Cycle Cross-Layer Protocol for Long-Range Wireless Sensor Networks with Low Power Budget.txt,"This paper presents a cross-layer protocol (IRIS) designed for long-range
pipeline Wireless Sensor Networks with extremely low power budget, typically
seen in a range of monitoring applications. IRIS uses ping packets initiated by
a base station to travel through the multi-hop network and carry monitoring
information. The protocol is able to operate with less than 1% duty cycle,
thereby conforming to ISM band spectrum regulations in the 868MHz band. The
duty cycle can be flexibly configured to meet other regulations/power budgets
as well as to improve the route forming performance. Simulation results show
guaranteed route formation in different network topologies with various
protocol configurations. System robustness against unreliable wireless
connections and node failures are also demonstrated by simulations.","Wireless Sensor Networks (WSNs) offer low cost solutions  for long term monitoring tasks operating in various types of  environments  [1]. Compare d with conventional wired  monitoring systems, wireless sensor nodes  can be rapidly   deployed with minimal  infrastructure  requirements , with the  potential to automatically form a network according to their  selforganising nature. During operation , WSNs can be  designed to be  robust to single node failures thereby being  exempt from frequent maintenance by human engineers. In  recent  decades , WSNs have been applied to many applications,  such as geological event monitoring [2], animal habitat  monitoring [3], resource industry [5], health monitoring [6],  smart cities [7], smart grid s [8] and smart farming [9]. Now  WSNs have become  the solid foundation of the rapidly   expanding Internet of Things (IoT) [10].  Wireless sensor nodes are normally powered by batteries or  energy harvesting devices  [11], which makes energy efficiency  a critical requirement where WSNs need to operat e for a long  period of time . The Radio Frequency (RF) module on a node is  usually a major energy consumer, and the power consumption  is mainly from (re)transmitt ing, receiving packets and idle  listening.  Energy consumed by packet collisions,  retransmissions, exchanging control information, idle listening  and overhearing are considered as overheads [12].  Well designed Medium Access Control (MAC) and network  layers should be able to keep the se overheads as low as possible, while achieving the performance required by the  application. For example S MAC  [13] and Z MAC [14] use  duty cycling procedures  to switch nodes between active and  sleep states to conserve energy. Some regulations have also  considered limiting the duty cycles for spectrum sharing  purposes . For example the UK regulator Ofcom’s IR 2030  document [15] has limited the duty cycle of most 868 MHz  industrial, scientific and medical (ISM) band s to 1%, where  such a band  is widely used by Long Range Wide Area Network  (LoRaWAN) nodes for many IoT applications [16].   Having a low duty cycle benefits the energy efficiency while  meeting the regulations, however it limits the number of packet  exchanges between nodes, which are necessary for operating  the MAC and network layer protocols. Motivated by these  constraints, in this paper we present a simple but novel  cross layer protocol  (IRIS ) which is designed to operate with an   ultralow duty cycle, for long range monitoring tasks such as  river/canal monitoring, coastline monitoring, underwater cable,   motorway and railway monitoring. These applicati ons require   pipeline network topologies ( potentially over hundreds of  kilometres) , often in environments that are not well served by  existing wireless infrast ructure, so  the monitoring information  must be passed over a large number of hops to reach the  destination. The organisation of  routes through which  information travels becomes challenging in such situations,  where lengths of the pipelines are long and involve a large  number of nodes. The proposed IRIS protocol integrate s energy  efficient MAC and netwo rk layers, achieved by simple node  logic  to achieve operation with a less than 1% duty cycle.  Specific contributions of this paper are summarised as follows:   1) A protocol which can operate in a scenario where  the duty  cycle s of all nodes is less than 1% during both network  initialisation and normal operation . Unlike many  stateoftheart protocols which require the nodes to have  high duty cycles during initialisation, IRIS can be  deployed to nodes with  extremely  limited initial energy  storage (e.g. nodes powered by energy harvesting devices  only without batteries ).  2) A protocol where th e duty cycle can be controlled.  IRIS  uses ping packets  periodically  initiated by a base station at  one end of the network (and relayed by multiple nodes on a  route) to carry m onitoring information to a base station at  the other end of the network.  This allows the base station to  control the duty cycle of the network according to different IRIS: A Low Duty Cycle Cross Layer Protocol  for Long Range Wireless Sensor Networks with  Low Power Budget   Yi Chu , Paul Mitchell, David Grace , Jonathan Rober ts, Domini c White  and Tautvydas Mickus   2  requirements.  Ping packets are widely used in networks  using the Internet Protocol (IP) to  test the reachability to  certain destinations. In the IRIS protocol the ping packets  will ultimately reach the end base station of the WSN.   3) An energy efficient route discovery process.  R oute finding  is completed while relaying the ping packets  without any  knowledge  of neighbour nodes . The simple nature of IRIS  allows the protocol to be scaled to networks with different  number s of nodes and hops. The low computation al  requirements make the protocol feasible for deployment  on  lowcost nodes.   4) A protocol which integrates coordinated MAC layer and  network layer functions under energy and bandwidth  constraints . The node logic is able to achieve energy  efficient transmission/reception scheduling while relaying  the monitoring information towards the base stati on and to  adapt to network topology changes.  The simple nature of  the protocol allows the network to operate with extremely  low date rate available.   The rest of the paper is organised as follows. Section II  presents the related work on low duty cycle protocols. Section  III introduces the network topology and the main idea of IRI S.  Section IV explains the methods  IRIS uses to achieve  reliability . Section V presents the simulation results and  discussions. Section VI concludes the paper.   II. RELATED WORK  "
137,DAE : Discriminatory Auto-Encoder for multivariate time-series anomaly detection in air transportation.txt,"The Automatic Dependent Surveillance Broadcast protocol is one of the latest
compulsory advances in air surveillance. While it supports the tracking of the
ever-growing number of aircraft in the air, it also introduces cybersecurity
issues that must be mitigated e.g., false data injection attacks where an
attacker emits fake surveillance information. The recent data sources and tools
available to obtain flight tracking records allow the researchers to create
datasets and develop Machine Learning models capable of detecting such
anomalies in En-Route trajectories. In this context, we propose a novel
multivariate anomaly detection model called Discriminatory Auto-Encoder (DAE).
It uses the baseline of a regular LSTM-based auto-encoder but with several
decoders, each getting data of a specific flight phase (e.g. climbing, cruising
or descending) during its training.To illustrate the DAE's efficiency, an
evaluation dataset was created using real-life anomalies as well as
realistically crafted ones, with which the DAE as well as three anomaly
detection models from the literature were evaluated. Results show that the DAE
achieves better results in both accuracy and speed of detection. The dataset,
the models implementations and the evaluation results are available in an
online repository, thereby enabling replicability and facilitating future
experiments.","Over the past ten years, air trac control has faced a growing number of users and the trac load keeps grow ing steadily. With an increasingly congested airspace, numerous new issues are appearing such as  ight de lays. This increases the overall cost of the  ights and exacerbates an already existing tendency for air com panies to close down1in favour of lowcost companies. In another vein, congestioned airports imply that the planes stay longer in taxiways which is where they are the least ecient (Polishchuk et al., 2019), increasing their fuel consumption as well as their particle emis sions (Zhang et al., 2019). To tackle these new challenges, Air Trac Control (ATC) needs improved surveillance technologies sup porting the constraints in terms of simultaneously han dled aircraft as well as overall accuracy. The Automatic Dependent SurveillanceBroadcast (ADSB) protocol is currently being deployed worldwide in an eort to im prove  ights management. ADSB requires participat ing aircraft to broadcast their information periodically in an encoded message, like a beacon. This tech nology embodies the shift from independent and non cooperative surveillance technologies, historically used for aircraft surveillance, to dependent and cooperative technologies. In this new context, ground stations need aircraft to cooperate and are dependent on aircraft's Global Navigation Satellite System (GNSS) capabilities to determine their position. Nonetheless, ADSB is not a new protocol. The ICAO (International Civil Aviation Organization) issued a plan 1https://www.nbcnews.com/news/world/britishtravel rmthomascookcollapsesstrandinghundredsthousands n1057456arXiv:2109.04247v1  [cs.LG]  8 Sep 20212 Antoine Chevrot et al. in 20022recognizing ADSB as an emerging technol ogy for dissemination of aircraft position information. In 2021, ADSB is now compulsory in most airspaces but the protocol itself stayed sensibly the same as it was imagined twenty years ago and the security was not in the highest priority. As a result, anyone with the proper equipment can receive and create messages freely. This liberty in both emission and reception make ADSB vulnerable to spoong, and more precisely to attacks called FDIA | False Data Injection Attack | which purpose is to create fake surveillance messages respect ing conscientiously the protocol in order to dupe the air trac controllers to believe in an abnormal situation. Although ADSB is not the only protocol used for  ights tracking { e.g radar technologies {, it is, as of today, a central brick in the means of surveillance used by public air transportation. In this context, there has been a growing interest for conducting research on anomaly detection systems that address these new threats (Strohmeier et al., 2015b). Among the dierent existing solutions, some are based on Machine Learning (ML) anomaly de tection models. These models already nd applications in many dierent domains like power systems (Wang et al., 2018) or sensor networks (Malhotra et al., 2016) and are found quite popular in recent years. One down side of these models is their need for consequent data availability to achieve meaningful results. It is indeed critical for ML researchers to have access to reliable and genuine data sources to train their models. Thankfully, for ADSB data, the OpenSky Network (Sch afer et al., 2014) is one of the references in terms of accessibil ity and data history in air transportation, and one can easily obtain surveillance data from almost anywhere on the globe. This access to genuine data and the lacks of anomalous ones in comparison favours one particular architecture of ML model called autoencoders. Autoencoders are unsupervised ML models often used for anomaly detection and can be found in the literature in many dierent forms. These models use a rst network called the encoder which encodes the input data into a latent representation which is then decoded by a second network called the decoder. The discrepancies between the input data and the output ones are then used to detect anomalies in the origi nal data. They can be coupled with Recurrent Neural Networks  RNN  to address the temporality of the data (Malhotra et al., 2016). Shown to be quite eec tive, they have already been used in the past to detect dierent types of anomalies in the ADSB protocol like 2https://www.icao.int/publications/Documents/9750_ 2ed_en.pdfenroute trajectory anomalies (Olive and Basora, 2019) or spoong attempts (Ying et al.). This paper presents a novel type of autoencoder to use for anomaly detection in ADSB. The main contri butions of this work is listed hereafter: (i)The DAE {Discriminatory autoencoder{, a novel asymetric autoencoder addressing  uctuations in time series. To the best of our knowledge, this is the rst time autoencoders are used with a single encoder connected to several decoders for anomaly detection in timeseries. (ii)The full data framework using existing tools includes the data cleaning, the feature extraction and the data serialization for model training. Emphasis is made on replicability through a code repository pub licly accessible. (iii) Realistic and replicable validation scenarios are cre ated using an alteration tool to experiment with dif ferent types of anomalies. It results in a dataset also available online to compare future models and pro vide a common base for benchmarks and studies. (iii) Experimental results using the abovementioned val idation scenarios to compare the dierent existing solutions of ML anomaly detection showing that the DAE performs well overall. To present the model and the dierent results achieved with it, this paper has been organized as follows: Section 2 provides a basis for understanding the ADSB protocol, an explanation on FDIAs and the risks associated with it. Section 3 presents previous works done on anomaly detection for the ADSB with an em phasis on Machine Learning based techniques. Section 4 introduces the novel anomaly detection model devel oped in this paper by detailing its architecture. Sec tion 5 details the process of data gathering and pro cessing to obtain proper training data for the model. Section 6 presents the evaluation of this paper, show casing the data used and the dierent results obtained using dierent anomaly detection models. Follow some discussions about implementation and caveats in Sec tion 7 .Section 8 concludes this paper. 2 Background 2.1 ADSB overview Communication via ADSB consists of aircraft using a Global Navigation Satellite System (GNSS) to de termine their position and broadcasting it periodically without solicitation (a.k.a beacons or squitters), along with other information obtained from onboard systemsDAE : Discriminatory AutoEncoder for multivariate timeseries anomaly detection in air transportation 3 such as altitude, ground speed, aircraft identity, head ing, etc. Ground stations pick up on the squitters, pro cess them and send the information out to the ATC system. The ADSB data link is generally carried on the 1090MHz frequency. ADSB is therefore a coop erative (aircraft need a transponder) and dependent (on aircraft data) surveillance technology, which con stitutes a fundamental change in ATC. It means for instance that not only ground stations with antennas positioned at the right angle and direction can receive position information. Aircraft can now receive squitters from other aircraft, which notably improves cockpit sit uational awareness as well as collision avoidance. The introduction of ADSB also provides controllers with improved situational awareness of aircraft posi tions in EnRoute and TMA (Terminal Control Area) airspaces, and especially in NRAs (Non Radar Areas). It theoretically gives the possibility of applying much smaller separation minima (e.g., from 80NM longitu dinal separation to just 5 NM in NRAs) than what is presently used with current procedures (Procedural Separation) (51, 2005). It has a much greater accuracy and update rate, with a smaller latency. The major drawback of the technology lies in its lack of encryption and authentication, which is discussed in the following section. 2.2 False Data Injection Attacks The progressive shift from independent and nonco operative technologies (PSR/SSR (Skolnik, 2008)) to dependent and cooperative technologies (ADSB) has created a strong reliance on external entities (aircraft, GNSS) to estimate aircraft state. This reliance, along with the introduction of airtoground data links via Modes A/C/S and the broadcast nature of ADSB, has brought alarming cyber security issues. Extensive re search can be found in the literature that discuss these issues (Sch afer et al., 2013; Zhang et al., 2017; Wesson et al., 2014; Strohmeier et al., 2017), stressing that the introduction of ADSB has enabled a class of attack referred to as False Data Injection Attacks (FDIAs). FDIAs were initially introduced in the domain of wireless sensor networks (Ma, 2008). A wireless sen sor network is composed of a set of nodes (i.e. sen sors) that send data report to one or several ground stations. Ground stations process the reports to reach a consensus about the current state of the monitored system. A typical scenario consists of an attacker who rst penetrates the sensor network, usually by compro mising one or several nodes, and thereafter injects false data reports to be delivered to the base stations. This can lead to the production of false alarms, the waste ofvaluable network resources, or even physical damage. Active research regarding FDIAs has been conducted in the power sector, mainly against smart grid state es timators (Dan and Sandberg, 2010; Liu et al., 2011). It shows that these attacks may lead to power black outs but can also disrupt electricity markets (Xie et al., 2010), despite several integrity checks. FDIAs also exist in the domain of air trac surveil lance. Because surveillance relies on the information provided by aircraft's transponders to ground stations, aircraft transponders are equivalent to nodes from a wireless network, and ground stations are equivalent to base stations. Although in the ATC domain, there is no real eort to penetrate the sensor network, as all com munications are unauthenticated and in clear text. Still, performing FDIAs on surveillance communications re quires a deep understanding of the system, its proto col(s) and its logic, to covertly alter the surveillance  ow. These attacks are much more complex to achieve than e.g., jamming, because the logic of the commu nication  ow must be preserved and the falsied data must appear probable. The means of the attacker to conduct FDIAs against ADSB communications have already been detailed in previous work (Strohmeier, 2016; Manesh and Kaabouch, 2017). Considering the attacker has the necessary equip ment, they can perform three malicious basic opera tions: (i)Message injection which consists of emitting non legitimate but wellformed ADSB messages. (ii)Message deletion which consists of physically delet ing targeted legitimate messages using destructive or constructive interference. It should be noted that message deletion may not be mistaken for jamming, as jamming blocks all communications whereas mes sage deletion drops selected messages only. (iii) Message modication which consists of modifying targeted legitimate messages using overshadowing, bit ipping or combinations of message deletion and message injection. One can sense the potential for disaster if one of these operations was to be executed successfully. It is of the utmost importance that none of the scenarios represent a real threat to such a critical infrastructure with human lives on the line. However, because of the inherent properties of the ADSB protocol, current so lutions for securing ADSB communications are only partial or involve an unbearable cost Strohmeier et al. (2017). Therefore, ATC systems must become robust against FDIAs, i.e. being capable of automatically de tecting any tempering with the surveillance communi4 Antoine Chevrot et al. cation  ow while being able to maintain the infrastruc ture in a working state. 3 Related Work "
352,A framework for compositional verification of security protocols.txt,"Automatic security protocol analysis is currently feasible only for small
protocols. Since larger protocols quite often are composed of many small
protocols, compositional analysis is an attractive, but non-trivial approach.
  We have developed a framework for compositional analysis of a large class of
security protocols. The framework is intended to facilitate automatic as well
as manual verification of large structured security protocols. Our approach is
to verify properties of component protocols in a multi-protocol environment,
then deduce properties about the composed protocol. To reduce the complexity of
multi-protocol verification, we introduce a notion of protocol independence and
prove a number of theorems that enable analysis of independent component
protocols in isolation.
  To illustrate the applicability of our framework to real-world protocols, we
study a key establishment sequence in WiMax consisting of three subprotocols.
Except for a small amount of trivial reasoning, the analysis is done using
automatic tools.","Security protocols are a crucial component of many contemporar y applica tions. Their security is however very diﬃcult to assess for humans, mainly due to the vast number of attack options available to an adversary . To deal with this complexity, a structured approach is needed. Starting fr om abstract protocols, formal methods faciliate the systematic detection of a ttacks or the generation of a proof of correctness. Automating this process in order to min imize the risk of human error is one of the major goals in security prot ocol analysis. Automatic protocol veriﬁcation is, in general, a complex task even f or short protocols.Thetimeneededforveriﬁcationofaprotocolusingmod ernmethods employed by state of the art tools such as Scyther [11] or AVISPA [4 ] is still exponential with respect to the number of messages. Consequen tly, automatic veriﬁcation of large protocols is currently infeasible. In this paper, we attempt to narrow the gap between small, academic protocols and large, indu strial protocols by taking advantage of compositional veriﬁcation. Large protocols are usually built from structured components. Th ey typically consist of several (optional) protocols composed in parallel, or a se quential composition of a key establishment protocol and a secure data tra nsfer pro tocol that uses the key. For instance, IPSec, SET, and WiMAX hav e all been designed with such a principle in mind. A compositional approach to the de sign and analysis of security protocols is therefore natural and ex pected to reduce the complexity of the analysis of the large protocol to the o rder of the complexity of the analysis of the largest component. This could be ac hieved by ﬁrst verifying properties of the components in isolation and then using the results to deduce properties of the composed protocol. Howe ver, as no generic compositionality results are known, further assumptions a re needed to facilitate this type of reasoning. We illustrate the nontriviality of protocol composition by means of t he well knownNeedhamSchroederLowe( NSL)publickeyauthenticationprotocol[33, 38]. In isolation, it satisﬁes even the strongest forms of authentic ation, such as ∗Corresponding author. Phone: (+352) 46 66 44 5484, Fax: (+35 2) 46 66 44 5500 Email addresses: suzana@item.ntnu.no (Suzana Andova), cremersc@inf.ethz.ch (Cas Cremers), kristian.gjosteen@math.ntnu.no (Kristian Gjøsteen), sjouke.mauw@uni.lu (Sjouke Mauw), sfm@item.ntnu.no (Stig F. Mjølsnes), sasa.radomirovic@uni.lu (Saˇ sa Radomirovi´ c). 1This work was partially carried out during the tenure of an ER CIM Fellowship. 2Supported in part by the Norwegian Research Council project 158597 NTNU Research Programme in Information Security. 3Supported in part by a Centre de Recerca Matem` atica Postdoc toral Fellowship. 2ni,ni′ inr,nr′ r {|ni,i|}pk(r) {|ni,nr,r|}pk(i) {|nr|}pk(r) {|ni′,i|}pk(r) {|ni′,nr′,r|}pk(i) {|nr′|}pk(r)ni,ni′ inr,nr′ r {|ni,i|}pk(r) {|ni,nr,r|}pk(i) {|nr|}pk(r) {|ni′,i,nr|}pk(r) {|ni′,nr′,r|}pk(i) {|nr′|}pk(r) Fig. 1. Repeated NSLprotocol: incorrect and correct chaining. agreement and synchronization [16]. However, when sequentially co mposing this protocol with itself (see the left drawing in Figure 1), authentic ation is not preserved. The reason is that the initiator imay successfully ﬁnish his run of the composed protocol, while the responder rpossibly never executed the second half of the protocol. This is because the second half of the in itiator’s run may match to the ﬁrst half of a diﬀerent run of the responder. This au thentication problem is illustrated in Figure 2. Here we see agent Aexecuting the initiator role iand agent Bexecuting two diﬀerent runs of the responder roler. The intruder links the messages as indicated. Run A(i) and run B(r)♯2 will agree on the values of ni, andnr, but not on the values of ni′andnr′, since these last two values are not communicated between these tw o runs. In a similar way, it is clear that run A(i) and run B(r)♯1 do not agree on the supposedly shared nonces. This problem is solved in the right drawing in Figure 1 by chaining the two protocols. A nonce from the ﬁrst instance of NSLis repeated as payload in the second instance. In this way the two protocols become linked and th e chained protocol satisﬁes authentication. The authentication problem fr om Figure 2 is now impossible. Eventhoughitiswell knownthatthecompositionofsecureprotoco lsisingen eral not secure [2,13,26,32] and compositionality has been recog nised as one of the open challenges for security protocol analysis [12,37], the vas t majority of formalisms andtoolsforsecurity protocolshave only addressed sin gleprotocol (i.e. noncomposed) analysis and veriﬁcation. Early work on identify ing and addressing the problem includes [20,39]. An initial attempt within the S trand Spaces model [42] has led to some theoretical results about compo sitionality. The Strand Spaces approach is similar to the one taken here in that b oth at tempt to identify the abstract properties two protocols need to s atisfy in order 3A(i) B(r)♯1B(r)♯2 Fig. 2. Authentication problem in incorrectly chained NSL p rotocol. to be securely composable. However, this work signiﬁcantly improve s uponthe Strand Spaces approach in terms of eﬃciency in verifying composed protocols and by considering sequential composition, which was absent in the S trand Spaces model. One of the recent signiﬁcant developments in compos itional protocol analysis is Protocol Composition Logic (PCL) [17,18]. It pr ovides support for compositional reasoning, and has been applied in a numb er of case studies, including the veriﬁcation of the TLS and IEEE 802.11i p roto cols [25] and contract signing protocols [5]. While the PCL approach is q uite general, it cannot, in contrast to the present approach, be easily automated. Inthis paper, wedevelop aframework to verify security propertie sof protocols that are composed from several smaller protocols. We prove seve ral theorems concerning the deduction of properties of a sequential compositio n of two protocols from properties these protocols have when running tog ether in a multiprotocol environment. With these theorems, we reduce the analysis of a sequential composition to the analysis of the component protoco ls running together. Analysing several protocols in a multiprotocol environment is, in ge neral, no easier thananalysing their sequential composition. Inordertomak e automatic analysis feasible, we introduce the notion of protocol set independ ence, where ciphertexts, signatures, and message authentication tags origin ating in one protocol set will never be accepted by the other protocol set an d vice versa. This notion allows us to prove several theorems regarding the dedu ction of properties of protocols running together in a multiprotocol envir onment from properties these protocols have when running in isolation. Verifying independence itself is nontrivial, therefore we need the n otion of strong independence, where the forms of ciphertexts, message authentication tags,andsignaturesinthetwoprotocolsetsaresuﬃciently diﬀer enttoprevent confusion. Strong independence can be easily veriﬁed at the synta ctical level, and implies independence. We show that through common design stra tegies 4for security protocols in current use, strong independence will be satisﬁed. Note that diﬀerent protocols can use the same cryptographic key s and still be both, independent and strongly independent. The model we use is based on the operational semantics for securit y proto cols deﬁned in [15]. In contrast to other approaches, in which only sin gular protocols are considered, this model provides a semantics of prot ocols in a multiprotocol setting. This makes it a good starting point for comp ositional veriﬁcation, since, as indicated, the problem of proving correctne ss of a com posed protocol can be translated into the problem of proving corr ectness of the components in a multiprotocol setting comprising the compone nts them selves. To show the applicability of our work, we perform a case study. We ha ve chosen to focus on the IEEE 802.16 standard, also known as WiMAX. This standard speciﬁes the air interface of wireless access systems fe aturing a se curity sublayer intended to protect network operators from the ft of service and provide conﬁdentiality to subscribers. WiMAX features a secur ity sub layer consisting of several subprotocols for authentication, key management, and secure communication. This makes WiMAX well suited for an analys is in our framework. Our veriﬁcation is completely toolsupported, exc ept for some trivial reasoning and theorem application. Overview of the paper We start oﬀ by giving a brief description of the security protocol mo del and security properties used in Section 2. In Section 3, we develop a fra mework for compositional reasoning about security protocols, and prove a number of compositionality theorems. We show how the developed theory can b e ap plied in practice by performing a case study on key management prot ocols in the security sublayer of WiMAX in Section 4. Related work is discussed in "
156,"Group Mobility: Detection, Tracking and Characterization.txt","In the era of mobile computing, understanding human mobility patterns is
crucial in order to better design protocols and applications. Many studies
focus on different aspects of human mobility such as people's points of
interests, routes, traffic, individual mobility patterns, among others. In this
work, we propose to look at human mobility through a social perspective, i.e.,
analyze the impact of social groups in mobility patterns. We use the MIT
Reality Mining proximity trace to detect, track and investigate group's
evolution throughout time. Our results show that group meetings happen in a
periodical fashion and present daily and weekly periodicity. We analyze how
groups' dynamics change over day hours and find that group meetings lasting
longer are those with less changes in members composition and with members
having stronger social bonds with each other. Our findings can be used to
propose meeting prediction algorithms, opportunistic routing and information
diffusion protocols, taking advantage of those revealed properties.","Many practical problems can beneﬁt from the knowledge of the underneath dynamics that govern human mobility. For example, it can be applied to better plan urban infrastructure, forecast trafﬁc, map the spread of biological viruses, or better design Mobile Adhoc Network (MANET) protocols. Speciﬁc network problems such as opportunistic routing and information diffusion in MANETs share a common in teresting property: they are highly dependent on how humans interact with each other. In this context, we deﬁne a human group as set of people that, for some reason or goal, get together in space and time. It is clear that knowledge of regular group meetings can be explored to improve the current state of the art of opportunistic information diffusion, routing or to increase the current understanding of how diseases spread. However, it remains a challenge how to deﬁne, detect, keep track and analyze groups of humans and their dynamics. In the literature, there are several proposals dedicated to understanding and modeling human mobility considering diverse aspects, but group mobility is currently an untrodden ﬁeld. The human species is a pretty sociable and this sociability must be considered in order to better understand, model and predict movement. The growing ubiquity of geolocalization sensors and the availability of data collected by them create a new opportunity to tackle the problem of group mobility. Withthis in mind, the present work focuses on characterization of groups’ dynamics through the analysis of proximity contact traces. Among the contribution of this work, we highlight:  Deﬁnition of a methodology for telling apart random and social interactions in proximity traces using a time dependent social graph model;  Proposal of a systematic way for detecting and track ing human mobile groups;  Characterization of group mobility properties, includ ing group evolution, periodicity and meeting dura tions;  A discussion and some early results on how knowl edge of group mobility could be applied to design opportunistic network protocols. This paper is organized as follows. Section II reviews some of the related work and discusses the corresponding contribu tions to characterization and modeling of group mobility. Sec tion III formalizes our methodological steps to detect track and characterize human groups’ dynamics. Section IV describes the experiments’ methodology and metrics, presenting results and the main groups’ characteristics detected. Section V discusses the application of group detection to information dissemination protocols. Finally, Section VI brings the ﬁnal remarks and future work. II. R ELATED WORK "
367,Performance Evaluation and Impact of Weighting Factors on an Energy and Delay Aware Dynamic Source Routing Protocol.txt,"Typical applications of the mobile ad-hoc network, MANET, are in disaster
recovery operations which have to respect time constraint needs. Since MANET is
affected by limited resources such as power constraints, it is a challenge to
respect the deadline of a real-time data. This paper proposes the Energy and
Delay aware based on Dynamic Source Routing protocol, ED-DSR. ED-DSR
efficiently utilizes the network resources such as the intermediate mobile
nodes energy and load. It ensures both timeliness and energy efficiency by
avoiding low-power and overloaded intermediate mobile nodes. Through
simulations, we compare our proposed routing protocol with the basic routing
protocol Dynamic Source Routing, DSR. Weighting factors are introduced to
improve the route selection. Simulation results, using the NS-2 simulator, show
that the proposed protocol prolongs the network lifetime (up to 66%), increases
the volume of packets delivered while meeting the data flows real-time
constraints and shortens the endto- end delay.","A Mobile Adhoc NETwork (MANET) has become increasi ngly popular due to its autonomic  and infrastructureless properties of dynamically s elforganizing, selfconfiguring and self adapting. With MANET, mobile nodes can move and acc ess data randomly at anytime and  anywhere. There is no need for fixed infrastructure . Mobile nodes such as PDA or laptops are  connected by wireless links. They may act as a host  and as a router in the network. They are  characterized by their reduced memory, storage, pow er and computing capabilities. We classify  the mobile nodes into two groups: small mobile host s (SMH) which have a reduced memory,  storage, power and computing capabilities and large  mobile hosts (LMH) equipped with more  storage, power, communication and computing facilit ies than the SMH.   MANET covers a large range of applications such as military operations where common wired  infrastructures are not directly reachable to provi de communication due to limited provision of  this facility in those settlements. We focus especi ally on realtime applications where a number  of them, including defence applications, have to re spect time constraint in order to update  wounded or positions of soldiers and enemies, get e nemy map position or find medical  assistance.  Realtime applications require their flows to be tr eated not only correctly but also within their  deadlines. However, the workload of realtime appli cations is unpredictable which may lead the International Journal of Computer Science & Informa tion Technology (IJCSIT) Vol 3, No 4, August 2011   226       mobile nodes to become quickly overloaded. Since in  MANET the mobile nodes are power  limited and require energy for computing as well as  routing the packets, the performance of a  realtime application highly depends on the lifetim e of mobile nodes. In fact, the energy  depletion of mobile nodes may lead to interruptions  in communications. Therefore, the realtime  data may miss their deadlines. So respecting the de adline cannot be guaranteed neither with  exhausted energy resources nor with overloaded inte rmediate mobile nodes. The main problem  is to choose the QoS aware routing protocol to rout e realtime data with respect to their  deadlines within MANET constraints.  Currently, most MANET research has focused on routi ng and connectivity issues [3] [7] in  order to cope with the dynamism of such networks. J ust solving the problem of connectivity is  not sufficient for using MANET. Some routing protoc ols are extended to support the quality of  service, QoS. To determine a route, a QoS routing p rotocol considers QoS requirements of the  traffic data (such as maximum bandwith availability , minimum endtoend delay and so on.) and  resources availability (such as maximum residual en ergy, etc.), too.   Based on dynamic source routing (DSR) [5], we intro duce the Energy and Delay aware  Dynamic Source Routing protocol (EDDSR) for MANET.  EDDSR is a routing protocol that  considers the energy efficiency and load capacities  in selecting route while focusing on the  delay guarantee and the overall network performance . In EDDSR, the route selection is done  according to residual energy and queue load of inte rmediate nodes, too. EDDSR allows the  packets of realtime data to be routed before the e xpiration delay. Simulation results show that  EDDSR outperforms the basic routing protocol, DSR,  in providing longer network lifetime and  lower energy consumption per bit of information del ivered. In addition, it minimizes the endto end delay and upgrades the rate of packets delivere d.  The rest of the paper is organized as follows: in t he second section, we present the basic routing  protocol. Then, we expose the related works in qual ity of service routing protocols. In the fourth  section, we describe the proposed Energy and Delay aware Dynamic Source Routing (EDDSR)  protocol. Detailed analysis of the performance diff erence is performed in sections 5 and 6.  2 THE DYNAMIC SOURCE ROUTING PROTOCOL , DSR  With routing protocols in mobile adhoc network, th e mobile nodes search for a route to connect  to each other in order to share the data packets. T he routing protocols can be categorized into  two, namely, table driven proactive like OLSR (Opti mized Link State Routing Protocol) [9] and  ondemanddriven reactive source initiated protocol s like DSR [5]. The focus in this work is on  reactive routing suitable to be deployed in a netwo rk with high mobility of the nodes where  routes are created dynamically as and when required  [10].  The Dynamic Source Routing Protocol, DSR, is an on demand routing protocol [5]. It discovers  routes between two nodes only when required which r educes the number of control packets.  DSR is based on three phases: the route request, th e route reply and the route selection. In route  request, the source mobile node discovers routes to  the destination node. The route reply returns  the discovered route from the destination to the so urce mobile node. In route selection, the  source mobile node selects the shortest route among  the discovered routes.  The route discovery is based on two messages i.e. r oute request packet (RREQ) and route reply  packet (RREP). When a mobile node wishes to send a message to a specific destination, it  broadcasts the RREQ packet in the network. The neig hbour nodes in the broadcast range receive  this RREQ message and add their own address and aga in rebroadcast it in the network.  International Journal of Computer Science & Informa tion Technology (IJCSIT) Vol 3, No 4, August 2011   227         Figure 1 DSR RREQ packets  When the RREQ message reaches the destination, the route to the specific destination is yet  defined. In fact, the message that reaches the dest ination has full information about the route.  That node will send a RREP packet to the sender (so urce node) in order to have complete route  information.     Figure 2 DSR RREP packets   The source node, among the discovered routes, selec ts the shortest one. The source node now  has complete information about the route in its rou te cache and can start routing the data flows.  In DSR, the routes are stored in without any constr aint on quality of services. The delay  requirement is not considered to ensure that packet s will reach their destinations before the  deadlines. Furthermore, DSR doesn’t contribute to r educe the power consumption of mobile  node, alleviating the network partitioning problem caused by the energy exhaustion of these  nodes.   3 RELATED WORK IN QUALITY OF SERVICE ROUTING PROTOCOLS   "
184,DQSB: A Reliable Broadcast Protocol Based on Distributed Quasi-Synchronized Mechanism for Low Duty-Cycled Wireless Sensor Networks.txt,"In duty-cycled wireless sensor networks, deployed sensor nodes are usually
put to sleep for energy efficiency according to sleep scheduling approaches.
Any sleep scheduling scheme with its supporting protocols ensures that data can
always be routed from source to sink. In this paper, we investigate a problem
of multi-hop broadcast and routing in random sleep scheduling scheme, and
propose a novel protocol, called DQSB, by quasi-synchronization mechanism to
achieve reliable broadcast and less latency routing. DQSB neither assumes time
synchronization which requires all neighboring nodes wake up at the same time,
nor assumes duty-cycled awareness which makes it difficult to use in
asynchronous WSNs. Furthermore, the benefit of quasi-synchronized mechanism for
broadcast from sink to other nodes is the less latency routing paths for
reverse data collection to sink because of no or less sleep waiting time.
Simulation results show that DQSB outperforms the existing protocols in
broadcast times performance and keeps relative tolerant broadcast latency
performance, even in the case of unreliable links. The proposed DQSB protocol,
in this paper, can be recognized as a tradeoff between broadcast times and
broadcast latency. We also explore the impact of parameters in the assumption
and the approach to get proper values for supporting DQSB.","A Wireless Sensor Network (WSN) consists of a large  number of small and low cost sensor  nodes powered by small batteries and equipped with various sensing devices to observe events  in the real world [14].  Usually, for many applications, once a WSN is depl oyed, probably in an  inhospitable terrain, it is expected to gather requ ired data for a certain period of time, which can  reach a length of years. To bridge the gap between limited energy supplies and network lifetime,  a WSN has to operate in a low dutycycled manner, w here nodes schedule themselves to be  active for a brief period of time and then stay asl eep for a long period of time [5, 6] . There are  two types of dutycycled WSNs, i.e. asynchronous sl eep scheduling, where each sensor keeps a  sleep schedule independent of another, and synchron ous sleep scheduling, where sensors make  synchronized periodic duty cycling with their neigh boring nodes to support broadcast or unicast  and reduce the idle listening energy cost. Any slee p scheduling scheme has to ensure that data  can always be routed from source to sink [7]. International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 3, June 2012  66       Usually, sleep schedules are completely uncoordinat ed. Due to the variation of awake time and  duration of the active interval, the whole network is more than often disconnected, and delay  encountered in packet delivery due to loss in conne ctivity can become a critical problem. As a  result, a path from source to sink may not always b e available, and a sufficient number of nodes  have to remain awake to ensure the existence of suc h a path. Consequently, data is stored at a  node till its proper neighboring node wakes up and delivers the data to the sink. This approach  would delay the delivery of messages to a sink cons iderably.  The existing works based on synchronization assume that there are usually multiple neighbors  available at the same time to receive the multicast /flooding message sent by a sender. This is not  true in low dutycycled asynchronous WSNs. Furtherm ore, synchronization is another issue that  is difficult to achieve, especially over multiple h ops. Periodic synchronization messages may  become costly. Usually, synchronization protocols a re complex and difficult to implement in  large scale WSNs. Without synchronized sleep schedu ling, BMAC [8], WiseMAC [9] and X MAC [10] are based on asynchronous sleep intervals and prov en to be energyefficient in  scenarios with low or varying traffic loads. Unfort unately, they cannot be directly applied to  broadcast applications because of their design inte ntions for unicast.  Multihop broadcast is an important network service  in WSNs, especially for applications such  as code update, remote network configuration, route  discovery, and so on. Distinguished from  the broadcast problem in alwayson networks, two ad ditional features make multihop broadcast  in low dutycycled WSNs become a new challenging is sue. Firstly, a node which broadcasts a  message once cannot guarantee that the message is r eceived by all of its neighboring nodes  simultaneously, while this property is satisfied in  an alwayson network. To successfully  broadcast a message, a sender has to transmit the s ame message more than once if other nodes  do not wake up at the same time. Essentially, broad casting in such a network is implemented by  a number of unicasts. Secondly, in asynchronous dut ycycled WSNs, each node cannot be  aware of its neighboring nodes' sleep schedules wit hout neighboring discovery and information  exchange protocols which require nodes to remain aw ake for enough time in order to aware  their neighbors' sleep schedules.  Therefore, a question arises: Is it possible to mai ntain a high broadcast delivery rate and to  exploit nodes' sleep schedules without the support of synchronization protocol at the same time,  in asynchronous dutycycled WSNs, where each sensor  turns on and off independently and  network connectivity is intermittent? Different fro m the existing related work, we propose a  quasisynchronization mechanism in order to coordin ate nodes' dutycycled behaviors in a  distributed manner. It is quasi because nodes are n ot required to wake up at the exact same time.  Sleep schedule adjustments stop if all the nodes ex cept the sender are able to receive broadcast  messages.  The main contributions of this paper are summarized  as follows: (1) We propose a novel  protocol DQSB by a mechanism of quasisynchronizati on for multihop broadcast, which  neither assumes time synchronization that requires all neighboring nodes wake up at the same  time, nor assumes dutycycled awareness that is dif ficult to use in asynchronous WSNs; (2)  After broadcast process from a sink is finished und er the quasisynchronization mechanism,  other nodes can build their paths to the sink for t ransmitting their sensed data after receiving the  broadcast messages. Moreover, these paths exhibit l ess latency because of no or very little  waiting time; (3) We develop a simulator based on t he ONE simulator [11] and evaluate DQSB,  including broadcast times and latency in different duty cycles, the impact of network size,  reliability with unreliable links and less latency routing paths for reverse data collection from  each node to broadcast source node, such as a sink.  Simulation results show that the  performance of DQSB satisfies the design goals. International Journal of Wireless & Mobile Networks  (IJWMN) Vol. 4, No. 3, June 2012  67       The rest of the paper is organized as follows: Sect ion 2 reviews the related work. Section 3  describes the models and assumptions of the solutio n to broadcasting and routing in dutycycled  WSNs. The design and implementation of DQSB are pre sented in Section 4. Simulation results  are discussed and analyzed in Section 5, where the impact of parameters in the assumption and  the approach to get proper values are explored for supporting DQSB. We conclude the paper in  Section 6.  2.  RELATED WORK   "
409,Analysis of Demand Driven Ad-hoc Routing Protocols on Performance and Mobility.txt,"Mobile ad hoc networking (MANET) is a growing technology that can support the
operation of adaptive wireless networks. With the increased demand rate of
wireless applications it is useful to have more adaptive and self organizing
technologies that adapt to changes within a network region. In this paper we
initially present a brief listing of table driven ad hoc routing protocols and
eventually analyze in detail the behaviour of demand driven ad hoc routing
protocols like - Ad Hoc On Demand Distance Vector Routing (AODV), Dynamic
Source Routing (DSR), Temporally-Ordered Routing Algorithm (TORA) in terms of
throughput, traffic dropped, routing traffic and mobility. The output graphs
are eventually discussed, thus enabling us to understand the routing technology
better.","  The mobile wireless network can be broadly classified  into two modes, namely – infrastructure mode and ad hoc  mode. In infrastructure mode, a central base station is used  for the mobile nodes to communicate with as long as it is  within the communication radius of base station. Handover  happens when the mobile node moves into the  communication radius of another base station, leaving the  previous one. In ad hoc mode, there are no fixed routers and  all nodes are capable of movement and can be connected in  a dynamic and arbitrary way. Nodes of these network act as  routers that discover and maintain routes to other nodes.  Example applications of ad hoc networks can be emergency  search and rescue operations and data acquisition operations  in unwelcoming terrains.  Ad hoc routing protocols are  getting popular with the increase in mobile computing. Ad  hoc networks include resourcestarving devices, low  bandwidth, high error rates and a topology that is  continuously changing. Some of the design goals with ad  hoc routing protocols are – minimal control overhead,  minimal processing overhead, multihop routing capability,  dynamic topology maintenance and loop prevention. The  protocols should operate in a distributed manner. The nodes  should operate either in proactive or reactive mode. This can  also be termed as table based or demanddriven modes  respectively. Proactive protocols are tablebased and  maintain routes for the entire network within each node. The  nodes must be fully aware of the changing topology. The  table based mode is quite an old way to get routing done in  ad hoc networks. By keeping routing tables to store the  location information of other nodes, this approach  distributes the routing data to other nodes. For topologies  that are overtly dynamic, the above approach can introduce a considerable overhead. Reactive protocols or demand  driven protocols trade off this overhead with increased  delay. A route to destination is established when it is needed  based on an initial discovery between the source and  destination [1]. In our paper, we analyze the different  demand driven adhoc routing protocols’ performance and  other behavior. The paper is organized as follows. Section II  gives a brief analysis of mobile ad hoc tabledriven  protocols, Section III gives a comparison of mobile ad hoc  demanddriven protocols, Section IV shows the simulation  result with demanddriven protocols, Section V gives the  comparison summary on demanddriven protocols, Section  VI is related work and Section VII is the conclusion.     II.  TABLE DRIVEN PROTOCOLS      In table driven approach, the freshness of the routing  tables is ensured by broadcasting a hello packet with  address information at frequent intervals of time. Each node  thus updates the location information of other participating  nodes. DestinationSequenced Distance Vector (DSDV) ,  Clusterhead Gateway Switch Routing (CGSR) and Wireless  Routing Protocol (WRP)  are some examples of table driven  protocols. A brief description of different table driven  routing protocols is given below: DestinationSequenced  Distance Vector  is a different version of the BellmanFord  algorithm to take care of time dependent topologies. Each  node maintains a routing table with the next hop entry for  each destination and metric for each link. Each entry is  marked with a sequence number assigned by the destination  node, which enables the mobile nodes to distinguish stale  routes from new ones, thus avoiding the routing loops. The  overhead with this protocol is high and this limits the  number of nodes in the network. In order to reduce the  packet overhead, two types of packets are used here – full  dump and incremental packets. Full dump packets which  contain all available routing information are sent  infrequently. Incremental packets are used to relay only the  changes since the last full dump packet and are sent  frequently. Clusterhead Gateway Switch Routing  differs  from DSDV by the type of addressing and networking  scheme employed. A clusterhead node or station is selected  here using a cluster head selection algorithm to control a  group of ad hoc nodes. A Least Cluster Change (LCC)  clustering algorithm is executed each time when two cluster  heads come into contact or when a node moves out of  contact of all other cluster heads, instead of invoking the  clusterhead reselection algorithm. It modifies DSDV  approach by using a hierarchical clusterheadtogateway routing architecture to route traffic from source to  destination. Gateway nodes are those nodes that are within  the communication range of two or more cluster heads. A  packet sent by a source station is routed to its clusterhead  and then to the gateway to another clusterhead and so on  until the cluster head of the destination station is reached. It  is then directed to the destination station. Each node  maintains a cluster member table and a routing table to get  the details to reach the destination. The Wireless Routing  Protocol is designed to maintain routing information among  all nodes in the network. Four tables are maintained by all  nodes, namely – Distance table, Routing table, Linkcost  table and Message retransmission list (MRL) table. Through  the update messages that are sent between neighboring  nodes, the mobile nodes inform each other of the link  changes. It contains a list of updates such as the destination,  the distance to destination and the node before the  destination. The neighbors then update their distance table  entries and check for new possible paths, which are relayed  back to the original nodes so that their tables can be  updated. The nodes maintain connectivity by sending hello  messages at definite intervals of time. The new nodes that  send hello messages are updated into mobile node’s routing  table and the mobile node sends a copy of its routing  information to them. A brief comparison is shown in table I  [2].    TABLE   I    TABLEDRIVEN  PROTOCOL  COMPARISON    Parameters DSDV CGSR WRP  Routing philosophy Flat Hierarchical Flat  No. of required  tables Two Two Four  Use Sequence  Numbers Yes Yes Yes  Use hello packets Yes No Yes  Routing metric  (path) Shortest Shortest Shortest  Loopfree network Yes Yes Yes (takes  some time)    III.   DEMAND DRIVEN PROTOCOLS     A different approach in comparison to the table driven  routing is the source initiated demand driven protocols that  creates the route only when needed by the source node.  When a route is needed by a source node, it would initiate a  route discovery process within the network. Once a route is  discovered and established, it is maintained until it is  needed.  AdHoc OnDemand Distance Vector Routing  (AODV) is a variation of DSDV algorithm. As a reactive  protocol, the finding of route is based on a route discovery  cycle that includes a network search that is broadcasted and  a unicast reply containing the discovered paths. When a  node wants to establish a communication link, it does a  pathdiscovery process to locate the other node. If a path to  destination exists in the source node’s routing table, it will  use that existing route to send data packets. Otherwise to  start the route discovery, the source node broadcasts a route  request, RREQ packet with it’s and destination’s IP  addresses, Broadcast ID (or RREQ ID) and the sequence  numbers of source and destination nodes. The RREQ ID is a pernode counter that is incremented every time the node  initiates a new RREQ. This makes the RREQ ID together  with the source IP address quite unique and can be used to  identify a particular RREQ. When a node receives this  RREQ, it creates a reverse path to the node and the hop  count in the RREQ is incremented by one. If the current  node does not have an unexpired route to destination the  RREQ is broadcasted to its neighbors with incremented hop  count value, thus creating a flooding scenario. Once the  receiving node’s sequence number is greater than or equal  to the destination station’s sequence number as indicated in  the RREQ, it generates a route reply , RREP (reply message)   indicating the route. The node then unicasts the message to  its next hop towards source node. Thus the receiving nodes  set a backward pointer to the source and generate a RREP  unicast packet. As RREP is routed back to source,  intermediate nodes set up forward pointers in their routing  tables. The RREP packets contain the source and destination  IP addresses, destination’s sequence number etc. If the  destination itself is creating the RREP, the hop count is  made as zero. The reverse route created as RREQ is  forwarded and is used to channel the RREP back to the  source. AODV nodes store a route table which stores the  nexthop routing information with a designated lifetime for  destination nodes. If the routes are used, the lifetime is  extended. The route expires after the lifetime, if not used.  AODV favors the least congested route and uses hello  messages to maintain node connectivity.   Dynamic Source Routing (DSR)  also uses source based  routing rather than table based and it is source initiated  rather than hopbyhop. A node wishing to communicate  issues a Route Request to all its neighbors and each  neighbor in turn rebroadcasts this Request adding its own  address in the header of the packet. When a Request is  received by the destination node or by an intermediate node  in the path to destination, a Route Reply is sent back to the  sender along with addresses accumulated in the Request  header. Thus the entire route is maintained in the packet  header. DSR is not that scalable to large networks.   TemporallyOrdered Routing Algorithm (TORA)  is a  distributed and adaptive protocol that can operate in a  dynamic network. For a particular destination, it uses the  ‘height’ parameter to determine the direction of a link  between any two nodes.  Thus multiple routes are often  present for a given destination. For a node to start  communication, it broadcasts a Query to all its neighbors,  which is rebroadcast through the network until it reaches the  destination. This node would reply with an Update that  includes its height with respect to the destination, which is  sent back to the sender. Each node that receives the Update  sets its own height to one greater than that of the neighbor  that sent it, which results in a series of directed links from  sender to destination in the order of height values. Internet  MANET Encapsulation Protocol (IMEP) is normally run at  the layer below TORA so that some functionalities from  lower layers can be used by TORA [3][6].     IV. SIMULATION OF DEMANDDRIVEN PROTOCOLS     We did a network simulation of existing demand driven  protocols like DSR, TORA and AODV [3], [5][6] to study the performance and to analyze its behavior, under different  number of nodes and other changes in parameters, using  existing models. For DSR, the scenarios created could  compare for example, the throughput, total routing traffic,  dropped traffic etc. For TORA also, the scenarios compare  the throughput, total routing traffic and dropped traffic. For  AODV, its performance is first analyzed with default  parameters. It is then compared to a scenario where traffic is  decreased by tuning some parameters. Our main focus  would be on the above performance analysis. The mobility  aspects under two protocols – DSR and AODV would also  be investigated briefly. In DSR scenario, all nodes in the  network are configured to have mobility by configuring  trajectories. Every node runs DSR and multiple FTP or  Telnet sessions. In AODV also, all nodes in the network are  configured to have mobility by configuring trajectories.  Output comparison graphs would be discussed to analyze  the protocol behavior, under different circumstances.     A. Performance Comparison    As shown in figure 1, firstly a wireless server is  configured with DSR and 40 mobile nodes are configured as  work stations (that can generate application traffic) running  DSR. They are placed as 20 nodes on one side and  remaining 20 nodes on the other side. Later the same  exercise is done with 80 nodes, by placing 40 nodes each on  either side of the server. The simulation is done for 30  minutes (1800 sec).         Fig.1 The general mobile ad hoc network topology used for simulation.    The wireless nodes can communicate to each other within  a cloud or to the server. They can also communicate with  the wireless nodes in the other cloud. Figure 2 shows the  generated throughput of 40 and 80 node DSR networks that  run some applications like Telnet, Email or FTP sessions.  The mobile nodes are configured to eliminate all receivers  that are over 1500 meters away.       Fig.2 The throughput of adhoc network when using DSR with 40 nodes  and 80 nodes.    The graph shows an expected result that the throughput of  80 node DSR network is greater than the 40 node DSR network, reaching a peak of around 24,000 bits (during  1200 sec) compared to 12,000 bits (during 500 sec) for 40  nodes. Lack of scalability of DSR, in terms of functioning  well in bigger networks is evident from the performance  graphs as it is meant for low diameter ad hoc mobile  networks.      Fig.3 The amount of traffic dropped for adhoc network when using DSR  with 40 nodes and 80 nodes. Note the high drop for 80 nodes.    As the traffic gets higher for 80 nodes, the traffic dropped  also hits higher compared to 40 nodes, reaching a peak of  around 270 bits (during 1200 sec) as shown in figure 3. For  40 nodes DSR network, the dropped traffic is almost  negligible.      Fig.4 The routing packets sent (received is similar) for adhoc network  when using DSR with 40 nodes and 80 nodes.    The routing traffic sent and received, as expected would  be more for 80 nodes DSR network, reaching a peak of  around 3800 bits during 30 minutes. This happens because  the route request is flooded to all its neighbors (which in  turn broadcasts it) when a node wants to communicate. So  higher the number of nodes, higher the traffic generated.  Secondly, a wireless server is configured with TORA and  40 mobile nodes are configured as work stations running  TORA by placing 20 nodes on one side and remaining 20  nodes on the other side. Later the same exercise is done with  80 nodes, by placing 40 nodes each on either side of the  server. The simulation is done for 30 minutes (1800 sec).   Figure 5 shows the generated throughput of 40 and 80  node TORA networks that run some applications like  Telnet, Email or FTP sessions. The nodes are configured to  eliminate all receivers that are over 1500 meters away. In  contrast to DSR, TORA works better with higher number of nodes as it is adaptive and works well dynamically with 80  nodes and the throughput graph for 40 nodes and 80 nodes  TORA networks looks comparable.      Fig.5 The throughput of adhoc network when using TORA with 40 nodes  and 80 nodes.      Fig.6 The amount of traffic dropped for adhoc network when using TORA  with 40 nodes and 80 nodes. Note the high drop for 40 nodes.    As in figure 6, the traffic drop is negligible with 80 nodes  TORA network and 40 nodes network also gives marginally  low dropped traffic with a maximum of 13 bits. Generally  the drop in traffic looks better than DSR in comparison with  the scenarios of 40 and 80 nodes discussed before, where 80  nodes DSR shows few peaks of traffic drops. Figure 7  shows the routing packets sent and received using TORA.      Fig.7 The routing packets sent (received is similar) for adhoc network  when using TORA with 40 nodes and 80 nodes.    Thirdly, a wireless server is configured with AODV and  40 mobile nodes are configured as work stations running  AODV by placing 20 nodes on one side and remaining 20  nodes on the other side. This is done in the default mode.  Later the same exercise is done with 40 nodes, with reduced or light traffic. The simulation is done for 30 minutes (1800  sec). Figure 8 shows the generated throughput of 40 node  AODV network that runs some applications like Telnet,  Email or FTP sessions. It is configured to eliminate all  receivers that are over 1500 meters away. Parameters set for  AODV (to reduce routing traffic) are as follows: Route  Discovery Parameter: Gratuitous Reply – Enabled, Active  Route Timeout: 30 sec and WLAN data rate: 1Mbps.      Fig.8 The FTP upload and download time for adhoc network when using  AODV with 40 nodes. The default setting and Less Traffic (LT) setting is  used.    Figure 9 shows routing traffic sent and received when  using AODV in default and light traffic modes. Obviously,  the routing traffic curves are low in the case of light traffic  scenario where routing throughput is low.      Fig.9 The routing traffic sent (TS) and traffic received (TR) for adhoc  network when using AODV with 40 nodes. The default setting and Less  Traffic (LT) setting is used.      Fig.10 The Throughput for adhoc network when using DSR, TORA and  AODV (default and low traffic (LT)) with 40 nodes. Figure 10 shows the throughput comparison of all 3  protocols –DSR, TORA and AODV. AODV with gratuitous  reply enabled (light traffic/LT option) and DSR shows  comparable throughput. Default AODV shows a greater  throughput and TORA is in between.    B. Mobility Comparison  Figure 11 shows the topology used for the study. Here 20  mobile nodes (with raw traffic generator over IP or  application traffic) are made mobile by configuring  trajectories that make them move left or right in the upward  or downward direction.      Fig.11 The network topology used in mobility analysis. A wireless server  was surrounded by a cloud of around 20 mobile nodes which had  trajectories defined. Only 12 nodes are shown in the diagram.    Figure 12 shows the traffic in a 20 node DSR network.  All nodes in the network by configuring trajectories are set  to have mobility and every node runs some applications like  HTTP, Telnet or FTP sessions.  Nodes are configured to  eliminate all receivers that are over 500 meters away. Later  it is changed to 1000 meters elimination. Since the network  is mobile, the refresh interval is set to 10 seconds. The total  traffic sent peaks to 40,000 – 45,000 bits as shown in the  graph. WLAN data rate was 1 Mbps.    Fig.12 The traffic pattern for adhoc network when using DSR with  mobility on multiple nodes. The sending and receiving patterns are similar.    Figure 13 shows the traffic drop when the receivers are  eliminated over 500 meters away and 1000 meters away.  Clearly, 500 meter elimination shows greater drop in traffic.  Also the traffic dropped with DSR network averages around  130 packets for 500 meter elimination as shown in figure 12  for the topology and parameters chosen. Figure 14 shows  the traffic in a 20 node AODV network with mobility by  configuring trajectories. It is configured to eliminate all receivers that are over 1500 meters away. Since the network  is mobile, the refresh interval is set to 5 seconds.      Fig.13 The DSR packets dropped for 2 cases (500m elimination & 1000m  elimination) when using DSR with mobility on multiple nodes.      Fig.14 The traffic pattern for adhoc network when using AODV with  mobility on multiple nodes.    Figure 15 shows that the traffic dropped is comparatively  low in AODV with 500 meter and 1000 meter receiver  elimination.    Fig.15 The AODV packets dropped for 2 cases (500m elimination &  1000m elimination) when using AODV with mobility on multiple nodes.    V. SUMMARY ON DEMAND DRIVEN PROTOCOL FEATURES AND  PERFORMANCE    A comparison summary on the three simulated protocols  can be given as follows. The table 2 shows [2] the details in  a nutshell. DSR is meant for wireless ad hoc networks  where the mobile nodes move with moderate speed in  comparison to packet transmission latency [7]. As DSR  packets need to contain full routing information, the memory overhead is more compared to AODV. But it does  not make use of periodic router advertisement which saves  some bandwidth and power consumption. A direct result of  this is that router advertisement overhead would be nil and  topology changes are eliminated. As DSR allows multiple  routes to the destination, in the event of a link failure, the  other valid routes can be checked and this can prevent route  reconstruction, hastening the route recovery. If multiple  routes are not available, route discovery should be done to  find a route. As DSR assumes small network diameter, it is  not scalable to large networks. The requirement to place the  route in both route replies and data packets increases the  control overhead much more than in AODV.    TABLE   II    DEMANDDRIVEN  PROTOCOL  COMPARISON    Parameters AODV DSR TORA  Routing philosophy Flat Flat Flat  Routes stored in Route Table Route Cache Route Table  Multicast option Yes No No  Multiple routes No Yes Yes  Routing metric  (path) Most Fresh  and Shortest  Shortest  Shortest  Loopfree network Yes Yes Yes   Route re configuration  approach Delete route  – and notify  source Delete route  – and notify  source Link reversal  – and route  repair     AODV overhead is much lesser in comparison to DSR as  the route replies need to carry only the destination IP  address and sequence number. This also reduces the  memory overhead in comparison to DSR. AODV also uses  a route discovery mechanism that is similar to DSR. A big  advantage of AODV is its support for multicast  communication. But on the negative side it needs symmetric  links between nodes and cannot make use of asymmetric  links. TORA is a linkreversal algorithm that is suitable for  densely populated network with large number of nodes. It  creates directed acyclic graphs (DAG) to help route creation  and supports multiple routes for single sourcedestination  pair. Multiple routes reduce route reconstruction overheads.  This protocol supports multicast in conjunction with  Lightweight Adaptive Multicast Algorithm (LAM) by  working as an underlying protocol [8]. TORA needs  synchronized clocks for its operation and if the external  time source fails, the protocol would fail. Even route  rebuilding can incur lengthy delays because of  synchronization related oscillations [2], [4][6].    VI. RELATED WORK   "
145,A Real-Time Database QoS-aware Service Selection Protocol for MANET.txt,"The real-time database service selection depends typically to the system
stability in order to handle the time-constrained transactions within their
deadline. However, applying the real-time database system in the mobile ad hoc
networks requires considering the mobile nodes limited capacities. In this
paper, we propose cross-layer service selection which combines performance
metrics measured in the real-time database system to those used by the routing
protocol in order to make the best selection decision. It ensures both
timeliness and energy efficiency by avoiding low-power and busy service
provider node. A multicast packet is used in order to reduce the transmission
cost and network load when sending the same packet to multiple service
providers. In this paper, we evaluate the performance of our proposed protocol.
Simulation results, using the Network Simulator NS2, improve that the protocol
decreases the deadline miss ratio of packets, increases the service
availability and reduces the service response time.","  With the rapid growth of the realtime constrained information services used in a mobile database  environment, there is an increasing demand to suppo rt and guarantee the quality of service (QoS)  such as completing the transactions within their de adline. The mobile ad hoc network, MANET,  is of interest because there is no prior investment  for fixed infrastructures, it can be easily  deployed in a short time and end users can access a nd manipulate data anytime and anywhere.  Each mobile node acts as a host autonomous end syst em (requestor or source data node) and as a  router (intermediate nodes) for others in the netwo rk. The mobile nodes are classified by their  capacities into two groups: small mobile host SMH, requestor node, which has a reduced  memory, storage, power and computing capabilities a nd large mobile host LMH, source data  node, equipped with more storage, power and communi cation and computing facilities than the  SMH. The databases are stored at source data, LMH, and accessed by requestor nodes, SMH. The  key challenging in the mobile networks is providing  the time constrained services with node  limited resources. For example, the military applic ations have to respect time constraint in order  to update positions of wounded soldiers, get enemy map position or find medical assistance. If the  wounded warriors cannot reach a medical assistance center in time, the information might  become useless. For another example, the informatio n about source data overload that is caused  by important number of user transactions sent to it  should also reach a mobile requestor heading   towards this direction timely. If the requestor rec eives such information early enough, it will be  able to react accordingly to avoid the overloaded s ource data node. International Journal of Database Management System s ( IJDMS ) Vol.3, No.4, November 2011  102  Currently, most MANET research has focused on routi ng and connectivity issues in order to cope  with the dynamism of such networks. Just solving th e problem of connectivity is not sufficient.  These applications often need times to utilize reso urces or services that are present on other  mobile nodes. Often nodes cannot communicate direct ly with each other. MANET’s basic role is  to allow mobile users to exchange data and use each  other’s database services. So there are needs  for data communication protocol and database servic e selection protocol without any central  intelligence in the network. Otherwise, the node li fetime is usually affected by the unpredictable  user transactions to the source data node (service provider). This constraint may lead to overload  and so to deplete the source data node energy which  may affect the service availability. With the  frequent disconnections due to the energy depletion , the transactions may miss their deadlines  whereas there are other same service providers avai lable in the vicinity. Service selection of the  nearest database service provider is insufficient. Other criteria for database service selection  should be highlighted. It must guarantee a minimum of QoS essential for the execution of  transactions with respect to the deadline. However,  respecting the deadline cannot be insured nor  guaranteed if the energy resource is exhausted, or with a system overloaded by unpredictable  transactions from other mobile nodes. There has bee n a significant research interest towards  semantic, context and/ or QoSaware service selecti on. We pay particular attention to QoSaware  service selection as it matches with our research i nterests. We focus especially on crosslayer  service selection a special class of efficient serv ice selection approaches for MANET. The service  selection algorithm combines QoS parameters accordi ng to different layers. Crosslayer service  selection exploits the capability of integrating se rvice information along with routing information  (in the same message), thus the service selection p ackets at the application layer are avoided and  energy is saved. To find a suitable database servic e in MANET is a challenging problem and is  relative to the appropriate QoS metrics choice and their relevance.     In this paper, we aim to apply the crosslayer serv ice selection for selecting an available realtime  database system, RTDBS. The workload in these syste ms is unpredictable. They may become  quickly overloaded and unstable leading to the decr ease of the required quality of service (QoS)  in terms of executing transactions within their dea dlines. Therefore, we pay particular attention to  integrate the performance metrics measured in RTDBS  to those used by routing protocol in order  to make the best selection decision, under the dead line constraint. How to guarantee the  transaction without exceeding its realtime constra ints or wasting resources? What are the  appropriate metrics combining timeliness on the one  hand and on the other hand choosing the  suitable service without depleting resources? We pr opose RealTime Database QoSaware  Service Selection protocol (RTDQS). In RTDQS, the d atabase service selection is done based on  both intermediate nodes and database service provid er QoS metrics. Then, we aim to evaluate  crosslayer service selection proposed protocol and  its ability to reduce energy consumption,  reduce service response time and guarantee timeline ss.    The rest of the paper is organized as follows: in t he second section, we present the related work to  the service selection protocols. Then, we present t he QoS guarantees in a RTDBS in the third  section. In the next section, we describe the propo sed RealTime Database QoSaware Service  Selection protocol (RTDQS). Detailed analysis of sy stem performance is performed in the  sections V and VI.    2.  RELATED WORK   "
198,A Faster Routing Scheme for Stationary Wireless Sensor Networks - A Hybrid Approach.txt,"A wireless sensor network consists of light-weight, low power, small size
sensor nodes. Routing in wireless sensor networks is a demanding task. This
demand has led to a number of routing protocols which efficiently utilize the
limited resources available at the sensor nodes. Most of these protocols are
either based on single hop routing or multi hop routing and typically find the
minimum energy path without addressing other issues such as time delay in
delivering a packet, load balancing, and redundancy of data. Response time is
very critical in environment monitoring sensor networks where typically the
sensors are stationary and transmit data to a base station or a sink node. In
this paper a faster load balancing routing protocol based on location with a
hybrid approach is proposed.","   A wireless sensor network (WSN) consists of spatially distributed autonomous sensors  to cooperatively monitor physical or environmental conditions, such as temperature, sound,  vibration, pressure, motion or pollutants. The emergence of wireless sensor networks has  enabled new classes of applications that benefit a large number of fields. In [1] Joseph Polastre  et al have identified the need for using WSN for habitat and environmental monitoring. The  challenges in the hierarchy of: detecting the relevant quantities, monitoring and collecting the  data, assessing and evaluating the information, formulating meaningful user displays, and  performing decisionmaking and alarm functions are enormous as suggested by F.L.Lewis [2].  Unique characteristics of a WSN include limited power, ability to withstand harsh  environmental conditions, ability to cope with node failures, mobility of nodes, dynamic  network topology, communication failures, heterogeneity of nodes, large scale of deployment  and unattended operation.      Many to one communication paradigm is widely used in regard to sensor networks since  sensor nodes send their data to a common sink for processing. This manytoone paradigm also  results in nonuniform energy drainage in the network. Sensor networks can be divided in two  classes as event driven and continuous dissemination networks according to the periodicity of 	 	           	   !   "" #$ $    2 communication. In eventdriven networks, data is sent whenever an event occurs. In continuous  dissemination networks, every node periodically sends data to the sink. Routing protocols are  usually implemented to support one class of network in order to save energy.       The challenges of WSN have been studied by Yao K [3]. The key challenge in wireless  sensor networks is maximizing network lifetime. The appropriate communication mode will  significantly reduce energy consumption of communication and prolong networks lifetime.  Therefore, many researchers are currently focusing on the design of poweraware protocols for  wireless sensor networks. Regardless of communication protocol, researchers must choose  communication mode: single hop or multi hop. Using a single hop communication mode, each  sensor sends its data directly to the base station. In multi hop mode, each node sends its data  destined ultimately for the base station through intermediate nodes. Now multi hop  communication enjoys more researches’ favor. In [13], Bhardwaj et al. have studied a multi hop  sensor network; they minimized the energy spent on sending a packet by using optimum number  of relay nodes. Bandyopadhyay et al. [14] have studied a multi hop clustered wireless sensor  network. [8,11] give a comparative study of multihop routing protocols. The reason many  researches choose multi hop mode lies in that it is expected to consume less power than the  single hop communication, but that is not always correct. In most wireless sensor networks  nodes are static, using multi hop mode, nodes closest to the base station have a highest load of  relaying packets as compared to other nodes, just as the nodes located farthest away from the  base station have the highest energy burden due to long range communication in single hop  mode. These key nodes will quickly drain the battery and result in invalidation of the whole  system, although other nodes have enough energy. It is evident from [20] that multi hop  communication is not always the best mode.     Monitoring the environment is one of the main applications of wireless sensor networks.  Given that these networks are densely populated and that local variations in the environmental  variables are small, a large amount of redundant data is generated by sensor nodes. The time  delay in receiving information in the base station end is very critical to the better functioning of  the network. When an event occurs all the sensors in the region will sense and start transmission  of data. The base station will receive the same data from a number of sensors. Also transmission  energy is greater than the processing energy. Thus energy is wasted to transmit redundant  information to the base station. So there is a trade off between time and reliability and in WSN  reliability can be compromised as redundancy.       Most of the protocols suggested are based on energy conservation. The redundancy of  information from the sensors is not taken into consideration. Again most of the protocols  assume multi hop paths. Single hop networks also proved to be energy efficient. Thus there is a  need to approach the problem in a balanced way.  This paper argues the energy savings due to  single hop and presents an efficient algorithm to use the hybrid structure.      2. RELATED WORK  "
319,A future mobile packet core network based on ip-in-ip protocol.txt,"The current Evolved Packet Core (EPC) 4th generation (4G) mobile network
architecture features complicated control plane protocols and requires
expensive equipment. Data delivery in the mobile packet core is performed based
on a centralized mobility anchor between eNode B (eNB) elements and the network
gateways. The mobility anchor is performed based on General Packet Radio
Service tunnelling protocol (GTP), which has numerous drawbacks, including high
tunnelling overhead and suboptimal routing between mobile devices on the same
network. To address these challenges, here we describe new mobile core
architecture for future mobile networks. The proposed scheme is based on IP
encapsulated within IP (IP-in-IP) for mobility management and data delivery. In
this scheme, the core network functions via layer 3 switching (L3S), and data
delivery is implemented based on IP-in-IP routing, thus eliminating the GTP
tunnelling protocol. For handover between eNB elements located near to one
another, we propose the creation of a tunnel that maintains data delivery to
mobile devices until the new eNB element updates the route with the gateway,
which prevents data packet loss during handover. For this, we propose Generic
Routing Encapsulation (GRE) tunnelling protocol. We describe the results of
numerical analyses and simulation results showing that the proposed network
core architecture provides superior performance compared with the current 4G
architecture in terms of handover delay, tunnelling overhead and total
transmission delay.","  In recent years, the marked increase in the use of smart phones and other mobile devices has led  to huge growth in wireless mobile communication dat a traffic. This trend appears likely to  continue, and Cisco forecasts that the volume of mo bile data traffic will increase eightfold  between 2015 and 2020 [1]. This growth in mobile da ta traffic places increasing demands on  wireless communication systems, and represents a ma jor challenge for cellular providers in terms  of upgrading their core networks to accommodate fut ure network requirements and keeping up  with increasing customer demand.    One of the greatest challenges for future mobile co mmunication networks is how to design and  build 5th generation (5G) mobile networks. The need  for new network architecture is essential to  support growth in demand for broadband services of various kinds delivered over the networks,  and to support the Internet of Things (IoT) service s and applications [2].    Many approaches have been proposed to address the g rowth in data traffic on mobile networks,  including devicetodevice communication and radio resource management. However, these  efforts have focused mainly on increasing the capac ity of wireless radio links. The future mobile  network consists of two main parts: a radio link an d a nonradio mobile core network. Effective  design of both the radio link and the mobile core i s required to meet the requirements of the  future mobile network [3].   International Journal of Computer Networks & Commun ications (IJCNC) Vol.10, No.5, September 2018  84   The current 4th generation (4G) core network termed  the Evolved Packet Core (EPC) is based on  the General Packet Radio Service tunnelling protoco l (GTP) [4]. With EPC, eNodeB (eNB)  elements establish GTP tunnels with serving gateway s (SGWs) and Packet Data Network (PDN)  gateways (PGWs) to create centralized mobility anch ors for data packet forwarding. However,  the 4G network has a number of limitations. First, there are load balance and latency issues.  Growth in data traffic requires a reduction in the transmission and connection delays. Simplifying  the mobile core and reducing the number of identifi cations can make mobile core networks  simpler and more efficient, and hence more costeff ective. The second problem is suboptimal  routing. With current 4G networks, the uplink and d ownlink data packets are routed via mobility  anchors, which often results in the suboptimal path s. For example, a data instead of taking the  shortest path, the packet is routed via a PGW and a n SGW. The Third is the GTP tunnelling  protocol overhead. GTP protocol adds three headers to the data payload totalling 36 bytes; i.e.,  GTP,     User Datagram Protocol (UDP) and IP. In addition, t he use of GTP protocol and mobility anchors  means that the full functionality of packet switchi ng cannot be exploited, the result being that  circuit switching is favoured over packet switching . Fourth is the required capital expenditure.  The EPC network is simply not costeffective, due t o the huge number of routers that are required  to support the core network.    2.  LITERATURE REVIEW     A variety of schemes have been proposed to overcome  these issues. The Distributed Mobility  Management (DMM) scheme proposed by the Internet En gineering Task Force [5] provides  mobility solutions with localized mobility anchors that are distributed within the network, in  combination with centralized anchors, where the sys tem is arranged in a hierarchical model. This  was proposed to optimize routing for local data tra ffic, and reduces delays due to the shorter  distances to local servers [6]. A mobility data off loading approach using femtocells has been  proposed to enhance the 4G network [7]. In this sch eme, data traffic is forward to the mobile  device without using the mobile core network, which  reduces the volume of internet traffic and  unwanted data flow into the mobile core network.    Another approach to distributing mobility in 4G net works is the Ultra Flat Architecture (UFA).  The key element of UFA is to decrease the number of  the network nodes to one (i.e., a single base  station), based on the distribution of user and con trol plane roles in the node. UFA provides  improved performance and seamless handover [8]. In [9] and [10], the authors proposed a new  mobile network architecture for 5G networks termed 5GTPC. This architecture was based on the  Transparent Interconnection of Lots of Links (TRILL ) protocol, and was designed to use link  layer routing bridges rather than GTP protocol.    3.  METHODOLOGY   "
334,Zest: REST over ZeroMQ.txt,"In this paper, we introduce Zest (REST over ZeroMQ), a middleware technology
in support of an Internet of Things (IoT). Our work is influenced by the
Constrained Application Protocol (CoAP) but emphasises systems that can support
fine-grained access control to both resources and audit information, and can
provide features such as asynchronous communication patterns between nodes. We
achieve this by using a hybrid approach that combines a RESTful architecture
with a variant of a publisher/subscriber topology that has enhanced routing
support. The primary motivation for Zest is to provide inter-component
communications in the Databox, but it is applicable in other contexts where
tight control needs to be maintained over permitted communication patterns.","The goal behind Zest is to utilise middleware to improve on the features offered by the Constrained Application Protocol (CoAP) [1], [2] by providing: Encryption as standard Access control through Macaroons Support for auditing communication across nodes Support for asynchronous communication between nodes We chose to build our solution using ZeroMQ1because of its ﬂexibility to support different topologies such as brokerless communication and for its simple abstraction over traditional TCP sockets. Other reasons we adopted ZeroMQ included its support for secure connections based on ellipticcurve cryptography and that it is well supported across a variety of platforms and programming languages. Zest forms the core protocol within the Databox project [3], which we envisage being instantiated in the formfactor of a settop box or similar. All components are encapsulated as Docker contain ers.2Databox hosts thirdparty computations as Apps , while external devices such as sensors interface to the Databox via Drivers responsible for interacting with the external device through reads and writes to an associated store , a light weight timeseries database. Zest’s requirements therefore are to support this highly controlled communication model, in a relatively resourceconstrained environment, where operations must be logged for subsequent audit and where data transfers should be authenticated and protected in ﬂight. The Databox communication model not only involves encryption across communication channels but also requires support for ﬁne grained access to resources. We therefore developed the Zest 1http://zeromq.org/ 2https://docker.com/ Fig. 1. Databox architecture. protocol to support these features as standard, including sup port for audit information to be pushed to any App permitted to receive it. Data is isolated within Databox by enforcing that each Driver may write only to its own Store, and Apps must request permission on installation to be able to access a Store. If the user grants permission, the App receives a set of access tokens (formatted as Macaroons [4]) which it can subsequently present to the Store to verify its access is allowed. Data may only be communicated to a thirdparty service through an Export Driver , subject to the user granting appropriate permission when installing the App. Available Stores are registered in a HyperCat catalogue on installation, so they can be discovered by other Apps.3Each store provides aRESTful API supporting JSON, text and binary data across the Zest protocol. Underlying storage is implemented using the Irmin [5] system using a gitstructured backend. This supports a key design goal of Databox, to provide accountability of data stored and accessed, by using the commit history of the gitbased storage system to provide a detailed account of all mutations to data. In the remainder of this paper we discuss related work (§II), detail the Zest protocol (§III) and architecture (§IV), and conclude (§V). II. R ELATED WORK "
287,Joint Traffic-Aware UAV Placement and Predictive Routing for Aerial Networks.txt,"Aerial networks, composed of Unmanned Aerial Vehicles (UAVs) acting as Wi-Fi
access points or cellular base stations, are emerging as an interesting
solution to provide on-demand wireless connectivity to users, when there is no
network infrastructure available, or to enhance the network capacity. This
article proposes a traffic-aware topology control solution for aerial networks
that holistically combines the placement of UAVs with a predictive and
centralized routing protocol. The synergy created by the combination of the UAV
placement and routing solutions allows the aerial network to seamlessly update
its topology according to the users' traffic demand, whilst minimizing the
disruption caused by the movement of the UAVs. As a result, the Quality of
Service (QoS) provided to the users is improved. The components of the proposed
solution are described and evaluated individually in this article by means of
simulation and an experimental testbed. The results show that all the
components improve the QoS provided to the users when compared to the
corresponding baseline solutions.","In recent years, the need for broadband wireless connectivity has been steadily increasing. From online video streaming to remote vehicle piloting, new applications require reliable wireless links with high throughput and low delay. Additionally, some scenarios pose additional challenges when planning the network. In emergency scenarios, such as for est res and earthquakes, groups of rstresponders are distributed throughout a large area and need to communicate among themselves and with a remote command center [1]. In addition to traditional voice and text services, these communications may also include broadband services requiring the exchange of multimedia content. In some circumstances, ex isting networks might not be able to provide reliable Corresponding author at INESC TEC and Faculdade de Engenharia, Universidade do Porto, Campus da FEUP, Rua Dr. Roberto Frias, 4200465 Porto, Portugal Email addresses: eduardo.n.almeida@inesctec.pt (Eduardo Nuno Almeida), andre.f.coelho@inesctec.pt (Andr e Coelho), jruela@inesctec.pt (Jos e Ruela), rui.l.campos@inesctec.pt (Rui Campos), mricardo@inesctec.pt (Manuel Ricardo)and broadband wireless connectivity due to failures of the base stations or lack thereof. Other scenarios that exacerbate the challenges of network planning are Temporary Crowded Events (TCEs), such as music festivals and outdoor festivities [2]. TCEs are characterized by a high density of users that are concentrated in predened areas for short pe riods of time and generate signicant and variable trac, which is in uenced by the event dynamics. In order to satisfy the Quality of Service (QoS) requirements in these scenarios, novel network ar chitectures are being considered. An interesting so lution relies on the use of Unmanned Aerial Vehicles (UAVs) acting as aerial WiFi Access Points (APs) or cellular base stations, forming aerial wireless net works [3, 4]. Due to the mobility of the UAVs and the ability to position them in the 3D space, aerial networks can quickly adapt to the dynamic condi tions of the environment and users' trac demand. Thus, aerial networks are excellent solutions to pro vide ondemand wireless connectivity when there is no network infrastructure available or to enhance the capacity of existing networks with the deploy ment of temporary additional aerial base stations. Preprint submitted to Elsevier April 17, 2020arXiv:2004.07371v1  [cs.NI]  15 Apr 2020In [2] we proposed an aerial network architecture named TracAware MultiTier Flying Net work (TMFN), which is illustrated in Fig. 1. The TMFN is composed of Flying Mesh Access Points (FMAPs) and Gateway (GW) UAVs, which are or ganized in a twotier multihop architecture. The access tier consists of FMAPs, which are rotary wing UAVs acting as aerial WiFi APs that form small cells to serve the users on the ground. The backhaul tier is composed of Gateway UAVs that forward trac from the FMAPs to the Internet. The TMFN can be dynamically repositioned and recongured according to the users' trac demand, in order to improve the overall provided QoS. To control the TMFN topology, we proposed a Network Planning (NetPlan) algorithm in [2]. The NetPlan algorithm determines the horizontal positions and WiFi cell ranges of the hovering FMAPs in order to improve the TMFN's aggre gate throughput. To this end, the NetPlan algo rithm positions the FMAPs closer to the users gen erating more trac with shorter WiFi cells, with the remaining FMAPs being distributed through out the coverage area. As a followup of this work, we proposed the RedeFINE routing solution [5, 6]. RedeFINE is a predictive centralized rout ing protocol for highcapacity multihop aerial net works, which is able to determine, in advance, the forwarding tables of the FMAPs and the time in stants they shall be updated in order to minimize communications disruptions. By assuming that the future trajectories of the FMAPs are known, Re deFINE is able to predict the time instants when each FMAP should update its forwarding table so that the overall network throughput is maximized. This is achieved by eliminating the process of neigh bor discovery and the time wasted in updating the forwarding table in traditional routing solutions, where nodes typically recover from link failures af ter they occur and are detected. Finally, we pro posed a gateway UAV placement (GWP) al gorithm [7]. The GWP algorithm takes advantage of the knowledge of the FMAPs' future positions and oered trac to determine the position of the gateway UAVs in order to enable communications paths with high capacity. Although the NetPlan, the RedeFINE and the GWP solutions were de veloped independently, they were designed to be used simultaneously. To the best of our knowledge, there are no solutions combining the UAV place ment, routing and gateway placement problems in a single solution for aerial networks. Figure 1: TracAware MultiTier Flying Network (TMFN) providing alwayson broadband Internet connectivity to the users attending a music festival. In this article, we propose a novel solution re sulting from the holistic combination of the Net Plan algorithm [2], the RedeFINE routing solution [5], including an inter ow interference routing met ric [6], and the GWP algorithm [7] applied to the TMFN. The synergy created by the integration of the three components allows the TMFN to improve the QoS provided to the users whilst minimizing the communications disruption within the TMFN's backhaul tier. The proposed solution determines the updated TMFN topology periodically with each update cycle having the following sequence of op erations. First, the NetPlan algorithm determines the updated positions and WiFi cell ranges of the FMAPs for the following cycle based on the users' positions and their oered trac. Then, the Rede FINE routing solution determines the optimal for warding tables for the FMAPs and the time instants they shall be updated, considering their future tra jectories calculated through the initial and nal po sitions of the FMAPs. Finally, the GWP algorithm determines the optimal position of the GWs con sidering the FMAPs' future positions and oered trac. Although the three components were de signed to be used simultaneously, they are evalu ated individually using the ns3 simulator [8]. This allows the evaluation of the corresponding compo nent without the interference from the remaining ones. The NetPlan algorithm is also evaluated in an experimental testbed. In this process, we evaluate the airtoground and groundtoair channel prop agation models in the testbed for UAVs hovering at low altitudes in an openair environment. This allows the verication of the theoretical models pro posed in the literature [9]. Moreover, using the 2experimental channel models, instead of the the oretical ones, in the ns3 simulations allows a more accurate reproduction of the testbed conditions. The contributions of this article are threefold: A novel solution resulting from the holistic combination of the NetPlan, RedeFINE and GWP solutions for aerial networks, which im proves the network performance and minimizes the communications disruptions; Evaluation of the NetPlan algorithm in an ex perimental testbed; Experimental evaluation of the airtoground and groundtoair channel propagation models for UAVs hovering at low altitudes in an open air environment. The rest of this article is organized as follows. Section 2 discusses the related work. Section 3 presents the TMFN network architecture and the holistic solution proposed in this article. Section 4 explains the NetPlan algorithm. Section 5 contains the evaluation of the NetPlan algorithm. Section 6 describes the RedeFINE routing protocol. Section 7 contains the evaluation of RedeFINE. Section 8 presents the GWP algorithm. Section 9 discusses the evaluation of the GWP algorithm. Section 10 draws the conclusions and future work. 2. Related Work "
438,Performance-Driven Internet Path Selection.txt,"Internet routing can often be sub-optimal, with the chosen routes providing
worse performance than other available policy-compliant routes. This stems from
the lack of visibility into route performance at the network layer. While this
is an old problem, we argue that recent advances in programmable hardware
finally open up the possibility of performance-aware routing in a deployable,
BGP-compatible manner. We introduce ROUTESCOUT, a hybrid hardware/software
system supporting performance-based routing at ISP scale. In the data plane,
ROUTESCOUT leverages P4-enabled hardware to monitor performance across
policy-compliant route choices for each destination, at line-rate and with a
small memory footprint. ROUTESCOUT's control plane then asynchronously pulls
aggregated performance metrics to synthesize a performance-aware forwarding
policy. We show that ROUTESCOUT can monitor performance across most of an ISP's
traffic, using only 4 MB of memory. Further, its control can flexibly satisfy a
variety of operator objectives, with sub-second operating times.","Internet routing uses costdriven policies to select onein terdomain path per destination along which to direct trafﬁc. To select one path amongst multiple policycompliant ones, the Internet’s Border Gateway Protocol (BGP) uses partic ularly crude criteria rather than dynamically optimizing for performance. For instance, BGP will favor paths crossing fewer networks or paths crossing networks whose identiﬁers are smaller.1As a result, BGP selects routes that are often suboptimal in terms of throughput, latency, and reliability. This problem is far from new and the suboptimality of Internet routing is longestablished [54, 59, 60]. Yet, despite several strong attempts [8 –11,54,62], few practical progresses have been made. The problem is that enabling performance aware routing is particularly challenging requiring: scalable monitoring of path performance, handling path dynamics, stability and correctness of routing, and insurmountable resis tance to any approach incompatible with BGP. Despite the problem’s difﬁculty and its long history, we posit its time to revisit this problem, for three reasons. First, Internet application requirements have evolved, with a sharper focus on reliably high network performance. For hy perscale Web services with numerous wellconnected points ofpresence across the globe, BGP is, in fact, good enough 1One of BGP tiebreaking criteria is indeed to prefer routes announced by the router with the smallest IP address [51].most of the time [12]. However, even in these bestcase en vironments, the beneﬁts of reducing tail latency and perfor mance variability in response to transient congestion are valu able enough for providers like Google and Facebook to invest in performanceaware routing [55, 65]. Google’s Espresso showed that being able to dynamically reroute around tran sient congestion improved mean time between rebuffers in their video service by 35–170% [65]. Espresso explicitly pins these gains on being able to dynamically respond to perfor mance variability across paths (rather than just averagecase improvement from an onetime evaluation), thus underscor ing the need for making path decisions based on continuous assessments of the changing performance of paths. Beyond Web services, other applications are even more demanding: in gaming, even small latency overheads can put players at a disadvantage [27]. The importance of tail latency as opposed to mean latency is also demonstrated on CDN’s efforts to improve latency of the worstperforming clients [19]. Thus, if performanceaware routing were practical, the beneﬁts would justify signiﬁcant design effort. Second, the available paths are increasingly diverse, due to increased peering and the establishment of Internet Exchange Points (IXPs), which simply did not exist at the time of BGP’s ﬁrst design iteration (1989). Further, if plans for satellite based global Internet connectivity [18, 58] come to fruition, the performance gap across different paths will also increase. Two teams of researchers have separately argued in recent position papers [14, 43] that these satellite systems exhibit continuous changes in both the performance and availability of routes, and thus, will pose challenges to the performance oblivious and slowtoconverge BGP routing. Third, the recent development of programmable switches that allow linerate, perpacket data plane operations enables new design primitives. These heretofore unavailable primi tives, as we shall show, drastically improve our ability to both evaluate and control multiple candidate routes. Motivated by the above factors, we present ROUTE SCOUT , a novel softwarehardware codesign for performanceaware routing. ROUTE SCOUT ’s data plane estimates loss and delay along different policycompliant nexthop routes for differ ent destinations. It leverages probabilistic data structures in programmable switches to aggregate delay and loss measure ments on a per destinationnexthop granularity. This indata plane aggregation eliminates the necessity of mirroring trafﬁc to more powerful general purpose hardware, thus alleviating: (a) bandwidth and compute overheads; and (b) deterioration in monitoring capabilities when they are most needed, under congestion. Past methods (§2) are incapable of producing 1arXiv:2001.07817v2  [cs.NI]  18 Nov 2020such accurate, highcoverage, realtime, and lowoverhead performance measurements for multiple candidate nexthops for a large number of destinations. The succinct measurements allow ROUTE SCOUT ’s con trol plane to evaluate multiple policycompliant candidate paths by measuring their performance systematically for small slices of live trafﬁc. ROUTE SCOUT then encodes the best path choices in the data plane using a small memory foot print. ROUTE SCOUT enforces those choices gradually, while continually monitoring performance to avoid selfinduced congestion and, therefore, oscillations [29]. While ROUTE SCOUT could be used by any Autonomous System (AS), for tractability of control, we trim the problem’s scope: we take the perspective of a stub AS which offers no transit services to other ASes. This eliminates the risk of con ﬂicting decisionmaking leading to transient loops and insta bility. We humbly suggest that this “relaxation” still leads to a highly nontrivial and useful setting: stubs comprise 85% of all ASes;2the majority of stubs are multihomed and virtually all Internet trafﬁc and originates from some stub. In addition, despite sitting at the edge of the Internet, stubs often know several paths to reach each destination: our measurements on CAIDA ASlevel topologies [2] reveal that the majority of them (55%) can use at least two equallypreferred paths for at least 80% of the destinations.3Stubs also tend to connect with their neighbors via redundant links, further increasing path diversity [46]. Finally, while ROUTE SCOUT can only control paths from the stub, not towards it, the resulting reductions in roundtrip time, and being able to avoid congestion/failures at least in one direction, are still valuable improvements. ROUTE SCOUT is carefully designed to run on available programmable switches, respecting constraints on memory, operations per packet, memory accesses per packet, and con straints on accesses to memory blocks across pipeline stages. It requires no coordination across ASes and works over un modiﬁed BGP. Within an AS, it yields beneﬁts starting with only one programmable switch deployed at the edge. Our main contributions are the following: •ROUTE SCOUT , a system capable of rerouting trafﬁc to test the performance of alternative routes to each destination preﬁx, in a controlled and automated manner. •Methods to compute delay and loss rates across different paths that are accurate and effective, while respecting the constraints of dataplane hardware. •Efﬁcient interconnection between the control and data plane that allows: (a) fast, ﬁnegrained, and asynchronous changes in the forwarding and monitoring policy; (b) fast, ﬁne grained, and lowbandwidth retrieval of statistics. •An implementation of ROUTE SCOUT on a Barefoot Toﬁno switch [5], with an evaluation of its control and dataplane. 2A likely low estimate, computed from CAIDA’s ASlevel topology [2]. 3For each stub we calculated the number of BGPequivalent paths for 1000 randomly selected destination preﬁxes, following [28].2 Motivation Performanceaware routing is an old problem [8,10,54,59,60], with several known solutions of varying ambition and com plexity. Early work [31] narrowly targeted multihomed end users with perfect visibility over their performance, cost being their ﬁrst priority, and direct links the only possible bottleneck. TeXCP [40] and MATE [24] focused on intradomain rout ing, splitting trafﬁc across already setup tunnels. We would instead like to tackle the problem from the perspective of an AS picking routes to external destinations, with no endhost control, and only observing its own trafﬁc. In this setting, we discuss several alternatives for monitoring path performance, whose limitations make the case for R OUTE SCOUT . Active probing: One can actively probe routes [21, 35]. While this approach can be effective in the intradomain set ting, where recent work [34,42] used specially crafted probes to monitor performance, it is insufﬁcient for our interdomain context as probes may not be representative of real trafﬁc’s performance — the volume of probing trafﬁc is likely or ders of magnitude less than the actual trafﬁc, and some ISPs are known to treat probing trafﬁc preferentially [23]. Several systems propose to address some of these issues by collect ing and combining measurements from endusers [49, 57]. However, requiring large numbers of cooperative users makes bootstrapping hard. Passive sampling: Gathering statistics on live trafﬁc is possi ble using sampling with sFlow [50] or NetFlow [22]. However, sampling simply does not capture performance — measuring these metrics requires capturing state across particular packets per ﬂow (§4.2, §4.3), not arbitrary random samples. Mirroring: While mirroring obviously captures the requisite information, it does not scale and is inﬂexible. To avoid con gestion from mirrored trafﬁc, one can ratelimit it, but this has limitations similar to sampling: naive ratelimiting will dis card arbitrary packets across ﬂows, impairing loss and delay estimation. Alternatively, one can target mirroring more nar rowly, with systems like Everﬂow [68] and Stroboscope [61]. However, for continuous, highcoverage monitoring across In ternet preﬁxes and potential nexthops, such methods would require a large and constantly changing set of monitoring rules in network devices. Further, even if we could dynami cally match on a given number of ﬂows per preﬁx and mirror only those ( e.g., with programmable switches to store ﬂow identiﬁers), the mirrored trafﬁc will still be burdensome. As an illustration, consider an operator who wants to moni tor the performance for trafﬁc sent to 1000 destinations over only 2alternative nexthops and by mirroring only 50ﬂows per destinationnexthop pair. At the mean ﬂow rate observed in CAIDA traces [1], we ﬁnd that such a design would require mirroring 25:7Gbps of trafﬁc. In contrast, by aggregating measurements directly in the data plane, ROUTE SCOUT gen erates 108:4kbps in performance reports, i.e.,at287,000 higher efﬁciency. 2Endsystem monitoring: Google [65] and Facebook [55] have recently shared their solutions for pathaware routing. These approaches leverage their unique control: one end of the monitored connections terminates at their own powerful servers, and the other at a client application that also supplies performance data. This is obviously infeasible for ASes. Sketches: Sketches [41, 44, 45, 47, 64, 66] offer aggregate estimates for packet/ﬂow counts and size distributions, but do not capture latency and loss across routes. ROUTE SCOUT exploits programmable switches that open up avenues unavailable to past efforts. To the best of our knowledge, no prior work leveraging programmable switches fully addresses either the sensing / monitoring or the con trol necessary for performanceaware routing. Blink [33] uses such switches to detect packet retransmissions. How ever, Blink can only detect large outages on a single path, not congestion and latency differences across multiple paths. Dapper [30], Lossradar [67], and Inband Network Teleme try [42] provide performance metrics, such as lost packets and queuing delays, but require bidirectional trafﬁc or/and exter nal mechanisms to aggregate performance markings. While Marple [48] could potentially be used to implement perfor mance monitoring, it does not run in today’s programmable switches and does not provide ﬂexible rerouting. 2.1 Design constraints The following constraints drive R OUTE SCOUT ’s design: R1 Respect routing policies: By default, ROUTE SCOUT must select amongst equallypreferred routes, replacing arbitrary tiebreaks in BGP, and hotpotato routing. R2 Ensure correctness and stability: ROUTE SCOUT must prevent loops and oscillatory behavior. R3 Deployability: ROUTE SCOUT should not require any coordination between ASes. A single AS deploying ROUTE SCOUT should also beneﬁt from it without up grading its entire network. R4 Support asymmetric routing: Due to asymmetric rout ing, a ROUTE SCOUT switch may not see both directions of trafﬁc, it must, therefore, be able to estimate and im prove performance from oneway trafﬁc. R5 Respect ﬂow afﬁnity: To avoid performance degrada tion due to reordering of packets that could result from sending packets of the same ﬂow across different paths, ROUTE SCOUT must enforce ﬂowpath afﬁnity. R6 Fit today’s switches: ROUTE SCOUT should ﬁt within the scarce memory (dozens of MB at best [39]), restricted operations set (e.g., no ﬂoating points) and parallel mem ory accesses available to existing programmable network hardware. R7 Limit bandwidth usage: ROUTE SCOUT We must limit bandwidth usage between the data and control planes, regardless of the trafﬁc rate and burstness. Figure 1: ASA andASB are providers for the other three ASes. ASX has several legacy switches and a ROUTE SCOUT capable switch; not all edge switches in ASX run R OUTE SCOUT . 3 Overview ROUTE SCOUT is a closedloop control system that dynami cally adapts how a stub AS forwards its outgoing trafﬁc across multiple policycompliant routes according to observed per formance and operators objectives. We illustrate ROUTE SCOUT operations on a simple running example (Fig. 1) in which a stub network, ASX, routes trafﬁc to multiple destinations among which ASC andASD.ASX knows two equallypreferred paths to reach both destinations through its providers, ASA andASB, with whom ASX has 250Gbps links. BGP’s arbitrary tiebreaking selects ASA as the nexthop for trafﬁc to ASC andASB for trafﬁc to ASD. Unbeknownst to ASX, the path via ASB has a much lower delay to ASC and a slightly lower delay to ASD. Only one (edge) devices of ASX is programmable ( R3). Inputs To use ROUTE SCOUT , the operator ﬁrst speci ﬁes the preﬁxes of interest4, together with their typical trafﬁc demands .5In our example, ASX’s operator wants ROUTE SCOUT to optimize for destinations ASC andASD, which drive 100and200Gbps of trafﬁc respectively. Then, the operator speciﬁes her objectives which in our example are (a) to minimize the delay to both destinations; and (b) to load balance trafﬁc across the nexthops, as long as delay is not increased by >10%. Note that ROUTE SCOUT automatically learns the policycompliant nexthops from BGP ( R1). System To satisfy the operator’s objectives, ROUTE SCOUT implements a control loop which. . . . . . directs trafﬁc to alternative nexthops . . . monitors performance across preﬁxnexthop pairs . . . computes an optimized trafﬁc allocation to nexthops . . . actuates appropriate trafﬁc shifts in the data plane ROUTE SCOUT splits the above functions across its control and dataplanes (Fig 2). The dataplane collects and aggre gates measurements for the controlplane to analyze ( sensing ). The controlplane decides which trafﬁc to monitor and which trafﬁc to reroute to which nexthops ( analysis ). The data plane receives and enforces these decisions ( actuation ). ROUTE SCOUT sensing and actuation operates at the gran ularity of a “slot”, which we deﬁne as a small amount of 4few hundreds (in expectation) accounting for most of the trafﬁc [26, 53] 5adequately accurate estimates, are easy to obtain §6.1. 3AnalysisControl plane Data planeOutgoingtra!cIncoming tra!creroute x%of dstC Actuation …Dst preﬁxesObjectivesDemand… port 1port 2port nSolver AggregatorsForwardingSelectordstClossdelayABdstClossdelayABdstClossdelayAB monitor x%of dstCSensing Loss & DelayMonitor  MonitoringSelectorFigure 2: ROUTE SCOUT is a closedloop control system with sens ing, analysis, actuation split across data and control planes. trafﬁc to a particular preﬁx. Operating at a perslot granular ity provides measurement efﬁciency, improved stability and better resource utilization. For instance, slotbased routing enables ROUTE SCOUT to use paths that can not support all the trafﬁc for a given preﬁx. Coming back to our example, ASD receives twice the traf ﬁc as ASC. Assuming a total of 3,000slots, ROUTE SCOUT allocates 1,000slots to ASC, and 2,000slots to ASD, with each slot carrying around 0 :1 Gbps of trafﬁc. Data plane: ROUTE SCOUT data plane enforces the per slot monitoring and forwarding decisions made by the con trol plane. To scalably monitor effectively satisfying R6, ROUTE SCOUT exploits TCP’s semantics together with proba bilistic data structures to analyze the relevant packets, aggre gate the measurements( R7), and actuate the corresponding forwarding decisions (§4). Note that, while ROUTE SCOUT relies on TCP, it only requires some TCP ﬂows to exist per preﬁx, meaning it can still be useful even in QUICdominated Internet. To ﬂexibly forward, ROUTE SCOUT uses two match action tables and a novel memory mapping scheme (§4.1), that allows it to seamlessly adapt to BGP updates, preﬁx or policy changes, consistently satisfying R1 In our example, ROUTE SCOUT reroutes 1slot of trafﬁc to each destination via the alternative nexthop, namely ASB (as decided by the control plane) and monitors 4slots one for each destination, nexthop pair. As a result, aggregated loss and delay measurement for each pair will be available to the control plane. Control plane: ROUTE SCOUT control plane pulls aggregated data plane measurements, and computes a new forwarding state based on these and the operator objectives (§6.2) by formulating and solving a linear optimization program(§6.2). The main challenge in computing a new forwarding state is the conﬂicting objectives that the operators often have. In our example, the operator wants low delay (primary) and bal anced load (secondary). These cannot be satisﬁed together as ASB offers lower delay for both destinations. This is a delib erately simple example: since performance for ASC improves more, ASD’s trafﬁc should be load balanced. But the problem becomes more complex as the number of preﬁxes, nexthops, and objectives grows. ROUTE SCOUT moves to the computed forwarding state Figure 3: ROUTE SCOUT uses two matchaction tables to ﬂexibly forward the trafﬁc according to the controlplane decisions and ﬂexibly monitor a given fraction of trafﬁc per next hop. on a slotbyslot basis while tracking and reactive any per formance degradation to avoid heavily congesting remote bottlenecks potentially violating R2. Slotbyslot trafﬁc shifts also reduce the risk of oscillations, even when multiple ROUTE SCOUT systems coexist, by adding randomness and therefore avoiding synchronization [29] 4 R OUTE SCOUT Data Plane ROUTE SCOUT ’s data plane uses compact data structures and efﬁcient algorithms to ﬂexibly forward trafﬁc (§4.1) and accu rately measure delay (§4.2) and loss (§4.3). We also discuss the impact of adversarial inputs and defenses (§4.4). 4.1 Selector stage TheSelector enforces the forwarding and monitoring deci sions communicated by the control plane (§3) on a perpreﬁx basis. The forwarding decisions correspond to the number of slots to forward to given next hops, while the monitoring de cisions correspond to the number of slots to collect statistics for on given next hops. TheSelector implements slotbased forwarding and moni toring by ﬁrst hashing each incoming packet to a range [ 0,k] and then using two matchaction tables to identify subranges [i,j) of of the range [ 0,k] that need to be to be monitored or forwarded to a given port. The two tables, forwarding Selector andmonitoring Selector , use the same type of keys composed of: (i) a preﬁx; and (ii) a range [ i,j) which identiﬁes a subset of trafﬁc. In the forwarding Selector table, each key maps to a next hop. In the monitoring Selector table, each key maps to the index of a memory block of a table ( aggregator (§4.2 4.3)) in which the corresponding aggregated statistics will be stored. By adapting the contents of each table, the controller can ﬂexibly adapt the forwarding and monitoring behavior. Example: Fig. 3 shows an example with a hash range of 0100, and 3 rules in each table. The rules are such that, in expectation, 30% of packets (subrange 0–30) to preﬁx ‘prefX’ will be forwarded to port 4. Additionally, 1/3 of these packets (subrange 0–10) will be monitored before being forwarded, with the monitoring results stored in index 1of the aggregator . Observe that the ﬂexible design of the monitoring Selector table allow seamless adaptation to the system’s dynamics. For example if the BGP peer at port 4 withdraws prefX, then the range of the green (second) rule in the forwarding Selector could be expanded to include hash outputs 030, and the red (ﬁrst) rules in both the forwarding Selector andmonitoring 4(a)  (b)  (c) Figure 4: Delay monitor :(a) SYNs of different ﬂows (blue/above & yellow/below) increment different indexes; (b) The ﬁrst ACK of the yellow ﬂow checks that all its indexes (3,5,8) are set, and reads the timestamp of the yellow SYN from the reversible index 8; (c) The same ACK removes the footprint of the yellow ﬂow by XORing T3 to the indexes of (3,5,8), and decrementing their counters. Selector will be deleted. The index 1 of the aggregator used to store measurements for this preﬁxnexthop pair can also be reset and assigned to another one. 4.2 Measuring delays This component is responsible for accurately and scalably measuring the delay of any ﬂow belonging to one of the mon itoring slots enforced by the Selector . It relies on a monitor and an aggregator . The monitor estimates the delay observed by each ﬂow by tracking speciﬁc TCP metadata, while the aggregator accumulates these statistics which are eventually pulled by the control plane. Estimating delay: To estimate the delay of a given ﬂow in the presence of asymmetric routing, the Delay monitor computes the time elapsed between its TCP SYN and the ﬁrst ACK (similarly to [38]). While doing so means that ROUTE SCOUT only measures delay at connection setup, it also minimizes the noise from applicationlevel effects which are likely to be more signiﬁcant for later packets. Recording timestamps at scale is challenging. Indeed, sim ply storing the SYN timestamp and the 5tuple in a hash table does not scale since it requires >100 bits per measurement. To address this problem, we use a combination of two proba bilistic data structures: an Accumulator , for storing sums of timestamps at each index, and a Counter for counting how many timestamps are in each sum in the Accumulator . In essence, the Counter can be seen as a Counting Bloom Fil ter [25], while the Accumulator is similar to an Invertible Bloom Lookup Table [32]. We use XOR ( ) as sum operator rather than a simple addition — while both +andare re coverable (given AandABorA+B, one can recover B), cannot cause overﬂows. Unlike previous works [44, 67] that send their full Bloom ﬁlters to the controller to be decoded (incurring both compute and bandwidth expense), we measure entirely in the data plane, and only expose aggregated statis tics to the control plane which can pull them asynchronously. Example, Fig. 4: As SYNs of different ﬂows arrive (Fig. 4a), we hash their 5tuples with multiple hash functions, thus generating multiple indexes. Here the yellow (lower) ﬂow is hashed to (3;5;8), and the blue (upper) ﬂow to (1;3;6). Each entry of the Accumulator in those indexes is ed with the timestamp of the SYN. Additionally, the Counter of each entry is incremented. Different SYNs can end updating the same index, e.g., index 3 in Fig. 4a. On receiving an ACK, we ﬁrst compute the corresponding indexes using the same hash functions. If all the correspond ingCounter values are nonzero, then we know that the SYN timestamp is contained in the Counter . In Fig. 4b, the ACK of the yellow ﬂow arrives and ﬁnds its indexes set. To get the timestamp of its corresponding SYN, we need to ﬁnd one index among the indexes to which the ACK is hashed, whose value in the Counter is one. We will call this index reversible. The same index in the Accumulator yields the timestamp for this ﬂow’s SYN, thus allowing us to compute its delay. In Fig. 4b, the ACK ﬁnds a value equal to 1in the index 8, namely the third of the three indexes it is hashed to. Thus, the timestamp of the SYN is at index 8 in the Accumulator . To erase the footprint of a SYN from the Delay monitor , we decrement each of the hashed indexes in the Counter , and the recovered timestamp with the sums at these indexes in theAccumulator . In Fig. 4c, we illustrate the result of this process; observe that by ing the timestamp in each of the hashed indexes, the effect of the yellow SYN vanishes. Keeping the Delay monitor healthy: In the common case, theDelay monitor stores some perﬂow state only during the handshake as an ACK removes the memory footprint created by the corresponding SYN. This allows the Delay monitor to scale with the number of ﬂows regardless of their rate and duration. Still, a large number of SYNs not followed by corresponding ACKs can pollute the Delay monitor . This challenge can be easily addressed by keeping track of the number of SYNs in the Delay monitor and not add new ones if the ﬁlter has exceeded its capacity (number of elements it can store based on allocated memory, §7.2). Alternatively, the ﬁlter can be reset periodically. Aggregating statistics: Theaggregator stores the delay mea surements per preﬁxnexthop pair in an array with two values per index: one for storing the sum of the delays and one for storing the number of delay measurements contained in the former. The control plane can pull the measurements for a preﬁxnexthop pair or for all pairs at once, and calculate the mean delay. For example, in Fig. 4c, once the ACK has read the timestamp of its SYN it calculates the time elapsed since then and update the values in the index that is mapped to its preﬁx and output port. The mapping between the preﬁx nexthop pair and the index in the aggregator is assigned by the control plane and communicated via the monitoring Se lector . Thus, to monitor different preﬁxes or different number of next hops for some preﬁxes, one just changes this mapping instead of reallocating memory and needing recompilation (see example in §4.1). 5Figure 5: Here the Loss monitor sees three packet arrivals, 2inorder and1retransmit. The ﬁrst, with sequence number S:5500 has the next expected sequence number E:6500, and inserts the latter into the CBF by incrementing the indexes corresponding to the E:6500 (blue indexes, 1, 3, and 4). The second packets ﬁnds its indexes (now yellow, 1, 3, and 4) nonzero, thus knows it was expected. It cleans itself out, and inserts the next expected packet (blue indexes, lower) . The third one, a retransmit, ﬁnds one of its indexes (2) unset. 4.3 Measuring loss rates The design and challenges of the loss measurement compo nent are similar to those for delay with some key distinctions. In particular, to measure the loss rate, the monitor tracks the amount of retransmitted and regular packets, while the ag gregator accumulates the counts for each category. Estimating loss rate: Measuring retransmissions at scale is challenging since one cannot simply store every packet and compare new arrivals against the past history to identify du plicates. Our solution, somewhat surprisingly, requires only a few bits per ﬂow, at the cost of one minor compromise: the in ability to distinguish reordering from retransmissions. Given that reordering also hurts TCP [15], mistakenly accounting for it as loss is not a signiﬁcant downside, if it is one at all. Our solution keeps only one element per ﬂow by exploiting TCP semantics and the fact that, given a TCP packet p, one can compute the next expected sequence number based on p sequence number and payload length. By storing this expected sequence number, we can check whether the next packet is either a retransmission or an outoforder packet. Instead of storing a 16bit (expected) sequence number, e, we can in sert it into a counting bloom ﬁlter (CBF), i.e.,the same data structure as our Counter for delay estimation. Since, packets across ﬂows can share sequence numbers, we insert the con catenation of the 5tuple with the sequence number instead. Increasing the length of the inserted value is immaterial, as the length of the hash output is the same. Whenever a packet with sequence number sarrives, we check the CBF for < 5tuple, s>: If the entry does not exist, the packet is outoforder or a retransmit. If the entry exists, the packet is inorder and we delete it from our ﬁlter by decre menting all the indexes < 5tuple, s> hashes to. We then insert thenext expected packet by incrementing all the indexes that <5tuple, s+tcp:len> hashes to. Not all packets carry information regarding previous seg ments. For instance, an ACK that does not carry any TCP data will be followed by a packet of the same sequence number regardless of whether the former was lost or not. Similarly,KEEPALIVE messages (commonly used in Web trafﬁc) con tain an “unexpected” sequence number: one byte less than the previously sent sequence number. To avoid these issues, we only use packets with TCP payload. This does not disrupt functionality, as for every nonzeropayload packet whose subsequent sequence number we store, there will be a non zeropayload packet that can remove it, even if it comes after multiple zeropayload ACKS. Example, Fig. 5: In this example, we illustrate how 3packets (the last one being a retransmitted one) of a ﬂow update the CBF. The yellow (upper) box contains their sequence number, and the blue box (lower), the sequence number of the expected packet. The ﬁrst packet inserts the ﬁngerprint of the expected (second) one by incrementing the values stored in the indexes that the expected sequence number (concatenated with the 5tuple of the ﬂow) hashes to (blue indexes). Thus, when the second packet arrives, it will ﬁnd all hashed indexes of its sequence number set (yellow indexes), and will consider itself expected. This is not true for the third packet whose indexes are not all set and is a retransmit. Keeping the monitor healthy: Similarly to the Delay moni tor, the Loss monitor contains one item per ﬂow regardless of its rate as the structure “cleans itself” with incoming packets. In particular, once a ﬂow terminates, the corresponding RST or a FIN removes the ﬂow permanently. Still, outoforder and lost packets will, in most cases, cause some packets to stay in the ﬁlter. However, this represents a very small fraction of packets, as we discuss in §7.3. To avoid overﬂowing the mon itor, a counter in the data plane can keep track of the number of ﬂows using it. If the ﬁlter’s capacity is exceeded, insertions are stalled until some of the ﬂows terminate. Alternatively, the ﬁlter can be reset periodically as we show in §7.3. Aggregating statistics: Similarly to the Delay aggregator , theaggregator stores the number of expected and unexpected packets observed per preﬁx and next hop. 4.4 Dealing with adversarial inputs Like any datadriven system, ROUTE SCOUT is prone to at tacks in which malicious endpoints or networks aim at faking signals in order to inﬂuence its decisions. While possible, and deserving a complete analysis in a followup work, we brieﬂy argue why such attacks on ROUTE SCOUT are hard to perform. In order to inﬂuence ROUTE SCOUT ’s decisions, a mali cious endpoint could try to: (i) send repeated packets to fake retransmissions; or (ii) send fake pairs of SYNs and ACKs with a small/large timing differences to fool the delay monitor. We note two things. First, such adversarial end points must be hosted within the stub AS, since ROUTE SCOUT optimizes exit trafﬁc. Assuming basic antispooﬁng techniques are in place (e.g. [56]), each end point has a single IP address to source trafﬁc from. As such, limiting the number of ﬂows tracked per IP would be sufﬁcient to mitigate the attack. Sec ond, ROUTE SCOUT randomly associates a ﬂow to a next hop, depending on a hash function. As such, the attacker is equally 6(a)  (b) Figure 6: (a) We implement the Delay monitor as a series of arrays; (b) A packet can either check if it is expected or insert the next expected packet in the Loss monitor . likely to add noise to measurements of allnext hops, making targeting one nexthop difﬁcult. ROUTE SCOUT can also de feat attempts to use traceroutes for probing such decisions by randomly forwarding traceroutes to next hops. Similarly, a malicious transit network can: (i) drop packets to increase the loss rate; or (ii) drop/delay SYNs, SYN/ACK, or ACKs to fool the delay monitor. While this is possible, we note that, by doing so, malicious networks can only make their performance worse, not better. As such, malicious networks can only push away trafﬁc, not attract more. Observe, that an attacker cannot craft a SYN/ACK packet for every SYN it receives to fake low latency as she does not know the sequence number that the receiver will use until the actual SYN/ACK packet is received. Finally, attackers can also attempt to pollute ROUTE SCOUT ’s data structures. An efﬁcient way to mitigate such pollution is to periodically reset the data structures, as we discuss in §7. 5 Hardware Design Our design needs modiﬁcation to ﬁt a real Protocol Indepen dent Switch Architecture (PISA) switch. We brieﬂy explain the key constraints imposed by PISA and how we adapted the Delay and Loss monitors accordingly. We have tested our design in a Barefoot Toﬁno Wedge 100BF32X. PISA constraints: A packet traversing a PISA switch goes through a pipeline of stages. Besides the limited memory and instruction set, which our design already addresses, there are constraints on the sequence of memory accesses [13,63]. First, a packet cannot read or write multiple memory addresses in the same memory block. Second, memory blocks are tied to a single stage in the pipeline and can only be accessed in it. This is to avoid contention from stages processing different packets simultaneously. Similarly, accessing stages in a different order or multiple times per packet is not possible. Delay Monitor modiﬁcations: To access any kind of Bloom Filter, including those in the Delay Monitor, we need to access multiple indexes, each corresponding to the output of a hash. For instance, in Fig. 4a, the yellow SYN would need to access three indexes corresponding to the yellow indexes. In PISA though, one cannot concurrently access multiple indexes of the same memory block. We thus divide the two tables ofthemonitor into smaller chunks, and constrain each hash to index a single chunk as seen in Fig. 6a. Now, chunks reside in different stages of the pipeline and can be accessed serially. Serializing accesses creates another issue. Particularly, when an ACK arrives, the monitor ﬁrst needs to ﬁnd out if it corresponds to the ﬁrst ACK of a ﬂow whose SYN is in the Accumulator (Fig. 4b), and if so, decrement all cor responding indexes in the Counter . For this, the SYN will need to traverse all three pipeline stages in Fig. 6a to check whether all corresponding indexes of the Counter are non zero. But after doing so, the packet cannot return to stage 1and decrease their values in the Counter . To address this, the monitor recirculates packets corresponding to ﬁrst ACKs. Observe that even if we could rely on SYNACK, which is impractical due to asymmetric routing, we would still not be able to avoid recirculation. Indeed, even if an incoming ACK knew upon arrival that the timestamp of the corresponding SYN is in the structure, it will still need to ﬁnd a reversible index to read this timestamp and then it to all (previous) stages. As an illustration, in Fig. 6a, the reversible index is in stage 3. At the time the packet reads it, it can no longer return to stages 1 and 2, and it to the corresponding indexes. Loss Monitor modiﬁcations: Similarly here, we need to split the CBF into multiple chunks and stages. Recall that every incoming packet needs to check if it is expected, remove itself, and insert the next expected packet in the CBF. This results in two violations of the PISA constraints. First, a packet needs to access each memory chunk (in each stage) in two different indexes, one corresponding to the output of itself, whose value it needs to decrement, and one corresponding to the next expected packet, whose value it needs to increase. Second, the former access is conditioned on whether the packet is expected or a retransmission something which will only be known after the packet traversed all stages. To address the ﬁrst violation, we allow each packet one of the two operations, either to remove itself, if it is expected, or to insert the next expected one iteratively. To achieve this, we keep track of the number of packets seen by each ﬂow. Particularly, when a packet arrives, it checks the number of nonzeropayload packets its ﬂow has already sent. If this number is even, as for S:5500 and S:7500 in Fig. 6b, then the packet will insert the next expected one in the CBF. If the number is odd, as for S:6500 in Fig. 6b, the packet will try to ﬁnd its footprint in the CBF and remove it. We use a counting bloom ﬁlter to efﬁciently keep track of the number of packets. To address the second violation, we assume all packets to be expected and recirculate packets that violate this assumption. In more detail, on arrival, a packet whose ﬂow has sent an odd number of packets reads and decrements the indexes corresponding to it in the CBF. If the packet was indeed expected, i.e.,all read values are nonzero (as for S:6500 in Fig. 6b), the packet increments the Accumulator and leaves the device. If the packet was a retransmission, it is recirculated to reincrement the indexes it wrongly decremented. 76 R OUTE SCOUT Control Plane In this section, we describe ROUTE SCOUT ’s control plane and how it leverages measurements from the data plane to improve forwarding decisions. We start by describing the controlplane inputs (§6.1). We then explain how it solves the induced optimization problem (§6.2). We describe the simplest version of the control plane that would enable performancedriven routing and support conﬂict ing operator objectives. To cover additional operational needs, this control plane can be extended for instance to strengthen stability guarantees as shown in [29]. 6.1 Inputs ROUTE SCOUT triggers the Solver periodically giving as input a description of the environment, a set of objectives, and op tionally, some additional constraints for each preﬁx, together with fresh performance statistics. Environment: The network environment includes topologi cal, trafﬁc, and routing information. The former two are pro vided by the operator and the latter by BGP. Topological information corresponds to the set of direct nexthops and their link capacities. Trafﬁc information consists of the set of preﬁxes that ROUTE SCOUT should optimize for, together with the volumes they drive. Routing information corresponds to the set of nexthops that ROUTE SCOUT can use to route each preﬁx (obtained from routing tables and BGP policies). Expecting trafﬁc information is reasonable as important preﬁxes are few and stable over time [26, 53]. The traf ﬁc volumes to these preﬁxes can also be estimated accu rately [37, 52]. Note that inaccurate trafﬁc volumes won’t affect ROUTE SCOUT ’s performance if the direct links are not running at full capacity which is true in most stub ISPs. If that’s not the case, ROUTE SCOUT might indeed not ﬁnd the optimal solution but will never deteriorate the performance by moving trafﬁc to a worse next hop. Objectives: The operator can decide whether they want to: (i) optimize for delay and/or loss; (ii) minimize the number of trafﬁc shifts necessary to meet the requirements; or (iii) loadbalance trafﬁc by minimizing the difference between the most and the leastused nexthop. Linear combinations of these or similar other objectives are easily implementable. ROUTE SCOUT also allows multiple objectives to be ﬂex ibly implemented. To do so, the operator needs to express how important each objective is by deﬁning priorities and how valuable are the differences among alternative forward ing states by deﬁning tolerance levels. Objectives with lower priority will only be optimized if there are multiple equally preferred solutions, namely solutions that differ from the op timal by no more than the tolerance level. For example, an operator might want to balance the load across the nexthops, as long as the delay difference between the best and the used nexthop is lower than 10%. The operator can communicate this to ROUTE SCOUT by giving a high priority to delay with 10% tolerance, and a lower priority to loadbalancing.Operational constraints: ROUTE SCOUT admits con straints of two types: (i) those that limit the number of next hops trafﬁc can be spread on; and (ii) those that deﬁne per formance constraints. Constraining the maximum number of nexthops per destination might be useful, for instance, to ease debugging. Performance constraints are maximum loss/delay values that trafﬁc for a certain destination should experience. Deﬁning such objectives is useful for meeting Service Level Agreements (SLAs), or particular application requirements. Data plane statistics: ROUTE SCOUT periodically pulls mea surements of loss and delay aggregated per preﬁx and next hop from the respective aggregators . 6.2 Solver The solver is responsible for synthesizing a forwarding state. To do so, it formulates each of the operator’s inputs into a constraint or an objective, creating a linear optimization prob lem. Problem statement: LetNbe a set of nexthops and Prthe set of destination preﬁxes to optimize for. Let PaPrN be the set of all pairs of destinations and equallypreferred nexthops (learned by BGP). The goal is to ﬁnd a mapping Ft:Pa!N, namely the number of slots allocated to each pair (preﬁx, nexthop) at time tsuch that it optimizes the operator’s objectives, while adhering to the environmental and operational contraints. We implement the Solver using Gurobi [3]. 7 Evaluation We evaluate ROUTE SCOUT ’sDelay monitor (§7.2), Loss mon itor(§7.3) and Solver (§7.4). For the monitors, we investi gate the tradeoff between accuracy and memory footprint using real trafﬁc traces and our practical hardware design (§5). We ﬁnd that, with 1MB of memory, the Delay monitor can accurately measure the delay of hundreds of thousands of ﬂows/sec. Moreover, the Loss monitor can accurately mea sure loss rate of 36Kﬂows/sec with as little as 312KB of memory. For the Solver , we focus on runtime, and show that it computes forwarding states for thousands of destinations, across tens of next hops and for various objectives, in less than a second. 7.1 Methodology "
374,Multi-hop Data Fragmentation in Unattended Wireless Sensor Networks.txt,"In this work, we analyze the advantages of multi-hop data fragmentation in
unattended wireless sensor networks (UWSN) and propose a lightweight protocol
to achieve it. UWSN has recently become an important aspect in various areas of
sensor networks where real-time data collection is difficult to manage.
However, the characteristics of UWSN also poses new problems especially in data
protection. For more efficient protection, data fragmentation has been proposed
to fragment sensing data, which prevents attackers from successfully exploiting
the data. However, there are currently minimal work on the strategies of the
placement of fragments inside a sensor network. Through this work, we analyze
the effects of multi-hop fragment dispersal in relation to effectiveness of
data protection and energy consumption. Furthermore, we design a new routing
algorithm suitable for the energy-efficient placement of data fragments in
UWSN. We utilize simulation-based modeling and testbed implementation via
FIT/IoT-Lab to prove the effectiveness of our work.","In various applications that require usage of a wireless sensor net work (WSN), it can be difficult to use the commonly assumed net work environment of WSN, which is the interaction and multihop wireless communication between a sink node and multiple sensors. This is the case of hostile environments such as battlefields and inaccessible regions (e.g. fallout sites) where it could be difficult to collect sensing data and manage the network in realtime manner. In these specific cases, it is more preferable to utilize itinerant sinks to be able to collect sensing data per demand. In the near future, we can envision new Internet of Things (IoT) services, comprised of hightech devices, such as automated unmanned aerial vehicles (UAVs) to act as sink nodes in a sensor network to be able to pro vide these functionalities. Such kind of sensor network architecture has been defined by researchers as the unattended wireless sensor networks (UWSN) [17]. In UWSN, one of the most important factors is the survivability of the data, which takes into account whether a data generatedby a sensor node is successfully transferred to the itinerant sink node. This is especially critical in UWSN because the data must be stored in the unattended sensors before an itinerant sink arrives in the proximity to receive the data. During this time, the data can be a viable target to attackers, who are also mobile and either steal, modify, or erase the data from the sensor nodes [21][22]. One of the potential technologies to enhance the survivability of the data is data fragmentation[ 4][12][13]. The general purpose of data fragmentation is to fragment a data kinto fkfragments through a cryptographic means. An itinerant sink can decode the data by collecting f′ knumber of fragments where f′ k≤fk. If the f′ k is high enough, it becomes more difficult for an attacker to be able to successfully exploit the data, as it must attack multiple sensors to be able to collect f′ kfragments. Therefore, data fragmentation provides protection of the data itself, while also providing some flexibility even if some of the fragments are erased or not received by the itinerant sink node. However, majority of the stateoftheart in data fragmentation only consider the security aspects, as in how to fragment the data and defragment them again. They do not consider where to place the fragments in the sensor network, even though it is very likely that in a sensor network, there can be numerous number of de ployed sensors, while the conditions of which sensors can receive a data fragment can be very dynamic. Moreover, for the sake of transferring data to remote sensors, multihop routing protocols are needed. The general architecture of UWSN does not need multi hop routing, therefore adding a routing layer just for the sake of transferring data fragments induce considerable energy consump tion and bandwidth consumption from control packet transmission. Even though some epidemic flooding methods are proposed to dis seminate data to remote sensor nodes [ 23][1], these are methods used for replication of same data, which have different character istics and objectives compared to data fragmentation. Therefore, it is difficult to use epidemic protocols for dissemination of data fragments without inducing heavy overhead, because fragmented data are different in detail. In this paper, we look at some methods on the dispersal of data fragments within a UWSN. The main objective of our research is based on the fact that data fragmentation, being a effective and reliable method to prevent data exploitation, must be used, even at the cost of more energy consumption. However, to improve the security of data fragmentation itself, multihop fragment dispersalarXiv:1901.05831v1  [cs.NI]  17 Jan 2019is needed. However, this incurs more data transmissions in the network, increasing energy consumption of the network. Thus, our first contribution is finding the relation of the distance of data fragments from the origin in regards to an assumed attacker model. Also, our model analyzes the effect of remote fragmentation and its relations to energy consumption. Then, we focus on the fact that multihop data fragment dispersal requires a multihop routing protocol, which is bound to create even more network overhead. To solve this problem, we consider a method to transfer data fragments to remote sensors without utilization of costly existing routing protocols. More specifically, we propose a sinknode oriented route configuration protocol, which show how existing routing protocols can be modified to not induce excessive overhead to each sensor node, while majority of the processing is focused on the sink node. We compare the performance of our proposed method to other data fragment dispersion methods, and show that our method is superior to its counterparts in terms of data protection and energy efficiency. For our analysis we utilize simulationbased modeling tools to strengthen our initial beliefs, and then utilize the FIT/IoT Lab experimentation environment [ 10] to test our proposed scheme at a more practical scale. 2 RELATED WORK "
239,CISER: An Amoebiasis inspired Model for Epidemic Message Propagation in DTN.txt,"Delay Tolerant Networks (DTNs) are sparse mobile networks, which experiences
frequent disruptions in connectivity among nodes. Usually, DTN follows
store-carry-and forward mechanism for message forwarding, in which a node store
and carry the message until it finds an appropriate relay node to forward
further in the network. So, The efficiency of DTN routing protocol relies on
the intelligent selection of a relay node from a set of encountered nodes.
Although there are plenty of DTN routing schemes proposed in the literature
based on different strategies of relay selection, there are not many
mathematical models proposed to study the behavior of message forwarding in
DTN. In this paper, we have proposed a novel epidemic model, called as CISER
model, for message propagation in DTN, based on Amoebiasis disease propagation
in human population. The proposed CISER model is an extension of SIR epidemic
model with additional states to represent the resource constrained behavior of
nodes in DTN. Experimental results using both synthetic and real-world traces
show that the proposed model improves the routing performance metrics, such as
delivery ratio, overhead ratio and delivery delay compared to SIR model.","Infectious diseases have caused a large number of mor tality in recent years (e.g., includes SARS (2003), swine ﬂu (2009) and MERS CoV (2013), etc.). Mathematical modeling of infectious diseases is used to predict the transmission and the outcome of the diseases, which helps to provide possible countermeasures to reduce the mortality rate or to eradicate the diseases. Amoebiasis is a chronic infectious disease, caused by unicellular microorganism Entamoeba histolytica , which is continuously threatening countless human beings living in unhygienic environment/conditions in developing countries, especially in SubSaharan Africa (SSA). Since amoebiasis is an infectious disease, some of the researchers [1] have modeled the transmission behavior of amoebiasis in human population. Inspired from such modeling, we have observed that amoebiasis disease modeling can also be applied in modeling the epidemic message forwarding in Delay Tolerant Networks (DTNs). DTNs are mobile networks in which a complete endto end path rarely exists due to high node mobility and fre quent disconnection. Since, the connectivity between nodes in DTN is not constantly maintained, a routing protocol is required, which tries to route messages through one or more relay nodes in opportunistic multihop manner. Epidemic routing [2] is one of the simplest routing protocol schemes in Sobin is a PhD student in the Dept. of Computer Science and Engineering, IIT Roorkee, India. email: sobincc@gmail.com. Snehanshu is a professor in Dept. of Computer Science and Engineering, PESITSouth Campus, Bangalore, India. email: snehanshusaha@pes.edu. Vaskar is an Alexander von Humboldt Fellow in Universitt Mannheim and Technische Universitt Darmstadt and an assistant professor (on leave) in the Dept. of Computer Science and Engineering, IIT Roorkee, India. email: vaskar@ieee.org Hategekimana is a research scholar in the Dept. of Mathematics, Jain Univer sity, India. email: ﬁdeleh67@gmail.com Sumana is a PhD student in the Dept. of Computer Science and Engineering, PESIT South Campus, India. email: sumanasinha@pes.edu. Fig. 1. Comparison of (a) amoebiasis disease propagation with (b) Epidemic message propagation in DTN disease propagation DTN, which adopts a ﬂoodingbased strategy for message forwarding. The basic idea is that a source node having a message to a destination, forwards it to all its neighbors. The neighbor nodes act as relays, ﬂoods the message further in the network, so that message eventually delivered to the destination. There is a clear connection between epidemic message transmission in DTN and the amoebiasis disease propa gation in human population (See Fig.1). Amoebiasis is an infectious disease caused by a parasitic protozoan, Enta moeba histolytica. There are two stages of the life cycle of Entamoeba histolytica , infectious cysts and motile phagocyte trophozoites. The infective form of Entamoeba histolytica, called cysts, are shed within the feces of the infected host and later infect food and drinks by ﬂies or other meansarXiv:1608.07670v1  [cs.NI]  27 Aug 20162 of direct or indirect contact with contaminated feces. The trophozoites is an acute infectious stage of amoebiasis and exists only in the host. A similar scenario exists in case of epidemic message transmission in DTN; when a source node with a message to be delivered to a destination, store and carry the mes sage, until it ﬁnds a node in its communication range to forward. The amount of time taken by a node to store the message without forwarding depends on the connectivity of the network. When the source node ﬁnds a node in its communication range, it will choose the encountered node as relay and creates a copy of the message and forward to it. In order to design a mathematical model for epidemic message transmission in DTN based on the dynamic trans mission of amoebiasis, we propose a novel epidemic model, called as CISER model, with two additional classes, exposed (E) and carrier (C) to basic SIR model [3]. The exposed class (E) represents the individuals which are exposed to the disease, but the level of infection is not enough to make them infectious. Similarly, the carrier class ( C) represents the individuals, which never recover from the disease and spreads it further in the population. While adopting the CISER model to the epidemic message transmission in DTN environment, the susceptible class ( S) represents the set of nodes in the network, which are available for receiving a copy of the message. The exposed class ( E) represents the set of nodes which are already having a copy of the message, but are not able to forward the message further in the network due to lack of resources such as, storage and energy. The infected class ( I) represents the set of nodes which already received a copy of the message and ready to forward that further in the network. The carrier class (C), is a subcategory of infected class, which represents set of relays nodes, which are having a copy of the message and spreads the message further in the network. The co existence of two classes, I and C, are similar to trophozoites and cysts in the transmission of amoebiasis. In the acute infected stage of amoebiasis ( I), the host is infected, but not spreading the disease to any other hosts; similar to node having a copy of the message, but not forward further in the network. The carrier stage of amoebiasis, occurs when the host remains acute infection for a period of time (in class I) and later spreads the infection ( class C) by excretion of cysts in their stools. The recovered class (R) represents the nodes which have either received and delivered the message to the destination or discarded due to expiry of TTL of the message. In nutshell, the paper explores the possibilities of intro ducing a novel model for epidemic message propagation in DTN, considering the resourceconstrained behavior of DTN nodes. The goal is to improve certain key QoS param eters and to provide emphatic evidence of how the proposed model is better than other models in the same class (basic SIR model). More speciﬁcally, we have investigated the certainty of achieving higher delivery ratio, lower delivery delay and lower overhead ratio compared to the basic SIR model.2 R ELATED WORK "
191,Navigability of temporal networks in hyperbolic space.txt,"Information routing is one of the main tasks in many complex networks with a
communication function. Maps produced by embedding the networks in hyperbolic
space can assist this task enabling the implementation of efficient navigation
strategies. However, only static maps have been considered so far, while
navigation in more realistic situations, where the network structure may vary
in time, remain largely unexplored. Here, we analyze the navigability of real
networks by using greedy routing in hyperbolic space, where the nodes are
subject to a stochastic activation-inactivation dynamics. We find that such
dynamics enhances navigability with respect to the static case. Interestingly,
there exists an optimal intermediate activation value, which ensures the best
trade-off between the increase in the number of successful paths and a limited
growth of their length. Contrary to expectations, the enhanced navigability is
robust even when the most connected nodes inactivate with very high
probability. Finally, our results indicate that some real networks are
ultranavigable and remain highly navigable even if the network structure is
extremely unsteady. These findings have important implications for the design
and evaluation of efficient routing protocols that account for the temporal
nature of real complex networks.","Transfer of information, mass, or energy is a key function in many natural and artiﬁcial complex systems, ranging from generegulatory networks1and the brain2to online and ofﬂine social networks3, the Internet4, and transportation networks5. Milgram’s experiment6showed that some of these systems can be efﬁciently navigate d, i.e., their elements are able to perform an effective information routing even though they do not pos sess global knowledge of the system. This surprising proper ty was ﬁrst explained by Kleinberg using a network model7,8, in which each node resides in the Euclidean plane and forwar ds information to the neighbor which is closer to destination. More recently, it has been suggested that the geometry of com plex networks is not Euclidean but hyperbolic, as a result of the i nterplay between the popularity and similarity attributes of the nodes9–12. Within this framework, the observed topological properti es of complex networks are naturally explained on the basis of a hidden metric space deﬁning distances between nod es, and a connection probability dependent on such distance s. Moreover, distances in the underlying hyperbolic geometry can guide greedy routing very efﬁciently in scalefree netw orks, meaning that the success probability of the process is extre mely high, while the routing paths deviate only slightly fro m the topological shortest paths, following closely the geodesi cs in the hyperbolic plane13. These advances in the understanding of the navigability of c omplex networks are framed within the traditional approach taking the structure of networks as static. However, this as sumption has been recently challenged by the empirical obse rvation of a temporal dimension in many natural and social systems14–17, demonstrating that nodes and edges switch on and off with several time scales. The empirical analysis of such tem poral networks18has unveiled new statistical properties, such as a heavytailed distribution of interevent times betwee n consecutive links, known as burstiness19, or the heterogeneous distribution of activity in social interactions20. Temporal effects have been shown to impact both the behavio r of dynamical processes on networks21–25and the connectivity of their corresponding static represe ntations26,27. Timerespecting paths18, for instance, play a crucial role in slowing down or speeding up the spreading of information or diseases28, and certainly affect also the message routing throughout the network. Although navigation is expected to be substantially differ ent in temporal networks than in static ones, few empirical o r the oretical works have been devoted to study the impact of the te mporal dimension on the navigability of complex systems4,29,30. Some of these studies are concerned with the small world prop erty31, while others aim at quantifying network vulnerability to temporary failures32, or explore temporal networks using greedy walks that proce ed from node to node by always following the ﬁrst available contact33. However, the general mechanisms that guarantee an optimal routing in situations where the network’s structure changes with time, or where noise affects t he communication paths, are not fully understood yet. Uncov ering such mechanisms is thus a fundamental task, with a broad rang e of potential applications, for instance, in communicatio n engineering34and system biology35. Here, we tackle this issue by proposing a hybrid model to stud y the navigability of temporal networks and show that, surprisingly, temporal networks can be navigated more efﬁc iently than their static counterparts. Furthermore, we sho w that some real networks are ultranavigable, meaning that they re main highly navigable even when the network topology is stro ngly dynamic. Our model considers static reconstructions of rea l networks and a simple node activationinactivation dynam ics. This allows us to control for the maximum duration of the rout ing process, as well as to discard peculiar features of speci ﬁc real evolving systems, such as circadian rhythm36. The activation dynamics may represent temporal failures o f nodes due to random unknown events, or noise. Our approach suggests a new greedy routing protocol in static networks, that combines standard greedy routing and a simulated activation dynamic s, which can boost the navigability of some real networks, at the expense of elongated paths. Next, we set our analysis upon ﬁve different empirical netwo rks: ArXiv collaborations (ArXiv), US Commodities network s (Commodities), Metabolic networks (Metabolic), the Inter net at the autonomous system level (Internet) and the World T rade Web (WTW). Detailed descriptions of the data sets can be foun d in Methods. 1 Greedy routing on temporal networks Information packets, or other assets, are transferred in a n etwork from a source node to a destination one by following gr eedy routing in hyperbolic space11. We consider a twodimensional hyperbolic plane of constan t negative curvature where each node ihas polar coordinates ( ri,θi), see Methods. The implementation of the routing algorithm requires that there is only one packet per sourcedestination pair, that each node knows it s coordinates, the coordinates of its neighbors in the netwo rk, and the coordinates of the destination node. Then, the node hold ing the packet will transfer it to its neighbor with the small est hyperbolic distance to the destination node. We take the hyperbolic embedding of the largest connected co mponent37of each real complex network, that we refer as the static map M(G0,S), where G0stands for the static graph and Sis the underlying metric space where the nodes have permanen t coordinates. Next, we generate several synthetic temporal networks by applying a Poissonian activationinactivatio n dynamics on its nodes. We consider that nodes can be in an active state, being able to receive and forward information, or in an inact ive state, in which case they cannot receive neither forward inf ormation packets. At each time step t, each node iis active with probability ai. Thus, at each time step t, a graph Gtis deﬁned, in which only active nodes and the links between th em are present. The sequence of graphs G={Gt}t=1,2,...Tconstitutes a synthetic temporal network of length (durati on)T. The activation probabilities control the density of the tempor al networks, affecting the probability of a message being se nt. For instance, in the case of a constant activation probability s et equal for all nodes, ai=a, each graph Gthas an expected average degree equal to kt=ak, where kis the average degree of the original static network. Therefore, the greedy routing acts on a temporal map M(G,S)depending on the temporal network Gand the underlying hyperbolic space S. The greedy forwarding algorithm is implemented sequentia lly on the temporal map M(G,S), so there is one attempt to forward the information packet for each time s tept. At time t, the node holding the information packet tries to forward it to its neighbor with the lowest distance to the ﬁna l destination. If the neighbor is active at time t, then it receives the packet. Otherwise, the packet remains at the holding nod e. The model with a=1 corresponds to greedy routing on the original static network, with all nodes active at all times, for a number of steps equal to T. Therefore, the network’s duration Tcan be interpreted as the maximum lifetime of information pa ckets. In this scenario, a greedy path is successful when a packet reaches its destination in a time t≤T, and unsuccessful otherwise. In the limit of T→∞, all packets are expected to be able to reach their destination because the number of diff erent paths that can be realized by greedy routing on the temp oral networks grows with T. We run numerical simulations for different network’s durat ionT, taking a number of random source–destination pairs which is the minimum between 105andN(N−1)/2, where Nis the number of nodes of the network. In numerical experimen ts varying the activation probability, the random subset of so urce–destination node pairs is kept the same, while it is cha nged when varying T. 2 Results We ﬁrst consider a constant activation probability set equa l for all nodes, ai=a. In this case, the model is characterized by two parameters, the activation probability a, which controls the activation dynamics, and the network’s duration T, which represents the maximum lifetime of information packets. We evaluate the performance of greedy routing on the temporal map by measuring two main quantities: the success ratio p s, deﬁned as the fraction of packets that successfully reach t heir destination within a time Tover the total number of sourcedestination pairs consider ed; and the average topological stretch 2/100 2500 5000 T0.00.51.0ps0.1 0.3 0.6 0.9 a=1Arxiv 0 500 1000 T0.00.51.0Commodities 0 500 1000 T0.00.51.0Metabolic 0 500 1000 T0.900.951.00Internet 0 5000 10000 T050100s 0 5000 10000 T02550 0 5000 10000 T01224 0 5000 10000 T036 0 500 1000 T1230 500 1000 T0.950.981.00WTW Figure 1. Success ratio ps(top row) and average stretch s(bottom row) as a function of T, for different values of the activation probability a, in ﬁve real networks. The success ratio and the average stre tch in the static map, a=1, appear plotted with dashed lines. ¯sof successful greedy paths, where the stretch is deﬁned as th e ratio between the hoplength of a greedy path and the shorte st path between the corresponding source and destination node s. The stretch tells us how much the successful greedy paths a re longer with respect to the shortest ones. In the Supplementary Material, we also give results for the a verage geometric stretch sg, which is deﬁned analogously to s but considering the hyperbolic lengths of greedy and shorte st paths; and the average coverage κ, which informs of the average number of different visited nodes against the average numbe r of nodes that compound a successful path. 2.1 Effects of network dynamics on navigability The success ratio psis a key parameter in determining the navigability of comple x networks. A large success ratio, close to ps∼1, means that almost all nodes can be reached by a message sent by any other node. On the contrary, if psis small, information can not be successfully transmitted from most n odes. Fig. 1, top row, shows the fraction of successful paths psas a function of the network duration T, for different values of the activation probability a. The success ratio varies considerably across different static networks ( a=1), ranging from very low success ratio for the ArXiv, to ps∼1 for the WTW and the Internet, which indicates a better congruence of these syst ems with their underlying geometry. Remarkably, for sufﬁci ently large T, the success ratio in all temporal networks ( a<1) under consideration is always larger than the one achieve d on their static counterparts (dashed line, top row Fig. 1and Table 1in Methods). This effect is particularly evident for the cas es where psin the static map is rather low, such as for the ArXiv network, where the success ratio increases from ps=0.24 for a=1 tops=0.90 for a∼0.2. Nonetheless, when the static success ratio is high (e.g. I nternet), pson the temporal maps increases too. As expected, psis a growing function of the network duration T: the larger the maximum lifetime of the packets, the higher ps. In the limit of T→∞,psis expected to reach its maximum since, for any pair of nodes, all different paths between them will be available at some time, ensuring that a successf ul one will certainly arise. This implies that the success ra tio always increases with T, although the growing rate can be extremely slow for very lar geT. Oppositely, in the routing on static networks, psdoes not vary with Tbecause no new paths are added by increasing the lifetime of i nformation packets. Our results show that, surprisingly, it is more efﬁcient to h ave some (or even a great number of) nodes inactive than havin g all nodes active and contributing to the routing process. Th e reason for this behavior is rooted in the fact that, with a=1, some packets might get stuck into topological traps . From the greedy routing deﬁnition, indeed, it is clear that if a packet comes back to a node twice, it will come back again, and the loo p would continue forever with the packet never reaching its destination. To understand this mechanism, consider a node isending a packet to his neighbor j, because jis the closest (among all i’s neighbors) to destination node k. If during the next time step, node iturns out to be the closest node to destination kamong j’s neighbors, then the packet will return to i. As long as no topological change takes place in the network, this process will repeat endlessly. Any cycle involving a packet coming back to a node twice constitutes a topological trap, See Fig. 2. In contrast, ifa<1, the topology of the network changes at each time step, henc e the packet is able to escape any topological traps it 3/10Figure 2. Representation of a topological trap, in Euclidean space. Greedy routing demands sending the info rmation packet always to the neighbor closest to destination. Conse quently, in a)the packet never stops jumping between nodes iand jand is captured by the topological trap, while in b)the inactivation of ienables the packet to follow an alternative route through land successfully reach destination node k. may encounter along the route and eventually reach its desti nation. Nevertheless, the new successful path followed by t he packet will deviate from the geodesic connecting the two nod es in the hyperbolic plane, thus the path length will necessa rily be longer than the shortest. The average topological stretch s, deﬁned as the ratio between the hoplength of greedy paths a nd the corresponding shortest paths in the network, is also a measure of navigatio n efﬁciency. From its deﬁnition, it holds that s≥1. A small stretch, s/greaterorsimilar1, indicates that most packets follow a route very close to th e shortest one, while if s≫1, paths are much longer. Fig.1, bottom row, shows the average stretch sas a function of the network’s duration T, for different values of the activation probability a. As for the success ratio, sis also an increasing function of T. Indeed, the larger the duration T, the lengthier the paths that become successful, and these very long paths incr ease the average stretch. It is important to note that the shortest paths between two no des in M(G,S)may be much longer than the shortest path in the corresponding static maps, because of timerespecti ng paths. This is particularly true for very sparse temporal networks, i.e. with low activation probability. Therefore, sis always greater in temporal maps than in the corresponding static ones, as shown in Fig. 1, demonstrating that the activation dynamics is responsibl e for creating lengthier successful paths. This effect is clearly visible in those data sets where psin the static networks is low, such as the ArXiv or Commoditie s. In these networks, the large increase in the success ratio du e to the activation dynamics comes with a large growth in the average stretch. The probability of ﬁnding much more succes sful tracks is increased at the cost of choosing longer paths . On the contrary, if psin the static maps is high, such as for the Internet or the WTW, sshows a small increase in the temporal maps. These different proﬁles correspond to the di fferent geometricity of the considered networks. In fact, t he less congruent topology and geometry are, the larger the num ber of topological traps present in M(G,S)and the larger the potential increase in success. Temporal maps with limited c ongruency, such as ArXiv or Commodities, show the larger gai ns in success overcoming traps at the expenses of a notable incr ease in s, and longer durations T. On the contrary, networks with a conspicuous latent geometry, like the Internet and the WTW , are not characterized by a large number of topological trap s, hence sdoes not rise as much. Interestingly, different effects are obtained on the succe ss ratio and the stretch depending on the activation probabi lity. The lowest values of sare found for intermediate values of a, while psgenerally increases as the activation probability decreas es, down to a value for which the network becomes too inactive, an d then psbecomes lower again. In most networks, psremains almost unchanged if the activation probability is set equal toa=0.3 or to a=0.1 in the limit of large T, while ssigniﬁcantly increases if the activation decreases from a=0.3 toa=0.1, specially for the Internet and the WTW. Conversely, choos ing a=0.6,psgrows from 0.96 in the static case to 0.99 for the Internet and from 0.99 to 0.997 in the WTW, but the stretch increases very little from s=1.11 to s≈1.76 for the Internet, and from s=1.04 to s≈1.29 for the WTW. This indicates it may exist an optimal activation probability that maximizes the increase in the success ratio and minimizes the increase in the stretch. 4/100 0.5 1 a060120s1000 3000 5000 7000 9000Arxiv 0 0.5 1 a03060Commodities 0 0.5 1 a01530Metabolic 0 0.5 1 a048Internet 0 0.5 1 a036WTW 0 0.5 1 a0.000.030.05ps / s 0 0.5 1 a0.000.070.14 0 0.5 1 a0.000.120.25 0 0.5 1 a0.000.350.70 0 0.5 1 a0.000.501.00 Figure 3. Average stretch, s(top row), and success ratio divided by the average stretch, ps/s(bottom row) as a function of a. Each curve corresponds to a different value of the duration T. Notice the rightmost point is not 1 (the static reference) but 0.96. The optimal activation aOof each network is observed as a maximum in the plots of the bot tom row. The approximate values of aOfor each network are: aArx O≈0.25,aCom O≈0.25,aMet O≈0.33,aInt O≈0.60 and aWTW O≈0.67. 2.2 Optimal activation probability Top row of Fig. 3shows sas a function of the activation probability a, for several values of the network’s duration T. Inter estingly, the average stretch is not a strictly decreasing f unction of a, but it reaches a minimum for some intermediate value. On one hand, when the activation probability is very small, t he stretch is typically large because of the lack of availabl e active neighbors. The packet will usually remain in the holding nod e or it will be transferred erratically, resulting in an incr ease of s. On the other hand, if a/lessorsimilar1, the topology of M(G,S)is similar to the static one, so the packet tends to fall into t he same topological traps spending a long time moving in cycles (thu s increasing the stretch) before it succeeds to escape the lo op. Remarkably, the minimum of sis reached for some optimal value of the activation probabil ity,a=aO. This feature is addressed in more detail in the bottom row of F ig.3, which shows the ratio between the success ratio and the average stretch ( ps/s) as a function of the activation probability a. Since ps/lessorequalslant1 and s/greaterorequalslant1 by deﬁnition, perfect navigability is reached when ps=s=1, and thus ps/s=1. The ratio ps/srepresents a measure of the tradeoff between the increase i n both the success ratio and the stretch. The larger the ratio, the more efﬁcient the navigation. For each network under consideration, it exists an optimal v alue aOof the activation probability that maximizes the trade off between success ratio and stretch. For the ArXiv and the C ommodities, the curves of the ratio ps/sas a function of a depend on the duration T, with larger ps/sfor smaller T, while for the Internet and the WTW, these curves are indepen dent ofTand collapse. Fig. 3shows that the WTW combines the largest success ratio with th e smallest stretch, followed by the Internet, Metabolic, Commodities and the ArXiv networks. However, it is important to remark that the ps/sratio is always higher for the static maps than for the tempor al ones. For instance, the static value for the Internet is ps/s=0.87 (see Tab. 1in Methods), while in the temporal network it does not exceed 0.70. This is due to the fact that, in temporal maps the large gai n in success, which is bounded with a top value of 1, necessarily comes with an increase in stretch, which in fa ct can be quite limited, as for the Internet or the WTW, but is unbounded. 2.3 Heterogeneous activation dynamics In this section, we analyse how navigation is affected by an a ctivation probability which varies across nodes. We do it in two different fashions: i) constant activation probability a<1 only for nodes whose degree belongs to a certain interval, a nd ii) activation probability linearly depending on nodes’ degre es. 2.3.1 Activation of nodes within degree intervals Here, the random activation dynamics is targeted to subsets of equal number of nodes with degrees in a certain range of val ues. We measure the success ratio when only one of these subsets of nodes is randomly activatedinactivated with constant aand the rest of the network remains active. To implement this pre scription, we order all nodes in a network from highest to low est degree and divide this sorted list in segments of same number of nodes. The node bins are then labeled using the average 5/100 5000 10000 T0.50.60.70.8psArxiv 0 5000 10000 T0.850.900.951.00Commodities 0 5000 10000 T0.920.940.950.97Metabolic 0 5000 10000 T0.9840.9870.9900.993Internet 0 5000 10000 T050100s 0 5000 10000 T03570 0 5000 10000 T0714 0 5000 10000 T048 0 1000 2000 T0360 1000 2000 T0.9900.9951.000 b>0 b=0 b<0WTW Figure 4. Success ratio ps(top row) and average stretch s(bottom row) as a function of Tfora=0.5, see Fig. S4 in SM for other values of a. Solid lines designate constant activation of nodes, while symbols indicate that nodes activate linearly and proportionally to their degree ( b>0), or inversely proportional ( b<0). The minimum and maximum activation probabilities allowed are 10−3and 1−10−3respectively. As a reference, the values for the static netw orks, a=1, are given in Table 1in Methods. degree kof the nodes belonging to that bin. The size of the bins has bee n set to ξ=5% of the total number of nodes N. This method aims at identifying which degree intervals have a major contribution to the destruction of topological trap s, and hence specially boost the success. We ﬁnd that all tempor al maps M(G,S)experience a sudden increase in pswhen k is at its maximum, see Fig. S2 in SM. In scalefree networks, n ode degrees are distributed as a powerlaw p(k)∼k−γ(theγ values for the considered networks are reported in Table 1, Methods). This means that the interval kmaxcontains not only the biggest hub but also several densely connected nodes. There fore, our results imply that switching on and off nodes with l ow degree has a limited effect on the efﬁciency of navigation. I n fact, the higher the degree of a node the more radical the cha nges it can induce in the direction of a greedy path. When we construct the bin with temporal behaviour by samplin g the nodes uniformly at random from any part of the degree spectrum, so that the bin is approximately character ized by the kof the entire network, we ﬁnd a low psclose to the static and similar to that obtained for bins of low degree nod es. Therefore, not all nodes are equally able of beating topo logical traps, and the increase in success mostly relies on activati on dynamics affecting densely connected nodes. Also, notic e that activating with a<1 some randomly selected nodes is not equivalent to activati ng the whole network with the corresponding average probability a=1−ξ(1−a). This is due to the fact that, while navigating the network, s ome nodes are visited more often than others. If all visited nodes can activate with som ea<1, the actual noise affecting the network becomes effective ly greater than in our implementation. When information packets are able to escape cycles, and the s uccess rises due to the emergence of new (lengthier) success  ful paths, the average stretch increases too. We corroborat e this statement in the bottom row of Fig. S2 in SM, which shows that the maximum stretch precisely occurs at kmaxin all networks. As expected, the highest sis always found for the minimum activation a=0.1, which corresponds to the situation where packets ﬁnd most nodes along their routes to be inactive so they are constantly redirected, thus producing long greedy path s. Interestingly, at kmaxthesfora=0.9 considerably varies across networks, with the ArXiv exhibiting the highest value, then Commodities, Metabolic, Internet and ﬁnally the WTW. This supports the idea that more congruent networks posess less t opological traps. In general it is also satisﬁed that avalues around aOdisplay lower satkmax. 2.3.2 Linear activation depending on degree Here, we study the navigability of temporal maps in which the activation probability of a node i,ai, depends linearly on its degrees ki, such as a(k)=bk+c. (1) 6/10Forb>0, the activation probability is proportional to the node’s degree so the larger the degree the more active is the node; ifb<0, the activation probability is inversely proportional to k, and if b=0 we recover the case of constant activation probability. The average activation probability aof the whole network, a=N−1∑N i=1ai(k), varies depending on the choices of the coefﬁcients bandc. We set the average activation probability aas an independent parameter, and choose cso that c=a−bk. The constraints for the coefﬁcient barise from the network’s minimum and maximum degree, kminandkmax, respectively, as b≤min/braceleftbigg1−a (kmax−k),−a (kmin−k)/bracerightbigg ifb>0 |b|≤min/braceleftbigg−(1−a) (kmin−k),a (kmax−k)/bracerightbigg ifb<0. For each network under consideration, we choose two values o f the coefﬁcient b(one positive and one negative) that ensure the highest heterogeneity in the activation probability, w ithout completely inactivating any of the nodes, i.e. a(kmin)>0 and a(kmax)>0. Details regarding the choice of the coefﬁcient can be foun d in the SM. Figure 4shows the effects of a heterogeneous activation probabilit y of nodes, both proportionally ( b>0) and inversely proportional ( b<0) to their degree k, compared with constant activation probability ( b=0), for a=0.5. We observe that when the activation probability is proportional to k, allM(G,S)tend to exhibit lower success ratios than in the case with the same abut constant activation probability. This effect can be und erstood by considering that highly connected nodes are visited more often than the rest during the routing process. Consequently, the system exhibits an effective ahigher than 0 .5, which induces lower psvalues (closer to the static reference) as shown in previous results. The same reasoning explains the observed behaviour of the stretch sin bottom row of Fig. 4. For all networks and when b>0, the tendency of sis comparable to that found for a>0.5 in the constant activation case, see bottom row Fig. 1. This feature is specially noticeable for the Internet, where sgrowth is similar to the obtained for a=0.9. On the opposite situation, for b<0, when the activation probability gets lower as nodes becom e more connected, the reversed phenomenon occurs. Figure 4(bottom row) shows that for all M(G,S), the sresembles that found for low constant a’s. Moreover, a small increase in pswith respect to b=0 is visible for the ArXiv, the Commodities, and the Metaboli c networks in top row of Fig. 4. The cause is an effective overall activation a<0.5. For the Internet, psstill grows higher for b<0 than for b=0, though it is barely appreciable, and it requires large T. For the WTW, psreaches 1 for any bso we can not observe an incremented ps. However, we note that psgrowth for the WTW is retarded when b<0, just as happens for the Internet. In these two last networks, the inﬂuence of the largest hub on the routing performance is remarkable due to t heir strong hierarchical nature. For this reason, the time Tneeded for achieving ps∼1 is noticeably enlarged in the event that the main hub is poorly activated. 3 Discussion Navigability is a primary function in many complex networks that, as we have shown, can be strongly affected by temporal alterations in the activity of nodes. The interplay between the activation dynamics generating the temporal networks a nd the greedy routing process, indeed, yields a rich phenomenolog y. The activation process can be understood as the result of r andom events, like service failures, or, alternatively, it could be thought as part of a local information transfer protocol a pplied by the node holding the packet in a static network, so to boost the su ccess of the routing operation at a limited cost. Our results show that, surprisingly, temporal maps can be na vigated more efﬁciently than the corresponding static ones , even though the number of simultaneously available paths to transfer the packets is greatly reduced. Interestingly, th e number of successful paths, in which the packet reaches its destina tion, is increased due to the activation dynamics. This incr ease in the success ratio pscomes at the cost of a growth in the stretch ¯ s, meaning that longer paths are required to successfully deliver the packet. However, the ratio between the success a nd the stretch, ps/¯s, shows a nontrivial behavior as a function of the activation probability, unveiling the existence of an o ptimal value which maximizes the increase in the success and at the same time minimizes the increase in the stretch. More realistic forms of the activation probability, i.e., w hen the dynamics only affects a subset of nodes or when the activation is correlated with the degree, show similar resu lts. This analysis uncovered the role of highly connected no des in the routing process, which are mainly responsible for the larger success ratio achieved in temporal maps. Contrary to expectations, our ﬁndings suggest that it is possible to imp rove the routing performance by switching on and off the hubs of the network more often than the rest of the nodes. Finally, th e navigability of some real networks, like the Internet and t he WTW, remains extremely high in the temporal maps. In fact, ti mevarying effects increase even more the high success rate associated to the static maps, at the cost of a very small incr ease in the stretch, slowly growing with T, a feature that we n ame ultranavigability. Even more, temporal changes in the stru cture of these networks increase the success even if the acti vation 7/10probability is very low. At the same time, the high routing su ccess observed in these networks could be due in part to tempo ral behavior in the system, although this possibility has not be en acknowledged before and all the merit for their navigabil ity properties has been accredited to their static architectur e. Our work sets a ﬁrst attempt to measure the effects of tempora l dynamics on the navigability of real networks. It has been increasingly recognized, indeed, that networks are dynami c entities that evolve in time, with connections being estab lished and terminated for different reasons. This study paves the w ay towards a better understanding of the role of the network’ s temporal dimension in navigation processes, and provides h ints for developing better routing strategies exploiting s uch dynam ics. Further research is in order to extend our results. One m ay consider more sophisticated generative models of tempor al networks, that may, for instance, incorporate a bursty dyna mics of links or nodes. 4 Methods "
34,Max-min Fair Rate Allocation and Routing in Energy Harvesting Networks: Algorithmic Analysis.txt,"This paper considers max-min fair rate allocation and routing in energy
harvesting networks where fairness is required among both the nodes and the
time slots. Unlike most previous work on fairness, we focus on multihop
topologies and consider different routing methods. We assume a predictable
energy profile and focus on the design of efficient and optimal algorithms that
can serve as benchmarks for distributed and approximate algorithms. We first
develop an algorithm that obtains a max-min fair rate assignment for any given
(time-variable or time-invariable) unsplittable routing or a routing tree. For
time-invariable unsplittable routing, we also develop an algorithm that finds
routes that maximize the minimum rate assigned to any node in any slot. For
fractional routing, we study the joint routing and rate assignment problem. We
develop an algorithm for the time-invariable case with constant rates. We show
that the time-variable case is at least as hard as the 2-commodity feasible
flow problem and design an FPTAS to combat the high running time. Finally, we
show that finding an unsplittable routing or a routing tree that provides
lexicographically maximum rate assignment (i.e., that is the best in the
max-min fairness terms) is NP-hard, even for a time horizon of a single slot.
Our analysis provides insights into the problem structure and can be applied to
other related fairness problems.","Figure 1: A simple energy harvesting net work: the nodes sense the environment and forward the data to a sink s. Each node has a battery of capacity B. At timeta node i's battery level is bi;t, it harvests ei;tunits of energy, and senses at data rate i;t.Recent advances in the development of ultralowpower transceivers and energy harvesting devices (e.g., solar cells) will enable selfsustainable and perpetual wireless networks [11, 14, 15]. In contrast to legacy wireless sensor networks, where the available energy only decreases as the nodes sense and forward data, in energy harvesting networks the available energy can also increase through a replenishment process. This results in signicantly more complex variations of the available energy, which pose challenges in the design of resource alloca tion and routing algorithms. The problems of resource allocation, scheduling, and rout ing in energy harvesting networks have received considerable attention [2, 4, 9, 12, 13, 16{18, 23, 24, 29, 32, 34]. Most existing work considers simple networks consisting of a single node or a link [2,4,13,16,29,34]. Moreover, fair rate assignment has not been thoroughly studied, and most of the work either focuses on maximizing the total (or average) through put [2,4,9,12,18,23,27,29,32,34], or considers fairness either only over nodes [24] or only over time [13,16]. An exception is [17], which requires fairness over both the nodes and the time, but is limited to two nodes . In this paper, we study the maxmin fair rate assignment and routing problems, requiring fairness over both nodes and time slots, and with the goal of designing optimal and ecient algorithms. 1arXiv:1406.3671v2  [cs.NI]  9 Nov 2014Following [9,13,16,17,23,24], we assume that the harvested energy is known for each node over a nite time horizon. Such a setting corresponds to a highlypredictable energy prole, and can also be used as a benchmark for evaluating algorithms designed for unpredictable energy proles. We consider an energy harvesting sensor network with a single sink node, and network connectivity modeled by a directed graph (Fig. 1). Each node senses some data from its surrounding (e.g., air pressure, temperature, radiation level), and sends it to the sink. The nodes spend their energy on sensing, sending, and receiving data. 1.1 Fairness Motivation Two natural conditions that a network should satisfy are: (i) balanced data acquisition across the entire network, and (ii) persistent operation (i.e., even when the environmental energy is not available for harvesting). Figure 2: An example of a network in which throughput maximization can result in a very unfair rate allocation among the nodes.The condition (i) is commonly reinforced by requiring fair ness of the sensing rates over network nodes. We note that in the network model we consider, due to these dierent en ergy costs for sending, sensing, and receiving data, throughput maximization can be inherently unfair even in the static case. Consider a simple network with two energy harvesting nodes aandband a sink sillustrated in Fig. 2. Assume that ahas one unit of energy available, and bhas two units of energy. Let cstdenote the joint cost of sensing and sending a unit  ow, crt denote the joint cost for receiving and sending a unit  ow. Let aandbdenote the sensing rates assigned to the nodes aandb, respectively. Suppose that the objective is to maximize a+b. Ifcst= 1,crt= 2, then in the optimal solution a= 1 andb= 0. Conversely, ifcst= 2,crt= 1, then in the optimal solution a= 0 andb= 1. This example easily extends to more general degenerate cases in which throughputmaximum solution assigns nonzero sensing rates only to one part of the network, whereas the remaining nodes do not send any data to the sink. One approach to achieving (ii) is by assigning constant sensing rates to the nodes. However, this approach can result in underutilization of the available energy. As a simple example, consider a node that harvests outdoor light energy over a 24hour time horizon. If the battery capacity is small, then the sensing rate must be low to prevent battery depletion during the nighttime. However, during the daytime, when the harvesting rates are high, a low sensing rate prevents full utilization of the energy that can be harvested. Therefore, it is advantageous to vary the sensing rates over time. However, fairness must be required over time slots to prevent the rate assignment algorithm from assigning high rates during periods of high energy availability, and zero rates when no energy is available for harvesting. 1.2 Routing Types We consider dierent routing types, which are illustrated in Fig. 3. (a) Routing tree.  (b) Unsplittable routing.  (c) Fractional routing. Figure 3: Routing types: (a) a routing tree, (b) unsplittable routing: each node sends its data over one path, (c) fractional routing: nodes can send their data over multiple paths. Paths are represented by dashed lines. Each routing type incurs dierent tradeos between the supported sensing rates1and the required amount of control information. Routing types with higher number of active links require more control 1A metric of performance can be the minimum sensing rate that gets assigned to any node in any time slot. 2Figure 4: A network example in which unsplit table routing provides minimum sensing rate that is  (n) higher than for any routing tree. Assume cst=crt= 1 andT= 1. Available energies at all the nodes ai,i2 f1;:::;kgare equal to 1, as shown in the box next to the nodes. Other nodes have energies that are high enough so that they are not constraining. In any routing tree, b has someaias its parent, so ai=b=c1= :::=ck"
141,Experimentation with MANETs of Smartphones.txt,"Mobile AdHoc NETworks (MANETs) have been identified as a key emerging
technology for scenarios in which IEEE 802.11 or cellular communications are
either infeasible, inefficient, or cost-ineffective. Smartphones are the most
adequate network nodes in many of these scenarios, but it is not
straightforward to build a network with them. We extensively survey existing
possibilities to build applications on top of ad-hoc smartphone networks for
experimentation purposes, and introduce a taxonomy to classify them. We present
AdHocDroid, an Android package that creates an IP-level MANET of (rooted)
Android smartphones, and make it publicly available to the community.
AdHocDroid supports standard TCP/IP applications, providing real smartphone
IEEE 802.11 MANET and the capability to easily change the routing protocol. We
tested our framework on several smartphones and a laptop. We validate the MANET
running off-the-shelf applications, and reporting on experimental performance
evaluation, including network metrics and battery discharge rate.","Although Internet connectivity is nearly ubiquitous, there are many situations in which using infrastructureless commu nication is better than an IEEE 802.11 hotspot or cellular communication, because the latter are either infeasible, inef ﬁcient, or cost ineffective. For example, in remote areas, e.g. forests, ocean, or in catastrophe scenarios [ 1], [2], there is simply no infrastructure to provide connectivity. Or in social upraise scenarios, in which the infrastructure cannot be trusted, as the use of Open Garden1shows. A more leisurely example is low latency gaming [ 3], [4] or sharing a ﬁle with acquaintances. Another application scenario could be group communication in mass events, like conferences or concerts [ 5], in which infrastructure may be unable to support all communication demand. For all these reasons, wireless adhoc networking was identiﬁed as a major emerging technology at the ""Internet on the Move"" workshop [6] and by Conti et al. [7]. Although smartphones are privileged network nodes in the people centric scenarios mentioned above, work in this direction lies primarily in the ﬁeld of middleware for distributed applications, whereby connectivity is blindly assumed up to few exceptions like Haggle [ 8], and only a few provide support for smartphones. Recently, application frameworks that leverage WiFi Direct or cooperation between IEEE 802.11 and Bluetooth (BT) appeared. But those solutions do not create an IPlevel network, require overlay routing for multihop communication, and applications need to be adapted to a speciﬁc framework 1http://opengarden.com/aboutApplication Programming Interfaces ( APIs). IPlevel multihop networking makes the difference in scenarios where latency is critical, and where communication with other IP enabled devices like laptops or PCs is wanted. Moreover, it is completely transparent to applications, which just use the sockets API. In this paper, we review work on MANET s of smartphones, and proceed to extensively survey solutions that claim to provide adhoc connectivity for smartphones (section II) We then introduce AdHocDroid to turn smartphones into nodes of an IPlevel mobile adhoc network. A MANET of Android smartphones enables simpliﬁed instantiation of a testbed for experimental evaluation of routing protocols, data dissemination, distributed applications, etc. [ 9]. We describe how to set up an IPlevel 802.11 adhoc network with multihop capability on smartphones running the Android Operating System ( OS), and share lessons learned (section III). Our purpose is to advance MANET experimentation by enabling easy testing on MANET network protocols. Then, we introduce a taxonomy of MANET features and use it to characterize the surveyed solutions and AdHocDroid (section IV). Finally, we experimentally validate AdHocDroid running applications on the network, and evaluating network performance (throughput and latency) and battery consumption (section V). II. R ELATED WORK "
205,Fair and Throughput-Optimal Routing in Multi-Modal Underwater Networks.txt,"While acoustic communications have been considered the prominent technology
to communicate under water for several years, other technologies are being
developed based, e.g., on optical and radio-frequency electro-magnetic waves.
Each technology has its own advantages and drawbacks: for example, acoustic
signals achieve long communication ranges at order-of-kbit/s bit rate, whereas
optical signals offer order-of-Mbit/s transmission rates but only over short
transmitter--receiver distances. Such a technological diversity can be
leveraged by multi-modal systems, which integrate different technologies and
provide intelligence to decide which one should be used at any given time. In
this paper, we address a fundamental part of this intelligence by proposing a
novel routing protocol for networks of multi-modal nodes. The protocol makes
distributed decisions about the flow in each link and over each technology at
any given time, in order to advance a packet towards its destination. Our
routing protocol prevents bottlenecks and allocates resources fairly to
different nodes. We analyze the performance of our protocol via simulations and
in a field experiment. The results show that our protocol successfully
leverages all technologies to deliver data, even in the presence of imperfect
topology information. To permit the reproduction of our results, we share our
simulation code.","Several different physical layer (PHY) technologies have been developed to communicate under water. While most of them rely on acoustic communications at different frequencies and over different bandwidths [1], optical communications are also gaining momentum [2], [3], [4], and recent work suggests that radiofrequency (RF) electromagnetic communications are also ﬁnding their way into research interests [5] and system development [6]. Novel system architectures based on electrostatic ﬁelds [7] and magnetoinductive communications [8] are also being explored, albeit these technologies are still in their infancy compared to acoustics, optics, and electromagnetics. Each of the above underwater PHY technologies offers a different balance of advantages and disadvantaged. The most prominent differences between underwater acoustic and optical commu nications, for instance, concern the data rate and the communications range. Acoustics typically provides low (orderofkbit/s) transmission rates, but can cover ranges up to several km. However, the performance of underwater acoustics is highly inﬂuenced by the environment, especially by strong and timevarying multipath. Underwater optical communication, on the other hand, provides a very high bandwidth on the order of up to several Mbit/s, but requires the transmitter and receiver to be very close, typically up to a few m apart, and their transceivers to be aligned within each other’s ﬁeld of view. In addition, optical communications are sensitive to turbidity and tend to work best in dark waters. By way of contrast, RF communications do not need any alignment and can be developed based on very standard hardware already used for terrestrial radio systems; however, the conductivity of ocean waters attenuates RF waves within very short distances, and limits the achievable bit rates to less than 100 kbit/s within a distance of a few tens of m [5]. The above analysis suggests that there is a lot of potential in the integration of different PHYs into a multimodal communication system. Such a system may be able to exploit the advantages of different technologies by transmitting through the best available one at any given moment. This approach was proposed, e.g., in [9]. After comparing the declared performance of the technologies available at the time, the authors concluded that a system encompassing optical and acoustic communications would be a good candidate for the wireless control of remotely operated vehicles. Notably, recent work [10] supports the vision of multimodal systems by showing that embedded3 processing platforms have sufﬁciently evolved to host the signal processing algorithms of acoustic communication systems on generalpurpose computing platforms. This means that both the com plexity and the versatility of these systems is already borne easily by current hardware, making multimodal communications de facto possible already with current technology. A key role, in multimodal communication systems, is played by the logic that decides how to switch between the available PHYs. While multimodal pointtopoint links are manageable with relatively simple policies [11], organizing multimodal nodes into a network requires a complete change of perspective. In fact, the nodes may connect to different neighbors using (possibly partially overlapping) subsets of their PHYs. These subsets may change over time according to a variety of circumstances, that depend, e.g., on environmental conditions, mobility, and on the trafﬁc requirements of the nodes. In this paper, we design a speciﬁc component of the multi modal PHY usage logic: the multihop routing algorithm. We aim to provide a routing solution that fully utilizes the available PHY technologies in an optimized fashion. Speciﬁcally, by considering the different PHY technologies as another layer of network resources, we formalize the routing problem as a maximization problem where each node tries to extract the most from all its available PHYs. The solution to this problem leads to a routing protocol that is distributed and fair, and avoids bottlenecks. Our algorithm is valid in any network topology, and can be applied to any combination of available PHY technologies, including when different nodes incorporate different technologies. Our contribution is twofold: A novel distributed routing algorithm for multimodal underwater networks, which maximizes the amount of information transmitted through all technologies available to each node, while at the same time balancing the trafﬁc ﬂow through the network and pursuing a fair network utilization for all nodes; A framework to handle both the cases where incomplete and complete topology information is available to each node. We evaluate the performance of our routing algorithm by means of numerical simulations and in several ﬁeld experiments performed in a lake north of Berlin with multimodal nodes embedding4 different acoustic modems. To the best of our knowledge, this is the ﬁrst reported trial for multi modal routing schemes. The remainder of this paper is organized as follows. Section II discusses related work; Section III presents and formalizes our routing algorithm; Section IV describes our simulation scenario and discusses the simulation results; Section V reports the results of the ﬁeld experiments; Section VI draws concluding remarks. II. R ELATED WORK "
350,AODVSEC: A Novel Approach to Secure Ad Hoc on-Demand Distance Vector (AODV) Routing Protocol from Insider Attacks in MANETs.txt,"Mobile Ad hoc Network (MANET) is a collection of mobile nodes that can
communicate with each other using multihop wireless links without requiring any
fixed based-station infrastructure and centralized management. Each node in the
network acts as both a host and a router. In such scenario, designing of an
efficient, reliable and secure routing protocol has been a major challenging
issue over the last many years. Numerous schemes have been proposed for secure
routing protocols and most of the research work has so far focused on providing
security for routing using cryptography. In this paper, we propose a novel
approach to secure Ad hoc On-demand Distance Vector (AODV) routing protocol
from the insider attacks launched through active forging of its Route Reply
(RREP) control message. AODV routing protocol does not have any security
provision that makes it less reliable in publicly open ad hoc network. To deal
with the concerned security attacks, we have proposed AODV Security Extension
(AODVSEC) which enhances the scope of AODV for the security provision. We have
compared AODVSEC with AODV and Secure AODV (SAODV) in normal situation as well
as in presence of the three concerned attacks viz. Resource Consumption (RC)
attack, Route Disturb (RD) attack, Route Invasion (RI) attack and Blackhole
(BH) attack. To evaluate the performances, we have considered Packet Delivery
Fraction (PDF), Average End-to-End Delay (AED), Average Throughput (AT),
Normalized Routing Load (NRL) and Average Jitter and Accumulated Average
Processing Time.","Mobile Ad hoc Network (MANET) is a collection of mo bile nodes which establish a network  spontaneously and communicate over a shared wireles s channel without any predeployed       infrastructure and mostly decentralized management [1]. In an ad hoc network, security is       became a key requirement now a days. As the communi cation is done via shared wireless      media, it is highly vulnerable to many security thr eats. In this particular case, security can be  thought for two occurrences viz. Data communication  and Routing message relays. Securing  data communication is very much easy using pointto point and/or endtoend security         techniques, but the major concerns are resided with in the security of routing message as these  messages ultimately form a route to pass the data p ackets between two ends. Thus, routing    International Journal of Computer Networks & Commun ications (IJCNC) Vol.4, No.4, July 2012  192       protocol itself has to be secured and none of the b asic protocols are given with security          provision.  In this paper, we have demonstrated Active Forge ex ploits that are possible against the AODV  protocol and have offered a secure solution using a  simple cache concept to provide security  from the malevolent nodes.  The rest of this paper is organized as follows: Sec tion 2 describes the fundamental working of  AODV. Section 3 elaborates the concerned security i ssues in AODV. Our related study is kept  in Section 4. Section 5 provides the complete under standing of our proposed approach to     modify AODV protocol. Section 6 and Section 7 show our Methodology for evaluation and     results of our Simulation in NS2.33 along with its  Graphs respectively. We have concluded this  paper in Section 8 followed by the vital references  for our research work.   2. FUNDAMENTAL WORKING OF AODV  Ad hoc On Demand Distance Vector Routing (AODV) [2] [3] is a Reactive routing protocols,  which appear to be more suitable for ad hoc network s, do not maintain uptodate information  about the network topology as it is done by the pro active routing protocols like Destination    Sequenced Distance Vector (DSDV) [4] and Optimized Link State Routing Protocol (OLSR)  [5], but they create routes on demand. Among reacti ve routing protocols, the Ad hoc On       Demand Distance Vector Routing (AODV) is a very pop ular on demand routing protocol which  has been developed for MANETs and it is widely use.  AODV performance is the best           considering its ability to maintain connection by p eriodic exchange of information and we found  that AODV outperforms other routing protocol and is  viable for MANET [6]  [8].  As its name suggests, route discovery process is in itiated on demand i.e. whenever a particular  source node wants to start communication with a par ticular destination and if it is not having the  corresponding route in its routing table, it initia tes route discovery process. Route discovery  process consists of two control messages viz. Route  Request (RREQ) and Route Reply (RREP).  The source node generates RREQ message at the very first step of the discovery process and  floods that to its neighborhood. Intermediate node( s) upon having the RREQ message, makes  reverse route entry for the source node in its rout ing table and floods the same RREQ packet  further in the network.  The ultimate destination node will generate RREP pa cket in response to the received RREQ  message and sends that back to the originator of RR EQ via unicast property. Before passing the  received RREP packet towards the source node, inter mediate node(s) again updates its routing  table now for having the destination node’s forward ing entry into it. Thus, Source node can start  the actual data transmissions after receiving RREP for the concerned destination. Figure 1      depicts the fundamental working of route discovery process in AODV.   International Journal of Computer Networks & Co  Figure 1. Fundamental Working of Route Discovery Pr  One of the very important properties of AODV is that it al so allows any intermediate node(s) to  gener ate and send RREP towards the source node on behalf of   is having the fresher route to that destination node. Besid es the mentioned two control  messages, AODV uses one more to maintain the establishe d route as a part of route  main tenance process in AODV usi    3. SECURITY ISSUES WITH  In any kind of communications, security is considered as an essential requirement for making  the system much more reliable. For the same purpose, rou ting protocol in ad hoc networks is the  most important as pect that has to be secured from possible security threa ts. Widely used AODV  routing protocol is also highly vulnerable to many attacks as there is no security provision with  it and the control messages are dispatched in plain text only . Thus, a  made by forging any of its control me  In this work, we focused on the three perilous active forge attacks through fake RREPs in which  attacker actively makes use of malignant RREP message by  forgi  sequence number and/or hop count to launch the attacks  known pair of source and destination. Following subsectio ns explain the effect of the concerned  actively forged at tacks by fake RRE  3.1. R esource Consumption (RC) Attack  For achieving this particular goal, an attacker uses two  fake RREPs and further disturbs the  route as if it makes a loop in the data path resulting  into resource consumption of the  participating nodes of data path.  already established.  International Journal of Computer Networks & Co mmunications (IJCNC) Vol.4, No.4, Ju    Fundamental Working of Route Discovery Pr ocess in AODV   One of the very important properties of AODV is tha t it also allows any intermediate node(s) to  ate and send RREP towards the source node on behalf  of the ultimate destination node if it  is having the fresher route to that destination nod e. Besides the mentioned two control  messages, AODV uses one more to maintain the establ ished route as a part of route  tenance process in AODV usi ng Route Error (RERR) message.  SSUES WITH AODV  In any kind of communications, security is consider ed as an essential requirement for making  the system much more reliable. For the same purpose , routing protocol in ad hoc networks is the  pect that has to be secured from possible security threats. Widely used AODV  routing protocol is also highly vulnerable to many attacks as there is no security provision with  it and the control messages are dispatched in plain  text only. Thus, a ttacks on AODV are mainly  made by forging any of its control me ssages viz. RREQ, RREP, RERR. [9].  In this work, we focused on the three perilous acti ve forge attacks through fake RREPs in which  attacker actively makes use of malignant RREP messa ge by forgi ng the fields of destination  sequence number and/or hop count to launch the atta cks  on already established path in  known pair of source and destination. Following sub sections explain the effect of the concerned  tacks by fake RRE P and blackhole attacks.  esource Consumption (RC) Attack   For achieving this particular goal, an attacker use s two fake RREPs and further disturbs the  route as if it makes a loop in the data path result ing into resource consumption of the  participating nodes of data path. Figure 2(a) shows one example topology in which a path is Ju ly 2012  193       One of the very important properties of AODV is tha t it also allows any intermediate node(s) to  the ultimate destination node if it  is having the fresher route to that destination nod e. Besides the mentioned two control          messages, AODV uses one more to maintain the establ ished route as a part of route             In any kind of communications, security is consider ed as an essential requirement for making  the system much more reliable. For the same purpose , routing protocol in ad hoc networks is the  pect that has to be secured from possible security threats. Widely used AODV  routing protocol is also highly vulnerable to many attacks as there is no security provision with  ttacks on AODV are mainly  In this work, we focused on the three perilous acti ve forge attacks through fake RREPs in which  ng the fields of destination    on already established path in between  known pair of source and destination. Following sub sections explain the effect of the concerned  For achieving this particular goal, an attacker use s two fake RREPs and further disturbs the  route as if it makes a loop in the data path result ing into resource consumption of the              2(a) shows one example topology in which a path is        International Journal of Computer Networks & Co  Figure 2. Loop forming attack using two fake RREPs  Figure 2(b) and Figure 2(c) illustrates the fake RREP propagation by the a ttacker  node 2 and node 4 respectively. As a result, the vi ctim nodes inside the data loop would be  forced to con sume more energy in continuous data forwarding (see   3.2. Route Disturb (RD) Attack  The major goal of doing such an attack i  known pair of source and destination.  Figure 2 (a) is repeated in Figure  position of an attacker.  Figure 3.  After finding a route to node 5, as shown in  RREP to node 5 impersonating a non  tab le entry for the destination. As a result, the exis ting route is disturbed (see  new route discovery process would be e International Journal of Computer Networks & Co mmunications (IJCNC) Vol.4, No.4, Ju    Loop forming attack using two fake RREPs   2(c) illustrates the fake RREP propagation by the a ttacker impersonating  node 2 and node 4 respectively. As a result, the vi ctim nodes inside the data loop would be  sume more energy in continuous data forwarding (see  Figure 2(d)).  Route Disturb (RD) Attack   The major goal of doing such an attack i s to break or disturb the established route between   known pair of source and destination. Figure 3 shows the consequence of this attack. Above  Figure  3 (a) for showing the example of an established rou te and the    3. Route Disturb attack using a fake RREP  5, as shown in Figure 3 (b) the attacker generates and sends a fake  5 impersonating a non existing node identity forcing node 5 to change its routing  le entry for the destination. As a result, the exis ting route is disturbed (see Figure  new route discovery process would be e xpected. Ju ly 2012  194     impersonating  node 2 and node 4 respectively. As a result, the vi ctim nodes inside the data loop would be  s to break or disturb the established route between   3 shows the consequence of this attack. Above  3 (a) for showing the example of an established rou te and the  3 (b) the attacker generates and sends a fake  5 to change its routing  Figure  3 (c)) and International Journal of Computer Networks & Co  3.3. Route Invasion (RI) Attack  By means of such an attack, the attacker node invad es itself into the existing  having all data packets pass through it. To achieve  this particular goal, the attacker will first find   a route to reach the victim pair of source and dest ination.  invasion attack. Figure 2 (a) is repe  case.     Figure 4. Route Invasion attack using a fake RREP  Figure 4 (b) shows that the attacker node generates and se nds a fake RREP to the source node  forcing it to change its routing entry  the resultant data path after successful launch of this particular a  3.4. Blackhole (BH) Attack   In blackhole attack [13][14] , the malicious node waits for the neighbors to ini tiate a RREQ  packet. As the node receives the RREQ packet, it im mediately sends a false RREP packet with a  modified higher sequence number. So, that the sourc e node assumes that node is having the  fresh route towards the destination. The source nod e ignores the RREP p  other nodes and begins to send the data packets ove r malicious node. A malicious node takes all  the routes towards itself. It does not allow forwar ding any packet anywhere. This attack is called  a blackhole as it swallows all data packe International Journal of Computer Networks & Co mmunications (IJCNC) Vol.4, No.4, Ju  Route Invasion (RI) Attack   By means of such an attack, the attacker node invad es itself into the existing data path  having all data packets pass through it. To achieve  this particular goal, the attacker will first find   a route to reach the victim pair of source and dest ination. Figure 4 demonstrates the route  2 (a) is repe ated for Figure 4 (a) showing the position of attacker for this    Route Invasion attack using a fake RREP   4 (b) shows that the attacker node generates and se nds a fake RREP to the source node  forcing it to change its routing entry for reaching the destination via itself. Figure 4 (c) depicts  the resultant data path after successful launch of this particular a ttack.    , the malicious node waits for the neighbors to ini tiate a RREQ  packet. As the node receives the RREQ packet, it im mediately sends a false RREP packet with a  modified higher sequence number. So, that the sourc e node assumes that node is having the  fresh route towards the destination. The source nod e ignores the RREP p acket received from  other nodes and begins to send the data packets ove r malicious node. A malicious node takes all  the routes towards itself. It does not allow forwar ding any packet anywhere. This attack is called  a blackhole as it swallows all data packe ts. Ju ly 2012  195     data path for      having all data packets pass through it. To achieve  this particular goal, the attacker will first find   4 demonstrates the route        4 (a) showing the position of attacker for this  4 (b) shows that the attacker node generates and se nds a fake RREP to the source node  4 (c) depicts  , the malicious node waits for the neighbors to ini tiate a RREQ   packet. As the node receives the RREQ packet, it im mediately sends a false RREP packet with a  modified higher sequence number. So, that the sourc e node assumes that node is having the  acket received from  other nodes and begins to send the data packets ove r malicious node. A malicious node takes all  the routes towards itself. It does not allow forwar ding any packet anywhere. This attack is called International Journal of Computer Networks & Co  Figure 5 shows the Blackhole attack in MANETs in which, so urce node wants to send data  packets to a destination node in the network. The a ttacker replies with false reply RREP having  higher modified sequence number. So, da  the blackhole instead of the destination.  4. RELATED WORK   "
241,A Self-Stabilizing General De Bruijn Graph.txt,"Searching for other participants is one of the most important operations in a
distributed system. We are interested in topologies in which it is possible to
route a packet in a fixed number of hops until it arrives at its destination.
Given a constant $d$, this paper introduces a new self-stabilizing protocol for
the $q$-ary $d$-dimensional de Bruijn graph ($q = \sqrt[d]{n}$) that is able to
route any search request in at most $d$ hops w.h.p., while significantly
lowering the node degree compared to the clique: We require nodes to have a
degree of $\mathcal O(\sqrt[d]{n})$, which is asymptotically optimal for a
fixed diameter $d$. The protocol keeps the expected amount of edge redirections
per node in $\mathcal O(\sqrt[d]{n})$, when the number of nodes in the system
increases by factor $2^d$. The number of messages that are periodically sent
out by nodes is constant.","The Internet becomes more and more relevant for every part of our society, as people increasingly use it to interact with each other and exchange information. Common examples are realtime applications like streaming platforms, multiplayer games or social media networks that are maintained by overlay networks. The performance of these kind of systems beneﬁts from a low latency/delay. For example, experiments in [ 4] show that users issue fewer search requests when the latency on Google web servers is increased by only 100ms. For many systems there are hard deadlines on the delay that are acceptable: Multiplayer games often require serverside delays only up to 10ms, because any higher delay would reduce the fun for the players drastically. To keep the delay low, we require an overlay network to form a topology with a low diameter in legal states such that requests can be delivered quickly to the correct entity. Reaching a legal state can be guaranteed if the system isselfstabilizing , i.e., the system is able to recover from illegal states. We are interested in selfstabilizing systems that are able to route requests to their target as fast as possible even under a large number of participants. For example, routing in a simple line structure takes Θ(n)hops, whereas routing in a de Bruijn graph can be done in O(logn)hops. Both of these structures have only a constant node degree. If the degree of the nodes is much higher, i.e., in a clique, routing can be done way more eﬀectively: We can send requests to their destination in only one hop, since every node is connected to every other node in the system. The drawback here is that nodes have to maintain a large number of outgoing edges, which may be very costly, especially in systems with many participants. Our goal is ∗This work was partially supported by the German Research Foundation (DFG) within the Collaborative Research Center ""OnTheFly Computing"" (SFB 901). ©Michael Feldmann and Christian Scheideler; licensed under Creative Commons License CCBY Leibniz International Proceedings in Informatics Schloss Dagstuhl – LeibnizZentrum für Informatik, Dagstuhl Publishing, GermanyarXiv:1708.06542v2  [cs.DC]  15 Dec 20171:2 A SelfStabilizing General De Bruijn Graph to develop a selfstabilizing protocol for a network, in which the node degree is lower than the node degree in the clique, but still enables to route requests to their destination in a constant number of hops w.h.p. Given a constant d∈N,d≥2, our network has a diameter of at most d(w.h.p.) in every legitimate state. As a network topology, we use the qary ddimensional de Bruijn graph ( q=d√n), called general de Bruijn graph, which was ﬁrst presented in [ 14]. The selfstabilizing protocol consists of a combination of subprotocols: We combine the sorted list with the qconnected list, the standard de Bruijn graph and the qary de Bruijn graph. For the resulting structure it holds that each node has an outdegree ofO(d√n), which is asymptotically optimal for a ﬁxed diameter d. 1.1 Model We model a distributed system as a directed graph G= (V,E)withn=|V|. Each peer in the system is represented by a node v∈V. Each node v∈Vcan be identiﬁed by its unique reference or its unique identiﬁer v.id∈N(called ID). Additionally, each node vmaintains local protocolbased variables and has a channelv.Ch, which is a systembased variable that contains incoming messages. The message capacity of a channel is unbounded and messages never get lost. If a node uknows the reference of some other node v, thenucan send a messagemtovby putting mintov.Ch. We distinguish between two diﬀerent types of actions: The ﬁrst type is used for standard procedures and has the form /angbracketleftlabel/angbracketright(/angbracketleftparameters/angbracketright) :/angbracketleftcommand/angbracketright, wherelabelis the name of that action, parameters deﬁnes the set of parameters and command deﬁnes the statements that are executed when calling that action. It may be called locally or remotely, i.e., every message that is sent to a node has the form /angbracketleftlabel/angbracketright(/angbracketleftparameters/angbracketright). The second action type has the form/angbracketleftlabel/angbracketright: (/angbracketleftguard/angbracketright)−→/angbracketleftcommand/angbracketright, wherelabelandcommand are deﬁned as above andguardis a predicate over local variables. An action for some node umay only be executed if its guard is trueor if there is a message in u.Chthat requests to call the action. In both cases, we call the action enabled. An action whose guard is simply trueis called Timeout . When a node uprocesses a message m, thenmis removed from u.Ch. We deﬁne the system state to be an assignment of a value to every node’s variables and messages to each channel. A computation is an inﬁnite sequence of system states, where the statesi+1can be reached from its previous state siby executing an action that is enabled in si. We call the ﬁrst state of a given computation the initial state . We assume fair message receipt, meaning that every message of the form /angbracketleftlabel/angbracketright(/angbracketleftparameters/angbracketright)that is contained in some channel, is eventually processed. Furthermore, we assume weakly fair action execution , meaning that if an action is enabled in all but ﬁnitely many states of a computation, then this action is executed inﬁnitely often. Consider the Timeout action as an example for this. We place no bounds on message propagation delay or relative node execution speed, i.e., we allow fully asynchronous computations and nonFIFO message delivery. Our protocol does not manipulate node identiﬁers and thus only operates on them in comparestoresend mode, i.e., we are only allowed to compare node IDs to each other, store them in a node’s local memory or send them in a message. Note that we compute the hash value of a node’s identiﬁer in our protocol, but this does not manipulate the ID itself. We are interested in the formation and maintenance of a certain graph topology (which we introduce in Section 2.2) for the nodes in the distributed system. In this paper we assume that there are no corrupted IDs in the initial state of the system, otherwise we would require failure detectors to identify corrupted IDs, which exceed the scope of this paper. Thus we can assume that node IDs are always correct in all states, as our protocol is comparestoresend. Nevertheless, node channels may contain an arbitrary amount of messages containing falseM. Feldmann and C. Scheideler 1:3 information in initial states: We call these messages corrupted and we will argue that all corrupted messages will eventually be processed by our protocol. We say the system is in alegitimate (stable) state , if the nodes and the edges form the desired graph topology and there are no corrupted messages in the system. We are now ready to deﬁne what it means for a protocol to be selfstabilizing: IDeﬁnition 1 (Selfstabilization) .A protocol is selfstabilizing if it satisﬁes the following two properties: Convergence: Starting from an arbitrary system state, the protocol is guaranteed to arrive at a legitimate state. Closure: Starting from a legitimate state, the protocol remains in legitimate states there after. There is a directed edge (u,v)∈E, ifustores the reference of vin its local memory or if there is a message in u.Chcarrying the reference of v. In the former case, we call that edge explicitand in the latter case we call that edge implicit. In order for our distributed algorithms to work, we require the directed graph Gcontaining all explicit and implicit edges to stay at least weakly connected at every point in time. A directed graph G= (V,E) isweakly connected , if the undirected version of G, namelyG/prime= (V,E/prime)is connected, i.e., for two nodes u,v∈Vthere is a path from utovinG/prime. Once there are multiple weakly connected components in G, these components cannot be connected to each other anymore as it has been shown in [ 16] for comparestoresend protocols. For a graph that contains multiple weakly connected components, our protocol converts each of these components to our desired topology. Nodes may initiate search requests at any point in time. If node v initiates a search request, it enables the action Search(t), wheret∈Nis the ID of the node to be searched. We do not assume that there is always a node with ID tin the system, i.e., either the search request eventually reaches u∈Vwithu.id=t, or it reaches a node at which our routing algorithm outputs ""Failure!"". In both cases the routing algorithm terminates . 1.2 Related Work "
48,BEAD: Best Effort Autonomous Deletion in Content-Centric Networking.txt,"A core feature of Content-Centric Networking (CCN) is opportunistic content
caching in routers. It enables routers to satisfy content requests with
in-network cached copies, thereby reducing bandwidth utilization, decreasing
congestion, and improving overall content retrieval latency.
  One major drawback of in-network caching is that content producers have no
knowledge about where their content is stored. This is problematic if a
producer wishes to delete its content. In this paper, we show how to address
this problem with a protocol called BEAD (Best-Effort Autonomous Deletion).
BEAD achieves content deletion via small and secure packets that resemble
current CCN messages. We discuss several methods of routing BEAD messages from
producers to caching routers with varying levels of network overhead and
efficacy. We assess BEAD performance via simulations and provide a detailed
analysis of its properties.","ContentCentric Networking (CCN) is a relatively recent internetworking paradigm touted as an alternative current IP based Internet architecture. While IP trafﬁc consists of packets between communicating endpoints, CCN trafﬁc is comprised of explicit requests for, and responses to, named content objects. An important features of namebased content retrieval is decoupling of content from its producer. This enables more natural content distribution by allowing routers to oppor tunistically cache content within the network . Cached content can be returned in response to future requests, which are called interests . This reduces the need to forward interests to content producers, thus lowering network congestion and content retrieval latency. However, router caches are not mandatory in CCN. In some cases, caching content might not be beneﬁcial, e.g., for routers with high content processing speeds, since high arrival rates translate to less time spent in cache. If this cache lifetime is very short, the probability of cache misses increases and cache’s utility decreases proportionally. Indeed, some prior literature shows (via simulations and experiments) that caching at the edges of the internetwork, i.e., at consumer facing routers, is most beneﬁcial and more costeffective than doing so in the core, i.e., in transit routers [1]. To help caching routers determine the lifetime of cached content, the latter includes an optional ExpiryTime ﬁeld. Routers are expected to ﬂush content once this time elapses.However, a router can choose to keep content cached beyond its lifetime. Lifetime of content in a particular router’s cache depends entirely upon that router’s implementation and policy. This uncertainty (or freedom) means that content may linger in the network for a very long time. One notable drawback of this libertarian approach to caching is that some content may need to be deleted before ExpiryTime elapses. Consider content that frequently (yet sporadically) evolves over time, e.g., news articles. The appear ance of breakingnews articles is unscheduled. As situations develop, updates and corrections to the content occur at unpre dictable times. Such updates supersede previously distributed content by rendering it stale. Thus, in this case, producers need a way to remove old content. Another example is content (that has released and subsequently cached) which contains erroneous information. As errors are detected and corrected, a producer needs to ﬂush the incorrect older version. The deletion problem occurs because ExpiryTime is the only way for a producer to communicate anticipated content lifetime to the network. However, a producer can not change its mind after content has been published and distributed. Thus, there is a need for a safety mechanism for innetwork content deletion. In this paper, we design a protocol – Best Effort and Autonomous Deletion (BEAD) – that mitigates this problem. In the process, we encounter and address several challenges, including efﬁcacy, efﬁciency and security. We also experimentally assess the proposed BEAD protocol. The rest of this paper is organized as follows. Section II overviews CCN. Related work is summarized in Section III. Section IV presents minimal requirements for content deletion. Sections V and VI describe authentication and routing of deletion requests in BEAD, respectively. The BEAD protocol is analyzed in Section VII and its performance is assessed in Section VIII. The paper ends with a discussion of BEAD optimizations and practical factors in Section IX. Future work is summarized in Section X. II. CCN O VERVIEW This section provides an overview of the CCN architecture and protocol, according to the most recent speciﬁcation [2]. Given familiarity with CCN, it can be skipped without loss of continuity. Unlike IP, which focuses on addressable endhosts, CCN emphasizes named and addressable content. A consumer issues a request, called an interest , specifying the name of desired content. CCN names are structured simular to URIs. For exam ple, a particular content produced by the NSA might be named:arXiv:1512.07311v1  [cs.NI]  23 Dec 2015lci:/us/gov/DoD/NSA/SnowdenDiary . An interest for a particular content Nis routed towards an authoritative producer for the content based on Nitself. In CCN, both interest and content messages have generalpurpose Payload ﬁelds. Consumers can use an interest’s Payload ﬁeld to push information to producers, while producers use a content’s Payload ﬁeld to carry actual application data. As an interest traverses the network, each router determines if a copy of requested content is cached in its Content Store (CS). If a cache hit occurs, the router satisﬁes the interest by sending the matching content on the interface on which the interest arrived. Otherwise, the router (1) records some state derived from the interest in its Pending Interest Table (PIT) in order to provide a backwards path for the future content, and (2) forwards the interest to the next hop(s) speciﬁed in its Forwarding Information Base (FIB). State retained in the PIT contains the content name and the interface(s) on which interests for that name have been received. A FIB is a routing table that maps hierarchical name preﬁxes to outbound interfaces. LongestPreﬁx Matching (LPM) is used to determine the matching FIB entry. A routerRcan collapse multiple interests into the same PIT entry whenever: 1)Rreceives an interest for name N 2)Rdoes not have content Nin its cache 3)R’s PIT already contains an entry for N When interest collapsing occurs, Ronly records the interface on which the new interest arrived and drops that interest. Whenever requested content arrives, Rforwards it on all interfaces listed in the corresponding PIT entry. Afterwards, the PIT entry is ﬂushed. If no router can ﬁnds a cached copy of requested content in its cache, the interest eventually reaches the producer that responds with the matching content, if possible. If the producer can not provide it (e.g., content does not exist) a NACK is generated [2], [3]. As content traverses the reverse path to the consumer, routers may choose to cache it in anticipation of future requests. As mentioned earlier, each content includes a producerset ExpiryTime ﬁeld. This value is content and applicationspeciﬁc. However, each router can use any cache management algorithm, e.g., LRU or LFU. III. R ELATED WORK "
173,Parallel genetic algorithm for planning safe and optimal route for ship.txt,"The paper represents an algorithm for planning safe and optimal routes for
transport facilities with unrestricted movement direction that travel within
areas with obstacles. Paper explains the algorithm using a ship as an example
of such a transport facility. This paper also provides a survey of several
existing solutions for the problem. The method employs an evolutionary
algorithm to plan several locally optimal routes and a parallel genetic
algorithm to create the final route by optimising the abovementioned set of
routes. The routes are optimized against the arrival time, assuming that the
optimal route is the route with the lowermost arrival time. It is also possible
to apply additional restriction to the routes.","In the modern world we often hear about drones, selfdriving cars and, in general, about increasing transport automation. The vast majority of re search is dedicated to cars, however, cars are usually used for relatively short trips, generally taking several days at most, with breaks so that drivers can rest. It is almost impossible to move great amounts of goods from one con tinent to another by car or truck. Ships are used for that. For example, it usually takes about four or ve weeks to travel from Brazil to Europe and it is possible to transport thousands of tonnes of cargo in a single voyage. In addition, it might be economically ecient to either reduce the crew size, through deeper automation or even develop unmanned ships that are able to function without onboard supervision [5]. 1arXiv:1905.05478v1  [cs.NE]  14 May 2019Such unmanned ships need to autonomously operate their internal sys tems and control their technical operations. Moreover, such a ship needs to navigate autonomously, which means that it should be able to plan its route without human assistance. In contrast with cars, ships travel in areas of almost innite size, where it is usually possible to travel in almost any direc tion. As a result, we could not use methods, that are used to plan routes for autonomous cars, to solve the same task for autonomous ships, because the possible directions of a car are restricted. Research shows that optimizing ship routes can also have economic bene ts: an optimal route leads to lower fuel consumption and lowers operational costs [9]. This paper describes an algorithm that could be used to plan routes for ships. The algorithm does not need any human attention while it operates, as a result it could be employed by a navigation system of an autonomous ship. The proposed algorithm tries to plot a safe and optimal route for a ship. Plotting an optimal route can be considered as an optimisation problem. A ship is a complex technical entity that is aected by several physical processes. Just like most of the vehicles, it is not able to turn on place and it is not able to stop instantly. The turn diameter of a ship may be up to 4 times longer than the ship's length [12]. A ship travels in water and as water is not dense, it creates relatively low resistance and inertia makes the ship move for a long time even after the engines are shut down. The distance a ship passes before it fully stops may exceed two nautical miles (about 3.7 kilometres). These distances are greater than a ship itself, and they aect the ship manoeuvring capabilities. Thus, these characteristics should be taken into consideration while planning a route for a ship. The methods, used to optimize complex dynamic systems are commonly divided into two groups: strict methods and models, that are adapted to real life interaction of the modelled objects with their environment; and meth ods of \soft computing"" that employ intellectual technologies. Evolutionary models based on genetic algorithms have shown their eectiveness [18] for multiobjective optimisation problems. Optimisation algorithms are discrete procedures that consist in modifying the initial set of solutions in order to nd the best one. According to the dynamic catastrophe theory, application of such evolutionary methods to the development of the \ship { environment"" system is expressed by generating multiple alternate solutions and choosing the optimal one [19]. In case of the problem that consists in planning a route for a ship, the problem area may be an extremely large portion of water area. In addition, it is important to consider water currents while planning a route; moreover, the problem area changes with time because of tides that make depths vary 2periodically. Strict methods fail to consider these variations or require too much time to produce an acceptable solution [16]. Therefore, we think that heuristic methods may be considered a suitable solution for this problem. Section 2 describes the task in more detail, and states some considerations about it. Section 3 provides an overview of existing solutions for the problem. Section 4 describes the proposed method in detail and section 5 provides experimental results. Section 6 describes topics that need further research and possible improvements for the method. Section 7 represents our ndings and conclusions. 2 Task Ocean ships transport millions of tonnes of cargo all over the seas. Ship fuel costs a lot and a ship consumes tonnes of fuel during a voyage. Fuel con sumption may be reduced when the route is optimal, which means, the ship is moving with its optimal speed and does not manoeuvre intensively [21]. In addition, cargo may have expiration dates so it is essential to deliver it in time. Ships usually travel in wellknown areas where routes may be prede ned. In some cases, a ship has to travel in an area that has not been studied profoundly, or, for some reasons, follow a unique route. For example, a scien tic ship while doing its research has to travel within poorly studied areas. In some cases a ship needs to manoeuvre intensively even in wellstudied areas, for example, at a highly loaded seaport when it travels to or from a pier. For instance, Europoort at Rotterdam serves thousands of ships per year [1]. It is dicult to manoeuvre safely when a port is overcrowded. If the action is taking place in dicult circumstances, for example in a strait with a complex seabed, the weather conditions become important. Sea currents and winds aect the ship's movements, therefore it is essential to consider the weather when planning a route for a ship. Ships do not travel in void, so there is a water area where the action takes place. This area is restricted by coasts, even though it is very large. The bottom of such an area has a complex structure and there is a special kind of maps that describe this territory and that are used in maritime navigation. One of the important characteristics of a water area is a nautical chart that provides depth measurements at particular regions of an area. A ship is able to travel only within the areas that are deep enough. Nautical charts tend to provide average depths while the depths may change within a day because of tides. In some cases, a ship is able to pass through a particular area only during the rise of the sea level, because the area is too shallow or the ship sits in water too deeply. A ship has to wait until the level rises enough and avoid 3appearing in the area during the fall of the level; otherwise it will crash. The nautical chart provides information about the depths of particular regions and therefore about the obstacles that do not allow a ship to travel. For this task, we assume that a route for a ship consists of several points called waypoints. The rst waypoint of a route is called the start and the last point is called the destination. Part of a route between two adjacent waypoints is an edge. While following a route, a ship must sequentially arrive to every waypoint of the route. Every waypoint corresponds to a geographical location with particular coordinates. We assume that the area where the action is taking place is relatively small (tens of square nautical miles), as a result we may ignore the curvature of the Earth, use meters for coordinates instead of degrees, and use xandyaxes instead of latitude and longitude. The proposed method can be adapted to larger areas and degree based coordinates if needed. Every waypoint also has additional parameters that describe how a ship should follow the edge after the waypoint. Such parameters include the moment of time when a ship is expected to arrive to a waypoint, the moment of time, when a ship is expected to depart from a waypoint, the speed a ship is expected to move with while it follows the edge after the waypoint and, optionally, radius of the curve a ship must follow if a route requires it to turn. Therefore, the task is to plan a safe and optimal route for a particular ship in a particular area starting at a predened location and ending at a predened location. A safe route is such a route that a ship is able to follow without crashing into an obstacle (like an island or area's seabed). An optimal route is such a route that is shorter in terms of travel time, than any other route that connects the start and destination points. We use time to compare routes instead of distances, because a ship may follow a longer route at a higher speed and arrive earlier than when it follows a shorter route at a lower speed. This paper describes an algorithm that does not take the weather into account, ignores sea level changes and assumes that a ship travels alone, there are no other ships nearby. 3 Related works "
