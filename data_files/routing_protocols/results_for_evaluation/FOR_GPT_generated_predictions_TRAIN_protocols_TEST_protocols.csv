Unnamed: 0,titles,abstract,introduction,prediction,result
179,PSVR - Self-stabilizing Publish_Subscribe Communication for Ad-hoc Networks.txt,"This paper presents the novel routing algorithm PSVR for pub/sub systems in
ad-hoc networks. Its focus is on scenarios where communications links are
unstable and nodes frequently change subscriptions. PSVR presents a compromise
of size and maintenance effort for routing tables due to sub- and
unsubscriptions and the length of routing paths. Designed in a self-stabilizing
manner it scales well with network size. The evaluation reveals that PSVR only
needs slightly more messages than a close to optimal routing structure for
publication delivery, and creates shorter routing paths than an existing
self-stabilizing algorithm. A real world deployment shows the usability of the
approach","Industrial wireless sensor networks are an emerging ﬁeld for process monitoring and control that require dynamic forms of the manytomany communication paradigm for data dissemination. This communication style is best supported by publish/subscribe (pub/sub) systems instead of requestreply messaging. In channelbased pub/sub systems, publishers assign each message to one of several channels which are known by all nodes. Subscribers express interest in one or more channels (a.k.a. subscribing to the channel) and only receive messages as signed to these. The pub/sub paradigm guarantees disseminating all messages to nodes with a subscription for that channel. The advantage is the loose coupling, i.e., publishers are unaware of the subscribers that receive their messages. Nodes can at any time give up subscriptions and create new ones. The eﬃciency of message dissemination in pub/sub systems depends on the used routing strategy. The goal is to deliver each publication with a minimum number of messages to all subscribers. The minimum number of messages is used when the publication is routed along the Steiner tree for the publishing node and all nodes subscribing to the message’s channel. Since Steiner trees are computationally too expensive many systems use a ﬁxed spanning tree for routing. A publisher recursively forwards a message into those subtrees that containasubscriberforthemessage’schannel.Thisrequireseachnodetoprovide the necessary information and does in general not result in the shortest routing path.Othersystemsorganizetheirnodesintoavirtualring.Apublishedmessage is then simply forwarded once around this ring and thereby delivered to allarXiv:1609.06841v1  [cs.DS]  22 Sep 2016subscribers. This does not require any routing tables and there is no need to distribute un/subscriptions into the network. Unfortunately this requires at least as many messages as nodes in the virtual ring. In this paper we consider scenarios where nodes frequently change their sub scriptions, hence, an eﬃcient update of the routing structure is required. Also delivery of publications must be guaranteed while subscriptions are changing. To meet this goal we propose the routing algorithm PSVR, which is a signiﬁcant extension of the algorithm in [14]. PSVRpresents a compromise between the length of routing paths and the eﬀort to maintain the routing tables. One of the core ideas is to augment routing on the virtual ring by shortcuts. We show that for a speciﬁc class of graphs on average the increase of the length of routing paths is bearable and updating a node’s subscription list is simple. To increase system robustness and to tolerate the failure and recovery of links and nodes the proposed algorithms are selfstabilizing. The eﬀectiveness of the proposed algorithm is shown through simulations using a realistic channel model and by a comparison with a selfstabilizing treebased approach. 2 Related Work","In this paper we propose a routing algorithm for publish-subscribe (pub/sub) systems. The goal of the routing algorithm is to deliver a publication with a minimum number of messages to all subscribers. The routing strategy is based on a Steiner tree, which is computationally too expensive and requires at least as many messages as nodes in the virtual ring. In this paper we consider scenarios where nodes frequently change their subscriptions, hence, an efficient update of the routing structure is required. To meet this goal we propose the routing algorithm PSVR, which is self-stabilizing. The proposed","90,80"
305,Minimum Process Coordinated Checkpointing Scheme for Ad Hoc Networks.txt,"The wireless mobile ad hoc network (MANET) architecture is one consisting of
a set of mobile hosts capable of communicating with each other without the
assistance of base stations. This has made possible creating a mobile
distributed computing environment and has also brought several new challenges
in distributed protocol design. In this paper, we study a very fundamental
problem, the fault tolerance problem, in a MANET environment and propose a
minimum process coordinated checkpointing scheme. Since potential problems of
this new environment are insufficient power and limited storage capacity, the
proposed scheme tries to reduce the amount of information saved for recovery.
The MANET structure used in our algorithm is hierarchical based. The scheme is
based for Cluster Based Routing Protocol (CBRP) which belongs to a class of
Hierarchical Reactive routing protocols. The protocol proposed by us is
nonblocking coordinated checkpointing algorithm suitable for ad hoc
environments. It produces a consistent set of checkpoints; the algorithm makes
sure that only minimum number of nodes in the cluster are required to take
checkpoints; it uses very few control messages. Performance analysis shows that
our algorithm outperforms the existing related works and is a novel idea in the
field. Firstly, we describe an organization of the cluster. Then we propose a
minimum process coordinated checkpointing scheme for cluster based ad hoc
routing protocols.","With recent advances in mobile technology and mobile devices, mobile computinghas become an important part of our life. People are using wireless networks fortheir daytoday work, be it making a phone call or to download news or to see andlisten or only listen to their favorite song from various multimedia servers with thehelp of various devices such as mobile phones, PDAs or a laptop. More servicesare in t he offering in near future . The desire to be connected anytime,anywhere, anyhow has led to the development of wireless networks, opening newvista ofInternational Journal on AdHoc Networking Systems (IJANS) Vol. 1, No. 2, October 2011 52research in pervasiv e and ubiquitous computing . This emerging fieldof mobile and nomadic computingrequires a highl yfailure free environment to effectively manage the communication among the peers. Ad hoc networks have recently been considered as an attractive research filed. In some case, such as emergency, disaster relief or battlefield operations, when a wire line is not available, an ad hoc network can be set for the communication. Clustering of MHprovides a convenient framework for resource management. The main advantage of clustering is reducing the number of messages sent to each BS from each node, channel acc ess, power control and bandwidth control. In cluster based architecture, whole network is divided into several clusters and in each cluster network elects one node to be called as cluster head. Hence,clustered ad hoc network consists of three kinds of nod es–cluster heads, gateways and ordinary nodes. Clusterheads are the nodes that are given the responsibility for routing the messages within the cluster and performing the data aggregation. The communication between two adjacent clusters are conducted thr ough the gateway nodes. All nodes other than that gateway and clusterheads are called ordinary nodes. Both gateways and ordinary nodes are managed by their clusterheads. There is no physical backbone architecture available in ad hoc wireless networks. forrouting of the message, a node dependson other nodes to relay packets if they do not have direct links. Wireless backbone architecture can be used to support efficient communications between nodes [1], [2], [3], [5]. To support backbone architecture, the clusterheads should be a part of the backbone and the fewer the number of backbone nodes the better. Fewer nodes in the backbone can reduce the quality of messages exchanged by backbone nodes [3], [4] . In this paper, we propose a checkpointing scheme for clustering routing protocol as a method of improving reliability. A cluster head send routing and collected data information to BS, which periodically save the state of cluster head. If a cluster head fails or some fault is detected , then BS detects the cluster head failure and some new node in the cluster is assigned the responsibility of the cluster head. Using checkpointing the cluster can quickly recover from a transient fault of cluster head. The merits of our work are as follows. .Wepropose a minimum process checkpointing algorithm for cluster based architectures in which a MH first takes a tentative checkpoint and later on when it receives commit request from the initiator, MH converts its tentative checkpoint into permanent checkpoint. The paper is organized as follows. Section 2 discusses the background material for this work. We give System Design in Section 3 and Section 4provides the organization and setup of a cluster. Theproposed checkpointing scheme is formulated in Section 5 . Section 6 discu sses handling of disconnections and Section 7 shows the performance of our algorithm . Finally, S ection 8concludes the paper. 2.Related Work and problem formulation","In this paper, we propose a checkpointing scheme for clustering routing protocol as a method of improving reliability. In this scheme, a cluster head takes a tentative checkpoint and later on when it receives commit request from the initiator, MH converts its tentative checkpoint into permanent checkpoint. The checkpointing scheme is based on the principle of minimum process checkpointing. The checkpointing scheme is based on the principle of minimum process checkpoint. The checkpointing scheme is based on the principle of minimum process checkpoint. The proposed checkpointing scheme is based on the principle of","70,90"
31,Are Smart Contracts and Blockchains Suitable for Decentralized Railway Control?.txt,"Conventional railway operations employ specialized software and hardware to
ensure safe and secure train operations. Track occupation and signaling are
governed by central control offices, while trains (and their drivers) receive
instructions. To make this setup more dynamic, the train operations can be
decentralized by enabling the trains to find routes and make decisions which
are safeguarded and protocolled in an auditable manner. In this paper, we
present the findings of a first-of-its-kind blockchain-based prototype
implementation for railway control, based on decentralization but also ensuring
that the overall system state remains conflict-free and safe. We also show how
a blockchain-based approach simplifies usage billing and enables a
train-to-train/machine-to-machine economy. Finally, first ideas addressing the
use of blockchain as a life-cycle approach for condition based monitoring and
predictive maintenance in train operations are outlined.","Unlike car traffic, most mainline railway operations have technical frameworks to constantly  enforce strict safety procedures . The se frameworks are designed and implemented to  withstand an operator’s  failure or even death. While the scope of the frameworks differ s  between countries, the state oftheart implementations such as ETCS1 include the constant  upkeep of “safe blocks” (to prevent collisions even in case when one of the trains comes to  an unexpected stop  or derails ), emergency braking if a red signal is passed  (or if the human   operator does not react within a specified tim e), detection of train decomposition, and  variable speed control. Trainside and lineside IT components work together to achieve these  goals.   Beyond the safety guaranteeing frameworks, railway operation requir es live  dispatching: in addition to schedule based passenger /freight trains, dispatching  must  accommodate  adhoc traffic, deviations, construction caused alterations , equipment  failures  etc. Despite advances in conventional and AIsupported decision making, a lot of  this work is still performed by humans, i.e. experienced dispatchers. Dispatching and safety                                                                                                                  † Michael Kuperberg (michael.kuperberg@deutschebahn.com) is the Chief Blockchain Architect of DB Systel GmbH, the IT provider o f Deutsche Bahn AG   ‡ Daniel Kindler (daniel.kindler@deutschebahn.com) is the Managing Partner Blockchain & DLT Solutions – DB Grou p Business Segment Infrastructure of DB  Systel GmbH   §Sabina Jeschke (sabina.s.jeschke@deutschebahn.com) is a Member of the Management Board Digitalization & Technology (T) of Deu tsche Bahn AG    PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     2 frameworks are usually partially decentralized for large railway networks: they are split into  regions so that size and comple xity are manageable – very similar to air traffic control  operations. Over time, such operations have been electrified, electronical equipment has  been introduced, and  the newest equipment generation relies on digital2, semi detached  infrastructure element s (switches, signals, occupancy sensors) as well as on in cab signaling.   Dispatching and safety frameworks are complex , heterogenous  and very costly  (with an  invest  of between 100,000 and 300,000  € per km3), developed over many years and with  lifecycles of several decades . Despite attempts at standardization, both interoperability and  vendor lock in pose an ongoing challenge.  Additionally , such frameworks have historically  been nation specific; international s tandards such as ETCS require substantial investment in  hardware and software  during a transition phase . Ultimately, this should help overcome the  heterogenous patchwork of country specific standards in place throughout the EU: cross  border train operation often requires additional training, multi system vehicles (at a higher  cost), or changing trains/staff at the border.   Still, railway traffic management (incl. dispatching and safety/security) is not part of  ETCS; such functionality is being desig ned as part of ERTMS4, which is the overall initiative  that encompasses ETCS  and GSM R. Infrastructure utilization is the key to lower operating  costs, and customer satisfaction is strongly correlated with punctuality and density of  service. Thus, some  progress has been made on improving track utilization (e.g. using  “moving blocks”5), in addition to improvements in safety. Despite these advances, the  principles of railway operations remain largely the same : control center is “the master” and  the train is “ the slave”. This resembles the mainframe design patterns, where the trains are  only the “terminals”.   This hubandspoke pattern remains in place even for cutting edge “autonomous train  operation”6. Thus, the mainstream approach is a “slow evolution”, mandated by the  backward compliance in large networks but also by the intrinsic interests of the  manufacturers  and investors . However, there are situations where seamless train to infrastructure  and train totrain contracting  would lead to improvements: trains could  dynamically negotiate and “sell” a timeslot, automating redispatching in a rational, market  driven way.  Potentially , passengers can request unscheduled stops  (and bid/po ol for them) ,  and unpredicted construction or extension of maintenance shutdown periods could be  propagated across the network.  Additionally, trains could self report operation impacting  defects (such as overheated axle bearings or derailments).   Another potential for improvements exist s in the “ back office ” area: many national rail  networks provide “open access” to competing passenger and freight railways, which pay  regulated fees for infrastructure usage (tracks, stations, energy supply). Likewise, the “ back  office ” sells ahead oftime access rights since network access is strictly controlled to enable  timetabled train operations to maintain their quality of service. Using a blockchain, both  the  sale/allocation of access  resp. usage  rights and the actual payment for them would happen  transactionally and instantly, in one system rather than in several. In the area of  maintenance and servicing, currently, maintenance windows, maintenance intervals, and  maintenance plans are designed to ensure the safety of t he system. The use of blockchain  coupled with the ever evolving sensor technology of trains or infrastructure components PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     3 can be seen as the basis of modern maintenance, in which the individual components  independently register their requirements. The rol lout of such on demand maintenance  then includes e.g. also the automatic ordering of spare parts or the provision of special  teams.   In Figure 1, we sho w the most essential parts of this “ecosystem”. Each shown part exists  in several instances : there are sovereign rail networks both at national level and regional  levels . In reality, there are additional layers ( e.g. procurement, malus/bonus processing, HR ,  maintenance planning and management, construction , governmental oversight , insurance )  which we do not detail here. Ultimately, we are working towards a modular, API driven  multi modal “Transportation Operating System” where all interactions (from ticket  purchase to subcontractor  payments) are handled on the basis of a consistent, trusted,  replicated ledger “ data base ”. Some of the functionality shown there has already been  showcased by us in previous works: e.g. blockchain based station usage billi ng7 and  blockchain based revenue sharing8. Throughout these modules, privacy, reliability and  performance (throughput, latency) remain an ongoing challenge.   In this paper, we investigate  a disruptive  approach to train control  based on  Distributed  Ledger Technologie s (DLT s) that thoroughly rethinks the involved roles: a DLT becomes the  trusted “single truth” for both the current state of the network s and for the “future  infrastructure reservations” which are the results of pre schedulin g and ad hoc planning .  The ledger data is replicated across ledger nodes, providing fa ult tolerance and reliability.  Furthermore, smart contracts serve as “gatekeepers” to the state changes (e.g. new  reservations or cancellations) and the participating nodes cross verify these changes,  implementing a consensus mechanism that ensure s consistency with specified rules  across  Figure 1: some IT building blocks in deregulated passenger train operations  PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     4 nodes. We show how a prototype implementation works, and where additional research is  needed. As part of the paper, w e discuss the challenges to this approach, and compare it to  existing implementations. We also show how it can be developed to a modular  “Transportation  Operating System”.   The remainder of this paper is structured as follows: Section 2 shows the full complexity  of the problem and how we have defined the scope for the initial proof ofconcept (which  was implemented using a training facility used by De utsche Bahn AG). Section 3 presents  the architecture of the solution and explains the choice of the used technologies. Section 4  describes some important implementation asp ects (incl. the use of the Ethereum blockchain  stack) and the ‘lessons learned’ that we gathered during the PoC. Section 5 analyzes related  work and how it compares to our results . Section 6 concludes and provides an outlook,  together with the planned next steps.      2. Work objective , scope definition  and assumptions   Our research objective is t o enable trains (resp. train operators) and infrastructure  elements to be first level, active  and self aware participants in railway control systems.  Active participation  by vehicles builds on access to a trustworthy , uptodate  view of the  network use  past, current and planned. Such active participation includes  wayfinding ( both  adhoc and inadvance) , booking and actual usage of the infrastructure , as well as  interaction with lineside equipment  (e.g. setting a switch into the correct position)  and with  other vehicles . As part of our objective, we want to establish an authoritative data  repository that is audit proof/tamper proof (through write once read many  semantics , aka  WORM ) and which relies  on open source, security assessed COTS software components   rather than on proprietary technology .   The write  access to th e data  repository is  to be  protected by “gatekeepers”, which  ensure that only secure entries  can be inserted  (e.g. no two trains are l ocated in the same   block at the same time). The WORM semantics mean that data cannot be overwritten  (not  even by consensus). Some nodes may choose to store only a certain, regulation imposed  backlog of past data to keep the data amount manageable.   Train localization and integrity checks (detection of decomposition) are assumed to be  available; there exist established technologi es for this (such as trackside equipment, GNSS,   Differential GPS9 resp. axle counters10). Trainside safety /security measures (such as a forced  emergency stop when trying to enter an occupied block) would access the state information  (e.g. block occupancy ) stored in the proposed, new system  currently, such information is  transmitted by track side equipment /IT (e.g.  LZB, magnets in PZB/ Indusi) resp. by GSM R (as  in ETCS  Level 3 ). Therefore, the physical reality and the IT representation are matched: the  infrastructure elements and the trains have “IoT digital twins”.   It is imperative that a digital twin and its physical counterpart are “mutually r eliable” for  both state representation and state changes. For example, the physical switch must be  reliably “locked” except during state changes, and may not change its position without  having been instructed by the digital twin to do so. If a switch posit ion is modified by brute  force (e.g. through sabotage), the malfunction must be detected (e.g. by an appropriate  circuitry) and the disruption must be represented in the IoT digital twin , preventing an PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     5 accident . We assume in the following that infrastructure elements and the synchronization  between the IT representation and the physical entity is available and reliable, i.e. solved  outside of our work.   Likewise, we assume that the trainside safety asp ects of th e (automated or human  operated) train operation  are maintained. However, they information they rely upon are  not provided by the centralized control center, but rather by the blockchain based network.  For example, trainside emergency stop is auto activated  if a train enters an occupied block.   It is a part of our approach that a train pays the infrastructure usage directly to the  infrastructure element (e.g. to a track stretch). This means that the infrastructure element  has a way to receive payments, and i ts owner  can administrate those payments. Payments  can also be bonuses (or fines), or “back  office” tasks as in Figure 1. To enable such a M2M  economy, we propose to use blockchain wallets (which are effectively PKI keypairs , cf.  Ethereum ), where the balance of a wallet is stored on the blockchain ledger. In th is paper,  we do not discuss how the payment is integrated into the planning/management/control  processes.   3. Solution Architecture and Employed Technologies   Conventional train control systems are usually centralized in two ways: logically and  technically. Logically, there is just one business entity (the “infrastructure operator”)  running the control system, and it is the only party that has full access rights (incl. write  permissions) ; it may  or may not  allow read only access for train operato rs at its own  discretion. Technically, the control system is usually centralized because cost factors do not  encourage a multi node/multi location setup. Additionally, a “hot standby” or even “active  active” setup means that data must be replicated  success fully and completely  before  it can  be considered as “written  through” ; this may increase latency and  strain the data links  between the locations.   Increasingly, infrastructure malfunctions lead to compensation claims from the train  operators, which themsel ves have to pay compensations for delays  to customers . This forms  a monetary driver for further fault tolerance in railways operations; additional ly, the  ongoing progress in hardware performance tocost ratio  encourage s the “ design for  failover ” approach  even in the light of the additional implementation costs  compared to the  simple setup.  PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     6 Therefore, our architecture (as shown in Figure 2 ) is primarily based on technical  decentralization , i.e. on multiple nodes . The blockchain identity of the tr ain is the actor  which orders paths (i.e. performs reservations of an infrastructure element for a given  timeframe); it interacts with the blockchain identity of the infrastructure element via the  smart contract which is the gatekeeper (ensuring consistenc y and  a safe global state). The  smart contract is the entity which changes the “should be” part of global state. When it  comes to the “is” global state, the physical world is the “leading  truth ”; the state on the  blockchain is mirroring the “physical truth”. The train protection component does rely on  the “isstate ” but consults the future state as well.   When it comes to logical decentralization, the situation is more intricate. Logical  decentralization means that the nodes  belong to multiple parties. This immediately poses  the questions of authority, agreements, responsibility and liability. When it comes to  security and human life, strong authorities are the traditional choice.  Implicitly, a single  authority means a single (central) responsibility.  In aviation, the pilot and the co pilot are an  example where strict rules of authority in a multi party setup are used to pre vent a  stalemate (standoff), as there is no arbiter to act as an intermediary  between the parties .   Logical decentralization is inherently more complex than logical centralization, as it  needs to address  the situation with failing/unreachable nodes, the me aning of dissenting  minorities, party splitting and unstable behavior (cf. the “Byzantine generals” problems and  the associated body of research). At the same time, large scale networks with decentralized  decision making have appeared and maintained operat ion, e.g. the public Bitcoin and the  public Ethereum blockchains. Such networks succeed in horizontal scaling, a working set of  rules for consensus  (which is a systematic decision making using defined majority rules ), and  in fault tolerance. At the same ti me, achieving suitable QoS and performance (latency,  throughput , predictability ) while maintaining scalability remain s challenging in  decentralized DLTs and blockchains.   Figure 2: architecture of the prototype  PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     7 Ultimately, our solution architecture is technically suitable for both  logically centralized  and logically decentralized setups: since  we use a private consortial  (non public)  blockchain  as the “engine” to run our algorithms and store our data, additional nodes can be added   and additional part ies can be onboarded. Note that for our architecture, there is no need  for separate  “oracles” that supply externally source d information . For timer triggered  events (e.g. checking whether a reserved element can be released since the reservation has  expires and the train has vacated the element) , reliable solutions  are rather straightforward  to implement.   It is important to stress that reservations (and payments) are handled in a peer topeer  fashion between trains and infrastruct ure elements (such as switches ); the IoT twin of the  infrastructure element  is in control of the element’s blockchain wallet . Blockchain , on the  other side,  is the event bus and the recording ledger, but it is not a first level, self aware ,  individually acting entity with own interest. At the same time, the participants of the  blockchain network safeguard the outcome of the peer topeer transactions, because these  transactions (e.g. admitting a train into a track section) are security relevant and affect al l  peers – not just two.   State changes on a blockchain consists of several steps. Independently of the used  technology, the three core steps on the “happy path” are transaction proposal, transaction  validation and the replication of the validated transaction; there might also be technology  specific steps such as ordering of the transactions . The transaction validation is the most  intricate step: it is where “minin g” could be included to combat spamming resp. to introduce  incentives to “compute” the block. In our situation (private network), transaction validation  is the trust intensive step. The important design question to answer here is: how many  network particip ants have to vote in favor of a transaction to validate it? The possible  answers re “at least n” (n 1), “at least 51% of all participants ” etc. Our architecture is very  flexible  w.r.t. the validation algorithm, and we have employed Proof ofWork (with mini mal  complexity), Proof ofAuthority and also Proof ofStake , while adjusting the consensus  thresholds .   For the implementation  of the state keeping and of the smart contracts , we used the  open source Ethereum blockchain  (geth)  in a private/consortial setup , as described in the  next section.   4. The Prototype Implementation of the Blockchain based Control Core   To validate our approach, we looked for a physical system that would be as close as  possible to a real life mainline railway . At the PoC stage, using a real railway would incur  risks that could affect human lives, and a “secluded” fullstale test setup was not available.  As a replacement, the Darmstadt training facility  for infrastructure operators  (“Eisenbahnbetriebsfeld Darmstadt” near Frankfurt am Main , known as EBD , cf. Figure 3)  was a very good opportunity:   • The facility is a long standing joint venture between a research university  (Technische Universität Darmstadt) and the Deutsche Bahn AG ( resp. its DB Netz AG  subsidiary)   • EBD is actively being used for academic teaching and railway research, having been  employed  in a significant number of projects11 PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     8 • The EBD includes different generations of railway control equipment (from  mechanical to electronical), so it is clear which functionality of it our approach would  replace    • The facility includes a large, complex model railway layout that is fully digital and  includes a variety of train material, working signals and switches, as well as “section  occupation” informatio n as well as “vehicle location” functionality (both can be used  through documented APIs and  over established network protocols)   • The existing security/safety/localization software and hardware in the EBD would   remain as is for our undertaking , while the tra in control and dispatching were to be   engineer ed using blockchain technology, following the architecture  described above.     We have decided in favor of the ready touse EBD and the against a custom made scale  model railway even though the model railway would be transportable and thus better  suitable for on premise demonstrations. The reason to start with the EBD  is that  the  reproducibility  and trustworthiness of our results from the perspective of domain specia lists  (both non IT and IT)  is strengthened when using a validated, established third party setup  as a foundation. Our implementation supplies train control and dispatching functionality  that works “on top of”  the EBD provided interfaces. Our contribution i ncludes additional  detailed checks not performed  by the EBD software  itself : e.g.  we ensure that switches are  always  in the correct  position.   As the EBD is a scale model of the current, centralized mode of railway operations, the  EBD’s model locomotives c annot be active participants of the blockchain based approach :  they do not have computing power or communication facilities , even for lightweight API Figure 3: EBD validation setup (excerpt of the railway layout)  PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     9 based access to blockchain nodes . In fact, even the trainside safety asp ects (such as  emergency full stop if a red signal is passed) are virtualized  inside the EBD by the central  control logic of the model railway. To enable humans (i.e. train drivers) to “reserve” paths   (i.e. necessary sequences of infrastructure elements for the  specified time), we provide a  graphical UI which visualizes every step, from wayfinding over payment to the actual usage.  For automated operation, the underlying input (departure and arrival  points and times)  may be provided by passengers or by operator s from the train owning railway undertaking.   In this context, by now one known disadvantage of using Ethereum is that “out of the  box”, it is an unpermissioned  (permissionless) blockchain: theoretically , everyone  (within the  consortium)  is free to set up one or several  node s and to participate and potentially , every  participant (and every node) is equal righted. Technically, there is no PKI based  authentication and aut horization in Ethereum (e.g. unlike in Hyperledger Fabric), leading to  anonymity/pseudon ymity.   However, there are two levels of protection in place for our implementation : the  network level protection restricts access to nodes based on a whitelist. Additionally, at the  level of smart contracts  and assets, Ethereum’s concepts and the Solidity language for smart  contracts provide built in mechanisms of ownership, delegation, and custom defined  permissions for custom defined assets and contracts.   For the initial implementation, we have chosen Eth ereum over e.g. Hyperledger Fabric  because of the built in wallet functionality and because there are ready touse  implementations of Proof ofWork ( PoW ), Proof ofStake (PoS) and Proof ofAuthority  (PoA) consensus algorithms. At the same time, we fully un derstand that the privacy  preserving concept of “channels” (e.g. in Hyperledger Fabric ) is more suitable, and  blockchain native tokens and assets can be added to most ledger implementation . Other  products may  also provide more choices w.r.t. programming la nguages for smart contract s,  while Solidity is the only smart contract programming language available in Ethereum. As  other ledger technologies (e.g. Hashgraph, R3 Corda, Hyperledger Burrow , Neo, …) mature,  we will re evaluate this choice.   The UML sequenc e diagram in Figure 4 shows the steps involved in a successful  reservation of a multi resource travel path. The release of the infrastructure elements can  be “as quick as possible” (as soon as the train has passed them, which improves efficiency),  or can b e triggered later (incl. “implicit release” when the reservation expires, provided that  there is no active usage of the infrastructure element).   The route finding on throug hputconstrained , weighted/priced  and time aware graphs  is already solved by several libraries and products. In our approach, the current and future  reservation are stored on a distributed ledger; at the time of writing, there were no libraries  that would expose such route finding  functio nality directly  on ledger stored graphs. Thus,  we have used a rather simple JavaScript library  for finding potential routes , but JGraphT12 is  one of the more elaborate candidates. Available  routes (a subset of potential ly possible   routes) are then determine d on the basis of the ledger stored reservations.  PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     10 Both the graph search and the subsequent reservation are subject to transactional  concern such as atomicity, consistency, isolation and optimistic/pessimistic locking. For  example, if the set of the potential routes (which are found by a train) is not lock ed, there is  a probability that another train will book a part of that potential route. Then, by the time  that the initial train decides to book a potential route, it may have become unavailable.   Such problems are not DLT specific and solved in different ways (optimistic, speculative,  pessimistic, time constrained locking) in existing systems. To keep our prototype  implementation simple, we did not implement pessimistic transaction locking but instead  act in an optimistic way: we accept the possibility of a “booking failure” if the selected  potential route has become unavailable in between (some or all segments, that is). In such  a case, the wayfinding and reservation attempts are simply repeated.   Likewise, for the initial implementation iteration, we chose to live with possible side  effects of non atomic behavior , when a route with multiple resources is booked: if the first  Figure 4: sequence diagram of the path reservation logic (excerpt, simplified view)  PREPRINT     PREPRINT     ISSN ???? ???? (online)   DOI xxxx/ zzzzzz .yyy.xx     11 resource booking(s) succeed but a following resource booking fails, the already booked  segments of the chosen route are “releas ed” (un reserved). Then, the train has to re try  again.   Including locking and trans actionality into the booking contract is of course possible, but  we decided to do it once the technology stack for the next version of the approach has been  reevaluated: w e are investigating ledgers such as Hyperledger  Fabric , R3 Corda  and others   because they offer sub groups (“channels”) so that not all information is broadcast to every  node in the network.   Railway operating software is subject to strict norms  (e.g. EN 50 128, 50129) and SIL  (safety integrity level) procedures. In addition to rigorous testing, formal verification may be  required to prove the suitability of both platform components and application components ,  as a prerequisite to certification . These tasks w ill be part of our future work.   Some Blockchain implementation s do not prohibit or (as Ethereum) even explicitly  support forks : branches which make the ledger a non linear, tree like structure. A fork marks  a “split” where state changes are non serialized and two branches can contain two  conflicting statements about the same item. Forks can be intentional13; but fork like  situatio ns can also happen if the network splits in two parts with no interconnections  between them: each network part develops its own version of the ledger. Obviously, forks  (resp. a nonlinear blockchain without  consistency checks) bring the risk of ambiguity –  something that must be avoided in train control.   When we chose Ethereum for the prototype implementation, we were aware of the  possibility of forks on the public ledger – and even as we are using a consortial, non public  setup, network partitioning cannot be fully excluded. As part of our future work, we plan to  conduct a deeper evaluation of other DLT technologies and products, and avoidance of forks  as well as the detection/avoidance of network partitions will be a key evaluation criterion .  While the Ethe reum blockchain has the “replicate everything on each full node”  principle, it is possible to reduce  the data load (e.g. through sharding ) and participants can  use asymmetric cryptography to encrypt private information passed over an unencrypted  medium (DL T), given that the public keys (for the encryption part) are already available as  part of the wallet . Other enterprise grade DLT/Blockchain stacks (such as Hyperledger Fabric  from the Linux Foundation) offer further facilities for privacy scoping, e.g. cha nnels.   5. Related work","Unlike car traffic, railway operations have technical frameworks to constantly enforce strict safety procedures. These frameworks include the constant upkeep of “safe blocks” (to prevent collisions even in case when one of the trains comes to an unexpected stop or derails), emergency braking if a red signal is passed, detection of train decomposition, and variable speed control. Despite advances in conventional and AI-supported decision making, a lot of this work is still performed by humans, i.e. experienced dispatchers. Despite attempts at standardization, both interoperability and vendor lock in","80,70"
455,Content-based Dynaic Routing in Structured Overlays Networks.txt,"Acyclic overlays used for broker-based publish/subscribe systems provide
unique paths for content-based routing from a publisher to interested
subscribers. Cyclic overlays may provide multiple paths, however, the
subscription broadcast process generates one content-based routing path per
subscription. This poses serious challenges in offering dynamic routing of
notifications when congestion is detected because instantaneous updates in
routing tables are required to generate alternative routing paths. This paper
introduces the first subscription-based publish/subscribe system, OctopiS,
which offers inter-cluster dynamic routing when congestion in the output queues
is detected. OctopiS is based on a formally defined Structured Cyclic Overlay
Topology (SCOT). SCOT is divided into homogeneous clusters where each cluster
has equal number of brokers and connects to other clusters through multiple
inter-cluster overlay links. These links are used to provide parallel routing
paths between publishers and subscribers connected to brokers in different
clusters. While aiming at deployment at data center networks, OctopiS generates
subscription-trees of shortest lengths used by Static Notification Routing
(SNR) algorithm. Dynamic Notification Routing (DNR) algorithm uses a bit-vector
mechanism to exploit the structuredness of a clustered SCOT to offer
inter-cluster dynamic routing without making updates in routing tables and
minimizing load on overwhelmed brokers and congested links. Experiments on a
cluster testbed with real world data show that OctopiS is scalable and reduces
the number of inter-broker messages in subscription delivery by 89%,
subscription delay by 77%, end-to-end notification delay in static and dynamic
routing by 47% and 58% respectively, and the lengths of output queues of
brokers in dynamic routing paths by 59%.","Content–based Publish/Subscribe (CPS) systems are used for many– to–many communication among loosely coupled distributed entities. Apublisher publishes data in form of notiﬁcations , while a sub scriber registers its interest in form of a subscription (set of ﬁlters or predicates) to receive notiﬁcations of interest [ 4,10,13,27]. In broker–based CPS systems, a dedicated overlay network , formed by a set of inter–connected brokers, is used to connect publishers and subscribers while keeping them anonymous from each other [ 4,13]. Publish/subscribe is an active area of research due to its increas ing popularity and gradual adoption in different application domains [27]. It is the communication substratum in social networking sys tems [ 12,28], business process monitoring [ 22], software deﬁned networking [ 26], massive multi–player online games [ 1], and many commercial applications [ 9,12,16,17,19]. A subscription is broad cast in the overlay network and saved in routing table of each broker in order to form a subscription–tree. Upon receiving a notiﬁcation,a broker calculates next destination–paths by matching contents in the notiﬁcation with ﬁlters in saved subscriptions. This technique is called the content–based orﬁlter–based routing using Reverse Path Forwarding [4,8]. A CPS system in this paper refers to a subscription–based publish/subscribe system that uses a dedicated broker–based overlay network for content–based routing [5]. Most CPS systems use acyclic overlay topologies, which provide single routing path and offers limited ﬂexibility to deal with network conditions like load imbalance, and link congestion. To stabilize a CPS system, subscribers are shifted from overloaded to less loaded brokers in a network area. Unfortunately, ﬁnding less loaded brokers requires extra inbroker processing and generates additional network trafﬁc, which exerts more load on the system. This not only keeps a system unstable for quite sometime until the load shift process is complete but also causes loss of messages [ 6]. Cyclic overlay networks are expected to improve performance and throughput by of fering multiple paths among publishers and subscribers. When a link congestion or load imbalance is detected, the best available path can be selected to offer dynamic routing . Although multiple paths may be available, at most one routing path, activated by a subscription– tree, can be used to route notiﬁcations [ 5]. If a link is congested, no alternative routing paths are available for content–based rout ing. The available multiple links can be exploited to generate new contentbased routing paths and avoid shifting subscribers, how ever, this requires an intelligent algorithm to search for alternative routing paths and then make a large number of updates in routing tables, which is costly and not scalable for large network settings (cf. Sec. 2). This indicates that for dynamic routing, acyclic and cyclic overlays suffer from almost the same limitations. Ideally, for high throughput and scalability, dynamic routing should be achieved without requiring updates in routing tables. Notiﬁcation routing in cyclic overlay networks has received a little attention and, to the best of our knowledge, no CPS system offers dynamic routing. In addition to the limitation of one subscription–tree, the traditional CPS systems have more fundamental issues. For example, each sub scription should be uniquely identiﬁed to avoid loops. Notiﬁcations should carry identiﬁcations of matching subscriptions to identify routing paths. Extra interbroker messages, and larger lengths of routing paths with no support for dynamic routing (cf. Sec. 2). This paper introduces the ﬁrst CPS system, OctopiS , which offers inter–cluster dynamic routing. The system is based on a purpose built topology called Structured Cyclic Overlay Topology (SCOT) generated from Cartesian product of graphs (cf. Sec. 3). We use a novel clustering technique to divide SCOT into groups of brokers (i.e., clusters ). Classiﬁcations of clusters, brokers, and links are introduced to deﬁne structuredness of a SCOT (cf. Sec. 4). OctopiS exploits the structuredness to generate subscription–trees of shortest lengths and do not require unique identiﬁcations to detect loops. The system offers intercluster dynamic routing without makingarXiv:1512.06425v2  [cs.DC]  2 Mar 20171 2 3 4 5 6 S1 PS2R1 R2 R3 (a) Subscription broadcast in a cyclic overlay when all links and brokers handle normal loads.1 2 3 4 5 6 S1 PS2R1 R2 R3 (b) Subscription broadcast when the links lh2;5iand lh3;6ihandle heavy loads.1 2 3 4 5 6 S1 PS2R1 R2 R3 (c) Subscription–trees of shortest– lengths when the links lh2;5iand lh3;6ihandle have heavy load.1 2 3 4 5 6 S1 PS2 S3R1 R2 R3 (d) BID–based routing in cyclic over lays. BIDs are added in matching no tiﬁcations to avoid loops. Figure 1: A cyclic overlay of six brokers each represented by a circle. The grey lines indicate overlay links that connect brokers. The thick grey lines are overloaded links. The dashed, solid and dotted arrow messages indicate the subscription–trees of the subscribers S1, S2, and S3 respectively, interested in notiﬁcations from the publisher P. The dashed red lines separate regions R1,R2, and R3. updates in routing tables (cf. Secs. 4 & 5). The proposed Static Notiﬁcation Routing (SNR) algorithm uses subscription–trees to send notiﬁcations to interested subscribers, while Dynamic Notiﬁcation Routing (DNR) algorithm reduces delivery delay by offering inter– cluster dynamic routing when congestion is detected. In summary, the contributions of this paper are as follows. (i) Sec. 2 identiﬁes issues surrounding the CPS systems that use cyclic overlays. (ii) Sec. 3 introduces how Cartesian product of graphs can be used to formally describe SCOT. Additional constraints are introduced to optimize SCOT for content–based routing. (iii) Sec. 4 describes a clustering approach with additional classiﬁcations for topology elements to prevent loops in SCOT. This section also introduces a lightweight bit–vector mechanism to identify target clusters for inter– cluster dynamic routing. (iv) A subscription broadcast algorithm that generates subscription–trees of shortest lengths in a clustered SCOT is described in Sec. 5. (v) Details on static routing (by SNR algorithm) and dynamic routing (by DNR algorithm) are provided in Sec. 6. (vi) Comparison with state–of–the–art identiﬁcation–based routing is discussed in Sec. 7. We describe related work in Sec. 8, and conclude in Sec. 9. 2 BACKGROUND ISSUES In this section, we use Fig. 1 to discuss different issues related to content–based routing in cyclic overlays. In particular, we discuss the issue of: (i) adding a Unique Identiﬁcation to each subscription to avoid cycles in subscription broadcast, (ii) Extra Inter–broker Messages (IMs) to detect and discard duplicate subscriptions, (iii) larger Lengths of Subscription–trees , and (iv) Path Identiﬁcation for notiﬁcation routing. In this paper, an overlay link is represented aslhsource ;destinationi, where the source anddestination are mes sage sending and receiving brokers respectively. I1 Unique Identiﬁcation : Content–based routing generates loops in cyclic overlays. Loops route a message indeﬁnitely if it is not detected and discarded. The Subscription Broadcast Process (SBP) broadcasts subscriptions to form subscription–trees for notiﬁcations routing. Since multiple paths can be available, a broker may receive duplicate subscriptions (or duplicates). To solve this issue, each broker adds its unique identiﬁcation, called Broker Identiﬁcation (or BID) , in a subscription of the local subscriber . The subscription and BID form a networkwide unique identiﬁcation, which is saved in routing tables to detect and discard duplicates.I2 Extra Inter–broker Messages (IMs) : Extra IMs have to be gen erated to detect and discard duplicates. In Fig. 1(a), broker 4 receives the subscription of S2 from broker 5. The link lh5;4iis added in the subscription–tree of S2, assuming that broker 4 discards a second copy of the subscription received from broker 1. Similarly, broker 5 discards a second copy of the subscription of S1 received from broker 2, assuming that the ﬁrst copy was already received from broker 4 (there is, therefore, no subscription–tree link from broker 2 to broker 5). This indicates that, despite using BIDs, extra IMs are generated to detect and discard duplicates. I3 Subscription–tree Length : In an acyclic overlay, SBP generates a unique subscription–tree even if a subscription is issued multiple times (after calling unsubscribe from the same broker). However, this is not the case in cyclic overlays, where multiple subscribe calls issued from the same broker may generate multiple subscription– trees with different lengths. SBP in cyclic overlays is an uncon trolled process and selects the ﬁrst available link (or broker) as the next destination. This may generate subscription–trees of larger lengths when load on the links and brokers is uneven. For example, subscription–trees of S1 and S2 in Fig. 1(a) have shortest lengths (number of hops), however, the subscription–tree of S2 in Fig. 1(b) has larger length. Presumably, the links lh2;5iandlh3;6ihad heavy network trafﬁc when S2 issued the subscription. Broker 6 received the subscription of S2 from broker 5 and discarded the duplicate received from broker 3. Although P and S2 are hosted by the brokers in the same region (i.e., R3), S2 receives notiﬁcations from P after they are processed by brokers in R1andR2. Subscription–trees of longer lengths increase in–broker computation, generate extra IMs, waste network bandwidth, and cause high latency in notiﬁcation delivery. Ideally, a subscription–tree should always has the shortest length, even if some links have high loads when the subscription is issued (e.g., the subscription–trees in Fig. 1(c)). To the best of our knowledge, no CPS system generates subscription–trees of shortest lengths. I4 Path Identiﬁcation : The issue of loops is also relevant for deliv ering notiﬁcations. For example, the matching process executed at broker 6 in Fig. 1(a) indicates that a notiﬁcation nfrom P should be forwarded onto the links lh6;3iandlh6;5i. Broker 6 creates two copies of n,n1andn2, to forward to brokers 5 and 3, respectively. S1 receives n1from broker 4 and S2 receives n2from broker 3. Unfortunately, the matching process at broker 3 indicates that the subscription of S1 matches n2, and a copy of n2, say n0 2, should 2be forwarded to broker 2. n0 2ultimately reaches S1 after being forwarded by broker 4. Again, the matching process at broker 4 identiﬁes that S2 should also receive a copy of n0 2, and this process continues indeﬁnitely until identiﬁed and stopped. Similarly, n1, forwarded by broker 6 onto lh6;5i, is received more than once. To prevent receiving duplicates, host broker of a publisher adds BIDs, assigned to matching subscriptions, to a notiﬁcation. Reverse path forwarding technique is used to route the notiﬁcation along the paths identiﬁed by the BIDs and each interested broker removes its BID from the notiﬁcation before forwarding it to the next brokers. Rout ing is stopped when no BID is left in the notiﬁcation. This approach is further explained by using Fig. 1(d). For any notiﬁcation mfrom P, broker 6 creates two copies, m1andm2, where m1with the BID of broker 3 is forwarded onto link lh6;3i, and m2with the BIDs of brokers 4 and 5 is forwarded onto link lh6;5i. Because of carrying an additional BID, payload of m2is greater than payload of m1. After receiving m2, broker 5 removes its own BID and forwards one copy of m2to S3, and another copy to broker 4. After receiving m2, broker 4 removes its own BID and forwards a copy of m2to S1. Since no BID is left, broker 4 does not forward m2any further. In a large overlay network, a notiﬁcation may be received by a large number of subscribers hosted by many brokers and many BIDs may have to be added in a notiﬁcation [ 16]. In scenarios where scalability is a major requirement, BID–based routing is a bottleneck. I5 Single Routing Path : As SBP generates one subscription–tree per subscription, updates in routing tables have to made to offer dynamic routing. Fig. 1(a) shows that there are three paths from bro ker 6 to broker 3 and only the path (with link lh3;6i), being part of the subscription–tree of S2, is used as a contentbased routing path. If the link lh6;3iis congested, S2 has to be moved to some other broker in the less loaded network area, which requires unsubscribe andsubscribe calls generating more network trafﬁc and requiring updates in a number of routing tables. If the link lh6;3iis broken for some reason, a new subscription–tree has to be generated to send notiﬁcations to S2. This requires an intelligent algorithm that makes updates in routing tables of brokers 2, 3, 5, and 6 to remove the link lh3;6iand add the link lh2;5i. Looking at the decoupled nature of CPS systems, such algorithms are difﬁcult to design and not scalable for large networks. 3 STRUCTURED CYCLIC TOPOLOGY In this section we describe our approach of designing a structured cyclic topology for loop free contentbased routing. Structured cyclic topologies provide parallel links that can be used as alternative routing paths when congestion is detected. Our goal is to use inter cluster parallel links as alternative contentbased routing paths when congestion is detected. This requires no updates in routing tables to offer intercluster dynamic routing. We use the Cartesian Product of Undirected Graphs (CPUG) to design large, structured overlay cyclic networks based on small graph patterns [23]. 3.1 Preliminaries A graph is an ordered pair G=VG;EG, where VGis a ﬁnite set of vertices and EGis a set of edges or links that connect two vertices inG. The number of vertices of G(called order ) isjGj(orjVGj). Similarly, the number of edges in GiskGk(orjEGj). A graphin which each pair of vertices are connected by an edge is called a complete graph . The diameter of a graph G, represented as diam(G) , is the shortest path between the two most distant nodes in G. A graph product is a binary operation that takes two small graph operands—for example GVG;EGandHVH;EH—to produces a large graph whose vertex set is given by VGXVH. Many types of graph products exist, but we ﬁnd the Cartesian product most suitable for contentbased routing. Other products, for example, the Direct product and the Strong product can be used but their rulebased interconnection of vertices increases node degree and makes rout ing complex. The CPUG of two graphs GVG;EGandHVH;EHis denoted by GH, with vertex set VGHand set of edges EGH. Two vertices g;h2VGHandg0;h02VGHare adjacent if g=g0and hh02EGHorgg02EGHandh=h0. Formally, the sets of vertices and edges of a CPUG are given as [15]. VGH=fg;hjg2VG^h2VHg (1) EGH=fhg;hg0;h0ijg=g0;hh02EH _gg02EG;h=h0g) (2) The operand graphs GandHare called factors of GH. CPUG is commutative—that is, GH=HG. Although CPUG of nnumber of graphs is possible, we are concerned with CPUG of only two graphs. 3.2 Structured Cyclic Overlay Topology TheStructured Cyclic Overlay Topology (SCOT) is aCPUG of two graphs. One graph, represented by Ga f, is called SCOT acyclic factor , while the second graph operand, represented by Gc f, is called SCOT connectivity factor . A SCOT has two important properties: (i)Acyclic Property emphasizes that the Ga fmust be an acyclic graph, and (ii) Connectivity Property requires that Gc fmust be a complete graph. These properties augment a SCOT with essential characteristics that are used for generating subscription–trees of shortest lengths. Va fandVc fare the sets of vertices of Ga fand Gc f, while Ea fand Ec fare the sets of edges of Ga fand Gc f, respectively. For a singleton graph of vertex setfhgVc f, the graph Gh a fgenerated by Ga ffhgis called a Gh a f","Content-based Publish/Subscribe (CPS) systems are used for many–to–many communication among loosely coupled distributed entities. A publisher publishes data in form of notifications, while a subscriber registers its interest in form of a subscription (set of filters or predicates). A subscription is broad cast in the overlay network and saved in routing table of each broker in order to form a subscription–tree. A subscription is then used to route notifications using content-based routing using Reverse Path Forwarding. However, acyclic overlay topology provides only one routing path","80,95"
247,A delay-based routing metric.txt,"In overlay networks, both local and long-distance links appear as a single
hop to a routing protocol. Traditional routing metrics (based on hop count or
packet loss) fail to take the differences between such links into account. In
this paper, we study a metric based on packet delay that has been designed to
improve routing in overlay networks. We show a lightweight technique for
measuring delay asynchronously, and show how to use the data it provides for
constructing a routing metric. Using delay naively leads to persistent routing
oscillations, so our routing protocol implements a number of features to bound
the frequency of oscillations. We show that our protocol causes no oscillations
in real-world tests, and has oscillations with a period on the order of minutes
in artificially constructed worst-case setups.","Anoverlay network is a network created on top of an existing network. In more technical terms, an overlay netwo rk is a network the links of which are realised as ﬂows (or connections) of the underlying network. Overlay networks are an old idea, and have many applica tions. They can be used as a transition technology, when the desired physical network does not exist yet — the transition to IPv6 was bootstrapped by running IPv6 within the 6bone, an overlay over the existing IPv4 Internet. Virtual Private Networks (VPN) are a technology that allows a network node to appear connected at a place different from what is implied by the physical network topology, typically in order to work around topologybased security policies; onion routing [15] generalises this idea to large public virtual networks that are usedtoprovideamodicumofanonymitytotheirusers.Finall y, by reroutingaroundfailuresfaster thanthe underlyingnet work does, overlay networks are used to improve the reliability of largescale distributed systems in the presence of parti al network failures. It is this last application that concerns us here. A. Overlay networks for reliability BGP, the routing protocol used in the Internet core, is designedtoscaletoverylargenetworks.Thisimpliesanumb er of tradeoffs, most notably relatively slow reconvergence after a network failure, on the order of minutes. Measurements indicate that at any one time a few percent of the expected routes are not available [13]. This implies that in a sufﬁcie ntly large distributed system implemented on the Internet, at an y time at least some of the participants will not be able to communicate. There are multiple ways of dealing with this issue. An interesting approach is to design application algorithms t hat are able to deal with temporary failures; for example, theSMTP protocol used for electronic mail has a complex system of timeouts, retries and fallback servers that allow it to de al with temporary failures. A more recent example is that of the Kademlia distributed hashtable algorithm(used notabl y for locating peers in largescale peertopeer ﬁle transfer ap plica tions),which ishighlyredundantin orderto dealwith arbit rary communication failures. A more modular approach consists in delegating the relia bility requirements to a lower sublayer. In this approach, the applicationblindlysendsitsdatatothedesireddestinati on,and a lower sublayer uses an overlay network to route the data to the destination, using a routing algorithm with fast rerout ing properties and with its own routing policies, possibly diff erent from the policiesused by the underlyingnetwork.This overl ay network and routing algorithm can be implemented within the application layer (as an adhoc library), as in Resilient Overlay Networks [1], which makes it possible to ﬁnetune the routing heuristics in an applicationspeciﬁc manner (e .g. prefer lower latency or higher reliability) without the nee d for crosslayer interactions. Alternatively, the overlay net work can be implemented at the network layer, using familiar packet switching technology, which reduces ﬂexibility somewhat b ut allows using unmodiﬁed applications over the overlay. B. Routing in a distributed cloud SlapOS is a framework for building distributed cloud applications. SlapOS was initially implemented over nativ e IPv6, which was found to be too unreliable. SlapOS was then modiﬁedtouse a dense network(butnota fullmesh)ofvirtual links [2], and route over it by using the offtheshelf proto col Babel [3] with the hopcount metric. This solution worked fairly well as long as the cloud was mostly local. Unfortunately, as soon as distant nodes were added, Babel started making routing choices that, whil e consistent with the shortesthop metric, were clearly sub optimal. Consider for example the topologyin Figure 1, whic h consists of four nodes conﬁgured in an almost complete mesh. As long as all the links are operational,the shortesthopme tric yields optimal results — trafﬁc local to Europe remains in Europe. However, if the link between Lille and Marseilles breaks, the shortesthop metric does not allow the routing protocol to distinguish between the local route through Par is and the remote route throughTokyo,which is thereforechose n in roughly one half of the cases. The shortesthop metric is not precise enough for the distributed cloud. In this paper, we describe our work on extending the Babel routing protocol with a metric based on packet delay.Fig. 1. A realworld topology C. A delaybased metric Our goal in this work is to extend the Babel routing protocol with the simplest possible metric that does reliab ly distinguish between local and nonlocal routes in the overl ay network generated by SlapOS. Our metric is not meant to be the endall of all metrics for overlay networks; still, th e requirements of the application dictate a number of propert ies that it must have. First, as one of the goals of the distributed cloud is to reduceoperationalcost,themetricmustnotrequireanyman ual conﬁguration, which rules out manually conﬁguring links as “local” or “remote”. We have chosen to base our network on theroundtrip time (RTT), or twoway delay, which is easily measured with offtheshelf hardware with an accura cy sufﬁcient to distinguish between Paris and Tokyo. (Oneway delay might lead to a more generally useful metric in the presence of asymmetric network congestion, but it is more difﬁcult to measure and is not required for this particular application.) Second, the algorithm must be easy to implement on cheap offtheshelf hardware, and, in particular, it must not rel y on globally synchronised clocks. Since the links used in a distributed cloud are of varying quality, it must consume a negligible amount of additional network resources. Additi on ally, since the hardware used in the distributed cloud can be fairly loaded, it should be asynchronous, i.e. not require r eal time response to query packets. Finally, since delay can be caused by network congestion, using delay in a routing metric causes a feedback loop, which can cause persistent oscillation. We require that our algor ithm provide reasonable stability, with a bound on the period of oscillations of at least a few minutes. D. Stability issues Using delay as an input to the routing metric in congested networks gives rise to a negative feedback loop: low RTT encouragestrafﬁc,whichin turncausesthe RTT to increase. In a discrete domain, such a feedback loop can cause persistent oscillations. Consider for example the topology in Figure 2, where the linksA·BandA·Care subject to congestion. Suppose that there is a signiﬁcant amount of trafﬁc from AtoD. The routing protocol initially chooses some route, say the rout e throughB; as the link A·Bbecomes congested, its RTT rises, so the routing protocol reroutes through C. The situationthen reverses: the link A·Cbecomes congested, the protocol reroutes through B, etc. A B C D Fig. 2. Worstcase topology In the general case, such oscillations are unavoidable in the presence of congestion, but their frequency can be limited. Our protocol containstwo mechanisms, saturation and hysteresis, that cooperateto limit the frequencyof oscill ations; in Section IVB, we provide empirical data that shows that in the worst case the period of the oscillations is on the order o f minutes. II. RELATED WORK","An overlay network is a network created on top of an existing network. It is a network whose links are realised as flows (or connections) of the underlying network. It is used to improve the reliability of largescale distributed systems in the presence of partial network failures. In this paper, we propose a new approach to resiliency in large-scale distributed systems. We consider two scenarios: 1) routing in a distributed cloud, and 2) routing in a distributed cloud. In the first case, we consider the shortest-hop metric. In this paper, we propose a new","80,70"
245,Federated Route Leak Detection in Inter-domain Routing with Privacy Guarantee.txt,"In the inter-domain network, a route leak occurs when a routing announcement
is propagated outside of its intended scope, which is a violation of the agreed
routing policy. The route leaks can disrupt the internet traffic and cause
large outages. The accurately detection of route leaks requires the share of AS
business relationship information of ASes. However, the business relationship
information between ASes is confidential due to economic issues. Thus, ASes are
usually unwilling to revealing this information to the other ASes, especially
their competitors. Recent advancements in federated learning make it possible
to share data while maintaining privacy. Motivated by this, in this paper we
study the route leak problem by considering the privacy of business
relationships between ASes, and propose a method for route leak detection with
privacy guarantee by using blockchain-based federated learning framework, in
which ASes can train a global detection model without revealing their business
relationships directly. Moreover, the proposed method provides a
self-validation scheme by labeling AS triples with local routing policies,
which mitigates route leaks' lack of ground truth. We evaluate the proposed
method under a variety of datasets including unbalanced and balanced datasets.
The different deployment strategies of the proposed method under different
topologies are also examined. The results show that the proposed method has a
better performance in detecting route leaks than a single AS detection
regardless of whether using balanced or unbalanced datasets. In the analysis of
the deployment, the results show that ASes with more peers have more possible
route leaks and can contribute more on the detection of route leaks with the
proposed method.","Border Gateway Protocol (BGP) is used in the interdomain network for exchange of routing information between au tonomous systems (ASes). In BGP , each AS selects the best route according to its routing policies and announces the selected route to neighbors. Different from the shortest path routing policy in the intradomain, the routing policy in the interdomain network is more complicated since it considers business relationships between ASes, where the business relationship can be categorized into two types according to AS economic factors [1]: customertoprovider (c2p) and peer topeer (p2p) . The interdomain routing policies have been extensively investigated in a number of studies, such as [2], [3], [4]. Their analysis suggests that a policy most commonly adopted is valleyfree rule [5]. In the valleyfree rule, routes learned from providers or peers should not be exported to other providers or peers. However, due to misconﬁguration and malicious attacks, the routing announcement may be propagated in violation of their agreed routing policy, which is deﬁned as route leak [6], [7]. Route leaks can cause major outages by redirecting trafﬁc and bring a risk of encountering Maninthe Middle attacks [8]. For instance, during March 12, 2015, a broadband provider of India (AS17488) wrongly announced over three hundred Google’s preﬁxes to its provider AS9498, making many of Google’s services inaccessible to their users [9]. Another incident occurred on February 11, 2021, AS28548 in Mexico leaked more than two thousand preﬁxes to its neighbors and affected about 80 countries in the world [10]. The detection of route leak is becoming increasingly Corresponding author: Xiaohong Huang, huangxh@bupt.edu.cnimportant, given the growing number of serious route leak reports. The major challenge of detecting route leaks is that the business relationships of ASes are conﬁdential. Each AS only knows the relationships between itself and its neigh bors but does not know the exact relationship of others due to privacy issues. In order to detect route leaks, some studies [1], [11], [12], [13] focus on inferring AS business relation ships. However, their inference techniques still suffer errors on partial critical links [12]. Studies like [7], [14], [15], [16] do not consider the privacy of AS relationship well and require deployers directly revealing AS relationship information, which makes the deployment hard to proceed. Another challenge for route leak detection is the lack of ground truth. Only a few destructive routing leak events reported have been validated. Route leaks that are not related to the customeraware services, e.g. multimedia services, are hard to be validated. For example, S. Abd El Monem et al. [17] show there were only 13 validated route leak incidents between 2006 and 2018. The lack of a ground truth makes popular techniques such as traditional machine learning techniques difﬁcult to be utilized in route leak detection. Federated learning is a distributed machinelearning method that allows participants globally to train a model without needing to transport their local training data to a central server. Moreover, instead of aggregating local train ing data, federated learning aggregates local model updates of participants, which can protect data privacy of partic ipants. However, traditional federated learning methods require a thirdparty server for aggregating model updates, which is vulnerable to single point of failure. To avoid this problem, blockchainbased federated learning frameworkarXiv:2110.07964v1  [cs.NI]  15 Oct 20212 [18], [19], [20], [21] is proposed, where blockchain can pro vide security management of participants, auditability, and so on. In this paper, we propose a method to route leak de tection using a blockchainbased federated learning frame work. As outlined previously, one AS has limited AS busi ness relationship information, while the detection of route leaks needs as much relationship information as possible. By using federated learning, ASes can globally train a model to identify route leaks with sharing model updates instead of directly sharing their business relationships with others. Furthermore, in order to further strengthen the privacy pro tection of relationship information, we propose to replace business relationships with AS triples to train the models. By labeling AS triples as malicious or regular using local routing policies, our method provides a solution to solve the lack of ground truth in route leaks. In the proposed method, AS participants ﬁrstly use their known routing policies to generate local training data for training. The local training data are composed of AS triples and corresponding labels that show the triples are malicious or regular. Then, each AS participant uses its local training data to train a local model and exchange updates of the local model with each other through the blockchain network. In each global communication round, one AS can gather all local model updates of participants and aggregate these updates. After the training is ﬁnished, the ﬁnal global model updates are stored in the blockchain. AS participants can retrieve the global model from blockchain and utilize it for further route leak detection. The contributions of this paper are summarized as fol lows: We consider the problem of route leak detection and propose a privacypreserving method for sharing routing policy information in AS triples compared to methods that directly share business relationships among ASes. We customize a blockchainbased federated learning framework to learn routing policies in interdomain networks and globally train a model to detect route leaks accurately. We evaluate the proposed method on different datasets and analyze different deployment strategies of the method under different topologies. Results show that the proposed method can improve the performance of a single AS in detecting route leaks. The results also indicate that AS with more peers appears to have more possible route leaks and can contribute more to the detection of route leaks than others if they deploy the method. The remainder of the paper is organized as follows. Section 2 gives an overview of route leak deﬁnitions in interdomain networks and related works in detecting route leaks. In Section 3, we introduce the route leak detection problem and the proposed solution method. Section 4 intro duces the conducted experiments and the analysis of results. Section 5 gives the conclusion of this paper.2 B ACKGROUND AND RELATED WORKS 2.1 Route Leaks Route leaks deﬁned in RFC 7908 [6] are categorized into six types: Type1: a multihomed AS (has more than one provider) leaks the routes learned from its one provider to its another provider. Type2: an AS leaks the routes learned from its one peer to its another peer. Type3: an AS leaks learned routes from its provider to its peer. Type4: an AS leaks of the routes learned from its peer to its provider. Type5: a multihomed AS announces the routes learned from its one upstream ISP as its origin routes to its another upstream ISP . Type6: an AS leaks its internal routes to its provider or peer. The Type5 and Type6 leaks are more related to the origin preﬁx hijacking and can be detected by Route Ori gin Validation (ROV) techniques, such as Resource Public Key Infrastructure (RPKI) [22]. RPKI can build a trusted repository for validating ownership certiﬁcates of preﬁxes and origin ASN. Type1, Type2, Type3 and Type4 leaks are primarily grouped by ASes business relationships. Fig.1 illustrates simple examples of these 4 types of route leaks, wherePis the announcing route. In this paper, we mainly focus on the detection of Type1 to Type4 leaks. 2.2 Route leaks detection The Internet Routing Registries (IRRs) are public distributed databases that allow ASes to register and share their routing policies. Using information in IRR, ASes can detect route leaks that violate routing policies. However, IRR databases are managed by different Regional Internet Registries (RIRs) or private organizations [23], which pose challenges for information synchronization and consistency. Routeleak Protection (RLP) [16] adds a new BGP com munity attribute named Downonly to the BGP update message for detecting and mitigating route leaks. When receiving a new route, ASes will check the value in the Downonly community of the route to decide whether to forward it to upstream providers/peers or not. If the route comes from the customer or peer ASes and the community shows no forwarding to upstream ASes, then the route is marked as route leak. However, the performance of RLP can be easily affected by misconﬁguration of BGP communities and maliciously modiﬁcations or discarding of Downonly communities during route propagation [24]. S. Li et al. [5] conclude a relationship between route loops and route leaks from analyzing local routing infor mation and develop an algorithm for detecting route leaks. However, only some route leaks may cause route loops. Therefore, it can only detect part of route leaks. Similar to [5], M. Siddiqui et al. [25] also develop a theoretical framework for detecting route leaks. However, the detection method is valid in route leak initiations and is not suitable for detecting route leak propagation [25]. Autonomous System Provider Authorization (ASPA) [26] is based on the RPKI and adds a new type of object to the RPKI repository. The new object includes the pair of downstream AS and authorized upstream AS. The autho rized upstream AS is allowed to propagate the downstream AS’s announcements. By validating the certiﬁcates of pairs, ASes can detect route leaks. However, it cannot validate3 p2pc2pNormal updateMalicious update 1 2 3 5 4 6P {1}P {1}Leak P {1,4}Leak P {1,4,2}Leaking AS 1 2 3 5 4 6P {1}P {1}Leak P {1,2}Leaking AS 1 2 3 5 4 6P {1}P {1}Leak P {1,4}Leaking AS 1 2 3 5 4 6P {1}P {1}Leak P {1,2}Leaking AS(a) Type1(b) Type2(d) Type4(c) Type3 Normal ASLeaking AS Fig. 1: Route leak examples of Type1 to Type4 route leaks: a) Type1: AS4 leaks route Plearned from its provider AS1 to its another provider AS2; b) Type2: AS2 leaks route Plearned from its peer AS1 to its another peer AS5; c) Type3: AS4 leaks routePlearned from its provider AS1 to its peer AS6; d) Type4: AS2 leaks route Plearned from its peer AS1 to its provider AS3. The p2p represents peertopeer relationship and c2p represents customertoprovider relationship complex relationships like mutual transit, where ASes pro vide transit service to each other [5]. There are studies [7], [14], [15] based on blockchain to prevent route leaks. In the blockchain, ASes share their relationships and store them in blocks. However, it also direct expose conﬁdential AS business relationship, which inﬂuences incentive of deployment. J. Yue et al. [27] consider the privacy of AS policy when using blockchain for route leak detection. They use Trusted Execution Environment (TEE) [28] to implement the privacy protection. However, it requires each chain node to maintain a global conﬁdential and tamperproof routing policy repository, which adds the risk of routing policy leakage if there is a chain node that acts maliciously. Moreover, since TEE uses a combination of hardware and software for protecting the data privacy, it is affected by hardware vulnerabilities and its updates require hardware update. In this paper, we propose a method for route leak de tection using blockchainbased federated learning, which considers the privacy protection of AS business relationship information and uses AS triples instead of AS business rela tionships to train models. The proposed method keeps the data local and shares only model updates, which lowers the risk of data leakage. With the help of blockchain technique, the proposed method can audit and track data. Even if one AS acts maliciously and leaks the updates, it does not leak the direct business relationship information. Besides, since the method uses AS triples, the complex relationships such as mutual transit can also be handled. 3 M ETHODOLOGY","Border Gateway Protocol (BGP) is used in the interdomain network for exchange of routing information between autonomous systems (ASes). In the interdomain network, each AS selects the best route according to its routing policies and announces the selected route to neighbors. However, due to misconfiguration and malicious attacks, the routing announcement may be propagated in violation of their agreed routing policy, which is defined as route leak. In this paper, we propose a method to detect route leaks using a blockchain-based federated learning framework. We propose a method to","85,80"
172,Efficient On-Chip Multicast Routing based on Dynamic Partition Merging.txt,"Networks-on-chips (NoCs) have become the mainstream communication
infrastructure for chip multiprocessors (CMPs) and many-core systems. The
commonly used parallel applications and emerging machine learning-based
applications involve a significant amount of collective communication patterns.
In CMP applications, multicast is widely used in multithreaded programs and
protocols for barrier/clock synchronization and cache coherence. Multicast
routing plays an important role on the system performance of a CMP. Existing
partition-based multicast routing algorithms all use static destination set
partition strategy which lacks the global view of path optimization. In this
paper, we propose an efficient Dynamic Partition Merging (DPM)-based multicast
routing algorithm. The proposed algorithm divides the multicast destination set
into partitions dynamically by comparing the routing cost of different
partition merging options and selecting the merged partitions with lower cost.
The simulation results of synthetic traffic and PARSEC benchmark applications
confirm that the proposed algorithm outperforms the existing path-based routing
algorithms. The proposed algorithm is able to improve up to 23\% in average
packet latency and 14\% in power consumption against the existing multipath
routing algorithm when tested in PARSEC benchmark workloads.","Rapid advancement in semiconductor technology has made it possible to integrate tens, hundreds and even thousands of processing elements on a single chip multiprocessor (CMP). NetworksonChips (NoCs) [1] have become the mainstream intrachip communication infrastructure for CMPs and many core systems due to their scalability and power efﬁciency. The communication in NoCs can be categorized into unicast (onetoone) and multicast (onetomany) communication. A signiﬁcant amount of multicast trafﬁc is demonstrated in paral lel applications involving multithreaded programs, replication, barrier/clock synchronization [2], and cache coherence [3] protocols. Simulations of a set of CMP benchmark applications with MESI cache protocols show that the multicast trafﬁc per centage ranges from 5%","NetworksonChips (NoCs) have become the mainstream intrachip communication infrastructure for CMPs and many core systems due to their scalability and power efficiency. The communication in NoCs can be categorized into unicast (one-to-one) and multicast (one-to-many) communication. Multicast traffic is demonstrated in parallel applications involving multithreaded programs, replication, barrier/clock synchronization, and cache coherence protocols. Simulations of a set of CMP benchmark applications show that the multicast traffic per centage ranges from 5%","100,100"
295,Learning the Travelling Salesperson Problem Requires Rethinking Generalization.txt,"End-to-end training of neural network solvers for graph combinatorial
optimization problems such as the Travelling Salesperson Problem (TSP) have
seen a surge of interest recently, but remain intractable and inefficient
beyond graphs with few hundreds of nodes. While state-of-the-art
learning-driven approaches for TSP perform closely to classical solvers when
trained on trivially small sizes, they are unable to generalize the learnt
policy to larger instances at practical scales. This work presents an
end-to-end neural combinatorial optimization pipeline that unifies several
recent papers in order to identify the inductive biases, model architectures
and learning algorithms that promote generalization to instances larger than
those seen in training. Our controlled experiments provide the first principled
investigation into such zero-shot generalization, revealing that extrapolating
beyond training data requires rethinking the neural combinatorial optimization
pipeline, from network layers and learning paradigms to evaluation protocols.
Additionally, we analyze recent advances in deep learning for routing problems
through the lens of our pipeline and provide new directions to stimulate future
research.","NPhard combinatorial optimization problems are the family of integer constrained optimization problems which are intractable to solve optimally at large scales. Robust approximation algorithms to popular problems have immense practical applications and are the backbone of modern industries. Among combinatorial problems, the 2D Euclidean Travelling Salesperson Problem (TSP) has been the most intensely studied NPhard graph problem in the Operations Research (OR) community, with applications in logistics, genetics and scheduling [ 44]. TSP is intractable to solve optimally above thousands of nodes for modern computers [ 3]. In practice, the Concorde TSP solver [ 2] uses linear programming with carefully handcrafted heuristics to ﬁnd solutions up to tens of thousands of nodes, but with prohibitive execution times.2Besides, the development of problemspeciﬁc OR solvers such as Concorde for novel or understudied problems arising in scientiﬁc discovery [ 61] or computer architecture [50] requires signiﬁcant time and specialized knowledge. An alternate approach by the Machine Learning community is to develop generic learning algo rithms which can be trained to solve anycombinatorial problem directly from problem instances themselves [ 67,6,7]. Using classical problems such as TSP, Minimum Vertex Cover and Boolean Satisﬁability as benchmarks, recent endtoend approaches [ 39,60,46] leverage advances in graph representation learning [ 40,24,65,5] and have shown competitive performance with OR solvers on trivially small problem instances up to few hundreds of nodes. Once trained, approximate solvers based on Graph Neural Networks (GNNs) have signiﬁcantly favorable time complexity than their OR counterparts, making them highly desirable for realtime decisionmaking problems such as TSP and the associated class of Vehicle Routing Problems (VRPs). 1Code and datasets: github.com/chaitjo/learningtsp 2The largest TSP solved by Concorde to date has 109,399 nodes with running time of 7.5 months.arXiv:2006.07054v6  [cs.LG]  25 May 20220 2 4 6 8 10 12 14 # Training Samples 1e6010203040506070TSP200 Optimiality Gap (%) 0 100 200 300 400 500 Wall Clock Time (Hours)Model Training from scratch Active Search from scratch Pretraining Pretraining + Active Search Pretraining + Finetuning Insertion Heuristic Training Size TSP200 TSP2050Figure 1: Computational challenges of learning large scale TSP. We compare three identical autoregressive GNNbased models trained on 12.8 Million TSP instances via reinforcement learning. We plot average optimality gap to the Concorde solver on 1,280 heldout TSP200 instances vs. number of training samples (left) and wall clock time (right) during the learning process. Training on large TSP200 from scratch is intractable and sample inefﬁcient. Active Search [ 6], which learns to directly overﬁt to the 1,280 heldout samples, further demonstrates the computational challenge of memorizing very few TSP200 instances. Comparatively, learning efﬁciently from trivial TSP20TSP50 allows models to better generalize to TSP200 in a zeroshot manner, indicating positive knowledge transfer from small to large graphs. Performance can further improve via rapid ﬁnetuning on 1.28 Million TSP200 instances or by Active Search. Within our computational budget, a simple nonlearnt furthest insertion heuristic still outperforms all models. Precise experimental setup is described in Appendix A . Motivation Scaling endtoend approaches to practical and realworld instances is still an open question [ 7] as the training phase of stateoftheart models on large graphs is extremely time consuming. For graphs larger than few hundreds of nodes, the gap between GNNbased solvers and simple nonlearnt heuristics is especially evident for routing problems like TSP [42, 37]. As an illustration, Figure 1 presents the computational challenge of learning TSP on 200node graphs (TSP200) in terms of both sample efﬁciency and wall clock time. Surprisingly, it is difﬁcult to outperform a simple insertion heuristic when directly training on 12.8 Million TSP200 samples for 500 hours on universityscale hardware. We advocate for an alternative to expensive largescale training: learning efﬁciently from trivially small TSP and transferring the learnt policy to larger graphs in a zeroshot fashion or via fast ﬁnetuning. Thus, identifying promising inductive biases, architectures and learning paradigms that enable such zeroshot generalization to large and more complex instances is a key concern for training practical solvers for realworld problems. Contributions Towards endtoend learning of scaleinvariant TSP solvers, we unify several stateoftheart architectures and learning paradigms [ 54,42,17,37] into one experimental pipeline and provide the ﬁrst principled investigation on zeroshot generalization to large instances. Our ﬁndings suggest that learning scaleinvariant TSP solvers requires rethinking the status quo of neural combinatorial optimization to explicitly account for generalization: •The prevalent evaluation paradigm overshadows models’ poor generalization capabilities by measuring performance on ﬁxed or trivially small TSP sizes. •Generalization performance of GNN aggregation functions and normalization schemes beneﬁts from explicit redesigns which account for shifting graph distributions, and can be further boosted by enforcing regularities such as constant graph diameters when deﬁning problems using graphs. •Autoregressive decoding enforces a sequential inductive bias which improves generalization over nonautoregressive models, but is costlier in terms of inference time. •Models trained with expert supervision are more amenable to posthoc search, while rein forcement learning approaches scale better with more computation as they do not rely on labelled data. Our framework and datasets are available online3. Additionally, we use our pipeline to characterize the recent stateoftheart in deep learning for routing problems and provide new directions for future research [35]. 3https://github.com/chaitjo/learningtsp 22 Related Work","NP-hard combinatorial optimization problems are intractable to solve optimally at large scales. Among them, the 2D Euclidean Travelling Salesperson Problem (TSP) has been the most intensely studied NP-hard graph problem. In this paper, we present a novel approach to learning large-scale TSP via reinforcement learning. We compare three identical autoregressive GNN-based models trained on 12.8 Million TSP200 instances via reinforcement learning. We show that learning efficiently from trivial TSP200 nodes is in terms of both sample efficiency and wall clock time","70,70"
139,Multiparty Routing: Secure Routing for Mixnets.txt,"Anonymous communication networks are important building blocks for online
privacy protection. One approach to achieve anonymity is to relay messages
through multiple routers, where each router shuffles messages independently. To
achieve anonymity, at least one router needs to be honest. In the presence of
an adversary that is controlling a subset of the routers unbiased routing is
important for guaranteeing anonymity. However, the routing strategy also
influenced other factors such as the scalability and the performance of the
system. One solution is to use a fixed route for relaying all messages with
many routers. If the route is not fixed the routing decision can either be made
by the communication initiator or the intermediate routers. However, the
existing routing types each have limitations. For example, one faces
scalability issues when increasing the throughput of systems with fixed routes.
Moreover, when the routing decision is left to the initiator, the initiator
needs to maintain an up-to-date view of the system at all times, which also
does not scale. If the routing decision is left to intermediate routers the
routing of the communication can be influenced by an adversary. In this work,
we propose a novel multiparty routing approach for anonymous communication that
addresses these shortcomings. We distribute the routing decision and verify the
correctness of routing to achieve routing integrity. More concretely, we
provide a mixnet design that uses our routing approach and that in addition,
addresses load balancing. We show that our system is secure against a global
active adversary.","Anonymous communication networks (ACNs) provide se cure communication channels that hide not only data contents but also the communications’ metadata, thus providing protec tion against trafﬁc analysis. By routing data through multiple proxies, ACNs prevent network eavesdroppers from linking the source and destination of messages. Furthermore, ACNs enable senders to communicate with potentially malicious destinations without revealing their identity or location. ACNs are typically overlay networks consisting of a set of dedicated routers, also called relays, that are connected via the Internet. The ﬁrst ACN design in the early 1980s [1] introduced the concept of mixes for implementing anonymous email. These mixes are relays that collect a batch of Nequal size messages, cryptographically transform them, and output them in a reshufﬂed form, so that the output messages cannot be traced to their corresponding inputs based on message content, size, timing or order. The best known ACN is Tor [2]. The Tor network is an ACN that consists of about seven thousands relays run by volunteers, and provides service to an estimated two million daily users who use it primarily to anonymously browse the web [3]. Other examples of ACN networks include for example Mixminion [4] an anonymousremailer, Freenet [5], [6] used for anonymous ﬁlesharing, and DCNets [7] that can be deployed for broadcast applications such as group messaging. The goal of ACNs is to anonymize communications by relaying them over multiple routers. There are three main types of anonymous routing in terms of how routers are chosen to form the path. First, in deterministic routing , the paths are predetermined by the system conﬁguration. Chaum’s original ACN pro posal [1] considered a sequence of mixes organized in a cascade . Systems that adopted the cascade network topology in their designs include JAP [8], and voting systems, such as Helios [9]. An advantage of cascades is that routing headers are unnecessary, since the next hop in the path is predetermined. Cascades however, are of limited practicality due to their poor scalability, limited anonymity, and lack of resilience to router failures [10]. Second, in source routing , the full path is chosen by the initiator of the communication. This is the routing used by Tor [2] and by anonymous remailers such as Mixmaster [11] and Mixminion [4]. In comparison to cascades, source routing is more resilient against failures of routers [12]; it is more scalable, meaning that the network can grow to accommodate more users; and consequently, can provide better anonymity to those users. However, an important requirement in source routing is that the initiator must have a full view of the network, since otherwise partial network knowledge can be exploited by an adversary to ﬁngerprint and identify users based on which relays they choose [13]. As a consequence, all users need to periodically download the full list of currently available routers, their addresses, public keys, and other routingrelevant information. This is a major bottleneck for the scalability of the network, particularly if the routers have a high churn – as is often the case in peertopeer networks. Third, in hopbyhop routing each router locally decides on the next router of the path. Hopbyhop routing is advantageous over source routing because it does not require entities to maintain an uptodate view of the full network, as well as allows for better load balancing. The main disadvantage of hopbyhop routing is that it is vulnerable to route capture attacks, where a malicious relay can gain full control over the route of a message, so that it is relayed through adversarial relays [14]. The earliest ACN employing hopbyhop routing is Crowds [15], and another example is Morphmix [16], which uses witnesses to mitigate route capture attacks. In this paper we propose multiparty routing , a novel type of anonymous routing that broadens the design space with aarXiv:1708.03387v2  [cs.CR]  9 Nov 2017fourth kind of routing. Our solution comes with important advantages over the previous routing approaches. Multiparty routing offers a scalability advantage over source routing: in our proposal the communication initiators need to only know one (or a small number) of routers, compared to the full view required in source routing. At the same time, we prevent the route capture attacks of hopbyhop routing by decentralizing the routing decision using a multiparty computation technique. In addition to anonymity, our protocol guarantees the integrity of both shufﬂes and routing, which is novel for ACNs. Our main contribution is a concrete multiparty routing protocol that employs cryptographic primitives, such as com mitment schemes, signatures, and cryptographic hash func tions. We combine our routing protocol with a mix network that employs provable shufﬂes, threshold decryption, and rerandomizable encryption to realize secure and veriﬁable anonymous communication, and load balancing. Our solution achieves security against global active adversaries and offers improved resilience and scalability against relay failures com pared to deterministic and source routing. We achieve close to optimal load balancing by integrating relevant information about the throughput of relays into the routing strategy. Our protocol is a midlatency anonymous communication network and thus can be deployed for applications that are more tolerant to latency such as anonymous wiki, microblogging, voting, and auctions. II. R ELATED WORK","Anonymous communication networks (ACNs) are overlay networks consisting of a set of dedicated routers, also called relays, that are connected via the Internet. The goal of ACNs is to anonymize communications by relaying them over multiple routers. There are three main types of anonymous routing in terms of how routers are chosen to form the path. First, in deterministic routing, the paths are predetermined by the system configuration. Second, in source routing, the full path is chosen by the initiator of the communication. In this paper, we propose multiparty routing","80,70"
159,Performance Analysis of Observation Based Cooperation Enforcement in Ad Hoc Networks.txt,"Node misbehavior due to selfish or malicious behavior could significantly
degrade the performance of MANET because most existing routing protocols in
MANET aim to find the most efficient path. Overhearing and reputation based
cooperation schemes have been used to detect and isolate the misbehaving nodes
as well as to force them to cooperate. Performance analysis has been done for
the network traffic using OCEAN over DSR on ns2 while considering the low
energy levels for mobile nodes. Throughput, energy level, routing packets and
normalized routing overhead are analyzed for OCEAN and normal DSR to show the
impact of OCEAN on the overall network performance.","Mobile ad hoc network (MANET)  is a group of wireless  mobile computers (or nodes), in which nodes cooperate by  forwarding packets for each other to allow them to communicate beyond direct wireless transmission range [1]. Ad hoc networks require no centralized administration or fixed ne twork infrastructure such as base stations or access  points, and can be quickly and inexpensively set up as needed. They can be used in scenarios in which no infrastructure exists, or in which the existing infrastructure does not meet application requirements for reasons such as security or cost.    These nodes generally have a limited transmission range and, so, each node seeks the assistance of its neighboring nodes in forwarding packets. Specially configured routing protocols are used in order to establish  routes between  nodes which are further than a single hop. However, cooperation among the nodes is not guaranteed in a real  world network and the presence of misbehaving nodes could degrade the network performance significantly.    MANETs are highly vulnerab le to several types of attacks,  due to their open medium, lack of centralized monitoring, management point, and lack of strong line of defense.  Selfish nodes misbehave to save power or to improve their access to service relative to others  [6]. Malicious n odes  always attack the network's availability through common techniques such as flo oding, black hole and denial of  service attacks .   Many contributions to prevent misbehavior have been submitted so far, such as payment schemes for network services, secure routing protocols, intrusion detection, economic incentives and distributed reputation systems to detect and isolate misbehaved nodes  [2] [4]. These exiting  approaches alleviate some of the problems, but not all.  Despite that these schemes have proved eff ective. Second  hand reputation systems require nodes in the network to exchange reputation information about other nodes  [8] [9].   As a result, exchanging second hand reputation  information opens up a new vulnerability, since nodes may falsely accuse other  nodes of misbehaving. If a node  observes another node participating incorrectly, it reports this observation to other nodes who then take action to avoid being affected by the misbehavior and perhaps even punish the node by refusing to forward its traffic. Making a decision about whether to believe an accusation requires authenticating and trusting the accusing node. Such trust maintenance could be performed offline or could be bootstrapped during network operations. In the former case,  IJCSI International Journal of Computer Science Issues, Vol. 8, Issue 6, No 2, November 2011  ISSN (Online): 16940814  www.IJCSI.org 79    the network require s a priori trust relationships that may  not be practical in truly ad hoc networks. In the latter case,  bootstrapping trust relationships in ad hoc networks involves significant complexity and risk and may not be reasonable for a very dynamic or short lived  network.    In this paper, OCEAN (Observation based Cooperation  Enforcement in Ad hoc Network) was used in forbidding all kinds of indirect reputation information  [1]. A node  makes routing decisions based solely on direct observations of its neighboring nodes’ exchanges with it. This eliminates most trust management complexity, albeit at a cost of less information with which to make decisions about node behavior  [3].   The rest of this paper is organized as follows: Section 2 describes the similar research th at has already been done in  this area. The detailed protocol is explained in Section 3. The simulation environment is provided in section 4. The results and discussion is in section 5. Finally, section 6 concludes the paper.   2. Related Work","Mobile ad hoc network (MANET) is a group of wireless mobile computers (or nodes) which cooperate by forwarding packets for each other to allow them to communicate beyond direct wireless transmission range. In this paper, we propose OCEAN (Observation based Cooperation Enforcement in Ad hoc Network), a protocol for preventing misbehavior in MANETs. OCEAN is based on direct observations of the nodes' exchanges with each other. OCEAN eliminates most of the complexity and provides nodes'","80,90"
238,Impact of Mobility on Power Consumption in RPL.txt,"The main theme of this paper is to implement the mobility model in Cooja
simulator and to investigate the impact of the mobility on the performance of
Routing Protocol over Low power Lossy networks (RPL) in the IoT environment. In
the real world, mobility occurs frequently. Therefore in this paper, a
frequently used mobility model -- Random Way Point (RWP) is used for analysis.
RWP can be readily applied to many existing applications. By default, the Cooja
simulator does not support mobility models. For this, the Bonn Motion is
introduced into Cooja as a plugin. As IoT deals with the resource-constrained
environment, a comparison is done between the static environment and the mobile
environment in terms of power consumption. As expected, the results indicate
that mobility affects the RPL in terms of Power Consumption.","Till now the internet is being used for browsing the web,  accessing multimedia content, playing games, social  networking, and topic search, sending and receiving  emails and in many other tasks and now the trend is  shifting towards usage of the internet as a global platform  for communication between machines (M2M). Within the  next few years, the Internet will turn as a seamless platform  for traditional networks as well as networked objects thus  paving a way to a new era of Interconnected Smart  Objects forming Pervasive Computing Environments  (Weiser, 1999). This does not mean that Internet infrastructure will  disappear. It will continue its role as a global backbone for  WWW but in addition, extends its hand towards  interconnecting physical objects with computing and  communication capabilities across a wide range of  services and technologies (Smart Objects). This can be  achieved by embedding electronics into physical  objects making them Smart Objects. Smart objects (or  things) can be defined as the entities (Miorandi et al.,  2012) that have a physical embodiment and a set of  associated physical features (e.g., size, shape, etc.), and have a minimal set of communication functionalities,  such as ability to be discovered and to accept incoming  messages and reply to them, possess a unique identifier,  associated to at least one name and one address,  possess some basic computing capabilities, may  possess some means to sense physical phenomena  (e.g., temperature, light, electromagnetic radiation). The  term Internet of Things was first coined by Kevin Ashton in  1999 in the context of supply chain management  (Ashton, 2009). The three pillars of IoT are: Being identifiable, Is being communicable, and Being interactive (ability to interact with anything). The InternetofThings can be treated as a highly dynamic  distributed networked system with a large number of  smart objects that are capable of producing and  consuming highly dynamic information. The vision of IoT  provides opportunities to manufacturers and companies  including users. It will find wide applicability in many  sectors, such as agriculture, environmental monitoring,  healthcare, product management, inventory  management, home automation, transportation, and  logistics domain, supply chain management, disaster · · · 23 l imanager ’s Journal o  Wireless Communication Networks  Vol.  No. 4l n ,  6   Januar y  March 2018alerting and recovery, utilities, enterprise, security, and  surveillance. The features of the IoT can be identified as Device  heterogeneity, Scalability, Ubiquitous data exchange,  Poweroptimized solutions, Localization and tracking  capabilities, SelfOrganization Capabilities, Semantic  Interoperability, PrivacyPreserving, and Security. Internet  of Things (IoT) ecosystem is a complex environment  consisting of much heterogeneous hardware as well as  software components. A large amount of data will be  generated by sensors in the real world and hence impose  a great demand for data storage and data processing  which can later be converted into useful services or  information. Some applications need very complex  processing procedures that include historical data and  time series analysis, whereas some applications are  sensitive to latency and some applications are very  simple in nature. Therefore, it is very difficult to imagine a  realworld and ultrascale IoT system without including a  Cloud or some powerful devices. In IoT, a resource may go from physical resources, for  example, memory, CPU, Network Bandwidth, Power and  so forth, to programming resources like virtualization  function, strategies that perform data combination, or  methods to distinguish a mindboggling occasion, and  so on. In cloud computing systems, the provision of  service is pay per use, dynamic and elastic model. This  depends on the formal or semiformal contracts between  the customer and the cloud supplier. The resource  allocation involves complicated algorithms to allocate  better physical or virtual resources to applications. In IoT, the necessities of resource distribution mechanism  for cloud computing holds great yet with some extra  prerequisites like adapting up to the adhoc nature of IoT  and astute adhoc cooperations among gadgets and  clients. Interactions for the administration arrangement in  IoT makes the procedure of resource allotting and  administration more intricate than in customary cloud  computing. IoT frameworks handle hundreds, thousands,  or a large number of parallel solicitations and a few kinds  of utilization request quick reaction, inside a strict time  interim. In IoT, multiple applications with potentially different requirements will be sharing the same resources  (Delicato et al., 2017). Priority in access to shared  resources should be given to timecritical applications,  whereas in noncritical applications should guarantee  that its requirements are met. Additionally, the nature of  information created by IoT gadgets likewise influences its  handling. Sensors deliver a tremendous amount of data  which can be data stream, w hich ranges from a c ouple  of bytes for every second to a couple of gigabits for every  second. This information rate can be sporadic, unusual,  and bursty in nature. Dealing with the resources  associated with handling IoT data and conveying IoT  administrations need to take into account the following  issues: resource constraints like Computational  constraints, Storage problems, Bandwidth Constraints,  Applicationaware protocols/Contextaware protocols,  and Infrastructure support. 1. Literature Review 1.1 RPL RPL (Winter et al., 2012) is a routing protocol for low power  and Lossy networks designed by the IETF Routing over Low  power and Lossy network (ROLL) group, utilized as the  current routing protocol in Contiki. RPL gives a mechanism  to disperse data over the powerfully shaped network  topology. This dissemination empowers negligible design  in the nodes, enabling nodes to work generally selfruling.  RPL fundamentally underpins multipointtopoint traffic,  with sensible help for pointtomultipoint traffic and  essential highlights for pointtopoint traffic. It operates  under the assumption that the network contains a sink  node with greater computing ability and power resources  than the rest of the nodes in the network. The initial phase in the network registration is Neighbour  Discovery (ND). This causes the node to decide the  neighbors in the region and to choose the best parent  accessible. The node will initially transmit an RS (Router  Solicitation) packet as a multicast to each and every  routers. On getting the RS packet, every one of the routers  reacts back with an RA (Router Advertisement) as a  unicast to the node. The RA packet contains Prefix  Information (PIO), Context Option (CO), and Authoritative RESEARCH PAPERS 24 imanager ’s Journal o  Wireless Communication Networks  n , l l Vol. 6  No. 4  Januar y  March 2018Border Router Option (ABRO). After accepting the RA, the node chooses a router as its  default router (in light of first got RA) and infers the  worldwide IPv6 address in view of the prefix option. The  node at that point sends a Neighbour Solicitation (NS) as a  unicast message to its default router. The NS will contain  the Address Registration Option (ARO). This option will tell  the switch that the hub is straightforwardly reachable and  furthermore the connection layer address of the node.  The switch will influence a passage of the node in its  Neighbour to reserve and react with a Neighbour  Advertisement (NA) with the status of address enrolment. After Neighbour Discovery, RPL is introduced and the  network enrolment process will start (Tsvetkov & Klein,  2011). RPL builds a graph known as Destination Oriented  Directed Acyclic Graph (DODAG). The whole network  topology will be divided into multiple RPL instances. These  RPL instances is an arrangement of different DODAG.  Each DODAG is extraordinarily recognized by DODAGID  (Winter et al., 2012). Directed Acyclic Graph (DAG) : A directed graph  having the property that all edges are arranged such that  no cycles exist. All edges are contained in paths situated  toward and ending at least one root nodes. DAG root: A DAG root is a node inside the DAG that  has no outgoing edges. Since the graph is noncyclic, by  definition, all DAGs must have no less than one DAG root  and all paths end at a DAG root. DestinationOriented DAG (DODAG): A DAG  established at a solitary destination, i.e., at a solitary DAG  root (the DODAG root) with no outgoing edges. DODAG root: A DODAG root is the DAG base of a  DODAG. The DODAG root may go about as a border  router for the DODAG; specifically, it might total routes in  the DODAG and may redistribute DODAG routes into other  router protocols. Virtual DODAG root: A Virtual DODAG root is the after effect of at least two RPL routers, for example, 6LoWPAN  Border Routers (6LBRs), organizing to synchronize DODAG  state and act in the show as though they are a solitary  DODAG root (with different interfaces), as for the LLN. The · · · · ·coordination doubtlessly happens between controlled  gadgets over a solid travel interface. Up: Up alludes to the heading from leaf nodes  towards DODAG roots, following DODAG edges. This is  utilized in graphs and depth firstsearch, where vertices  from the root are deeper or ""down"" and vertices closer to  the root are ""shallower"" or ""up"". Down: Down alludes to the course from DODAG roots  towards leaf nodes, reverse of DODAG edges. This takes is  utilized as a pa rt of graphs and depth firstsearch, wh ere  vertices advance from the root are deeper or ""down"" and  vertices closer to the root are ""shallower"" or ""up"". Rank: A node's Rank characterizes the node's  individual position in respect to different nodes  concerning a DODAG root. Rank entirely increments in the  Downward direction and entirely reduces in the Up  direction. This upon the DAG's Objective Function (OF).  The Rank may similarly track a basic topological distance,  might be figured as an element of connection  measurements, and may consider different properties,  for example, constraints. Objective Function (OF): An OF characterizes how  routing metrics, optimization objectives, and related  functions are utilized to process Rank. Moreover, the OF  directs how parents in the DODAG are chosen and,  subsequently, the DODAG arrangement. Objective Code Point (OCP): An OCP is an identifier  that demonstrates which Objective Function, the DODAG  uses. RPLInstanceID: An RPLInstanceID is one of a kind  identifier inside a network. DODAGs with the same  RPLInstanceID share a same Objective Function. RPL is the only one of the protocols presented, which may  also employ source routing. This occurs when it is  operating in nonstoring mode (Herberg & Clausen,  2011), which gives a basic assessment of the RPL  protocol. Among others, it records its firmness as far as  data traffic, particularly pointtopoint activity,  conceivable control packet discontinuity and the  suspicion of bidirectional connections as hazardous  purposes of the specification.· · · · · ·RESEARCH PAPERS 25 l imanager ’s Journal o  Wireless Communication Networks  Vol.  No. 4l n ,  6   Januar y  March 20181.2 PowerAware Metrics Metrics are utilized to evaluate the nature of a connection  or route under specific angles. The most commonly sent  metric is Hop Count, with which the route utilizing the least  hops is picked. Be that as it may, this is frequently not as  much as perfect: not all connections are made  equivalent in quality, and longdistance links are  particularly inclined to be lossy. Powerawareness might  be acquainted with existing routing protocols with the  assistance of appropriate metrics. A metric which takes power levels on either the node or  network level may impact the routing choices of a  protocol in a way which preserves power resources.  Vasseur et al. (2011) specify the several routing metrics for  the Routing Protocol for Low Power and Lossy Networks  (RPL) protocol, some of which may be interesting for other  deployments as well, and the notable are: Node Power: The power level of a node might be  considered in various ways: Most instinctively, it might be  received to pick a route  over nodes  with extraordinar y  leftover  power , keeping  in mind  the end goal to stretch  its  lifetime  and alleviate  nodes  with fewer  resources . In doing   as such, the estimation  of remaining  power  must  be put into  the setting  by the transceiver  expenses  of the individual   node  and in addition  its normal  lifetime . It might  be useful  to  utilize  a node  with less batter y which  is probably  going  to be  energized  sooner  rather  than later (e.g. a cell phone  on the  nightstand)  than one with high remaining  power  that needs  to keep going for some time (e.g. a node in the wall). Throughput: At the point when the information sent  over a router surpasses the measure of throughput, it can  deal with, the subsequent packet errors will cause  retransmissions, squandering power on excess  communication. Hence, a router may determine the  throughput it can deal with. Latency: Distinctive kinds of data may have diverse  latency constraints, for example, in light of the fact that  the information may wind up rapidly, is critical if there  should arise an occurrence of a crisis or may trigger  timeouts. By considering these necessities, a convention  can disseminate  the network  stack  in a way that backings  · · ·diverse  traffic  prerequisites . These  methodologies  can be  joined:  (Ortiz  et al., 2013)  have  proposed  the utilization  of  Fuzzy Logic to consolidate  a few applicable  attributes  of a  course  or conn ection into one explanation about its  quality. 2. Background 2.1 6LoWPAN and Routing Protocol for Low Power Lossy  Networks Internet Engineering Task Force (IETF) revealed the IPv6  over LowPower  Wireless  Personal  Area Networks  (6LoWPAN).  6LoWPAN characterizes  an arrangement  of protocols  that  can be utilized  to coordinate  the sensor  nodes  with IPv6  systems. Some com mercial products have already  released  the protocol  suite with core protocols  composing   the 6LoWPAN architecture . An applicable  IETF Working   Group  named  Routing  Over  Low power  and Lossy systems   (ROLL)  has recently  created  the RPL routing  protocol  draft,  which  is the reason  for routing  over low power  and lossy  systems  including 6L oWPAN. The RPL  protocol develops  as  the accepted  IPv6 routing  standard  for WSN. It is a tree arranged routing protocol to shape a Destination Oriented Directed Acyclic Graph (DODAG) with some  characterized measurements and an objective function  to control the choice of the best way to the root node. RPL provides a mechanism to disseminate information  over the dynamically formed network topology by a set of  ICMPv6 control messages, such as DIO, DAO, and DIS  (Zhang & Li, 2014). DIO message contains information about the rank,  the objective function, the node id, and so on. It  defines and maintains upward routes. DAO message promotes prefix reachability towards  the client nodes of a DODAG to empower downward  traffic. DIS message is utilized to proactively request the  DODAG related data from neighboring nodes. Generated Data from the nodes will be received by the  root node. The root node in RPL is like a connection  between the wireless sensor network and the internet. RPL  still needs a lot of contributions to reach a full solution.  Some of which are power consumption without losing · · ·RESEARCH PAPERS 26 imanager ’s Journal o  Wireless Communication Networks  n , l l Vol. 6  No. 4  Januar y  March 2018accuracy. As the sensor nodes have limited supply of  power, Power consumption is a big issue in IoT. Hence,  routing protocols for IoT should be designed such that it  maximizes the powerconsumption. Sensor nodes can  act as a sender, receiver, or a router. Any malfunctioning  of the sensor nodes is not accepted and hence the  accuracy of the routing protocols is maintained in the  presence of low power sensor nodes in another aspect of  power concern. 2.2 Mobility Models The mobility models are classified into two principles  considering specific mobility characteristics of each  model. In real life environment, the common mobility  model is Trace Model which is the first mobility model to  be considered. Traces give exact data, particularly when they include countless participants and a properly long  perception period. The second mobility model is the  synthetic model (Sanchez & Manzoni, 1999), which  attempts to sensibly represent to the practices of MNs  without utilization of traces. This model contains two types,  viz., a group mobility model and an entity mobility model  as shown in Figure 1. A mobility model should attempt to copy the  developments of real Mobile Nodes (MNs). Alters in speed  and course should be insensible time slots. For instance,  MNs need not travel in straight lines at consistent speeds  over the span of the whole simulation, since real MNs  would not go in such a limited way. In this paper, different  synthetic entity mobility models for ad hoc networks are  discussed.RESEARCH PAPERS Figure 1. Structure of Mobility Models  27 l imanager ’s Journal o  Wireless Communication Networks  Vol.  No. 4l n ,  6   Januar y  March 20182.2.1 Entity Mobility Models Seven mobility models were proposed for (or utilized as a  part of) the execution assessment of an adhoc network  protocol. The principal model, the Random Way Point  (RWP) Mobility Model is the most widely recognized  mobility model utilized by specialists and RWP mobility  model is utilized for investigation in this paper. Therefore,  RWP is discussed in more depth than the other six models  presented. 2.2.2 Random Way Point (RWP) Mobility Model RWP mobility model is the famous model utilized by the  exploration community as a result of its wide accessibility  and its effortlessness to utilize. The RWP model was  proposed by (Johansson et al., 1999; Broch et al., 1998).  In simulation fields, the mobile node selects a position (x,  y) randomly as a destination and choose randomly and  uniformly the velocity from a range (V, V) to travel min max towards the destination. When it reaches the destination, the node stops for little  time called 'pause time' parameter, T. After this pause timeframe, the node picks one progressively another  destination randomly  towards  it, and a constant  similar   procedure  is followed until the point  when  simulation  closes, In the RWP model, the mobility behavior of nodes will be  decided by two main parameters: V and T. The max pause topology of AdHoc network will be in the stable mode  when the V is minimum and T is long. In a similar way, max pause when V is maximum and T is low, the adhoc network max pause will be in dynamic mode (Bai et al., 2003). These two  parameters play a major role in the RWP model. By varying  these parameters, mainly the V parameter, various max mobility situations can be generated with various node  speed. Subsequently, it appears to be imperative to  measure the node speed. One of the ideas is the average node speed. When T is pause 0, assuming V is consistently and randomly chosen max between [0, V], then the average node speed will be max 0.5 V (Camp et al., 2002). Be that as it may, the T max pause parameter should not be ignored because it is the relative  speed of two nodes that choose if the bridge between  them breaks or forms, rather than their individual rates (Kaur, 2012). In this way, average node speed gives off an  impression of being the fitting metric to represent node  speed. For instance, the development hint of a node is  shown in Figure 2. From (Johansson et al., 1999), the mobility metric to catch  and measure this node speed with the relative speed  between nodes i and j at time t is: RS(i, j, t) = (1) By then, the Mo bility me tric M is figured as th e proportion  of relative speed landed at the midpoint of overall node  sets and in overall time (Kaur, 2012). (2) where |i, j| is the quantity of particular node match (i, j), n is the aggregate number of nodes in the simulation field,  and T is the simulation time. 2.2.3 Random Walk (RW) Mobility Model This mobility model was produced and portrayed  numerically by Einstein in 1926 to copy the unpredictable  developments of the particles known as Brownian motion.  In this model, a node begins its movement by choosing a  direction with speed from the predetermined extents [0,  2*π] and [0, V]. The node moves for a settled time max interval t or moves for a settled distance d. After distance  d or time t, new direction and speed are chosen from the  predetermined extents (Camp et al., 2002). RW mobility model acts comparatively to the RWP Mobility  Model. In the two models, development of the node has  solid randomness. Moreover, Nodes move along an  unpredictable  path and for this RW is recommended  to RESEARCH PAPERS Figure 2. Example of Node Movement in the R andom W ay Point Model 28 imanager ’s Journal o  Wireless Communication Networks  n , l l Vol. 6  No. 4  Januar y  March 2018mimic  their development . Besides , nodes  do not preser ve  their speed  and direction , however  it changes  these  two  parameters  in each  time interval. It is considered  as a  memoryless mobility process because each step is  calculated independently with the previous one. 2.2.4 Random Direction (RDM) Mobility Model In this model, the node chooses direction and velocity  from the range (0, 2*π) and (0, V). When node reaches max at the end of th e simulation area, it waits there for pause  time. After the expiry of pause time, another direction will  be chosen from (0, π) and continues to travel towards the  end of the simulation area in a new direction. This process  of choosing random direction and velocity continues until  the completion of the simulation. RDM Model is similar to  the RWM Model, but with a small difference like the motion  of the node to the end of simulation instead of constant  time as in RWM. 2.2.5 Gauss Markov (GM) Mobility Model The need of the model, can make the node quicken,  decelerate, or turn persistently. Liang and Haas (1999)  have proposed this model and was generally utilized by  Camp et al. (2002); Hu and Johnson (2000). This model  expresses that the present movement of a node is  identified with the previous movement through Gaussian  conditions by utilizing speed, course, and Gaussian  arbitrary noise. The level of reliance on previous speed  and course is controlled by parameter α. This model is  also known as feature temporal reliance. This model  conducted towards the end of the simulation region can  be expressed in various ways. Bai and Helmy (2004) have  proposed a direction change towards the end without  deciding decisively how this is done. Amoussou et al. (2005) have proposed a 180° turn, this  technique is difficult since it conflicts with one of the  primary reasons behind why the GM model was proposed  in any case; which was to maintain a strategic distance  from sharp turns. Likewise, the transient reliance of GM is  lost here, since the following course has nothing to do with  the past one for this situation . Alenazi  et al. (2013)  have   proposed  an enhanced  3D GM model , which  incorporates   a buffer  zone  to allow  MNs to move  easily  around  the simulation  boundaries  without  bounces  and it works   legitimately  on a twodimensional simulation region. 2.2.6 Prob abilistic Random Walk Mobility Model In this model, (Roy, 2010; Camp et al., 2002) Probability  assumes a major role in the nodes positioning. A node has  several movements like forward, invert, or remain in x and  ydirection, which depends on the probability  characterized in probability framework. PRW Model has  three conditions: 0 (current position), 1 (Past position), and  2 (next position). In the probability framework, p(a, b)  characterizes the node development from state a to b.  The values which are defined will deny movements  between the past and next positions of the MN without  going through the present area. This model is really more than purely random movements,  but choosing the appropriate values of P(a, b) may prove  difficult. The MN moves in straight lines for different periods  of time and does not show the highly variable direction  seen in the RWF Mobility Model. 2.2.7 Boundless Simulation Area (BSA) Mobility Model This mobility model is different from other mobility models.  A connection exists between the previous condition and  the present condition of the node (Hass, 1997). In this  model, the new direction and speed values are subject to  the past direction and speed estimations of the node.  Every time new values of the direction and speed are  given. At the point when a node reaches the end of the  simulation area, it will not reflect again into the simulation  region; rather, it keeps on traveling and returns on the  opposite side of the reenactment zone. This mobility  model makes more practical node development since it  relies upon the past speed and direction of the node. In  the BSA model, Sharp turns and sudden stops can be  disposed. 2.2.8 City Section Mobility Model CSM model (Davies, 2000) is one of the important mobility  models, which sets parameters such as the speed limit of  every node way. Every MN starts the simulation at the  limited intersection  of two node  ways . By going  to the  destination , it includes  one flat and one vertical  movement . RESEARCH PAPERS 29 l imanager ’s Journal o  Wireless Communication Networks  Vol.  No. 4l n ,  6   Januar y  March 2018When  the destination  arrived , MN stops  for some  random   time and after that picks  another  destination  randomly  and  the procedure  is repeated . This procedure  is known  as an  epoch . The CSM model  states  that every MN following   predefined  ways  will raise the average  hop count  in the  simulation field. This model gives sensible movements  compared to other mobility models. 2.3 IoT Routing Protocols Requirements Home Automation, UrbanLow Power, and Lossy Networks  (LLNs) are distinctive applications that have diverse  qualities regarding mo vement, network size, and level of  mobility. Subsequently, the necessities of the routing  protocol contrasts starting with one application then onto  the next application. In spite of these distinctions, the  advantages are grouped into six categories (Martocci et  al., 2010). Mobility: Generally IoT does not encounter  movements, but rather a few applications require the  movement of the nodes to be considered. A reasonable  routing protocol ought to have the capacity to adapt to  the area changes of the nodes. Power Efficiency: The nodes in the IoT environment  are batterydriven, which run selfsufficiently. A routing  protocol that is ingenious as far as power utilization is  crucial to the usefulness of an IoTbased system. Traffic Patterns: A routing protocol for the IoT needs to  coordinate the movement of its zone of sending. Scalability: The measure of the network in IoT may shift  from 100 to 1000000 nodes. Consequently, the routing  protocol intended for the IoT should coordinate the  necessities of the system size. Directionality: In wireless networks, bidirectional  connection between joins are not ensured. A routing  protocol for the IoT must have the capacity to perceive  and keep away from unidirectional connections at any  rate and might have the capacity to utilize them one way. Transmitter usage: Concerning power utilization, the  transmitter is the most costly part of a device. Routing  Protocols may be outfitted with a number of components  influencing the way in which they settle on routing.· · · · · ·3. Methodology",Internet of Things (IoT) is a new era of a distributed networked system with a large number of smart objects that are capable of producing and consuming highly dynamic information. The Internet of Things (IoT) is a complex environment consisting of much heterogeneous hardware as well as software components. The IoT is a highly dynamic distributed networked system with a large number of smart objects that are capable of producing and consuming highly dynamic information. The IoT is a new applications that can be adoT,cool!
162,A Simple Scheme for Distributed Passive Load Balancing in Mobile Ad-hoc Networks.txt,"Efficient routing is one of the key challenges for next generation vehicular
networks in order to provide fast and reliable communication in a smart city
context. Various routing protocols have been proposed for determining optimal
routing paths in highly dynamic topologies. However, it is the dilemma of those
kinds of networks that good paths are used intensively, resulting in congestion
and path quality degradation. In this paper, we adopt ideas from multipath
routing and propose a simple decentral scheme for Mobile Ad-hoc Network (MANET)
routing, which handles passive load balancing without requiring additional
communication effort. It can easily be applied to existing routing protocols to
achieve load balancing without changing the routing process itself. In
comprehensive simulation studies, we apply the proposed load balancing
technique to multiple example protocols and evaluate its effects on the network
performance. The results show that all considered protocols can achieve
significantly higher reliability and improved Packet Delivery Ratio (PDR)
values by applying the proposed load balancing scheme.","Future smart cities will lead to a signiﬁcant growth in the amount of VehicletoInfrastructure (V2I) and Vehicleto Vehicle (V2V) communication [1]. As the network topology is frequently changing due to the mobility behavior of the vehi cles, MANET routing protocols are a promising candidate for ﬁnding reliable communication paths. However, most current mesh routing protocols focus on the determination of a single optimal communication path between sender and destination. High data trafﬁc demands lead to an intense usage of those paths, decreasing the Quality of Service (QoS)capabilities of the applications due to packet collisions and congestion. To overcome these issues, various load balancing strategies have been proposed, which make use of additional coordination and communication in order to signal congested nodes and lower the transmission rates if needed. As these approaches highly raise the protocol complexity, they are rarely applied to real world mesh routing protocols. In recent work [2], we proposed the novel MANET routing protocol B.A.T.Mobile , which uses mobility prediction for optimized forwarding decisions and proactive avoidance of path losses. Every node manages the path quality information of all possible forwarders for a given destination in a scorebased routing table. In this paper, we exploit this property to achieve load balancing using a simple packet distribution scheme. The general idea is that spreading data trafﬁc over multiple suboptimal routing paths will lead to a better overall network performance than using a singleoptimal path. Fig. 1 illustrates the problem statement and shows an example use case for load balancing in the context of V2V communication. However, the proposed method can also be applied in other types of MANETs such as Unmanned Aerial Vehicle (UA V) swarming applications. Our simulation setup has been published as an Open Source framework [3] and is based on the discrete network simulator Objective Modular Network Testbed in C++ (OMNeT++) [4] and its IN ETMANET framework. The remainder of this paper is struc tured as follows: after discussing the related work, we present the system model of our solution approach and describe the key components of the suggested load balancing scheme. In the next section, we describe our simulation environment and the reference scenario for the performance evaluation. Finally, detailed results of comprehensive simulation studies are presented and discussed. II. R ELATED WORK","In this paper, we propose a novel load balancing scheme for vehicular-to-vehicle (V2V) communication in mesh networks (MANETs). The proposed scheme uses a simple packet distribution scheme to distribute data traffic over multiple suboptimal routing paths. The proposed scheme is based on the objective modular network testbed in C++ (OMNeT++) and its IN ETMANET framework. The proposed scheme is based on a simple packet distribution scheme, which is based on the mobility prediction of the route.",cool!
322,Genetic Improvement of Routing Protocols for Delay Tolerant Networks.txt,"Routing plays a fundamental role in network applications, but it is
especially challenging in Delay Tolerant Networks (DTNs). These are a kind of
mobile ad hoc networks made of e.g. (possibly, unmanned) vehicles and humans
where, despite a lack of continuous connectivity, data must be transmitted
while the network conditions change due to the nodes' mobility. In these
contexts, routing is NP-hard and is usually solved by heuristic ""store and
forward"" replication-based approaches, where multiple copies of the same
message are moved and stored across nodes in the hope that at least one will
reach its destination. Still, the existing routing protocols produce relatively
low delivery probabilities. Here, we genetically improve two routing protocols
widely adopted in DTNs, namely Epidemic and PRoPHET, in the attempt to optimize
their delivery probability. First, we dissect them into their fundamental
components, i.e., functionalities such as checking if a node can transfer data,
or sending messages to all connections. Then, we apply Genetic Improvement (GI)
to manipulate these components as terminal nodes of evolving trees. We apply
this methodology, in silico, to six test cases of urban networks made of
hundreds of nodes, and find that GI produces consistent gains in delivery
probability in four cases. We then verify if this improvement entails a
worsening of other relevant network metrics, such as latency and buffer time.
Finally, we compare the logics of the best evolved protocols with those of the
baseline protocols, and we discuss the generalizability of the results across
test cases.","A fundamental element in many modern applications is the use of networked systems: be it environment monitoring, smart industries, smart cities, or distribution systems, networks of various scales and complexity are employed today practically everywhere. One of the most important aspects in networking is the concept of network protocol , i.e., a set of welldefined data format and rules that allow nodes in a network to communicate with each other [Holzmann, Gerard J 1991]. Typically, a physical network relies on multiple protocols, which are arranged as a protocol stack where protocols at lower layers provide basic functionalities which are progressively enriched by Authors’ address: Michela Lorandi, michela.lorandi@studenti.unitn.it; Leonardo Lucio Custode, leonardo.custode@unitn.it; Giovanni Iacca, giovanni.iacca@unitn.it, Department of Information Engineering and Computer Science, University of Trento, Via Sommarive 9, Povo, Italy, 38123. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. ©2021 Association for Computing Machinery. 26883007/2021/3ARTxxx $15.00 https://doi.org/10.1145/nnnnnnn.nnnnnnn ACM Trans. Evol. Learn., Vol. 1, No. 1, Article xxx. Publication date: March 2021.arXiv:2103.07428v1  [cs.NI]  12 Mar 2021xxx:2 Lorandi, et al. the higher layer protocols. Among those basic functionalities, routing is a crucial one, as it allows data to flow across the network and reach their destination. While wellestablished efficient routing protocols exist for IP networks, routing in mobile ad hoc networks (MANETs) and other Internet of Things (IoT) instances, such as networks of cars, unmanned vehicles, or collectives of vehicles and humans, is still a very active area of research. One particularly challenging kind of MANETs is represented by the delay tolerant networks (DTNs), also known as disruption tolerant networks , opportunistic networks orintermittently connected wireless networks . Originally designed in the 1970s for space communications, but applied since the early 2000s also to terrestrial applications such as urban mobile networks, DTNs are (typically, heterogeneous) decentralized networks that lack continuous connectivity due to their node sparsity, limited wireless radio access, and limited energy resources. In these contexts, routing is NPhard [Balasubramanian, Aruna and Levine, Brian and Venkatara mani, Arun 2007] and as such it is usually solved by heuristic (besteffort) “store and forward” replicationbased approaches, where multiple copies of the same message are moved and stored across nodes in the hope that at least one will eventually reach its destination. Still, the sparsity and mobility of the nodes causes unpredictable meeting patterns and frequent disconnections [Alouf, Sara and Neglia, Giovanni and Carreras, Iacopo and Miorandi, Daniele and Fialho, Álvaro 2010], which result in relatively low data delivery probabilities (also called delivery rates, or delivery ra tios), even with wellestablished protocols such as Epidemic [Amin Vahdat and David Becker 2000], PRoPHET [Lindgren, Anders and Doria, Avri and Schelén, Olov 2003], and their variants. As shown in [Abolhasan, Mehran and Wysocki, Tadeusz and Dutkiewicz, Eryk 2004; Boukerche, Azzedine and Turgut, Begumhan and Aydin, Nevin and Ahmad, Mohammad Z and Bölöni, Ladislau and Turgut, Damla 2011; Hong, Xiaoyan and Xu, Kaixin and Gerla, Mario 2002], the node density and their mobility affect the delivery probability in most kinds of MANETs (not only DTNs), although the problem is further exacerbated in DTNs: while in dense MANETs composed of slowmoving nodes (e.g. pedestrians) the delivery probability obtained by stateoftheart routing protocols can be higher than 90% [Johansson, Per and Larsson, Tony and Hedman, Nicklas and Mielczarek, Bartosz and Degermark, Mikael 1999], in sparse MANETs made of fastmoving nodes (e.g. vehicles) the delivery probability can be as low as 1518%, [Clausen, Thomas 2004; Saudi, Nur Amirah Mohd and Arshad, Mohamad Asrol and Buja, Alya Geogiana and Fadzil, Ahmad Firdaus Ahmad and Saidi, Raihana Md 2019]. Furthermore, other factors such as the number of sources (i.e., the nodes transmitting data) can also affect the delivery probability: the lower the number of sources, the higher the delivery probability [Clausen, Thomas 2004; Perkins, Charles E and Royer, Elizabeth M and Das, Samir R and Marina, Mahesh K 2001]. Traditionally, network protocols are modelled as a reactive system , i.e., a twoplayer game (agent vs environment) where an agent (a node in the network) reacts , by performing a certain action, to predefined conditions in the environment (the rest of the network): for instance, the agent retries a message transmission if it does not receive an acknowledgment. As such, a protocol can be described with an automaton, for which formal specifications can be logically expressed and verified. For that, one usually needs to have complete knowledge about (and strict assumptions on) the environment. This approach, rooted in the theory of Temporal Logic and infinite (Büchi) automata [Buchi, J Richard and Landweber, Lawrence H 1990], has been the gold standard in protocol design and verification for decades. However, there are limitations. First of all, this way of designing protocols assumes in general the environment, and all its states, to be known: this is usually not the case for DTNs, where the environment conditions can be unpredictable due to the nodes’ mobility. Secondly, the numerical (time and space) complexity of these design methods makes them impractical when the number of states of protocol and environment grows [Vardi, Moshe Y 2018]. This is the case of DTNs, where the number of states of the environment can be ACM Trans. Evol. Learn., Vol. 1, No. 1, Article xxx. Publication date: March 2021.Genetic Improvement of Routing Protocols for Delay Tolerant Networks xxx:3 very large, depending on the number of nodes and their state. For these reasons, finding a way to design better routing protocols for DTNs, or at least improving the performance of the existing ones, is still an open research question. Here, we consider the Genetic Improvement (GI) [Langdon, William B 2015] of two of the main routing protocols used in DTNs, namely Epidemic and PRoPHET. Our methodology consists in the following: first, we dissect the two protocols into their fundamental components, i.e., basic network functionalities such as checking if a node can start transferring data, or sending messages to all connections; then, we apply Genetic Programming (GP) to rearrange these components into evolving trees, in the attempt to maximize the data delivery probability. It is worth stressing that, in principle, this methodology can be easily generalized to other protocols, also at different layers of the protocol stack, and to different kinds of networks. To evaluate the proposed methodology, we perform a broad in silico experimentation where we improve Epidemic and PRoPHET on six test cases of urban networks made of three different kinds of mobile nodes (pedestrians, cars, and trams). Overall, we find that GI consistently produces a gain in data delivery probability. We then verify if this improvement in the delivery probability entails a worsening of other relevant network metrics, and find some counterintuitive results obtained as “byproducts” of GI: in fact, we find that the best evolved protocols not only increase the delivery probability, but also reduce the overall network overhead (i.e., the number of retransmissions). However, they trade these improvements for a higher latency. We also investigate the generaliz ability of the best evolved protocols across test cases, and find that apart from one specific map (Manhattan), the evolved protocols are able to generalize to unseen test cases, producing results that are still better than the baseline protocols. Finally, we compare the working logics of the best evolved protocols with those of the baseline protocols, and identify some common aspects which underlie their improved performance. Novel aspects of this work. Compared to the existing works on GP applied to protocol evolution, our work presents various elements of novelty which are worth highlighting. In particular, among the literature we will briefly survey in the next Section, the closer works on the application of GP to the evolution of protocols act either on the application layer, focusing in particular on aggregation protocols (i.e., protocols that calculate an aggregation function of distributed data, such as their mean) [Weise, Thomas and Geihs, Kurt and Baer, Philipp A 2007; Weise, Thomas and Tang, Ke 2011; Weise, Thomas and Zapf, Michael and Geihs, Kurt 2008], protocol adaptors, i.e., interfaces between incompatible application protocols [Van Belle, Werner and Mens, Tom and D’Hondt, Theo 2003], or application logics in Wireless Sensor Networks [Johnson, Derek M. and Teredesai, Ankur M. and Saltarelli, Robert T. 2005; Valencia, Philip and Lindsay, Peter and Jurdak, Raja 2010]; or, they use GP to optimize only a very specific equation used in existing protocols, such as the formula used to variate the contention window size in IEEE802.11 DCF [Lewis, Tim and Fanning, Neil and Clemo, Gary 2006], or the update rule of the routing table [Roohitavaf, Mohammad and Zhu, Ling and Kulkarni, Sandeep and Biswas, Subir 2018] (the latter work being based on rather simplified network simulations). Besides these works, three other papers have addressed, although with various limitations, very related research questions, namely [Alouf, Sara and Neglia, Giovanni and Carreras, Iacopo and Miorandi, Daniele and Fialho, Álvaro 2010; Yamamoto, Lidia and Tschudin, Christian 2005a,b]. Among these, the first two works apply GP to perform the online distributed adaptation of an extremely simplified delivery protocol (which allows only direct message exchanges, i.e., without routing): in this case GP automatically selects different combinations of modules in order to adapt the resulting protocol to the network conditions. This approach is quite different from the one we propose here, which instead is based on offline genetic improvement of realistic routing protocols for DTNs. The last one, on the other hand, does ACM Trans. Evol. Learn., Vol. 1, No. 1, Article xxx. Publication date: March 2021.xxx:4 Lorandi, et al. focus on the same protocols we study in this paper, i.e., Epidemic and PRoPHET, however it uses a GA to adjust the protocols’ parameters (such as the number of copies) in response to the network dynamics, in order optimize the overall delivery probability. Again, this approach is quite different from our proposal. Thus, to the best of our knowledge no prior work has used GP to genetically improve the inner logic of existing routing protocols, yet alone those used in DTNs. Structure of the paper. The remaining of this paper is organized as follows. In the next Section, we present the related work. Then, in Section 3 we introduce the method, in particular the GP configuration and the simulation setup. In Section 4, we describe the details of the experimentation, while the numerical results are discussed in Section 5. Finally, in Section 6 we draw the conclusions and hint at possible extensions of this work. 2 RELATED WORK","Routing in mobile ad hoc networks (MANETs) and other Internet of Things (IoT) instances is still a very active area of research. While well-established routing protocols exist for IP networks, routing in MANETs and other IoT instances, such as networks of cars, unmanned vehicles, or collectives of vehicles and humans, is still a very active area of research. In this paper, we propose a novel approach to improve the performance of routing protocols in MANETs, based on the results in the following:",cool!
290,LASeR: Lightweight Authentication and Secured Routing for NDN IoT in Smart Cities.txt,"Recent literature suggests that the Internet of Things (IoT) scales much
better in an Information-Centric Networking (ICN) model instead of the current
host-centric Internet Protocol (IP) model. In particular, the Named Data
Networking (NDN) project (one of the ICN architecture flavors) offers features
exploitable by IoT applications, such as stateful forwarding, in- network
caching, and built-in assurance of data provenance. Though NDN-based IoT
frameworks have been proposed, none have adequately and holistically addressed
concerns related to secure onboarding and routing. Additionally, emerging IoT
applications such as smart cities require high scalability and thus pose new
challenges to NDN routing. Therefore, in this work, we propose and evaluate a
novel, scalable framework for lightweight authentication and hierarchical
routing in the NDN IoT (ND- NoT). Our ns-3 based simulation analyses
demonstrate that our framework is scalable and efficient. It supports
deployment densities as high as 40,000 nodes/km2 with an average onboarding
convergence time of around 250 seconds and overhead of less than 20 KiB per
node. This demonstrates its efficacy for emerging large-scale IoT applications
such as smart cities.","The new emerging concept of smart cities applies concepts from the Internet of Things (IoT) to the management of diverse municipal infrastructure and assets [ 1]. Smart cities will involve large numbers of IoT devices installed in a range of settings from individual homes to critical infrastructure, potentially in a very dense deployment. As a result, their feasibility will require advances in efﬁciency and scalability of IoT communications. Additionally, smart cities will require strong guarantees of security: networked devices will handle large volumes of sensitive information and control valuable assets such as utility infrastructure, thus widening the attack surface for potential compromise. Thus, strong endtoend security and privacy mechanisms between smart devices and the cloud are imperative. Recent literature suggests that InformationCentric Network ing (ICN) is a more appropriate approach than Internet Protocol (IP) for IoT [ 2]. Named Data Networking (NDN) [ 3], in particular, is a strong architecture for creating scalable and efﬁcient smart city networks, by employing features such as stateful forwarding and innetwork caching. In addition, it offers security beneﬁts such as enforced provenance through mandatory networklayer signatures. This work is supported in part by the U.S. NSF grants:1345232 and 1248109 and the U.S. DoD/ARO grant: W911NF0720027. Paper currently in submission in IEEE IoT Journal .Several ICNbased IoT deployments have been announced in the literature, however no holistic NDN of Things (NDNoT) architecture and protocol suite has yet been proposed. In particular, existing literature tends to neglect concerns related to secure routing and onboarding, two of the most difﬁcult problems in IoT. Works that do address routing or onboarding do so separately, neglecting the fact that they are closely coupled. As a result, the proposed disjoint schemes are either incompatible or inefﬁcient when combined. Therefore, we propose in this paper a scalable and secure framework addressing both onboarding and routing in the NDNoT. The scalability of an IoT deployment is adversely affected by the low computational and memory capacities of IoT devices, as well as the characteristics of the low power lossy networks (LLNs) they use to communicate. Thus, we employ a hierarchical network structure, a design which has been recommended to achieve scalability in IoT [ 4]. Such an architecture allows us to ofﬂoad the burden of routing onto a few lessconstrained “anchor” nodes, while other devices need only form destinationoriented trees. In our framework, secure onboarding is made a prerequisite to routing, in order to help protect the network against routing attacks such as blackholes [ 5]. Each node in the network is authenticated prior to commencing routing, and in turn a node also authenticates the network it is joining. Since asymmetric cryptography is typically infeasible on IoT devices, we use symmetric cryptography. Our onboarding protocol is based on preshared keys between each node and a designated authentication manager in the infrastructure. We have combined our approaches to routing and onboarding into a single holistic framework for Lightweight Authentication & Secured Routing (LASeR). The combined authentication and onboarding processes are very lightweight, requiring only three round trips and few cryptographic operations. In summary, the contributions of our work are: (1) We analyze the current stateoftheart of routing and authentication in the NDNoT; (2) We propose LASeR, a holistic framework for efﬁcient and secure onboarding and routing in NDN; and (3) We demonstrate LASeR’s effectiveness and efﬁciency through analyses conducted in ndnSIM, the NDN module for ns3. The remainder of this paper is organized as follows: Sec tion II reviews prior work on NDN and IoT; Section III presents our model for the IoT network and reviews the primitives employed by NDN; Section IV describes the cryptographic materials and operations underlying LASeR’s authentication mechanism; Section V presents the protocols employed forarXiv:1703.08453v1  [cs.NI]  24 Mar 2017onboarding and routing; Section VI offers a simulationbased validation of LASeR’s effectiveness; and ﬁnally, Section VII concludes the paper and gives an overview of our planned future work. II. R ELATED WORK","Named Data Networking (NDN) is a strong architecture for creating scalable and efficient smart city networks. However, no holistic NDN of Things (NDNoT) architecture and protocol suite has yet been proposed. In particular, existing works tend to neglect concerns related to secure routing and onboarding, two of the most difficult problems in IoT. In this paper, we propose a holistic framework for Lightweight Authentication & Secured Routing (LASeR), a holistic framework for efficient and secure onboarding and routing in the NDNDN. We demonstrate LASeR'",cool!
324,B.A.T.Mobile: Leveraging Mobility Control Knowledge for Efficient Routing in Mobile Robotic Networks.txt,"Efficient routing is one of the key challenges of wireless networking for
unmanned autonomous vehicles (UAVs) due to dynamically changing channel and
network topology characteristics. Various well known mobile-ad-hoc routing
protocols, such as AODV, OLSR and B.A.T.M.A.N. have been proposed to allow for
proactive and reactive routing decisions. In this paper, we present a novel
approach which leverages application layer knowledge derived from mobility
control algorithms guiding the behavior of UAVs to fulfill a dedicated task.
Thereby a prediction of future trajectories of the UAVs can be integrated with
the routing protocol to avoid unexpected route breaks and packet loss. The
proposed extension of the B.A.T.M.A.N. routing protocol by a mobility
prediction component - called B.A.T.Mobile - has shown to be very effective to
realize this concept. The results of in-depth simulation studies show that the
proposed protocol reaches a distinct higher availability compared to the
established approaches and shows robust behavior even in challenging channel
conditions.","Mobile robotic networks are an important subset of mobile adhoc networks (MANETs) and form a class for a wide range of different network types. Applications range from dynamic trafﬁc management in the ﬁeld of vehicular adhoc networks (V ANETs) to maintaining robust swarm communication for Unmanned Aerial Vehicles (UA Vs) exploring hazardous areas. The provision of reliable endtoend communication in this kind of networks is a challenging topic due to the high relative mobility. Established routing protocols can barely cope with the frequently changing network and fail to adopt to the new channel and topology conditions. This issue is widely known and has been onesidedly addressed from two different perspectives: a mobilitycentric view and a routing centric view. In this paper, we combine these approaches to enhance the overall routing performance and the stabil ity of communication paths in low altitude UA V networks. Application layer mobility control data is used to predict future node positions. This information is then used to enable a forwardlooking routing approach to optimize the packet forwarding process. We analyze the system behaviour with multiple mobility algorithms (see Fig. 1), which are described in Section IVA. Our simulation setup has been published as an Open Source framework and is described in [1]. The remainder of this paper is structured as follows: after discussing therelated work, we present the system model of our solution approch, which contains the novel prediction method and our proposed routing protocol as subchapters. In the next section we describe the used mobility algorithms, the trafﬁc model and our simulation environment. Finally, detailed results of multiple simulation evaluations are presented, which compare our proposal to existing approaches. The results show the high efﬁciency of our proposed methods and prove their suitability for highly dynamic mobile robotic networks. II. R ELATED WORK","Mobile robotic networks are an important subset of mobile adhoc networks (MANETs) and form a class for a wide range of different network types. The provision of reliable end-to-end communication in this kind of networks is a challenging topic due to the high relative mobility. Existing routing protocols can barely cope with the frequently changing network and fail to adopt to the new channel and topology conditions. In this paper, we combine two different perspectives: a mobilitycentric view and a routing centric view to enhance the overall routing performance and the stability of communication paths. We present the results of",cool!
47,An Ultimate Approach of Mitigating Attacks in RPL Based Low Power Lossy Networks.txt,"The Routing Protocol for Low-Power and Lossy Networks (RPL) is the existing
routing protocol for Internet of Things (IoT). RPL is a proactive,lightweight,
Distance Vector protocol which offers security against various forms of routing
attacks. Still, there are various attacks(as rank, version attacks and many
more ) which is possible in this network due to problem of unauthenticated or
unencrypted control frames, centralized root controller, compromised or
unauthenticated devices and many more ways. There are various solutions present
in the literature but every solution has its pros and cons. There is no
appropriate system framework till now which completely solves these all issues.
So, we present an ultimate approach to mitigate these RPL attacks more
efficiently and effectively. We use IDS based system for internal attacks and a
mini-firewall for removing the external attacks. In IDS based approach, we use
intrusion detection system at multiple locations for analyzing the behaviour of
nodes. The final decision whether the node is attacker or not depends on mainly
three things as: trust between the neighbouring nodes, local decision by
multiple sink nodes and global decision by root node. We also use some
blockchain features in this framework for better internal security. We use some
threshold values and rules in mini-firewall for removing external attacks. In
this paper, we provide the proposed approach and theoretical analysis of this
approach which provide better protection from these attacks than any other
method.","In todays world, IoT is technical revolutionary area in mobile and wireless communication ﬁeld which deploy Low power and Lossy Networks (LLN). These networks are typ ically composed of many heterogeneous embedded devices with limited power, memory, and processing resources. Now, IoT is applicable in many areas such as industrial monitoring, smart home, health care, environmental monitoring, smart city, smart grid and many more. Due to the huge number of applications of these networks, security become a critical part for privacy of personal data. RPL is default routing protocol in these network which is susceptible from various attacks. Now, We brieﬂy describe the related technologies use in this paper. A. Routing Protocol as RPL and it’s Attacks RPL is distance based proactive protocol used for routing in IoT network. At beginning, a RPL protocol creates a graph like structure called the Destination Oriented Directed AcyclicGraph (DODAG). The DODAG consists of paths from the sender nodes(IoT devices) to the sink node(6LBR). During routing, every node maintains its rank relative to its position in the DODAG tree, and every DODAG is maintained by control and route information . The control frames are used by DODAG are DODAG Information Object (DIO),Destination Advertisement Object (DAO) and DODAG Information Solic itation (DIS) for transmitting the DODAG information. Route path selection is a key factor for RPL, RPL use the Various routing metrics, route constraints and objective functions (OF) such as hop count, energy minimization and latency to com pute the best route path. The basic framework of RPL network is shown below. Fig. 1. RPL Based Low Power Lossy Network There are various attacks possible in RPL network which signiﬁcantly impact the network resources and its perfor mance. These attacks are possible due to the problem of unauthenticated or unencrypted control frames, centralizedarXiv:1910.13435v2  [cs.CR]  27 Dec 2019root controller, compromised and unauthenticated devices and many more ways. Some of these attacks are shown in ﬁgure 2 and brieﬂy describe below. Fig. 2. RPL Network Attacks 1) Sinkhole Attack: In this internal attack, attacker or compromised node advertises beneﬁcial path to attract many nearby nodes to route trafﬁc through it. This attack disrupt the network topology and can become very stronger when combined with another attacks[2]. 2) Version Number Modiﬁcation Attack: This internal attack is occurred by changing version number(lower to higher) of a DODAG tree. When nodes receive the new higher version number DIO message they start the formation of new DODAG tree. This results unoptimized or inconsistency of network topology, increases control overhead and higher packet loss[2]. 3) Denial of Service Attack: Denial of service or Distributed denial of service attack is attempt to make resources unavailable to its valuable user [1213]. In RPL this attack can be done by the IPv6 UDP packet ﬂooding[2]. 4) Neighbor Attack: In this attack, intruder broadcast DIO messages that it received without adding information of himself.The node who receives this messages may conclude that new neighbor node send this DIO message. The victim nodes select the out range neighbors node for routing purpose which affects network quality parameters[2].5) Wormhole Attack: This attack can occurred by creating tunnel between the two attackers and transmitting the selective trafﬁc through it which Disrupt the network topology and trafﬁc ﬂow[2]. 6) Decreased Rank Attacks: In a DODAG, rank is used for positions of nodes relative to the sink node. It means lower the rank is close to the root and vice verse. When a malicious node advertises a lower rank value, it means, it wants majority of trafﬁc pass through it. As a result, many legitimate nodes connect to the attacker. An attacker can change its rank value through the falsiﬁcation of DIO messages. ﬁnally, an attacker either drop this messages or selectively forward these messages. It becomes more powerful when combined with other attacks[2]. 7) Identity Attacks: Identity attacks contain clone ID and sybil attacks. In a clone ID attack, an attacker copies the identities of a valid node onto another physical node. In a sybil attack, which is similar to a clone ID attack, an attacker uses several logical entities on the same physical node. These attacks can be used to take control over large parts of a network without deploying physical nodes[2,1213]. 8) Snifﬁng Attacks: A snifﬁng attack perform by the listening of the packets transmitted over the network. This attack compromises the conﬁdentiality of communications. It also check the pattern of trafﬁc for major attacks[1213]. B. Blockchain Blockchain is fundamentally a decentralized, distributed, shared, and immutable database ledger that stores data across a peertopeer (P2P) network. It has chained blocks of data that have been timestamped and validated by miners. Funda mentally, the block data contains a list of all transactions and a hash to the previous block. The blockchain has a full history of all transactions and provides a global distributed trust[1]. C. Intrusion Detection System(IDS) An intrusion detection system (IDS) is a system that mon itors network trafﬁc for suspicious activity and issues alerts when such activity is occurred. These can be signature based or anomaly based and network or host based depending upon the need of application. These mainly used for the detection of internal attacks. D. Firewall Firewall is used for protection from outsider attacks. This use some threshold values or speciﬁc rules to ﬁlter unwanted trafﬁc such as ﬁltering is based on port numbers, ip addresses and many more parameters. E. Trust Trust means integrity, strength, ability, conﬁdence of one person on the other person or thing. A trust is a relationship or agreement which one party, known as a trustor, givesanother party, the trustee. The rest of the paper is organized as follows: section 2 describes the Related Work and motivation for our work. Section 3 mentions our proposed framework system followed by the theoretical analysis of work in section 4. In Section 5, a conclusion of our ﬁndings is presented with future extensions to our work. II. R ELATED WORK & M OTIVATION","Routing Protocol as RPL is a routing protocol used in Low Power Lossy Networks (LLN). RPL is a distance based proactive protocol used for routing in these networks. In this paper, we propose a new routing protocol called Route Path Locator (RPL) which is a distance based proactive protocol used for routing in LLN. RPL is a distance based proactive protocol which is susceptible from various attacks. In this paper, we propose a new routing protocol called Route Path Locator (RPLBR) based on the a distance based on the",cool!
214,Modeling and Simulating Network Connectivity in Routing Protocols for MANETs and VANETs.txt,"This paper presents a framework for node distribution with respect to
density, network connectivity and communication time. Using NS2, we evaluate
and compare performance of three routing protocols; Ad-hoc On-demand Distance
Vector (AODV), Dynamic Source Routing (DSR) and Fisheye State Routing (FSR)
both in MANETs (IEEE 802.11) and VANETs (IEEE 802.11p). We further enhanced
these protocols by changing their routing information exchange intervals; MOD
AODV, MOD DSR and MOD FSR. A comprehensive simulation work is performed for the
comparison of these routing protocols for varying motilities and scalabilities
of nodes. As a result, we can say that AODV outperforms DSR and FSR both in
MANETs and VANETs.","Mobile Ad hoc Network (MANETs) are self configuring network of mobile nodes connected  by wireless links. Vehicular Ad hoc Networks (VANETs) belong to special class of MANETs. They  are distributed and self assembling communication networks that are made up of multiple autonomous  moving vehicles and peculiarize by very high node mobility.   Routing protocols are designed to calculate paths for communication networks. In table  driven, proactive protocols are based upon periodic exchange of contr ol messages and maintains  routing tables. However, the reactive protocol tries to discover a route only when demand arrives. Our simulation work based upon three protocols comparison in MANETs and in VANETs named as  AODV [1], DSR [2] and FSR [3]. Moreover,  we introduce some modifications in their routing  exchange intervals; 1) in MOD AODV, augments AODV’s Expanding Ring Search algorithm (ERS)  limits, 2) in MOD DSR, time associated with storage of routes in Route Cache is modified and 3)  Scope intervals in F SR are adjusted in MOD FSR.     II.   Related Work and Motivation","We propose a routing protocol for Vehicular Ad hoc Networks (VANETs) based on a table driven proactive protocol, a proactive protocol and a reactive protocol. We compare three routing protocols named as AODV, DSR and FSR in MANETs and VANETs. We introduce some modifications in their routing exchange intervals; 1) in MOD AODV, augments AODV’s Expanding Ring Search algorithm (ERS) limits, 2) in MOD DSR, time associated with storage of routes in Route Cache is modified and 3) in",cool!
378,A Delay Aware Routing Protocol for Wireless Sensor Networks.txt,"Wireless Sensor Networks (WSNs) consist of sensor nodes which can be deployed
for various operations such as agriculture and environmental sensing, wild life
monitoring, health care, military surveillance, industrial control, home
automation, security etc. Quality of Service (QoS) is an important issue in
wireless sensor networks (WSNs) and providing QoS support in WSNs is an
emerging area of research. Due to resource constraints nature of sensor
networks like processing power, memory, bandwidth, energy etc. providing QoS
support in WSNs is a challenging task. Delay is an important QoS parameter for
forwarding data in a time constraint WSNs environment. In this paper we propose
a delay aware routing protocol for transmission of time critical event
information to the Sink of WSNs. The performance of the proposed protocol is
evaluated by NS2 simulations under different scenarios.","Fig1. A simplified model for Wireless Sensor Networks  Provisioning of Quality of Service (QoS)   is a challenging   problem in WSNs. A simplified model for QoS in WSNs is shown in Fig2 which is redrawn from [3]. In WSNs, delivery of certain time critical events  to the Sink or Base Station   within a specific  deadline is an important aspect of  QoS for the success of  certain delay aware  applications such as military surveillance, industrial monitoring, healthcare, disaster management etc. End to End Delay is considered to be one of the important parameter like the other QoS parameters such as  reliability, energy, data accuracy, coverage  etc. in Wireless Sensor Networks.  In this paper we propose a delay aware routing protocol for wireless sensor networks. The proposed protocol is a routing solution for the transmission of time critical event information to the Base Station within a deadline. It also ensures reliability by following multipath routing  so that at least one copy of the event information   is received by the Sink or Base Stations. We will use the term Sink or Base Stations interchangeably in this literature. The proposed protocol is designed for the application of typical WSNs where certain time critical events required to be detected and to be informed to the Sink within a certain delay limit with reliability.               Fig2. A simplified model for QoS in Wireless Sensor Networks  The remainder of this paper is organized as follows. In section 2, we present a review of the related work. In section 3, we have presented   the detail working principle of the proposed protocol. In section 4, we have discussed the performance of the proposed protocol and finally in section 5 conclusions have been presented.  2. Related Works  QoS provision in wireless sensor  networks is an emerging field of research and various literatures are available on this field. In this section we are briefly reviewing some of the QoS aware routing protocols for wireless sensor networks. Our survey mainly deals with delay and energy aware reliable  routing protocols in wireless sensor networks.  T.He et. al proposed stateless realtime communication protocol called SPEED [7]  in WSNs. It meets the end to end delay by   enforcing    uniform communication speed in every hop in the network through  feedback control mechanism and nondeterministic QoS aware geographicforwarding.   E.Felemban et al. proposed MMSPEED [9] which was designed as an extension of the SPEED to support multiple communication speeds over multi path and provides differentiated reliability.",In this paper we propose a delay aware routing protocol for wireless sensor networks. The proposed protocol is a routing solution for the transmission of time critical event information to the Sink or Base Station within a deadline. It also ensures reliability by following multipath routing so that at least one copy of the event information is received by the Sink or Base Stations. The proposed protocol is designed for the application of typical WSNs where certain time critical events required to be detected and to be informed to the Sink within a certain delay limit with reliability. The proposed protocol is designed for the application of,cool!
338,Circuit Routing Using Monte Carlo Tree Search and Deep Neural Networks.txt,"Circuit routing is a fundamental problem in designing electronic systems such
as integrated circuits (ICs) and printed circuit boards (PCBs) which form the
hardware of electronics and computers. Like finding paths between pairs of
locations, circuit routing generates traces of wires to connect contacts or
leads of circuit components. It is challenging because finding paths between
dense and massive electronic components involves a very large search space.
Existing solutions are either manually designed with domain knowledge or
tailored to specific design rules, hence, difficult to adapt to new problems or
design needs. Therefore, a general routing approach is highly desired. In this
paper, we model the circuit routing as a sequential decision-making problem,
and solve it by Monte Carlo tree search (MCTS) with deep neural network (DNN)
guided rollout. It could be easily extended to routing cases with more routing
constraints and optimization goals. Experiments on randomly generated
single-layer circuits show the potential to route complex circuits. The
proposed approach can solve the problems that benchmark methods such as
sequential A* method and Lee's algorithm cannot solve, and can also outperform
the vanilla MCTS approach.","Electrical and electronic devices in our lives, such as comput ers or phones, consist of many integrated circuits (ICs, also known as chips) and printed circuit boards (PCBs). An IC or a PCB contains many physical wires that connect the compo nents in or on it. A correct layout of such wires is important to the functionality and performance of the circuit. The prob lem of routing in circuit design is hence to ﬁnd the proper paths to place those wires to achieve expected connectivity with certain constraints, one of which is that wires carrying different signals should not intersect. Many Electronics De sign Automation (EDA) software tools have been developed for this purpose. Circuit routing is computationally expensive and challeng ing. A PCB, such as the motherboard of a smartphone, can easily contain thousands of pins (a pinis a contact, or metal lead, of an electronic component) and over ten layers, mak ing manual design extremely timeconsuming [Hui Kong et Figure 1: A PCB under routing in KiCAD. Red thin lines indicate nets to be connected and yellow pads are pins of nets. Green traces are ﬁnished paths connecting nets. Plus signs are grid intersections. al., 2009; Coombs and Holden, 2001 ]. A 2012 chip could contain “about 100 kilometers of copper wiring” inside of it1. On top of the problem size, circuit routing is NPhard. Complex routing problems are usually solved in two stages: ﬁrst global routing and then detailed routing [Alpert et al., 2008; Chen and Chang, 2009; Kahng et al. , 2011 ]. Global routing routes on large circuit blocks, called Gcells, with relaxations on many constraints, while detailed routing gen erates wires of proper shapes and positions based on results from global routing. However, the two stages do not always couple well. For example, it is difﬁcult for the wire density in global routing result to match the routability of the down stream detailed router [Zhang and Chu, 2012 ]. As a result, a lowcongestion global routing result may lead to subsequent detail routing difﬁcult. The miscoupling of the two stages be comes more profound as design rules evolve rapidly [Shi and Davoodi, 2017 ]. The distinction between the two stages also results in complex EDA software that is difﬁcult to maintain and evolve coherently. In addition, routing algorithms are dominantly manually crafted based on domain knowledge. Developing new algo rithms is laborious. Manual updates are always needed when new design constraints and goals arise. Many of these algo rithms are based on heuristics which cannot guarantee solu tions. For example, the order of nets typically affects the rout ing results [Alpert et al. , 2008 ]and some routable problems 1https://www.technologyreview.com/s/428466/ makingwiringthatdoesnttripupcomputerchips/arXiv:2006.13607v1  [cs.AI]  24 Jun 2020may become insolvable in certain heuristics [Zhang, 2016 ]. Therefore, an endtoend and general routing approach that does not depend on domain knowledge is highly de sired. In this paper, we view circuit routing as a sequen tial decision process that adds a vertex (or edge) onto a grid graph in each step, just like placing a stone in the game Go, which is suitable to be solved by Monte Carlo tree search (MCTS) [Browne et al. , 2012 ]. To better guide the search process, we use a deep neural network (DNN) that embeds the routing state. Unlike previous approaches, our MCTSbased approach does not require domain knowledge nor specialized heuristics, and constraints and goals can be altered by revis ing the reward function without changing the algorithm itself. Hence, it has lower implementation and maintenance costs, and the computer can improve its skills as it routes more and more circuits. However, it is not trivial to apply the vanilla MCTS al gorithm for circuit routing. On one hand, the average reward based upper conﬁdence bound for trees (UCT) [Co quelin and Munos, 2007 ]in vanilla MCTS does not cor respond to the optimal paths in the routing problem. On the other hand, the search space of routing is too large for random search. Hence, we propose a search algorithm that combines Monte Carlo simulation with policy networks. First, a maximum rewardbased UCT [Jacobsen et al. , 2014; Keller and Helmert, 2013 ]is used to represent the best search result for an optimal path. Second, to reduce the search space, we combine the depth ﬁrst search (DFS) and a trained neural network as the rollout policy of the MCTS algorithm. 2 Related Work","Circuit routing is a challenging and computationally expensive problem. It is usually solved in two stages: first global routing and then detailed routing. However, the two stages do not always couple well. For example, it is difficult for the wire density in global routing result to match the routability of the down stream detailed router. Hence, a low-congestion global routing result may lead to subsequent detail routing difficult. In this paper, we propose a new end-to-end routing approach that does not require domain knowledge nor specialized heuristics. We use a deep neural network (D",cool!
419,Jointly Optimal Routing and Caching for Arbitrary Network Topologies.txt,"We study a problem of fundamental importance to ICNs, namely, minimizing
routing costs by jointly optimizing caching and routing decisions over an
arbitrary network topology. We consider both source routing and hop-by-hop
routing settings. The respective offline problems are NP-hard. Nevertheless, we
show that there exist polynomial time approximation algorithms producing
solutions within a constant approximation from the optimal. We also produce
distributed, adaptive algorithms with the same approximation guarantees. We
simulate our adaptive algorithms over a broad array of different topologies.
Our algorithms reduce routing costs by several orders of magnitude compared to
prior art, including algorithms optimizing caching under fixed routing.","Optimally placing resources in a network and routing requests toward them is a problem as old as the Internet itself. It is of paramount importance in information centric networks (ICNs) [31, 57], but also naturally arises in a variety of networking applications such as webcache design [14, 36, 58], wireless/femtocell networks [42, 45, 51], and peertopeer networks [16, 39], to name a few. Motivated by this problem, we study a caching network , i.e., a network of nodes augmented with additional storage capabilities. In such a network, some nodes act as designated content servers, permanently storing content and serving as \caches of last resort"". Other nodes generate requests for content that are forwarded towards these designated servers. If, however, an intermediate node in the path towards a server stores the requested content, the request is satised early: i.e., the request ceases to be forwarded, and a content copy is sent over the reverse path towards the request's source. This abstract setting naturally captures ICNs. Designated servers correspond to tra ditional web servers permanently storing content, while nodes generating requests cor respond to customerfacing gateways. Intermediate, cacheenabled nodes correspond to storageaugmented routers in the Internet's backbone: such routers forward requests but, departing from traditional networklayer protocols, immediately serve requests for content they store. An extensive body of research, both theoretical [9, 14, 24, 25, 30, 40, 47, 48] and experimental [14, 31, 36, 39, 49, 58], has focused on modeling and analyzing net works of caches in which routing is xed , and requests follow predetermined paths. For example, shortest paths to the nearest designated server are often used. Given routes to be followed, and the demand for items, the above works aim to model and analyze (theoretically or empirically) the behavior of dierent caching algorithms deployed over intermediate nodes. It is not a priori clear whether xed routing and, more specically, routing towards the nearest server is the appropriate design choice for such networks. This is of special interest in the context of ICNs, where delegating routing decisions to another protocol amounts to an \incremental"" deployment. For example, in such a deployment, requests can be forwarded towards the closest designated web servers over paths determined according to, 1arXiv:1708.05999v1  [cs.NI]  20 Aug 2017e.g., existing routing protocols such as OSPF or BGP [35]. Subsequent caching decisions by intermediate routers aect only where{within a given path{requests are satised. An alternative is to jointly optimize both routing andcaching decisions simultaneously. Do ing so however poses a signicant challenge, precisely because this joint optimization is inherently combinatorial. Indeed, jointly optimizing routing and caching decisions with the objective of, e.g., minimizing routing costs, is an NPhard problem, and constructing a distributed approximation algorithm is far from trivial [11, 23, 30, 51]. This state of aairs gives rise to the following questions. First, is it possible to design distributed, adaptive, and tractable algorithms jointly optimizing both routing and caching decisions over arbitrary cache network topologies, with provable performance guarantees ? Identifying such algorithms is important precisely due to the combinatorial nature of the problem at hand. Second, presuming such algorithms exist, do they yield signi cant performance improvements over xed routing protocols ? Answering this question in the armative may justify the potential increase in protocol complexity due joint opti mization. It can also inform future ICN design, indicating whether full optimization is preferable, or whether an incremental approach in which routing and caching are separate suces. Our goal is to provide rigorous, comprehensive answers to these two questions. We make the following contributions: We show, by constructing a counterexample, that xed routing (and, in particular, routing towards the nearest server) can be arbitrarily suboptimal compared to jointly optimizing caching and routing decisions. Intuitively, joint optimization aects rout ing costs drastically because exploiting path diversity increases caching opportunities . We propose a formal mathematical framework for joint routing and caching opti mization. We consider both source routing and hopbyhop routing strategies, the two predominant classes of routing protocols over the Internet [35]. We study the oine version of the joint routing and caching optimization problem, which is NPhard, and construct a polynomialtime 1","We study a caching network, i.e., a network of nodes augmented with additional storage capabilities. In such a network, some nodes act as designated content servers, permanently storing content and serving as caches of last resort'. Other nodes generate requests for content that are forwarded towards these designated servers. If, however, an intermediate node in the path towards a server stores the requested content, the request is satis ed early: i.e., the request is forwarded towards the nearest designated server. It is not a",cool!
261,Tempest: Temporal Dynamics in Anonymity Systems.txt,"Many recent proposals for anonymous communication omit from their security
analyses a consideration of the effects of time on important system components.
In practice, many components of anonymity systems, such as the client location
and network structure, exhibit changes and patterns over time. In this paper,
we focus on the effect of such temporal dynamics on the security of anonymity
networks. We present Tempest, a suite of novel attacks based on (1) client
mobility, (2) usage patterns, and (3) changes in the underlying network
routing. Using experimental analysis on real-world datasets, we demonstrate
that these temporal attacks degrade user privacy across a wide range of
anonymity networks, including deployed systems such as Tor; path-selection
protocols for Tor such as DeNASA, TAPS, and Counter-RAPTOR; and network-layer
anonymity protocols for Internet routing such as Dovetail and HORNET. The
degradation is in some cases surprisingly severe. For example, a single host
failure or network route change could quickly and with high certainty identify
the client's ISP to a malicious host or ISP. The adversary behind each attack
is relatively weak - generally passive and in control of one network location
or a small number of hosts. Our findings suggest that designers of anonymity
systems should rigorously consider the impact of temporal dynamics when
analyzing anonymity.","Anonymous communication is a key privacyenhancing technology that aims to protect user identity in online communications [5, 8, 19, 26, 29]. The most widelyused anonymity protocol today is onion routing [26], which in the form of the Tor network [19] is estimated to have over 2 million users a day. The Tor network comprises over 7,000volunteer proxies, carries 100 Gbps of traf ﬁc, and is widely used by citizens, journalists, whistle blowers, businesses, governments, lawenforcement, and intelligence agencies [61, 63]. An important thread of research has proposed new anonymity systems that im *Corresponding Author: Ryan Wails: U.S. Naval Re search Laboratory, Email: ryan.wails@nrl.navy.mail Yixin Sun, Mung Chiang, Prateek Mittal: Princeton University, Email: {yixins, chiangm, pmittal}@princeton.edu Aaron Johnson: U.S. Naval Research Laboratory, Email: aaron.m.johnson@nrl.navy.mailprove on Tor in the context of networklevel adversaries, such as Autonomous Systems (ASes) that have vast vis ibility into Internet traﬃc. Systems such as DeNASA, Astoria, TAPS, and CounterRAPTOR have modiﬁed pathselection algorithms for onion routing to mitigate the threat of ASlevel adversaries [4, 36, 50, 58]. Sys tems such as LAP, Dovetail, PHI, and HORNET have moved cryptographic functionality for anonymous com munication from end hosts into the Internet routing in frastructure to improve performance [11, 12, 31, 56]. However, for simplicity of security analysis, design ers of these systems abstract away important compo nents of the system, which could impact user anonymity in practice. In particular, one simpliﬁcation commonly used in the analysis of anonymity protocols is to limit the eﬀects of time on the operation of the protocol [1, 4, 31, 50, 56]. For example, security analyses typically assume that each user communicates with a ﬁxed desti nation once, that the set of participants in the protocol is static, or that the network structure is static. The question then arises: what are the eﬀects of the tempo ral dimension of system operations on user anonymity? Contributions. In this paper, we present Tem pest: a set of attacks that demonstrates the impact of temporal dynamics on the security of several promi nent anonymity protocols. We target Tor and some of the latest proposals for improving its security against ASlevel adversaries (namely, DeNASA [4], TAPS [36], and CounterRAPTOR [58]), as Tor has proven to be the most popular protocol for the current Internet. We also target proposals for networklayer anonymity that represent the main ideas for providing anonymity against ASlevel adversaries in a nextgeneration Inter net (namely, Dovetail [56] and HORNET [11]). We consider the vulnerability of such protocols to deanonymization due to the eﬀects on anonymous communication paths of three main types of temporal dynamics: (1) client mobility, (2) user behavior over multiple connections, and (3) network routing dynam ics. We consider especially a patientadversary that is interested in performing longterm attacks on anony mous communication. Such an adversary is a real con cern of today’s Tor users [33, 38], for example those avoiding mass surveillance. We propose and, using real world datasets, evaluate attacks that allow an adversary to exploit longterm observations about anonymity path changesfor deanonymizing user identities. arXiv:1801.01932v2  [cs.CR]  29 Mar 2018Tempest: Temporal Dynamics in Anonymity Systems 2 Table 1. This paper identiﬁes and analyzes temporal dynamics (Tempest attacks) that degrade user privacy in anonymity systems, including Tor, proposals for improving path selection in Tor (top half), and networklayer anonymity protocols (bottom half). Exploiting Client Mobility Exploiting User Behavior Exploiting Routing Changes Vanilla Tor [19] Novel (§5.2) Known [7, 30, 34, 38] Known [59] DeNASA [4] Novel (§A.1) Novel (§6.1) CounterRAPTOR [58] Novel (§5.3) Novel (Resistance, §B.1) Known (Resistance) [58] TAPS [36] Known (Resistance) [36] Novel (§7.1) Astoria [50] Known [36] HORNET [11] Novel (§5.4) Novel (§7.2) Dovetail [56] Novel (§6.2) PHI [12] Novel (§B.2) LAP [31] Novel (implied by §5.4) Novel (implied by §7.2) We ﬁnd that Tempest attacks have signiﬁcant im pact on the anonymity of these systems. One impact thatweshowisthat,inTorbasedsystems,pathchanges due to client mobility allow an increasing number of ASlevel adversaries to observe client traﬃc, compro mising client identity with a degree much greater than previouslythoughtpossible.Innetworklevelanonymity systems, adversaries can also correlate partial informa tion about anonymity paths with auxiliary information about client movements to deanonymize client identity. Our work presents the ﬁrst analysis of the impact of path changes due to client mobility. Another impact that we show is that path changes due to user behavior, such asmultiple connections to the same destination at diﬀerent times, and path changes due to network rout ing updates allow an adversary to combine probabilistic information leaks inherent in pathselection algorithms to deanonymize clients’ ASes over time. Note that in ferring the AS of a client represents a signiﬁcant re duction in client anonymity (the typical anonymity set comprises over 50,000 ASes without our attacks). Our work is the ﬁrst demonstration of how probabilistic in formation leaks due to the restricted ASlevel Internet topology can be aggregated over time. Our results present a new evaluation paradigm for important classes of anonymouscommunication proto cols. They suggest that designers of anonymity systems should thoroughly consider the impact of temporal dy namics when analyzing system security. Our work fur ther motivates the design of anonymous communication protocols that are resilient when used over time and un der changing circumstances. 2 Overview of Tempest Attacks In this section, we provide an overview of Tempest at tacks and summarize our key ﬁndings. Exploiting Client Mobility. We demonstrate how an adversary can exploit information leakage via naturallyoccurring realworld movements of clients.Client mobility results in connections to anonymity net works appearing from diﬀerent network locations over time; we ﬁnd that this enhances an adversary’s abil ity to perform traﬃcanalysis attacks and deanonymize client communications. We experimentally quantify the degradation in anonymity for Vanilla Tor ( i.e.plain Tor as it exists today), CounterRAPTOR [58], and HORNET [11] using realworld location datasets to model client mobility. Across all studied systems, we ﬁnd that considering the eﬀects of client mobility re sults in an orderofmagnitude degradation in client anonymity: (1) for Vanilla Tor, client mobility in creases the exposure of the clientTor communications to ASlevel adversaries, due to heterogeneous network paths originating from varying client locations; (2) for CounterRAPTOR, client mobility increases an adver sary’s ability to actively manipulate BGP routing and hijack/intercept client traﬃc to the anonymity network, due to a fundamental mismatch in assumptions between its locationaware path selection and the dynamics of client mobility; and (3) for HORNET, client mobil ity results in changes in the network paths between a client and its destination over time, which can be corre lated with external (nonanonymous) location datasets to deanonymize the anonymitynetwork connections. Exploiting User Behavior. We consider users that regularly connect to a destination and demon strate how an adversary can take advantage of that to deanonymize users in several prominent anonymity pro posals. Multiple user connections allow an adversary to aggregate probabilistic information leakage from con nections over time and eventually deanonymize the user by identifying his AS. We experimentally quantify this degradation in anonymity over multiple connections for DeNASA [4], a locationaware path selection algorithm for Tor that avoids suspect ASes, and Dovetail [56], a networklevel anonymity protocol that uses a level of indirection within Internet communications to provide anonymity. We ﬁnd that multiple connections have devTempest: Temporal Dynamics in Anonymity Systems 3 astating consequences on user anonymity in DeNASA and Dovetail. The path selection algorithms in both De NASA(focusingontheﬁrsthop/guardrelay)andDove tail leak partial information about the client’s network location, leading to a continual reduction in anonymity as the client makes connections. The speed of this re duction is surprisingly fast for some unfortunate clients. Exploiting Routing Changes. We show how an adversary can exploit naturallyoccurring routing changes to compromise client anonymity. Similar to the impact of client mobility, routing changes leak addi tional information to an adversary as they occur, which can be aggregated over time to make accurate infer ences about client location. We experimentally quantify the degradation in anonymity due to routing changes for TAPS [36], a trustaware path selection algorithm for Tor, and HORNET [11]. For both TAPS and HOR NET, routing changes lead to varying anonymity sets for clients over time, allowing an adversary to intersect the anonymity sets at diﬀerent points in time and infer client network locations (client ASes). Impact. The impact of the Tempest attacks is summarized in Table 1. For each of the three tempo ral dynamics considered, we demonstrate attacks that weaken security in at least one onionrouting proto col and one networklayer anonymity protocol. We note that our results on exploiting client mobility repre sent the ﬁrst analysis of this issue, to the best of our knowledge, and we demonstrate its negative impact on a range of systems. We also note that our results on exploiting user behavior and routing changes include several novel attacks across recentlyproposed onion routing and networklayer anonymity protocols, sug gesting a signiﬁcant reevaluation of their eﬀectiveness. In particular, our work is the ﬁrst to consider the ag gregation of probabilistic information leaks due to the restricted ASlevel Internet topology over time. To highlight the broad impact of Tempest, Table 1 includes novel attacks that appear in the Appendix, in cluding exploiting client mobility in DeNASA, exploit ing user behavior in CounterRAPTOR, and exploiting user behavior in PHI (note that the results in the main body of the paper are selfcontained). Table 1 also in cludes entries for protocols not studied directly in this work.Itplacesintocontextanattack[36]onAstoria[50] that is similar to our attacks exploiting userbehavior dynamics. It also indicates that some of our attacks should also be eﬀective against LAP [31], as LAP re veals strictly more to the adversary about the source and destination of a connection than HORNET does.Due to the variety of systems considered, the Tem pest attacks vary in the kind of anonymity degradation they achieve and in the adversary capabilities that they require. In several cases we attack anonymity using the same notions and metrics used to argue for the system’s eﬀectiveness by its designers. In every case, the adver saries we consider fall within the threat model stated for the system under analysis. In addition, the adversaries we consider are generally passive and need to control only one or a small number of network entities ( e.g.an AS, a website, or a Tor relay). To summarize our con tributions, we identify the eﬀects of temporal dynamics on paths in anonymity systems as a general concern aﬀecting the anonymity of those systems. We present the Tempest attacks and show that they can reduce the anonymity of Tor, suggested Tor improvements, and networklayer anonymity protocols. 3 Background In this section, we present the required background on Internet routing and anonymity protocols. Network Routing. Routing in the Internet is set up among routers via the Border Gateway Proto col (BGP). BGP produces routing paths between the autonomous subnetworks that comprise the Internet, calledAutonomous Systems (ASes). There are roughly 58,000ASesadvertisingroutesontheInternet[14].Each AS is connected to at least one other AS, and the con nected ASes exchange traﬃc with each other in a va riety of bilateral relationships that specify when traﬃc should be sent and how it is paid for. In BGP, routing operates on variablelength IP preﬁxes , which are each a sequence of bits that is compared to beginning of the destination IP address to route a packet. Onion Routing. Onion routing [26] achieves anonymous communication online by encrypting the network traﬃc and sending it through a sequence of relaysbefore going to the destination. The relays run at the application layer on the hosts, and traﬃc between each pair of hosts is routed using existing Internet rout ing protocols. To communicate, the client selects a se quence of relays, constructs a persistent circuitthrough them, and uses it to establish a connection to the des tination. The circuit is constructed iteratively and is encrypted once for every relay, which prevents each re lay from learning more than the previous and next hops, and in particular it prevents any one relay or local net work observer from identifying both the source and des tination. Servers can remain anonymous by running as hidden services , which maintain persistent circuits intoTempest: Temporal Dynamics in Anonymity Systems 4 the anonymity network through which they can be con tacted. Onion routing is wellknown to be vulnerable to atraﬃc correlation attack [60], however, in which an adversary that observes both the client and the desti nation can deanonymize the connection by correlating the traﬃc leaving the client with that entering the des tination. Tor [19] is the most popular system implementing onion routing. The Tor network currently consists of over 7,000relays cumulatively forwarding 100 Gbps of traﬃc[61].WewillapplyTempestattackstoToraswell as to several recent proposals to improve Tor’s security by changing the way that it selects paths: DeNASA [4], TAPS [36], and CounterRAPTOR [58]. These attacks are likely to also be eﬀective for other similar propos als [1, 3, 20, 37, 39, 50]. NetworkLayer Anonymity Protocols. Onion routing protocols are run at the application layer, which allowsthemtobedeployedwithoutchangestotheexist ing Internet. However, several protocols [11, 12, 31, 56] proposeoperatingatthenetworklayerforeﬃciencyand ubiquity. These protocols change the way that routers set up and route packets and thus require changes in some of the core infrastructure of the Internet. Several of them make use of some other nextgeneration rout ing algorithm ( e.g.pathlets [25]) to propagate routing information and select routing paths. These protocols have many similarities with onion routing, and it is also useful to view them through the temporal lens. We fo cus on two of these protocols, HORNET [11] and Dove tail [56], because they represent two distinct approaches that have been suggested. As indicated in Table 1, our results also imply vulnerability in the other network layer anonymity protocols. 4 Models and Metrics The Tempest attacks each exploit some temporal dy namic, but they diﬀer in where and how it is exploited. An overview of the attack methods appears in Table 2. Adversary Models. Motivated by mass surveillance concerns, we consider the context of a patient adversary that is interested in performing long term deanonymization attacks. We consider several diﬀerent adversaries, depending on the system and the way a temporal dynamic enables an attack. In each case we identify a fairly weak adversary within the attacked system’s threat model , with results in the following threat models: a single AS, at least one Tor relay, and the destination site. Our adversaries are generally pas sive, with the exceptions that we consider an active IPpreﬁx hijack (Section 5.3) and that active methods may be used to link together connections as originating from the same client. In several of our attacks, we assume that the adversary has this ability to link together multiple connections (see Table 2). Observations at the Tor protocol level can allow circuits to be linked via tim ing [30, 32], but the application layer enables even more eﬀective linking in many important use cases, includ ing (1) a malicious website, which can either passively observepseudonymous logins or actively create link able connections [36]; (2) a public IRC channel, which makes pseudonymous activity observable by any adver sary [34]; (3) a hidden service that a malicious client can repeatedly connect to [51]; and (4) an administra tive service that only one entity has access to, such as SSH access to a personal server, where such accesses could be observed and recognized by a malicious ISP hosting the server. Anonymity Metrics. Due to the diversity of our attacks, we use several types of metrics for their evalu ation (see Table 2 for each attack’s metric). Probability of observing the client connection : In some attacks, the adversary attempts to observe the traﬃc between the client and the anonymity network. Such observations can facilitate attacks like website ﬁn gerprinting [28] and timing analysis [38]. We quantify this attack as the probability that the adversary suc ceeds in observing the client connection. Size of source anonymity set : In cases where the adversary uses his observations to reduce the set of pos siblesources, we measure anonymity as the size of this set [42]. The sources in our attacks are ASes. Accuracy and rejection rate when guessing source : Some attacks score possible sources heuristically and then guess the highestscoring source (sources are ASes in our attacks). Because these methods aren’t perfect, the guess may be wrong. However, we can recognize when the scores are too low to make a conﬁdent guess and reject making one. For this approach (multiclass classiﬁcation with the reject option [6]) we measure anonymity using accuracy andrejection rate [49]. Ac curacy is the fraction of correct guesses among cases in which a guess is made, and rejection rate is the fraction of cases in which no guess was made. Entropy of source distribution : When the adver sary’s observations allow him to perform Bayesian in ference on the source, we measure anonymity as the entropy of the posterior distribution [57]. Our distri butions are over ASes, and we use a uniform prior. Bayesian inference is a strong deanonymization techTempest: Temporal Dynamics in Anonymity Systems 5 Table 2. Overview of Tempest attacks showing the attacked system, adversary capabilities, attack goal, and evaluation metric. System Adversary Supporting Capabilities Attack Goal Metric §5.2Vanilla Tor Single AS Observe client directlyProbability of observing clientguard connection §5.3Counter RAPTORSingle AS BGP hijack Observe client directlyProbability of hijacking clientguard connection §5.4HORNET Destination AS Links client connections Has identiﬁed mobility datasetLink pseudonym to realworld identityAccuracy and rejection rate when guessing client identity §6.1DeNASA Some Tor relays Links client connections Identify client AS Entropy of posterior distribution over ASes §6.2Dovetail Single AS Links client connections Identify client AS Set size of possible client ASes §7.1TAPS Destination websiteInduces linkable circuits Performs guard discoveryIdentify client AS Set size of possible client ASes §7.2HORNET Destination AS Tracks connection across routing changeIdentify client AS Set size of possible client ASes §A.1DeNASA Single AS Observe client directlyProbability of observing clientguard connection §B.1Counter RAPTORSome Tor relays Links client connections Identify client AS Entropy of posterior distribution over ASes §B.2PHI Single AS Links client connections Identify client AS Accuracy and rejection rate when guessing client AS nique, but it is not feasible for all attacks ( e.g.due to computational constraints), which prevents us from us ing this metric in many cases it might otherwise apply. Note that many of our metrics measure anonymity of theclient AS . Although a single AS may serve many thousands of clients, an attack that identiﬁes the client AS is still quite dangerous, as (1) the client AS can be targeted to divulge the user’s real iden tity (such targeting would likely be necessary for real world deanonymization even if the client’s IP address were known); (2) the diversity of user attributes ( e.g. physical location) is much lower within a client AS and may combine well with auxiliary knowledge; and (3) the client AS can be used to link connections and build a pseudonymous proﬁle. Indeed, a main challenge in de signing networklayer anonymity protocols is hiding the client AS, as the IP address can be easily hidden by the client AS using Network Address Translation. In several analyses, we focus on the anonymity of the users against whom the attack is mostsuccessful, such as those in locations that experience the largest anonymity losses. The vulnerability of such users to deanonymization is important to consider, as (1) users don’t beneﬁt equally from anonymity, and the most vul nerable users may suﬀer the most from deanonymiza tion; (2) even if a minority of users will end up being deanonymized, that small risk may be too high for a majority of users, who thus cannot use the system; and (3) relatively few deanonymizations may erode overall trust in the system given the diﬃculty of communicat ing inconsistent anonymity guarantees.Network Model. To model Internet routing, we generally infer an ASlevel topology. We infer AS paths using the algorithm proposed by Mao et al.[43], which searches for shortest valleyfree paths that respect lo cal preference for diﬀerent economic relationships ( e.g. customer, provider, peer). While this type of inference isn’t perfect [24], it is used in the original evaluations of all the recentlyproposed anonymity systems that we study(Tor,beinganolderdesign,originallyomittedany networklevel analysis at all but has since been evalu ated using traceroute data [40]). This is true even for those systems (HORNET, Dovetail) that do not work with BGP, which are evaluated using the existing Inter net topology under the supposition that a future Inter net would have similar topological properties. 5 Client Mobility We demonstrate how an adversary can exploit infor mation leakage from client movements to deanonymize client communications. As clients connect to anonymity networks from various network locations, they expose themselves to more adversaries and leak location data that will enable adversaries to deanonymize them. We experimentallyquantifytheeﬀectivenessofsuchattacks for Vanilla Tor, CounterRAPTOR, and HORNET us ing realworld Foursquare and Gowalla data to model client mobility. We also present supplemental results for DeNASA in Appendix A.1.Tempest: Temporal Dynamics in Anonymity Systems 6 Table 3. Number of users with countrylevel movements and number of days to complete the movements in Foursquare ( F) and Gowalla ( G) datasets. Num. Countries 2 3 4 5 6 ≥7 Users F 40145 13179 5649 2708 1490 2574 Users G 17884 4557 1694 705 305 299 Q1Days F 48 120 195 228 248 245 Q1Days G 7 31 56 77 103 125 Med. Days F 144 252 301 331 353 364 Med. Days G 24 71 111 135 160 177 5.1 Mobility Dataset We explored two datasets to model client movements: a Gowalla Dataset [13] and a Foursquare Dataset [66, 67]. The datasets contain location data from real users over the periods Feb 2009–Oct 2010 and Apr 2012–Sep 2013, respectively. We focus on the countrylevel movements of users and use it as a proxy for network movements, as we lack ﬁnegrained data to model ASlevel movements. Table 3 compares the two datasets in terms of num bers of users with distinct countrylevel movements. Note that we only count newcountries in the number of countries visited, i.e., if a user moves out of a coun try and later travels back, we do not recount it. The table also shows the Quartile 1 ( Q1) and median num ber of days it takes to visit each number of countries in both datasets. The median time may take months due to some infrequent travelers, but there are some clients who visit several countries in less than a month. We also notice that the Foursquare dataset shows a higher Q1/median number of days, indicating that Foursquare users travel less frequently than Gowalla users. How ever, given the large number of Foursquare users, the absolute number of users for a given travel frequency is similar between the two datasets. For our analysis in this section, we use both the Foursquare and Gowalla datasets to model client move ments. We use two datasets to map each country to a “possible” AS that a user may connect from in that country: (1) for evaluations on the Tor network, we use Juen’s top Tor client ASes dataset [39] to map the coun try to the top Tor client AS located in that country, and (2) for networklayer anonymity protocols, we use the top Internet Service Provider per country (based on the number of active IP addresses) [15]. 5.2 Vanilla Tor Protocol. A Tor circuit typically consists of three hops. Clients choose a small set of relays (the default number is one) called guardsthat are used as the ﬁrst hop in ev ery circuit. A client will attempt to use the same guard for four to ﬁve months before choosing new guards, but this rate is often accelerated because a client is forced tochoose a new guard if its guard goes oﬄine. To balance the traﬃc load, Tor relays are chosen by clients with probability proportional to their bandwidth. Attack. We quantify the probability that, as a client moves, an adversary is able to observe the client’s Tor traﬃc from the critical position between the client and its guard. Such a position allows the adversary to observe the client IP address and thus to perform web site ﬁngerprinting [28], to locate hidden services [51], and to deanonymize via traﬃc correlation when des tination observations are also available [38]. This po sition is so sensitive that Tor developed entry guards speciﬁcally to make it diﬃcult to observe. We consider a passive adversary controlling a single AS whose goal is to be onpath between a client and its guard relay at some point in time. As a client moves to new loca tionswhilestillusingthesameguardrelaychosenatthe initial location, an ASlevel adversary will have increas ing probabilities to observe the clientguard connection. Note that, although we suppose that the client uses the same guard across movements ( e.g.by using Tor on a laptop), a similar increase in clientguard traﬃc expo sure occurs if the client uses a diﬀerent Tor instance at each new location. Methodology. We obtain Tor network data from CollecTor [62]. We use a Tor relay consensus ﬁle from 1Oct2016andretrieverelevantdataﬁeldsfromeachre layentry,suchasguardﬂag,bandwidth,andIPaddress. We map IP addresses to ASes using Route Views preﬁx toAS mappings [55]. We use CAIDA’s Internet topol ogy [10] with inferred AS relationships from Oct 2016. WeusethesamedatatomodelTorandInternetrouting throughout the paper unless otherwise noted. We evaluate the CAIDA top 50 ASes [9] as poten tialadversarieswhichincludeallTier1ASes.Wechoose the top 50 ASes to evaluate because they are large In ternet service providers that carry a signiﬁcant amount of network traﬃc, and thus they are at a good position to observe clientguard connections (we did also con sider the attack from all ASes and observed a similar increase in probability). We measure the probability of these ASes to be onpath in the clientguard connection at least once during the client’s movements. We assume that the client connects to the Tor network at least once in each country. For a given client and for each guard, we use AS path inference to determine if an adversary AS is onpath at the client’s current and previous lo cations. We then compute the probability by weighting across the guards’ bandwidth. Results. Figure 1 shows the probability of compro mising a clientguard connection in Vanilla Tor, averTempest: Temporal Dynamics in Anonymity Systems 7 0 5 10 15 20 250.00 0.10 0.20 Num. CountriesProb. of Compromise●●●●●●●●●●●●●●●●●●●● ●  Gowalla Foursquare Fig. 1.Probability of compromising a clientguard connection in Vanilla Tor, averaged over the top 50 ASes, with the line showing the median and shaded area showing values within [Q1−1.5IQR, Q3+ 1.5IQR]. aged over the top 50 ASes. Each point on the line shows the median attack probability over clients with a given number of countrylevel movements. The shaded area shows values between [Q1−1.5IQR, Q 3+ 1.5IQR], whereQ1andQ3are Quartile 1 and Quartile 3, re spectively, and IQR, the interquartile range, is deﬁned asQ3−Q1. This is a standard way to exclude out liers. Initially, the median probability is 2.8% with no movement (1 country). With two more movements (3 countries), the median probability already doubles for both datasets. The probability can reach over 25% for the clients who have visited 14 countries or more, which is nearly 9 times more than the baseline (1 country, no movement). The median probability decreases slightly after 20 country movements in the Gowalla dataset (23 in Foursquare dataset). This is due to the small sam ple of users with high numbers of movements in the datasets, causing higher variance. For instance, there is only one Gowalla user that has visited 20 countries, and thus the last data point reﬂects the probability of only that user. Overall, the probability of an adversarial AS compromising a clientguard connection signiﬁcantly in creases during countrylevel movements. 5.3 CounterRAPTOR Protocol. CounterRAPTOR [58] improves Tor’s se curity against BGP hijacks [59] by changing the way that guards are chosen. For each guard Gi, a client cal culates a resilience value Rithat estimates the fraction of Internet ASes that wouldn’t succeed in hijacking the client’s traﬃc to Giby (falsely) claiming to be the ori gin AS of the IP preﬁx containing Gi. The guard relay selection algorithm combines the resilience value Riand the bandwidth of the guard Giby a conﬁgurable param eterαin order to take into account both the resilience to hijack attacks and load balancing. Attack. Weconsideranadversarycontrollingasin gleASwhosegoalistoobservethesensitiveclientguard 0 5 10 15 20 250.0 0.4 0.8 Num. CountriesProb. ≥1 Hijack Success●●●●●●●●●●●●●●●●●●●● ●  Gowalla FoursquareFig. 2.Probability of succeeding in at least one hijack in CounterRAPTOR, averaged over the top 50 ASes, with the line showing the median and shaded area showing values within [Q1−1.5IQR, Q3+ 1.5IQR]. traﬃc(asinSection5.2)viaaBGPhijackoftheguard’s preﬁx.CounterRAPTORaimstomaximizeTorclients’ resiliencies to hijack attacks by choosing a guard relay based on client location. However, the guard selection is done based on the client’s initiallocation, and the same guard is used for several months even though the clients may move across locations . Thus, ASlevel adversaries have an increased power for succeeding in a hijack at tack when clients move to new locations because the guard is only optimized for the initiallocation. Methodology. We evaluate the CAIDA top 50 ASes [9] as potential adversaries. We measure the prob ability of these ASes to succeed in at least one hijack attack during the client’s movements. Note that a suc cessful hijack attack allows the adversary to observe the traﬃc between client and guard, enabling the traﬃc analysis attacks discussed in Section 5.2. For each client and each guard, we use AS path inference to determine if an adversary AS can succeed in a hijack attack on the guard. We then compute the attack probability by weighting across the bandwidth of the guards. Results. Figure 2 shows the probability of succeed ing at least one hijack attack on the client’s guard, av eraged over the top 50 ASes. Each point on the line shows the median value over clients with a given num ber of countrylevel movements. The shaded area shows values in the range [Q1−1.5IQR, Q 3+ 1.5IQR]. We can see that the median probability of hijack success reaches about 68% with only one movement (2 coun tries) for both datasets, compared to an initial of 58% and 50%, respectively, with no movement (1 country). When the number of movements is more than 10 coun tries, the attack probability can reach over 90%. The median probability decreases slightly when the number ofcountriesreachesmorethan12intheGowalladataset due to the same reason as in Figure 1; when the number of movements increases, there are fewer users resulting in higher variance. Overall, our analysis shows that theTempest: Temporal Dynamics in Anonymity Systems 8 probability of hijack success can quickly increase with only very few client movements. 5.4 HORNET Protocol. HORNET [11] (short for Highspeed Onion Routing at the NETwork layer) provides similar privacy guarantees as onion routing but operates at the network layer. HORNET builds on routing protocols in which the source can obtain potential routing paths to the destination. Each router cryptographically modiﬁes the full packet ( i.e.headers and payload) such that each AS onpath between a source and destination can identify only its previous and next AS hops. HORNET’s stated threat model is an adversary who compromises a frac tion of ASes, possibly including the destination AS. Attack. Our attack on HORNET exploits infor mation leakage via auxiliary information about client movements patterns. The threat model for this attack is an adversary who compromises the destination AS. The adversary wants to deanonymize clients who use a servicehostedwithinthedestinationAS, e.g.anASwho provides cloud services wants to ﬁnd the true identities of pseudonymous accounts on a video streaming website hosted in its cloud. The clients’ identities are protected by HORNET when logging into their pseudonymous ac countsonthedestinationwebsite.Atthesametime,the clients may revealtheir identities and locations via aux iliary channels. For instance, researchers, activists, and politicians who frequently travel to diﬀerent countries andgivepublicspeechesexposeboththeiridentitiesand locations. Users may also check in using locationaware services such as Foursquare and Yelp that publicly re veal that information. Identiﬁed user movements may also be collected by a cellular provider and shared with the website for commercial purposes or with a common legal authority. Note that the auxiliary location infor mation is not directly linkable to the users’ accounts on the destination website. The adversary AS has access to two sets of data: (1) pseudonymous accounts of its clients and the preceding hop in the AS path from the clients to the destination AS;(2)auxiliaryinformationthatcontainrealidentities of people and their location data. The adversary’s goal is to link the two datasets and connect the real identities to the pseudonymous activi ties of the clients. The intuition is that the penultimate hop used to reach the destination AS depends on the location of the client. With dataset (1), the adversary can identify a set of possible client locations for each connection to a pseudonymous account by considering which locations could choose a path to the destinationthrough the observed penultimate AS hop. Then, with dataset(2),theadversarycanexaminethelocationdata of identiﬁed users and ask the question: which identi ties were in one of the possible locations for the connec tion?Thisanonymitysetcouldbequitelargeifonlyone pseudonymous connection is considered, but by linking many connections over time the adversary can derive new information when a client moves to new location and thus shrink the client’s anonymity set. Methodology . As described in Section 5.1, we use the Foursquare and Gowalla datasets as auxiliary infor mation that reveal real client identities and their loca tions. We map each client geolocation to the AS of the top Internet Service Provider that oﬀers service in the country of the geolocation. Before any location infor mation, each client’s anonymity set comprises the en tire population of 107,061Gowalla users and 266,909 Foursquare users, respectively. We then consider loca tion data points at a daily granularity. We assume the clients have daily connections to the destination. For each day, we take all the clients with location data and compute the penultimate AS hops given their mapped source ASes. Then, for each client, we can eliminate all the other clients without the same penultimate AS hop from its anonymity set. Given the imperfect auxiliary information (not all clients have location data every day), we only eliminate clients with location data the same day, and assume that the clients who do not have data can be at any arbitrary location and thus do not eliminate them from any anonymity set. After processing all location data from the dataset, we rank the remaining candidates in each client’s anonymity set based on their total number of location datapoints,fromhighesttolowest.Theintuitionisthat we want to place more conﬁdence in the clients who re veal their locations frequently and thus provide more identifying information. We also assign a weight value to each candidate iasea∗Ni, wherea= 0.1andNiis the number of location data points of candidate i. The value ofawas chosen based on the distribution of number of location data points to scale down the numerical values. Then, for each candidate, we compute the weight ratio of its weight over the sum of all candidates’ weights in the given client’s anonymity set. Next, we focus only on the highestweight candi date in each anonymity set. If the weight ratio of the highestranked candidate is above a threshold, then we will guess this candidate as the source; otherwise, we “reject”theinput( i.e.donotguess)duetoalackofcon ﬁdence. Note that we allow a single client to have multi ple pseudonymous accounts on the destination website,Tempest: Temporal Dynamics in Anonymity Systems 9 0.0 0.4 0.8 Num. Location Data PointsAccuracy 100−149 150−199 200−249 250−299 300−349 350−399 400+●●● ●● ● ● ●  (G) 80% R.R. (G) 90% R.R. (F) 80% R.R. (F) 90% R.R. Fig. 3.Accuracy rates for HORNET deanonymizations with in crease in number of location data points at various rejection rates (R.R.) for Gowalla (G) and Foursquare (F) datasets. as we may guess the same candidate for multiple client accounts in the above process. We evaluate the accuracy rates vs. the number of location data points with ﬁxed rejection rate [49] to show the eﬀectiveness of the attack. Accuracy rate is computed as the number of correct guesses over the to tal number of guesses, and rejection rate is computed as the number of nonguesses over the total number of pseudonymous accounts. Results. We present the results for destination Fastly (AS541130), which is a CDN provider for red dit.com and many other websites. We also evaluate other popular sites measured by Alexa [2] such as Google (AS15169), Facebook (AS32934), and Twitter (AS13414), the results for which show similar patterns and appear in Appendix A.2. We evaluate clients for which we have suﬃcient location information, which, in this case, are the clients with at least 100 location data points in the datasets (there are 50,566such clients in Foursquare and 4,645in Gowalla). Figure 3 illustrates the results for ﬁxed rejection rates of 80% and 90%, respectively, for both datasets. For each data point, we bucket clients using increments of 50 location data points. For clients with more than 400location data points, we group them all together since there are many fewer clients. We can see that the accuracy rate quickly increases with the number of location data points. For Gowalla users, with 200 location data points or more, the accuracy rate reaches 100% with rejection rate at 90%, meaning that the adversary can deanonymize 10% of the clients with no false positives. With lower rejec tion rate at 80%, the accuracy rate eventually reaches 100% as well for clients with 300 location data points or more. For Foursquare users, the accuracy rate reaches 97% at 90% rejection rate with 300 location data points ormore,andreaches100%with350locationdatapoints or more for both rejection rates. The diﬀerence between the two datasets can be due to the frequency of client movements, e.g., a client with 300 data points of thesame location may not reveal that much information compared to a client with 300 data points spread across 10 diﬀerent countries. From Table 3, we can see that Foursquare users travel less frequently than Gowalla users. 5.5 Summary We show that client mobility can expose new vulnera bilities that put mobile clients at risk. For Vanilla Tor, client mobility increases the probability that an AS level adversary can observe the traﬃc between clients and guards; for CounterRAPTOR, client mobility in creases the probability of succeeding in routing attacks; forHORNET,clientmobilitymakesitveryeﬀectiveand accurate to deanonymize clients that reveal a suﬃcient amount of location information. 6 User Behavior In some of the anonymity systems that we study, clients leak partial information about their network location through observable parts of their anonymity paths. If an adversary learns such information from a single connec tion, then an adversary that can link multiple connec tionsas originating from the same client may learn in creasing amounts of information. In this section, we at tack two protocols, DeNASA and Dovetail, with an ad versary who links together observations over time. Ad ditionally, we refer an interested reader to Appendices B.1 and B.2, where we provide supplemental results ex ploring how our Tempest attacks can be extended to two similar systems: CounterRAPTOR and PHI. 6.1 DeNASA Protocol. DeNASA [4] is a proposal to improve Tor’s security by modifying how relays are selected for cir cuits.Itisdesignedtopreventdeanonymizationviatraf ﬁc correlation by a small number of Suspect ASes , that is, ASes that appear frequently on paths to or from the Tor network. In the DeNASA guardselection algorithm gselect, clients make a bandwidthweighted choice of guard only from among relays that are suspectfree . A suspectfree relay is deﬁned as a relay such that neither of the toptwo Suspect ASesappearon thenetwork path between the client and the relay. Suspect ASes are glob ally ranked in descending order of how often they are in a position to perform traﬃc correlation on Tor circuits. Attack. The subset of suspectfree relays available to a client varies depending on the client ISP’s Inter net links and routing policies. Because of this variation across client locations, clients in diﬀerent locations will often select the same guard with diﬀering probabilities.Tempest: Temporal Dynamics in Anonymity Systems 10 Thus,aguardselectionleakssomelocationinformation; an adversary who can identify a client’s guard can at tempt to infer the client’s location by considering guard selectionlikelihoodsfromvariouslocations.InthisTem pest attack, we demonstrate that multiple guard selec tions, identiﬁed by the adversary over time as belonging to the same client, can leak enough information to re veal the client’s AS. Recall that identifying the client’s AS is a serious degradation of anonymity (Section 4). To run this attack, the adversary runs some Tor re lays. The malicious relays will occasionally be used for a client’s circuits, allowing the adversary to discover the client’s guards over time [65]. The adversary may also employ other known guard discovery attacks [22, 45]. We suppose that the adversary is able to link together a client’s connections over time using the methods de scribed in Section 4, which can all be accomplished by an adversary running relays. Having identiﬁed guards (G1,...,G n)used by the same client over time, the adversary performs Bayesian inference to compute the posterior probability Pr(L|G1,...,G n)for each possi ble client location L. The adversary uses whatever prior belief he has about the client location (we use a uni form prior). Clients use public routing data to identify suspectfree relays, and so the adversary can compute the guardselection distributions for all client locations needed to compute the posterior distribution over loca tions. Increasing numbers of identiﬁed guards reduces the uncertainty in this posterior distribution and can eﬀectively reveal the client location. Methodology. We analyze this information leak age over multiple guard selections by simulating De NASA’s gselect algorithm using our network model (Section 4). We identify a maximal connected compo nentcontaining 55,244ASesinthegraphgeneratedfrom our AS path inference to use as Tor client locations; we restrict our analysis to a clique to prevent inaccu racies arising from missing edges in the inferred graph. For each of these client ASes, we compute the suspect free guard selection distribution that clients inside these ASes will use to choose guards. Following Barton et al. [4], we use AS1299 (Telia Company) and AS3356 (Level 3) as the suspect ASes that clients try to avoid. Since the adversary performs Bayesian inference in this attack, we use the entropy of the adversary’s pos terior distribution over client locations as our measure of client anonymity. We employ a number of heuristics to search for worstcase “leaky” client ASes from which guard selections reveal location information quickly; for example, one heuristic ranks client ASes in ascending order by the mean entropy of the adversary’s posterior 0 1 2 3 4 5 60 5 10 15 Num. Observed GuardsEntropy (Bits)● ● ● ●  AS1759 AS199348 AS25089 AS57217Fig. 4.Mean entropy of posterior clientAS distribution of De NASA gselect clients in “leaky” ASes after xguard observations. distribution after a singleguard selection is made (av eraged over guards). We select the top ten leaky client ASes identiﬁed by our heuristics to evaluate. For each of these ten client ASes, we simulate a client inside the AS making guard selections (with re placement). We compute the likelihood that these se lections were made by a client in each of the possible 55,244client ASes. From these likelihoods, we generate the adversary’s posterior distribution over all possible client locations using a uniform prior. We perform this simulation 100 times for each of the ten client ASes. Results. In Figure 4 we show the entropy of thisposteriorlocationprobabilitydistribution,averaged acrossthesamples,foreachclientASatvaryingnumber of guard observations. For visual clarity, we only present four of the evaluated ASes (the other six ASes exhibit similar or identical trends). After two observed guard selections, clients from all ten ASes drop below 4 bits of entropy. After three observations, the median entropy for these ASes drops to just 1 bit. Observe how multiple observations combine to cause dramatic reductions in anonymity. For example, after a single guard selection observation, clients in AS199348 only lose an average of 1.34 bits of entropy; however, a second observation, in combination with the ﬁrst, yields a substantial loss of 13.26 bits and depletes nearly all of the client’s entropy. A client is forced to select two or more guards quickly (e.g.in hours or days) if his guards go oﬄine and is guaranteed to select a new guard every few months. 6.2 Dovetail Protocol. Dovetail [56] is a networklayer anonymity protocol designed for networks that support source controlled routing. In Dovetail, a source host Sbuilds a route to a destination host Dusing overlapping head andtailpath segments to and from a matchmaker AS M, which is chosen randomly from a set of available matchmaker ASes. Sbuilds the head path segment to Mand encrypts D’s identity to M.SandMcoordinate tochooseandbuildthetailsegmentto DsuchthatheadTempest: Temporal Dynamics in Anonymity Systems 11 and tail path segments intersect at a common AS, X, called the dovetail. AfterXremoves the loop to the matchmaker, the ﬁnal path used for communication is S;X;D. ASes on a Dovetail path learn: (1) the identities of their immediate predecessor and successor ASes on the path, (2) their absolute position in a path (e.g.ﬁrst hop, second hop, etc.), and (3) the host/AS at the end of their path segment (ASes on the head seg ment learn M’s identity, ASes on the tail segment learn D’s identity, and Xlearns both MandD’s identity). In sourcecontrolled routing, a client chooses the AS path used for his connections from a subset of paths made available by his ISP — we call this path subset routable paths . To build a Dovetail connection, a client randomly chooses a head path segment from among his routable paths containing six or more ASes to the matchmaker; the dovetail is chosen to be the secondto last AS on the head path segment. The details of tail path selection are unimportant for this attack. Attack. To reiterate, a client is limited to select a head path segment to the matchmaker from among routable paths; the availability of routable paths varies depending upon the client’s ISP, and so path usage inherently leaks location information. If the adversary compromises the kth AS on a path, then he can narrow down the client’s location by considering the set of ASes that could have created a path of length (k−1)to the predecessor AS Pin the path. With our Tempest attack, we demonstrate that this leakage is greatly exacerbated if a single Dovetail client makes many connections. Suppose the adversary con trols an AS that monitors connections passing through his AS, a scenario that is within Dovetail’s stated threat model.Werequirethattheadversarylinkstogethercon nections as originating from the same client ( e.g.using a method described in Section 4). The adversary will use his path observations when he happens to be chosen in the dovetail position because this position is the closest to the source that also learns the connection’s destina tion, which facilitates the connectionlinking required for this attack. Suppose the adversary makes observa tions{(P1,k1),..., (Pn,kn)}with respect to a client, where (Pi,ki)denotes the adversary’s predecessor and absolute position on the ith connection on which he is in the dovetail position; then, the adversary can com pute the set of possible client locations as ∩n i=1L(Pi,ki) whereLmaps a predecessor Pand position kto the set ofclientlocationsthatcancreateapathoflength (k−1) toP. The output of this attack is a possibility set over client locations, in contrast to the probability distribu tionover client locations obtained by the adversary inthe Section 6.1 attack; computing the observation like lihoods required for Bayesian inference is computation ally expensive given Dovetail’s route selection scheme. Methodology. We run our attack in a simulated Dovetail network with paths inferred from CAIDA’s In ternet topology. We follow Sankey and Wright and use a network model in which a client can route a connec tionthrough anyvalleyfreeASpathbetweenthesource anddestinationwithatmostonepeertopeerlink.ASes withoutcustomerASesactaspossibleclientISPsinthis analysis; there are 47,052such ASes in the topology. Dovetail Frequency. We assume the adversary com promises a single, ﬁxed AS; as such, interesting ASes to consider as compromised are ones that are selected of ten as a dovetail. We run simulations to determine ASes that are likely to be selected to serve as the dovetail. In each simulation, a source AS and matchmaker AS are chosen uniformly at random from among all client ISP ASes and all ASes, respectively. Then, we simulate a client in the source AS who builds a path to the match maker AS and record the dovetail AS. We collect sam plesbyrepeatingthisprocedure 10,000timesandchoose as our adversarial AS the mostcommon dovetail. Anonymity Evaluation. We run simulations to mea sure the eﬃcacy of this attack with respect to the ﬁxed adversarial AS. In each simulation, we choose a source AS uniformly at random from among all client ISP ASes and choose 500 ASes uniformly at random from among all ASes to serve as matchmaker ASes. Then, we sim ulate a client in the source AS who makes up to 100 repeated connections to the same destination (the des tination location is irrelevant for this analysis). For each connection, the client chooses a matchmaker AS uni formly at random from among the 500 possible and builds a path to the matchmaker. If the ﬁxed adver sarial AS happens to be placed in the dovetail position on this path, the adversary observes his predecessor AS in the path and his ordinal position in the path. The adversary then computes the set of all ASes who could have constructed a path of observed length to his prede cessor and, through intersection, updates his set of pos sible client locations maintained persistently for the en tire simulation (initially containing all 47,052client ISP ASes). If the adversary is not selected as the dovetail for a connection, he simply takes no action. We record the size of the possible client location set after each of the 100 sourcematchmaker paths are constructed. We collect samples by repeating this procedure 500times. Results. Dovetail Frequency. AS1299 (Telia Com pany) is selected most frequently as the dovetail AS, used in 4.03% of all samples. The distribution is veryTempest: Temporal Dynamics in Anonymity Systems 12 Num. ConnectionsAnon. Set Size (Num. ASes) 0 20 40 60 80 100102103104● ● ● ●●● ●  5th 10th 20th 30th 50th 75th Fig. 5.Anonymity set sizes in Dovetail after xrepeated connec tions with respect to AS1299. Each line corresponds to a per centile of the samples’ anonymity set sizes. rightskewed — although 1,005unique ASes are selected as dovetail at least once, the top ten ASes of the distri bution are used as the dovetail in 30.73% of all samples. Anonymity Evaluation. Because AS1299 was se lected as the dovetail most frequently in our frequency analysis, we use it as our ﬁxed adversarial AS. We also ran experiments for the other nine mostfrequently selected dovetail ASes and ﬁnd that they all produce similar results. Figure 5 plots the number of ASes in the source’s anonymity set after xrepeated connections. Each line corresponds to a percentile; for example, the point at (x= 100, y= 126)in the “5th” percentile indi cates that, after 100 connections, AS1299 could rule out all but 126 possible source ASes in 5% of samples. This attack yields signiﬁcant anonymity reductions in many of our samples. After 10 repeated connections, in 5% of samples, our adversary can rule out all but 5,100source ASes as possible — a 90% reduction in anonymity set size. By 100 repeated connections, the 5th percentile across samples is reduced by 99.7%. These results exhibit a continual reduction in anonymity as the client make connections, suggesting that clients who make many connections place them selves at a high risk for deanonymization. A client could make hundreds of repeated connections over a few days/weeks if he is a frequent user of some Internet ser vice. We ﬁnd that each of the ten most frequently se lected dovetail ASes are strong vantage points for this attack. Many of these ASes are Tier 1 or large transit networks; such ASes are naturally of interest to many adversaries and are high value targets for compromise. 6.3 Summary For both the DeNASA and Dovetail protocols, we demonstrate serious weaknesses to an adversary who can link observations together. We emphasize that the signiﬁcantanonymitydegradationinourﬁndingsoccurs only after a client makes multiple connections , whereas prior work has focused on quantifying anonymity after a single observed connection.7 Routing Changes Natural Internet routing dynamics can change the net work paths between hosts in an anonymity system. In this section, we show how an adversary can use such route changes to deanonymize users of two systems: TAPS and HORNET. 7.1 TAPS Protocol. TrustAwarePathSelection(TAPS)[36]pro poses to improve Tor’s resistance to traﬃccorrelation attacks by choosing circuits based on the trust that a client has in diﬀerent network components. TAPS models a trust belief as peradversary probability dis tributions that describe the likelihood that relays and network paths between relays are under observation by eachadversary.Becausediﬀerentclientlocationsusedif ferentnetworkpaths,TAPSleaksinformationaboutthe client’s location through how the client chooses its cir cuits’ relays. To limit this leakage, TAPS clusters client locations around a ﬁxed set of representative locations, and then each client chooses circuits as if it were in its cluster’s representative location. The clustering routine is informed by a static snapshot of the state of the net work at the time of cluster generation. This snapshot contains information about the entities in the trust be lief, such as the Tor relays and the ASes. Importantly, it includes inferred ASlevel routing paths. Because the state of the network changes over time, Johnson et al. state that clusters should be reformed periodically. Attack. There exists a signiﬁcant temporal issue with the TAPS clustering process: a client’s circuit construction behavior may reveal his cluster, a client’s cluster may change across cluster reformations , and the adversary can intersect those clusters to gradually re veal the client’s location. The TAPS AStocluster as signments are public, and so the adversary can use them to perform this deanonymization. For our attack, we suppose the adversary employs a variant of the Chosen Destination Attack [36] in which the client repeatedly connects to a malicious website over a longer timescale. The adversary runs a number of web servers hosted in diﬀerent ASes and includes resources from each server in the website. Each time the client connects to the site, the adversary uses his servers, in conjunction with a guard discovery attack [22, 45], to observe the client’s circuitconstruction be havior. As demonstrated against Astoria, these obser vations can identify the client’s representative location and thus his cluster. After the adversary determines a client’s clusters (C1,...,C n)acrossncluster formaTempest: Temporal Dynamics in Anonymity Systems 13 Anonymity Set Size (Num. ASes)CDF 1 10 100 10000 0.2 0.4 0.6 0.8 1 ● ●●● ●  n=1 n=2 n=3 n=6 n=12 Fig. 6.Anonymity set sizes of possible client ASes in TAPS after ncluster formations. tions, then the adversary knows the client’s AS is in the set/intersectiontextn i=1Ci. As cluster composition varies across reformations, the client’s AS can eventually be revealed (Section 4 describes how revealing the AS degrades the client’s anonymity). Methodology. We measure this degradation by running the TAPS clustering routine on archived Tor and Internet routing data. We implement TAPS (specif ically, the TrustAll conﬁguration with The Man trust policy) to conservatively evaluate how it is aﬀected by network changes. In particular, we omit AS organiza tions, IXPs, and IXP organizations as possible sources ofcompromise, andweuse aﬁxed preﬁxtoASmapping at all times. These choices should make our anonymity analysis conservative, as anonymity degrades faster the more that the composition of TAPS clusters changes across cluster reformations. By implementing TAPS to use fewer data sources and more static data, we expect that the clusters generated by TAPS vary less in com position across reformations. We perform twelve TAPS cluster formations — one foreverymonthin2016.WeuseCAIDA’sserial2ASre lationships and CollecTor’s Tor data for each respective month, and a ﬁxed Route Views preﬁxtoAS mapping set from Jan 2016 for each clustering. Following John sonet al.[36], we use the top Tor client ASes identiﬁed by Juen [39] as medoid centers and conﬁgure TAPS to generate 200 client clusters. We verify that our TAPS implementation is deterministic on input ( i.e.changes in AScluster assignments are driven by changes in net work data, and not by some use of randomness within the clustering algorithm). Weidentifyasetof 50,388stable ASes ,thatis,those that exist in all twelve clusterings (ASes are only clus terediftheyexistintheCAIDArelationshipdatasetfor thatmonth).Wemeasuretheanonymitysetsizeofeach of these stable ASes after a variable number nof consec utive cluster formations; namely, |/intersectiontextn i=1Ci(AS)|whereCi maps an AS to the ASes in its cluster in month i.Results. Figure 6 plots distributions of anonymity set sizes. Each CDF corresponds to the distribution af ternconsecutive cluster formations. The (n= 1)CDF shows the anonymitysetsize distribution after the ini tial clustering in Jan, (n= 2)shows the distribution after cluster formations in Jan and Feb, etc.Each point on a CDF corresponds to the anonymityset size for one of the 50,388client ASes. TAPS cluster reformations have serious conse quences with respect to user anonymity. Initially ( n= 1), the TAPS clustering assignment does well at produc ing large clusters with similar sizes: the 5th, 50th, and 95th percentiles are all of the same order of magnitude with sizes of 103, 445, and 927 ASes, respectively. How ever, just a single reformation can harm large fractions of users. After just a singlereformation in Feb ( n= 2), we observe a 94% reduction in anonymityset size, from 445 to 28 ASes, for the median client AS, and a 99% re ductioninsizefrom154to2ASesatthe10thpercentile. By six total clusterings, ( n= 6), 49% of ASes are left with singleton anonymity sets. Clients from any one of these ASes in this nearmajority are rendered identiﬁ able to their AS by their circuitconstruction patterns over time. By being patient and exploiting this tempo ral vulnerability in TAPS, the adversary can learn many clients’ locations. 7.2 HORNET Protocol. Refer to Section 5.4 for a more complete description of the HORNET protocol. The important properties of the protocol to recall are: (1) HORNET provides anonymity at the network layer; (2) the identi ties of the source and destination hosts of a connection are hidden from all ASes carrying the connection’s traf ﬁc except the source and destination ASes, respectively; and(3)ASeslearntheirimmediatepredecessorandsuc cessor ASes on a connection’s path. Attack. For this Tempest attack, we observe that network routes can change over time and that such changes can leak information about the client location. Consider a compromised AS Athat observes a connec tion to a destination server within A. The adversary observes the penultimate AS hop Xof this connection. Thus, the adversary knows that the client’s location is in the set S0containing all ASes that currently have a route toAwith penultimate hop X. Now, suppose a route change occurs that causes the client to reconnect through penultimate AS hop Y. We assume that the adversary can link the reconnection to the prior con nection via traﬃc analysis ( e.g.the destination typi cally has only one active connection or a higherlevelTempest: Temporal Dynamics in Anonymity Systems 14 protocol has an identiﬁable handshake pattern at con nection start). The adversary can then compute the set S1containing ASes that route to Athrough penulti mate hopYand conclude that the client’s AS is within S0∩S1. Thus, as with the previous attack (Section 7.1), the client’s anonymity is degraded by learning its AS. To run this attack, the adversary (1) controls an AS A, (2) monitors connections to a thirdparty destination host within A, and (3) waits for route changes to occur that aﬀect the connections he is monitoring. The adver sary must also have some source of data about the avail ableroutesto A,severalofwhicharecurrentlyavailable, including public routing datasets [64] and public plat forms for traceroute measurements [54]. We assess the risk this attack poses by quantifying the frequency of naturallyoccurring route changes and the impactthat a single change can have on anonymity. Methodology. We use traceroute data made avail able by RIPE Atlas [54] to analyze Internet routing changes. RIPE Atlas is an Internet measurement plat form consisting of thousands of volunteerrun network probes.Theseprobesaredistributedacrossthousandsof diﬀerent networks and can be conﬁgured to run various Internet measurements, such as pings and traceroutes. We consider one such Internet measurement ( id = 5001); in this measurement, all online probes run UDPtraceroutestok.rootservers.net.InJan–Feb2016, the period we consider for this study, this name resolved to 193.0.14.129 in AS25152. There were approximately 8,500probes hosted across 5,700IP preﬁxes, representa tiveof10–11%ofallocatableIPv4space,runningtracer outes to this destination every 30 minutes. For the sake of this analysis, we consider the scenario where AS25152 is under adversarial control and contains a destination host of interest to the adversary. We identify a set of stable probes whose IP preﬁx and AS of origin do not change during our measure ment period; we want to ensure that route changes that we observe are due to changes in network routes and not “artiﬁcially” induced by a probe’s physical location changing. We identify 6,566stable probes hosted across 2,726unique ASes. These probes will serve as the clients our adversary will attempt to deanonymize. Frequency of Changes. We use Route Views preﬁx toAS mappings to compute the AS path each probe uses to reach AS25152. At the granularity of the mea surement interval (30 minutes), we search for route changes that cause a change in a stable probe’s penul timate hop to AS25152 between two traceroutes. We perform this search for all stable probes over the en tire monthlong period. We compute the mean number Anonymity Set Size (Num. ASes)CDF 1 10 100 10000 0.2 0.4 0.6 0.8 1 ●●●● ●  Before Change After ChangeFig. 7.Mean anonymity set sizes for ASes before and after a route change occurs in HORNET. of penultimate hop changes each AS experiences from Jan–Feb (averaging over probes). Impact of Changes. For each route change we iden tify in a stable probe p’s traceroute data, we com pute two sets: S0, containing all probes with traceroutes matchingp’s penultimate hop before the route change occurred, and S1, containing all probes with traceroutes p’s penultimate hop after the route change occurred. We then measure p’s anonymity set size with respect to S0 andS0∩S1(i.e.before and after the route change) by computing|{A(p)|p∈S0}|and|{A(p)|p∈S0∩S1}|, whereAmaps a probe to its Autonomous System of origin. Following this method, we compute the mean beforeandafter anonymity set sizes for each AS with at least one route change by averaging over all route changes and stable probes. Results. Frequency of Changes. We ﬁnd that 840 (30%) of the 2,726ASes experience at least one penul timate hop route change from Jan–Feb and that the distribution of changes is longtailed. 20% of ASes ex perience at least 2 penultimate hop changes on average, 10% of ASes experience at least 3.8 changes, 5% of ASes experience at least 7.9 changes, and 3% of ASes experi ences at least 50.8 changes. ASes that had at least one route change are susceptible to this attack. Frequent route changes can further expose users both by increas ing the probability that an adversary can make at least one route change observation for a user and by intro ducing the possibility that multiple route changes can be linked to a single user. Our results are limited to lo cations with probes, but, due to the large samplesize of probes, the distribution of frequencies we obtain should apply to the Internet as a whole. Impact of Changes. Figure 7 depicts the distribu tion of mean anonymity set sizes for each of the 840 ASes with at least one change before and after a single, average routing change occurs. A nontrivial percentage of these ASes (8%) are left with singleton anonymity sets after the average route change. There is a sizable reduction in anonymity for most ASes; for example,Tempest: Temporal Dynamics in Anonymity Systems 15 the median shifts from an anonymity set size of 170 ASes to just 8 ASes. The anonymity sets formed in this analysis are limited to locations with probe cover age.Thisparticularlyaﬀectstheabsoluteanonymityset sizes. However, we expect that the relative reductions in anonymity ( e.g.an order of magnitude) reﬂect an ad versary’s ability in practice. These results present a serious risk for users. Sup pose that the destination under surveillance in AS25152 servesclive client connections on average at any given timeandsupposethatusersaredistributedroughlyuni formly across the Internet AS space. From our analysis above, we would expect that 0.3cconnections will ex perience a penultimate hop route over the month (see Frequency results, we found that 30% of source ASes experienced a penult. hop change). If the destination is popularorconnectionsarelonglived, cwillbelargeand thus many users will be vulnerable to this attack. 7.3 Summary For both TAPS and HORNET, we show that a pa tient adversary who waits for network changes (clus ter reformations in TAPS, route changes in HORNET) can use public datasets (cluster assignments, tracer oute data) to achieve orderofmagnitude reductions in clients’ anonymity set sizes. As the network continues to change, clients ASes can be completely identiﬁed. 8 Discussion and Ethics Countermeasure Challenges. Explicitly accounting for temporal dynamics could reduce the severity of the Tempest attacks. However, the most straightforward de fenses encounter subtle tradeoﬀs and weaknesses. For example, an obvious approach to defending against the clientmobility attacks on vanilla Tor and Counter RAPTOR is for the client to select multiple guards in diﬀerent locations and use the one closest to current location. However, this raises an immediate tradeoﬀ be tween defending against Tempest and limiting the num ber of potentially malicious relays in the guard position. This approach also raises the possibility of an attack in which an adversary places guards in targeted locations to aﬀect nearby clients. As another example, a natural attempt to prevent the userbehavior attack on Dove tail would be for each client to choose a small number of matchmakers to use for all connections. However, as noted by Sankey and Wright (Section 5.1 [56]), reusing the same matchmaker gives it the ability to perform an intersection attack across connections based on their tail segments, as the client chooses each tail segment to minimize intersections with the head path. As a ﬁnal example, a plausible defense against the routing change attack on HORNET might seem to be for the client to choose paths for which the penultimate hop changes infrequently. However, in addition to making a client’s anonymity dependent on routing dynamics out side of its control, this creates an additional information leak to the adversary, who could take into account path variability when considering which client location is a likelysourceforanobservedconnection.Thusdefending against the Tempest attacks appears to be a nontrivial challenge that we leave for future work. Active Attacks. In this paper, we mainly consider adversaries passively observing network traﬃc. How ever, we do consider an adversary performing active BGP hijacks against CounterRAPTOR in Section 5.3 and Appendix B.1, and we do include active methods among those that might be used to link connections and perform guard discovery. We leave for future work a more general analysis of the power of active adversaries to exploit temporal dynamics. Such adversaries could be very powerful. For instance, an active adversary may be able to track the movements of a Vanilla Tor client by continually intercepting traﬃc to the guard. As an other example, an active adversary may cause observ ableroutingchangesbywithdrawingandinserting(pos sibly completely legitimate) routes in HORNET. Ethical Considerations. All the datasets we used in this paper were publicly available. With the privacy and safety of Tor users in mind, we refrain from collect ing any user data on the live Tor network. Instead, we workwithexistingpublicdatasets,suchasnetworkdata from CAIDA and RIPE Atlas, Tor data from CollecTor, and location data from Gowalla and Foursquare, to per form attack analysis while preserving the anonymity of real Tor users. The code used for this paper is available athttps://github.com/rwails/tempest for review. 9 Related Work","In this paper, we present Temporary Dynamics in Anonymity Systems (TDS): a set of attacks that demonstrate the impact of temporal dynamics on the security of anonymity protocols. We target Tor and some of the latest proposals for improving its security against network-level adversaries (namely, DeNASA, Astoria, TAPS, and CounterRAPTOR). We also target proposals for network-layer anonymity that represent the main ideas for providing anonymity against AS-level adversaries in a next-generation Internet (namely, Dovetail, and HORNET). We evaluate the",cool!
233,A Secure Wireless Routing Protocol Using Enhanced Chain Signatures.txt,"We propose a routing protocol for wireless networks. Wireless routing
protocols allow hosts within a network to have some knowledge of the topology
in order to know when to forward a packet (via broadcast) and when to drop it.
Since a routing protocol forms the backbone of a network, it is a lucrative
target for many attacks, all of which attempt to disrupt network traffic by
corrupting routing tables of neighboring routers using false updates. Secure
routing protocols designed for wired networks (such as S-BGP) are not scalable
in an ad-hoc wireless environment because of two main drawbacks: (1) the need
to maintain knowledge about all immediate neighbors (which requires a discovery
protocol), and (2) the need to transmit the same update several times, one for
each neighbor. Although information about neighbors is readily available in a
fairly static and wired network, such information is often not updated or
available in an ad-hoc wireless network with mobile devices. Our protocol is a
variant of S-BGP called SS-BGP and allows a single broadcast for routing
updates without having the need to be aware of every neighboring router. The
protocol is based on a novel authentication primitive called Enhanced Chain
Signatures (ECS).","The BorderGatewayProtocol(BGP) [1,2] is a Path Vector Routing protocol, in which routers repeatedly advertise ‘better’ routes (along with t he path de tails) to their immediate neighbors. On receiving an update, a router checks its routing table to decide if this advertised route is better than its exis ting routes. If so, the router updates its table and advertises the new route t o all its other immediate neighbors. The ‘textbook’ variant of BGP (hereafter ca lled BGP) has many security vulnerabilities [3,4]. For instance, a rogue router c ould claim a shorter route to some destination in order to intercept traﬃc. T herefore, real implementations use a modiﬁed variant of BGP called SecureBGP (SB GP). In SBGP, routers must have knowledge of immediate neighbors and up dates are peerspeciﬁc. In the context of adhoc wireless networks, a nod e with several re ceivers in its vicinity must ﬁrst establish the identity of every such re ceiver who is also a forwarder, and then broadcast as many updates. Such co ntrol plane traﬃc becomes a bottleneck in scenarios where the wireless devices are densely distributed, power constrained and have low data plane traﬃc. In [5], a novel signature scheme called Chain Signatures (CS) is propo sed. As an application, a secure routing protocol called Stateless Secure B GP (SSBGP)isalsopresented.The attackscenariodescribedisofa“routetru ncationattack”1 in wired networks. SSBGP is as secure as SBGP and has some advan tages. The main advantages in their protocol over SBGP are: (1) update s can be broadcast and need not be peerspeciﬁc, and (2) routers need n ot be aware of their immediate neighbors. However, such advantages are not ove rwhelming in the scenario presented in [5] because true broadcast channels do not exist in wired networks. On the other hand, wireless networks provide tru e broadcast channels without the ability to control or determine who receives th is broadcast. This feature presents a perfect application scenario for SSBGP. We extend the work of [5] and propose a protocol for wireless routing. The proto col optimizes traﬃc in the control plane by allowing an adhoc network of wireless n odes to establish routing information in presence of several compromise d nodes and without any prior knowledge of topology. The protocol is based on a n extension of CS called Enhanced Chain Signatures (ECS). 2 Wireless Routing using BGP Notation: The following discussion is based on Figure 1, which shows a wireless network. The circles represent areas of coverageof the transm itter nodes located at their centers, which are represented by small colored discs. Th e arrows rep resent various messages broadcast by the nodes at the tail. Note that although the arrows point to particular directions, every node within the cor responding circle is able to receive that message. Each circle has the same radius so that any node Xis covered by some node YiﬀYis covered by X. Two nodes with nonoverlapping coverage can communicate by using intermediate n odes as for warders. Each node has a permanently active receiver and a passiv e transmitter that activates when a message is to be sent or a received message is to be for warded. All messages sent by the transmitter are broadcast to a nyone in the covered area. Senders of broadcasts are uniquely determined via this public key. In other words, it is not possible for a broadcasting node to concea l its identity. The symbol X⇐Ydenotes the string “ There is a metric 1 path from Yto X” and the symbol X⇐denotes the string “ There is a metric 0 path from Xto X”. The symbol X→:mindicates that mis broadcast by X.SX(m) indicates a signature on message mbyXusing an existentially unforgeable signature scheme (we assume that the signature scheme provides message r ecovery). BGP updates: (control plane) Refer to Fig. 1. The following updates are sent for routes to A. Each signature (except the ﬁrst) implies a hop of metric 1. 1.A→:SA(A⇐) 2.B→:SA(A⇐),SB(A⇐B) 3.C→:SA(A⇐),SB(A⇐B),SC(B⇐C) 4.D→:SA(A⇐),SB(A⇐B),SC(B⇐C),SD(C⇐D) 5.E→:SA(A⇐),SB(A⇐B),SC(B⇐C),SE(C⇐E) 6.F→:SA(A⇐),SB(A⇐B),SC(B⇐C),SD(C⇐D),SF(D⇐F) 1Referred to as a path extraction attack in [5]Fig.1.A typical scenario for a route truncation attack in wireless networ ks. Aftertheaboveupdateshavebeentransmittedandallsignature sareveriﬁed, each node updates its routing table to contain a tuple (destination, nexthop, metric). For instance C’s table will contain the entry ( A,B,2). See [1] and Sec tion 3.2fordetails onhowthe nodesconstructthe table. Thenodes usethis table to decide when to broadcast a received data packet and when to ke ep silent. If a packet arrives from a node that is the next hop for the destinatio n, then the packet is dropped, otherwise it is forwarded. Forwarding: (data plane) node Ebroadcasts a data packet destined to A. On receiving this packet, node Cwill activate its transmitter to forward the message (since C’s routing table shows that Eis not the nexthop on route to A). BothBandDwill receive this broadcast from Cbut only Bwill activate to forward it further (since D’s routing table shows that Cis the nexthop for destination A). Finally, the broadcast of Bis received by Aand there is no further forwarding. Route truncation attack: Although the signatures ensure that fake routes cannotbecreated,theydonotensurethatintermediateroutes arenottruncated. As an example, Fis an attacker who needs to intercept the above data packet. First note that using the above updates, D’s routing table is set to discard data packets received from Cand addressed to A. Thus, such packets would never be received by F. To launch its attack, Fpretends to have a shorter route to A thanCdoes. To do this, Freplaces its routing update broadcast in Step 6 with the following: F→:SA(A⇐),SF(A⇐F) On receiving this update, node Dwill believe that the route to AviaFis shorter. Consequently, Dwill update its routing table to forward a data packet received from Cand addressed to A. This general attack is called route truncation. In this attack, every data packet sent by Eand addressed to Awill be received by F. Although we only considered an eavesdroppingattack, it is trivial forFto launch a DoS attack. For instance, if Fdrops all data plane traﬃc, it can ensure that data packets originating from Dand addressed to Anever reach their destination. SecureBGP Routing: A possible way to disallow this attack is to use SecureBGP (SBGP), which is an augmented version of BGP. SBGP requires that updates be recipient speciﬁc. Although SBGP is designed for w ired net works, the same concept can be adapted to wireless. SBGP requir es that each host be aware of their immediate neighbors (in this context, receive rs within its coverage). SBGP assumes that this information has somehow bee n established. LetXandYdenote nodes within E’s andF’s coverages respectively (but not covered by any other node). The SBGP updates are as follows. 1.A→:SA(A⇐B) 2.B→:SA(A⇐B),SB(B⇐C) 3.C→:SA(A⇐B),SB(B⇐C),SC(C⇐D) C→:SA(A⇐B),SB(B⇐C),SC(C⇐E) 4.D→:SA(A⇐B),SB(B⇐C),SC(C⇐D),SD(D⇐F) 5.E→:SA(A⇐B),SB(B⇐C),SC(C⇐E),SE(E⇐X) 6.F→:SA(A⇐B),SB(B⇐C),SC(C⇐D),SD(D⇐F),SF(F⇐Y) The above protocol is secure from route truncation attack. Fro m an applica tion perspective, the only diﬀerence between (ordinary) BGP and S BGP is that while BGP is resistant to every attack except route truncation att acks, SBGP is also resistant to such attacks. Stateless Routing: Observe that the SBGP protocol of Example 2 has two major drawbacks: (1) Each router must be “aware” of its neig hbors, and (2) In the example, router Ccan no longer broadcast the same message for every neighbor.Thishasscalabilityproblemsasfollows.Firstly,everytran smittermust have prior knowledge of all receivers within its coverage, which is clea rly prob lematic. Secondly, since each update is peerspeciﬁc, even a single r oute change could result in a large number of broadcastsby a node with many rece ivers in its coverage. It would be much simpler if the underlying routing protoco l resisted route truncation attacks and required each router to broadcas t only one short message on each update without being aware of its neighbors/rece ivers. We call such a protocol a Stateless Routing Protocol . To avoid the route truncation attack in a stateless protocol, given the message in Step 4 of Examp le 1, attacker Fshould not be able to extract SA(A⇐).Our Contribution: We present a stateless routing protocol that resists route truncation attac ks. Our proposed protocol, called Stateless SecureBGP (SSBGP) is a variation of S BGP and provides the following beneﬁts: 1. It is fully stateless  routers need not be aware of their neighbor ing receivers. 2. It is communication eﬃcient  one constant size broadcast per up date irre spective of the number of peers.2.1 Related Work","In this paper, we propose a protocol for wireless routing based on Stateless Secure BGP (SSBGP). The protocol is based on a novel extension of Chain Signatures (CS) called Enhanced Chain Signatures (ECS). The protocol is based on a new signature scheme called Enhanced Chain Signatures (ECS). The protocol is based on a new signature scheme called Enhanced Chain Signatures (ECS). The protocol is based on a new signature scheme called Enhanced Chain Signatures (ECSBGP) based on a new protocol for wireless routing",cool!
204,A Reinforcement Learning Framework with Region-Awareness and Shared Path Experience for Efficient Routing in Networks-on-Chip.txt,"Network-on-chip (NoC) architectures provide a scalable, high-performance, and
reliable interconnect for emerging manycore systems. The routing policies used
in NoCs have a significant impact on overall performance. Prior efforts have
proposed reinforcement learning (RL)-based adaptive routing policies to avoid
congestion and minimize latency in NoCs. The output quality of RL policies
depends on selecting a representative cost function and an effective update
mechanism. Unfortunately, existing RL policies for NoC routing fail to
represent path contention and regional congestion in the cost function.
Moreover, the experience of packet flows sharing the same route is not fully
incorporated into the RL update mechanism. In this paper, we present a novel
regional congestion-aware RL-based NoC routing policy called Q-RASP that is
capable of sharing experience from packets using the same routes. Q-RASP
improves average packet latency by up to 18.3% and reduces NoC energy
consumption by up to 6.7% with minimal area overheads compared to
state-of-the-art RL-based NoC routing implementations.","As manycore chips continue to integrate an increasing   number of cores, network onchip (NoC)  architectures have  emerged as the leading solution  to overcome data movement  bottlenecks by offering improved scalability,  performance ,  and reliability  during communication  [1]. Within NoCs,  routing policies play a key role in determining  the path that  packets take towards a destination.  Traditional  routing   policies range from  simple  deterministic policies such as  dimension order  XY routing  which always chooses the  same route  for packets between a  source and destination , to  more complex  adaptive congestion aware reinforcement  learning  (RL) based policies such as Qrouting  [2].   Typically, routing policies can be classified as oblivious  or adaptive based on how routing decisions are made .  Oblivious routing policies do not consider the current  network state  when selecting routing paths , e.g., XY  routing, random walk routing , etc. In contrast, a daptive  policies consider runtime knowledge, such as network  congestion information based on downstream router buffer  occupancy , when selecting a routing path . Typically,  adaptive routing can perform better than oblivious routing  when packet flows are non uniform, i.e.,  when  some nodes  are over represented in the communication traffic . In such  cases, a daptive routing can better distribute traffic in the  NoC  to avoid congestion .   While adaptive policies can greedily select the least  congested next hop, they lack information about congestion on the remaining path.  The problem can be solved by   communicating the global state of congestion in the NoC to  every router,  but such solutions  scale poorly and  incur  excessive communicat ion overhead.  Qrouting  [3]  represents an alternative solution whereby the routing  policy can form  a global estimate of congestion by  using  information only from neighboring nodes . A NoC router  is  associated with each nod e in the network . The router   maintains a table with congestion estimates  for different  destinations  in the form of Qvalues . Qrouting policies  have been shown to improve NoC performance compared  to other routing policies  [3] due to their ability to learn from  experience .   The performance of Q routing policies depends on their  1) cost function, and 2) update mechanism. The cost  function defines how congestion is inferred from the  network condition  to assess  the quality of a routing action ,  whereas the update mechanism defines a methodology to  use the experience of the routing agent  (cost and estimates  from neighbor nodes) to update the existing policy. In prior  Qrouting approaches, the cost can be slow to calculate, or  fail to represent congestion accurately. Further , update  mechanisms used in prior approaches fail to effectively  update the Q values, resulting in underperforming  Q routing policies.   We address these limitations  by designing an improved  Qlearning based NoC routing framework called QRASP  (QRouting for NoCs w ith Region Awareness and Shared  Path Experienc e). QRASP  defines  a path and region  aware cost  by prioritizing  path contention over latency  or  input contention  and augmenting it with a regional cost  comp onent . It also shares learning updates between packet   flows to different destinations  which share the same route.   Our work  makes  the following novel  contributions:   • We i dentify the shortcomings of existing NoC Q routing policie s in terms of cost function s and update  mechanisms.   • We develop a  new region aware path contention  based  NoC Qrouting cost function  for selecting  contention free paths in congestion free regions.   • We devise a new update mechanism to share learning  experience between packet fl ows with different  destinations  using the same routes .  The rest of this paper is organized as follows. Section II  presents a background o n Qlearning  and Q routing.  Section  III discusses  prior work . Section I V describes our Q routing  framework , QRASP . Section V presents experimental  results  followed by concluding remarks  in Section V I. II. BACKGROUND   Qrouting is a class of adaptive routing policies which  uses the learning framework of Q learning to solve the  routing problem in NoCs as a reinforcement learning (RL)  problem. We discuss  Qlearning  as well as Qrouting  for  NoCs (which uses Q learning) in the rest of this section.   A. Qlearning   Qlearning is a  model free learning algorithm for solving  RL problems.  It is model free because it does not require a  model of the environment to learn a policy. In RL, an agent  learns to maximize the return, or longterm reward , over a  sequence of actions in an environment. The ag ent has a  representation of the current environment state, 𝑠. At each  step 𝑡, the agent takes an action 𝑎t in state 𝑠𝑡. The action  transitions the agent state from 𝑠𝑡 to the next state, 𝑠𝑡+1. At  step 𝑡+1, the agent also receives  a scalar reward  for the  action 𝑎𝑡 which is used by a learning algorithm  like Q  learning  to update the current agent policy.   In Q learning, an agent uses the state value function  𝑄(𝑠𝑡, 𝑎𝑡) to estimate the expected return of an action 𝑎𝑡 in  state 𝑠𝑡. As each step 𝑡, the policy is updated using Eq. (1):  𝑄𝑛𝑒𝑤(𝑠𝑡, 𝑎𝑡)←(1−𝛼)⋅𝑄(𝑠𝑡, 𝑎𝑡)  +𝛼⋅(𝑟𝑡+ 𝛾⋅max 𝑎∈𝐴𝑄(𝑠𝑡+1,𝑎)) (1)  where  α is the learning rate, 𝑟𝑡 is the reward for action 𝑎𝑡 in  state 𝑠𝑡, 𝛾 is the discount factor, and max 𝑎∈𝐴𝑄(𝑠𝑡+1,𝑎) is the  expected return for choosing the best action at state 𝑠𝑡+1  from the set of all actions  𝐴. The learning rate specifies the  weight of new experience compared to  the existing estimate .  The reward  𝑟𝑡 is a scalar value representing the  consequence  of taking action 𝑎𝑡 at 𝑠𝑡. 𝛾 ∈ [0,1] is the  discount factor  that determines the importance of future  rewards . With a  discount factor  (𝛾) of 0, the agent will  consider only current rewards , represented by  𝑟𝑡  in Eq. (1) .  Conversely, as 𝛾 approaches 1,  the agent  will consider  future rewards equally.   The function 𝑄(𝑠,𝑎) is commonly represented using a  table called the Q table. The Q table stores the expected  return of each state action pair as Q values 𝑄 (𝑠𝑡, 𝑎𝑡). The  agent policy can simply be a greedy selection function to  maximize reward or minimize cost. For exampl e, an agent  policy may maximize  the cumulative reward  by taking  action 𝑎∗= max 𝑎∈𝐴𝑄(𝑠𝑡, 𝑎) at each step. In most  implementations, an 𝜀greedy policy is used where an agent  can query the table to either select the greedy action  𝑎∗ to  optimize return  or randomly select an action with a  probability 𝜀 to explore the environment for learning. In this  way, t he 𝜀greedy policy can explore alternative solutions  by selecting non optimal actions with some probability.  Given  sufficient update coverage of all  stateaction pairs,  the policy  eventually  converges to the optimal state action  policy.   B. Qrouting  in NoCs   Qrouting applies the RL framework to the problem of  routing in NoC s using Q learning . Typically, t he objective  is to learn a routing policy which can minimize packet  latency by adapting to the network condition online.   In Qrouting, the state, 𝑠 is defined as the location of the  packet being routed  (i.e., the local router ) and the packet’s destinatio n.  In the selection stage  of routing, the direction  of the output port selected at each hop is denoted as the  action, 𝑎. After the packet reaches the downstream router,  the downstream router transmits a learning packet back to  the local router with its o wn estimate of the remaining cost  until the packet reaches its destination. The  estimate of the  remaining cost and the immediate cost of selecting action 𝑎  (experience) is used to update the Q routing policy to  reinforce actions which reduce total packet latency from the  source to the destination. The Q values representing the Q  routing policy are updated using Eq (2):  𝑄𝑥(𝑑, 𝑦) ←(1−𝛼)⋅𝑄𝑥(𝑑,𝑦)+𝛼∙(𝑞𝑥+𝛾⋅𝑚𝑖𝑛 𝑧∈𝑍𝑄𝑦(𝑑,𝑧)) (2)  Eq. (2) represents the case where  router  𝑥 estimates the  latency to send a packet to node 𝑑 using the neighbor 𝑦 as  𝑄𝑥(𝑑, 𝑦). When router  𝑥 selects neighbor 𝑦 as the next hop,  node 𝑦 must send back its own estimate of minimum latency  for the packet’s remaining journey 𝑚𝑖𝑛 𝑧∈𝑍𝑄𝑦(𝑑,𝑧), where 𝑍 is  the set of all valid neighbours of 𝑦. Finally, router  𝑥 must  update the Q value 𝑄𝑥(𝑑, 𝑦) using the time the packet  spends in the router  𝑥’s local queue , 𝑞𝑥 and the estimate  from node 𝑦. The discount rate 𝛾 is used to adjust the weight   of the congestion estimate for the remaining path  in the  update . Similarly, the learning rate  𝛼 can be used to assign  weightage to new experiences.  Note that the cost 𝑞𝑥 is a Q  routing design choice and  can be redefined.  Furthermore ,  while Eq. (2) defines a single update per routing action, a Q routing update mechanism can specify multiple updates to  avoid stale Q values.   TABLE I. TABLE OF QVALUES  FOR DESTINATIONS 03 IN ROUTER  8 IN  8×8 NOC MESH NETWORK WITH MINIMAL ROUTE  QROUTING .  Destination ( 𝑑) Neighbors ( 𝑦) QValues ( 𝑄8(𝑑, 𝑦))  Node 0  Node 0  𝑄8(0,0)  Node 1  Node 0  Node 1  𝑄8(1,0) 𝑄8(1,1)  Node 2  Node 0  Node 1  𝑄8(2,0) 𝑄8(2,1)  Node 3  Node 0  Node 1  𝑄8(3,0) 𝑄8(3,1)  The Q routing policy is stored in a distributed manner  in  the form of tables inside routers. The table  in each router   stores Q values which represent the estimated latency to  each destination node for each output port available for   selection . Table I shows  an example of the table from Node  8’s router  in an 8×8 mesh NoC . When  Node 8 sends a packet  to Node 3 through neighbor Node 0, the Q value for the  routing action 𝑄8(3,0) will be updated using Eq. (2). Upon  receiving the packet from Node 8, Node 0 sends back its  own estimate for the packet’s remaining journey, i.e.,  𝑄0(3,1), assuming  it selects its neighbor Node 1 as the next  node . Next, t he weighted sum of the latency in Node 8 ’s  router  𝑞𝑥 and the  estimate 𝑄0(3,1) is used to update 𝑄8(3,0)  in the table  using Eq.  (2). At each hop t he router  follows the  minimum selection rule, i.e., it  selects the action with the  lowest Q value  to minimize total packet latency.   The tables  with Q values  and the minimum select ion  rule enable selecting  the path with the minimum expected  total latency  to every destination from every node  in the  network . By selecting the neighbor with the minimum  expected latency,  a Qrouting policy aims to min imize  the  total accumulated cost  of its routing actions . In this section,  the cost 𝑞𝑥 has been defined as the queue latency of the  packet in the local router. When defined as such, the Q  values in each router converge to the total latency (cost)   from the  current router to the destination. Since the Q values determine the routing policy, the choice of cost function is  central to the Q routing policy. The cost function is flexible  and can be redefined to even represent goals different than  minimizing latenc y, e.g.,  minimizing  transmission  power ,  controlling router temperature, etc.  As packets are rout ed  using Q routing , the path  with the least total cost  to each  destination is learned using experience from  packets going  to the same destination.   III. RELATED WORK","Qrouting is a class of adaptive routing policies which uses the learning framework of Q learning to solve the routing problem in network onchips (NoCs). It is a class of policies which uses the learning framework of Q learning to solve the routing problem in NoCs as a reinforcement learning (RL) problem. In this paper, we address the shortcomings of existing Q routing policies in terms of cost function, and update mechanism. QRASP (QRouting for NoCs w ith Region Awareness and Shared Path Experience) based on the cost function",cool!
4,On the Scalability of LISP Mappings Caches.txt,"The Locator/ID Separation Protocol (LISP) limits the growth of the
Default-Free Zone routing tables by creating a highly aggregatable and
quasi-static Internet core. However, LISP pushes the forwarding state to edge
routers whose timely operation relies on caching of location to identity
bindings. In this paper we develop an analytical model to study the asymptotic
scalability of the LISP cache. Under the assumptions that (i) long-term
popularity can be modeled as a constant Generalized Zipf distribution and (ii)
temporal locality is predominantly determined by long-term popularity, we find
that the scalability of the LISP cache is O(1) with respect to the amount of
prefixes (Internet growth) and users (growth of the LISP site). We validate the
model and discuss the accuracy of our assumptions using several one-day-long
packet traces.","The growth of the DefaultFree Zone (DFZ) routing tables [20] and associated churn observed in recent years has led to much debate as to whether the cur rent Internet infrastructure is architecturally unable to scale. Sources of the problem were found to be partly organic, generated by the ongoing growth of the topology, but also related to operational prac tices which seemed to be the main drivers behind prex deaggregation within the Internet's core. Di verging opinions as to how the latter could be solved triggered a signicant amount of research that nally materialized in several competing solutions (see [18] and the references therein). In this paper we focus on location/identity sepa ration type of approaches in general, and consider the Locator/ID Separation Protocol (LISP) [23] as their particular instantiation. LISP semantically de couples identity from location, currently overloaded by IP addresses, by creating two separate names paces that unambiguously address endhosts (identi ers) and their Internet attachment points (locators). This new indirection level has the advantage that itsupports the implementation of complex trac en gineering mechanisms but at the same time enables the locator space to remain quasistatic and highly aggregatable [13]. Although generally accepted that location/identity type of solutions alleviate the scalability limitations of the DFZ, they also push part of the forwarding complexity to the edge domains. On the one hand, they require mechanisms to register, distribute and retrieve bindings that link elements of the two new namespaces. On the other, LISP routers must store in use mappings to speedup packet forwarding and to avoid generating  oods of resolution requests. This then begs the question: does the newly introduced LISP edge cache scale? This paper provides an analytical answer by ana lyzing the scalability of the LISP cache with respect to the growth of the Internet and growth of the LISP site. To this end we leverage the workingset the ory [6] and previous results that characterize tem poral locality of reference strings [2, 15] to develop a model that relates the LISP cache size with the missrate. We nd that the relation between cache size and missrate only depends on the popularity 1arXiv:1504.03004v2  [cs.NI]  14 Apr 2015distribution of destination prexes. Additionally, for a given miss rate, as long as the popularity follows a GeneralizedZipf distribution, the LISP cache size scales constantly O(1) with respect to the growth of the Internet and the number users, if the last two do not in uence the popularity distribution. If this does not hold then the cache scales linearly O(N). To support our results, we also analyze the popularity distribution of destination prexes in several one day realworld packet traces, from two dierent networks and spanning a period of 3 :5 years. The rest of the paper is structured as follows. We provide a brief overview of LISP in Section 2. In Sec tion 3 we derive the cache model under a set of as sumptions and thereafter discuss its predictions and implications for LISP. In Section 4 we present em pirical evidence that supports our assumptions and evaluate the model, while in Section 5 we discuss the related work. Finally, we conclude the paper in Sec tion 6. 2 LISP Background LISP [23] belongs to the family of proposals that im plement a location/identity split in order to address the scalability concerns of the current Internet archi tecture. The protocol specication has recently un dergone IETF standardization [8], however develop ment and deployment eorts are still ongoing. They are supported by a sizable community spanning both academia and industry and rely for testing on a large experimental network, the LISPbeta network [1]. The goal of splitting location and identity is to in sulate core network routing that should ideally only be aware of location information (locators), from the dynamics of edge networks, which should be con cerned with the delivery of information based on iden tity (identiers). To facilitate the transition from the current infrastructure, LISP numbers both names paces using the existing IP addressing scheme, thus ensuring that routing within both core and stub net works stays unaltered. However, as locators and identiers bear relevance only within their respective namespaces, a form of conversion from one to the other must be performed. LISP makes use of encap Mapping  System xTRAxTRBRLOC A1RLOC A2 RLOC B1RLOC B2 EIDSRC EIDDST LISP  Legacy  Internet12 3 4Figure 1: Example packet exchange between EIDSRC andEIDDST with LISP. Following intra domain routing, packets reach xTRAwhich obtains a mapping binding EIDDSTtoRLOCB1andRLOCB2 from the mappingsystem (steps 13). From the map ping,xTRAchoosesRLOCB1as destination and then forwards towards it the encapsulated packets over the Internet's core (step 4). xTRBdecapsulates the packets and forwards them to their intended des tination. sulation [10] and a directory service to perform such translation. Prior to forwarding a host generated packet, a LISP router maps the destination address, or End point IDentier (EID), to a corresponding destina tion Routing LOCator (RLOC) by means of a LISP specic mapping system [25, 14]. Once a mapping is obtained, the border router tunnels the packet from source edge to corresponding destination edge net work by means of an encapsulation with a LISP UDPIP header. The outer IP header addresses are the RLOCs pertaining to the corresponding border routers (see Fig. 1). At the receiving router, the packet is decapsulated and forwarded to its intended destination. In LISP parlance, the source router, that performs the encapsulation, is called an Ingress Tun nel Router (ITR) whereas the one performing the decapsulation is named the Egress Tunnel Router (ETR). One that performs both functions is referred to as an xTR. Since the packet throughput of an ITR is highly de pendent on the time needed to obtain a mapping, but 2also to avoid overloading the mappingsystem, ITRs are provisioned with mapcaches that store recently used EIDprextoRLOC mappings. Stale entries are avoided with the help of timeouts, called time to live (TTL), that mappings carry as attributes. Whereas, consistency is ensured by proactive LISP mechanisms through which the xTR owner of an up dated mapping informs its peers of the change. Intu itively, the mapcache is most ecient in situations when destination EIDs present high temporal and/or spatial locality and its size depends on the diversity of the visited destinations. As a result, performance depends entirely on mapcache provisioned size, traf c characteristics and the eviction policy set in place. 3 Cache Model We start this section by discussing some of the fun damental properties of network trac that may be exploited to gain a better understanding of cache per formance. Then, assuming these properties are char acteristic to real network traces we devise a cache model. Finally we analyze and discuss the predic tions of the model. 3.1 Sources of Temporal Locality in Network Trac We consider the following formalization of trac, ei ther at Web page or packet level, throughout the rest of the paper. Let Dbe a set of objects (Web pages, destination IPprex, program page etc.). Then, we consider trac to be a strings of references r1;r2;:::;ri:::whereri=o2Dis a reference at theith unit of time that has as destination, or re quests, object o. Generally, we consider the length of the reference string to be N. Also, note that we use object and destination interchangeably. Two of the dening properties of reference strings, important in characterizing cache performance, are the heavy tailed popularity distribution of destina tions and the temporal locality exhibited by the re quests pattern. We discuss both in what follows.3.1.1 Popularity Distribution copious amounts of studies in elds varied as linguis tics [27, 21], Web trac [2, 19], videoondemand [3], p2p overlays [5] and  ow level trac [22] found the probability distribution of objects to have a positive skew. Generally, such distributions are coined Zipf like, i.e., they follow a power law; whereby the prob ability of reference is inversely proportional to the rank of an object. Generally, the relation is surmised as:(k) = kwhereis the frequency, or num ber of requests observed for an object, kis the rank,   = 1=H(n;) is a normalizing constant and H(n;) is thenthgeneralized harmonic number. It is interesting to note that although Zipf's law has its origins in linguistics, it was found to be a poor t for the statistical behavior of words frequencies with low or midtohigh values of the rank variable. That is, it does not t the head and tail of the distribu tion. Furthermore, it's extension due to Mandelbrot (often called the ZipfMandelbrot law) only improves the tting for the head of the distribution. Such dis crepancies were also observed for Web based and p2p reference strings. Often the head of the distribution is  attened, i.e., frequency is less than the one predicted by the law, or the tail has an exponential cuto or a faster power law decay [21, 5]. But these dierences are usually dismissed on the basis of poor statistics in the high ranks region corresponding to objects with a very low frequency. Nevertheless, Montemurro solved recently the problem in linguistics by extending the Zipf Mandelbrot law such that for high ranks the tail un dergoes a crossover to an exponential or larger ex ponent powerlaw decay. Surprisingly, he found this features, i.e. deviations from the Zipflike behavior, to hold especially well when very large corpora [21] are considered. We further refer to this model as the Generalized Zipf law or GZipf and, in light of these observations, we assume the following: Assumption 1. The popularity distribution of des tination IPprex reference strings can be approxi mated by a GZipf distribution. 33.1.2 Temporal locality can be informally dened as the property that a re cently referenced object has an increased probability of being rereferenced. One of the well established ways of measuring the degree of locality of reference strings is the interreference distance distribution. Breslau et al. found in [2] that strings gener ated according to the Independent Reference Model (IRM), that is, assuming that references are inde pendent and identically distributed random variables, from a popularity distribution have an interreference distribution similar to that of the original string. Ad ditionally, they inferred that the probability of an object being rereferenced after tunits of time is pro portional to 1 =t. Later, Jin and Bestavros proved that in fact temporal locality emerges from both long term popularity and shortterm correlations. How ever, they found that the interreference distance dis tribution is mainly induced through longterm popu larity and therefore is insensitive to the latter. Ad ditionally, they showed that by ignoring temporal correlations and assuming a Zipflike popularity dis tribution, an object's rereference probability after t units of time is proportional to 1 =t(2","The growth of the Internet infrastructure has led to much debate as to whether it is architecturally unable to scale. This has led to the development of several competing solutions, including the Locator/Identity Separation Protocol (LISP). In this paper we analyze the scalability of the LISP edge cache with respect to the growth of the Internet and the growth of the LISP site. We find that the cache size scales constantly O(1) with respect to the growth of the Internet and the number of users, if the popularity distribution follows a GeneralizedZipf distribution of destination pre-x",cool!
197,GROUPS-NET: Group Meetings Aware Routing in Multi-Hop D2D Networks.txt,"In the next generation cellular networks, device-to-device (D2D)
communication is already considered a fundamental feature. A problem of
multi-hop D2D networks is on how to define forwarding algorithms that achieve,
at the same time, high delivery ratio and low network overhead. In this paper
we aim to understand group meetings' properties by looking at their structure
and regularity with the final goal of applying such knowledge in the design of
a forwarding algorithm for D2D multi-hop networks. We introduce a forwarding
protocol, namely GROUPS-NET, which is aware of social group meetings and their
evolution over time. Our algorithm is parameter-calibration free and does not
require any knowledge about the social network structure of the system. In
particular, different from the state of the art algorithms, GROUPS-NET does not
need communities detection, which is a complex and expensive task. We validate
our algorithm using different publicly available data-sources. In real large
scale scenarios, our algorithm achieves approximately the same delivery ratio
of the state-of-art solution with up to 40% less network overhead.","In recent years, high data rate applications such as videos, songs, games, and social media have become increasingly popular in cellular networks. DevicetoDevice (D2D) com munication has been proposed to facilitate high data rate transmissions among near users offering higher throughput, efﬁcient spectral usage, extended network coverage and improved energy efﬁciency. D2D refers to the direct transmission of content between devices in close proximity, without need for all data to go through the base station. To enable direct D2D ad hoc links in the current cellular network architecture, the 3GPP con sortium proposed DevicetoDevice Proximity Service (D2D ProSe) [1]. D2D ProSe reuses LTE radio interface for direct transmission between devices, allowing the base station to participate and control D2D connection establishment and creation of routes between devices. Several studies in the context of 3GPPLTE [2] have shown D2D’s great poten tial for alleviating data trafﬁc demands. Nowadays, D2D spans way further, being considered not only as a 3GPP technology, but as one of the key enabling technologies in 5G cellular networks [3]. D2D modes can be classiﬁed into two basic types: 1 hop transmission , in which a message goes directly from the source to the destination if they are close enough to each other; and multihop transmission , where the message must be opportunistically routed, device by device, from the source to the destination. This last strategy is more complex, since it depends on the intermittent communication struc ture of a mobile network and is suited for communications that tolerate larger delivery times. This concept was ini tially introduced in the context of Delay Tolerant Networks Ivan O. Nunes, Clayson Celes, Pedro O. S. Vaz de Melo and Anto nio A. F. Loureiro are with the Department of Computer Science from the Federal University of Minas Gerais, Belo Horizonte, MG, 31270901. Email:fivanolive, claysonceles, olmo, loureiro g@dcc.ufmg.br(DTNs), but it has many applications to D2D networks as well [25]. A fundamental difference from D2D networks to pure DTNs is the possibility of a centralized control plane with a distributed data plan, as depicted in Figure 1. In this case, the base station controls the forwarding policy while the data is transmitted from devicetodevice until it reaches the destination [32]. Forwarding algorithms in multihop D2D networks aim to achieve costeffective delivery, i.e., the highest possible delivery ratio with the lowest possible network overhead. In this case, the delivery ratio is measured as the percentage of messages routed opportunistically that are successfully de livered to the destination. Successfully delivered messages are the ones that the base station will not need to deliver itself, enabling bandwidth ofﬂoad. The network overhead is measured by the average number of times that the content needs to be D2Dtransmitted for the message to reach its destination. A high number of transmissions may negatively impact the users’ experience by, for example, increasing the devices’ energy expenditure. Considering these metrics, the most successful strategy for opportunistic costeffective forwarding in D2D Net works, Bubble Rap [21, 25], relies on two aspects: informa tion about the nodes’ centrality and the static social commu nities they are part of. The ﬁrst element can be approximated by the node popularity within the mobile network. The latter, however, presents some signiﬁcant problems. First, communities are computationally expensive to identify [30]. Second, they are hard to detect in a distributed way, since individual nodes do not have information about the contact graph of the whole network. Existing distributed commu nity detection algorithms achieve at most 85% precision in the detected communities [22]. Another problem of com munity detection algorithms is the parameter calibration, which depends on the parameters to be adjusted for each given scenario [37]. In a realtime application, such as D2D communication, such calibration is not feasible. Moreover,arXiv:1605.07692v2  [cs.NI]  14 Aug 20172 Fig. 1. D2D hybrid architecture: centralized control and distributed data planes there is no established truth for community detection. In fact, Abrahao et al. [9] showed that, for the same scenarios, different community detection algorithms yield very dif ferent results for communities’ compositions. Finally, static communities detection does not account for the dynamism in humans’ social relationships, i.e., how they change over time. Given all these issues, in this work we go beyond and propose the use of social groups’ meetings instead of communities. A social group meeting is deﬁned as a group of people who are together, in space and time, for some social reason or common goal . For example, friends hanging out at a bar share the social motivation of being together to relax and talk to each other. Students in the classroom share the objective of learning the class’ subject content. People in a bus are together because they share the same goal of going to the same route. These are examples of social group meetings. As human beings have regular schedules and routines, it is reasonable to expect social group meetings to present some regularity as well. From the implementation point of view, different from communities, detecting a social group meeting in a dis tributed fashion is an easy task. A device can detect a group meeting of which it is part of by simply looking at the list of devices that remained nearby for more than a given time, for example, 10 min. Moreover, the group meeting detection method does not change depending on the scenario nor require parameters’ calibration for each speciﬁc network, as in community detection schemes. In addition to those desirable characteristics, by looking only at recent group meetings or by giving a higher importance to more recent meetings, it is possible to account for the dynamic nature of social relationships. All of these favorable characteristics motivated us to employ group meetings in the design of an opportunistic routing scheme that is better suited for D2D networks than the current socialaware proposals. Generally speaking, the main contribution of the present work is to introduce social group meetings and their regularity as a better metric for social context, specially for opportunistic D2D communication and ad hoc networks, in which community detection is a hard task . Speciﬁcally, the contributions of this work are fourfold: A methodology for detecting and tracking group meet ings from pairwise contact traces; A characterization and a model of group meetings, which can be used to predict future meetings using the informa tion about the most recent ones; An analysis of the stateoftheart synthetic mobility mod els, which allowed us to conclude that group meetings’ properties are not well captured by the synthetic traces generated from such models; An opportunistic forwarding algorithm for D2D net works, aware of group meetings, which does not need to detect communities nor calibrate parameters, and that achieves better costeffectiveness than the stateoftheart solution in real largescale scenarios. This paper is organized as follows. Section 2 presents the related work and discusses the corresponding contributions with respect to human mobility, costeffective opportunistic routing, and D2D communication. Section 3 formalizes our methodology to detect and track group meetings from pair wise contact traces. Section 4 describes the main properties of group meetings that make them interesting in the design of a new forwarding strategy. Section 5 introduces GROUPS NET, a group meetings aware routing protocol. Section 6 presents a comparison of real and synthetic mobility traces regarding the presence of group mobility. Section 7 eval uates GROUPSNET, contrasting its performance with the stateoftheart solution, Bubble Rap, in different network scales. Finally, Section 8 presents ﬁnal remarks and future work. 2 R ELATED WORK","Device-to-Device (D2D) communication has been proposed to facilitate high data rate transmissions among near users in cellular networks. In this paper, we propose a novel approach for opportunistic forwarding in D2D networks, based on the concept of Bubble Rap. Bubble Rap is a strategy for opportunistic forwarding in D2D networks, where the forwarding algorithm aims to achieve the highest possible delivery ratio with the lowest possible network overhead. In this case, the forwarding algorithm relies on two aspects: information about the nodes’",cool!
400,Self-Interpretable Time Series Prediction with Counterfactual Explanations.txt,"Interpretable time series prediction is crucial for safety-critical areas
such as healthcare and autonomous driving. Most existing methods focus on
interpreting predictions by assigning important scores to segments of time
series. In this paper, we take a different and more challenging route and aim
at developing a self-interpretable model, dubbed Counterfactual Time Series
(CounTS), which generates counterfactual and actionable explanations for time
series predictions. Specifically, we formalize the problem of time series
counterfactual explanations, establish associated evaluation protocols, and
propose a variational Bayesian deep learning model equipped with counterfactual
inference capability of time series abduction, action, and prediction. Compared
with state-of-the-art baselines, our self-interpretable model can generate
better counterfactual explanations while maintaining comparable prediction
accuracy.","Deep learning (DL) has become increasingly prevalent, and there is naturally a growing need for understanding DL pre dictions in many decisionmaking area, such as healthcare diagnosis and public policymaking. The highstake nature of these areas means that these DL predictions are con sidered trustworthy only when they can be well explained. Meanwhile, timeseries data has been frequently used in these areas (Zhao et al., 2021; Jin et al., 2022; Yang et al., 2022), but it is always challenging to explain a timeseries prediction due to the nature of temporal dependency and varying patterns over time. Moreover, timeseries data often comes with confounding variables that affect both the input 1Department of Computer Science, Rutgers University. Corre spondence to: Jingquan Yan <jy766@rutgers.edu >. Proceedings of the 40thInternational Conference on Machine Learning , Honolulu, Hawaii, USA. PMLR 202, 2023. Copyright 2023 by the author(s).and output, making it even harder to explain predictions from DL models. On the other hand, many existing explanation methods are based on assigning importance scores for different parts of the input to explain model predictions (Ribeiro et al., 2016; Lundberg & Lee, 2017b; Chen et al., 2018; Wang et al., 2019b; Weinberger et al., 2020; Plumb et al., 2020). However, understanding the contribution of different input parts are usually not sufficiently informative for decision making: people often want to know what changes made to the input could have lead to a specific (desirable) prediction (Wachter et al., 2017b; Goyal et al., 2019; Nemirovsky et al., 2022). We call such changed input that could have shifted the prediction to a specific target actionable counterfactual explanations . Below we provide an example in the context of time series. Example 1 (Actionable Counterfactual Explanation ). Suppose there is a model that takes as input a time se ries of breathing signal x∈RTfrom a subject of age u= 60 to predict the corresponding sleep stage as ypred= ‘Awake’ ∈ {‘Awake’ ,‘Light Sleep’ ,‘Deep Sleep’ }. Typical methods assign importance scores to each entry of xto explain the prediction. However, they do not provide action able counterfactual explanations on how to modify xtoxcf such that the prediction can change to ycf=‘Deep Sleep’ . An ideal method with such capability could provide more information on why the model make specific predictions. Actionable counterfactual explanations help people under stand how to achieve a counterfactual (target) output by modifying the current model input. However, such expla nations may not be sufficiently informative in practice, es pecially under the causal effect of confounding variables which are often immutable. Specifically, some variables can hardly be changed once its value has been determined, and suggesting changing such variables are both meaningless and infeasible (e.g., a patient age and gender when modeling medical time series). This leads to a stronger requirement: a good explanation should make as few changes as possible on immutable variables; we call such explanations feasible counterfactual explanations . Below we provide an example in the context of time series. Example 2 (Feasible Counterfactual Explanation ).In Ex ample 1, age uis a confounder that affects both xand 1arXiv:2306.06024v3  [cs.LG]  22 Jun 2023SelfInterpretable Time Series Prediction with Counterfactual Explanations ysince elderly people (i.e., larger u) are more likely to have irregular breathing xand more ‘Awake’ time (i.e., y=‘Awake’ ) at night. To generate a counterfactual ex planation to change ypredto‘Deep Sleep’ , typical methods tend to suggest decreasing the age ufrom 60to50, which isinfeasible (since age cannot be changed in practice). An ideal method would first infer the age uand search for a feasible counterfactual explanation xcfthat could change ypredto ‘Deep Sleep’ while keeping uunchanged. In this paper, we propose a selfinterpretable time se ries prediction model, dubbed Counterfactual Time Series (CounTS), which can both (1) perform time series predic tions and (2) provide actionable and feasible counterfactual explanations for its predictions. Under common causal struc ture assumptions, our method is guaranteed to identify the causal effect between the input and output in the presence of exogenous (confounding) variables, thereby improving the generated counterfactual explanations’ feasibility. Our contribution is summarized as follows: •We identify the actionability and feasibility require ments for generating counterfactual explanations for time series models and develop the first general self interpretable method, dubbed CounTS, that satisfies such requirements. •We provide theoretical guarantees that CounTS can identify the causal effect between the time series input and output in the presence of exogenous (confounding) variables, thereby improving feasibility in the gener ated explanations. •Experiments on both synthetic and realworld datasets show that compared to stateoftheart methods, CounTS significantly improves performance for gener ating counterfactual explanations while still maintain ing comparable prediction accuracy. 2. Related Work","Deep learning (DL) has become increasingly prevalent, and there is naturally a growing need for understanding DL predictions in many decisionmaking area, such as healthcare diagnosis and public policymaking. However, it is always challenging to explain a timeseries prediction due to the nature of temporal dependency and varying patterns over time. On the other hand, many existing explanation methods are based on assigning importance scores to different parts of the input to explain the prediction. However, they do not provide actionable counterfactual explanations on how to modify the current model input",cool!
309,SlotSwapper: A Schedule Randomization protocol for Real-Time WirelessHART Networks.txt,"Industrial process control systems are time-critical systems where reliable
communications between sensors and actuators need to be guaranteed within
strict deadlines to maintain safe operation of all the components of the
system. WirelessHART is the most widely adopted standard which serve as the
medium of communication in industrial setups due to its support for Time
Division Multiple Access (TDMA)based communication, multiple channels, channel
hopping, centralized architecture, redundant routes and avoidance of spatial
re-use of channels. However, the communication schedule in WirelessHART network
is decided by a centralized network manager at the time of network
initialization and the same communication schedule repeats every hyper-period.
Due to predictability in the time slots of the communication schedule, these
systems are vulnerable to timing attacks which eventually can disrupt the
safety of the system. In this work, we present a moving target defense
mechanism, the SlotSwapper, which uses schedule randomization techniques to
randomize the time slots over a hyper-period schedule, while still preserving
all the feasibility constraints of a real-time WirelessHART network and makes
the schedule uncertain every hyper-period. We tested the feasibility of the
generated schedules on random topologies with 100 simulated motes in Cooja
simulator. We use schedule entropy to measure the confidentiality of our
algorithm in terms of randomness in the time slots of the generated schedules.","Timecritical systems such as the industrial process con trol systems are realtime cyberphysical systems (CPS) that monitor and control the production lines in a manufacturing plant. The number of devices in such setup keeps increas ing. To support more devices and to cope up with frequent changes in the network topology due to addition (removal) of devices to (from) the network, a switch of the commu nication infrastructure from wired networks to wireless net works is desirable. Among the existing wireless sensor net work (WSN) standards, WirelessHART is best suited for the industrial process control systems due to its reliable TDMA based schedule, centralized architecture, multichannel sup port, channel hopping, redundancy in routes, and avoidance of spatial reuse of channels. ©2019 Copyright held by authors. RTN'19, July 2019, Stuttgart, GermanyAlthough the use of wireless brings  exibility and adapt ability to the communication infrastructure, it increases the threats of cyber attacks. Some recent sophisticated attacks against critical infrastructures such as Stuxnet [1] and Drag on y [2] have alerted us to the shaky protection of the conventional air gap solution. The main components of a WirelessHART network are the sensors, actuators, Gate way, a network manager, and multiple access points (AP). Each communication between these devices are realtime  ows with xed periods and deadlines. To make the  ows schedulable, the schedule in a WirelessHART network is pre determined by the centralized network manager at the time of network initialization. The same schedule is repeated over every hyperperiod ( i.e., lowest common multiple of the pe riods of all the  ows in the network), until there is any change in the network topology, such as addition/removal of new/existing devices to/from the network. The repeti tive execution of the deterministic  ow schedule in a Wire lessHART network over every hyperperiod makes these sys tems vulnerable to timing attacks. Such repetition greatly helps the attacker to analyze the eavesdropped traces and infer the schedule. With the inferred schedule, the attacker can further launch various strategic destructive attack steps. For instance, the attacker can selectively jam the transmis sions from/to a certain critical sensor/actuator which can eventually breach the safety of the system. In this work, we aim at reducing the predictability of the time slots in the communication schedule of a realtime WirelessHART network. We propose a moving target de fense (MTD) mechanism, the SlotSwapper , that random izes the time slots in the communication schedule over ev ery hyperperiod, satisfying all the feasibility constraints of a realtime WirelessHART network as follows| (1) dead lines of all realtime  ows in the network are to be satised, (2) the hop sequences associated with each  ow are to be preserved and (3) no con icting transmissions in the net work are allowed. From our analysis, the attacker who can monitor the wireless transmissions needs at least two hyper periods to infer the schedule. Randomizing the schedule over every hyperperiod renders the attacker's inference futile, thereby greatly improving the condentiality of the Wire lessHART network's operations. More varied are the slots in a schedule, more dicult it is for the attacker to predict them. Hence, the measure of uncertainty in the time slots of a schedule can be expressed in terms of the amount of randomness in the time slots over the hyperperiod sched ules generated by our algorithm. We redened schedule en tropy [3] as a metric to measure the uncertainty in predicting the time slots. We illustrated the feasibility of our proposed algorithm on random topologies with 100 simulated nodes in Contiki Cooja [4]. To the best of our knowledge, thisarXiv:1910.12000v1  [cs.NI]  26 Oct 2019is the rst work on randomization to reduce the determin ism of the time slots of a hyperperiod schedule in realtime WirelessHART networks. 2. RELATED WORK","In this work, we propose a novel mechanism for reducing the predictability of the time slots in a real-time WirelessHART network. The SlotSwapper is a moving target defense (MTD) mechanism that randomizes the time slots over every hyperperiod, satisfying all the feasibility constraints of a real-time WirelessHART network. The SlotSwapper is a novel mechanism that randomizes the time slots over every hyperperiod, satisfying all the feasibility constraints of a real-time WirelessHART network. The SlotSwa new mechanism is",cool!
289,A probabilistic approach to reduce the route establishment overhead in AODV algorithm for manet.txt,"Mobile Ad-hoc Networks (MANETS) is a collection of wireless nodes without any
infrastructure support. The nodes in MANET can act as either router or source
and the control of the network is distributed among nodes. The nodes in MANETS
are highly mobile and it maintains dynamic interconnection between those mobile
nodes. MANTEs have been considered as isolated stand-alone network. This can
turn the dream of networking ""at any time and at any where"" into reality. The
main purpose of this paper is to study the issues in route discovery process in
AODV protocol for MANET. Flooding of route request message imposes major
concern in route establishment. This paper suggests a new approach to reduce
the routing overhead during the route discovery phase. By considering the
previous behaviour of the network, the new protocol reduces the unwanted
searches during route establishment process","Data dissemination is the key application domain ta rgeted by MANET. Reliable routing is  important and critical in those applications. A maj or challenge that lies in MANET  communication is the unlimited mobility and more fr equent failures due to link breakage.  Conventional routing algorithms are therefore insuf ficient for adhoc networks. Several  researchers have done the qualitative and quantitat ive analysis of ad hoc routing protocols by  means of different performance metrics [ 5,6,8 ].  Researcher Community has broadly classified  the routing protocols into two categories [  2 ]. T hese are Proactive (Table Driven) routing  protocols and Reactive (On Demand) routing protocol s. The proactive protocol is the extension  of the protocols in wired network. In this case, a routing table is established in each node  contains the information of the routes to every oth er node in the network and this information is  updated periodically. Always the upto date informa tion is available with each node and it is  independent of the requirement. However, the period ic propagation of routing information  increases the network overhead.  A reactive protoco l on the other hand finds the route only on  demand. Performance analysis shows that reactive pr otocol outer perform proactive protocol in  terms of throughput, PDR and routing overhead [6, 8  ]. So the research has mainly concentrated  on reactive protocols. International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.2, March 2012  208        There are so many reactive protocols have been dev eloped about the last decade. Adhoc On demand Distance Vector (AODV) protocol [  2 ] is on e of the important on demand routing  protocol in MANET. In AODV the route is discovered only when it needs to send some data.  This on demand characteristics is the major advanta ge of AODV. Improvements of AODV have  been a major attraction in the research work [12,18   ].  The main purpose of the present study is  to exploit the route establishment in AODV.  Source  node initiates the route discovery process  by sending route request control packet. The paper also highlights the significance of network  overhead during the route discovery process and the n tries to propose an idea for reducing the  overhead. The proposed technique ensures the floodi ng of the minimum number of route  request message in the network.  The rest of this paper is organized as follows. Sec tion 2 gives how the route discovery process is  done using AODV. Section 3 describes issues of floo ding the route request messages in the  network. Related works are explained in section 4. A new approach to reduce the flooding  overhead is discussed in section 5 and a conclusion  is given in section 6.  2.  AN OUTLINE TO ROUTE ESTABLISHMENT IN AODV  Reactive routing protocol eliminates the routing ov erhead during the periodic information  interchange in the proactive routing protocol.    I n reactive or on demand protocols the upto  date routing table is not retained.  It will discov er the route only when it is having the data to  send. So this reduces the routing overhead.  In rea ctive protocol, the first step of data  dissemination is to find the route. This increases the time delay to establish the route. In order to  get the advantages of both table driven and on dem and routing protocols, one can combine the  approaches to form a hybrid protocol. Various proto cols have been developed under these  categories over the years.[14]. While AODV, DSR, TO RA are the examples of on demand  routing protocols and ZRP offers a hybrid protocol.  The present paper studies the AODV  algorithm and examines the overhead during the rout e establishment phase. Lots of researches  have been reported for the diminution of the unwant ed load in the network [3, 4].  The objective  of this paper is the study of AODV considering the multiple connections and the overhead  required to establish the connections through rerou te discovery.  The proposed work aims to  improve the AODV with the reduction of route discov ery overhead.  The basic principle of AODV [2] revolves around the  Distance Vector algorithm. In addition to  the distance vector algorithm, AODV uses a sequence  number to distinguish the route request  packet form the old one.  This is the extension of DSDV protocol which is table driven.  Alternately, the ADOV algorithm minimizes the netwo rk broadcast by creating routes on an on  demand basis.   AODV is classified as pure on deman d routing protocol.   Mainly there are two important phases in the AODV i mplementation viz. route discovery phase  and route maintenance phase [1]. In this paper we l imit our interest to route discovery phase. To  begin with a source node which wants to establish a  route, floods the route request message  RREQ in the network. Each RREQ packet is associated  with a sequence number in order to  avoid the duplication. A packet with the new sequen ce number is only accepted by a receiving  node.  Any RREQ packet with the same sequence numbe r when received is discarded. If a node  has information about the destination then it gives  the reply to the source. Otherwise it will send  this packet to its neighbours and thus the same req uest message floods in the network. If there is  no reply from any node after a certain interval of time it again tries to connect the route by  sending RREQ packet. When a node receives RREQ pack et it records the information about its  neighbour so as to establish a reverse path. When R REQ packet reaches the destination, it sends  a reply message RREP to the sender through the reve rse path. Then the source establishes a  forward path to the destination. The propagation of  route request packet RREQ stops at the  destination. The destination node generates the rou te reply packet RREP and sends to the source  node in the reverse direction of the discovered rou te. This is accomplished by maintaining a International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.2, March 2012  209       route request table at each node that keeps the inf ormation about their neighbours that generate  the route request message. When a node receives a r oute reply message, then it checks its route  request table and forward the message to the neighb ours from which the route request message  was received. After establishing the route, the dat a can be transmitted between source and  destination.   During the data transmission, if any link failures revealed the node facing the breakage informs  the incident to its neighbours. This message floods  in the network and finally reaches to the  source node. In this case route establishment proce ss repeats from the beginning. The link  failure can be detected by means of HELLO packet, b etween two nodes. The failure of  receiving HELLO packet indicates that the neighbour  has moved away. The nodes in MANET  are highly mobile so link breakage and link establi shment are very frequent. In order to cope up  with this problem, each route is associated with a timer. For establishing a better path after a  certain interval of time the existing route is dele ted and the route establishment process is  repeated.  3.  OVERHEAD DURING ROUTE DISCOVERY PROCESS   One advantage of AODV over other proactive routing protocols like DSDV is the reduction of  overhead due to frequent exchange of routing table.  AODV minimize this overhead by means of  its on demand characteristics. Whenever a data to b e send then the route establishment process  is carried out. Otherwise no exchange of informatio n between neighbors. Route discovery  process starts at source node and ends at the desti nation node. In AODV flooding is the most  suitable strategy for route discovery because of it s ever changing topology. Even if the routing  overhead is reduced flooding generates huge number of messages. In route discovery phase  source node generate the route request control mess age RREQ and send this to its neighbors.  Each node floods the same message over the network,  every time it wants to find the  destination. Some of the nodes, though just floods the message, but often   do not even get the  destination. This poses serious challenge in AODV r oute discovery. Because this unnecessary  and unproductive messages, the valuable and limited  resources like node energy, bandwidth and  battery power of each node are wasted. The problem is more serious with networks of larger  sizes.     Figure1. A typical network showing the flooding ove rhead; though there are only three paths  from S to D, the flooding is wide spread.   International Journal of Distributed and Parallel S ystems (IJDPS) Vol.3, No.2, March 2012  210       The Fig. 1 shows a typical mobile network with larg e number of nodes. S denotes source node  and D denotes destination node. Initially connectio n establishment algorithm is started at S by  creating RREQ message. S sends this control message  to N1, N4 and N7. In initial phase there  is no information of destination at each node is av ailable so it again forwards this packet to N2,  N13 and N8. But N4 and N7 forward the same packet t o N13. One message is redundant for  N13. Channel contention is the result of those redu ndant messages. This also increases the level  of congestion and collision in the network.   The route discovery process is initiated when S det ect any link breaks. If any node is move  away from the network then the neighboring nodes de tect this link failure and create a route  error message. This control message is forwarded to  its neighbors and finally reaches at the  source node. When node S receives the route error m essage then it initiates route discovery  process for D. Each time flooding creates extra ove rhead and the cost of the network become  high. An efficient route searching strategy that mi nimizes the overhead due to excessive  flooding is highly desirable. The key design object ive of the proposed route searching scheme is  to generate the route, with the use of minimum amou nt of network resources.   4.  RELATED WORK",The Ad hoc On Demand Distance Vector (AODV) protocol is one of the important on demand routing protocols in MANET. The proactive routing protocol is the extension of the protocols in wired network. The proactive routing protocol is maintained in each node and the information of the routes to every other node is updated periodically. The reactive routing protocol finds the route only when it needs to send some data. The reactive protocol eliminates the periodic propagation of routing information. The reactive protocol finds the route only when it needs to send some data. The performance analysis shows that the performance of the routing protocol outper,cool!
359,Eco-Routing based on a Data Driven Fuel Consumption Model.txt,"A nonparametric fuel consumption model is developed and used for eco-routing
algorithm development in this paper. Six months of driving information from the
city of Ann Arbor is collected from 2,000 vehicles. The road grade information
from more than 1,100 km of road network is modeled and the software Autonomie
is used to calculate fuel consumption for all trips on the road network. Four
different routing strategies including shortest distance, shortest time,
eco-routing, and travel-time-constrained eco-routing are compared. The results
show that eco-routing can reduce fuel consumption, but may increase travel
time. A travel-time-constrained eco-routing algorithm is developed to keep most
the fuel saving benefit while incurring very little increase in travel time.","Ground  transportation consumes  26.5% of the world   energy in 2016 [1]. In 2014, 3.1 billion gallons of wasted  fuel and 6.9 billion hours of extra time are caused by  congestion [2]. Vehicle trip planning and routing  based  on traffic information and predicted fuel consumption  can sav e fuel and travel time, the potential of which has  not been deeply explored .  Intelligent transportation techniques  have  demonstrated  promising results in reduc ing fuel  consumption [3, 4]. An early  study  of eco routing  using  average speed based fuel consumption model was  conducted, showing 25% fuel saving  compared with a  shortest time routing strategy [5]. To understand  network wide benefit, the user equilibrium and system  optimal b ehavior were  analyzed [6] and t he authors  concluded that  the potential  of fuel saving  is 9.3%. Other  factors such as signalized intersections  [7] and  penetration rate [8] were also studied .   A core piece for eco routing  algorithm  development  is a robust fuel consumption model. Microscopic fuel  consumption model s have been  studied extensively [9],  but for eco routing, fuel consumption for large number   of road sections  is needed , thus fast computation is also  needed . Macroscopic models [10] have  also been studied  to estimate fuel consumption without considering  heterogeneity in driving, resulting in same fuel  consumption for same average speed, thus not  appropriate for eco routing.  Mesoscopic models that use  road link average speed and grade are widely used for  ecorouting.  By considering link based variables, they  can address driving heterogeneity, thus  are more accurate  than macroscopic models. However, most of the existing  mesoscopic models for eco routing  are achieved with  parametric regression based models or power balance  models, [11] and many are not accurate enough due to  complexity of traffic scenario and nonlinearity of vehicle  powertrains.  Parametric methods like support vector  machine s (SVM) and neural network s (NN) were  also studied [12]. Recently, a nonparametric mod el called  multivariate adaptive regression spline (MARS) was  studied  [13]. MARS partition s the feature space into  hypercubes  with boundaries perpendicular to the axes  of  the feature space , thus a rotation of the coordinate axes  can completely change the structure of the MARS model.   The main idea of ou r method is that the fuel  consumption model should (i) use credible physics  driven simulation model (like Autonomie  [9] that we  choose), (ii) the driving speed should be from real vehicle  data which reflects the real world operating condition of  the road links, and (iii) instead of fitting individual trips,  the model should aim to fit the expected value from man y  trips.  We use the G aussian Mixture Regression (GMR) Fig. 1 Sample path for shortest route, fastest route, eco  route, and constrained eco route with routing cost  estimated from posted speed limit   to build our model [14]. The GMR model s the joint  density of model input and output, then derive s the  conditional expectation of the output from joint density  function  of the inputs  and output , thus the model is  invariant under any coordinate system. After  the fuel  consumpt ion model is developed, we use it to evaluate  the expected fuel consumption of different routing  strategies including shortest distance, shortest time, eco  routing, and travel timeconstrained eco routing. The  main contributions of this paper include: 1) a   nonparametric data driven fuel consumption model based  on real world driving data and Autonomie fuel  consumption simulation; 2) a constrained eco routing  strategy addressing tradeoff between travel time and fuel  consumption; and 3) studying the  fuel consu mption and  travel time  trade off of different routing strategies.   The rest of the paper is organized as follows. The  data used, the Autonomie model used , the Gaussian  Mixture Regression model ( GMR ) and the constrained  ecorouting method are presented in Section 2. Section 3  presents results and discussion. Conclusions and future  work are given in Section 4.     2 METHODOLOGY","Eco routing is a promising technique for reducing fuel consumption. However, the fuel consumption model for eco routing is not robust enough to address heterogeneity in driving. Several mesoscopic models have been studied, but they are not accurate enough due to complexity of traffic scenario and nonlinearity of vehicle powertrains. In this paper, we propose a non-parametric fuel consumption model based on real world driving data and Autonomie fuel consumption simulation. We use the Gaussian Mixture Regression (GMR) model to evaluate the fuel consumption of different routing strategies. We then develop a",cool!
62,Re-route Package Pickup and Delivery Planning with Random Demands.txt,"Recently, a higher competition in logistics business introduces new
challenges to the vehicle routing problem (VRP). Re-route planning, also known
as dynamic VRP, is one of the important challenges. The re-route planning has
to be performed when new customers request for deliveries while the delivery
vehicles, i.e., trucks, are serving other customers. While the re-route
planning has been studied in the literature, most of the existing works do not
consider different uncertainties. Therefore, in this paper, we propose two
systems, i.e., (i) an offline package pickup and delivery planning with
stochastic demands (PDPSD) and (ii) a re-route package pickup and delivery
planning with stochastic demands (Re-route PDPSD). Accordingly, we formulate
the PDPSD system as a two-stage stochastic optimization. We then extend the
PDPSD system to the Re-route PDPSD system with a re-route algorithm.
Furthermore, we evaluate performance of the proposed systems by using the
dataset from Solomon Benchmark suite and a real data from a Singapore logistics
1company. The results show that the PDPSD system can achieve the lower cost
than that of the baseline model. In addition, the Re-route PDPSD system can
help the supplier efficiently and successfully to serve more customers while
the trucks are already on the road.","In Singapore, the ecommerce industry is predicted to grow more than ﬁve times and reach S$7.5 billion by 2026 [1]. The ecommerce introduces complicated logistics requirement s for package pickup and delivery. The vehicle routing problem (VRP) was ﬁrst proposed in 1959 [2] to help a shipper effectively plan its delivery. Many researchers have exten ded the traditional VRP in many aspects. One of the signiﬁcant aspects is stochastic VRP, which can be referred to as VRP with one or more random parameters. The random parameters are common in a real situation in which shippers and supplier s do not have complete information about the delivery demand and other parameters a priori. Moreover, the planning by the shipper has to be dynamic as the customers can request for package pickup and delivery anytime. This is known as re route planning issue in which the shipper must adjust and re optimize truck utilization dynamically. Note that the plan ning becomes more challenging when the available trucks of the shipper cannot support all the requests, and the delivery ha s to be outsourced to a thirdparty carrier to minimize the customers’ dissatisfaction. In this paper, we consider the reroute planning of the shipper. In the scenario under consideration, the pickup an d delivery requests from customers are generated dynamicall y,e.g., throughout the day. The shipper ﬁrst decides whether to accept or reject the requests given available trucks. If t he request is accepted, the shipper has to decide how to utilize and reroute the trucks that might be already serving other c us tomers to accommodate the new request. On the other hand, if the request is rejected, the shipper will outsource the pack age pickup and/or delivery to a thirdparty carrier which typic ally incurs a higher cost. To achieve an efﬁcient solution for the shipper, we propose a reroute package pickup and delivery planning with stochastic demand (Reroute PDPSD) system. The Reroute PDPSD system aims to help the shipper to (i) plan trucks’ routing given that customers’ package sizes ar e random, (ii) decide whether to accept or reject new customer s while the trucks are serving the other customers, and (iii) r e plan the trucks’ routing when the new customer requests are accepted. The main objective is to minimize the total delive ry cost. In this regard, we ﬁrst present the ofﬂine package pick up and delivery optimization with stochastic demand (PDPSD) system formulated as a twostage stochastic optimization. The optimization can be solved as a linear programming. In the ﬁrst stage, trucks are reserved in advance while the routes o f trucks are decided in the second stage. Secondly, the Rerou te PDPSD system is presented as an extension of the PDPSD system. In this case, a reoptimization algorithm is develo ped and included in the Reroute PDPSD system. To this end, we perform performance evaluation of the Reroute PDOSD system by using dataset from both Solomon benchmark suite and a real dataset obtained from Singapore logistics compan y. Compared with the ofﬂine version, the Reroute PDOSD system enables the shipper to serve more customers with a lower total delivery cost. II. R ELATED WORK","In this paper, we consider the dynamic reroute planning of a shipper. The dynamic reroute planning is a problem in which the shipper must adjust and re optimize truck utilization dynamically. In this regard, we propose a reroute package pickup and delivery planning with stochastic demand (Reroute PDPSD) system. The Reroute PDPSD system aims to help the shipper to (i) plan trucks’ routing given that customers’ package sizes ar e random, (ii) decide whether to accommodate the new requests, and (iiiiii",cool!
246,QoS Provisioning Using Hybrid FSO RF Based Hierarchical Model for Wireless Multimedia Sensor Networks.txt,"Our objective is to provide guaranteed packet delivery service in time
constrained sensor networks. The wireless network is a highly variable
environment, where available link bandwidth may vary with network load. Since
multimedia applications require higher bandwidth so we use FSO links for their
transmission. The main advantage of FSO links is that they offer higher
bandwidth and security, while RF links offer more reliability. The routing in
this multitier network is based on directional geographic routing protocol, in
which sensors route their data via multihop paths, to a powerful base station,
through a cluster head. Some modifications have also been incorporated in the
MAC layer to improve the QoS of such systems.","RECENT advancement in field of sensor networks show that  there has been increased interest in the development  multimedia sensor network which consists of sensor nodes  that can communicate via free space optics (FSO) or RF. A  wireless multimedia sensor network typically consists of two  types of sensor nodes. One of these acts as data sensing nodes  with sensors like acoustic sensors or seismic sensors etc. The  other nodes are the video sensor nodes which capture videos  of event of interest.      Multimedia contents, especially video streams, require  transmission bandwidth that is orders of magnitude higher  than that supported by current offtheshelf sensors. Hence,  high data rate and lowpower, consumptiontransmission  techniques must be leveraged. In this respect, free space optics  seems particularly promising for multimedia applications.  FSO refers to the transmission of modulated visible or infrared  (IR) beams through the atmosphere to obtain broadband  communications over distances of several kilometers. The  main limitation of FSO is the requirement that a direct line of sight path exist between a sender and a receiver. However  FSO networks offer several unique advantages over RF  networks. These include the fact that FSO avoids interference  with existing RF communications infrastructure [1], is cheaply  deployed since there is no government licensing of scarce  spectrum required, is not susceptible to “jamming” attacks, and provides a convenient bridge between the sensor network  and the nearest optical fiber. In addition, “well designed” FSO  systems are eye safe, consumes less power and yields smaller  sized nodes because a simple baseband analog and digital  circuitry is required, in contrast to RF communication. More  importantly, FSO networks enable high bandwidth burst  traffic which makes it possible to support multimedia sensor  networks [1 ].    Class  Application  Bandwidth  (b/s) Delay  bound  (ms)  Loss  Rate   Nonreal  time  variable bit  rate Digital  Video  1M – 10M  Large  106  Available  Bit Rate  Web  Browsing  1M  10M  Large  108  Unspecified  Bit Rate  File Transfer  1M  10M  Large  108  Constant Bit  Rate  Voice  32 k – 2M 3060 102  Real time  Variable Bit  Rate  Video  Conference  128k  6M 4090 103  Table 1 Typical QoS requirements for several service classes    II. R ELATED WORK","Multimedia sensor networks are based on sensor nodes that can communicate via free space optics (FSO) or RF. In this paper, we propose a novel protocol for multimedia sensor networks based on free space optics (FSO) or RF. The proposed protocol is based on the theory of free space optics (FSO) and consists of a set of algorithms for determining the quality of service (QoS) for a given class of service. The proposed protocol is based on the theory of free space optics (RF) and a simple baseband analog",cool!
314,Secure Routing Protocol To Mitigate Attacks By Using Blockchain Technology In Manet.txt,"MANET is a collection of mobile nodes that communicate through wireless
networks as they move from one point to another. MANET is an
infrastructure-less network with a changeable topology; as a result, it is very
susceptible to attacks. MANET attack prevention represents a serious
difficulty. Malicious network nodes are the source of network-based attacks. In
a MANET, attacks can take various forms, and each one alters the network's
operation in its unique way. In general, attacks can be separated into two
categories: those that target the data traffic on a network and those that
target the control traffic. This article explains the many sorts of assaults,
their impact on MANET, and the MANET-based defence measures that are currently
in place. The suggested SRA that employs blockchain technology (SRABC) protects
MANET from attacks and authenticates nodes. The secure routing algorithm (SRA)
proposed by blockchain technology safeguards control and data flow against
threats. This is achieved by generating a Hash Function for every transaction.
We will begin by discussing the security of the MANET. This article's second
section explores the role of blockchain in MANET security. In the third
section, the SRA is described in connection with blockchain. In the fourth
phase, PDR and Throughput are utilised to conduct an SRA review using
Blockchain employing PDR and Throughput. The results suggest that the proposed
technique enhances MANET security while concurrently decreasing delay. The
performance of the proposed technique is analysed and compared to the routing
protocols Q-AODV and DSR.","MANET is a wireless network [1] without a central administration. MANET's simplicity makes it  popular. In a MANET, nodes communicate using radio frequency. MANET's open design is  vulnerable  [1]. The attacker may target the network while data or packets are transferred or by  monitoring netw ork activity. Attacks might target data or control. After network control  information is delivered, MANET sends data in packets. Attacks are any activity or threat that  compromises a network's security. Critical MANET security. Open media prohibits end toend  linkages. Security is maintained via many techniques. Key based protocols and IDS authenticate  Plan.  SRA and Blockc hain are protected by Secure Routing Protocol. Blockchain ensures data International Journal of Computer Networks & Communications (IJCNC) Vol.15, No.2, March 2023   128 record security and validity without a third party. Blocks store d ata in a blockchain. When full,  blocks are sealed and added to the chain.     Blockchain allows decentralis ed trust and security. New blocks are added sequentially. They're  added to blockchain's  ""end."" Once a block is added to the blockchain, changing its con tents  requires a majority vote. Each block has a hash, the previous block's hash, and the date. Hash  codes convert digital data to numbers and letters. Data changes the hash code.     A cryptographic hash function is a mathematical operation  [3]. Standard has h functions accept  variable length inputs and produce fixed length [2] outputs (hashes). Cryptographic hash  functions combine message passing and security [3]. Traditional hash functions are secured by  cryptographic hash functions  [3], which makes it more difficult to decipher message content or  recipient information. Given the network's vulnerability, assaults are classed as follows. SRA  with blockchain enables network security by producing hash codes for each transaction and  authenticating each node for d ata and control packets.     Early research focused only on secure data transmission routing mechanisms, even though attacks  might occur in any MANET security layer. Most MANET security approaches require network  nodes to perform a disproportionate amount of work based on constantly updated topology  control. This wastes resources and puts users at risk of hacker assaults. Without verification,  nodes distrust each other. Attacks that swiftly enter and change residential nodes can harm  network performance. This paper presents a blockchain based, management secure, QoS enhanced MANET .     By combining a hash function and blockchain technology to authenticate nodes that join the  network, SRA with blockchain maintains the network's security. Smart network nodes keep t rack  of the surrounding node's characteristics and if it makes a substantial contribution. The decision is  made using the delay criterion. The suggested algorithm offers pr ecise data for decision making  and maintain network security, the node is removed fr om the network based on its delay factor.      2. RELATED WORK","This paper presents a blockchain-based, management secure, QoS enhanced MANET. This network is a wireless network with nodes that communicate using radio frequency. It is a wireless network with nodes that communicate using radio frequency. The network's open design makes it vulnerable to attacks. Attacks might target data or control. This paper presents a blockchain-based, management secure, QoS enhanced MANET. This network is a wireless network with nodes that communicate using radio frequency. This paper presents a blockchain-based, a hash function that authenticates each node for data",cool!
132,Randomized Algorithm for the Maximum-Profit Routing Problem.txt,"In this paper, we consider the Maximum-Profit Routing Problem (MPRP),
introduced in \cite{Armaselu-PETRA}. In MPRP, the goal is to route the given
fleet of vehicles to pickup goods from specified sites in such a way as to
maximize the profit, i.e., total quantity collected minus travelling costs.
Although deterministic approximation algorithms are known for the problem,
currently there is no randomized algorithm. In this paper, we propose the first
randomized algorithm for MPRP.","Consider the following problem, introduced in [1]: Let Sbe a set of npoints in the plane, called sites. Each site Sihas an operating time window of [ si,ei], for some integers 0 ≤si≤ei≤T,T >0, and supplies a quantity qiof a certain unitpriced product that needs to be collected. Consider a ﬂ eet ofmsharing the same depot Dand having an equal capacity Q. The goal is to maximize the proﬁt, which is the total quantity collected minus the to tal travel costs. Here, the travel cost from a site Sito another site Sjis given by the euclidean distance d(i,j),∀i,j= 1,...,n. Vehicles are assumed to travel at constant unit speed, implying that travel times are equal to travel co sts. We call this problem the Maximum Proﬁt pickup Routing Problem (MPRP). Results on MPRP may have signiﬁcant impact on various applic ations, such as prize collecting, public transportation, forproﬁ t waste management and pickup, etc. 1MPRP is a generalization of the strongly NPhard Travelling Salesman Problem (TSP), making MPRP, MPRPM, and MPRPMVS also stron gly NPhard by extension. In this paper, we propose a randomized algorithm for MPRP, wh ich works under certain assumptions about the problem input paramete rs such as time windows and spatial distribution of the input sites around t he depot. 1.1 Related work","Maximum Profit Pickup Routing Problem (MPRP) is a generalization of the strongly NPhard Travelling Salesman Problem (TSP), making MPRP, MPRPM, and MPRPMVS also strongly NPhard by extension. In this paper, we propose a randomized algorithm for MPRP, which works under certain assumptions about the problem input parameters such as time windows and spatial distribution of the input sites around the depot. The algorithm is based on the principle of a random walk, which is a randomized algorithm for the optimally a randomized algorithm is a randomized",cool!
221,Analysis and Design of VANET Protocols for Srinagar City.txt,"Vehicular ad-hoc network (VANET) is subclass of mobile ad-hoc network which
is vehicle to vehicle and vehicle to infrastructure communication environment,
where nodes involve themselves as servers and/or clients to exchange and share
information. VANET have some unique characteristics like high dynamic topology,
frequent disconnections, restricted topology etc, so it need special class of
routing protocol. To simulate the VANET scenarios we require two types of
simulators, traffic simulator for generating traffic and network simulator. In
this project I created a sample scenario of VANET for AODV, DSDV, DSR routing
protocols. I have used SUMO for generating traffic mobility files and NS-3 for
testing performance of routing protocols on the mobility files created using
Traffic simulator SUMO.","1. VANET  ……………………………………………...  1   2. NS3 ……………………………………………........  3   3. Protocols  ……………………………………………  3    2. Literature Survey  6   1. SUMO: contributors and participants …………………..  6   2. NS3 and VANET protocols …………………………….  9    3. Theory  22   1. Unicast, Multicast and Broadcast ………………………  22   2. Proactive, Reactive and Hybrid protocols ………………  23   3. Categorization of next hop selection ……………………  24   4. Types of Routing protocols ……………………………..  27    4. Methodology  45",SUMO is a research group that aims to study the role of next-hop selection in routing protocols. SUMO is a research group that focuses on the role of next-hop selection in routing protocols. SUMO is a research group that aims to study the role of next-hop selection in routing protocols.,cool!
65,A new approach in position-based routing protocol using learning automata for vanets in city scenario.txt,"One of the main issues in Vehicular Ad-hoc NETworks (VANETs) is providing a
reliable and efficient routing in urban scenarios with regard to the high
vehicle mobility and presence of radio obstacle. In this paper, we propose a
Position-Based routing protocol using Learning Automata (PBLA). In addition,
PBLA uses the traffic information for enhancing learning. As we know, a main
characteristic of learning is increasing performance over time. We exploit this
characteristic to decreasing use of traffic information. Initially, PBLA make
effort to finding best and shortest path to mobile destination using traffic
information.","Vehicular Adhoc Networks (VANETs) is a subclass of  Mobile Adhoc Networks (MANETs);  Vehicles on the roads use wireless technology to co mmunicate each other without any pre deployed infrastructure. More recently, various app lications have appeared in the VANETs. The  applications have been classified into two categori es: 1. safety applications, which allow the  passengers or drivers to share contents such as roa d obstacles, traffic flows and accidents that  have occurred, 2. entertainment applications, which  allow vehicles to share multimedia or local  information such as MP3 music, videos, sale adverti sement or virtual tours of hotel rooms [12].  One of the main issues in VANETs is providing a rel iable and efficient routing in urban  scenarios with regard to the challenges (i.e., high  vehicle mobility and presence of radio obstacle)  [13].  Generally, the ad hoc network routing protocols are  divided in three category: unicast, multicast  and broadcast. Unicasts are divided in two parts: t opologybased and positionbased. Topology based routing protocols use links information that exist in the network to perform packet  forwarding. However, in positionbased routing prot ocols, each node needs only know its  neighbors' positions. After using proposed unicast protocols of MANETs in VANETs, it is  obvious that these protocols do not work properly i n VANETs and they are weak. In addition,  most of the protocols that exist in MANETs are topo logybased and their major problem is the  instability of routes that are caused by link break ages. In topologybased protocols, link  breakages occur repeatedly, consequently, the packe t loss rate and the overhead of routing  increase. Therefore, between topologybased and pos itionbased routing protocols, the last one is  more efficient for data delivery in high mobility c onditions, such VANETs. International Journal of Ambient Systems and Applic ations (IJASA) Vol.1, No.2, June 2013  46   In positionbased routing, each node is aware of th e positions of its direct neighbors by  periodically sending out beacon messages that indic ate the current position of the node. In  addition, with the aim of sending a packet to a des tination node, the sender requires information  on the current geographic position of the destinati on node. This information is gained via a so called location service [5].  In This paper, a positionbased routing protocol in  urban scenario is proposed that uses the  learning algorithm [11] for decreasing the communic ation overhead and the number of hops.  Furthermore, this protocol uses the traffic informa tion for enhancing learning. This Improving  learning reduces the communication overhead that is  generated by the traffic information.  In order to gain traffic information, we investigat ed the movement patterns of the vehicles in the  streets in different times of the day and generated  several databases for traffic density in different   times and areas. For instance, the traffic density is low in rural areas and during night hours but  very high in the urban area and during rush hours o f the day. Then routing decision with high  reliability will be made efficiently.   The rest of this paper is organized as follows: Sec tion 2 describes related work in the field of  unicast routing in VANETs. Section 3 reviews the le arning automata. Section 4 describes the  proposed positionbased routing protocol. Simulatio n results are shown in Section 5. Finally,  section 6 concludes the paper and gives directions for future works.  2.  RELATED WORK","Vehicular Ad hoc Networks (VANETs) are a subclass of Mobile Ad hoc Networks (MANETs). In this paper, we propose a position-based routing protocol in urban scenario that uses the learning algorithm for decreasing the communication overhead and the number of hops. Furthermore, this protocol uses the traffic information for enhancing learning. The proposed protocol uses the traffic information to improve routing decision with high reliability. The proposed protocol is based on the learning algorithm and the traffic information. The proposed protocol is based routing protocol is designed for high mobility scenarios.",cool!
323,Modelling and Verifying the AODV Routing Protocol.txt,"This paper presents a formal specification of the Ad hoc On-Demand Distance
Vector (AODV) routing protocol using AWN (Algebra for Wireless Networks), a
recent process algebra which has been tailored for the modelling of Mobile Ad
Hoc Networks and Wireless Mesh Network protocols. Our formalisation models the
exact details of the core functionality of AODV, such as route discovery, route
maintenance and error handling. We demonstrate how AWN can be used to reason
about critical protocol properties by providing detailed proofs of loop freedom
and route correctness.","Routing protocols are crucial to the dissemination of data packets between nodes in Wireless Mesh Networks (WMNs) and Mobile Ad Hoc Networks (MANETs). One of the most popular protocols that is widely used in WMNs is the Ad hoc OnDemand Distance Vec tor (AODV) routing protocol [39]. It is one of the four NICTA is funded by the Australian Government through the Department of Communications and the Australian Research Council through the ICT Centre of Excellence Program. R.J. van Glabbeek NICTA and UNSW. Email: rvg@cs.stanford.edu P. H¨ ofner NICTA and UNSW. Email: Peter.Hoefner@nicta.com.au M. Portmann TheUniversityofQueensland.Email:marius@itee.uq.edu .au W.L. Tan Griﬃth University. Email: w.tan@griﬃth.edu.auprotocols standardised by the IETF MANET working group, and it also forms the basis of new WMN routing protocols, including the Hybrid Wireless Mesh Proto col (HWMP) in the IEEE 802.11s wireless mesh net work standard [27]. The details of the AODV protocol are standardised in IETF RFC 3561 [39]. However, due to the use of English prose, this speciﬁcation contains ambiguities and contradictions. This can lead to signif icantly diﬀerent implementations of the AODV routing protocol, depending on the developer’s understanding and reading of the AODV RFC. In the worst case sce nario, an AODV implementation may contain serious ﬂaws, such as routing loops [20]. Traditional approaches to the analysis of AODV and many other AODVbased protocols [41,27,46,50, 43]aresimulationandtestbedexperiments.Whilesuch methods are important and valid for protocol evalua tion, in particular for quantitative performance evalua tion, they have limitations in regards to the evaluation of basic protocol correctness properties. Experimental evaluation is resource intensive and time consuming, and, even after a very long time of evaluation, only a ﬁnite set of network scenarios can be considered—no general guarantee can be given about correct protocol behaviourforawiderangeofunpredictabledeployment scenarios [2]. This problem is illustrated by recent dis coveriesoflimitationsinAODVlikeprotocolsthathave been under intense scrutiny over many years [35]. We believe that formal methods can help in this re gard; they complement simulation and testbed experi ments as methods for protocol evaluation and veriﬁca tion, and provide stronger and more general assurances about protocol properties and behaviour. The overall goal is to reduce the “timetomarket” for better (new or modiﬁed) WMN protocols, and to increase the relia bility and performance of the corresponding networks.2 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan In this paper we provide a complete and accurate formal speciﬁcation of the core functionality of AODV usingthespeciﬁcationlanguageAWN(AlgebraofWire less Networks) [15]. AWN provides the right level of abstraction to model key features such as unicast and broadcast, while abstracting from implementationrela teddetails.Asitssemanticsiscompletelyunambiguous, specifying a protocol in such a framework enforces to tal precision and the removal of any ambiguities. A key contribution is to demonstrate how AWN can be used to support reasoning about protocol behaviour and to provide rigorous proofs of key protocol properties, us ing the examples ofloop freedom and route correctness. In contrast to what can be achieved by model checking and testbed experiments, our proofs apply to all con ceivable dynamic network topologies. Route correctness is a minimal sanity requirement for a routing protocol; it is the property that the rout ing table entries stored at a node are entirely based on information on routes to other nodes that either is currently valid or was valid at some point in the past. Loop freedom is a critical property for any routing pro tocol, but it is particularly relevant and challenging for WMNs. Descriptions as in [17] capture the common un derstanding of loop freedom: “ A routingtable loop is a path speciﬁed in the nodes’ routing tables at a particu lar point in time that visits the same node more than once before reaching the intended destination. ” Packets caughtin aroutingloop,until they arediscardedbythe IP TimeToLive (TTL) mechanism, can quickly satu ratethelinksandhaveadetrimentalimpactonnetwork performance. It is therefore critical to ensure that pro tocols prevent routing loops. We show that loop free dom can be guaranteed only if sequence numbers are used in a careful way, considering further rules and as sumptions on the behaviour of the protocol. The prob lem is, as shown in the case of AODV, that these addi tional rules and assumptions arenot explicitly stated in the RFC, and that the RFC has signiﬁcant ambiguities in regards to this. To the best of our knowledge we are the ﬁrst to give a complete and detailed proof of loop freedom.1 2 The rigorous protocol analysis discussed in this pa per has the potential to save a signiﬁcant amount of 1Loop freedom of AODV has been “proven” at least thrice [42,3,55], but the proofs in [42] and [3] are not cor rect, and the one in [55] is based on a simple subset of AODV only, not including the “intermediate route reply” feature —a most likely source of loops. We elaborate on this in Section 7 . 2In this paper, we abstract from timing issues by postulat ing that routing table entries never expire. Consequently, we can make no claim on routing loops resulting from premature expiration of routing tables entries. This will be the subje ct of a forthcoming paper [8].time in the development and evaluation of new network protocols, can provide increased levels of assurance of protocol correctness, and complements simulation and other experimental protocol evaluation approaches. The remainder of this paper is organised as follows. Section 2 gives an informal introduction to AODV. We brieﬂy recapitulate AWN in Section 3. Section 5 pro videsadetailedformalspeciﬁcationofAODVinAWN.3 To achieve this, we present the basic data structure needed in Section 4. In Section 6 we formally prove some properties of AODV that can be expressed as in variants, in particular loop freedom and route correct ness.4Section 7describes relatedwork,and in Section 8 we summariseourﬁndings and point at workthat is yet to be done. 2 The AODV Routing Protocol TheAdhocOnDemandDistanceVector(AODV)rout ing protocol [39] is a widelyused routing protocol de signed for MANETs, and is one of the four protocols currently standardised by the IETF MANET working group5. It also forms the basis of new WMN routing protocols,including the Hybrid WirelessMesh Protocol (HWMP) in the IEEE 802.11s wireless mesh network standard [27]. AODV is a reactive protocol: routes are established only on demand. A route from a source node sto a des tination node dis a sequence of nodes [ s,n1,...,n k,d], wheren1,...,nkare intermediate nodes located on the path from stod. Its basic operation can best be explained using a simple example topology shown in Figure 1(a), where edges connect nodes within trans mission range. We assume node swants to send a data packet to node d, butsdoes not have a valid rout ing table entry for d. Nodesinitiates a route discovery mechanism by broadcasting a route request (RREQ) message, which is received by s’s immediate neighbours aandb. We assume that neither anorbknows a route to the destination node d.6Therefore, they simply re broadcast the message, as shown in Figure 1(b). Each RREQ message has a unique identiﬁer which allows nodes to ignore duplicate RREQ messages that they have handled before. 3Parts of the speciﬁcation have been published before in “A Process Algebra for Wireless Mesh Networks” [15], in “Automated Analysis of AODV using UPPAAL” [14] and in “A Rigorous Analysis of AODV and its Variants” [26]. 4A sketch of the loop freedom proof is given in [15] and in [26]. 5http://datatracker.ietf.org/wg/manet/charter/ 6In case an intermediate node knows a route to d, it di rectly sends a route reply back.Modelling and Verifying the AODV Routing Protocol 3 (a)d bsa (b)RREQRREQRREQd bsa RREQ RREQ RR EQRR EQRR EQ RREQRREQRREQ (c)d bsa RR EP RREP Fig. 1Example network topology When forwarding the RREQ message, each inter mediate node updates its routing table and adds a “re verse route” entry to s, indicating via which next hop the node scan be reached, and the distance in number of hops. Once the ﬁrst RREQ message is received by the destination node d(we assume via a),dalso adds a reverse route entry in its routing table, saying that nodescan be reached via node a, at a distance of 2 hops. Nodedthen responds by generating a route reply (RREP) message and sending it back to node s, as shown in Figure 1(c). In contrast to the RREQ mes sage, the RREP is unicast, i.e., it is sent to an individ ual next hop node only. The RREP is sent from dto a, and then to s, using the reverse routing table entries created during the forwarding of the RREQ message. When processing the RREP message, a node creates a “forward route” entry into its routing table. For exam ple, upon receiving the RREP via a, nodescreates an entry saying that dcan be reached via a, at a distance of 2 hops. At the completion of the route discoverypro cess, a route has been established from stod, and data packets can start to ﬂow. In the event of link and route breaks, AODV uses route error (RERR) messages to inform aﬀected nodes. Sequence numbers, another important aspect of AODV, indicate the freshness of routing information. AODV “ uses destination sequence numbers to ensure loop freedom at all times (even in the face of anomalous delivery of routing control messages), ... ” [39]. A proof of loop freedom of AODV has been sketched in [42]. Nodes maintain their own sequence number as well as a destination sequence number for each route discov ered. This use of sequence numbers can be an eﬃcientapproach to address the problem of routing loops, but hasto be taken with caution, since loop freedomcannot be guaranteed a priori [20]. 3 The Speciﬁcation Language AWN Ideally, any speciﬁcation is free of ambiguities and con tradictions. Using English prose only, this is nearly im possible to achieve. Hence every speciﬁcation should be equipped with a formal speciﬁcation. The choice of an appropriate speciﬁcation language is often sec ondary, although it has high impact on the analysis. The use of anyformal speciﬁcation language helps to avoidambiguitiesandtopreciselydescribetheintended behaviour. Examples of modelling languages are (i) the Alloy language, used by Zave to model Chord [54]; (ii) timed automata, which are the input language for the Uppaal model checkerand used by Chiyangwa,Kwiat kowska [9] and others [14] to reason about AODV; (iii) routing algebra as introduced by Griﬃn and Sobrinho [23], or (iv) AWN, a process algebra particularly tai lored for (wireless mesh) routing protocols [15,26]. For this paper we choose the modelling language AWN: on the one hand it is tailored for wireless proto cols and therefore oﬀers primitives such as broadcast ; on the other hand, it deﬁnes the protocol in a pseudo code that is easily readable. (The language itself is im plementation independent). AWN is a variant of stan dard processalgebras[34,25,1,4], extended with a local broadcast mechanism and a novel conditional unicast operator—allowing error handling in response to failed communications while abstracting from link layer im plementations of the communication handling—and in corporating data structures with assignments. It also describes the interaction between nodes in a network withadynamicnetworktopology.Processalgebrassuch as AWN are equipped with an operational semantics [15,16]: once a model has been described, its behaviour is governed by the transitions allowed by the algebra’s semantics. This can signiﬁcantly reduce the burden of proofs.Inthis paperweabstainfromaformaldeﬁnition ofthe operationalsemantics.7Instead,weemployacor respondence between the transitions of AWN processes and the execution of actions—subexpressions as occur in Entries 3–10 of Table 1—identiﬁed by line numbers in protocol speciﬁcations in AWN. 7Thereby we also abstain from explaining the modelling of the dynamic network topology in the semantics, i.e., the mechanism by which links between nodes break. This matter is explained in [15,16], and completely orthogonal to the fo r mal speciﬁcation of the AODV protocol and the correctness properties that are the focus of this paper. In particular, t he correctness properties hold independently of the number of link breaks or link occurrences.4 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Table 1 process expressions X(exp1,...,expn)process name with arguments p+q choice between proc. pandq [ϕ]p conditional process [[var:=exp]]p assignment followed by process p broadcast (ms).p broadcast msfollowed by p groupcast (dests,ms).piterative unicast or multicast to all destinations dests unicast (dest,ms).p◮qunicast mstodest; if successful proceed with p; otherwise with q send(ms).p synchronously transmit msto parallel process on same node deliver(data).p deliver data to application layer receive(msg).p receive a message ξ,p process with valuation P/an}bracke⊔le{⊔/an}bracke⊔le{⊔Q parallel procs. on the same node a:P:R nodearunning Pwith range R N/bardblM parallel composition of nodes [N] encapsulation We use an underlying data structure (described in detail inSection 4) with severaltypes, variablesranging over these types, operators and predicates. First order predicate logic yields terms (or data expressions ) and formulas to denote data values and statements about them. The AWN data structure always contains the typesDATA,MSG,IPandP(IP) ofapplication layer data,messages ,IP addresses —or any other node iden tiﬁers—and sets of IP addresses . The messages com prisedata packets , containing application layer data, andcontrol messages . The rest of the data structure is customisable for any application of AWN. In AWN, a WMN is modelled as an encapsulated parallel composition of network nodes. On each node several processes may be running in parallel. Network nodescommunicatewiththeirdirectneighbours—those nodes that are currently in transmission range—using either broadcast, unicast, or an iterative unicast/multi cast(herecalled groupcast ).Theprocess expressions are given in Table 1. A process name Xcomes with a deﬁn ing equation X(var1,...,varn)def=p, wherepis a process expression, and the variare data variables maintained by process X. A named process is like a procedure ; when it is called, data expressions expiof the appropriate type are ﬁlled in for the vari ablesvari. Furthermore, ϕis a condition, var:=expan assignment of a data expression expto a variable var of the same type, dest,dests,dataandmsdata expres sions of types IP,P(IP),DATAandMSG, respectively, andmsga data variable of type MSG. Given a valuation of the data variables by concrete data values, the process [ϕ]pacts aspifϕevaluates totrue, and deadlocks if ϕevaluates to false.8In case ϕcontains free variables that are not yet interpreted as data values, values are assigned to these variables in any way that satisﬁes ϕ, if possible. The process [[var:=exp]]pacts asp, but under an updated valu ation of the data variables. The process p+qmay act eitheras porasq,depending onwhichofthetwoisable to act at all. In a context where both are able to act, it is not speciﬁed how the choice is made. The process broadcast (ms).pbroadcasts (the data value bound to the expression) msto the other network nodes within range, and subsequently acts as p, whereas the process unicast(dest,ms).p◮qtries to unicast the message msto the destination dest; if successful it continues to act aspand otherwise as q.9The latter models an ab straction of an acknowledgmentofreceipt mechanism that is typical for unicast communication but absent in broadcast communication, as implemented by the link layer of wireless standards such as IEEE 802.11. The processgroupcast (dests,ms).ptries to transmit ms to all destinations dests, and proceeds as pregardless of whether any of the transmissions is successful. The processsend(ms).psynchronously transmits a message to another process running on the same network node; this action can occur only when the other process is abletoreceivethemessage.Theprocess receive(msg).p receives any message m(a data value of type MSG) ei ther from another node, from another process running on the same node or from the application layer pro cess on the local node. It then proceeds as p, but with the data variable msgbound to the value m. In partic ular,receive(newpkt(data,dip)) models the injection of a data from the application layer, where the func tionnewpktgenerates a message containing the appli cation layer dataand the intended destination address dip. Data is delivered to the application layer by de liver(data). A (state of a) valuated process Pis given as a pair (ξ,p) of an expression pbuilt from the above syntax, togetherwith a(partial) valuation function ξthat spec iﬁes values of the data variables maintained by p. Fi nally,P/an}bracke⊔le{⊔/an}bracke⊔le{⊔Qdenotes a parallel composition of processes PandQ, with information piped from right to left; in our application Qwill be a message queue. In the full process algebra [15], node expressions a:P:Rare given by process expressions P, annotated with anaddressaand a set of nodes Rthat are within 8As operators we also allow partialfunctions with the con vention that any atomic formula containing an undeﬁnedsub term evaluates to false. 9The unicast is unsuccessful if the destination destis out of transmission range of the node ipperforming the unicast, i.e., if in the dynamic network topology there is currently n o link between ipanddest.Modelling and Verifying the AODV Routing Protocol 5 transmission range ofa. A partialnetworkis then mod elled as a parallel composition of node expressions, us ing the operator /bardbl, and a complete network is obtained by placing this composition in the scope of an encapsu lation operator[ ]. The main purpose of the encapsula tion operator is to prevent the receipt of messages that have never been sent by other nodes in the network— with the exception of messages newpkt(data,dip) stem ming from the application layer of a node. More details on the language AWN can be found in [16]. To illustrate the use of AWN we consider a network of two nodes on which the same processis running. One node broadcasts an integer value. A received broadcast message will be delivered to the application layer if its value is 1. Otherwise the node decrements its value and broadcasts the new value. The behaviour of each node can be modelled by: X(n)def=broadcast (n).Y() Y()def=receive(m).([m=1]deliver(m).Y(). + [m/ne}a⊔ionslash=1]X(m−1)) If a node is in a state X(n) it will broadcast nand con tinue in state Y(). If a node is in state Y(), and it re ceivesm, it has two ways to continue. Process [ m=1] deliver(m).Y() is enabled if m=1. In that case mwill be delivered to the application layer, and the process returns to Y(). Alternatively, if m/ne}a⊔ionslash=1, the process con tinues as X(m−1). Note that calls to processes use ex pressions as parameters, in this case m−1. Let us have a look at two network topologies. First, assume that the nodes aandbare within transmis sion range of each other; node ain state X(2), and nodebinY(). In AWN this is formally expressed as [a:X(2):{b}/bardblb:Y():{a}], although below we simply write X(2)/bardblY(). Then, node abroadcasts 2 and continues as Y(). Node breceives 2, and continues as X(1). Next b broadcasts1,andcontinuesas Y(),whilenode areceives 1, and, since the condition m=1 is satisﬁed, delivers 1 and continues as Y(). This gives rise to transitions from one state to the other: X(2)/bardblY()a:broadcast (2)− −−−−−−−−− → Y()/bardblX(1)b:broadcast (1)−−−−−−−−−→ a:deliver (1)−−−−−−−→ Y()/bardblY(). In stateY()/bardblY() no further activity is possible; the net work has reached a deadlock. Second, assume that the nodes are not within trans mission range; formally [ a:X(2):∅/bardblb:Y():∅]. Again ais in stateX(2), andbinY(). As before, node abroadcasts 2 and continues as Y(); but this time the message is not received by any node; hence no message is forwarded or delivered and both nodes end up in state Y(). For the last scenario, we assume that aandbare within transmission range and that both nodes havethe same initial state X(1). Assuming that no packet collisions occur, and node asends ﬁrst: X(1)/bardblX(1)a:broadcast (1)− −−−−−−−−− → Y()/bardblX(1)b:broadcast (1)−−−−−−−−− → a:deliver (1)−−−−−−−→ Y()/bardblY(). Unfortunately, node bis in a state where it cannot receive a message, so a’s message “remains unheard” andbwill never deliver that message. To avoid this be haviour, and ensure that both messages get delivered, as happens in real WMNs, a message queue can be in troduced (see Section 5.6). 4 Data Structure for AODV In this section we present the data structure needed for the detailed formal speciﬁcation of AODV. As well as describing typesfor the information handled at the nodes during the execution of the protocol we also de ﬁne functions which will be used to describe the pre ciseintention—andoveralleﬀect—ofthevariousupdate mechanisms in an AODV implementation. The deﬁni tions are grouped roughly according to the various “as pects” of AODV and the host network. Many of the presented type and function deﬁnitions are straightforward; so in principle this section can be skipped or be used as reference material. 4.1 Mandatory Types As stated in the previous section, the data structure always consists of application layer data, messages, IP addresses and sets of IP addresses. (a) The ultimate purpose of AODV is to deliver ap plication layer data . The type DATAdescribes a set of application layer data items. An item of data is thus a particular element of that set, denoted by the variable data∈DATA. (b)Messages are used to send information via the net work.In ourspeciﬁcation weuse the variable msgof the type MSG. We distinguish AODV control mes sages (route request, route reply, and route error) as well as data packets : messages for sending appli cation layer data (see Section 4.8). (c) The type IPdescribes a set of IP addresses or, moregenerally,a set of node identiﬁers . In the RFC 3561[39], IPisdeﬁnedastheset ofallIPaddresses. We assume that each node has a unique identiﬁer ip∈IP.Moreover,inourmodel,eachnode ipmain tains avariable ipwhichalwayshasthe value ip. In any AODV control message, the variable sipholds6 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan the IP address of the sender, and if the message is part of the route discovery process —a route re quest or route reply message—we use oipanddip for the origin and destination of the route sought. Furthermore, ripdenotes an unreachable destina tion (a destination to which a route was established earlier, but this route is now broken) and nhipthe next hop on some route. 4.2 Sequence Numbers As explained in Section 2, any node maintains its own sequence number —the value of the variable sn—and a routing table whose entries describe routes to other nodes. The value of snincreases over time. In AODV each routing table entry is equipped with a sequence number to constitute a measure approximating the rel ative freshness of the information held—a smaller num ber denotes older information. All sequence numbers of routes to dip∈IPstored in routing tables are ulti mately derived from dip’s own sequence number at the time such a route was discovered. We denote the set of sequence numbers by SQNand assume it to be totally ordered. By default we take SQN to be IN, and use standard functions such as max. The initial sequence number of any node is 1. We reserve a special element 0 ∈SQNto be used for the sequence number of a route, whose semantics is that no sequence number for that route is known. Sequence numbers are incremented by the function inc:SQN→SQN inc(sn) =/braceleftbiggsn+1 ifsn/ne}a⊔ionslash= 0 snotherwise . The variables osn,dsnandrsnof typeSQNare used to denote the sequence numbers of routes leading to the nodesoip,dipandrip. AODV tags sequence numbers of routes as “known” or “unknown”. This indicates whether the value of the sequencenumbercanbetrusted.Thesequencenumber status ﬂagis setto unknown ( unk)when aroutingtable entry is updated with information that is not equipped with a sequence number itself. In such a case the old sequence number of the entry is maintained; hence the valueunkdoesnotindicatethatnosequencenumberfor the entry is known. Here we use the set K={kno,unk} for the possible values of the sequencenumberstatus ﬂag; we use the variable dskto range over type K. 4.3 Modelling Routes In a network, pairs( ip0,ipk)∈IP×IPof nodes are con sidered to be “connected”if ip0can send to ipkdirectly,i.e.,ip0is in transmission range of ipkand vice versa. We say that such nodes are connected by a single hop. Whenip0is not connected to ipkthen messages from ip0directed to ipkneed to be “routed” through inter mediate nodes. We say that a route(fromip0toipk) is made up of a sequence [ ip0,ip1,ip2,...,ipk−1,ipk], where (ipi,ipi+1),i= 0,...,k−1, are connected pairs; thelengthorhop count of the route is the number of single hops, and any node ipineeds only to know the “next hop” address ipi+1in order to be able to route messages intended for the ﬁnal destination ipk. In operation, information about routes to certain destinations is stored in routing tables maintained at each node. This information sometimes needs to be re evaluated in regard to its validity. Routes may become invalidif one of the pairs ( ipi,ipi+1) in the hoptohop sequence gets disconnected. Then AODV may be rein voked, as the need arises, to discover alternative routes. In addition to the next hop and hop count, AODV also “tags” a route with its validity, sequence number and sequencenumber status. Information about invalid routes is preserved until fresh information is received that establishes a valid replacement route. The pur pose of this is to compare the sequence number and hop count of the replacement route with that of the invalid one, to check that the information is indeed fresher (or equally fresh while the replacement route is shorter). For every route, a node moreover stores a list ofprecursors , modelled as a set of IPaddresses. This set collects all nodes which are currently poten tial users of the route, and are located one hop further “upstream”. When the interest of other nodes emerges, these nodes are added to the precursor list;10the main purpose of recording this information is to inform those nodes when the route becomes invalid. In summary, following the RFC, a routing table en try (or entry for short) is given by 7 components: (a) The destination IP address—an element of IP; (b) The destination sequence number—an element of SQN; (c) The sequencenumberstatus ﬂag—an element of the setK={kno,unk}; (d) A ﬂag tagging the route as being valid or invalid— an element of the set F={val,inv}. We use the variableflagto range over type F; (e) The hop count, which is an element of IN. The vari ablehopsranges over the type IN and we make use of the standard function +1; (f) The next hop, which is again an element of IP; and 10The RFC does not mention a situation where nodes are dropped from the list, which seems curious.Modelling and Verifying the AODV Routing Protocol 7 (g) A precursor list, which is modelled as an element ofP(IP).11The variable preranges over P(IP). We denote the type of routing table entries by R, and use the variable r. A tuple (dip,dsn,dsk,ﬂag,hops,nhip,pre) describes a route to dipof length hopsand validity ﬂag; the very next node on this route is nhip; the last time the entry was updated the destination sequence num ber wasdsn;dskdenotes whether the sequence number is “outdated” or can be used to reason about fresh ness of the route. Finally, preis a set of all neighbours who are “interested” in the route to dip. A node being “interested” in the route is somewhat sketchily deﬁned as one which has previously used the current node to route messages to dip. Interested nodes are recorded in casetherouteto dipshouldeverbecomeinvalid,sothat they maysubsequently be informed. We useprojections π1,...π7to select the corresponding component from the 7tuple: For example, π6:R→IPdetermines the next hop. 4.4 Routing Tables Nodes store all their information about routes in their routing tables ; a node ip’s routing table consists of a set of routing table entries, exactly one for each known destination. Thus, a routing table is deﬁned as a set of entries, with the restriction that each has a diﬀerent destination dip, i.e., the ﬁrst component of each entry in a routing table is unique.12Formally, we deﬁne the typeRTof routing tables by RT:={rt∈P(R)| ∀r,s∈rt:r/ne}a⊔ionslash=s⇒π1(r)/ne}a⊔ionslash=π1(s)}. AODV chooses between alternative routes if necessary to ensure that only one route per destination ends up in a given node’s routing table. In our model, each node ipmaintains a variable rt, whose value is the current routing table of the node. In the formal model (and indeed in any AODV im plementation)weneedtoextractthecomponentsofthe entry for any given destination from a routing table. To thisend, wedeﬁnethe followingpartialfunctions—they are partial because the routing table need not have an entry for the given destination. We begin by selecting 11The word “precursor list” is used in the RFC, but no properties of lists are used. 12As an alternative to restricting the set, we could have deﬁned routing tables as partial functions from IPtoR, in which case it makes more sense todeﬁne an entry as a6tuple, not including the the destination IP as the ﬁrst component.the entry in a routing table corresponding to a given destination dip: σroute:RT×IP⇀R σroute(rt,dip) :=/braceleftbiggrifr∈rt∧π1(r) =dip undeﬁned otherwise. Through the projections π1,...,π 7, deﬁned above, we can now select the components of a selected entry: (a) The destination sequence number relative to dip: sqn:RT×IP→SQN sqn(rt,dip) :=  π2(σroute(rt,dip)) ifσroute(rt,dip) is deﬁned 0 otherwise . (b) The “known” status of a route’s sequence number: sqnf:RT×IP→K sqnf(rt,dip) :=  π3(σroute(rt,dip)) ifσroute(rt,dip) is deﬁned unkotherwise . (c) The validity status of a recorded route: flag:RT×IP⇀F flag(rt,dip) :=π4(σroute(rt,dip)). (d) The hop count of the route from the current node (hosting rt) todip: dhops:RT×IP⇀IN dhops(rt,dip) :=π5(σroute(rt,dip)). (e) Theidentity of the next node on the route to dip (if such a route is known): nhop:RT×IP⇀IP nhop(rt,dip) :=π6(σroute(rt,dip)). (f) The set of precursors or neighbours interested in using the route from iptodip: precs:RT×IP⇀P(IP) precs(rt,dip) :=π7(σroute(rt,dip)). The domain of these partial functions changes during the operation of AODV as more routes are discovered and recorded in the routing table rt. The ﬁrst two func tions areextended to be total functions: wheneverthere is no route to dipinside the routing table under con sideration, the sequence number is set to “unknown” (0) and the sequencenumberstatus ﬂag is set to “un known” ( unk), respectively. In the same style each par tial function could be turned into a total one. However, in the speciﬁcation we use these functions only when they are deﬁned. We are not only interested in information about a single route, but also in information on a routing table:8 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan (a) The set of destination IP addresses for validroutes inrtis given by vD:RT→P(IP) vD(rt) :={dip|(dip,∗,∗,val,∗,∗,∗)∈rt}.13 (b) The set of destination IP addresses for invalid routes in rtis iD:RT→P(IP) iD(rt) :={dip|(dip,∗,∗,inv,∗,∗,∗)∈rt}. (c) Last, we deﬁne the set of destination IP addresses forknownroutes by kD:RT→P(IP) kD(rt) :=vD(rt)∪iD(rt) ={dip|(dip,∗,∗,∗,∗,∗,∗)∈rt}. The partial functions σroute,flag,dhops,nhopand precsare deﬁned for rtanddipiﬀdip∈kD(rt). 4.5 Updating Routing Tables Routing tables can be updated for three principal rea sons. The ﬁrst is when a node needs to adjust its list of precursors relative to a given destination; the second is when a received request or response carries information about networkconnectivity;and the last when informa tionisreceivedtotheeﬀectthatapreviouslyvalidroute should now be considered invalid. We deﬁne an update function for each case. 4.5.1 Updating Precursor Lists Recall that the precursors of a given node iprelative to a particular destination dipare the nodes that are “in terested” in a route to dipviaip. The function addpre takes a routing table entry and a set of IP addresses npreand updates the entry by adding npreto the list of precursors already present: addpre:R×P(IP)→R addpre((dip,dsn,dsk,ﬂag,hops,nhip,pre),npre) := (dip,dsn,dsk,ﬂag,hops,nhip,pre∪npre). Often it isnecessaryto addprecursorsto anentryof a given routing table. For that, we deﬁne the function addpreRT , which takes a routing table rt, a destination dipand a set of IP addresses npreand updates the entry with destination dipby adding npreto the list of 13We use “ ∗” as a wildcard.precursors already present. It is only deﬁned if an entry for destination dipexists. addpreRT :RT×IP×P(IP)⇀RT addpreRT (rt,dip,npre) := (rt−{σroute(rt,dip)}) ∪{addpre(σroute(rt,dip),npre)} Formally,weremovetheentrywithdestination dipfrom the routing table and insert a new entry for that desti nation. This new entry is the same as before—only the precursors have been added. 4.5.2 Inserting New Information in Routing Tables If a node gathers new information about a route to a destination dip, then it updates its routing table de pending on its existing information on a route to dip. If no route to dipwas known at all, it inserts a new entry in its routing table recording the information re ceived. If it already has some (partial) information then it may update this information, depending on whether the new route is fresher or shorter than the one it has already. We deﬁne an update function update(rt,r) of a routing table rtwith an entry ronly when ris valid, i.e., π4(r) =val,π2(r) = 0⇔π3(r) =unk, and π3(r) =unk⇒π5(r) = 1. After we have introduced our formal speciﬁcation for AODV in Section 5, we will show that we only use the function updateif this con dition is satisﬁed (Proposition 15); hence this deﬁnition is suﬃcient. update:RT×R⇀RT update(rt,r) :=  rt∪{r}ifπ1(r)/ne}a⊔ionslash∈kD(rt) nrt∪{nr}ifπ1(r)∈kD(rt) ∧sqn(rt,π1(r))< π2(r) nrt∪{nr}ifπ1(r)∈kD(rt) ∧sqn(rt,π1(r)) =π2(r) ∧dhops(rt,π1(r))> π5(r) nrt∪{nr}ifπ1(r)∈kD(rt) ∧sqn(rt,π1(r)) =π2(r) ∧flag(rt,π1(r)) =inv nrt∪{nr′}ifπ1(r)∈kD(rt) ∧π3(r) =unk nrt∪{ns}otherwise , wheres:=σroute(rt, π1(r)) is the current entry in the routing table for the destination of r(if it exists), andnrt:=rt− {s}is the routing table without that entry. The entry nr:=addpre(r,π7(s)) is identical torexcept that the precursors from sare added and ns:=addpre(s,π7(r)) is generated from sby adding the precursors from r. Lastly, nr′is identical to nrex cept that the sequence number is replaced by the oneModelling and Verifying the AODV Routing Protocol 9 from the route s. More precisely, nr′:= (dipnr,π2(s), dsknr,ﬂagnr,hopsnr,nhipnr,prenr) ifnr= (dipnr,∗, dsknr,ﬂagnr,hopsnr,nhipnr,prenr). In the situation where sqn(rt,π1(r)) =π2(r) both routes nrandnr′are equal. Therefore, though the cases of the above deﬁnition are not mutually exclusive, the function is well deﬁned. Theﬁrstcasedescribesthesituationwheretherout ing table does not contain any information on a route todip. The second case models the situation where the new route has a greater sequence number. As a conse quence all the information from the incoming informa tion is copied into the routing table. In the third and fourthcasethe sequencenumbersarethe sameandcan not be used to identify better information. Hence other measures are used. The route inside the routing table is only replaced if either the new hop count is strictly smaller—ashorterroutehasbeenfound—oriftheroute inside the routing table is marked as invalid. The ﬁfth case deals with the situation where a new route to a knowndestinationhasbeenfoundwithoutanyinforma tion on its sequence number ( π2(r) = 0∧π3(r) =unk). In that case the routing table entry to that destination is always updated, but the existing sequence number is maintained, and marked as “unknown”. Notethatwedonotupdateifwereceiveanewentry where the sequence number and the hop count areiden tical to the current entryin the routingtable. Following the RFC, the time period (till the valid route becomes invalid) should be reset; however at the moment we do not model timing aspects. 4.5.3 Invalidating Routes InvalidatingroutesisamainfeatureofAODV;ifaroute is not valid any longer its validity ﬂag has to be set to invalid. By doing this, the stored information about the route,suchasthesequencenumberorthehopcount,re mains accessible. The process of invalidating a routing table entry follows four rules: (a) any sequence num ber is incremented by 1, except (b) the truly unknown sequence number ( sqn= 0, which will only occur if dsk=unk) is not incremented, (c) the validity ﬂag of the entry is set to inv, and (d) an invalid entry cannot be invalidated again. However, in exception to (a) and (b), when the invalidation is in response to an error message, this message also contains a new (and already incremented) sequence number for each destination to be invalidated. The function for invalidating routing table entries takes as arguments a routing table and a set of desti nationsdests∈P(IP×SQN). Elements of this set are (rip,rsn)pairs that not only identify an unreachable destination rip, but also a sequence number that describes the freshness of the faulty route. As for routing tables, we restrict ourselves to sets that have at most one entry for each destination; this time we formally deﬁnedestsas apartial function fromIPtoSQN, i.e. a subset of IP×SQNsatisfying (rip,rsn),(rip,rsn′)∈dests⇒rsn=rsn′. We use the variable deststo range over such sets. When invoking invalidate we either distil destsfrom an error message, or determine destsas a set of pairs (rip,inc(sqn(rt,rip)), where the operator inc(from Section 4.2) takes care of (a) and (b). Moreover, we will distil or construct destsin such a way that it only lists destinations for which there is a valid entry in the routing table—this takes care of (d). invalidate :RT×(IP⇀SQN)→RT invalidate (rt,dests) :={r∈rt|(π1(r),∗)/ne}a⊔ionslash∈dests} ∪{(π1(r),rsn,π3(r),inv,π5(r),π6(r),π7(r))| r∈rt∧(π1(r),rsn)∈dests} All entries in the routing table for a destination ripin destsare modiﬁed. The modiﬁcation replaces the value valbyinvand the sequence number in the entry by the corresponding sequence number from dests. Copying the sequence number from destsleaves the possibility that the destination sequence number of an entry is decreased, which would violate one of the fun damental assumption of AODV and may yield unex pected behaviour. However, we will show that a de crease of a destination sequence number does not occur in our model of AODV. 4.6 Route Requests A route request—RREQ—for a destination dipis ini tiated by a node (with routing table rt) if this node wants to transmit a data packet to dipbut there is no valid entry for dipin the routing table, i.e. dip/ne}a⊔ionslash∈vD(rt). When a new route request is sent out it contains the identity of the originating node oip, and aroute request identiﬁer (RREQ ID); the type of all such identiﬁers is denoted by RREQID, and the variable rreqidranges over this type. This information does not change, even when the request is rebroadcast by any receiving node that does not already know a route to the requested destination. In this way any request still circulating through the network can be uniquely identiﬁed by the pair (oip,rreqid)∈IP×RREQID. For our speciﬁcation we setRREQID= IN. In our model, each node maintains a variable rreqsof type P(IP×RREQID) of sets of such pairstostorethe sets ofrouterequestsseenby the node so far. Within this set, the node records the requests it10 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan has previously initiated itself. To ensure a fresh rreqid for each new RREQ it generates, the node ipapplies the following function: nrreqid :P(IP×RREQID)×IP→RREQID nrreqid(rreqs,ip) := max {n|(ip,n)∈rreqs}+1, where we take the maximum of the empty set to be 0. 4.7 Queued Packets Strictly speaking the task of sending data packets is not regarded as part of the AODV protocol—however, failure to send a packet because either a route to the destination is unknown, or a previously known route has become invalid, prompts AODV to be activated. In our modelling we describe this interaction between packet sending and AODV, providing the minimal in frastructure for our speciﬁcation. If a new packet is submitted by a client of AODV to a node, it may need to be stored until a route to the packet’s destination has been found and the node is not busy carrying out other AODV tasks. We use a queue style data structure for modelling the store of packets at a node, noting that at each node there may be many dataqueues, oneforeachdestination.In general,wede note queues of type TYPEby [TYPE], denote the empty queue by [], and make use of the standard (partial) functions head: [TYPE]⇀TYPE,tail: [TYPE]⇀[TYPE] andappend:TYPE×[TYPE]→[TYPE] that return the “oldest” element in the queue, remove the “oldest” el ement, and add a packet to the queue, respectively. The data type STORE:=/braceleftbig store∈P(IP×P×[DATA])|/parenleftbig (dip,p,q),(dip,p′,q′)∈store⇒p=p′∧q=q′/parenrightbig/bracerightbig describes stores of enqueued data packets for various destinations, where P:={noreq,req}. An element (dip,p,q)∈IP×P×[DATA] denotes the queue qof pack ets destined for dip; the requestrequired ﬂag pisreqif a new route discovery process for dipstill needs to be initiated, i.e., a route request message needs to be sent. The value noreqindicates that such a RREQ message has been sent already, and either the reply is still pend ing or a route to diphas been established. The ﬂag is set toreqwhen a routing table entry is invalidated. As for routing tables, we require that there is at most one entry for every IP address. In our model, each nodemaintainsavariable storeoftypeSTOREtorecord its current store of data packets. We deﬁne some functions for inspecting a store:(a) Similar to σroute, we need a function that is able to extract the queue for a given destination: σqueue:STORE×IP→[DATA] σqueue(store,dip) :=/braceleftbiggqif (dip,∗,q)∈store [] otherwise . (b) We deﬁne a function qDto extract the destinations for which there are unsent packets: qD:STORE→P(IP) qD(store) :={dip|(dip,∗,∗)∈store}. Next, we deﬁne operations for adding and removing data packets from a store. (c) Adding a data packet for a particular destination to a store is deﬁned by: add:DATA×IP×STORE→STORE add(d,dip,store) :=  store∪{(dip,req,append(d,[]))} if (dip,∗,∗)/∈store store−{(dip,p,q)}∪{(dip,p,append(d,q))} if (dip,p,q)∈store. Informally,theprocessselectstheentry( dip,p,q)∈ store∈STORE, wheredipis the destination of the application layer data d, and appends dto queue qofdipin that triple; the requestrequired ﬂag p remains unchanged. In case there is no entry for dipinstore, the process creates a new queue [ d] of stored packets that only contains the data packet under consideration and inserts it—together with dip—into the store; the requestrequired ﬂag is set toreq, since a route request needs to be sent. (d) To delete the oldest packet for a particular desti nation from a store, we deﬁne: drop:IP×STORE⇀STORE drop(dip,store) :=  store−{(dip,∗,q)} iftail(q) = [] store−{(dip,p,q)}∪{(dip,p,tail(q))} otherwise , whereq=σqueue(store,dip) is the selected queue for destination dip. Ifdip/ne}a⊔ionslash∈qD(store) thenq= []. Therefore tail(q) and hence also drop(dip,store) is undeﬁned. Note that if dis the last queued packet for a speciﬁc destination, the whole entry for the destination is removed from store. In our model of AODV we use only addanddropto update a store. This ensures that the store will never contain a triple ( dip,∗,[]) with an empty data queue, that is dip∈qD(store)⇒σqueue(store,dip)/ne}a⊔ionslash= []. (1)Modelling and Verifying the AODV Routing Protocol 11 Finally, we deﬁne operations for reading and manipu lating the requestrequired ﬂag of a queue. (e) We deﬁne a partial function σpﬂagto extract the ﬂag for a destination for which there are unsent packets: σpﬂag:STORE×IP⇀P σpﬂag(store,dip) :=/braceleftbiggpif (dip,p,∗)∈store undeﬁned otherwise. (f) To change the status of the requestrequired ﬂag, we deﬁne functions setRRFandunsetRRF . After a route request for destination diphas been initiated, the requestrequired ﬂag for diphas to be set to noreq. unsetRRF :STORE×IP→STORE unsetRRF (store,dip) :=  store−{(dip,∗,q)}∪{(dip,noreq,q)} if{(dip,∗,q)} ∈store storeotherwise . In case that there is no queued data for destination dip, thestoreremains unchanged. Whenever a route is invalidated the correspond ing requestrequired ﬂag has to be set to req; this indicates that the protocol might need to initiate a new route discovery process. Since the function invalidate invalidates sets of routing table en tries, we deﬁne a function with a set of destinations dests∈P(IP×SQN) as one of its arguments (anno tated with sequence numbers, which are not used here). setRRF:STORE×(IP⇀SQN)→STORE setRRF(store,dests) := {(dip,p,q)∈store|(dip,∗)/∈dests} ∪{(dip,req,q)|(dip,p,q)∈store ∧(dip,∗)∈dests}. 4.8 Messages and Message Queues Messages are the main ingredient of any routing proto col. The message types used in the AODV protocol are route request, route reply, and route error. To generate theses messages, we use functions rreq: IN×RREQID×IP×SQN×K×IP×SQN×IP →MSG rrep: IN×IP×SQN×IP×IP→MSG rerr: (IP⇀SQN)×IP→MSG.14 The function rreq(hops,rreqid,dip,dsn,dsk,oip,osn,sip) generates a route request. Here, hopsindicates the hop 14The ordering of the arguments follows the RFC.countfromtheoriginator oip—that,atthetimeofsend ing, had the sequence number osn—to the sender of the message sip;rreqiduniquely identiﬁes the route re quest;dsnis the least level of freshness of a route to dip that is acceptable to oip—it has been obtained by incrementing the latest sequence number received in the past by oipfor a route towards dip; anddskin dicates whether we can trust that number. In case no sequence number is known, dsnis set to 0 and dskto unk. Byrrep(hops,dip,dsn,oip,sip) a route reply mes sage is obtained. Originally, it was generated by dip— wheredsndenotes the sequence number of dipat the time of sending—and is destined for oip; the last sender of the message was the node with IP address sipand the distance between dipandsipis given by hops. The error message is generated by rerr(dests,sip), where dests:IP⇀SQNis the list of unreachable destinations andsipdenotes the sender. Every unreachable desti nationripcomes together with the incremented last known sequence number rsn. Next to these AODV control messages, we use for our speciﬁcation also data packets: messages that carry application layer data. newpkt:DATA×IP→MSG pkt:DATA×IP×IP→MSG Although these messages are not part of the protocol itself, they are necessary to initiate error messages, and to trigger the route discovery process. newpkt(d,dip) generates a message containing new application layer dataddestined for a particular destination dip. Such a message is submitted to a node by a client of the AODV protocol hooked up to that node. The function pkt(d,dip,sip) generates a message containing applica tion layer data d, that is sent by the sender sipto the next hop on the route towards dip. All messages received by a particular node are ﬁrst stored in a queue (see Section 5.6 for a detailed descrip tion). To model this behaviour we use a message queue, denoted by the variable msgsof type [MSG]. As for every other queue, we will freely use the functions head,tail andappend. Table2providesasummaryofthe entiredatastruc ture we use. 5 Modelling AODV Our formalisation of AODV tries to accurately model the protocolasdeﬁnedin the IETFRFC3561speciﬁca tion [39]. The model focusses on layer 3 of the protocol stack, i.e., the routing and forwarding of messages and12 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Table 2 Data structure Basic Type Variables Description IP ip,dip,oip,rip,sip,nhip node identiﬁers SQN dsn,osn,rsn,sn sequence numbers K dsk sequencenumberstatus ﬂag F flag route validity IN hops hop counts R r routing table entries RT rt routing tables RREQID rreqid request identiﬁers P requestrequired ﬂag DATA data application layer data STORE store store of queued data packets MSG msg messages Complex Type Variables Description [TYPE] queues with elements of type TYPE [MSG] msgs message queues P(TYPE) sets consisting of elements of type TYPE P(IP) pre sets of identiﬁers (precursors, destinations, ...) P(IP×RREQID)rreqs sets of request identiﬁers with originator IP TYPE1⇀TYPE2 partial functions from TYPE1toTYPE2 IP⇀SQN dests sets of destinations with sequence numbers Constant/Predicate Description 0 :SQN,1 :SQN unknown, smallest sequence number <⊆SQN×SQN strict order on sequence numbers kno,unk:K constants to distinguish known and unknown sqns val,inv:F constants to distinguish valid and invalid routes noreq,req:P constants indicating whether a RREQ is required 0 : IN,1 : IN, <⊆IN×IN standard constants/predicates of natural numbers [] : [TYPE],∅:P(TYPE) empty queue, empty set ∈ ⊆TYPE×P(TYPE) membership, standard set theory Function Description head: [TYPE]⇀TYPE returns the “oldest” element in the queue tail: [TYPE]⇀[TYPE] removes the “oldest” element in the queue append:TYPE×[TYPE]→[TYPE] inserts a new element into the queue drop:IP×STORE⇀STORE deletes a packet from the queued data packets add:DATA×IP×STORE→STORE adds a packet to the queued data packets unsetRRF :STORE×IP→STORE set the requestrequired ﬂag to noreq setRRF:STORE×(IP⇀SQN)→STORE set the requestrequired ﬂag to req σqueue:STORE×IP→[DATA] selects the data queue for a particular destination σpﬂag:STORE×IP⇀P selects the ﬂag for a destination from the store σroute:RT×IP⇀R selects the route for a particular destination (,,,,,,):IP×SQN×K×F×IN×IP×P(IP)→Rgenerates a routing table entry inc:SQN→SQN increments the sequence number max :SQN×SQN→SQN returns the larger sequence number sqn:RT×IP→SQN returns the sequence number of a particular route sqnf:RT×IP→K determines whether the sequence number is known flag:RT×IP⇀F returns the validity of a particular route +1 : IN→IN increments the hop count dhops:RT×IP⇀IN returns the hop count of a particular route nhop:RT×IP⇀IP returns the next hop of a particular route precs:RT×IP⇀P(IP) returns the set of precursors of a particular route vD,iD,kD:RT→P(IP) returns the set of valid, invalid, known destinations qD:STORE→P(IP) returns the set of destinations with unsent packets ∩,∪,/uniontext{...}, ... standard settheoretic functions addpre:R×P(IP)→R adds a set of precursors to a routing table entry addpreRT :RT×IP×P(IP)⇀RT adds a set of precursors to an entry inside a table update:RT×R⇀RT updates a routing table with a route (if fresh enough) invalidate :RT×(IP⇀SQN)→RT invalidates a set of routes within a routing table nrreqid :P(IP×RREQID)×IP→RREQID generates a new route request identiﬁer newpkt:DATA×IP→MSG generates a message with new application layer data pkt:DATA×IP×IP→MSG generates a message containing application layer data rreq: IN×RREQID×IP×SQN×K×IP×SQN×IP→MSGgenerates a route request rrep: IN×IP×SQN×IP×IP→MSG generates a route reply rerr: (IP⇀SQN)×IP→MSG generates a route error messageModelling and Verifying the AODV Routing Protocol 13 packets, and abstracts from lower layer network proto cols and mechanismssuch as the CarrierSense Multiple Access (CSMA) protocol. The presented formalisation includes all core com ponents of the protocol, but, at the moment, abstracts from timing issues and optional protocol features. This keeps our speciﬁcation manageable. A consequence of not modelling timing issues is that statements such as “Can a route expire before a data packet is transmit ted?” [9] cannot be analysed, for in our model routes do not expire at all. Our plan is to extend our model step by step. The model allows us to reason about protocol behaviour and to prove critical protocol characteristics. A detailed list ofabstractionsmade can be found in [16, Section 3]. In this section, we present a speciﬁcation of the AODV protocol using process algebra. The model in cludes a mechanism to describe the delivery of data packets; though this is not part of the protocol itself it is necessary to trigger any AODV activity. Our model consists of7processes,named AODV,NEWPKT,PKT,RREQ, RREP,RERRandQMSG: –The basic process AODVreads a message from the message queue and, depending on the type of the message, calls other processes. When there is no message handling going on, the process initiates the transmission of queued data packets or generates a new route request (if packets are stored for a des tination, no route to this destination is known and no route request for this destination is pending). –The processes NEWPKTandPKTdescribe all actions performed by a node when a data packetis received. The formerprocess handles a newly injected packet. The latter describes all actions performed when a node receives data from another node via the proto col.Thisincludesacceptingthepacket(ifthenodeis the destination), forwarding the packet (if the node is not the destination) and sending an errormessage (if forwarding fails). –The process RREQmodels all events that might oc cur after a route request has been received. This includes updating the node’s routing table, forward ing the route request as well as the initiation of a route reply if a route to the destination is known. –Similarly, the RREPprocess describes the reaction of the protocol to an incoming route reply. –The process RERRmodels the part of AODV which handles error messages. In particular, it describes the modiﬁcation and forwarding of the AODV error message. –The last process QMSGconcerns message handling. Whenever a message is received, it is ﬁrst stored in a message queue. If the corresponding node is ableto handle a message it pops the oldest message from the queue and handles it. An example where a node is not ready to process an incoming message imme diately is when it is already handling a message. In the remainder of the section, we provide a for mal speciﬁcation for each of these processes and ex plain them step by step. Our speciﬁcation can be split into three parts: the brown lines describe updates to be performed on the node’s data, e.g., its routing table; the black lines are other process algebra constructs (cf. Section 3); and the blue lines are ordinary comments. 5.1 The Basic Routine The basic process AODVeither reads a message from the corresponding queue, sends a queued data packet if a route to the destination has been established, or initi ates a new route discovery process in case of queued data packets with invalid or unknown routes. This pro cess maintains ﬁve data variables, ip,sn,rt,rreqs andstore, in which it stores its own identity, its own sequence number, its current routing table, the list of routerequestsseen,andits currentstoreofqueueddata packets that await transmission (cf. Section 4). The message handling is described in Lines 1–20. First, the message has to be read from the queue of storedmessages( receive(msg)). After that, the process AODVchecks the type of the message and calls a process that can handle the message: in case of a newly in jected data packet, the process NEWPKTis called; in case of an incoming data packet, the process PKTis called; in case that the incoming message is an AODV control message (route request, route reply or route error), the nodeupdatesitsroutingtable.Moreprecisely,ifthereis no entry to the message’s sender sip, the receivernode creates an entry with the unknown sequence number 0 and hop count 1; in case there is already a routing ta ble entry ( sip,dsn,∗,∗,∗,∗,pre), then this entry is up dated to ( sip,dsn,unk,val,1,sip,pre) (cf. Lines 10, 14 and 18). Afterwards, the processes RREQ,RREPand RERRare called, respectively. The second part of AODV(Lines 21–32) initiates the sendingofadatapacket.Forthat,ithastobecheckedif there is a queued data packet for a destination that has aknownandvalidrouteintheroutingtable( qD(store) ∩vD(rt)/ne}a⊔ionslash=∅). Incasethat there ismorethan onedesti nationwithstoreddataandaknownroute,anarbitrary destination is chosen and denoted by dip(Line 21).15 Moreover datais set to the ﬁrst queued data packet from the application layer that should be sent ( data:= 15Although the word “let” is not part of the syntax, we add it to stress the nondeterminism happening here.14 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Process 1 The basic routine AODV(ip,sn,rt,rreqs,store)def= 1.receive(msg) . 2./* depending on the message, the node calls diﬀerent process es */ 3.( 4.[msg=newpkt(data,dip)]/* new DATA packet */ 5. NEWPKT(data,dip,ip,sn,rt,rreqs,store) 6.+[msg=pkt(data,dip,oip)]/* incoming DATA packet */ 7. PKT(data,dip,oip,ip,sn,rt,rreqs,store) 8.+[msg=rreq(hops,rreqid,dip,dsn,dsk,oip,osn,sip)]/* RREQ */ 9. /* update the route to sipinrt*/ 10. [[rt:=update(rt,(sip,0,unk,val,1,sip,∅))]]/* 0 is used since no sequence number is known */ 11. RREQ(hops,rreqid,dip,dsn,dsk,oip,osn,sip,ip,sn,rt,rreqs,store) 12. +[msg=rrep(hops,dip,dsn,oip,sip)]/* RREP */ 13. /* update the route to sipinrt*/ 14. [[rt:=update(rt,(sip,0,unk,val,1,sip,∅))]] 15. RREP(hops,dip,dsn,oip,sip,ip,sn,rt,rreqs,store) 16. +[msg=rerr(dests,sip)]/* RERR */ 17. /* update the route to sipinrt*/ 18. [[rt:=update(rt,(sip,0,unk,val,1,sip,∅))]] 19. RERR(dests,sip,ip,sn,rt,rreqs,store) 20.) 21.+[Letdip∈qD(store)∩vD(rt)]/* send a queued data packet if a valid route is known */ 22.[[data:=head(σqueue(store,dip))]] 23.unicast (nhop(rt,dip),pkt(data,dip,ip)) . 24. [[store:=drop(dip,store)]]/* dropdatafrom the storefordipif the transmission was successful */ 25.AODV(ip,sn,rt,rreqs,store) 26.◮/* an error is produced and the routing table is updated */ 27. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧nhop(rt,rip) =nhop(rt,dip)}]] 28. [[rt:=invalidate (rt,dests)]] 29. [[store:=setRRF(store,dests)]] 30. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 31. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧precs(rt,rip)/ne}a⊔ionslash=∅}]] 32. groupcast (pre,rerr(dests,ip)) .AODV(ip,sn,rt,rreqs,store) 33.+[Letdip∈qD(store)−vD(rt)∧σpﬂag(store,dip) =req]/* a route discovery process is initiated */ 34.[[store:=unsetRRF (store,dip)]]/* set requestrequired ﬂag to noreq*/ 35.[[sn:=inc(sn)]]/* increment own sequence number */ 36./* update rreqsby adding ( ip,nrreqid(rreqs,ip)) */ 37.[[rreqid:=nrreqid(rreqs,ip)]] 38.[[rreqs:=rreqs∪{(ip,rreqid)}]] 39.broadcast (rreq(0,rreqid,dip,sqn(rt,dip),sqnf(rt,dip),ip,sn,ip)) .AODV(ip,sn,rt,rreqs,store) head(σqueue(store,dip))).16This data packet is uni casttothenexthopontherouteto dip.Iftheunicastis successful, the data packet datais removed from store (Line 24). Finally, the process calls itself—stating that the node is ready for handling a new message, initiat ing the sending of another packet towards a destina tion, etc. In case the unicast is not successful, the data packet has not been transmitted. Therefore datais not removed from store. Moreover, the node knows that the link to the next hop on the route to dipis faulty and, most probably, broken. An error message is initi ated. Generally, route error and link breakage process ingrequiresthefollowingsteps:(a)invalidatingexisting routing table entries, (b) listing aﬀected destinations, (c) determining which neighbours may be aﬀected (if 16Following the RFC, data packets waiting for a route should be buﬀered “ﬁrstin, ﬁrstout” (FIFO).any), and (d) delivering an appropriate AODV error message to such neighbours [39]. Therefore, the pro cess determines all valid destinations deststhat have this unreachable node as next hop (Line 27) and marks the routing table entries for these destinations as in valid (Line 28), while incrementing their sequence num bers (Line 27). In Line 29, we set, for all invalidated routing table entries, the requestrequired ﬂag to req, thereby indicating that a new route discovery process mayneedtobeinitiated. InLine30therecipientsofthe error message are determined. These are the precursors of the invalidated destinations, i.e., the neighbouring nodes listed as having a route to one of the aﬀected destinations passing through the broken link. Finally, an error message is sent to them (Line 32), listing only those invalidated destinations with a nonempty set of precursors (Line 31).Modelling and Verifying the AODV Routing Protocol 15 Process 2 Routine for handling a newly injected data packet NEWPKT(data,dip,ip,sn,rt,rreqs,store)def= 1.[dip=ip]/* the DATA packet is intended for this node */ 2.deliver(data) .AODV(ip,sn,rt,rreqs,store) 3.+[dip/ne}a⊔ionslash=ip]/* the DATA packet is not intended for this node */ 4.[[store:=add(data,dip,store)]].AODV(ip,sn,rt,rreqs,store) The third and ﬁnal part of AODV(Lines 33–39) initi ates a route discovery process. This is done when there is at least one queued data packet for a destination without a valid routing table entry, that is not wait ing for a reply in response to a route request process initiated before. Following the RFC, the process gen erates a new route request. This is achieved in four steps: First, the requestrequired ﬂag is set to noreq (Line 34), meaning that no further route discovery pro cesses for this destination need to be initiated.17Sec ond, the node’s own sequence number is increased by 1 (Line 35). Third, by determining nrreqid(rreqs,ip), a new route request identiﬁer is created and stored— together with the node’s ip—in the set rreqsof route requests already seen (Line 38). Fourth, the message itself is sent (Line 39) using broadcast. In contrast to unicast, transmissions via broadcast are not checked on success. The information inside the message follows strictly the RFC. In particular, the hop count is set to 0, the route request identiﬁer previously created is used, etc. This ends the initiation of the route discovery process. 5.2 Data Packet Handling The processes NEWPKTandPKTdescribe all actions performed by a node when a data packet is injected by a client hooked up to the local node or received via the protocol,respectively.Forthe process PKT,this includes the acceptance (if the node is the destination), the for warding (if the node is not the destination), as well as the sending of an error message in case something went wrong. The process NEWPKTdoes not include the initiation of a new route request; this is part of the pro cessAODV. Although packet handling itself is not part of AODV, it is necessary to include it in our formalisa tion, since a failure to transmit a data packet triggers AODV activity. The process NEWPKTﬁrst checks whether the node is the intended addressee of the data packet. If this is the case,itdeliversthedataandreturnstothebasicroutine AODV. Ifthe node is notthe intended destination( dip/ne}a⊔ionslash= 17The RFC does not describe packet handling in detail; hence the requestrequired ﬂag is not part of the RFC’s RREQ generation process.ip, Line 3), the datais added to the data queue for dip(Line 4),18which ﬁnishes the handling of a newly injected data packet. The further handling of queued data (forwarding it to the next hop on the way to the destination in case a valid route to the destination is known, and otherwise initiating a new route request if still required) is the responsibility of the main process AODV. Similar to NEWPKT, the process PKTﬁrst checks if it is the intended addressee of the data packet. If this is the case, it delivers the data and returns to the basic routineAODV.Ifthe nodeisnotthe intendeddestination (dip/ne}a⊔ionslash=ip, Line 3) more activity is needed. In case that the node has a valid route to the data’s destination dip(dip∈vD(rt)), it forwards the packet using a unicast to the next hop nhop(rt,dip) on the way todip. Similar to the unicast of the process AODV, it has to be checked whether the transmission is suc cessful: no further action is necessary if the transmis sion succeeds, and the node returns to the basic routine AODV. If the transmission fails, the link to the next hop nhop(rt,dip) is assumed to be broken. As before, all destinations deststhatarereachedviathatbrokenlink are determined (Line 9) and all precursors interested in at least one of these destinations are informed via an error message (Line 14). Moreover, all the routing ta ble entries using the broken link have to be invalidated in the node’s routing table rt(Line 10), and all corre spondingrequestrequiredﬂagsaresetto req(Line11). In case that the node has no valid route to the des tinationdip(dip/ne}a⊔ionslash∈vD(rt)), the data packet is lost and possibly an errormessage is sent. If there is an (invalid) route to the data’s destination dipin the routing table (Line18),thepossiblyaﬀectedneighbourscanbedeter mined and the error message is sent to these precursors (Line 20). If there is no information about a route to wardsdipnothing happens (and the basicprocess AODV is called again). 18If no data for destination dipwas already queued, the function addcreates afreshqueuefor dip,and setthe request required ﬂagto req; otherwise, the requestrequired ﬂagkeeps the value it had already.16 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Process 3 Routine for handling a received data packet PKT(data,dip,oip,ip,sn,rt,rreqs,store)def= 1.[dip=ip]/* the DATA packet is intended for this node */ 2.deliver(data) .AODV(ip,sn,rt,rreqs,store) 3.+[dip/ne}a⊔ionslash=ip]/* the DATA packet is not intended for this node */ 4.( 5.[dip∈vD(rt)]/* valid route to dip*/ 6. /* forward packet */ 7. unicast (nhop(rt,dip),pkt(data,dip,oip)) .AODV(ip,sn,rt,rreqs,store) 8. ◮/* If the packet transmission is unsuccessful, a RERR messag e is generated */ 9. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧nhop(rt,rip) =nhop(rt,dip)}]] 10. [[rt:=invalidate (rt,dests)]] 11. [[store:=setRRF(store,dests)]] 12. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 13. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧precs(rt,rip)/ne}a⊔ionslash=∅}]] 14. groupcast (pre,rerr(dests,ip)) .AODV(ip,sn,rt,rreqs,store) 15. +[dip/ne}a⊔ionslash∈vD(rt)]/* no valid route to dip*/ 16. /* no local repair occurs; data is lost */ 17. ( 18. [dip∈iD(rt)]/* invalid route to dip*/ 19. /* if the route is invalid, a RERR is sent to the precursors */ 20. groupcast (precs(rt,dip),rerr({(dip,sqn(rt,dip))},ip)) .AODV(ip,sn,rt,rreqs,store) 21. +[dip/ne}a⊔ionslash∈iD(rt)]/* route not in rt*/ 22. AODV(ip,sn,rt,rreqs,store) 23. ) 24.) 5.3 Receiving Route Requests The process RREQmodels all events that may occur after a route request has been received. RREQﬁrst reads the unique identiﬁer ( oip,rreqid) of the route request received. If this pair is already stored in the node’s data rreqs, the route request has been handled before and the message can silently be ignored (Lines 1–2). If the received message is new to this node, i.e., (oip,rreqid)/ne}a⊔ionslash∈rreqs(Line 3), the node establishes a route of length hops+1 back to the originator oipof the message. If this route is “bet ter” than the route to oipin the current routing ta ble, the routing table is updated by this route (Line 4). Moreover the unique identiﬁer has to be added to the setrreqsof already seen (and handled) route requests (Line 5). After these updates the process checks if the node is the intended destination ( dip=ip, Line 7). In that case, a route reply must be initiated: ﬁrst, the node’s sequence number is—according to the RFC—set to the maximum of the current sequence number and the des tination sequence number stemming from the RREQ message (Line 8).Then the reply is unicast to the next hop on the route back to the originator oipof the route request.Thecontentofthenewroutereplyisasfollows: the hop count is set to 0, the destination and originatorare copied from the route request received and the des tination’s sequence number is the node’s own sequence numbersn;ofcoursethesender’sIPofthis messagehas tobesettothenode’s ip.Asbefore(cf.Sections5.1and 5.2), the process invalidates the corresponding routing table entries, sets requestrequired ﬂags and sends an error message to all relevant precursors if the unicast transmission fails (Lines 12–17). If the node is not the destination dipof the mes sage but an intermediate hop along the path from the originator to the destination, it is allowed to generate a route reply only if the information in its own rout ing table is fresh enough. This means that (a) the node has a valid route to the destination, (b) the destination sequence number in the node’s existing routing table entry for the destination ( sqn(rt,dip)) is greater than or equal to the requested destination sequence num berdsnof the message and (c) the sequence number sqn(rt,dip) is known, i.e., sqnf(rt,dip) =kno. If these three conditions are satisﬁed—the check is done in Line 20—the node generates a new route reply and sends it to the next hop on the way back to the origi natoroipof the received route request.19. To this end, it copies the sequence number for the destination dip from the routing table rtinto the destination sequence number ﬁeld of the RREP message and it places its dis tance in hops from the destination ( dhops(rt,dip)) in the corresponding ﬁeld of the new reply (Line 25). The 19This next hop will often, but not always, be sip; see [16].Modelling and Verifying the AODV Routing Protocol 17 Process 4 RREQ handling RREQ(hops,rreqid,dip,dsn,dsk,oip,osn,sip,ip,sn,rt,rreqs,store)def= 1.[(oip,rreqid)∈rreqs]/* the RREQ has been received previously */ 2.AODV(ip,sn,rt,rreqs,store)/* silently ignore RREQ, i.e. do nothing */ 3.+[(oip,rreqid)/ne}a⊔ionslash∈rreqs]/* the RREQ is new to this node */ 4.[[rt:=update(rt,(oip,osn,kno,val,hops+1,sip,∅))]]/* update the route to oipinrt*/ 5.[[rreqs:=rreqs∪{(oip,rreqid)}]]/* update rreqsby adding ( oip,rreqid) */ 6.( 7.[dip=ip]/* this node is the destination node */ 8. [[sn:= max(sn,dsn)]]/* update the sqn of ip*/ 9. /* unicast a RREP towards oipof the RREQ */ 10. unicast (nhop(rt,oip),rrep(0,dip,sn,oip,ip)) .AODV(ip,sn,rt,rreqs,store) 11. ◮/* If the transmission is unsuccessful, a RERR message is gen erated */ 12. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧nhop(rt,rip) =nhop(rt,oip)}]] 13. [[rt:=invalidate (rt,dests)]] 14. [[store:=setRRF(store,dests)]] 15. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 16. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧precs(rt,rip)/ne}a⊔ionslash=∅}]] 17. groupcast (pre,rerr(dests,ip)) .AODV(ip,sn,rt,rreqs,store) 18. +[dip/ne}a⊔ionslash=ip]/* this node is not the destination node */ 19. ( 20. [dip∈vD(rt)∧dsn≤sqn(rt,dip)∧sqnf(rt,dip)=kno]/*valid route to dipthat is fresh enough*/ 21. /* update rtby adding precursors */ 22. [[rt:=addpreRT (rt,dip,{sip})]] 23. [[rt:=addpreRT (rt,oip,{nhop(rt,dip)})]] 24. /* unicast a RREP towards the oipof the RREQ */ 25. unicast (nhop(rt,oip),rrep(dhops(rt,dip),dip,sqn(rt,dip),oip,ip)) . 26. AODV(ip,sn,rt,rreqs,store) 27. ◮/* If the transmission is unsuccessful, a RERR message is gen erated */ 28. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧nhop(rt,rip) =nhop(rt,oip)}]] 29. [[rt:=invalidate (rt,dests)]] 30. [[store:=setRRF(store,dests)]] 31. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 32. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧precs(rt,rip)/ne}a⊔ionslash=∅}]] 33. groupcast (pre,rerr(dests,ip)) .AODV(ip,sn,rt,rreqs,store) 34. +[dip/ne}a⊔ionslash∈vD(rt)∨sqn(rt,dip)<dsn∨sqnf(rt,dip)=unk]/*no valid route that is fresh enough*/ 35. /* no further update of rt*/ 36. broadcast (rreq(hops+1,rreqid,dip,max(sqn(rt,dip),dsn),dsk,oip,osn,ip)) . 37. AODV(ip,sn,rt,rreqs,store) 38. ) 39.) unicast might fail, which causes the usual error han dling (Lines 28–33). Just before transmitting the uni cast, the intermediate node updates the forward route entry todipby placing the last hop node ( sip)20into the precursor list for the forward route entry (Line 22). Likewise, it updates the reverse route entry to oipby placing the ﬁrst hop nhop(rt,dip) towards dipin the precursor list for that entry (Line 23).21 If the node is not the destination and there is either no route to the destination dipinside the routing ta ble or the route is not fresh enough, the route request received has to be forwarded. This happens in Line 36. The information inside the forwarded request is mostly 20This is a mistake in the RFC; it should be nhop(rt,oip). 21Unless the gratuitous RREP ﬂag is set, which we do not model in this paper, this update is rather useless, as the pre  cursornhop(rt,dip) in general is not aware that it has a route tooip.copied from the request received. Only the hop count is increased by 1 and the destination sequence number is settothemaximumofthedestinationsequencenumber in the RREQ packet and the current sequence number fordipin the routing table. In case dipis an unknown destination, sqn(rt,dip) returns the unknown sequence number 0. 5.4 Receiving Route Replies The process RREPdescribes the reaction of the proto col to an incoming route reply. Our model ﬁrst checks if a forward routing table entry is going to be created or updated (Line 1). This is the case if (a) the node has no known route to the destination, or (b) the desti nation sequence number in the node’s existing routing table entry for the destination ( sqn(rt,dip)) is smaller18 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Process 5 RREP handling RREP(hops,dip,dsn,oip,sip,ip,sn,rt,rreqs,store)def= 1.[rt/ne}a⊔ionslash=update(rt,(dip,dsn,kno,val,hops+1,sip,∅))]/* the routing table has to be updated */ 2.[[rt:=update(rt,(dip,dsn,kno,val,hops+1,sip,∅))]] 3.( 4.[oip=ip]/* this node is the originator of the corresponding RREQ */ 5. /* a packet may now be sent; this is done in the process AODV*/ 6. AODV(ip,sn,rt,rreqs,store) 7.+[oip/ne}a⊔ionslash=ip]/* this node is not the originator; forward RREP */ 8. ( 9. [oip∈vD(rt)]/* valid route to oip*/ 10. /* add next hop towards oipas precursor and forward the route reply */ 11. [[rt:=addpreRT (rt,dip,{nhop(rt,oip)})]] 12. [[rt:=addpreRT (rt,nhop(rt,dip),{nhop(rt,oip)})]] 13. unicast (nhop(rt,oip),rrep(hops+1,dip,dsn,oip,ip)) . 14. AODV(ip,sn,rt,rreqs,store) 15. ◮/* If the transmission is unsuccessful, a RERR message is gen erated */ 16. [[dests:={(rip,inc(sqn(rt,rip)))|rip∈vD(rt)∧nhop(rt,rip) =nhop(rt,oip)}]] 17. [[rt:=invalidate (rt,dests)]] 18. [[store:=setRRF(store,dests)]] 19. [[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 20. [[dests:={(rip,rsn)|(rip,rsn)∈dests∧precs(rt,rip)/ne}a⊔ionslash=∅}]] 21. groupcast (pre,rerr(dests,ip)) .AODV(ip,sn,rt,rreqs,store) 22. +[oip/ne}a⊔ionslash∈vD(rt)]/* no valid route to oip*/ 23. AODV(ip,sn,rt,rreqs,store) 24. ) 25.) 26.+[rt=update(rt,(dip,dsn,kno,val,hops+1,sip,∅))]/* the routing table is not updated */ 27.AODV(ip,sn,rt,rreqs,store) thanthedestinationsequencenumber dsnintheRREP message, or (c) the two destination sequence numbers are equal and, in addition, either the incremented hop count of the RREP received is strictly smaller than the one in the routing table, or the entry for dipin the routing table is invalid. Hence Line 1 could be re placed by [dip/ne}a⊔ionslash∈kD(rt)∨sqn(rt,dip)<dsn∨(sqn(rt,dip)=dsn ∧(dhops(rt,dip)>hops+1∨flag(rt,dip)=inv))].22 In case that one ofthese conditions is true, the rout ing table is updated in Line 2. If the node is the in tended addressee of the route reply ( oip=ip) the protocol returns to its basic process AODV. Otherwise (oip/ne}a⊔ionslash=ip) the message should be forwarded.Following the RFC [39], “If the current node is not the node indi cated by the Originator IP Address in the RREP mes sage AND a forward route has been created or updated [...],thenodeconsultsitsroutetableentryfortheorig inating node to determine the next hop for the RREP packet, and then forwards the RREP towards the orig 22In casedip/ne}a⊔ionslash∈kD(rt), the terms dhops(rt,dip) and flag(rt,dip) are not deﬁned. In such a case, according to the convention of Footnote 8 in Section 3, the atomic formu lasdhops(rt,dip)>hops+1 andflag(rt,dip)=invevaluate to false. However, in case one would use lazy evaluation of the outermost disjunction, the evaluation of the expression wo uld be independent of the choice of a convention for interpretin g undeﬁned terms appearing in formulas.inator using the information in that route table entry.” This action needs a valid route to the originator oip of the route request to which the current message is a reply (oip∈vD(rt), Line 9). The content of the RREP message to be sent is mostly copied from the RREP received; only the sender has to be changed (it is now the node’s ip) and the hop count is incremented. Prior to the unicast, the node nhop(rt,oip), to which the messageis sent, is added to the list of precursorsfor the routesto dip(Line 11) andtothenext hopontheroute todip(Line 12). Although not speciﬁed in the RFC, it would make sense to also add a precursor to the reverse route by [[rt:=addpreRT (rt,oip,{nhop(rt,dip)})]]. As usual, if the unicast fails, the aﬀected routing table entries are invalidated and the precursors of all routes using the broken link are determined and an error mes sage is sent (Lines 16–21). In the unlikely situation that a replyshould be forwardedbut novalid routeis known by the node, nothing happens. Following the RFC, no precursor has to be notiﬁed and no error message has to be sent—even if there is an invalid route. If a forward routing table entry is not created nor updated, the reply is silently ignored and the basic pro cess is called (Lines 26–27).Modelling and Verifying the AODV Routing Protocol 19 Process 6 RERR handling RERR(dests,sip,ip,sn,rt,rreqs,store)def= 1./* invalidate broken routes */ 2.[[dests:={(rip,rsn)|(rip,rsn)∈dests∧rip∈vD(rt)∧nhop(rt,rip) =sip∧sqn(rt,rip)<rsn}]] 3.[[rt:=invalidate (rt,dests)]] 4.[[store:=setRRF(store,dests)]] 5./* forward the RERR to all precursors for rtentries for broken connections */ 6.[[pre:=/uniontext{precs(rt,rip)|(rip,∗)∈dests}]] 7.[[dests:={(rip,rsn)|(rip,rsn)∈dests∧precs(rt,rip)/ne}a⊔ionslash=∅}]] 8.groupcast (pre,rerr(dests,ip)) .AODV(ip,sn,rt,rreqs,store) 5.5 Receiving Route Errors The process RERRmodels the part of AODV that han dles error messages. An error message consists of a set destsof pairs of an unreachable destination IP address ripand the corresponding unreachable destination se quence number rsn. If a node receives an error message from a neigh bour for one or more valid routes, it has—under some conditions—to invalidate the entries for those routes in its own routing table and forward the error message. The node compares the set destsof unavailable desti nations from the incoming error message with its own entries in the routing table. If the routing table lists a valid route with a ( rip,rsn)combination from dests and if the next hop on this route is the sender sipof the error message, this entry may be aﬀected by the error message. In our formalisation, we have added the requirement sqn(rt,rip)<rsn, saying that the entry is aﬀected by the error message only if the “incoming” sequence number is larger than the one stored in the routing table, meaning that it is based on fresher infor mation.23In this case, the entry has to be invalidated and all precursors of this particular route have to be informed. This has to be done for all aﬀected routes. In fact, the process ﬁrst determines all ( rip,rsn) pairs that have eﬀects on its own routing table and that may have to be forwarded as content of a new er ror message (Line 2). After that, all entries to unavail able destinations are invalidated (Line 3), and as usual when routing table entries are invalidated, the request requiredﬂagsaresetto req(Line 4). InLine6thesetof all precursors (aﬀected neighbours) of the unavailable destinations are summarised in the set pre. Then, the setdestsis “thinned out” to only those destinations that have at least one precursor— only these destina tions are transmitted in the forwarded error message (Line 7). Finally, the message is sent (Line 8). 23This additional requirement is in the spirit of Section 6.2 of the RFC [39] on updating routing table entries, but in contradiction with Section 6.11 of the RFC on handling RERR messages. In [20] we show that the reading of Section 6.11 of the RFC gives rise to routing loops.5.6 The Message Queue and Synchronisation We assume that any message sent by a node sipto a nodeipthathappenstobe withintransmissionrangeof sipis actually received by ip. For this reason, ipshould always be able to perform a receive action, regardless of which state it is in. However, the main process AODV that runs on the node ipcan reach a state, such as PKT, RREQ,RREPorRERR, in which it is not ready to perform a receive action. For this reason we introduce a process QMSG, modelling a message queue, that runs in parallel withAODVor any other process that might be called. Every incoming message is ﬁrst stored in this queue, and piped from there to the process AODV, whenever AODVis ready to handle a new message. The process QMSGis always ready to receive a new message, even whenAODVis not. The whole parallel process running on a node is then given by an expression of the form (ξ,AODV(ip,sn,rt,rreqs,store))/an}bracke⊔le{⊔/an}bracke⊔le{⊔(ζ,QMSG(msgs)). 5.7 Initial State To ﬁnish our speciﬁcation, we have to deﬁne an ini tial state. The initial network expression is an encapsu lated parallel composition of node expressions ip:P:R, where the (ﬁnite) number of nodes and the range Rof each node expression is left unspeciﬁed (can be any thing). However, each node in the parallel composition is required to have a unique IP address ip. The initial processPofipis given by the expression (ξ,AODV(ip,sn,rt,rreqs,store))/an}bracke⊔le{⊔/an}bracke⊔le{⊔(ζ,QMSG(msgs)), with ξ(ip) =ip∧ξ(sn) = 1∧ξ(rt) =∅∧ξ(rreqs) =∅ ∧ξ(store) =∅∧ζ(msgs) = [].(2) This says that initially each node is correctly informed about its own identity; its own sequence number is ini tialised with 1 and its routing table, the list of RREQs seen, the store of queued data packets as well as the message queue are empty.20 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Process 7 Message queue QMSG(msgs)def= 1./* store incoming message at the end of msgs*/ 2.receive(msg) .QMSG(append(msg,msgs)) 3.+[msgs/ne}a⊔ionslash= []]/* the queue is not empty */ 4.( 5./* pop top message and send it to another sequential process * / 6.send(head(msgs)) .QMSG(tail(msgs)) 7./* or receive and store an incoming message */ 8.+receive(msg) .QMSG(append(msg,msgs)) 9.) 6 Invariants Using AWN and the proposed model of AODV we can nowformaliseandprovecrucialpropertiesofAODV. In this section we verify properties that can be expressed as invariants, i.e., statements that hold all the time when the protocol is executed. The most important invariant we establish is loop freedom; most prior results can be regarded as stepping stones towards this goal. Next to that we also formalise and discuss route correctness . 6.1 State and Transition Invariants A(state) invariant is a statement that holds for all reachable states of our model. Here states are network expressions, as formally deﬁned in [16] and described in Section 3. An invariant is usually veriﬁed by show ing that it holds for all possible initial states, and that, for any transition Nℓ− →N′between network expres sions derived by our operational semantics, if it holds for state Nthen it also holds for state N′. In this paper we abstain from a formal deﬁnition of the operational semantics, and hence do not deﬁne the labelled tran sition relation − →between network states. Instead we verify invariants by checking that they are preserved under any execution of any line in one of the Processes 1–7. In [16] we formally document that such a check yields the required result. Besides (state) invariants, we also establish state ments we call transition invariants . A transition invari ant is a statement that holds for each reachable tran sitionNℓ− →N′between network expressions derived by the operational semantics. Again these transitions correspond with lines in one of the Processes 1–7; they either describe a relation between the states NandN′ beforeandafterexecutingtheinstruction—e.g.thatthe value of a speciﬁc variable maintained by our processes willneverdecrease—ortheydescribearelationbetween the instruction being executed (such as a broadcast of a message involving a certain value) and the state rightbeforehand (such as a comparable value maintained by the broadcasting node). Transition invariants are sim ply checked by going though all appropriate lines in Processes1–7. In a few caseswe use induction on reach ability; thisamountstoassumingthatthe samerelation holds for instructions executed earlier. Again we refer to [16] for the soundness of this approach. Inourformalisationoftransitioninvariants,wewrite NR:*cast(m)− −−−−−− → ipN′to indicate that our network moves from state Nto state N′by means of a broadcast , unicast orgroupcast of the message m, executed by nodeip, while the current transmission range of this node isR. The following observations are crucial in establish ing many of our invariants. Proposition 1 (a) With the exception ofnew packets that are submit ted to a node by a client of AODV, every message receivedand handled bythe main routine ofAODV has to be sent by some node before. More formally, we consider an arbitrary path N0ℓ1− →N1ℓ2− →...ℓk− →Nk withN0an initial state in our model of AODV. If the transition Nk−1ℓk− →Nkresults from a synchro nisation involving the action receive(msg) from Line 1 of Pro.1—performed by the node ip—where the variable msgis assigned the value m, then ei therm=newpkt(d,dip) or one of the ℓiwithi < k stems from an action *cast(m) of a node ip′of the network. (b) No node can receive a message directly from itself. Using the formalisation above, we need ip/ne}a⊔ionslash=ip′. ProofThe only way Line 1 of Pro. 1 can be executed, is through a synchronisation of the main process AODV with the message queue QMSG(Pro. 6) running on the same node. This involves the action send(m) ofQMSG. Heremis popped from the message queue msgs, which started out empty. So at some point QMSGmust haveModelling and Verifying the AODV Routing Protocol 21 performed the action receive(m). However, this ac tion is blocked by the encapsulation operator[ ], except whenmhas the form newpkt(d,dip) or when it synchro nises with an action *cast(m) of another node. ⊓ ⊔ At ﬁrst glance Part(b) does not seem to reﬂect reality. Of course, an application running on a local node has to be able to send data packets to another application running on the same node. However, in any practical implementation, when a node sends a message to itself, the message will be delivered to the corresponding ap plicationonthelocalnodewithouteverbeing“seen”by AODV or any other routing protocol. Therefore, from AODV’s perspective, no node can receive a message (directly) from itself. 6.2 Notions and Notations Before formalising and proving invariants, we introduce some useful notions and notations. All processes except QMSGmaintain the ﬁve data variables ip,sn,rt,rreqsandstore. Next to that QMSGmaintains the variable msgs. Hence, these 6 vari ables can be evaluated at any time. Moreover, every node expression in the transition system looks like ip: (ξ,P/an}bracke⊔le{⊔/an}bracke⊔le{⊔ζ,QMSG(msgs)) :R, wherePis a state in one of the following sequential processes: AODV(ip,sn,rt,rreqs,store), NEWPKT(data,dip,ip,sn,rt,rreqs,store), PKT(data,dip,oip,ip,sn,rt,rreqs,store), RREQ(hops,rreqid,dip,dsn,dsk,oip,osn,sip, ip,sn,rt,rreqs,store) RREP(hops,dip,dsn,oip,sip, ip,sn,rt,rreqs,store) RERR(dests,sip,ip,sn,rt,rreqs,store). Hence the state of the transition system for a node ip is determined by the process P, the range R, and the two valuations ξandζ. If a network consists of a (ﬁ nite) set IP⊆IPof nodes, a reachable network expres sionNis an encapsulated parallel composition of node expressions—one for each ip∈IP. In this section, we assumeNandN′to be reachable network expressions in our model of AODV. To distill information about a node from N, we deﬁne the following projections: Pip N:=P,whereip:(∗,P/an}bracke⊔le{⊔/an}bracke⊔le{⊔∗,∗):∗is a node expr. of N, Rip N:=R,whereip:(∗,∗/an}bracke⊔le{⊔/an}bracke⊔le{⊔∗,∗):Ris a node expr. of N, ξip N:=ξ,whereip:(ξ,∗/an}bracke⊔le{⊔/an}bracke⊔le{⊔∗,∗):∗is a node expr. of N, ζip N:=ζ,whereip:(∗,∗/an}bracke⊔le{⊔/an}bracke⊔le{⊔ζ,∗):∗is a node expr. of N.For example, Pip Ndetermines the sequential process the node is currently working in, Rip Ndenotes the set of all nodes currently within transmission range of ip, and ξip N(rt) evaluates the current routing table maintained by node ipin the network expression N. In the forth coming proofs, when discussing the eﬀects of an action, identiﬁed by a line number in one of the processes of our model, ξdenotes the current valuation ξip N, where ipis the address of the local node, executing the action under consideration, and Nis the network expression obtained right before this action occurs, corresponding with the line number under consideration. When con sidering the eﬀects of several actions, corresponding to several line numbers, ξis always interpreted most lo cally. For instance, in the proof of Proposition 12(a), casePro. 4, Line 36 , we write Hence ... ipc:=ξ(ip) =ipandξipc N=ξ(by (3)). At Line 4 we update the routing table using r:= ξ(oip,osn,kno,val,hops+1,sip,∅) as new entry. The routing table does not change between Lines 4 and 36; nor do the values of hops,oipandosn. WritingNkfor a network expression in which the local nodeipis about to execute Line k, this passage can be reworded as Hence ... ipc:=ξip N36(ip) =ipandξipc N36=ξip N36(by (3)).ξip N5(rt) := ξip N4(update(rt,(oip,osn,kno,val,hops+1,sip,∅))) :=update(ξip N4(rt),(ξip N4(oip),ξip N4(osn),...)). ξip N5(rt) =ξip N36(rt)∧ξip N4(hops) =ξip N36(hops)∧ ξip N4(oip) =ξip N36(oip)∧ξip N4(osn) =ξip N36(osn). In all of case Pro. 4, Line 36 , through the statement of the proposition, Nis bound to N36, so that ξip N= ξip N36. In Section 4.4 we have deﬁned functions that work on evaluated routing tables ξip N(rt), such as nhop. To ease readability, we abbreviate nhop(ξip N(rt),dip) by nhopip N(dip). Similarly, we use sqnip N(dip),dhopsip N(dip), flagip N(dip),σrouteip N(dip),kDip N,vDip NandiDip Nfor sqn(ξip N(rt),dip),dhops(ξip N(rt),dip),flag(ξip N(rt),dip), σroute(ξip N(rt),ip),kD(ξip N(rt)),vD(ξip N(rt)) and iD(ξip N(rt)), respectively. 6.3 Basic Properties In this section we show some of the most fundamental invariants for AODV. The ﬁrst one is already stated in the RFC [39, Sect. 3]. Proposition 2 Any sequence number of a given node ipincreases monotonically, i.e., never decreases, and is never unknown. That is, for ip∈IP, ifNℓ− →N′then 1≤ξip N(sn)≤ξip N′(sn).22 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan ProofIn all initial states the invariant is satisﬁed, as all sequence numbers of all nodes are set to 1 (see (2) in Section 5.7). The Processes 1–7 of Section 5 change a node’s sequence number only through the functions incand max. This occurs at two places only: Pro. 1, Line 35: Hereξip N(sn)≤inc(ξip N(sn))=ξip N′(sn). Pro. 4, Line 8: Hereξip N(sn)≤max(ξip N(sn),∗)=ξip N′(sn). From this and the fact that all sequence numbers are initialised with 1 we get 1 ≤ξip N(sn). ⊓ ⊔ The proof strategy used above can be generalised. Remark 3 Most of the forthcoming proofs can be done by showingthe statement for each initial state and then checkingalllocationsintheprocesseswherethevalidity of the invariant is possibly changed. Note that routing table entries are only changed by the functions update, invalidate oraddpreRT . Thus we have to show that aninvariantdealingwith routingtablesis satisﬁedafter the execution ofthese functions if it was valid before. In our proofs, we go through all occurrences of these func tions. In case the invariant does not make statements about precursors, the function addpreRT need not be considered. To ease readability we defer most of the proofs to the appendix; and show only the most important ones in the main text. Proposition 4 The set of known destinations of any node increases monotonically. That is, for ip∈IP, if Nℓ− →N′thenkDip N⊆kDip N′. Proposition 5 In each node’s routing table, the se quence number for a given destination increases mono tonically, i.e., never decreases. That is, for ip,dip∈IP, ifNℓ− →N′thensqnip N(dip)≤sqnip N′(dip). Our next invariant tells that each node is correctly informed about its own identity. Proposition 6 For each ip∈IPand each reachable stateNwe have ξip N(ip) =ip. This proposition will be used implicitly in many of the proofs to follow. In particular, for all ip′,ip′′∈IP ξip′ N(ip) =ip′′⇒ip′=ip′′∧ξip′ N=ξip′′ N. (3) Next, we show that every AODV control message contains the IP address of the sender. Proposition 7 If an AODV control message is sent by nodeip∈IP, the node sending this message identiﬁes itself correctly: NR:*cast(m)− −−−−−− → ipN′⇒ip=ipc, where the message mis either rreq(∗,∗,∗,∗,∗,∗,∗,ipc), rrep(∗,∗,∗,∗,ipc), orrerr(∗,ipc).The proof is straightforward: whenever such a message is sent in one of the processes of Section 5, ξ(ip) is set as the last argument. ⊓ ⊔ Proposition 8 All routing table entries have a hop count greater than or equal to 1. (∗,∗,∗,∗,hops,∗,∗)∈ξip N(rt)⇒hops≥1 (4) Proposition 9 (a) Ifa routerequestwith hopcount0 issentby anode ipc∈IP, the sender must be the originator. NR:*cast(rreq(0,∗,∗,∗,∗,oipc,∗,ipc))− −−−−−−−−−−−−−−−−−−− → ipN′⇒oipc=ipc(5) (b) If a route reply with hop count 0 is sent by a node ipc∈IP, the sender must be the destination. NR:*cast(rrep(0,dipc,∗,∗,ipc))− −−−−−−−−−−−−−−−− → ipN′⇒dipc=ipc(6) Proposition 10 (a) Each routing table entry with 0 as its destination sequencenumberhasasequencenumberstatusﬂag valued unknown. (dip,0,f,∗,∗,∗,∗)∈ξip N(rt)⇒f=unk (7) (b) Unknown sequence numbers can only occur at 1 hop connections. (∗,∗,unk,∗,hops,∗,∗)∈ξip N(rt)⇒hops= 1 (8) (c) 1hop connections must contain the destination as next hop. (dip,∗,∗,∗,1,nhip,∗)∈ξip N(rt)⇒dip=nhip(9) (d) If the sequence number 0 occurs within a routing table entry, the hop count as well as the next hop can be determined. (dip,0,f,∗,hops,nhip,∗)∈ξip N(rt) ⇒f=unk∧hops= 1∧dip=nhip(10) Proposition 11 (a) Whenever an originator sequence number is sent as part of a route request message, it is known, i.e., it is greater than or equal to 1. NR:*cast(rreq(∗,∗,∗,∗,∗,∗,osnc,∗))− −−−−−−−−−−−−−−−−−− → ipN′⇒osnc≥1 (11) (b) Whenever a destination sequence number is sent as part of a route reply message, it is known, i.e., it is greater than or equal to 1. NR:*cast(rrep(∗,∗,dsnc,∗,∗))− −−−−−−−−−−−−−−− → ipN′⇒dsnc≥1 (12)Modelling and Verifying the AODV Routing Protocol 23 Proposition 12 (a) If a route request is sent (forwarded) by a node ipc diﬀerent from the originatorof the request then the content of ipc’s routing table must be fresher or at least as good as the information inside the message. NR:*cast(rreq(hopsc,∗,∗,∗,∗,oipc,osnc,ipc))− −−−−−−−−−−−−−−−−−−−−−−−− → ipN′ ∧ipc/ne}a⊔ionslash=oipc ⇒oipc∈kDipc N∧/parenleftbig sqnipc N(oipc)>osnc ∨(sqnipc N(oipc) =osnc∧dhopsipc N(oipc)≤hopsc ∧flagipc N(oipc) =val)/parenrightbig (13) (b) If a route reply is sent by a node ipc, diﬀerent from the destination of the route, then the content of ipc’s routing table must be consistent with the in formation inside the message. NR:*cast(rrep(hopsc,dipc,dsnc,∗,ipc))− −−−−−−−−−−−−−−−−−−−−− → ipN′ ∧ipc/ne}a⊔ionslash=dipc ⇒dipc∈kDipc N∧sqnipc N(dipc) =dsnc ∧dhopsipc N(dipc) =hopsc∧flagipc N(dipc) =val (14) Proposition 13 Any sequence number appearing in a route error message stems from an invalid destination andisequaltothesequencenumberforthatdestination in the sender’s routing table at the time of sending. NR:*cast(rerr(destsc,ipc))− −−−−−−−−−−−−−−− → ipN′ ∧(ripc,rsnc)∈destsc ⇒ripc∈iDip N∧rsnc=sqnip N(ripc)(15) 6.4 WellDeﬁnedness We have to ensure that our speciﬁcation of AODV is actually well deﬁned. Since many functions introduced in Section 4 are only partial, it has to be checked that these functions are either deﬁned when they are used, or are subterms of atomic formulas. In the latter case, those formula would evaluate to false(cf. Footnote 8). The ﬁrst proposition shows that the functions de ﬁned in Section 4 respect the data structure. In fact, these properties are required (or implied) by our data structure. Proposition 14 (a) In each routing table there is at most one entry for each destination. (b) In each store of queued data packets there is at most one data queue for each destination.(c) Whenever a set of pairs ( rip,rsn) is assigned to the variabledestsof typeIP⇀SQN, or to the ﬁrst argument of the function rerr, this set is a partial function, i.e., there is at most one entry ( rip,rsn) for each destination rip. Property (a) is stated in the RFC [39]. Next, we show that a function is used in the speciﬁ cation of AODV only when it is deﬁned, with nhopand σpﬂagas possible exceptions. In this paper, we only give the proof for update; for the remaining functions σroute,flag,dhops,precs,addpreRT ,head,tailand dropthe proofs are straightforward, inspecting the lo cations of function calls; detailed proofs can be found in [16, Section 7.4]. Proposition 15 In our speciﬁcation of AODV, the functionupdateis used only when it is deﬁned. The functions nhopandσpﬂagneed acloserinspection. Proposition 16 In our speciﬁcation of AODV, the function nhopis either used within formulas or if it is deﬁned; hence it is only used in a meaningful way. If one chooses to use lazy evaluation for conjunction, thennhopis only used where it is deﬁned. Lastly, the function σpﬂagiscalledonlyinPro.1inLine33,within a formula. Again, if one uses lazy evaluation for con junction, then σpﬂagis used only where it is deﬁned. 6.5 The Quality of Routing Table Entries Inthissectionwedeﬁneatotalpreorder ⊑diponrouting table entries for a given destination dip. Entries are ordered by the qualityof the information they provide. This order will be deﬁned in such a way that (a) the quality of a node’s routing table entry for dipwill only increase over time, and (b) the quality of valid routing tableentriesalongarouteto dipstrictlyincreasesevery hop (at least prior to reaching dip). This order allows us to prove loop freedom of AODV in the next section. A main ingredient in the deﬁnition of the quality preorder is the sequence number of a routing table en try. A higher sequence number denotes fresher infor mation. However, it generally is not the case that along a route to dipfound by AODV the sequence numbers are only increasing. This is since AODV increases the sequence number of an entry at an intermediate node when invalidating it. To “compensate” for that we in troduce the concept of a net sequence number . It is de ﬁned by a function nsqn:R→SQN nsqn(r) :=/braceleftbiggπ2(r) ifπ4(r) =val∨π2(r) = 0 π2(r)−1 otherwise .24 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Forn∈INdeﬁne n•−1 := max( n−1,0);hence inc(n)•−1 =n. Thennsqn(r)=π2(r)•−1 ifπ4(r)=inv. To model increase in quality, we deﬁne ⊑dipby ﬁrst comparing the net sequence numbers of two entries—a larger net sequence number denotes fresher and higher quality information. In case the net sequence numbers are equal, we decide on their hop counts—the entry with the least hop count is the best. This yields the following lexicographical order: Assume tworouting table entries r,r′∈Rwithπ1(r) =π1(r′) =dip. Then r⊑dipr′:⇔nsqn(r)<nsqn(r′) ∨(nsqn(r) =nsqn(r′)∧π5(r)≥π5(r′)). To reason about AODV, net sequence numbers and the quality preorder are lifted to routing tables. As for sqnwedeﬁneatotalfunctiontodeterminenetsequence numbers. nsqn:RT×IP→SQN nsqn(rt,dip) :=  nsqn(σroute(rt,dip)) ifσroute(rt,dip) is deﬁned 0 otherwise . :=  sqn(rt,dip) ifflag(rt,dip) =val sqn(rt,dip)•−1 otherwise . If two routing tables rtandrt′have a routing table entry to dip, i.e.,dip∈kD(rt)∩kD(rt′), the preorder can be lifted as well. rt⊑diprt′:⇔σroute(rt,dip)⊑dipσroute(rt′,dip) ⇔nsqn(rt,dip)<nsqn(rt′,dip)∨/parenleftbig nsqn(rt,dip) =nsqn(rt′,dip) ∧dhops(rt,dip)≥dhops(rt′,dip)/parenrightbig For all destinations dip∈IP, the relation ⊑dipon rout ing tables with an entry for dipis total preorder. The equivalencerelationinducedby ⊑dipisdenotedby ≈dip. As withsqn, we abbreviate nsqn:nsqnip N(dip) := nsqn(ξip N(rt),dip).Note that sqnip N(dip)•−1≤nsqnip N(dip)≤sqnip N(dip).(16) After setting up this notion of quality, we now show that routing tables, when modiﬁed by AODV, never decrease their quality. Proposition 17 Assume a routing table rt∈RTwith dip∈kD(rt). (a) Anupdateofrtcan only increase the quality of the routing table. That is, for all routes rsuch that update(rt,r) is deﬁned ( π4(r) =val,π2(r) = 0⇔ π3(r)=unkandπ3(r)=unk⇒π5(r)=1) we have rt⊑dipupdate(rt,r). (17)(b) Aninvalidate onrtdoes not change the quality of the routing table if, for each ( rip,rsn)∈dests,rt has a valid entry for rip, and –rsnis the by one incremented sequence number from the routing table, or –bothrsnand the sequence number in the rout ing table are 0. That is, for all partial functions dests(subsets of IP×SQN) /parenleftbig (rip,rsn)∈dests⇒rip∈vD(rt) ∧rsn=inc(sqn(rt,rip))/parenrightbig ⇒rt≈dipinvalidate (rt,dests).(18) (c) If precursorsareadded to an entry of rt, the quality of the routing table does not change. That is, for alldip∈IPand sets of precursors npre∈P(IP), rt≈dipaddpreRT (rt,dip,npre). (19) We can apply this result to obtain the following theo rem. Theorem 18 In AODV, the quality of routing tables can only be increased, never decreased. Assume Nℓ− → N′andip,dip∈IP. Ifdip∈kDip N, thendip∈kDip N′and ξip N(rt)⊑dipξip N′(rt). ProofIfdip∈kDip N, thendip∈kDip N′followsby Proposi tion 4. To show ξip N(rt)⊑dipξip N′(rt), by Remark 3 and Proposition 17(a) and (c) it suﬃces to check all calls of invalidate . Pro. 1, Line 28; Pro. 3, Line 10; Pro. 4, Lines 13, 29; Pro. 5, Line 17: By construction of dests(imme diately before the invalidation call) (rip,rsn)∈ξip N(dests) ⇒rip∈vD(ξip N(rt))∧rsn=inc(sqn(ξip N(rt),rip)) and hence, by Proposition 17(b), ξip N(rt)≈dip invalidate (ξip N(rt),ξip N(dests)) =ξip N′(rt). Pro. 6, Line 3: Assume that invalidate modiﬁes an entry having the form ( rip,dsn,∗,ﬂag,∗,∗,∗). Let (rip,rsn)∈dests; then the update results in the en try (rip,rsn,∗,inv,∗,∗,∗). Moreover, by Line 2 of Pro.6,ﬂag=val.Bydeﬁnitionofnetsequencenum bers, nsqn(ξip N(rt),rip) =sqn(ξip N(rt),rip) ≤rsn•−1 =nsqn(ξip N′(rt),rip). The secondstepholds,since sqn(ξip N2(rt),rip)<rsn, using Line 2. Since the hop count is not changed byinvalidate , we also have dhops(ξip N(rt),rip) = dhops(ξip N′(rt),rip), and hence ξip N(rt)⊑dipξip N′(rt). ⊓ ⊔Modelling and Verifying the AODV Routing Protocol 25 Theorem 18 states in particular that if Nℓ− →N′then nsqnip N(dip)≤nsqnip N′(dip). Proposition 19 If, in a reachable network expression N, a nodeip∈IPhas a routing table entry to dip, then also the next hop nhiptowards dip, if notdipitself, has a routing table entry to dip, and the net sequence number of the latter entry is at least as large as that of the former. dip∈kDip N∧nhip/ne}a⊔ionslash=dip ⇒dip∈kDnhip N∧nsqnip N(dip)≤nsqnnhip N(dip),(20) wherenhip:=nhopip N(dip) is the IP address of the next hop. To prove loop freedom we will show that on any route established by AODV the quality of routing tables in creases when going from one node to the next hop. Here, the preorder is not suﬃcient, since we need a strict increase in quality. Therefore, on routing tables rtandrt′that both have an entry to dip, i.e.,dip∈ kD(rt)∩kD(rt′), we deﬁne a relation ⊏dipby rt⊏diprt′:⇔rt⊑diprt′∧rt/ne}a⊔ionslash≈diprt′. Corollary 20 The relation ⊏dipis irreﬂexive and transitive. Theorem 21 The quality of the routing table entries for a destination dipis strictly increasing along a route towards dip, until it reaches either dipor a node with an invalid routing table entry to dip. dip∈vDip N∩vDnhip N∧nhip/ne}a⊔ionslash=dip ⇒ξip N(rt)⊏dipξnhip N(rt),(21) whereNis a reachable network expression and nhip:= nhopip N(dip) is the IP address of the next hop. ProofAs before, we ﬁrst check the initial states of our transition system and then check all locations in Pro cesses 1–7 where a routing table might be changed. For an initial network expression, the invariant holds since all routing tables are empty. Adding precursorsto ξip N(rt) orξnhip N(rt) does not aﬀect the invariant, since the invariant does not depend on precursors, so it suf ﬁcesto examineallmodiﬁcationsto ξip N(rt) orξnhip N(rt) usingupdateorinvalidate . Moreover, without loss of generality we restrict attention to those applications of updateorinvalidate that actually modify the entry fordip, beyond its precursors;if updateonly adds some precursors in the routing table, the invariant—which is assumed to hold before—is maintained. Applications of invalidate toξip N(rt) orξnhip N(rt) lead to a network state in which the antecedent of (21) is not satisﬁed. Now consider an application of updatetoξnhip N(rt). We restrict attention to the case that the antecedent of (21) is satisﬁed right after the update, so that right before the update we have dip∈vDip N∧ nhip/ne}a⊔ionslash=dip. In the special case that sqnnhip N(dip) = 0 right before the update, we have nsqnnhip N(dip)=0 and thusnsqnip N(dip) = 0 by Invariant (20). Considering thatflagip N(dip) =val, this implies sqnip N(dip) = 0. By Proposition 10(d) we have nhip=dip, contradicting our assumptions. It follows that right before the update sqnnhip N(dip)>0; so in particular dip∈kDnhip N. An application of updatetoξnhip N(rt) that changes flagnhip N(dip) frominvtovalcannot decrease the se quence number ofthe entry to dipand hence strictly in creases its net sequence number. Before the updatewe hadnsqnip N(dip)≤nsqnnhip N(dip) by Invariant (20), so afterwards we must have nsqnip N(dip)<nsqnnhip N(dip), and therefore ξip N(rt)⊏dipξnhip N(rt). Anupdateto ξnhip N(rt) that maintains flagnhip N(dip) =valcan only increasethequalityoftheentryto dip(cf.Theorem18), and hence maintains Invariant (21). It remains to examine the updates toξip N(rt). Pro. 1, Lines 10, 14, 18: The entry ξ(sip,0,unk,val, 1,sip,∅) is used for the update; its destination is dip:=ξ(sip). Sincedip=nhopip N(dip) =nhip, the antecedent of the invariant to be proven is not sat isﬁed. Pro. 4, Line 4: We assume that the entry ξ(oip,osn, kno,val,hops+1,sip,∗) is inserted into ξ(rt). So dip:=ξ(oip),nhip:=ξ(sip),nsqnip N(dip):=ξ(osn) anddhopsip N(dip) :=ξ(hops)+ 1. This information is distilled from a received route request message (cf. Lines 1 and 8 of Pro. 1). By Proposition 1 this message was sent before, say in state N†; by Pro position 7 the sender of this message is ξ(sip). By Invariant (13), with ipc:=ξ(sip)=nhip,oipc:= ξ(oip) =dip,osnc:=ξ(osn) andhopsc:=ξ(hops), and using that ipc=nhip/ne}a⊔ionslash=dip=oipc, we get that sqnnhip N†(dip) =sqnipc N†(oipc)>osnc=ξ(osn),or sqnnhip N†(dip) =ξ(osn)∧dhopsnhip N†(dip)≤ξ(hops) ∧flagnhip N†(dip) =val. We ﬁrst assume that the ﬁrst line holds. Then, by the assumption dip∈vD(ξnhip N(rt)), the deﬁnition of net sequence numbers, and Proposition 5, nsqnnhip N(dip) =sqnnhip N(dip)≥sqnnhip N†(dip) > ξ(osn) =nsqnip N(dip). and hence ξip N(rt)⊏dipξnhip N(rt). We now assume the second line to be valid. From this we conclude nsqnnhip N†(dip) =sqnnhip N†(dip) =ξ(osn) =nsqnip N(dip).26 R. van Glabbeek, P. H¨ ofner, M. Portmann, W.L. Tan Moreover, dhopsnhip N†(dip)≤ξ(hops)< ξ(hops)+ 1 =dhopsip N(dip). Hence ξip N(rt)⊏dipξnhip N†(rt). To gether with Theorem 18 and the transitivity of ⊑dip this yields ξip N(rt)⊏dipξnhip N(rt). Pro. 5, Line 2: This update is similar to the one of Pro. 4, Line 4. The only diﬀerence is that the in formation stems from an incoming RREP message and that a routing table entry to ξ(dip) (instead of ξ(oip))isestablished.Therefore,theproofissimilar to the one of Pro.4, Line 4; instead ofInvariant (13) we use Invariant (14). ⊓ ⊔ 6.6 Loop Freedom The “na¨ ıve”notionofloop freedom is aterm that infor mally means that “a packet never goes round in cycles without (atsomepoint) beingdelivered”.Thisdynamic deﬁnition is not only hard to formalise, it is also too restrictive a requirement for AODV. There are situa tions wherepacketsaresent incycles,but which arenot considered harmful. This can happen when the topol ogy keeps changing. We refer to [16, Sect. 7.6] for an example. Due to this dynamic behaviour, the sense of loop freedom is much better captured by a static invariant, saying that at any given time the collective routing tables of the nodes do not admit a loop. Such a re quirement does not rule out the dynamic loop alluded to above. However, in situations where the topology remains stable suﬃciently long it does guarantee that packets will not keep going around in cycles. To this end we deﬁne the routing graph of a net work expression Nwith respect to destination dipby RN(dip):=(IP,E),whereallnodesofthenetworkform the set of vertices and there is an arc ( ip,ip′)∈Eiﬀ ip/ne}a⊔ionslash=dipand (dip,∗,∗,val,∗,ip′,∗)∈ξip N(rt). An arc in a routing graph states that ip′is the next hop on a valid route to dipknown by ip; a path in a routing graph describes a route towards dipdiscovered by AODV. We say that a network expression Nisloop freeif the corresponding routing graphs RN(dip) are loop free, for all dip∈IP. A routing protocol, such as AODV, is loop free iﬀ all reachable network expressions are loop free. Using this deﬁnition ofarouting graph,Theorem21 states that along a path towards a destination dipin the routing graph of a reachable network expression N, until it reaches either dipor a node with an invalided routing table entry to dip, the quality of the routing table entries for dipis strictly increasing. From this, we can immediately concludeTheorem 22 The speciﬁcation of AODV given in Sec tion 5 is loop free. ProofIf there were a loop in a routing graph RN(dip), then for any edge ( ip,nhip) on that loop one has, by Theorem 21, ξip N(rt)⊏dipξnhip N(rt).Thus, by transitiv ity of⊏dip, one has ξip N(rt)⊏dipξip N(rt), which contra dicts the irreﬂexivity of ⊏dip(cf. Corollary 20). ⊓ ⊔ According to Theorem 22 any route to a destination dipestablished by AODV—i.e. a path in RN(dip)— ends after ﬁnitely many hops. There are three possible ways in which it could end: (1) by reaching the destination, (2) by reaching a node with an invalid entry to dip, or (3) by reaching a node without any entry to dip. (1) is what AODV attempts to accomplish, whereas (2) is an unavoidable due to link breaks in a dynamic topology. It follows directly from Proposition 19 that (3) can never occur. 6.7 Route Correctness The creation of a routing table entry at node ipfor des tinationdipis no guarantee that a route from iptodip actually exists. The entry is created based on informa tion gathered from messages received in the past, and at any time link breaks may occur. The best one could require of a protocol like AODV is that routing table entries are based on information that was valid at some point in the past. This is the essence of what we call route correctness . We deﬁne a historyof an AODVlike protocol as a sequence H=N0N1...Nkof network expressions, whereN0is an initial state of the protocol, and for 1≤i≤kthere is a transition Ni−1ℓ− →Ni; we call Ha historyofthe state Nk. Theconnectivity graph ofa his toryHisCH:=(IP,E), where the nodes of the network form the set of vertices and there is an arc ( ip,ip′)∈E iﬀip′∈Rip Nifor some 0 ≤i≤k, i.e. if at some point during that history node ip′was in transmission range ofip. A protocolsatisﬁes the property route correctness if for every history Hof a reachable state Nand for ev ery routing table entry ( dip,∗,∗,∗,hops,nhip,∗)∈ξip N(rt) there is a path ip→nhip→ ··· → dipinCHfromipto dipwithhopshops and (if hops>0) next hop nhip.24 Theorem 23 LetHbe a history ofa networkstate N. (a) For each entry ( dip,∗,∗,∗,hops,nhip,∗)∈ξip N(rt) there is a path ip→nhip→ ··· → dipinCHfrom iptodipwithhopshops and (if hops>0) next hop nhip. 24A path with 0 hops consists of a single node only.Modelling and Verifying the AODV Routing Protocol 27 (b) For each route request sent in state Nthere is a corresponding path in the connectivity graph of H. NR:*cast(rreq(hopsc,∗,∗,∗,∗,oipc,∗,ipc))−−−−−−−−−−−−−−−−−−−−−−→ ipN′ ⇒there is a path ipc→ ··· → oipcinCH fromipctooipcwithhopschops(22) (c) For each route reply sent in state Nthere is a cor responding path in the connectivity graph of H. NR:*cast(rrep(hopsc,dipc,∗,∗,ipc))− −−−−−−−−−−−−−−−−−−− → ipN′ ⇒there is a path ipc→ ··· → dipcinCH fromipctodipcwithhopschops(23) Theorem 23(a) says that the AODV protocol is route correct. For the proof it is essential that we use the version of AWN where a node ip′is in the range of nodeip, meaning that ip′can receive messages sent by ip, if and only if ipis in the range of ip′. If AWN is modiﬁed soastoallowasymmetricconnectivitygraphs, as contemplated in [15,16], it is trivial to construct a 2node counterexample to route correctness. A stronger concept of route correctness could re quire that for every history Hof a state Nand for each (dip,∗,∗,∗,hops,nhip,∗)∈ξip N(rt) –eitherhops= 0 and dip=ip, –orhops= 1 and dip=nhipand there is a N†inH such that nhip∈Rip N†, –orhops>1 and there is a N†inHwithnhip∈Rip N† and (dip,∗,∗,val,hops−1,∗,∗)∈ξnhip N†(rt). It turns out that this stronger form of route correctness does not hold for AODV. It can be violated when a node forwardsa routerequest without updating its own (fresher) routing table entry for the originator of the route request. 7 Related Work","This paper provides a formal specification of the Ad hoc On-Demand Distance Vector (AODV) routing protocol using the algebraic language AWN (Algebra of Wireless Networks). AWN provides the right level of abstraction to model key features such as unicast and broadcast, while abstracting from implementation details. As AWN is completely unambiguous, it enforces to tal precision and the removal of any ambiguities. A key contribution is to demonstrate how AWN can be used to support reasoning about protocol correctness",cool!
267,On the IP Traffic Matrix Problem in Hybrid SDN_OSPF Networks.txt,"IP networks with a hybrid control plane deploy a distributed routing protocol
like OSPF and the centralized paradigm of SDN in parallel. The advantages and
disadvantages of a hybrid control plane have already been extensively discussed
in the literature. This paper examines to what extent hybrid SDN/OSPF can solve
the IP traffic matrix and related monitoring problems, inherent to the IP
layer. The problem persists in hybrid networks, as the required SDN byte
counters for a complete traffic matrix may not be sufficiently implemented (or
even not at all), or the deployed SDN nodes may be too few, or not adequately
located in the network. For such cases, we propose to augment the SDN traffic
statistics with SNMP-based measurements on IP backup links. We address
implementation and network function virtualization aspects of the required
hybrid monitoring infrastructure and discuss the timing issues of the
measurements based on hands-on experiences in our lab. We furthermore provide a
placement algorithm for SDN nodes and backup links that can guarantee a
complete IP traffic matrix.","THE IP trafﬁc matrix determines the amount of trafﬁc transferred per second between any ingressegress pair of routers. It is essential for IP network operation and management, including tasks like trafﬁc engineering, routing protocol conﬁguration, security and reliability, capacity planning, and fault diagnosis. The trafﬁc matrix is however not readily available in legacy IP networks. The measuring of all ﬂows directly is not practical, as it requires a signiﬁ cant amount of monitoring equipment and network wide conﬁguration efforts [1]. Therefore, the trafﬁc matrix is usually estimated orsampled , both leading to inaccurate results that may adversely impact net work operations, due to faulty conﬁgurations based on uncertain trafﬁc statistics. Throughput statistics on a perlink basis (commonly referred to as link loads ) are easily available from all network nodes via Simple Network Management Protocol (SNMP) requests and are typically monitored by network operators. The mathematical relation of the three parameters link load, routing, and trafﬁc matrix is L=RF, where the link load of the n M. Caria and A. Jukan are with the Technische Universit ¨at CaroloWilhelmina zu Braunschweig, 38106 Braunschweig, Ger many, email:fm.caria, a.jukang@tubs.delinks in the network is the (given) column vector L= (l1;l2;:::;l n)T, the demand of all mingressegress (IE) ﬂows is the (sought) row vector F= (f1;f2;:::;f m), and the routing is represented by the (given) binary nmmatrixR, whererijis 1 if ﬂow jis routed via linki, and 0 otherwise. To put it more intuitively, the load on a link is the sum of all the IE ﬂows that traverse it. Due to the fact that link loads represent aggregated ﬂows with their number being (depending on the topology) easily an order of magnitude below the number of IE ﬂows, an attempt to solve the above lin ear system for Fresults in a heavily underdetermined linear system. The estimation of the trafﬁc matrix based on this statistical data means the search for a good solution of the described problem, which however typically exhibits severe estimation errors [2]. Traditionally, network operators used to deal with the problem either by signiﬁcant overprovisioning of network resources (which renders the exact knowledge of the trafﬁc matrix unnecessary), or by installing expensive monitoring equipment. However, the ad vent of SoftwareDeﬁned Networking (SDN) involves a new and powerful mechanism for network monitor ing, as SDNenabled devices provide additional byte counters for all individual entries in their forwarding tables. We assume that this mechanism will solve the trafﬁc matrix problem once and for all in the long run. Today, however, IP networks are likely to be implemented with a hybrid control plane deploy ing a distributed routing protocol like OSPF and the centralized paradigm of SDN in parallel. In hybrid networks, the known and difﬁcult problem to generate the IP trafﬁc matrix persists, as the required SDN byte counters may not be sufﬁciently implemented (or even not at all [3]), or the deployed SDN nodes may be too few, or not adequately located in the network. This paper examines a new approach to solve the IP trafﬁc matrix and the related monitoring problem in networks with a hybrid SDN/OSPF control plane. We propose to augment the SDNbased trafﬁc statistics with SNMPbased throughput measurements of the absent ﬂows, obtained by temporarily ofﬂoading them on IP backup links. We address implementation as pects of the required hybrid monitoring infrastructure and discuss the timing issues of the measurements based on handson experiences in our lab. We explain the technical background and possible methodical pit falls, outline the design of our framework, discuss our practical experiences with OpenFlow and linkbasedarXiv:1610.08256v1  [cs.NI]  26 Oct 20162 measurements in our testbed, and address the confor mity of our ideas with the novel paradigms in network management such as Network Function Virtualization (NFV). We ﬁnally provide an ILP model and a greedy heuristic to determine the optimal measurement loca tions for SDN nodes and backup links, and we show in our performance evaluation that there is a near linear tradeoff between both resources. We conclude from our results that a hybrid control plane with only a few SDN nodes can provide the complete trafﬁc matrix in case multiple backup links are available for measurements. The rest of the paper is organized as follows: Sec tion II discusses the related work and our contribution. Section III presents the assumed IP network architec ture, and Section IV explains our perﬂow measure ment technique, implementation and virtualization as pects, and our practical measurement experiences in a testbed. We furthermore present an analytical model for backup link and SDN node location optimization and a fast heuristic in Section V. Finally, Section VI presents the performance study and Section VII con cludes the paper. II. R ELATED WORK AND OUR CONTRIBUTION","The IP traffic matrix is essential for network operation and management, including tasks like traffic engineering, routing protocol configuration, security and reliability, capacity planning, and fault diagnosis. The traffic matrix is usually estimated or sampled, both leading to inaccurate results that may adversely impact network operations. The traffic matrix is usually estimated or sampled based on SNMP requests, both leading to inaccurate results that may adversely impact network operations. The traffic matrix is typically estimated or sampled based on SNMP requests, both leading to inaccurate results that may adversely impacting network operators",cool!
146,"Efficient energy, cost reduction, and QoS based routing protocol for wireless sensor networks.txt","Recent developments and widespread in wireless sensor network have led to
many routing protocols, many of these protocols consider the efficiency of
energy as the ultimate factor to maximize the WSN lifetime. The quality of
Service (QoS) requirements for different applications of wireless sensor
networks has posed additional challenges. Imaging and data transmission needs
both QoS aware routing and energy to ensure the efficient use of sensors. In
this paper, we propose an Efficient, Energy-Aware, Least Cost, (ECQSR) quality
of service routing protocol for sensor networks which can run efficiently with
best-effort traffic processing. The protocol aims to maximize the lifetime of
the network out of balancing energy consumption across multiple nodes, by using
the concept of service differentiation, finding lower cost by finding the
shortest path using nearest neighbor algorithm (NN), also put certain
constraints on the delay of the path for real-time data from where link cost
that captures energy nodes reserve, energy of the transmission, error rate and
other parameters. The results show that the proposed protocol improves the
network lifetime and low power consumption.","Wireless Sensor Networks (WSNs) are rapidly emanating as an important and influential factor in  mobile computing, wireless systems, and vehicular ad hoc networks [1], Also, WSNs play a major role in  facilitating the work of applications in a wide range of areas, such as earthquake monitoring, data traffic in  transportation, tracking goals in battlefields, habitat monitoring, fire system detection [2, 3, 4].  Wireless Sensor Networks (WSNs) may have millions of nodes, which are deployed over the wide  sensing area in different parameters. These Nodes broadcast their link quality, which is depending on radio  frequency environment [5]. The main purposes of WSNs are to monitor, analyze, combine and respond to the  data which are gathered by hundreds or thousands of sensors which are distributed in some sensing  field [6].  The power of WSNs lies in the capability of deploying significant numbers of tiny nodes that have  been configured by themselves, each of these sensing nodes contains a microcontroller, external memory,  power source, and transceiver. Figure 1 shows the internal components of a sensor node [1].  In this paper, (ECQSR) protocol proposes; Efficient Energy, Cost Reduction, and QoS based routing  protocol for WSNs, to achieve load balancing by splitting the data traffic among set of nodes which are  distributed in the field, in addition to efficiently balance the consumption of energy through multiple  nodes [7, 8].  Moreover, ECQSR works on increasing the reliability of the data delivery using forward error  correction (FEC) technology, also, increasing the throughput via presenting data redundancy, DataInternational Journal of Electrical and Computer Engineering (IJECE)  Vol. 9, No. 1, February 2019, pp. 496~504  ISSN: 20888708, DOI: 10.11591/ijece.v9i1.pp496504      496 Int J Elec & Comp Eng  ISSN: 20888708     Efficient energy, cost reduction, and QoS based routing protocol for wireless sensor…  (Ghassan Samara) 497 redundancy provides type of flexibility on the path failure, in addition to recover lost data, also it has the  possibility of reconstructing the original messages, ECQSR protocol finds the shortest path which has the  least cost by using the nearest neighbor algorithm (NN). This path meets the end to end delay requirements  [7], Figure 2 shows Pseudocode of the nearest neighbor algorithm (NN).          Figure 1. Internal components of a sensor node          Figure 2. KNN kernel algorithm pseudocode                                        ISSN: 20888708  Int J Elec & Comp Eng, Vol. 9, No. 1, February 2019 :  496  504 498 Figure 3 shows the flow chart of the shortest path which is determined by the NN algorithm.        Figure 3. Shortest path flow chart      2. RESEARCH PROBLEM  Providing energy efficient, least cost, and QoS based routing protocol between sensor nodes in a  particular sensing field is a challenging task, because of power consumption [9, 10, 11], data loss, topology  control, coverage, mobility, routing and other parameters [1]. All of these parameters are considered in the  proposed protocol. This protocol will work on finding an optimal solution for all of these challenges so that  the proposed ECQSR protocol based on the idea of extending the routing approach and determining the path  with least cost and energy efficient that satisfy certain end to end delay during transmission [7, 12, 13].  The link cost function is a function that captures transmission energy, reserve energy, error rate, and  other parameters. Our protocol aims to get the shortest path with least cost by using the nearest neighbour  algorithm (NN), which should meet the end to end delay requirements.      Int J Elec & Comp Eng  ISSN: 20888708     Efficient energy, cost reduction, and QoS based routing protocol for wireless sensor…  (Ghassan Samara) 499 3. LITERATURE REVIEW   QoS routing in wireless sensor networks (WSNs) is a challenging problem because of the poor  resources of the sensor nodes. Therefore, this issue has received increasing interest from the researchers,  where they have made many proposals; here are some of these proposals which relate to our protocol  (ECQSR):  Sequential Assignment Routing (SAR) protocol, which is one of the oldest protocols that concern in  routing protocols that provide some QoS. SAR is a multiple path routing protocol that helps in routing  decisions based on three aspects: QoS on each path, energy resources, and packet priority level. However,  SAR protocol suffers from the overhead of dealing with routing tables and QoS metrics at each sensor  node [1, 7].  K. Akkaya and M. Younis in proposed a clusterbased QoS aware routing protocol that employs a  queuing model to deal with both nonreal time and realtime traffic. This protocol suffers from the  transmission delay which is not considered in the estimation of the endtoend delay [1]. SPEED is  considered as another protocol of QoS based routing protocol that supports a soft realtime end to end  pledges; But the main problem of this protocol, that it does not consider the energy metric in its routing  protocol [1, 7].  Message initiate Constrained Based Routing (MCBR) mechanism. MCBR is composed of route  constraints, QoS requirement of messages, and specifications of constraintbased destinations, but it suffers  from a large number of control packets that yields more overhead [1]. Felemban et al. proposed multiple  paths and multiple speed Routing Protocol (MMSPEED) for probable QoS guarantee in WSNs, QoS is  provided in two domains: reliability domain, and timelines domain, this protocol suffers from dealing with  data redundancy [1].  X. Huang, Y. Faun has proposed a multiconstrained QoS multiple path routing (MCMP) protocol,  the objective of this protocol is to utilize the multipath to maximize the performance of the network with a  minimum cost of energy, but it does not get over the problem of power consumption completely [1].  Efficient, Least Cost, EnergyAware (ELCEA) QoS Protocol, which aims to extend the routing and finding  an efficient path using Dijkstra’s algorithm and least cost with consideration of endtoend delay during the  current connection, but it failed in giving more importance on Quality of Service requirements [1, 7].      4. RESEARCH OBJECTIVES  There is a set of objectives, which can be achieved through the use of our protocol (ECQSR),  all these objectives must be compatible with each other. Figure 4 shows the relations between these  objectives [8, 14].          Figure 4. ECQSR objectives relationship                    ISSN: 20888708  Int J Elec & Comp Eng, Vol. 9, No. 1, February 2019 :  496  504 500 where: (NB)=networkbattery life; (QoS)=quality of service; (D)=delay; (EE)=energy efficiency;  (Cost)=total cost of the system; (T)=throughput system; (Cov)=coverage; (PER)=packet error rate.  These different objectives may conflict or not with each other; Different objectives are associated  together with various types of lines depending on the relationship between these objectives. The red line  connects two objectives which are a conflicting relationship, for example, maximization the coverage  conflicts with the delay, packet error rate, total cost of the system, and the networkbattery lifetime. Whereas,  the blue dashes and dots lines that connect two objectives mean that they have no direct relationship with  each other [14].  The most important desired objectives of the ECQSR protocol are summarized as follows:   To Keep the sensor nodes working as much as possible, Therefore, extending the lifetime of the network   To Reduce the cost by selecting the shortest path which is produced by using nearest neighbor algorithm  (NN), which meets the end to end delay requirements (minimizing the cost of the system)   To Maximize the coverage and the throughput of the network.   To Minimize energy consumption and packet error rate.      5. METHODOLOGY","Wireless Sensor Networks (WSNs) are rapidly emerging as an important and influential factor in mobile computing, wireless systems, and vehicular ad hoc networks. The main purposes of WSNs are to monitor, analyze, combine and respond to the data which are gathered by hundreds or thousands of sensors which are distributed in a sensing field. In this paper, (ECQSR) protocol proposes; Efficient Energy, Cost Reduction, and QoS based routing protocol for WSNs, to achieve load balancing by splitting the data traffic among the nodes, in addition",cool!
349,Simulation-Based Performance Evaluation of Routing Protocols in Vehicular Ad-hoc Network.txt,"A Vehicular Ad-hoc Network (VANET) is a collection of wireless vehicle nodes
forming a temporary network without using any centralized Road Side Unit (RSU).
VANET protocols have to face high challenges due to dynamically changing
topologies and symmetric links of networks. A suitable and effective routing
mechanism helps to extend the successful deployment of vehicular ad-hoc
networks. An attempt has been made to compare the performance of two On-demand
reactive routing protocols namely AODV and DSR which works on gateway discovery
algorithms and a geographical routing protocol namely GPSR which works on an
algorithm constantly geographical based updates network topology information
available to all nodes in VANETs for different scenarios. Comparison is made on
the basis of different metrics like throughput, packet loss, packet delivery
ratio and end-to-end delay using SUMO and NS2 simulator. In this paper we have
taken different types of scenarios for simulation and then analysed the
performance results.","ANET is autonomous and self organizing wireless ad hoc  communication network. In this network vehicles are called  nodes which involve themselves peer topeer for communication  of information. This is new technology in India thus government  has taken a huge attention on it. Many research projects related  VANET are COMCAR [1], DRIVE [2], FleetNet [3] and NoW  [4], CarTALK 2000 [5], CarNet [6]. Many different VANET  applications such  as Vehicle Collision Warning, Security  Distance Warning, Driver Assistance, Cooperative Cruise  Control, Dissemination of Road Information, Internet Access,  Map Location, Automatic Parking and Driverless Vehicles. In  this research paper we have analysed th e performance of AODV  DSR and GPSR routing protocol on CBR connection pattern  with different pause time, speed time also different network  parameters and different measured performance metrics such as  Packet Delivery Ratio, Packet Loss, Throughput and End toEnd  Delay of this three routing protocols are compared for their  performance analysis.       II. VEHICULAR AD HOC NETWORK ROUTING PROTOCOLS           An ad hoc routing protocol is a standard [9 10], that  controls how vehicle nodes decide in which way to route t he packets between computing device in vehicular ad hoc network.  There are different types of routing protocol in VANET such as  proactive routing protocol, reactive routing protocol, hybrid  routing protocol, topology based routing protocols and position  based routing protocols. Existing unicast routing protocols of  VANET is not capable to meet every traffic on highway road  scenarios. They have also had some advantages and  disadvantages. We have selected two reactive routing protocols  i.e. AODV and DSR and o ne position based routing protocol i.e.  GPSR for simulation purpose analysis.      Adhoc On Demand Distance Vector Routing Protocol (AODV)           It is purely On Demand route acquisition routing protocol.  It is better protocol than DSDV network as the size  of network  may increase depending on the number of vehicle nodes [7] [12].     Path Discovery Process [8] [12]           In order to discover the path between source and  destination, a route request message (RREQ) is broadcasted to all  the neighbours who again  continue to send the same to their  neighbours, until the destination is reached. Every node  maintains two counters: sequence number and broadcast id in  order to maintain loop free and most recent route information.  The broadcast id is incremented for ever y RREQ the source node  initiates. If an intermediate node receives the same copy of  request, it discards it without routing it further. When a node  forwards the RREQ message, it records the address of the  neighbour from which it received the first copy of the broadcast  packet, in order to maintain a reverse path to the source node.  The RREQ packet contains: the source sequence number and the  last destination sequence number know to the source. The source  sequence number is used to maintain information about  reverse  route and destination sequence number tells about the actual  distance to the final node.      V   International Journal of Scientific and Research  Publications, Volume 3, Issue 10, October  2013       2  ISSN 2250 3153   www.ijsrp.org     Figure 1 AODV Path Discovery Process     Route Maintenance [12]           A moving source node sends a new RREQ request packet to  find a new route to the dest ination. But, if an intermediate node  moves from its place, its upstream neighbour notices the move  and sends a link failure notification message to each of its active  upstream neighbours to inform them about the move until the  source nodes is reached. Aft er that the discovery process is again  initiated.     III. DYNAMIC SOURCE ROUTI NG PROTOCOL (DSR) [8] [12]          It is an On Demand routing protocol in which the sequence  of nodes through which a packet needs to travel is calculated and  maintained as an informati on in packet header. Every mobile  node in the network needs to maintain a route cache where it  caches source routes that it has learned. When a packet is sent,  the route cache inside the node is compared with the actual route  needs to be covered. If the re sult is positive, the packet is  forwarded otherwise route discovery process is initiated again.     A. Route Discovery           The source node broadcasts request packets to all the  neighbours in the network containing the address of the  destination node, and a r eply is sent back to the source node with  the list of network nodes through which it should propagate in  the process. Sender initiates the route record as a list with a  single element containing itself followed by the linking of its  neighbour in that route . A request packet also contains an  identification number called request id, which is counter  increased only when a new route request packet is being sent by  the source node. To make sure that no loops occur during  broadcast, the request is processed in th e given order .   If the pair (source node address, request id) is found  in the list of recent route requests, the packet is  discarded.    If the host’s address is already listed in the request’s  route record, then also the packet is discarded  ensuring the remov al of later copies of the same  request that arrive by using a loop.    When a destination address in the route request  matches the host’s address, a route reply packet is  sent back to the source node containing a copy of this  route.    Otherwise, add this host’s  address to the route record  field of the route request packet and rebroadcast the  packet.     Figure 2 DSR Route Discovery Process               A route reply is obtained in DSR by two ways: Symmetric  links (bidirectional), in which the backward route is follow ed  again to catch the source node. Asymmetric links (unidirectional)  needs to discover the route up to the source node in the same  manner as the forward route is discovered.     B. Route Maintenance           It can be accomplished by two ways: 1) Hop byHop  ackno wledgement at the data link layer.   2) End toEnd acknowledgements.             The first method allows the early detection and  retransmission of lost or corrupt packets in the data link layer. If  a transmission error occurs, a route error packet containing th e  address of node detecting the error and the host address is sent  back to the sender. Whenever a node receives a route error  packet, the hop in error is removed from the route cache and all  routes containing this hop are truncated at that point. When the  wireless transmission between two nodes does not work equally  well in both directions, and then end toend replies on the  application or transport layer may be used to indicate the status  of the route from one host to the other.     IV. GREEDY  PERIMETER  STATELESS  ROUTING   PROTOCOL  (GPSR)            Greedy Perimeter Stateless Routing (GPSR) [25] is one of  the best examples of position based routing. GPSR uses closest  neighbours information of destination in order to forward packet.  This method is also known as greedy forwarding. In GPSR each  node has knowledge of its current physical position and also the  neighbouring nodes. The knowledge about node positions  provides better routing and also provides knowledge about the  destination. On the other hand neighbouring nodes  also assists to  make forwarding decisions more correctly without the  interference of topology information. All information about International Journal of Scientific and Research  Publications, Volume 3, Issue 10, October  2013       3  ISSN 2250 3153   www.ijsrp.org  nodes position gathered through GPS devices. GPSR protocol  normally devised in to two groups:    Greedy forwarding: This is used to send data to the  closest nodes to destination.    Perimeter forwarding: This is used to such regions  where there is no closer node to destination.             In other words we can say it is used where greedy  forwarding fails. Further we will see in detail ho w these  forwarding strategy works and what are issues in them.     A. Greedy Forwarding           In this forwarding strategy data packets know the physical  position of their destination. As the originator knows the position  of its destination node so the greedy r egions/hops are selected to  forward the packets to the nodes that are closer to their  destination. This process repeats until the packet successfully  delivered to desired destination. Nearest neighbor’s physical  position is gathered by utilizing beaconing algorithms or simple  beacons. When a neighboring node forwards packet to closer  region to destination, the forwarding node receive a beacon  message that contain IP address and position information. Then it  updates its information in the location table. If forwarding node  does not receive beacon from its neighboring node within a  specific time period, it assumes that either neighbor fails to  forward packet to region closer to destination or neighbor’s is not  in its radio range. So it removes its entry from l ocation table [25].  The major advantage of greedy forwarding is that it holds current  physical position of forwarding node. Thus by using this strategy  total distance to destination becomes less and packets can be  transmitted in short time period. Besides its advantages there are  few drawbacks of this strategy i.e. there are some topologies used  in it that limits the packet to move to a specific range or distance  from the destination. Furthermore, this strategy fails when there  are no closer neighbours avai lable to destination.     B. Perimeter Forwarding           Perimeter forwarding is used where greedy forwarding fails.  It means when there is no next hop closest neighbour to the  destination is available then perimeter forwarding is used.  Perimeter forwarding use s nodes in the void regions to forward  packets towards destination. The perimeter forwarding used the  right hand rule. In right hand rule [25], the voids regions are  exploited by traversing the path in counter clockwise direction in  order to reach at speci fic destination. When a packet forward by  source node, it forwarded in counter clockwise direction  including destination node until it again reached at the source  node. According to this rule each node involved to forward  packet around the void region and each edge that is traversed are  called perimeter. Edges may cross when right hand rule finds  perimeter that are enclosed in the void by utilizing heuristic  approach [24]. Heuristic has some drawbacks besides it provides  maximum reach ability to destination . The drawback is that it  removes without consideration of those edges which are repeated  and this may cause the network partitions. To avoid this  drawback another strategy is adopted that is described below.        C. Planarized Graph           When two or more ed ges cross each other in a single graph  is called planar graph. Relative Neighbourhood Graph (RNG)  and Gabriel Graph (GG) [25] are two types of planar graphs used  to remove the crossing edges. Relative neighbourhood graph  (RNG) is defined as, when two edges  intersect with radio range  of each other and share the same area. For example, x and y are  the two edges that share the area of two vertices x and y. The  edge x, y are removed by using RNG because another edge from  x towards v is already available Figure 3. Gabriel Graph (GG) is  used to remove only those crossing edges which are in between  the shared area of two nodes having the same diameter as the  other nodes have. Figure 4 depicts GG: shows that the midpoint  diameter is less than the diameter of node x or node y. Thus the  edge from the x, y cannot be removed. So there is less network  disconnection in the GG as compared to RNG.       Figure 3 Example of RNG     Figure 4 Example of GG     D. Features of GPSR           GPSR combines the greedy forwarding with the perime ter  forwarding to provide better routing decision on both full and  Planarized network graph by maintaining neighbour’s  information in the location table. For the forwarding decisions in  perimeter mode GPSR packet header include the following  distinct chara cteristics [11].    GPSR packet header has the flag identity that is used to  identify whether packet is in greedy forwarding or in  perimeter forwarding.    It contains destination node physical address.    GPSR packet header also contains location of packet in  the perimeter mode and the location of the new face to  take a decision whether to hold the packet in the  perimeter mode or to return it to the greedy mode.    GPSR also have the record of sender and receivers  address of the packet when the edge’s crosses in the  new face.             GPSR also have several distinct characteristics that are if  the packet is in perimeter mode then its location address is International Journal of Scientific and Research  Publications, Volume 3, Issue 10, October  2013       4  ISSN 2250 3153   www.ijsrp.org  compared to forwarded node address and if distance to location  and destination node is less then packet it switched t o greedy  mode to forward packet towards destination. GPSR discard those  packets that are repeatedly forwarded as destination for such  packets are not in range. The packets in perimeter mode never  send twice through the same link if destination is in range.   Overall GPSR is an efficient example of the position based  routing that uses the geographic location of nodes and reduced  usage of routing state on each node. Furthermore, it provides  maximum robustness in highly dynamic wireless ad hoc  networks.     E. Issue i n GPSR           Besides GPSR certain characteristics, it suffers from several  drawbacks. Greedy forwarding measured as unsuitable for the  vehicular networks where the nodes are highly mobile and the  node may not be able to maintain its next hop neighbours  information as the other node may gone out of range due to high  mobility. This can lead to data packets loss. The second problem  may occur during beaconing mechanism that beacons may lost  due to channel destruction or bad signal. This problem can lead  to re moval of neighbour information from location table [13].  GPSR uses Planarized graphs as its repair strategy where greedy  forwarding fails. But these graphs perform well in the highway  scenario due to their distributed algorithms [14]. These graphs  does not  perform well in such environment of vehicular  communication where a lot of radio obstacles involves, in  addition to this their distributed nature may lead to certain  partition of network and may lead to packet delivery impossible.  Hence there is need of s uch position based routing protocols,  which merge position information with the road topological  structure in order to make possible vehicular communication in  presence of radio obstacles.     V. PROBLEM  STATEMENT           The objective of the work is to compare the performance of  the three routing protocols based on On Demand Behavior, i.e.  Adhoc On Demand Distance Vector (AODV), Dynamic Source  Routing (DSR) [8] [15] and Greedy Perimeter Stateless Routing  (GPSR) protocols, for wireless ad hoc networks based on t he  performance and comparison has been made on the basis of their  properties like throughput, packet delivery ratio (PDR), end to end delay and data packet loss with respect to different scenarios    one by varying the number of nodes, again by varying the   mobility of the nodes, again by varying the number of connecting  nodes at a time and lastly by varying pause time.     The general objectives can be outlined as follows:   1) Study of Ad hoc Networks   2) Get a general understanding of Vehicular Ad hoc  Networks   3) Study  of different types of VANET Routing Protocol  4) Detailed study of AODV, DSR and GPSR   5) Generate a simulation environment that could be used  for simulation of protocols   6) Simulate the protocols on the basis of different  scenarios: by varying the number of nodes a nd by  varying the traffic in the network   7) Discuss the result of the proposed work and concluding  by providing the best routing protocol.   VI. METHODOLOGY","In this paper we have analysed the performance of AODV DSR and GPSR routing protocols on CBR connection pattern with different pause time, speed time also different network parameters and different measured performance metrics such as Packet Delivery Ratio, Packet Loss, Throughput and End to End Delay. We have selected two reactive routing protocols i.e. AODV and DSR and one position based routing protocol i.e. GPSR for simulation purpose analysis. We have compared the performance of these three different measured performance metrics such as Packet Delivery Rati",cool!
5,Key rate of quantum key distribution with hashed two-way classical communication.txt,"We propose an information reconciliation protocol that uses two-way classical
communication. In the case of the BB84 protocol and the six-state protocol, the
key rates of the quantum key distribution (QKD) protocols that use our proposed
information reconciliation protocol are higher than previously known protocols
for wide range of error rates. We also clarify the relation between the
proposed protocol and known QKD protocols, and the relation between the
proposed protocol and entanglement distillation protocols (EDPs).","Quantum key distribution (QKD) protocols provide a way for two parties, a sender, Alice, and a receiver, Bob, to share an unconditionally secure key in the presence of an eavesdropper, Eve. Unlike conventional schemes of key distribution that rely on unproven computational assumptions,thesecurityofQKDprotocolsisguaranteed by the principles of quantum mechanics. QKDprotocolsusuallyconsistoftwoparts, aquantum andaclassicalpart. AlicesendsabinarysequencetoBob in the quantum part by encoding it into quantum states that are randomly chosen from a set of nonorthogonal states. Since unknown nonorthogonal states cannot be cloned perfectly, any eavesdropping attempt by Eve will disturb the transmitted quantum states. Thus, by esti mating the error rate of the transmitted quantum states, Alice and Bob can estimate the amount of information that Eve has gained. For the sequence that remains after the error estimation phase, which is usually called the raw key, Alice and Bob ﬁrst carry out an information reconciliation (IR) protocol [1] to share the same bit se quence. Alice and Bob then distill the ﬁnal secure key by conducting a privacy ampliﬁcation (PA) protocol [2]. The bestknown QKD protocols are the Bennett Brassard 1984 (BB84) protocol [3] and the sixstate pro ∗Part of this paper will be presented at the 2007 IEEE Interna tional Symposium on Information Theory, Acropolis Congres s and Exhibition Center, Nice, France, 24th–29th June 2007, and w ill be published in its proceedings without proofs. †Electronic address: shunwata@it.ss.titech.ac.jp ‡Electronic address: ryutaroh@rmatsumoto.org; URL:http://www.rmatsumoto.org/research.html §Electronic address: uyematsu@ieee.org ¶Electronic address: kawano@theory.brl.ntt.co.jptocol [4]. The unconditional security of the BB84 pro tocol has been proved [5, 6, 7]. Shor and Preskill [8] presented a simple proof of the BB84 protocol by show ing that the QKD protocol that uses the entanglement distillation protocol (EDP) [9, 10] can be converted into the BB84 protocol. After that, the unconditional secu rity of the sixstate protocol was proved [11] by using the same technique as Shor and Preskill used [8]. Recently, the security of generic QKD protocols that include the BB84protocolandthe sixstateprotocolhasbeen proved [12, 13, 14], which are based on information theoretical techniques instead of Shor and Preskill’s technique. In addition to the security of QKD protocols, the key ratesofQKDprotocolsarealsoimportant, where the key rate is deﬁned by the ratio of the length of the ﬁnal se cure key to the length of the raw key. Gottesman and Lo [15] converted EDPs that use twoway classical commu nication into QKD protocols that use the same commu nication. More speciﬁcally, they proposed preprocessing that uses twoway classical communication. By insert ing this twoway preprocessing before the conventional oneway IR protocol, the key rates of QKD protocols are increased when the error rate of a channel expressed as a percentage is more than about 9 %. Indeed, the tolerable error rate of the BB84 protocol is increased from 11 % to 18.9 %, and that of the sixstate protocol is increased from 12.7 % to 26.4 %, where the tolerable error rate is the error rate at which the key rate becomes zero. Chau later showed that the twoway BB84 protocol can tol erate 20.0 % error rate, and that the twoway sixstate protocol can tolerate 27.6 % error rate [16]. Recently, this kind of twoway preprocessing has been applied to QKD protocols with weak coherent pulses [17, 18]. It should be noted that this preprocessing is also known within the classical key agreement context, in which it is usually called an advantage distillation protocol [19]. Bae and Ac´ ın and Ac´ ın et al. [20, 21] extensively studied2 the noise toleranceof QKDprotocols with advantagedis tillation protocols, on the other hand, we are interested in the key rates of QKD protocols in this paper. Vollbrecht and Vestraete proposed a new type of two wayEDP [22]. This protocol uses previouslysharedEPR pairs as an assistant resource (twoway breeding EDP), and the distillation rate of this EDP exceeds that of one way EDPs for a whole range of ﬁdelities, where a ﬁdelity is that between the initial mixed state and the EPR pair. Usingthe fact that abreedingEDPcan be convertedinto aQKDprotocolassistedbyonetimepadencryptionwith a preshared secret key [23], Vollbrecht and Vestraete’s twoway breeding EDP [22] was converted into a two way QKD protocol assisted by onetime pad encryption [17, 24]. The key rate of the converted QKD protocol is higher than that of oneway QKD protocols [8, 11] for a whole range of error rates. It should be noted that the use of a preshared secret key is not the basis of their improvement, because any QKD protocol that makes use of a preshared key can be transformed into an equally eﬃcient protocol that does not need a preshared secret key [25]. We propose an IR protocol that uses twoway classi cal communication in this paper. Our proposed protocol is based on Vollbrecht and Vestraete’s idea of twoway breeding EDP [22], but does not require any preshared secret keys. Furthermore, our protocol does not leak information that is redundantly leaked to Eve [17, 24]. More precisely, in these protocols [17, 24], Alice sends a redundant message that is useless to Bob, but is useful to Eve. However, in the proposed protocol, Alice does not send that redundant information. As a result, for the BB84 and sixstate protocol, the key rates of the QKD protocols that use our IR protocol are higher than those of previously known protocols for a wide range of error rates. Especially, the key rate of our protocol is higher than those of known protocols [8, 11, 13, 24] for the whole range of error rates. We also show the relation between the proposed protocol and the advantage dis tillation protocol, i.e., the Bstep of Gottesman and Lo [15] (Remark 4). We also show the relation between the proposed QKD protocol and Vollbrecht and Vestraete’s EDP. As a results, it turns out that there does not seem tobeanyEDPthatcorrespondstoourproposedprotocol (Remark 5). The rest of this paper is organized as follows. Section II proposes a twoway IR protocol. Section III presents the key rate formula of the QKD protocol that uses our proposed IR protocol. There is a proof of the key rate formula in the Appendix D. Section IV presents the key rate formula as a function of error rate. The proof of this formula is presented in Appendix E.II. TWOWAY INFORMATION RECONCILIATION PROTOCOL We propose an IR protocol that uses twoway classical communication (called twowayIR protocol after this) in this section. When Alice and Bob have correlated classi cal sequences, x,y∈F2n 2, the purpose of IR protocols for Alice and Bob is to share the same classical sequence by exchanging messages over a public authenticated chan nel, where F2is the ﬁeld of order 2. Here, we assume that the pair of sequences ( x,y) is independently iden tically distributed (i.i.d) according to a joint probability distribution, PXY, onF2×F2. Let us review some notations for a linear code to de scribe our IR protocol. An [ n,n−m] linear code, Cn,m, is an (n−m)dimensional linear subspace of Fn 2. Then, a parity check matrix, MCn,m, of code Cn,mis anm×n matrix of rank mwith 0,1 entries such that cMT Cn,m=0 for anyc∈ Cn,m, whereMT Cn,mis the transpose ma trix ofMCn,m. A decoder, gCn,m, of code Cn,mis a map from a syndrome, t∈Fm 2, to an error, e∈ D(t), where D(t) :={e∈Fn 2|eMT Cn,m=t}is the set of errors whose syndromes are t. After this, we will assume that a lin ear code is implicitly speciﬁed with a parity check matrix and a decoder. We need to deﬁne some auxiliary random variables to describe our IR protocol. Let ξ1:F2 2→F2be a func tion deﬁned as ξ1(a1,a2) :=a1+a2fora1,a2∈F2, and letξ2:F2 2→F2be a function deﬁned as ξ2(a,0) :=a andξ2(a,1) := 0 for a∈F2. For a pair of joint random variables (( X1,Y1), (X2,Y2)) with a distribu tion,P2 XY, deﬁne random variables U1:=ξ1(X1,X2), V1:=ξ1(Y1,Y2) andW1:=U1+V1. Furthermore, deﬁne random variables U2:=ξ2(X2,W1),V2:=ξ2(Y2,W1) andW2:=U2+V2. For the pair of sequences, x= (x11,x12,...,x n1,xn2) andy= (y11,y12,...,y n1,yn2), which is distributed according to the product distribu tion,P2n XY, letu,vandwbe 2nbit sequences such that ui1:=ξ1(xi1,xi2), vi1:=ξ1(yi1,yi2), wi1:=ui1+vi1 and ui2:=ξ2(xi2,wi1), vi2:=ξ2(yi2,wi1), wi2:=ui2+vi2 for 1≤i≤n. Then, the pair ( u,v) is distributed according to the distribution, Pn U1U2V1V2, and the dis crepancy, w, between uandvis distributed accord ing to the distribution, Pn W1W2. For sequence w, let Tb:={j|1≤j≤n, wj1=b}be the set of indices of blocks such that the parities of the discrepancies are b. For the subsequence, u2:= (u12,...,u n2), letu2,Tbbe the subsequence that consists of the ith bit of u2such thati∈Tb. Wellknown methods [15, 19, 22] of twoway process ing within the key distillation context have been to clas sify blocks of length 2 according to the parity, wi1, of the discrepancies in each block. In conventional two way processing of the key distillation protocols [15, 19],3 which is socalled advantage distillation protocols, Al ice sends the parity sequence, u1:= (u11,...,u n1), to Bob so that he can identify the parity sequence, w1:= (w11,...,w n1), of the discrepancies. Then, Al ice and Bob discard u1andv1:= (v11,...,v n1) respec tively, because u1is revealed to Eve. Furthermore, Al ice and Bob discard the second bit of the ith block, if the parity of the discrepancies is 1, i.e., i∈T1. Fi nally, Alice and Bob undertake an error correction pro cedure for the subsequences ( u2,T0,v2,T0). More pre cisely, Alice sends the syndrome, t2:=u2,T0MT Cn0,m0, for the prescribed [ n0,m0]linear code, and then Bob de codesˆ w2,T0:=gCn0,m0(t2+v2,T0MT Cn0,m0) and obtains v2,T0+ˆ w2,T0, wheren0:=|T0|is the cardinality of the set,T0. Our twowayIR protocol, which is based on Vollbrecht and Vestraete’sidea oftwowayEDP[22], is quite similar tothe previouslydescribedtwowayprocessingexceptfor one signiﬁcant change. As is usual in information theory, if we allow negligible error probability, Alice does not need to send the parity sequence, u1, to Bob to identify parity sequence w1. More precisely, Bob can decode w1 with negligible decoding error probability if Alice sends a syndrome, t1:=u1MT Cn,m, for a linear code such that the rate ism n≃H(PW1) [26, Corollary 2]. Since Eve’s available information from syndrome t1is much smaller than thatfrom sequence u1itself, ourIRprotocolismore eﬃcient than the abovementionedtwowayprocessingin most cases, which will be discussed in Section IV. Our IR protocol is formally executed as follows, where the tilde˜and hatˆon a sequence, a set or a number indicate that they are guessed versions of those without these su perscripts. Note that the inputs of the IR protocol are Alice’s bit sequence xand Bob’s bit sequence y, and the outputs of the IR protocol are a sequence, ˆu, guessed by Alice and a sequence, ˜u, guessed by Bob. (i) Alice locally computes u1and Bob does the same forv1. (ii) For a prescribed [ n,n−m] linear code, Cn,m, Alice sends syndrome t1=u1MT Cn,mto Bob. (iii) Bob decodes ˆw1:=gCn,m(t1+v1MT Cn,m), and sends ˆw1to Alice. (iv) Alice computes ˆu2. If the number, ˆ n0:=|{i| ˆwi1= 0}|, of blocks such that the guessed par ity, ˆwi1, of the discrepancies is 0 does not satisfy n0≤ˆn0≤n0for prescribed integers, n0andn0, then Bob randomly guesses ˆu2,ˆT0. Otherwise, Al ice sends the syndrome, ˆt2:=ˆu2,ˆT0MCˆn0,ˆm0, for a prescribed [ˆ n0,ˆn0−ˆm0] linear code, Cˆn0,ˆm0. (v) Bob decodes ˜w2,ˆT0:=gCˆn0,ˆm0(ˆt2+ˆv2,ˆT0MT Cˆn0,ˆm0), and obtains ˜u2,ˆT0:=ˆv2,ˆT0+˜w2,ˆT0.Note that ˆu2,ˆT1andˆv2,ˆT1are set to all 0s in our pro tocol, which is mathematically equivalent to discarding them. According to the universal channel coding theorem for the linear code [26, Corollary 2], ratesm n=H(PW1)+δ andˆm0 ˆn0=H(PW2|W1=0)+δfor smallδ>0 are suﬃcient for Bob to decode w1andw2,T0with negligible decoding error probability. Furthermore, we set n0:=n(PW1(0)− δ) andn0:=n(PW1(1)+δ) to satisfy the condition, n0≤ ˆn0≤n0, in Step (iv) with high probability. Remark 1 Sincewe cannotestimatethe probabilitydis tribution of error exactly in QKD protocols and the actual distribution ﬂuctuates around the estimated er ror distribution, universality of codes is required. Even though the distribution of errors in the QKD protocols are not necessarily i.i.d., it is suﬃcient to consider a uni versality condition on codes for the i.i.d. case. More precisely, it is suﬃcient to use a linear code such that the decoding error probability of the linear code is uni versally small for any binary symmetric channel whose crossover probability is close to the estimated error rate. Such observations were ﬁrst pointed out by Hamada [27]. Eﬃciently decodeable linear codes such as the low den sity parity check matrix code [28] and the turbo code [29] satisfy this condition. III. SECURITY OF QKD AND KEY RATE This section presents the asymptotic key rate of QKD protocols that employs the IR protocol proposed in Sec tionII. Theasymptotickeyrateisderivedbythesecurity proof method [12, 13, 14]. Weimplementaprepareandmeasureschemeinaprac tical QKD protocol. However, when we analyze the secu rity of a QKD protocol, it is usually more convenient to consider its entanglementbased version. Without com promising security, we can assume that Alice and Bob’s raw keys and bit sequences for error estimation are ob tained by measuring a bipartite state, ρANBN, on anN pair of bipartite systems ( HA⊗HB)⊗N, thatρANBNis invariant under the permutation of the systems [42], and that Eve canaccess Tr ANBN[ρANBNEN] for a puriﬁcation ρANBNENofρANBN(see also [12, 13]). The speciﬁc form ofρANBNdepends on which scheme Alice and Bob em ploy to transmit a binary sequence, noise in the channel, and Eve’s attack. From [14, Lemma 4.2.2], without loss of generality, we can assume that puriﬁcation ρANBNEN lies on the symmetric subspace of ( HA⊗HB⊗HE)⊗N, because any puriﬁcation can be transformedinto another puriﬁcation using Eve’s local operation. Before the protocol is started, Alice and Bob discard the lastksubsystems, H⊗k A⊗ H⊗k B, for technical rea sons of security proof. More speciﬁcally, ksubsystems are discarded to apply the de Finetti style representa tion theorem [14, Theorem 4.3.2] (see also [30]) in the security proof. Therefore, we set N:= 2n+m+k.4 Then, Alice and Bob conduct the protocol for the state, ρA2n+mB2n+m:= Trk[ρANBN], wherekis the number of discardedsystems, misthenumberofsystemsforparam eter estimation, and 2 nis the number of systems that are used for key distillation. First,AliceandBobundertakethefollowingparameter estimationprotocolforthelast msubsystemsofthestate ρA2n+mB2n+m. The parameter estimation protocol is con ducted to estimate the number of discrepancies between Alice and Bob’s raw keys, and the amount of information that Eve has gained by eavesdropping. (i) Alice and Bob carry out a bipartite positive opera torvaluedmeasurement(POVM), M:={Ma}a∈A, for each system, HA⊗ HB, whereAis the set of measurement outcomes. The speciﬁc form of M depends on which scheme we use. (ii) If the type, Pa, of the measurement outcomes, a= (a1,...,a m), satisﬁesPa∈ Qfor a prescribed set, Q, the protocol outputs the type, Q:=Pa, and Alice and Bob conduct the key distillation protocol according to Q, where the type of sequence a= (a1,...,a m) is the frequency distribution deﬁned by Pa(a) :=|{i|1≤i≤m, ai=a}| mfora∈ A (for more details on the type, see [31, Chapter 11]). Otherwise, it outputs “abort”. It is convenient to describe the parameter estimation protocol using a completely positive (CP) map as fol lows. Let M⊗m:={Ma}a∈Ambe a product POVM on (HA⊗HB)⊗m, whereMa=Ma1⊗···⊗Mam. Then, we can deﬁne a CP map, EQ, by EQ:ρm/ma√sto→/summationdisplay a∈Tn Q(A)TrMaρm, (1) which maps the density operator to the probability such that the parameterestimation protocoloutputs Q, where Tm Q(A) is a set of all sequences on Amwith typeQ. When the output of the parameter estimation protocol isQ∈ Q, Alice, Bob, and Eve’s tripartite state is given by ρQ A2nB2nEN:=1 PPE(Q) (idA2nB2n⊗EQ⊗idEN)(ρA2n+mB2n+mEN), wherePPE(Q)isaprobabilitysuchthattheparameteres timation protocol outputs Q, and id denotes the identity map on each system. Alice and Bob apply a measurement MXY:={Mx⊗ My}(x,y)∈F2×F2onHA⊗ HBto the remaining 2 nsys tems to obtain classical data (raw keys). Then, Alice and Bob’s measurement results, ( x,y)∈F2n 2×F2n 2, andEve’s available information is described by a {ccq}state [43] ρQ XYEN:= (E⊗2n XY⊗idEN)(ρQ A2nB2nEN), where we introduce a CP map, EXY, that describes the measurement procedure for convenience. According to output Qof the parameter estimation protocol, Alice and Bob decide the parameters of the IR protocol: rate R(Q) :=m nof linear code Cn,m, num bersn0(Q) andn0(Q) that are used in Step (iv), and rateR0(Q) :=m0 n0of linear code Cn0,m0forn0(Q)≤ n0≤n0(Q). Furthermore, Alice and Bob also decide the length,ℓ(Q), of the ﬁnally distilled key according to Q. According to the determined parameters, a ﬁnal secure key pair is distilled as follows. (i) Alice and Bob undertake the twoway IR protocol in Section II, and Alice obtains ˆuand Bob obtains ˜u. (ii) Alice and Bob carry out a privacy ampliﬁcation (PA) protocol to distill a key pair ( sA,sB) such that Eve has little information about it. Alice ﬁrst randomly chooses a hash function, f:F2n 2→ {0,1}ℓ(Q), fromafamilyoftwouniversalhashfunc tions (refer [14, Deﬁnition 5.2.1] for a formal deﬁ nition of a family of twouniversal hash functions), and sends the choice of fto Bob over the public channel. Then, Alice’s distilled key is sA=f(ˆu) and Bos’s distilled key is sB=f(˜u). The distilled key pair and Eve’s available informa tion can be described by a {cccq}state,ρQ SASBCEN, where classical system Cconsists of random variables (T1,ˆT2,ˆW1) that describe the exchanged messages (t1,ˆt2,ˆw1) in the IR protocol and random variable F that describes the choice of the hash function in the PA protocol. To deﬁne the security of the distilled key pair (SA,SB), we use the universallycomposablesecurity def inition [32, 33], which is deﬁned by the trace distance between the actual key pair and the ideal key pair. We cannot state security in QKD protocols in the sense that the distilled key pair ( SA,SB) is secure for a particular outputQof the parameter estimation protocol, because there is a slight possibility that the parameter estima tion protocol will not output “abort” even though Eve has so much information. The QKD protocol is said to beεsecure (in the sense of the average over the outputs of the parameter estimation protocol) if /summationdisplay Q∈QPPE(Q)1 2/bardblρQ SASBCEN−ρQ,mix SASB⊗ρCEN/bardbl ≤ε,(2) whereρQ,mix SASB:=/summationtext s∈SQ1 |SQ||s,s/an}bracketri}ht/an}bracketle{ts,s|is the uniformly distributed key on the key space SQ:={0,1}ℓ(Q). To state the relation between the security and the asymptotic key rate of the previously mentioned QKD protocol, deﬁne Γ(Q) :={σAB|PσAB A=Q}5 as the set of twoqubit density operators that are com patible with output Qof the parameter estimation pro tocol, where PσAB Adenotes the probability distribu tion of the outcomes when measuring σABwith POVM M, i.e.,PσAB A(a) := Tr[MaσAB]. For a puriﬁca tion,σABE, of a density operator, σAB∈Γ(Q), let σX1X2Y1Y2E1E2:= (E⊗2 XY⊗id⊗2 E)(σ⊗2 ABE) be a{ccq}state that consists of 2bit pairs (( X1,X2),(Y1,Y2)) and en vironment systems E1,E2. By using functions ξ1and ξ2, deﬁne random variables ( U1,U2,W1,W2) for the pair of bits ((X1,X2),(Y1,Y2)) in the same way as in Section II. Then, let σU1U2W1E1E2andσU1U2W1U1E1E2be density operators that respectively describe the classical random variables (U1,U2,W1) and (U1,U2,W1,U1) with the en vironment system E1,E2. Theorem 2 ForQ∈ Q,i.e., theoutputoftheparameter estimation protocolsuchthat the QKDprotocoldoesnot abort, letℓ(Q) 2nbe the key rate of the protocol. For any ε>0, if the key rate satisﬁes ℓ(Q) 2n<1 2min σAB∈Γ(Q)max/bracketleftBig Hσ(U1U2|W1E1E2) −H(PW1)−PW1(0)H(PW2|W1=0), (3) Hσ(U2|W1U1E1E2)−PW1(0)H(PW2|W1=0)/bracketrightBig , then there exists a protocol that is εsecure in the sense of Eq. (2) for suﬃciently large n, whereHρ(A|B) := H(ρAB)−H(ρB) is conditional von Neumann entropy [34], andH(P) is Shannon entropy [31]. The meaning of the two arguments of the maximum in Eq. (3) should be noted. The ﬁrst argument states that the key rate is given by the diﬀerence between Eve’s ambiguity, Hσ(U1U2|W1E1E2), about Alice’s reconciled key and the amount, H(PW1) +PW1(0)H(PW2|W1=0), of information leaked in the IR protocol. On the other hand, since information leaked from the syn drome,t1=u1MT Cn,m, cannot be more than u1it self, we can evaluate the key rate under the condi tion that Eve can access u1itself, i.e., Eve’s ambiguity, Hσ(U2|W1U1E1E2), aboutAlice’sreconciliedkeyandthe amount,PW1(0)H(PW2|W1=0), of information leaked in the IR protocol. If either of them is omitted, the key rate is underestimated, which will be discussed in Sec tion IV. Theorem 2 is formally proved by demonstrating the above intuition formally, where we use a security proof method [12, 13, 14]. More precisely, we use the tech niques of privacy ampliﬁcation and minimum entropy, and the de Finetti style representation theorem and the property of symmetric states (see [14]). Since the tech niques used in the proof are not new and involved, we give the proof for Theorem 2 in the Appendix.IV. ANALYSIS OF KEY RATE Here, we analyze the asymptotic key rate formula in Theorem 2. More precisely, we derive a speciﬁc form of the key rate formulas as functions of the error rates for the sixstate [4] and BB84 protocols [3]. Before analyzing the key rate, let us deﬁne some nota tions. For x,z∈F2, let |ψ(x,z)/an}bracketri}ht:=1√ 2(|0/an}bracketri}ht|0+x/an}bracketri}ht+(−1)z|1/an}bracketri}ht|1+x/an}bracketri}ht) be the Bell states on twoqubit systems HA⊗HB. For a probability distribution, PXZ, onF2×F2, a state of the form, /summationdisplay x,z∈F2PXZ(x,z)|ψ(x,z)/an}bracketri}ht/an}bracketle{tψ(x,z)|, is called a Bell diagonal state. We occasionally abbrevi atePXZ(x,z) aspxz. Theorem 3 For a Bell diagonal state, σAB=/summationtext x,z∈F2PXZ(x,z)|ψ(x,z)/an}bracketri}ht/an}bracketle{tψ(x,z)|, we have 1 2max[Hσ(U1U2|W1E1E2) −H(PW1)−PW1(0)H(PW2|W1=0), Hσ(U2|W1U1E1E2)−PW1(0)H(PW2|W1=0)] = max[1 −H(PXZ) +P¯X(1) 2h/parenleftbiggp00p10+p01p11 (p00+p01)(p10+p11)/parenrightbigg , P¯X(0) 2(1−H(P′ XZ))], (4) whereh(p) :=−plogp−(1−p)log(1−p) is the binary entropy function, P¯X(0) := (p00+p01)2+(p10+p11)2, P¯X(1) := 2(p00+p01)(p10+p11), and P′ XZ(0,0) :=p2 00+p2 01 (p00+p01)2+(p10+p11)2, P′ XZ(1,0) :=2p00p01 (p00+p01)2+(p10+p11)2, P′ XZ(0,1) :=p2 10+p2 11 (p00+p01)2+(p10+p11)2, P′ XZ(1,1) :=2p10p11 (p00+p01)2+(p10+p11)2. The theorem is proved by a straight forward calculation. Thus, the proof is presented in the Appendix E. The sixstate protocol [4] uses three diﬀerent bases de ﬁned byzbasis{|0z/an}bracketri}ht,|1z/an}bracketri}ht},xbasis{1/√ 2(|0z/an}bracketri}ht±|1z/an}bracketri}ht)}, andybasis{1/√ 2(|0z/an}bracketri}ht ±i|1z/an}bracketri}ht)}. When Alice and Bob6 0.025 0.05 0.075 0.1 0.125 0.150.20.40.60.81Proposed B step One wayVollbrecht et al. Error rateKey rate FIG. 1: (Color online) Comparison of the key rates of the sixstate protocols. “Proposed” is the key rate of the six state protocol thatusestheproposedIRprotocol. “Vollbre cht et al.” is the key rate of the twoway sixstate protocol of [17, 24]. “Bstep” is the key rate of the twoway sixstate protocol of [15]. “Oneway” is the key rate of the oneway sixstate protocol with the noisy preprocessing [13]. It sh ould be noted that the key rates of twoway sixstate protocols of [14, 15, 16] are slightly higher than that of the proposed protocol for much higher error rate. obtain an error rate, e, the set Γ( Q) consists of states whose Bell diagonal entries p00,p10,p01,p11satisfy con ditionsp10+p11=e,p01+p11=e, andp01+p10= e. Together with the normalization condition, we ﬁnd p00= 1−3e 2andp10=p01=p11=e 2. Since it is suﬃ cient only to minimize over the Bell diagonal states (see the Appendix F), the key rate of the sixstate protocol for the error rate eis given by substituting p00= 1−3e 2 andp10=p01=p11=e 2into Eq. (4). The key rate of the sixstate protocol that uses the proposed IR protocol is plotted in Fig. 1. The BB84 protocol is similar to the sixstate protocol, but only uses the zbasis and the xbasis to transmit a bit sequence. Thus, we only obtain two conditions on the four coeﬃcients p00,p10,p01,p11. Thus, the set Γ( Q) consists of states whose Bell diagonal entries satisfy con ditionsp10+p11=eandp01+p11=e. The resulting candidates for Bell diagonal states in Γ( Q) have coeﬃ cientsp00= 1−2e+p11,p10=p01=e−p11, and p11∈[0,e], and we have to minimize the key rate for mula of Eq. (4) over the free parameter, p11∈[0,e]. The key rate of the BB84 protocol that uses the proposed IR protocol is plotted in Fig. 2. Remark 4 By using the chain rule of von Neumann en tropy, we can rewrite the l.h.s. of Eq. (4) as 1 2{max[Hσ(U1|W1E1E2)−H(PW1),0] +Hσ(U2|W1U1E1E2)−PW1(0)H(PW2|W1=0)}.(5) We can interpret this formula as follows. If Bob’s ambi guity,H(PW1), about bit U1, i.e., the amount of trans0.02 0.04 0.06 0.08 0.1 0.120.20.40.60.81Proposed B step One wayVollbrecht et al. Error rateKey rate FIG. 2: (Color online) Comparison of the key rates of the BB84 protocols. “Proposed” is the key rate of the BB84 pro tocol that uses the proposed IR protocol. “Vollbrecht et al. ” is the key rate of the twoway BB84 protocol of [17, 24]. “B step” is the key rate of the twoway BB84 protocol of [15]. “Oneway” is the key rate of the oneway BB84 protocol with the noisy preprocessing [13]. mitted syndromeperbit, issmallerthanEve’sambiguity, Hσ(U1|W1E1E2), about bit U1, then Eve cannot decode sequence U1[35, 36], and there exists some remaining ambiguity about bit U1for Eve. We can thus distill some secure key from bit U1. On the other hand, if Bob’s am biguity,H(PW1), about bit U1, i.e., the amount of trans mitted syndrome per bit, is larger than Eve’s ambiguity, Hσ(U1|W1E1E2), aboutU1, then Eve might be able to decode sequence U1from her side information, W1,E1, E2, and the transmitted syndrome [35, 36]. Thus, there exists the possibility that Eve can completely know bit U1, and we can distill no secure key from bit U1, because we have to consider the worst case in a cryptographic scenario. Consequently, sending the hashed version (syn drome) of sequence U1instead of U1itself is not always eﬀective, and the slopes of the key rate curves in Figs. 1 and 2 change when Eve becomes able to decode U1. The second and third terms of Eq. (5) are the same as the key rate formula of the protocol that uses Gottes man and Lo’s Bstep [15] followed by error correction and privacy ampliﬁcation. Even though Alice sends the sequence U1itself instead of its hashed version in the B step, the key rate of the protocol with the Bstep is equal to that of the proposed protocol for high error rates, be cause Eve can decode sequence U1from her side infor mation and the transmitted syndrome. Remark 5 The yield of Vollbrecht and Vestraete’s EDP [22] and the key rate of the QKD protocols [17, 24] are given by 1−H(PXZ) +P¯X(1) 4/braceleftbigg h/parenleftbiggp01 p00+p01/parenrightbigg +h/parenleftbiggp11 p10+p11/parenrightbigg/bracerightbigg .(6)7 We can ﬁnd by the concavity of the binary entropy func tion that the ﬁrst argument in the maximum of the r.h.s. of Eq. (4) is larger than the value in Eq. (6). To explain why the key rate of the proposed protocol is higher than that of [17, 24], we need to review the EDP [22] by using the notations in Section II. Assume that Alice and Bob share Bell diagonalstates, σ⊗2n AB. First, Alice and Bob di vide 2npairs intonblocks of length 2, and locally carry out CNOT operation on each block, where the 2 ith pair is the source and (2 i−1)th pair is the target. Then, Al ice and Bob undertake the breeding protocol [9] to guess bit ﬂip errors in the (2 i−1)th pair for all i. The guessed bit ﬂip errors can be described by a sequence, ˆw1. Note that twoway communication is used in this step. Ac cording to sequence ˆw1, Alice and Bob classify indices of blocks into two sets, ˆT0andˆT1. For a collection of 2 ith pairs such that i∈ˆT0, Alice and Bob conduct the breed ing protocol to correct bit ﬂip errors. For a collection of 2ith pairs such that i∈ˆT1, Alice and Bob perform measurements by {|0z/an}bracketri}ht,|1z/an}bracketri}ht}basis, and obtain measure ment results, x2,ˆT1andy2,ˆT1. Alice sends x2,ˆT1to Bob. Alice and Bob correct the phase errors for the remaining pairs by using information ˆT0andˆT1, and bit ﬂip error x2,ˆT1+y2,ˆT1. Ifweconvertthis EDPinto aQKDprotocol, the diﬀer ence between that QKD protocol and ours is as follows. In the protocol converted from [22], after Step (iii), Alice reveals the sequence, x2,ˆT1, which consists of the second bit,xi2, of theith block such that the parity of dis crepancies ˆwi1is 1. However, Alice discards x2,ˆT1in the proposed IR protocol of Section II. Since sequence x2,ˆT1 has some correlation to sequence u1from the view point of Eve, Alice should not reveal x2,ˆT1to achieve a higher key rate. In the EDP context, on the other hand, since the bit ﬂip error, x2,ˆT1+y2,ˆT1, has some correlationto the phase ﬂip errorsin the (2 i−1)th pair with i∈ˆT1, Alice should send the measurement results, x2,ˆT1, to Bob. If Alice discards measurement results x2,ˆT1without telling Bob what the result is, then the yield of the resulting EDP is worse than Eq. (6). Consequently, there seems to be no correspondence between the EDP and our proposed classical processing. V. CONCLUSION We proposed an information reconciliation protocol that uses twoway classical communication. For the BB84 and sixstate protocols, the key rates of QKD pro tocols that uses our information reconciliation protocol are higher than previously known protocols for a wide range of error rates. Furthermore, we showed the rela tion between the proposed protocol and the Bstep of [15] (Remark 4). We clariﬁed why the key rate of our protocol is higher than those of [17, 22, 24] (Remark 5), and found that there does not seem to be any EDP thatcorresponds to our proposed QKD protocol. Acknowledgment The ﬁrst author partly contributed to this work dur ing his internship at Nippon Telegraph Communication Science Laboratories. This research was also partly supported by the Japan Society for the Promotion of Science under a GrantsinAid for Young Scientists, No. 18760266, and a GrantsinAid for JSPS Fellows. APPENDIX A: NOTATIONS Theseappendicesaresuplementarymaterials,inwhich we prove Theorem 2, Theorem 3, and the fact that the key rate formula evaluated for a Belldiagonal state is the worst case. The proof of Theorem 2 is based on the proof method of [12, 13, 14], especially [14]. In Section A, we review notations and fundamental results that are used in subsequent sections. Notations in this paper is almost the same as those in [14]. In Section B, we review notions of the (smooth) minentropy, the (smooth) max entropy, and the privacy ampliﬁcation. Furthermore, we additionally show some lemmas, which are used to prove Theorem 2 in Section D. In Section C, we review the property of symmetric states and the de Finetti style representation theorem [14, 30]. We prove Theorem 2 in Section D. Section E presents a proof of Theorem 3. We show the fact that the key rate formula evaluated for a Belldiagonal state is the worst case in Section F. 1. Fundamentals For a ﬁnite set X, letP(X) be the set of nonnegative functionsPonX, i.e.,P(x)≥0 for allx∈ X. If P∈ P(X) is normalized, i.e.,/summationtext x∈XP(x) = 1, then Pis a probability distribution on X. Unless stated as a probability distribution, P∈ P(X) is not necessarily normalized. For a ﬁnitedimensional Hilbert space H, letP(H) be the set of nonnegative operator ρonH. Ifρ∈ P(H) is normalized, i.e., Tr ρ= 1, thenρis called a density operator. Mathematically, a state of a quantum mechan ical system with ddegree of freedom is represented by a density operator on Hwith dim H=d. Unless stated as a density operator or a state, ρ∈ P(H) is not neces sarily normalized. For Hilbert spaces HAandHB, the set of nonnegative operators P(HA⊗HB) on the tensor product space HA⊗HBis deﬁned in a similar manner. The classical random variables can be regarded as a specialcaseofthequantumstates. Forarandomvariable Xwith a distribution PX∈ P(X), let ρX:=/summationdisplay x∈XPX(x)|x/an}bracketri}ht/an}bracketle{tx|,8 where{|x/an}bracketri}ht}x∈Xis an orthonormal basis of HX. We call ρXthe operator representation of the classical distribu tionPX. When a quantum system HAis prepared in a state ρx A according to a realization xof a random variable Xwith a probability distribution PX, it is convenient to denote it by a density operator ρXA:=/summationdisplay x∈XPX(x)|x/an}bracketri}ht/an}bracketle{tx| ⊗ρx A∈ P(HX⊗HA),(A1) where{|x/an}bracketri}ht}x∈Xis an orthonormal basis of HX. We call the density operator ρXAa{cq}state [37], or we say ρXAis classical on HX. We callρx Aa conditional opera tor. When a quantum system HAis prepared in a state ρx,y Aaccording to a joint random variable ( X,Y) with a probability distribution PXY, a stateρXYAis deﬁned in a similar manner, and the state ρXY Ais called a {ccq} state. In quantum mechanics, the most general state evolu tion of a quantum mechanical system is described by a completely positive (CP) map. It can be shown that any CP map Ecan be written as E(ρ) =/summationdisplay a∈AEaρE∗ a (A2) for a family of linear operators {Ea}a∈Afrom the ini tial system Hto the destination system H′. We usu ally require the map to be trace preserving (TP), i.e.,/summationtext a∈AE∗ aEa= idH, but if a state evolution involves a measurement, thenthe correspondingCPmapisnotnec essarily trace preserving, i.e.,/summationtext a∈AE∗ aEa≤idH. 2. Distance and ﬁdelity In this paper, we use two kind of distances. One is the variational distance of P(X). For nonnegative functions P,P′∈ P(X), the variational distance between PandP′ is deﬁned by /bardblP−P′/bardbl:=/summationdisplay x∈X|P(x)−P′(x)|. Theotherdistanceusedinthispaperisthetracedistance ofP(H). For nennegative operators ρ,σ∈ P(H), the trace distance between ρandσis deﬁned by /bardblρ−σ/bardbl:= Tr|ρ−σ|, where|A|:=√ A∗Afor a operator on H, andA∗is the adjoint operator of A. The following lemma states that the trace distance between (not necessarily normalized operators) does not increase by applying a CP map, and it is used several times in this paper. Lemma 6 [14, Lemma A.2.1] Let ρ,ρ′∈ P(H) and let Ebe a tracenonincreasing CP map, i.e., Esatisﬁes TrE(σ)≤Trσfor anyσ∈ P(H). Then we have /bardblE(ρ)−E(ρ′)/bardbl ≤ /bardblρ−ρ′/bardbl.The following lemma states that, for a {cq}stateρXB, if two classical messages vand ¯vare computed from x and they are equal with high probability, then the {ccq} stateρXV BandρX¯V Bthat involve computed classical messagesvand ¯vare close with respect to the trace dis tance. Lemma 7 Let ρXB:=/summationdisplay x∈XPX(x)|x/an}bracketri}ht/an}bracketle{tx| ⊗ρx B be a{cq}state, and let V:=f(X) for a function fand ¯V:=g(X) for a function g. Assume that Pr{V/ne}ationslash=V}=/summationdisplay x∈X f(x)/negationslash=g(x)PX(x)≤ε. Then, for {ccq}states ρXV B:=/summationdisplay x∈XPX(x)|x/an}bracketri}ht/an}bracketle{tx| ⊗|f(x)/an}bracketri}ht/an}bracketle{tf(x)| ⊗ρx B and ρXVB:=/summationdisplay x∈XPX(x)|x/an}bracketri}ht/an}bracketle{tx| ⊗|g(x)/an}bracketri}ht/an}bracketle{tg(x)|⊗ρx B, we have /bardblρXVB−ρXVB/bardbl ≤2ε. Proof.We have /bardblρXVB−ρXV B/bardbl =/summationdisplay x∈XPX(x)/bardbl|x/an}bracketri}ht/an}bracketle{tx|/bardbl ·/bardbl|f(x)/an}bracketri}ht/an}bracketle{tf(x)|−|g(x)/an}bracketri}ht/an}bracketle{tg(x)|/bardbl·/bardblρx B/bardbl =/summationdisplay x∈XPX(x)·2(1−δf(x),g(x)) ≤2ε, whereδa,b= 1 ifa=bandδa,b= 0 ifa/ne}ationslash=b. /square The ﬁdelity between two (not necessarily normalized) operatorsρ,σ∈ P(H) is deﬁned by F(ρ,σ) := Tr/radicalBig√ρσ√ρ. The following lemma is an extension of Uhlmann’s theo rem to nonnormalized operators ρandσ. Lemma 8 [14, Theorem A.1.2] Let ρ,σ∈ P(H), and let |ψ/an}bracketri}ht ∈ HR⊗Hbe a puriﬁcation of ρ. Then F(ρ,σ) = max |φ/angbracketright/angbracketleftφ|F(|ψ/an}bracketri}ht/an}bracketle{tψ|,|φ/an}bracketri}ht/an}bracketle{tφ|), where the maximum is taken over all puriﬁcations |φ/an}bracketri}ht ∈ HR⊗Hofσ.9 The trace distance and the ﬁdelity have close relation ship. If the trace distance between two density operators ρandσis close to 0, then the ﬁdelity between ρandσ is close to 1, and vise versa. Lemma 9 [14, Lemma A.2.4] Let ρ,σ∈ P(H). Then, we have /bardblρ−σ/bardbl ≤/radicalbig (Trρ+Trσ)2−4F(ρ,σ)2. Lemma 10 [14, Lemma A.2.6] Let ρ,σ∈ P(H). Then, we have Trρ+Trσ−2F(ρ,σ)≤ /bardblρ−σ/bardbl. 3. Entropy For a random variable XonXwith a probability dis tributionPX∈ P(X), the entropy of Xis deﬁned by H(X) =H(PX) :=−/summationdisplay x∈XPX(x)logPX(x), where the base of log is 2. Especially for a real number 0≤p≤1, the binary entropy function is deﬁned by h(p) :=−plogp−(1−p)log(1−p). Similarly, for a joint random variables XandYwith a joint probability distribution PXY∈ P(X ×Y), the joint entropy ofXandYis H(XY) =H(PXY) :=−/summationdisplay (x,y)∈X×YPXY(x,y)logPXY(x,y). The conditional entropy of XgivenYis deﬁned by H(X|Y) :=H(XY)−H(Y). For a quantum state ρ∈ P(H), the von Neumann en tropy of the system is deﬁned by H(ρ) := Trρlogρ. For a quantum state ρAB∈ P(HA⊗HB) of the com posite system, the von Neumann entropy of the compos ite system is H(ρAB). The conditional von Neaumann entropy of the system Agiven the system Bis deﬁned by Hρ(A|B) :=H(ρAB)−H(ρB), whereρB= TrA[ρAB] is the partial trace of ρABover the systemA. Remark 11 In this paper, we denote ρAfor Tr B[ρAB] orρBfor Tr AC[ρABC] e.t.c. without declaring them if they are obvious from the context.4. Method of type","Quantum key distribution (QKD) protocols provide a way for two parties, Alice and Bob, to share an unconditionally secure key in the presence of an eavesdropper, Eve. The security of QKD protocols is guaranteed by the principles of quantum mechanics. The best-known QKD protocols are the Bennett Brassard 1984 (BB84) protocol and the six-state protocol. In this paper, we study the key rates of QKD protocols that include the BB84 protocol and the six-state protocol. We propose a two-way preprocessing that uses classical communication",cool!
230,Towards End-to-End Quality-of-Service by Domain-Level Routing and Forwarding.txt,"We propose to raise network domain to the first-class citizen in packet
routing and forwarding. By making domain explicit in packet header, it can be
held responsible for committed services and quality of service. Since the
service is easier to be monitored, verified, and compensated, a new business
model catering for emerging cross-domain, high-value, and performance-sensitive
applications can be fostered. The domain-level routing and forwarding
essentially create a L3.5 in the network protocol stack. We extend IPv6 with
new routing headers to support two types of forwarding approaches. One is based
on the next domain lookup and the other realizes the domain-level source
routing. We describe various design details covering header format, forwarding
behavior, routing protocol, DNS, and OAM. Several use cases are presented to
demonstrate the scheme potential. The design is compatible with today's
Internet architecture and incrementally deployable on existing infrastructure
with only moderate updates needed. We expect the preliminary work can trigger
more discussion and detailed design in the research and Internet standard
communities.","Emerging valueadded network functions (e.g., INT [ 21] and SFC [ 3]) are often claimed to be used in only a limited domain to secure their deployability. This is not because that they are technically incapable of being used in a wide area network crossing multiple domains, but because there is a lack of incentives for crossdomain interoperability. Unfortunately, without the endtoend usage, the value of such functions is also limited. This is not a new issue. It has long been recog nized that interdomain quality of service (QoS) is difficult to achieve due to economic and security reasons [ 13], and such efforts have even been largely abandoned. However, today, driven by emerging applications [ 15] (e.g., metaverse, live 3Dvideo for sports and entertainment events, and remote in teractive operations, which usually require the global reach), the need for interdomain QoS is becoming more urgent than before. The requirements of these applications are not limited to just high bandwidth and low latency in a statisti cal sense. They often have deterministic performance targetwith strict QoS criteria (e.g., zero packet drop guarantee, a constant bit rate, and a fixed latency budget). The Internet service providers must collaborate to achieve the QoS and service goals. If any involved one does not cooperate and behave, it makes no sense for the others to do anything better than the besteffort service as being practiced today, which essentially means no other guarantee beyond connectivity. Therefore, we believe the support of interdomain QoS and crossdomain network functions is so important that it de serves further investigation. The dilemma of interdomain cooperation must be cracked. We need to provide right incentives for network service providers to foster a viable business model that allows mul tiple service providers to work in concert with each other to provide certain networkwide valueadded services or QoS guarantee. In this paper we do not intend to discuss the busi ness aspects of this issue but study the technical means to facilitate the effort to establish a business model which can be adopted to benefit both end users and service providers. The question is why the service providers are not motivated to provide interdomain services and QoS before? The answer could be multifaceted. But an important reason is that the service providers or domains are invisible from end host’s perspective and thus they cannot be held accountable even if they will or are able to do better. While the routing architecture in today’s Internet is hi erarchical (i.e., with the differentiation of Exterior Gateway Protocol (EGP) and Interior Gateway Protocol (IGP)), the resulting forwarding table is flat. The Autonomous Systems (AS), which play an important role in the Internet routing, are no longer visible after the routing table is computed. At any node in the network, a next hop is all needed for forward ing a packet towards its destination. Since the domains and domain boundaries are invisible from the endhost’s perspec tive, and the domain information is ignored by forwarding, it is difficult to measure and audit perdomain behavior and performance, and difficult to attribute any issue to any ser vice provider. Simply put, if users have no visibility to the domains their traffic goes through, they cannot exert any effective control on it; similarly, if service providers have no clue whether the other domains behave, they are not motivated to react to any control.arXiv:2207.02326v1  [cs.NI]  5 Jul 2022Source routing offers users the capability to select the ac tual forwarding paths for their traffic. SRv6 [ 11] has become a mainstream sourcerouting technology which works on the IPv6 data plane. However, without a clear delineation of responsibility, service providers would feel reluctant to support EndtoEnd (E2E) source routing because the desig nated routes may break the established peering relationship and yet provide no tangible business benefits. The solution is to raise the status of service provider (or domain) to the firstclass citizen in packet forwarding. It has been observed that the different stakeholders on the Inter net have competing interests [7]. The tussles exist between users and service providers and among service providers. It suggests that “the Internet should support a mechanism for choice of source routing that would permit a customer to control the path of his packets at the level of providers ”. It becomes clear that the providers must be visible to end users at the packet level. But how? The answer is to intro duce L3.5 in the network protocol layer stack and make domain the L3.5 entity. The vision of L3.5 has been articu lated in [ 16]. It insightfully points out there is an unfortunate missing layer in the network protocol stack due to the early evolution of the Internet. The current protocol layer stack is formed before the advent of the Autonomous Systems. As the Internet scales out, multiple service providers and multiple roles (e.g., core, transit, and stub) are needed, so AS came into being, creating a new layer above IP effectively but which was largely ignored (except for routing). The authors in [ 16] however consider the introduction of L3.5 as a breakthrough to free the evolution of L3 because a new overlay can hide the underlay details and hence mul tiple different types of underlay (e.g., L3 protocols) can be supported. While we appreciate the insight, we hold a more modest opinion toward the actual usage of the new L3.5. It is not clear to us whether or not any new L3 protocol other than IP is ever needed, but nevertheless the introduction of L3.5 can bring the domain visibility to the forwarding plane. We believe this is a stronger motivation that makes the idea of L3.5 more compelling. Therefore, we focus on empower ing IPbased Internet and try to extend it with a new domain layer to help service providers collaborate and provide better support of E2E service and QoS. The domain layer allows the network performance and service level to be monitored at the service provider level. Because of this, contributor and culprit can be clearly identified, and service providers are easier to be compensated and therefore are more likely to collaborate for some common goals. This paper provides a design for IPv6 domain level routing and forwarding based on an abstract network model in which each domain is virtualized as a “router"". The remainder of the paper is organized as follows: Section 2 presents the domain level routing architecture with the abstract network model, L1/L2 L3: IPv6 L3.5: Domain L4: Transport L7:Application Figure 1: Protocol stack with a new L3.5 layer. Section 3 details the system design which covers various technical aspects enabling the domainlevel routing and for warding, Section 4 provides several use cases to demonstrate the potential of the new design, Section 5 summarizes the relate work, Section 6 analyzes the system cost and discusses the future work, and finally, Section 7 concludes the work. 2 ARCHITECTURE IPv6 is set to dominate the Internet, replacing IPv4 as the new narrow waist. According to Google statistics, the global IPv6 adoption rate is around 36% as of April 2022 [ 12] and increases rapidly. In addition to its huge address space, IPv6 is extensible with the wellknown Extension Header (EH) mechanism, making it possible for innovations on top of it (e.g., SRv6 [11]). Our design takes advantage of the EH. An Autonomous System (AS) is a single administrative entity or domain under the control of an Internet Service Provider (ISP). Uniquely identified by an AS number, each AS has combined routing logic and common routing policies. The ASes are interconnected through peering relationship with several hierarchical levels. They use Border Gateway Protocol (BGP) as the EGP; Within each AS, an IGP (e.g., OSPF and ISIS) is used. Jointly, a global routing table can be constructed on each router. The AS or domain sets a clear boundary for responsibil ity. The service provider of a domain can make decision on peering agreement and various routing policies. Since the intradomain network infrastructure and routing are under control of a domain, theoretically, the service providers are jointly capable of enforcing any routing/forwarding treat ments and offering premier services to selected users, as long as the services can be audited and appreciated. For example, each domain can commit to certain Service Level Agreement (SLA), and hence all the domains on a path can jointly achieve some level of predictable QoS guarantee. If the domains are made explicit in a packet, it becomes easy to audit their SLA compliance through various OAM tools. With such a provi sion, both the end users and the domain service providers are motivated to participate in the endtoend service with QoS guarantee, enabling performancesensitive and demanding applications over the Internet. 2b c fd k gae AS1  AS3 AS2  hi AS4 src dst DBR/Virtual Interface  x y zAS0 AS5  Domain/Virtual Router Figure 2: Domain Level Routing (DLR) network archi tecture abstraction. As shown in Figure 1, we make domain an explicit L3.5 protocol layer in IPv6 networks. Specifically, the domain related information will be encapsulated in an IPv6 Routing Header (RH) extension, which is located after the IPv6 base header and before the transport layer header (or other EHs if any). While the whole Internet architecture remains the same, we need a new model, as illustrated in Figure 2, to describe it. In the new model, each domain is abstracted as a virtual router. The Domain Border Routers (DBR) are abstracted as the virtual router interface, and all the intradomain routers of a domain form the switch fabric of the corresponding virtual router. A packet from its source to destination will be forwarded though a sequence of virtual routers. There can be multiple paths available. Each virtual router’s performance is individually monitored and measured. Hence each path’s performance can be inferred. Here we are particularly inter ested in the case of source routing, in which each packet can designate the sequence of virtual routers (i.e., domains) as the forwarding path. Presumably, such arrangement would only apply to some highvalue and performancesensitive applications, for which the users would like to pay a pre mium. Each virtual router (i.e., a domain’s provider) needs to commit to certain SLA to be qualified as a participant, and if selected, share the profit after offering the service. In this model, each virtual router is identified by the do main ID (i.e., the AS number) and reachable by the IP ad dresses of its ingress interfaces (i.e., DBRs). Only the ingress and egress DBRs will be aware of and process the L3.5 header, simulating the packet processing engine on router line cards. To ensure the committed QoS, each virtual router is respon sible for its own traffic management. That is, a domain can adopt various means such as traffic engineering or even ded icated private network. However, such means are invisible to users and other domains, allowing each service provider to have proprietary designs and architectures for better com petitive edge and profit margin. Ver(6)  NH = RH (43) Hop Limit  NH = UL Traffic Class Flow Label  Payload Length  Source Address (128bit)  Len  Original Destination Address (128bit)  Domain ID List for DomainLevel Source Routing (32 bit*N) RT = DLSR  Upper Layer Protocol(s) + Payload Base IPv6 Header Extended DLSR  Routing Header  DLSR Options TLV (optional) Domains Left Destination Address (128bit)  First Domain Reserved Figure 3: IPv6 packet format for Domain Level Source Routing (DLSR). 3 SYSTEM DESIGN This section provides the details to make the IPv6based Do main Level Routing (DLR) work. We discuss two flavors of DLRbased forwarding: the first is for source routing at the domain level, named Domain Level Source Routing (DLSR); the second is for DomainbyDomain (DBD) forward ing, which is similar to the conventional HopbyHop (HBH) forwarding, except that the “next hop"" router is replaced with the “next domain"". DLSR is preferred in a centralized service model. A cen tral service broker is responsible to contract with users and service providers, and provision and monitor the services. DBD can be used in a distributed peertopeer model. In this model, the QoS policies and capabilities can be communi cated between peering domains. Although it is a little harder to establish endtoend QoS guarantee in DBD, the routing and forwarding are still at the domain level, so it still easier to apportion the responsibilities and audit the compliance of each service provider. 3.1 Packet Format DLSR. The packet format for DLSR is shown in Figure 3. In the standard IPv6 base header, the Next Header (NH) field is set to the value 43, indicating the presence of a Routing Header (RH). In the RH extension header, the first two fields are standard EH container fields: the 8bit NH indicates the original Upper Layer (UL) protocol type and the 8bit Len records the length of the EH (in the unit of 8 octets and excluding the first 8 octets). the 8bit Routing Type field is set to a new value (to be assigned by IANA [ 14]), indicating the RH’s type is DLSR. The next 8bit field, Domain Left , is an index to the next domain to be visited in the Domain ID List field. The value of Domain Left decrements by one at each domain ingress. The next 8bit field, First Domain , provides 3Ver(6)  NH = RH (43) Hop Limit  NH = UL Traffic Class Flow Label  Payload Length  Source Address (128bit)  Len  Original Destination Address (128bit) RT = DBD  Upper Layer Protocol(s) + Payload Base IPv6 Header Extended DLR  Routing Header  DBD Options TLV (optional) Destination Address (128bit)  Reserved Reserved Figure 4: IPv6 packet format for DLR Domainby Domain (DBD) forwarding. the index of the first entry in Domain ID List . The following 24bit field is reserved for other purposes such as flags. The body of the DLSR RH is composed of three parts. The first part is used to record the original destination ad dress. The reason for this is that on the forwarding path, the destination address in the IPv6 base header would be replaced by some address to reach a domain. Keeping the original address ensures the original packet can be recov ered before the final packet delivery in the last domain. The second part is the reverse ordered Domain ID list, which defines the domainlevel forwarding path. The third part is the options in TypeLengthValue (TLV) format. We will show some possible options that help enhance or facilitate the DLSR functionality. There can be other EHs after the DLSR RH. After the last EH is the original upper layer (i.e., transport layer) protocol header and the packet payload. DBD. The DBD RH, as shown in Figure 4, is simpler. It would require a new DBD routing type as well. After the first 8 octets of the DBD RH are the original destination address and DBD options in TLV format. In the DBD RH, 40 bits are reserved for future enhancement. 3.2 Forwarding DLSR. Only can the ingress and egress DBRs of a domain process the RH. The other interior routers simply forward packets based on the destination address in the base header. Each DBR of domain 𝑑maintains a table named Domain Entry Table (DET) that maps each peering domain 𝑝of𝑑to 𝑝’s ingress DBR’s IP address. We use Figure 2 as an example to describe the forwarding process. Assume the source node srcin AS0 would send a packet to the destination node dstin AS5 and it acquires a domain level sourcerouting path AS0 →AS1→AS2→AS5. After the RH encapsulation, the packet’s destination address is copiedto the original destination address field in the RH and the domain ID list is initialized accordingly. The packet is then forwarded to the egress DBR xof AS0. Using the First Domain field and the Domain ID list, xfinds that it matches the first domain, AS0, on the path. xwill decrement Domains Left and find the next domain on the path, which is AS1. AS1 is used to search the DET. DBR a’s IP address is returned and copied into the destination address field of the base header. The packet is then forwarded to a. By examining the RH, the ingress DBR aknows that AS1 is not the last domain and the next domain on the path is AS2, so it will search the DET and find d’s address. The address is copied to the destination address field, the RH is updated (e.g., decrement Domains Left by 1), and the packet is eventually forwarded to b, the egress DBR of AS1. If no option needs to be processed, bwill simply forward the packet to daccording to the destination address. The packet is forwarded in AS2 following the similar pro cess as in AS1 and reaches the ingress DBR yin the last domain AS5. Once yfigures out its the ingress of the last do main, it will copy the original destination address in RH back to the destination address field in the base header. Finally, the packet is forwarded to dstin AS5. DBD. In this mode, each DBR needs to maintain another table named Next Domain Table (NDT) which maps each destination network (i.e., address prefix) to a Next Domain which is used to reach the destination. NDT is actually an augmentation to the Forwarding Information Base (FIB): in addition to the Next Hop (NH), it also provides the Next Domain (ND) for a destination network. So the two tables can be merged as one to support packet forwarding with or without DBD RH. If a packet from srctodstbears a DBD RH, it is forwarded toxusing the normal destination addressbased forwarding process. If xfinds the packet’s destination address is the same as the original destination address in the RH, it knows the packet is destined to another domain. It will search NDT and find AS1 as the next domain. Then AS1 is used to search DET and a’s address is returned and copied to the destination address field. The packet is then forwarded to a. For each ingress DBR in the following domains on the forwarding path, if it receives a DBD packet matching its address, it will check the original destination address field in the RH. If the address is in the current domain 𝑑(i.e., the ND of the destination is 𝑑), it will be copied back to the destination address field in the based header; otherwise, the ND is acquired from NDT using the original destination address, and the new destination address is acquired from DET using the ND. The egress DBRs in the domains en route only process the options if necessary. Repeating this process, the packet is eventually delivered to dst. 43.3 Routing DLR does not require any new control plane protocol. It can reuse the existing IGP protocols without any change and adapt BGP with minor extensions. DBRs run BGP to generate the NDT and DET. The AS path is a mandatory attribute of BGP. When a DBR sends a BGP update to a peering DBR in another AS, it adds its own AS number to augment the AS path to a network represented as a prefix, so the AS path contains all the ASes that need to be traversed to reach the destination network. A standard routing information would include the Next Hop (NH), which is the interface address of the DBR of the next domain, along with a domain list, in which the first domain is the next domain. Hence, the routing information is enough to map a domain to one of its DBR’s interface addresses. In our abstract network model, this is equivalent to the mapping between a virtual router and its ingress interface address. Hence, BGP can provide entire domainlevel path information to help construct the domainlevel network abstraction. To support DLSR, a centralized routing architecture using Path Computation Element (PCE) [ 22] is also possible. We leave the detailed design as future work. 3.4 DNS In the case of DLSR, we need to provide some mechanism to acquire the domainlevel source routing path. It is possible that the service broker can help provision the domain level paths and configure the DBR in the first domain to set up the path for specific applications. To achieve the true endtoend DLSR (i.e., set up a domain level path from srctodst), we can rely on DNS [ 18] and adopt the NetworkAware Domain Name System (NADNS) architecture [ 20]. DNS is a distributed and hierarchical data base used to acquire computer reachability means through the Internet. The data are formatted into various Resource Records (RRs). A typical use of DNS is for a host to get the IP addresses of a domain name by running the DNS protocol. We specify a new RR type for domainlevel path. The service provider at the source domain can register the domainlevel path RR for a target application in DNS servers. The source host can then make a DNS query for the domainlevel path RR. The returned data are used to construct the IPv6 base header and the DLSR RH. For DBD, NADNS can also be used for hosts to express QoS requirement and get the corresponding destination ad dress and RH option [20]. 3.5 OAM Network Operations, Administration, and Maintenance (OAM) refers to the toolset for network performance measurementand troubleshooting. Since the endtoend QoS requires in dependent domains to cooperate, DLR OAM is important to enforce the service contract. Through metering and ac counting, measures can be taken to hold the domains who miss their SLA responsible and meanwhile compensate the behaving domains. OAM can also be used to find candidate domainlevel paths. Insitu OAM (IOAM) [ 6] is an IETF standard for Inband Network Telemetry (INT). Working in several different modes, IOAM allows user packets to collect data from routers on the entire forwarding path. The data can be used to measure performance (e.g., bandwidth, delay, and delay jitter) and pinpoint issues (e.g., packet drop) on a per router basis. In our abstract network model, each domain is abstracted as a virtual router, so IOAM can be applied to collect data at the domain level. We encapsulate the IOAM header as an DLR RH option. Only the ingress and egress DBRs of a domain would process the IOAM in the DLR RH, which emulates the IOAM’s behavior on a router’s line cards. The telemetry data can be mutually verified to avoid possible frauds. For example, a domain’s egress timestamp can be verified by the next domain’s ingress timestamp through cross examination. It is conceivable that the other popular active and passive OAM methods (e.g., ping, traceroute, BFD, and TWAMP) [ 17] can also be adapted to the abstract network model in which a whole domain becomes a single entity under scrutiny. 4 USE CASES We discuss several DLR use cases to demonstrate its potential for endtoend service and QoS. Virtual Private Path. For some longlasting highvalue ap plications, crossdomain virtual private path can be provi sioned. Only the domainlevel path is exposed to end users. Each participating domain can use its own means to achieve the QoS goal assigned to it, and are compensated based on its contribution. Following the abstract network model, the domainlevel virtual private network is also possible. Deadline Based Forwarding. Some applications require a tight and bounded delay. Any packet that misses the deadline becomes useless and therefore it is better to be discarded as soon as possible. To support such an application, each domain participating the forwarding can commit to certain delay target to make sure the overall delay is within the bound. During the packet forwarding, the used time by each domain and the remaining delay budget can be kept as a TLV option in the DLR RH. The missed target in one domain can be made up by some subsequent domains, as long as the helpers can be properly compensated. Once a domain decides that it is impossible for a packet to reach its destination on 5time, it can drop the packet to save bandwidth. With domain as the basic entity, the responsibility is clear and accountable. Service Function Chaining (SFC). In addition to QoS, DLR is also good for service providers to collaborate on providing distributed network services. SFC is a general technique to initiate an ordered set of service functions (e.g., firewall, load balancing, WAN optimization, NAT, and encryption) in net work and steer the user traffic through it. Traditionally it can only be used by a single service provider. With DLR, it is eas ier to negotiate a plan to allocate different network functions in different domains. The service providers are compensated by the nature of the functions and the contribution of each participating domain. The SFC descriptor (e.g., NSH [ 19]) can be carried as a DLR RH option. 5 RELATED WORK","The need for interdomain QoS and cross-domain network functions is becoming more urgent than ever. The need for interdomain QoS is driven by emerging applications (e.g., metaverse, live 3Dvideo for sports and entertainment events, and remote in-teractive operations), which often require the global reach. The need for interdomain QoS is becoming more urgent than ever. The need for interdomain QoS is becoming more urgent than ever. The need for interdomain QoS is becoming more urgent than ever.",cool!
66,I-Min: An Intelligent Fermat Point Based Energy Efficient Geographic Packet Forwarding Technique for Wireless Sensor and Ad Hoc Networks.txt,"Energy consumption and delay incurred in packet delivery are the two
important metrics for measuring the performance of geographic routing protocols
for Wireless Adhoc and Sensor Networks (WASN). A protocol capable of ensuring
both lesser energy consumption and experiencing lesser delay in packet delivery
is thus suitable for networks which are delay sensitive and energy hungry at
the same time. Thus a smart packet forwarding technique addressing both the
issues is thus the one looked for by any geographic routing protocol. In the
present paper we have proposed a Fermat point based forwarding technique which
reduces the delay experienced during packet delivery as well as the energy
consumed for transmission and reception of data packets.","Geographic routing protocols are fast coming up in the arena of Wireless Adhoc and Sensor  Networks (WASN) for obvious reasons. Mobile Adhoc N etworks (MANET) are another area  where geographic routing protocols find their appli cation. This is because, adhoc and sensor  networks are more and more used for applications wh ere manual collection and assimilation of  data is either troublesome or is impossible. Eg mil itary surveillance, collecting temperature    and humidity of uninhabited regions etc. In scenari os like this, data packets may need to be  transmitted to one or more favorable locations wher e final computations on those data can take  place. So, the possibility of the final destination  node(s) to reside in a specific geographic  region(s) for a mobile sensor network can by no mea ns be ruled out. Now if the situation  demands the network either to be deployed for a pro longed period of time or if the frequency of  data transfer in the said network is considerably h igh, then the participating nodes in the  network need to have a sound reserve of residual en ergy. Needless to say that replenishing the  battery time and again in the networks under discus sion either adds up noncomputation/non communication overhead or may turn out to be an imp ossible proposal altogether. The only way  to retain uninterrupted service in such a scenario is to design a routing protocol that consumes  the least possible energy. One way to reduce the tr ansmitting/receiving energy of the network is  to reduce the frequency of packet transmission with out compromising the reliability. This can  be done by waiting for a considerable number of pac kets to a particular destination to arrive  first. A number of short transmissions are replaced  by a single long transmission. But this  approach is sure to take a toll on the performance of delay sensitive networks. International journal on applications of graph theo ry in wireless ad hoc networks and sensor networks  (GRAPHHOC) Vol.2, No.2, June 2010  35   Achieving energy efficiency and delay reduction in a single protocol is possible when one or  more parameters directly proportional to both can b e reduced. The transmitting distance can be  considered as such a parameter. Energy consumed for  transmitting a packet is a directly  proportional to the square of the distance between the sender and receiver along with being  dependent on the size of the packet transmitted/rec eived [6][7]. Assuming the transmission radii  of all the nodes in the network to be equal, it can  be said that lesser the distance between two  nodes, lesser is the number of hops required for pa cket transmission and thus lesser is the delay.  Because, the delay experienced in packet delivery i s a function of the processing time of the  intermediate nodes taken together. Considering the packet size for a said network using a  specific routing protocol to be constant, the energ y consumption along with delay in a particular  network can thus be reduced by reducing the transmi ssion path length. Now for a specific  geographic region, where the final destination(s) i s(are) fixed or changes seldom, position of  remaining nodes plays a vital role in determining t he energy consumed and delay experienced  by a network. But in most of the real life applicat ions the nodes are deployed in a random  manner. Thus to minimize the total transmitting dis tance for a multidestination network, one  needs to find out the minimum of the sum of the dis tances from a particular source to all the  destinations. If one considers the source node and the destinations to be the vertex of a triangle  or a polygon, then the sum of the distance of the s ource to the Fermat point [1] and the distances  from the Fermat point to all the destinations of th e considered triangular/polygonal region is  always minimum.  In this paper we have proposed an energy efficient routing protocol that works on the principle  of Fermat point. In [2] and [3] the authors have pr oposed Fermat point based geographic routing  mainly for two geocast regions. They have used a ge ometric method of finding the Fermat  point. In [4] however a global minima based scheme was proposed by the authors to find the  Fermat point for n geocast regions which out perfor med the geometry driven scheme discussed  in [3] in terms of total distance traveled by a dat a packet and the energy thus consumed by the  network in trafficking the packet from source to th e destined geographic regions. The  forwarding technique used in both [3] and [4] is gr eedy in nature. The present scheme uses the  'Global Minima' based scheme used in [4] for findin g the Fermat point and the forwarding  technique is also greedy in genre. However it makes  certain intelligent improvisations in the  forwarding technique used in [4] to get over the un necessary route looping that was present in  both [3] and [4]. As the proposed protocol is free from route looping, it further reduces the  effective distance traveled and the total number of  hops encountered by a packet. This way, the  energy expenditure for the network gets reduced as well.  The rest of the paper is organized as follows: In s ection 2 we have discussed some relevant  related works. Section 3 discusses the present forw arding technique and compares it with the  schemes discussed in [3] and [4]. In section 4 we h ave the results and section 5 is the  concluding section of this paper with a direction f or possible future works.    2.  RELATED WORKS","Geographic routing protocols are fast coming up in the arena of Wireless Ad hoc and Sensor Networks (WASN) for obvious reasons. Mobile Ad hoc Networks (MANET) are another area where geographic routing protocols find their application. In such scenarios, the nodes in the network need to have a sound reserve of residual energy. One way to reduce the energy consumption of the network is to reduce the frequency of packet transmission with out compromising the reliability. This can be done by waiting for a considerable number of short transmissions to arrive first. But this approach is sure to reduce the delay experienced in",cool!
432,Routing in Outer Space: Improved Security and Energy-Efficiency in Multi-Hop Wireless Networks.txt,"In this paper we consider security-related and energy-efficiency issues in
multi-hop wireless networks. We start our work from the observation, known in
the literature, that shortest path routing creates congested areas in multi-hop
wireless networks. These areas are critical--they generate both security and
energy efficiency issues. We attack these problems and set out routing in outer
space, a new routing mechanism that transforms any shortest path routing
protocol (or approximated versions of it) into a new protocol that, in case of
uniform traffic, guarantees that every node of the network is responsible for
relaying the same number of messages, on expectation. We can show that a
network that uses routing in outer space does not have congested areas, does
not have the associated security-related issues, does not encourage selfish
positioning, and, in spite of using more energy globally, lives longer of the
same network using the original routing protocol.","During the past years the interest in multihop wireless networks has been growing signiﬁcantly. These types of networks have an important functionality that is the possibility to use other nodes as relays in order to deliver messages and data from sources to destinations. This functionality makes multihop wireless networks not only scalable but also usable in various areas and contexts. One of the most representative and important examples of multihop wireless networks are wireless sensor networks where small devices equipped with a radio transmitter and a battery are deployed in an geographic area for monitoring or measuring of some desired property like temperature, pressure etc. [1], [2]. The routing on a wireless sensor network is one of the most interesting and difﬁcult issues to solve due to the limited resources and capacities of the nodes. Hence, protocols that use less information possible and need minimal energy consumption of nodes have become more than valuable in this context. Much research work has been devoted to ﬁnding energyefﬁcient routingprotocols for this kind of networks. Often, these pro tocols tend to ﬁnd an approximation of the shortest path between the source and the destination of the message. In [3], the authors analyze the impact of shortest path routing in a large multihop wireless network. They show that relay trafﬁc induces congested areas in the network. If the trafﬁc pattern is uniform, i. e. every message has a random source and a random destination uniformly and independently chosen, and the network area is a disk, then the center of the disk is a congested area, where the nodes has to relay much more messages that the other nodes of the network. We have the same problem if the network area is a square, or a rectangle, or any other twodimensional convex surface. Our experiments show that, when using geographic routing [4] on a network deployed in a square, 25% of the messages are relayed by the nodes in a small central congested region whose area is 3% of the total area of the square. Congested areas are bad for a number of important reasons. They raise securityrelated issues: If a large number of messages are relayed by the nodes deployed in a relatively small congested region, then jamming can be a vicious attack. It is usually expensive to jam a large geographical area, it is much cheaper and effective to jam a small congested region. In the square, for example, it is enough to jam 3% of the network area to stop 25% of the messages. Moreover, if an attacker has the goal of getting control over as many communications as possible, then it is enough to control 3% of the network nodes to handle 25% of the messages. There are also energyefﬁciency issues: Aside from retransmissions, that are costly and, in congested areas, often more frequent, the nodes have to relay a much larger number of messages. Therefore these nodes will die earlier than the other nodes in the network, exacer bating the problem for the nodes in the congested region that are still operational. In the long run, this results in holes in the network and in a faster, and less graceful, death of the system. Note that these problems are not solved by trying to balance the load just locally, as donearXiv:0711.0892v1  [cs.NI]  6 Nov 20072 by a few protocols in the literature (like GEAR [5], for example)—these protocols are useful, they can be used in any case (in our protocols as well), and are efﬁcient in smoothing the energy requirements among neighbors, while they can’t do much against congested areas and they don’t help to alleviate the above discussed security related issues. Lastly, there are other concerns in the contexts where the nodes are carried by individual independent entities. In this paper we do not consider mobility. However, if the position of the node can be chosen by the node itself in such a way to maximize its own advantage, and if energy is an issue, then no node would stay in the center of the square, the highly congested region. If the nodes are selﬁsh, an uneven distribution of load in the network area leads to an irregular distribution of the nodes—there is no point in positioning in the place where the battery is going to last the shortest. Selﬁsh behavior is a recent concern in the network community and it is rapidly gaining importance [4], [6], [7]. Most of these contributions show how to devise mechanisms such that selﬁsh nodes can’t help but truthfully execute the protocol. For the best of our knowledge, here we are raising a new concern, that can be important in mobile networks or whenever the position of the node can be an independent and selﬁsh choice. Solving these issues—security, energyefﬁciency, and tolerance to (a particular case of) selﬁsh behavior—is an important and nontrivial problem, and, at least partially, our goal. In this paper we attack this problem and set outrouting in outer space , a new routing mechanism that transforms any shortest path routing protocol (or approximated versions of it) into a new protocol that, in case of uniform trafﬁc, guarantees that every node of the network is responsible for relaying the same number of messages, on expectation. We can show that a network that uses routing in outer space does not have congested areas, does not have the associated security issues, and, in spite of using more energy globally, lives longer of the same network using the original routing protocol— that is, it is more energyefﬁcient. We support our claims by showing routing in outer space based on geographic routing, and performing a large set of experiments. The rest of the paper is organized as follows: In Section II we report on the relevant literature in this area; in Section III we present the theoretical idea behind our work, we come up with routing in outer space and prove its mathematical properties; In Section IV, after describing our node and network assumptions and our simulation environment, we discuss on on the practical issues related in implementing routing in outer space starting from geographic routing; lastly, we present an extensive set of experiments, fully supporting our claims.II. R ELATED WORK","In this paper, we study the impact of shortest path routing in a large multi-hop wireless network. We show that, when using geographic routing, 25% of the messages are relayed by the nodes in a small central congested region whose area is 3% of the total area of the square. This is bad for a number of reasons. First, it induces congested areas in the network, where the nodes have to relay much more messages than the other nodes in the network. Secondly, if the nodes are selfish, then there is node in the",cool!
286,Flash: Efficient Dynamic Routing for Offchain Networks.txt,"Offchain networks emerge as a promising solution to address the scalability
challenge of blockchain. Participants directly make payments through a network
of payment channels without the overhead of committing onchain transactions.
Routing is critical to the performance of offchain networks. Existing solutions
use either static routing with poor performance or dynamic routing with high
overhead to obtain the dynamic channel balance information. In this paper, we
propose Flash, a new dynamic routing solution that leverages the unique
characteristics of transactions in offchain networks to strike a better
tradeoff between path optimality and probing overhead. By studying the traces
of real offchain networks, we find that the payment sizes are heavy-tailed, and
most payments are highly recurrent. Flash thus differentiates the treatment of
elephant payments from mice payments. It uses a modified max-flow algorithm for
elephant payments to find paths with sufficient capacity, and strategically
routes the payment across paths to minimize the transaction fees. Mice payments
are directly sent by looking up a routing table with a few precomputed paths to
reduce probing overhead. Testbed experiments and data-driven simulations show
that Flash improves the success volume of payments by up to 2.3x compared to
the state-of-the-art routing algorithm.","Blockchain is the fundamental infrastructure to support a new generation of decentralized Internet applications. It has enabled many innovations from decentralized cryptocurren cies to smart contracts [ 25,35].Scalability is the primary challenge for blockchain to support decentralized applica tions at the Internet scale [ 18,23,25,27,32]. As a concrete example, Bitcoin only processed fewer than 20 transactions per second at peak from November 2018 to January 2019 [ 12], whereas Visa was reported to process more than 47,000 trans actions per second at peak during the 2013 holiday seasons [27]. Blockchain is intrinsically difficult to scale because it aims to achieve a global consensus between all participants, whichinvolves complex protocols to consistently replicate all state changes to every participant. Despite various efforts to im prove the efficiency and reduce the overhead of blockchain protocols [ 32,37], their performance is ultimately limited by the network bandwidth and processing capability of the participants to replicate state changes. Offchain networks (or payment channel networks) emerge as one of the most promising solutions to solve this dilemma [ 18, 23,27]. Two participants can use a bidirectional payment channel to make multiple payments with each other, with out the need to commit every transaction to the blockchain. The blockchain is only involved when the participants set up and tear down the payment channel, or when they have disagreements on the transaction results. A network of pay ment channels form an offchain network , and allows two participants without direct channels to send payments via a multihop path. A transaction can be safely committed in an offchain network, as soon as the participants on the payment path achieve an agreement with a multisignature contract such as a Hashed Timelock Contract (HTLC) [ 27]. This obvi ates the need to consistently commit the transaction to every participant on the blockchain. As a result, offchain networks have the potential to significantly improve the transaction throughput and reduce the transaction latency of blockchain. Examples including Lightning Network [ 10], Raiden Net work [ 11], and Ripple [ 9] are increasingly being adopted and used in practice. Routing is critical for offchain networks to fulfill their promise. Efficient routing can successfully deliver most pay ments in an offchain network, minimizing the operations on the blockchain. While routing is a wellstudied problem in computer networking, there is a key difference between an offchain network and a computer network. In a computer network, each link has static capacity and the capacity does not change as the link sends packets. However, in an of fchain network, the initial balance of a payment channel (i.e. channel capacity) is deposited by the participants during the channel setup, and the balance is updated after every 1arXiv:1902.05260v2  [cs.NI]  11 Jun 2019payment in the channel. As a result, offchain networks are more dynamic than computer networks. At a high level, there are two major classes of protocols for network routing. The first uses static routing where the path for each flow is fixed after (periodical) path discovery. Many traditional routing protocols such as OSPF and ISIS fall into this class. Static routing guarantees reachability, and is typically used when the network topology and traffic are mostly static, or if the network capacity is abundant and the performance is not a concern. Early routing protocols for offchain networks, such as Flare [ 28], SlientWhispers [ 24] and SpeedyMurmurs [ 29], leverage this approach, but they suffer from low transaction throughput, because they do not consider dynamic channel balance in offchain networks. The limitation of static routing motivates the second class of protocols that use dynamic routing, where the path for each flow or flowlet is dynamically updated based on real time network characteristics. Many emerging solutions in datacenters and interdatacenter WANs [ 14,20,21,31,33] fall into this class. Spider [ 30] applies dynamic routing to offchain networks and achieves higher performance than earlier static protocols for blockchain. Dynamic routing, however, is not a panacea. It is well known that there exists a tradeoff between path optimality and probing overhead. Using an optimal path comes at the cost of probing the network in the first place. This is es pecially true for offchain networks, as the channel balance changes after each payment, and one needs to pay the prob ing overhead for every single payment if an optimal path was to be chosen. Classical solutions in computer networking suggest to strike a balance between path optimality and probing over head by differentiating the treatment of elephant flows from that of mice flows [ 13,16]. A small number of elephant flows are dynamically scheduled on different paths for high per formance, and the vast mice flows are randomly mapped to static paths for low probing overhead. Realizing the idea of elephant flow routing in offchain networks is challenging for at least two reasons. •First, we need to understand whether elephant flow routing is suitable for offchain networks. If all pay ments in offchain networks have similar size, then there does not exist elephant payments in the first place. Even if so, if mice payments are highly ad hoc, i.e. a sender often chooses a different receiver to send a payment, significant probing for mice payments can still not be avoided. •Second, we need to design an efficient protocol to sat isfy the unique requirements of offchain networks. Because offchain networks are more dynamic than computer networks, elephant payments need to probe more paths aggressively in order to find efficient paths.The problem is exacerbated by the distributed nature of offchain networks. Unlike datacenters networks and interdatacenter WANs that have centralized control planes, blockchain systems are decentralized, and there is no coordination between participants. To address these challenges, we first conduct a measure ment study on the payment traces of two realworld blockchain networks, Ripple [ 9] and Bitcoin [ 7]. By analyzing the traces, we find two important characteristics of cryptocurrency transactions. First, the payment sizes of transactions exhibit heavytailed distributions. Most transactions are small, while a small number ( <10%) of transactions contribute to the most (over 94%) of the total transaction volume. This demonstrates the existence of elephant transactions in offchain networks. Second, payments are highly recurrent. Within a period of 24 hours, over 80% of transactions happen between existing pairs of participants. This suggests that most mice payments can leverage existing paths with no extra probing overhead, instead of discovering new paths. Based on these findings, we design Flash, a new dynamic routing solution for offchain networks that separate elephant payments from mice payments to achieve high throughput with low probing overhead. Flash uses a modified maxflow algorithm based on EdmondsKarp [ 15] to probe and find can didate paths with sufficient capacity for elephant payments, and carefully distribute the payments over these paths to minimize transaction fees (collected by intermediate nodes). Mice payments are sent through a few existing paths if they have already been computed to minimize the need of probing. Payments are split into trunks to be sent through multiple paths when needed, since the atomicity of the transactions can be ensured with recent proposals such as Atomic Multi Path Payments (AMP) [1]. In summary, we make the following contributions. •We perform a measurement study on the payment traces of real blockchain networks to understand the traffic characteristics of cryptocurrency transactions. •We design Flash, a new routing protocol for offchain networks that separate elephant payments from mice payments to achieve high throughput with low prob ing overhead. •We implement a prototype of Flash on a cluster of com modity servers. Testbed experiments and tracedriven simulations show that Flash improves the network throughput by up to 2.3x compared to the stateof theart routing algorithm. The code of Flash and the offchain network traces are open source on Github.1 1https://github.com/NetXlab/Offchainroutingtracesandcode 2ONCHAINAliceBobDeposit: 6 Tx1Tx2Alice: 4Bob: 2OFFCHAINDeposit: 6Alice: 5Bob: 1423351Open ChannelClose ChannelFigure 1: A payment channel between Alice and Bob. Alice and Bod deposit 4 and 2 satoshis respectively to open a channel. Two payments are made off the chain. Alice first pays Bob 1 satoshi, and then receives 2 satoshis from Bob. Finally, the channel is closed by committing the latest state to the chain. 2 BACKGROUND AND MOTIVATION In this section, we first give a brief introduction of offchain networks, and then motivate our design with our findings in real traces from Ripple [9] and Bitcoin [25]. 2.1 A Primer on Offchain Networks Payment channels. Payment channels are a basic building block of offchain networks. A payment channel is established between two parties, and allows them to make multiple pay ments without the need to commit every payment to the chain. To ensure the offchain security, both parties maintain a multisignature address which guarantees that any balance updates on the channel require mutual agreement. The chain is only involved when there is a dispute regarding current balance or setting up and tearing down the channel. By mov ing payments away from the chain, it reduces computation and replication overhead, improves transaction throughput, and lowers latency. Furthermore, because sending payments over payment channels does not need to reward “miners”, payment channels provide competitively low transaction fees and better support payments. A toy example in Figure 1 illustrates the basic operations of a payment channel with bitcoin as the cryptocurrency. To open a channel, Alice and Bod jointly make a transaction on the chain, in which they deposit funds to the channel. The channel is established after the transaction is commit ted to the chain. In this example, Alice funds the channel with 4 satoshis and Bob with 2 satoshis (Satoshi is the small est unit of bitcoin). At this point, the balance—which limits the maximum amount of bitcoin one party can send to the other—becomes 4 satoshis for Alice and 2 satoshis for Bob. AliceBobCharlie4415AliceBobCharlie53241Figure 2: An indirect payment on a payment channel network. Alice can pay Bob 1 satoshi through Char lie, but cannot do more than 2 satoshis since the pay ment channel from Charlie to Bob has a balance of 2 satoshis. The balance of each party is then updated after each success ful transaction executed based on mutual agreement. Thus if Alice pays Bob 1 satoshi, both would have a balance of 3 satoshis. As long as the channel remains open and the pay ment from one to the other does not exceed its balance, Alice and Bob can repeatedly make any number of transactions. Finally, Alice and Bob can choose to close the channel if no more transactions are needed. The final state of the chan nel is committed to the chain, and both can withdraw their balances. Offchain networks. It is clearly impractical for a user to open a payment channel with every party it needs to trans act with; the channel opening cost and the latency of doing this on the chain would be prohibitive. Payment channel networks, or offchain networks , are therefore developed to support indirect payments between two parties that does not have a payment channel. An offchain network is composed of many payment channels. Figure 2 shows an example of a simple offchain network with just two payment channels. Two parties can make a transaction so long as there is a directed path between them and the payment amount is no bigger than the minimum channel balance of the path. In order to guarantee the atomicity and security of payments via multiple payment channels, an offchain network usually relies on the hash timelocked contracts (HTLC) [ 27]. For ex ample, in Figure 2 if Alice wants to pay Bob 1 satoshi through Charlie, HTLC guarantees that Charlie receives funds from Alice if and only if Bob receives the payment from Charlie successfully. Otherwise the funds are returned to the payer Alice. HTLC also guarantees that either the balances of all channels on the path are updated or none is updated after the transaction. Offchain networks have seen rapid development over re cent years and is increasingly adopted in many scenarios. Lightning Network [ 10], Raiden Network [ 11], and Ripple [ 9] are prominent examples in practice. Lightning and Raiden are offchain networks for Bitcoin and Ethereum, two of the most popular blockchain technologies, respectively. Lightning for 3109 107 105 103 101 101 103 105 107 109 USD0.00.20.40.60.81.0CDF(a) Ripple 100 101 102 103 104 105 106 107 108 109 1010 1011 1012 Satoshi0.00.20.40.60.81.0CDF (b) Bitcoin Figure 3: Payment size distributions for Ripple and Bitcoin transactions. example has 2,700+ active nodes, 21,000+ channels, and 560+ bitcoins (∼$2M USD) network capacity as of January 2019 according to [ 8]. Ripple is another large offchain network using its own cryptocurrency called XRP as the main trans action medium. Its network has 200+ enterprise customers including banks and payment providers worldwide. All three offchain networks allow transactions involving multiple pay ment channels. 2.2 Motivation We believe a sensible first step of designing offchain net work routing is to understand the workloads carried by these newly emerged networks, that is the cryptocurrency transac tions. Unfortunately this aspect has received little attention so far compared to other features of offchain networks such as the topological characteristics [29]. We conduct a measurement study of transactions in the Ripple network, which to our knowledge is the only offchain network whose transaction data are publicly available. We use a dataset from [ 6] that includes over 2.6 million transac tions in Ripple from January 2013 to November 2016. Each transaction data entry includes sender, receiver, volume, and time information. In addition we crawl the onchain transac tions of Bitcoin as our second dataset. We believe the charac teristics of onchain and offchain transactions are similar as more onchain transactions are moving to offchain networks for faster turnaround and lower cost. We run a full Bitcoin node with Bitcoin Core2to synchronize all blocks and col lect all the transactions (over 103 million) from its launch in January 2009 to October 2018. We exclude all the newly generated coins with no senders. We now highlight two unique characteristics of cryptocur rency transactions observed from the traces. Payment sizes are heavytailed. We first investigate the payment size distribution. Figure 3 shows the CDF of pay ment size in Ripple and Bitcoin traces. We observe that most payments are small, while a few large payments contributes 2https://bitcoin.org/en/fullnodethe most volume. For Ripple, nearly 94.5% of the volume be longs to only 10% of the payments, the size of which is more than $1,740 USD. The median payment size is only $4.8 USD. For Bitcoin, 10% of payments larger than 8.9×107satoshis contribute 94.7% of the total volume, while the median pay ment size is only 1.293×106satoshis. This is intuitive to un derstand since in practice highvolume transactions happen between a small number of enterprises and financial insti tutions. For example, the volume of transactions between banks can be substantial, but the trade frequency is relatively low. Most of the time transactions happen between individu als and merchants, such as money transfer between friends and families, and purchases of goods and services. These constitute the vast majority of the use of cryptocurrencies in the same way traditional currencies are used. The design implication of heavytailed payment size is salient. On one hand, small or mice payments are naturally less likely to saturate a payment channel, and tend to be sensitive to the settlement time. As such, they can be deliv ered with high probability using just one or a few paths, and the paths do not have to be carefully chosen to minimize delay. On the other hand, a large payment or elephant pay ment consumes much more funds and using a few paths may not be sufficient. Elephant payments are more important to the offchain network as their successful delivery would greatly improve the success volume and performance. At the same time minimizing transaction fees is also important to elephant payments given their significant volume. We thus believe a more delicate and optimized routing solution is jus tified for elephant payments to thoroughly consider all the factors above. The solution needs to strategically choose a good set of paths with enough capacity, and carefully sched ule the elephant payment across the paths with varying fees. The increased settlement time and probing overheads are acceptable given the low frequency of elephants. Our distinct treatment of elephant and mice payments is markedly different from prior work that treats all payments equally through the same routing mechanism [ 24,28–30]. As we will show, exploiting this characteristic gives us more flexibility to improve success volume and ratio of the network while maintaining the overheads. Payments are highly recurrent and clustered. We next investigate the relationship between sender and receiver of the offchain transactions. Due to the lack of this information in the Bitcoin trace, we only analyze the Ripple trace. We examine each of the 1306 days the Ripple trace covers, and identify the recurring transactions as those with the same senderreceiver pairs within a 24hour period. Observe that the median percentage of recurring transac tions among all transactions of the day stands at 86% across 40.0 0.2 0.4 0.6 0.8 1.0 Percentage of recurring transactions0.00.20.40.60.81.0CDF(a) The CDF of percentage of recurring transactions among all transactions in a 24hour period across 1306 days in Ripple. 0.0 0.2 0.4 0.6 0.8 1.0 Percentage of top5 recurring transactions0.00.20.40.60.81.0CDF(b) The CDF of percentage of top5 recurring transactions among all recurring trans actions in a 24hour period across 1306 days in Ripple. Figure 4: Analysis of the recurring transactions in the Ripple trace. 1306 days as shown in Figure 4a. Thus most of the trans actions in Ripple are actually recurring within a 24hour time frame. Moreover, we find that a user’s recurring trans actions happen with a small set of users. Figure 4b shows for an average user, its top5 most frequent recurring pay ments account for over 70% of the daily transactions. These properties again make intuitive sense since the realworld financial relationship for most people is stable and clustered. One mostly transacts with a small number of parties such as their favorite online merchants and offline businesses (shops, diners, etc.) near work and home, as well as their friends and family. The design implication of recurring transactions and clus tered receivers is also interesting. It allows the use of a rout ing table to store the paths for the recurring receivers, so path finding can be simplified to table lookups especially for mice payments. A small routing table would be enough to cover most recurring transactions due to the clustered nature of them. This is instrumental towards reducing the overhead of processing (mice) payments without much performance sacrifice. To quickly recap, the transaction characteristics presented here enable us to explore a larger design space for offchain routing, and motivate our design of Flash which we now introduce. 3 DESIGN Flash is a distributed online routing system that processes each transaction as it arrives at the sender, because a central ized offline approach is inherently infeasible for decentral ized offchain networks with constantly changing channel balance. Flash differentiates elephant and mice payments and applies different routing algorithms in order to achieve a bet ter performanceoverhead tradeoff. For elephants that have significant impact on overall performance, Flash first adopts a modified maxflow algorithm to find and probe paths with sufficient balance to satisfy their demands, and then solvesan optimization program to split the payment over paths to minimize the transaction fees. For mice payments whose demands are easy to satisfy, Flash uses a lightweight solu tion that simply routes them randomly through a small set of precomputed paths whenever possible in order to reduce the probing overhead. 3.1 Prerequisites Flash’s design relies on two prerequisites about the offchain networks. Locally available topology. The topology of an offchain network, without the channel balance information, is fairly stable and changes on an hourly or daily scale. This is be cause opening or closing a payment channel requires on chain transactions which take at least tens of minutes, and a channel usually remains in the network after establishment. Therefore practical offchain routing protocols in Lightning and Raiden require each node to locally store the topology of the offchain network and periodically update it using some gossiping protocols [ 3,5]. Flash assumes similar mechanisms are in place and the connectivity topology is locally available at each node. Note the topology is a directed graph since payment channels are bidirectional: funds can flow in either direction and channel balances on different directions are different. Atomic multipath payments. To improve the network uti lization, Flash uses multipath routing whenever possible and assumes the atomicity of multipath payments is guar anteed, similar to prior work [ 30]. This can be achieved by mechanisms such as Atomic Multipath Payments (AMP) pro posed for Lightning [ 1]. Building upon HTLC, AMP allows a payment to be split over multiple paths while ensuring the receiver either receives all funds from several partial pay ments, or gets nothing (i.e. payment fails). The design and implementation of such a mechanism is beyond this paper. 3.2 Routing Elephant Payments The design challenges for routing elephant payments are: (1) how to find good paths with sufficient capacity to sat isfy demand as much as possible, and (2) how to carefully split the payment across the paths in order to minimize the transactions fees. Path finding with modified maxflow. We discuss some strawman solutions to the first challenge on path finding and why they do not work, and then present Flash’s solution with a modified maxflow algorithm. Strawman solutions. With the network topology locally avail able, a first attempt at the path finding problem would be to simply have the sender compute kgood paths. Shortest paths for example are a natural choice since they minimize 51623303030305(a) k simple shortest paths share the same bottleneck path 2020162310030303052020443030(b) k edge disjoint path routing is not always eﬀective  Figure 5: An illustrative example of common shortest path schemes. Node 1 is the sender, and node 6 is the receiver. In each scheme two paths are used, i.e. k=2. number of hops and helps reduce transaction fees. However, restricting to shortest paths may lead to severe underuti lization when they share a common bottleneck. To see this, we consider an example in Figure 5(a). Two simple shortest paths from node 1 to 6 share the same bottleneck link from node 1 to 2. Using them provides a total capacity of 30 while the other path of 1546 is underutilized. To overcome this one may consider edgedisjoint shortest paths, which are used in Spider [ 30]. Yet they may not always work either es pecially when the common bottleneck has abundant capacity. Figure 5(b) shows that using 2 edgedisjoint shortest paths yields a total capacity of 50, while using 2 simple shortest paths that traverse from 1 to 2 yields a total capacity of 60 since the common link from 1 to 2 has abundant capacity now. It is thus important to consider channel capacity in path finding for elephant payments. This naturally motivates us to resort to maxflow algorithms [ 17]. A maxflow algorithm such as EdmondsKarp [ 15] is used to find the maximum flow between a pair of nodes in a flow network. However they cannot be directly applied to offchain networks. Max flow algorithms require a weighted graph, meaning that the balance or capacity of all edges of the graph should be known. This is infeasible in our problem: the channel balance is dynamically changing in offchain networks, and probing each channel of each path whenever an elephant payment arrives does not scale for a network with thousands of nodes and tens of thousands of channels [8]. Flash’s solution. We thus develop a modified maxflow algo rithm based on EdmondsKarp [ 15] to sequentially find k paths and their maximum flow without excessive overheads. Algorithm 1 shows the pseudocode. Each node has the network topology Gwithout capacity information. When a new elephant arrives the sender sin vokes Algorithm 1 to route it. It uses a capacity matrix C to record the probed channel capacity of the paths, and a residual capacity matrix C′to record the remaining capacityAlgorithm 1 Modified EdmondsKarp for elephant payment routing 1:Input : Topology graph G, a payment ( s,t,d) from stotwith demand d, maximum number of paths needed k 2:Output : Path set P, capacity matrix C 3:P=∅,f=0 ▷Initialize maximum flow f 4:C=∞ ▷Initialize capacity matrix C[n×n] 5:C′=∞ ▷Initialize residual capacity matrix C′[n×n] 6:while|P|<kdo ▷Find at most kpaths 7: p=BreathFirstSearch (G,C′,s,t) 8: ifp==∅then 9: break 10: Add ptoP 11: Probe each channel on pto obtain their capacity Cp 12: Find the bottleneck capacity c=min Cp 13: f=f+c 14: v=t 15: forv,sdo 16: u=p[v] 17: ifC[u,v]=∞then ▷Set channel capacity for the first time 18: C[u,v]=Cp[u,v] 19: C′[u,v]=Cp[u,v] 20: ifC[v,u]=∞then 21: C[v,u]=Cp[v,u] 22: C′[v,u]=Cp[v,u] 23: C′(u,v)=C′(u,v)−c ▷Reduce channel capacity 24: C′(v,u)=C′(v,u)+c ▷Increase capacity of the channel in the reverse direction 25:iff≥dthen 26: return P,C ▷Return paths found and capacity 27:else 28: return∅ of channels as in EdmondsKarp [ 15]. Both CandC′are ini tialized to infinity (lines 4–5 in Algorithm 1). It then enters a loop with at most kiterations to find at most kpaths. In each loop Flash first runs the BreadthFirstSearch on topology G with the residual capacity matrix C′to find a feasible short est path pwith nonzero capacity (line 8), and adds pto the solution set P. It then sends probes along pto obtain capacity of each channel on it, and obtains the bottleneck capacity c. This indicates that we can send con path p(line 14). It updates the capacity of channels that have been probed for the first time in Caccording to the probing results Cp. It also updates the residual capacity of channels on path pin the residual capacity matrix C′using cto reflect the new flow found by p. After the loop terminates, Algorithm 1 returns the paths Pand capacity matrix Cif the maximum flow f over these paths satisfies the payment demand d. Compared to EdmondsKarp with O(|V||E|)iterations, our algorithm ends with at most kiterations and kpaths to probe 6when there are at least kpaths between sandtonG. This helps reduce the probing overhead. We find that setting k between 20 to 30 provides good performance in practical of fchain network topologies with thousands of nodes and tens of thousands of channels. Also our algorithm works with out the capacity matrix as input by assuming each channel has nonzero capacity. It is thus possible, though rare in our evaluation, that our algorithm finds a path but its effective capacity is zero after probing. Path selection. Given a set of paths with sufficient capacity from Algorithm 1, the next step is to determine how to route over them to minimize the total transaction fees. The fee information is collected during the probing process with the capacity information. We take a principled approach and solve this using mathematical optimization. Specifically, we have the path set Pand the capacity matrix C. We represent the fee collected by a channel (u,v)with a charging function fu,v. We assume fis convex. Thus the fee amounts to fu,v(rp)if we route a partial payment of rpto(u,v). The objective of the optimization program is to minimize the total fees subject to constraints that the payment demand dis met, and channel capacity is respected: minÕ p∈PÕ {(u,v)}ap u,vfu,v(rp) (1) subject toÕ p∈Prp=d, Õ p∈Prpap u,v−Õ p∈Prpap v,u⩽C(u,v),∀(u,v). Here ap u,vindicates whether puses channel(u,v)or not. Note that partial payments on different direction of the same channel can offset each other in terms of balance. The optimization program (1)is a convex optimization and can be solved using standard solvers quickly due to the small problem size with kpaths. In practice the fee charging function is typically linear with a fixed fee plus a volume dependent component, which means (1)is a simple linear program and even easier to solve. 3.3 Routing Mice Payments The design challenge for mice payment routing is to sim plify the protocol and minimize overhead due to their large quantity. Applying elephant routing design here would be an overkill. We now present our design for mice payments which also consists of path finding and path selection. Path finding. Each node maintains a routing table for mice payments. It contains paths for the unique receivers of this node. Upon seeing a new receiver that does not exist in the routing table, the node computes top mshortest paths (i.e. using Yen’s algorithm [ 36]) on the local topology G, and addsthem to the routing table. If the receiver is in the routing table, Flash simply reuses the existing paths. Since most payments are recurring as explained in §2.2, this design sim plifies path finding into table lookups in most cases without any computation. The recurring nature of mice also ensures the routing table size is not too large. We use top mshortest paths where mis much less than kthe number of paths used for elephant routing in §3.2, because mice payments do not require much capacity, and typically a few shortest paths provide good performance ( m=4in our evaluation). The routing table is periodically refreshed when the local network topology Gis updated (by the underlying gossip protocol): all entries are recomputed using the latest G. Also when a payment encounters an unaccessible path with zero effective capacity or no connectivity, Flash replaces it with the next top shortest path. Timeouts are used to remove receivers and their entries that have not been accessed for a long time to limit the routing table size. Path selection. With mshortest paths from the routing table, the sender determines path selection using a trialand error loop. It first sends the full payment along a random path p. If successful the protocol ends. Otherwise, the sender probes pto find its effective capacity cpand sends a partial payment of volume cpalong p. It then updates the remaining demand of the payment and continues the iteration. This ensures low probing overhead since Flash only probes when it is necessary and at most mpaths are probed. The use of multiple paths also improves the success ratio of delivering the payment. Instead of following a fixed order (say in a descending order of path length), Flash randomly picks the paths to better load balance them without knowing their instantaneous capacities. Lastly, when mpaths are exhausted and demand is not satisfied, Flash declares the payment fails. 4 SIMULATION In this section, we evaluate the performance of Flash against existing offchain routing algorithms using simulation. Our evaluation aims to answer the following questions: •How does Flash perform under realistic offchain net work topologies and traces? •How does channel capacity and network load affect Flash’s performance? •How effective is differentiating elephant and mice pay ments in Flash? •How effective is the mice payment routing algorithm? 4.1 Methodology","Offchain networks (or payment channel networks) are emerging as one of the most promising solutions to solve the scaling challenge of blockchain. They allow two participants to make multiple payments with each other, without the need to commit every transaction to the blockchain. As a result, offchain networks have the potential to significantly improve the transaction throughput and reduce the transaction latency of blockchain. However, routing is critical for offchain networks to fulfill their promise. Efficient routing can successfully deliver most payments in an offchain network, minimizing the operations on the blockchain.",cool!
17,Clustering Effects on Wireless Mobile Ad-Hoc Networks Performances.txt,"A new era is dawning for wireless mobile ad hoc networks where communication
will be done using a group of mobile devices called cluster, hence clustered
network. In a clustered network, protocols used by these mobile devices are
different from those used in a wired network; which helps to save computation
time and resources efficiently. This paper focuses on Cluster-Based Routing
Protocol and Dynamic Source Routing. The results presented in this paper
illustrates the implementation of Ad-hoc On-Demand Distance Vector routing
protocol for enhancing mobile nodes performance and lifetime in a clustered
network and to demonstrate how this routing protocol results in time efficient
and resource saving in wireless mobile ad hoc networks.","A wireless mobile adhoc network is a group  of mobile devices that forms  a network which does not   requir e the usage of wires or cables for communication . Mobile nodes in this  network are able to  detect the presence of  nodes that are in close proximity . Due to the limited transmission range of  wireless network interfaces, multiple networks “hops” may be needed for one node to exchange data  with another across the network. Wireless ad hoc networks have some properties such as the dynamic  network topology, limited bandwidth and energy constraint in the network  as described by Kumar et  al [1]. Mobile ad hoc network  (MANET)  is useful for different purposes e.g. military operation to  provide communication between squads, collabo rative and distributed computing, wireless mesh  control, wireless sensor networks, hybrid network, medical control etc.  Kumar et al  [1] said “r outing   protocol plays very important part in implementation of mobile ad hoc networks . The following are  the main  protocols used in routing:   Proactive or table driven routing protocols and Reactive or on demand routing protocols. DSR  (Dynamic Source Routing) requires no periodic packets of any kind at any level within the network  as  stated by Johnson et al  [2].  2   DSR does not use any periodic routing advertisement, link status sensing, or neighbour detection  packets, and does not rely on these functions from any underlying protocols in the network. This  entirely on demand behaviour and lack of periodic activity allows the number of overhead packets  caused by DSR to scale all the way down to zero, when all nodes are approximately stationary with  respect to each other and all routes needed for current communication have already been discovered   also as stated by Johnson et  al [2]. As nodes begin to move more or as communication patterns  change, the routing packet overhead of DSR automatically scales to only that needed to track the  routes currently in use. In response to a single Route Discovery (as well as through routing  information from other packets overheard), a node may learn and cache multiple routes to any  destination. This allows the reaction to routing changes to be much more rapid, since a node with  multiple routes to a destination can try another cached route if the one it has been using should fail.  This caching of multiple routes also avoids the overhead of needing to perform a new Route  Discovery each time a route in use breaks. The operation of Route Discovery and Route Maintenance  in DSR are designed to allow  unidirectional links and asymmetric routes to be easily supported. In  wireless networks, it is possible that a link between two nodes may not work equally well in both  directions, due to differing antenna or propagation patt erns or sources of interference  as described by  Johnson et al  [2]. DSR allows such unidirectional links to be used when necessary, improving overall  performance and network connectivity in the system  [1].     DSR also supports internetworking between different types of wireless networks a llowing a source  route to be composed of hops over a combination of any types of networks available  by Johnson et al   [2]. For example, some nodes in the ad hoc network may have only short range radios, while other  nodes have both short range and long range  radios; the combination of these nodes together can be  considered by DSR as a single ad hoc network  [2].   DSR is an on demand routing protocol and cannot perform  well in a large MANET and the reason is  that it has scalability issues  when the size of the n etwork increases , mostly  when there is node  mobility simultaneously .  Proactive routing requires control overhead for building and updating this table, having information   about the state of the network. For ondemand  routin g protocols,  routes are found when  required ;  however this causes it to suffer  significant route setup delay which becomes intolerable in the  presence of both a large number of nodes movement . The fundamental  idea of on demand routing  protocols  is that , an initial  node sends a route request  and makes a decision based on the reply   received , which may be sent by an intermediate mobile node . However, on demand routing  algorithms have the disadvantage of increasing per packet overhead. This perpacket  overhead  reduces  the available bandwidth for information transmission  in the network . Due to the routine  of  dissemination  of path request s (flooding), it is difficult to reduce  the dissemination of packets   unnecessarily [1].  Management  of large number of node s is one of the essential issues ad hoc n etwork  faces.     The nodes of a wireless adhoc network are divided into numerous  fragmented  or intersecting  clusters.  Each cluster elects one node  as the so called cluster head and t hese distinct  nodes are accountable  for  the routing process. Neighbours of cluster heads cannot be cluster heads as well.   But cluster heads are able to communicate with each other by using gateway nodes . A gateway is a  node that has two or more cluster heads as its neighbours or — when the clusters are disjoint —at least  one clust er head and another gateway node.   Cluster heads  helps in the reduction of traffic and this is because requests will only be sent through  them . Information transmission is therefore done only by these cluster heads  from one cluster to the  other . As in any other categorized  protocol  used in routing , there are overheads associated with cluster  formation and maintenance  as described by Sk. Munwar and Dr. V.V.Rama Prasad [3].       3   Figure  1: A cluster based Ad Hoc n etwork : [4]          Pattern  used by CBRP :  Source → Cluster head → Gateway → Cluster head → Gateway → ··· → Destination     This paper presents the implementation of Adhoc On Demand Distance Vector  (AODV ) routing  protocol to enhance the performance and lifetime of nodes in a clustered network and to demonstra te  how this routing protocol results in time efficient and resource saving  in mobile ad hoc networks.  AODV is implemented using Network Simulator 2 (NS 2) which is the simulation environment. NS  2[5] is an object oriented discrete event driven network simu lator developed at University of  California ( UC) Berkeley written in C++ and Object Tool Command Language  (OTcl ).    2.0 Related work s","DSR (Dynamic Source Routing) is a routing protocol that is used in mobile ad hoc networks. It is a table driven routing protocol and has the advantage of scalability in large networks. However, DSR has the disadvantage of increasing per packet overhead. This per packet overhead reduces the available bandwidth for information transmission in the network. The routing protocol is a table driven routing protocol and has the disadvantage of increasing per packet overhead. The routing protocol is a table driven routing protocol and has the disadvantage of increasing per packet overhead. The routing protocol is scalable in large",cool!
171,QF-Geo: Capacity Aware Geographic Routing using Bounded Regions of Wireless Meshes.txt,"Routing in wireless meshes must detour around holes. Extant routing protocols
often underperform in minimally connected networks where holes are larger and
more frequent. Minimal density networks are common in practice due to
deployment cost constraints, mobility dynamics, and/or adversarial jamming.
Protocols that use global search to determine optimal paths incur search
overhead that limits scaling. Conversely, protocols that use local search tend
to find approximately optimal paths at higher densities due to the existence of
geometrically direct routes but underperform as the connectivity lowers and
regional (or global) information is required to address holes. Designing a
routing protocol to achieve high throughput-latency performance across network
densities, mobility, and interference dynamics remains challenging.
  This paper shows that, in a probabilistic setting, bounded exploration can be
leveraged to mitigate this challenge. We show, first, that the length of
shortest paths in networks with uniform random node distribution can, with high
probability (whp), be bounded. Thus, whp a shortest path may be found by
limiting exploration to an elliptic region whose size is a function of the
network density and the Euclidean distance between the two endpoints. Second,
we propose a geographic routing protocol that achieves high reliability and
throughput-latency performance by forwarding packets within an ellipse whose
size is bounded similarly and by an estimate of the available capacity. Our
protocol, QF-Geo, selects forwarding relays within the elliptic region,
prioritizing those with sufficient capacity to avoid bottlenecks. Our
simulation results show that QF-Geo achieves high goodput efficiency and
reliability in both static and mobile networks across both low and high
densities, at large scales, with a wide range of concurrent flows, and in the
presence of adversarial jamming.","The adoption of multihop wireless mesh networks in access, back haul, vehicular, swarm, or ad hoc contexts remained modest over the last couple of decades despite substantial R&D. However, recent trends are contributing to growth in the adoption of these networks. Among these trends is the growth in the number of edge nodes uti lizing shortrange communications—with high speed (i.e., mmWave or Sidelink) 5G communications [ 1–3] or low speed (i.e., LoRa or NB IoT) communications in resourcelimited and infrastructurelimited settings [ 4]. The increased availability of SDR (Softwaredefined Radio) (e.g., 5GNew Radio [ 5]) is contributing to this trend byproviding greater interchangeability. Likewise, flexibility in the higher levels of the networking stacks (using, e.g., OpenFlow [ 6]) is contributing to this trend. Finally, most commercial networks, both realized and proposed, are full of fiber nearer the core of the network, but this architecture is not easily mimicked in military applications, resulting in an acute need for mesh technologies [ 7,8]. These trends motivate a reconsideration of gaps that remain in the performance of multihop wireless mesh systems. We will focus on the gaps in goodput efficiency, reliability, latency, and tolerance to external as well as internal interference. In this paper, we address these gaps in the context of routing. We are particularly interested in the quick establishment of high goodput efficiency routes, even as the networks scale in size, in the presence of limited network density and/or network dynamics—whether due to node mobility, traffic load that is variable, or interference that is benign or adversarial. To that end, the proposed solution needs to generalize across a wide range of network configurations, in contrast to many extant routing protocols whose performance is tuned to specific configurations, e.g., high density or low interference levels. 1.1 Challenges We propose that one of the primary unresolved routing challenges for wireless meshes is the difference in handling the complexity of sparse network connectivity. This is not intended to include the issues where some of the nodes are not connected to the bulk of the network. In ad hoc networks, there is a nonzero probability that a few nodes will be disconnected at any density, but as the density increases beyond a critical point, the degree of disconnection falls off exponentially. In mobile networks, such loss of connection can be shortlived and be addressed with a modicum of delay tolerance. Define the network density, 𝜌, as the expected number of nodes within a single hop range of an arbitrary location. Then for net works of nontrivial size, there is a critical density, 𝜌0, such that as the density falls below 𝜌0, the network rapidly becomes mostly disconnected, and as the density rises above this threshold, islands of local connectivity rapidly coalesce to include almost all of the nodes.1The transition is sharper for larger networks but never a step function (i.e., never a true phase transition). When the network density is only slightly above 𝜌0, there is a high probability of connectivity between any pairs of nodes, but the topology of the network is qualitatively dissimilar from networks of high densities (e.g., 𝜌=5). This is illustrated by Fig. 1. Lowdensity 1A theoretical derivation of 𝜌0is not known. At one time, we was thought that 𝜌0=√ 2. Numerical simulations have shown that 𝜌0is slightly larger than√ 2, but have so far failed to disprove a new conjecture 𝜌0=3√ 3. In the remainder of the document, when the density is√ 2, this is intended to represent the approximate critical density. 1arXiv:2305.05718v1  [cs.NI]  9 May 2023YungFu Chen, Kenneth W. Parker, and Anish Arora Figure 1: Foamlike networks vs foglike networks. Each fig ure has the same 300 randomly placed nodes. On the left the transmission radius ( 𝑅) is equal to 1 yielding 𝜌=2, while on the right𝑅=2yielding𝜌=8. networks have a predominance of “holes” where flow across the region requires substantial detours. At higher densities, these holes largely disappear. To make this distinction evocative, we will refer to minimally connected networks as foamlike (i.e.,∼√ 2≤𝜌<∼2) and highly connected networks as foglike (i.e.,∼4≤𝜌). This qualitative difference between foamlike and foglike net works affects many existing protocols. For example, geographic routing for pointtopoint flows performs efficiently in foglike networks where optimal routes tend to be geometrically direct; decisions based only on local information are sufficient and require minimal overhead. But they tend to perform poorly in foamlike networks, where they backtrack upon encountering holes in the network. The limited use of regional or global information can make a few backtrack events very inefficient, significantly distort ing the average. Conversely, many proactive and reactive routing protocols are prone to performing a global search, even when it is not necessary due to high network connectivity. Decisions based on global search (or search over large regions) limit the network scaling, because of high control overhead and/or long latency. Another primary challenge is related to the stability of paths, which is decreased by node mobility, changes in external interfer ence (including adversarial jamming), and even changing traffic patterns. Because these problems are exacerbated by increasing net work scale, and because the speed at which the network can repair itself (or refine routing paths) slows with increasing scale, at some scale, these problems lead to network failure [ 9]. Moreover, routing in some applications has to account for the network transitioning from foamlike to foglike, or vice versa. 1.2 Approach Foamlike networks maintain connectivity, despite frequent and larger holes, through indirect routes. Let us define path stretch as the ratio of the length of the shortest path to the Euclidean distance between the endpoints. Our experimental results demonstrate that path stretch can be over 10x for short paths at minimal network densities and that path stretch decreases for longer paths and at higher network densities. Quantifying this trend allows a proba bilistic bound on the path length. For example, at a density of 2, there is a 99% chance that endpoints that are 5 transmission units apart have a path stretch of less than 3.1, implying that 99% of thetime, the length of a shortest path between the end points (at this network density) will be less than 15.5 transmission radius. LetPdenote the probability of finding a shortest path in a de fined region. By using regression over many simulations of uniform random networks and random pairs of endpoints, a function was derived for the smallest ellipse that contains a shortest path be tween a given pair of endpoints with probability P. This function depends both on the distance between the endpoints and the den sity of the network. Only ellipses with vertices at the source and the destination are considered. For notational convenience, let ℓ𝑐𝑜𝑛 be the ratio of the length of the major axes of this ellipse to the distance between the endpoints. The basic approach to routing in a network, given a source and a destination, is to search for a shortest path within the elliptic region determined by the function. This approach to routing is refined to accommodate concurrent flows and external interference in the network, as follows: (1)Estimate an effective density 𝜌′(≤𝜌) of the network, which is the density resulting from only using the capacity not already allocated to other flows. Accordingly, determine an ellipse factor, ℓ𝑐𝑎𝑝(≥ℓ𝑐𝑜𝑛), for a larger ellipse that whp contains a shortest path in the presence of internal and external interference. (2)Search for a shortest path that avoids exceeding the capacity of relay nodes where possible. (3)Track the residual capacity at each node for use in the process. 1.3 Contributions of the Paper This paper shows the feasibility of a probabilistic framework that limits exploration while yielding a sufficiently high probability of routing success when paths exist. This is in contrast to routing based on worstcase analysis, which leads to an overly pessimistic framing of the solution space and incurs higher overhead and lower stability. Secondly, an elliptic search region is computed to serve as a slightly conservative but reasonably tight estimate of the region for exploration. The result can be directly applied without modification to many networks that only approximate the uniform constant density assumption. For classes of networks that depart radically from these assumptions, it is our position that the deployment distribution information can and should be incorporated into the routing system, in an analogous manner. Thirdly, a design of geographic routing protocol, QFGeo (for QuickFireGeo), is presented. QFGeo is based on a depthfirst search in the elliptic region. QFGeo offers notably improved performance in foamlike networks, where “optimistic” routing approaches al most always underperform, often dramatically. QFGeo also per forms well in foglike networks where “conservative” algorithms, especially proactive worst case algorithms, often incur overhead that is rarely needed. That is QFGeo yields nearly optimal goodput efficiency across a wide range of densities. Almost all existing al gorithms make implicit assumptions about network topology that favor either foglike or foamlike networks and ensure dramatic loss of efficiency when these assumptions do not hold. This combination of approaches leads to a useful middle ground between aggressively proactive and highly reactive approaches. If changes to the network, its environment, or the traffic are in frequent a proactive algorithm that approximates maintenance of all relevant network information may be acceptable. But in more 2QFGeo : Capacity Aware Geographic Routing using Bounded Regions of Wireless Meshes dynamic scenarios and at larger scales it becomes impossible to maintain so much information. In contrast an extremely reactive approach makes finding a route on demand quite expensive, which also limits scaling. We postulate that a location service is approxi mately the minimal proactive infrastructure that doesn’t result in acute ondemand route discovery problems. However, having found a route with minimal proactive infrastructure QFGeo proactively maintains it for the duration of the flow. Our simulation results for QFGeo show: •QFGeo achieves high goodput efficiency and has a high likeli hood of finding reliable paths, notably in diverse network config urations as well as in the presence of changes in network density, node mobility, external interference, and jamming. •QFGeo achieves its improved performance due to limiting the search region and its introduction of memory of the routing path. •Proper selection of the ellipse factor improves the goodput effi ciency by reducing the latency while not harming the reliability. •The memory of the last forwarder in QFGeo allows ongoing flows to further reduce their packet traversal time and optimize the packet reception reliability, especially when nodes are mobile. Moreover, memory improves the goodput efficiency in scenarios of lowdensity networks with and without mobility as well as in highdensity networks with mobility. Our simulations are comparative with Geographic Routing and with Maximum Capacity Routing [ 10]. Extensive simulations com paring with other stateofthepractice protocols such as Optimized Link State Routing (OLSR) [ 11] and Ad hoc On Demand Distance Vector (AODV) [ 12] show even greater improvements in QFGeo ; these are, however, omitted from this paper for lack of space. 1.4 Organization of this Paper In Section 2, we discuss QFGeo in the context of related stateof theart routing solutions in wireless mesh networks. In Section 3, we outline our numerical analysis of the path stretch and the existence of tight bounds on the minimum search region for the shortest path. In Section 4, we present the QFGeo routing protocol in terms of a detailed explanation of its distributed approach for the bounded search of route forwarding. We describe our evaluation and simulation results, and make concluding remarks in Section 6. 2 RELATED WORK","In this paper, we address the routing challenges of multi-hop wireless mesh networks. We propose a routing protocol that can be used to establish high-goodput efficiency routes even as the networks scale in size, in the presence of limited network density and/or network dynamics. We consider the following scenarios: a network with a low density is a foam-like network, and a network with a high density is a fog-like network. The network topology is qualitatively different from a dense network, where the topology. We propose a routing protocol that can be used to",cool!
449,On-Demand Routing for Urban VANETs using Cooperating UAVs.txt,"Vehicular ad hoc networks (VANETs) are characterized by frequent routing path
failures due to the high mobility caused by the sudden changes of the direction
of vehicles. The routing paths between two different vehicles should be
established with this challenge in mind. Stability and connectedness are a
mandatory condition to ensure a robust and reliable data delivery. The idea
behind this work is to exploit a new reactive routing technique to provide
regulated and well-connected routing paths. Unmanned Aerial Vehicles (UAVs) or
what are referred to as drones can be both involved in the discovery process
and be full members in these discovered paths in order to avoid possible
disconnections on the ground when the network is sparsely connected. The
different tests of this technique are performed based on NS-2 simulator and the
outcomes are compared with those of related on-demand routing protocols
dedicated for VANETs. Interesting results are distinguished showing a reduced
end-to-end delay and a high delivery ratio, which proving that this
heterogeneous communication between vehicles and UAVs is able to extend the
network connectivity.","V ANET has seen a growing interest from both academia and industry. Such network can provide a lot of opportunities to design many applications supporting a comfortable and safe driving experience. Additionally, by exchanging messages, this kind of networks offers useful services and entertainment ap plications to drivers and passengers helping to avoid accidents, trafﬁc jam, and to enhance road capacity. Furthermore, these communications can also include helpful infotainment like the weather, restaurant locations, gas station, parking places, etc. A reliable data delivery is considered as a keystone to deploy these aforementioned applications. Data packet routing plays a basic role to support the perfor mance success of V ANETs. Numerous routing challenges need to be addressed in order to adapt the proposed solutions to the unique characteristics of V ANETs, especially the movements of vehicles (various speeds and directions). The majority of the proposed reactive routing protocols dedicated for V ANETs only discover the existence of routing paths between a pair of vehicles and they are based on a recovery strategy when a link breakage occurs. As a result, when there is a path failure, a signiﬁcant delay is diagnosed in the initializing of a new path.Moreover, the majority of these protocols do not take into account whether the discovered paths are dense with vehicles or not in order to increase the probability of a successful data delivery between a pair of source and destination nodes. In other words, when the network on the ground is poorly dense (i.e.,sparsely connected), these protocols cannot forward the data packets because of their inefﬁcient recovery strategies (new route discovery) to ﬁnd a new path, and consequently, the data packets cannot reach their ﬁnal destinations. In this paper, we propose a new ondemand routing protocol based on the idea of using UA Vs as full members belonging to existing V ANETs on the ground and assisting vehicles during the routing process. This proposal is designed for urban cities and is essentially based on the densest (connected), stable, and the fastest paths in terms of delay for the data delivery. A set of techniques is adopted during the discovery process, which aims to reduce the delay of delivery and minimize the routing overhead. A scoring technique based on several criteria is used to select the most appropriate path for the data delivery. Moreover, a maintenance process is deployed in the case of path failures according to the situation of the network as follows: (i) An alternative path can be found at each path failure without reinitiating the discovery process. When the network on the ground is highly fragmented, (ii) UA Vs are used to bridge the communication gaps, thus creating new alternative paths. The remainder of this paper is organized as follows. First of all, we present an overview of relevant related works proposed in the literature in Section II. In Section III, the proposed routing protocol is described in details. The performance evaluation and the outcomes of our proposal are presented in Section IV. Finally, Section V concludes the paper and summarizes some future perspectives. II. R ELATED WORK ","In this paper, we propose a new on-demand routing protocol based on the idea of using vehicles as full members belonging to existing V ANETs on the ground and assisting vehicles during the routing process. The proposed protocol is designed for urban cities and is based on the idea of using UA Vs as full members belonging to existing V ANETs on the ground and assisting vehicles during the routing process. A set of techniques is adopted during the discovery process, which aims to reduce the delay of delivery and minimize the routing overhead.",cool!
257,Scalable and Congestion-aware Routing for Autonomous Mobility-on-Demand via Frank-Wolfe Optimization.txt,"We consider the problem of vehicle routing for Autonomous Mobility-on-Demand
(AMoD) systems, wherein a fleet of self-driving vehicles provides on-demand
mobility in a given environment. Specifically, the task it to compute routes
for the vehicles (both customer-carrying and empty travelling) so that travel
demand is fulfilled and operational cost is minimized. The routing process must
account for congestion effects affecting travel times, as modeled via a
volume-delay function (VDF). Route planning with VDF constraints is notoriously
challenging, as such constraints compound the combinatorial complexity of the
routing optimization process. Thus, current solutions for AMoD routing resort
to relaxations of the congestion constraints, thereby trading optimality with
computational efficiency. In this paper, we present the first
computationally-efficient approach for AMoD routing where VDF constraints are
explicitly accounted for. We demonstrate that our approach is faster by at
least one order of magnitude with respect to the state of the art, while
providing higher quality solutions. From a methodological standpoint, the key
technical insight is to establish a mathematical reduction of the AMoD routing
problem to the classical traffic assignment problem (a related vehicle-routing
problem where empty traveling vehicles are not present). Such a reduction
allows us to extend powerful algorithmic tools for traffic assignment, which
combine the classic Frank-Wolfe algorithm with modern techniques for
pathfinding, to the AMoD routing problem. We provide strong theoretical
guarantees for our approach in terms of near-optimality of the returned
solution.","Mobility in urban environments is becoming a major issue on the global scale [22]. The main reasons are an increas ing population with higher mobility demands and a slowly adapting infrastructure [1], resulting in serious congestion problems. In addition, the usage of public transit is dropping, whilst mobilityondemand operators such as Uber and Lyft are increasing their operation on urban roads, increasing further congestion [7, 25, 41]. For instance, the yearly cost of congestion in the US has doubled between 2007 and 2013 [37, 49], and in Manhattan cars are traveling about 15% slower compared to ﬁve years ago [17]. Space limitations and a largely ﬁxed infrastructure make congestion an issue difﬁcult to address in urban environ ments. While existing public transportation systems need to be extended to ease congestion, it is important to adopt technological innovations improving the efﬁciency of urban transit. The advent of cyberphysical technologies such as autonomous driving and wireless communications will en able the deployment of Autonomous MobilityonDemand Fig. 1. The AMoD network. The white circles represent intersections and the black arrows denote road links. The dotted arrows represent pickup and dropoff locations for single customers. (AM OD) systems, i.e., ﬂeets of selfdriving cars providing ondemand mobility in a oneway vehiclesharing fashion (see Fig. 1). Speciﬁcally, such a system is designed to carry passengers from their origins to their destinations, potentially in an intermodal fashion (i.e., utilizing several modes of transportation), and to assign empty vehicles to new requests. The main advantage of AM OD systems is that they can be controlled by a central operator simultaneously computing routes for customercarrying vehicles and rebalancing routes for empty vehicles, thus enabling a systemoptimal operation of this transportation system. This way, AM OD systems could replace current taxi and ridehailing services and reduce the global cost of travel [44]. Conversely to conventional navigation providers computing the fastest route by passively considering congestion in an exogenous manner, AM OD systems controlled by a central operator enable one to consider the endogenous impact of the single vehicles’ routes on road trafﬁc and travel time, and can thus be operated in a congestionaware fashion. Statement of contributions: We introduce a computationally efﬁcient approach for congestionaware AM OD routing to minimize the system cost—the total cost of executing the routing scheme over all the vehicles in the system. To the best of our knowledge, this is the ﬁrst method that takes into consideration the full representation of the volumedelay function that estimates the travel time based on the amount of trafﬁc. Moreover, we demonstrate that our approach is faster by at least one order of magnitude than previous work (see Section II) for congestionaware AM OD, while being more accurate in terms of congestion estimation. On the algorithmic side, we develop a reduction which transforms the AM OD routing problem into a Trafﬁc As signment Problem (TAP), where the latter does not involve rebalancing of empty vehicles. We then prove mathematicallyarXiv:1903.03697v1  [math.OC]  8 Mar 2019that an optimal solution for the latter TAP instance yields a solution to our original AM OD problem with the following properties: (i) The majority (e.g., 99% in our experiments) of rebalancing demands are fulﬁlled and (ii) the system cost of the solution is upper bounded by the system optimum where 100% of the rebalancing demands are fulﬁlled. (We note that, in practice, the unfulﬁlled rebalancing demand, being just a small fraction – say, <1%– can be addressed via post processing heuristic strategies with minimal impact on cost.) Such a reformulation of the AM OD problem allows us to leverage stateoftheart techniques for TAP, that can efﬁ ciently compute a congestionaware system optimum. In par ticular, we employ the classic FrankWolfe algorithm [13, 27], which is paired with modern shortestpath techniques, such as contraction hierarchies [14] (both of which are implemented in recent opensource libraries [8, 12]). This allows us to compute in a few seconds (on a commodity laptop) AM OD routing schemes for a realistic test case over Manhattan, New York, consisting of 156;000passenger travel requests. Organization : The remainder of this paper is structured as follows. In Section II we provide a review of related work. In Section III we formally deﬁne the instances of TAP and AM OD we are concerned with in this work. There we also discuss the assumptions of our model and possible limitations. In Section IV we provide a description of the FrankWolfe algorithm for TAP. Our main theoretical contribution is given in Section V, where we describe our approach for AM OD by casting it into TAP, and develop its mathematical properties. In Section VI we demonstrate the power of our approach and test its scalability on realistic inputs. We conclude the paper with a discussion and future work in Section VII. II. R ELATED WORK","We introduce a computationally efficient approach for congestion-aware Autonomous Mobility-on-Demand (AM OD) routing, where the routing scheme considers the endogenous impact of the single vehicles’ routes on road traffic and travel time. We demonstrate that our approach is faster by at least one order of magnitude than previous work (see Section II), while being more accurate in terms of congestion estimation. We also demonstrate that our approach is faster by at least one order of magnitude than previous work (see Section II). Furthermore, we demonstrate that our approach is faster than previous work",cool!