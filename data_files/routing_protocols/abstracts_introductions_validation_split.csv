Unnamed: 0,titles,abstract,introduction
167,Deciding How to Decide: Dynamic Routing in Artificial Neural Networks.txt,"We propose and systematically evaluate three strategies for training
dynamically-routed artificial neural networks: graphs of learned
transformations through which different input signals may take different paths.
Though some approaches have advantages over others, the resulting networks are
often qualitatively similar. We find that, in dynamically-routed networks
trained to classify images, layers and branches become specialized to process
distinct categories of images. Additionally, given a fixed computational
budget, dynamically-routed networks tend to perform better than comparable
statically-routed networks.","Some decisions are easier to make than others—for exam ple, large, unoccluded objects are easier to recognize. Ad ditionally, different difﬁcult decisions may require different expertise—an avid birder may know very little about iden tifying cars. We hypothesize that complex decisionmaking tasks like visual classiﬁcation can be meaningfully divided into specialized subtasks, and that a system designed to perform a complex task should ﬁrst attempt to identify the subtask being presented to it, then use that information to select the most suitable algorithm for its solution. This approach—dynamically routing signals through an in ference system, based on their content—has already been incorporated into machine vision pipelines via methods such as boosting (Viola et al., 2005), coarsetoﬁne cas cades (Zhou et al., 2013), and random decision forests (Ho, 1995). Dynamic routing is also performed in the primate visual system: spatial information is processed somewhat separately from object identity information (Goodale & 1California Institute of Technology, Pasadena, Cali fornia, USA. Correspondence to: Mason McGill <mm cgill@caltech.edu >. Proceedings of the 34thInternational Conference on Machine Learning , Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).Milner, 1992), and faces and other behaviorallyrelevant stimuli ellicit responses in anatomically distinct, special ized regions (Moeller et al., 2008; Kornblith et al., 2013). However, stateoftheart artiﬁcial neural networks (ANNs) for visual inference are routed statically (Simonyan & Zis serman, 2014; He et al., 2016; Dosovitskiy et al., 2015; Newell et al., 2016); every input triggers an identical se quence of operations. Clearly Sticks (Classify)Clearly Insects (Classify) Ambiguous (Inspect Further) Figure 1. Motivation for dynamic routing. For a given data rep resentation, some regions of the input space may be classiﬁed con ﬁdently, while other regions may be ambiguous. With this in mind, we propose a mechanism for introducing cascaded evaluation to arbitrary feedforward ANNs, focus ing on the task of object recognition as a proof of concept. Instead of classifying images only at the ﬁnal layer, every layer in the network may attempt to classify images in low ambiguity regions of its input space, passing ambiguous images forward to subsequent layers for further considera tion (see Fig. 1 for an illustration). We propose three ap proaches to training these networks, test them on small im age datasets synthesized from MNIST (LeCun et al., 1998) and CIFAR10 (Krizhevsky & Hinton, 2009), and quantify the accuracy/efﬁciency tradeoff that occurs when the net work parameters are tuned to yield more aggressive early classiﬁcation policies. Additionally, we propose and evalu ate methods for appropriating regularization and optimiza tion techniques developed for staticallyrouted networks. 2. Related Work "
161,Resilient networking in wireless sensor networks.txt,"This report deals with security in wireless sensor networks (WSNs),
especially in network layer. Multiple secure routing protocols have been
proposed in the literature. However, they often use the cryptography to secure
routing functionalities. The cryptography alone is not enough to defend against
multiple attacks due to the node compromise. Therefore, we need more
algorithmic solutions. In this report, we focus on the behavior of routing
protocols to determine which properties make them more resilient to attacks.
Our aim is to find some answers to the following questions. Are there any
existing protocols, not designed initially for security, but which already
contain some inherently resilient properties against attacks under which some
portion of the network nodes is compromised? If yes, which specific behaviors
are making these protocols more resilient? We propose in this report an
overview of security strategies for WSNs in general, including existing attacks
and defensive measures. In this report we focus at the network layer in
particular, and an analysis of the behavior of four particular routing
protocols is provided to determine their inherent resiliency to insider
attacks. The protocols considered are: Dynamic Source Routing (DSR),
Gradient-Based Routing (GBR), Greedy Forwarding (GF) and Random Walk Routing
(RWR).",1.1 Report outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2 Related work 6 
120,Design and Implementation of the End System to Intermediate System (ES-IS) Routing Information Exchange Protocol as a Loadable Kernel Module in Linux Kernel 2.6.txt,"This paper presents a partial implementation of the ES-IS Routing Information
Exchange Protocol packet processing in Linux Kernel 2.6, which is for use in
conjunction with the Connectionless Network Protocol (CLNP) in Aeronautical
Telecommunication Network (ATN). First, we show the data structures involved in
the protocol operation. Second, we describe the map of the packet processing
whose design has been developed in the research. Third, we explain how the
protocol is implemented as a loadable kernel module. Finally, we conclude the
implementation result based on performed tests.","  The increasing demand of air travel requires the im plementation of a new technology to manage the  air space for more optimum utilization while improv ing safety level. Therefore, the International  Civil Aviation Organization (ICAO) tasked its membe r countries, including Indonesia, to apply the  standardized Communications, Navigation, Surveillan ce, and Air Traffic Management (CNS/ATM)  systems [4]. Acting upon this mandate, the Agency f or the Assessment and Application of  Technology (BPPT) initiated the research to help sa tisfy the needs of the Directorate General of  Civil Aviation, and PT Angkasa Pura I and II to imp lement those systems in Indonesia [10].    BPPT began the project with the development of the ATN [9]. This infrastructure enhances the  communications aspect with groundground and airgr ound links for digital data transfer between  aircraft and civil air traffic control facilities. In ATN, data is conveyed by the CLNP [5], which lie s  on the network layer together with several routing information exchange protocols.     As a part of the project, we have built the prototy pe of the ESIS Routing Information Exchange  Protocol as a loadable kernel module in Linux Kerne l 2.6. The implemented protocol has been  supplied with the capabilities to provide basic con figuration information that allows ESs and ISs  directly connected through the same subnetwork to d iscover each other’s presence. However, the                                                    1 Swiss German University, German Center, Tangerang,  Indonesia, {stella.maria,  maulahikmah.galinium}@student.sgu.ac.id  2 The Agency for the Assessment and Application of T echnology/Badan Pengkajian dan Penerapan Teknologi (BPPT),  Jakarta, Indonesia, {fahmi, haret}@inn.bppt.go.id  3 Department of Information Technology, Swiss German  University, German Center, Tangerang, Indonesia,  {james.purnama, charles.lim, harya.widiputra}@sgu.a c.id functions for the distribution of route redirection  information are not yet built. Furthermore, there  has been no test for reliability and performance me asurement conducted as of now.    2. Related Work  "
121,Storage Aware Routing for Generalized Delay Tolerant Networks.txt,"This paper presents a novel storage aware routing (STAR) protocol designed to
provide a general networking solution over a broad range of wired and wireless
usage scenarios. STAR enables routing policies which adapt seamlessly from a
well-connected wired network to a disconnected wireless network. STAR uses a
2-Dimensional routing metric composed of a short and a long term route cost and
storage availability on downstream routers to make store or forward routing
decisions. Temporary in-network storage is preferred over forwarding along a
path that is slower than average and opportunistic transmission is encouraged
when faster than average routes become available. Results from ns2 based
simulations show that STAR achieves $40-50\%$ higher throughput compared to
OLSR in mobile vehicular and DTN scenarios and does $12-20\%$ better than OLSR
in the static mesh case. Experimental evaluation of STAR on the ORBIT testbed
validates the protocol implementation, and demonstrates significant performance
improvements with 25\% higher peak throughput compared to OLSR in a wireless
mesh network.","In the United States, there were close to 280 million smart phone subscriptions in 2015 and the number is expected to cross 410 million by 2021 [1]. The consumer data demand is expected to be 9 exabytes per month in 2021 for smartphone users alone. With several other applications over wireless links such as Internet of Things, it is expected that mobile and wireless devices connected to the Internet over wireles s links will generate the majority of future Internet trafﬁc l oad. However, the current Internet protocol stack was not design ed to handle wireless connectivity and mobility. Industry and academic researchers have deﬁned two major ways of dealing with this situation: innovations at the edge i.e., the acces s network or through a radical redesign of the core networking principles. Support for mobility at the edge is achieved thr ough fast handoff, multihoming, data prefetching, and exploi ting access diversity such as the Google Project Fi [2]. The mobile network industry is working hard on new generation standards, 3G to 5G, that have progressively better support for mobility and handling of the demand for data. At the same time, a fairly large group of academic researchers have made progress in clean slate redesign of the Internet to address native support for both mobility and security. This Future Internet Architecture research initiative [3] [4] [5] that started almost a decade ago is now near completion of the secondphase. MobilityFirst [4], Named Data Network [3], eXpressi ve Internet Architecture [6], Nebula [7] and ChoiceNet [8] are the ﬁve projects funded under the National Science Foundations FIA program [9] in the United States. There are similar programs in Europe [10] and Asia [11] as well. The general approach in several FIA projects is to locate named entities such as content, service, host and other prin  ciples in the network using innetwork lookup mechanisms to ﬁnd the nearest point where the named entity can be found [12]. When combined with the mostly mobile Internet usage, one can expect a routing protocol that locates these entities must additionally build and maintain various path s to nodes in the network with the requirement that routes and choices of destinations are both optimized to support varyi ng degree of disconnections. Here disconnection could be due t o variable link quality observed in the wireless edge due to li nk conditions and host mobility and may be extended to lookup delays, cache deletion, router outages as well as delays due to congestion. Even though routing is the main glue that can deliver other architecture functions, this principle comp onent of the network stack, in most FIA projects, is only loosely deﬁned with the exception of MobilityFirst FIA. Therefore, an important initial step is to design a single routing techniq ue that can function well over a range of usage scenarios and provide seamless connectivity across a wide spectrum of sta ble to highly dynamic networks. From a protocol perspective, such a technique might as well be general enough to function under any network architectures, as long as some primary architectural requirements are satisﬁed. Both industry re search in edge network enhancement and academic research in clean slate design can beneﬁt from such a routing protocol. In this paper, our goal is to present a network routing protocol that can function well across a variety of mobile and wireless scenarios as well as deliver data under complet e disconnections. We discuss, in Section VI, the generality o f this protocol that can enable integration into various FIA a r chitectures. We present comprehensive results from the des ign and analysis of this storage aware routing (STAR) protocol. STAR uses link state advertisements so that network nodes can construct the connectivity graph. Each link in the graph data structure consists of the last known (short term) and historic (long term) packet transmission times and each nod eis marked with its storage availability. A breadth ﬁrst sear ch on this graph is used to compute multiple shortest paths to each destination. The path in which the sum of short term transmission times along each link is minimum is considered the best path. STAR then decides to transmit the data along the best path if two conditions are satisﬁed. First: the shor t term transmission time along that path should be not much higher than the long term observations which is built as a moving average over an interval of time. Second, the storage availability on downstream routers must be above a threshol d. If either condition is violated, STAR chooses to temporaril y store the data instead of forwarding it along the path. In the scenario when the short term transmission time along the pat h is lower than the long term, STAR would opportunistically us e that path to take advantage of the improvements, provided th e storage criterion at downstream routers are met. STAR was the basis of the the intradomain routing scheme called Generalized Storage Aware Routing (GSTAR) [13] in the MobilityFirst architecture. We note in Section VI that w ith some minor changes, it is also suitable as a single network protocol for Named Data Network instead of separate routing schemes that have been suggested to support adhoc [14], V ANET [15] and wired networks [16]. We present the primary motivation that led to the design of STAR in Section II. We then present the design of a storage router and choice of a transport layer in Section III. We describe the STAR protoco l and present performance analysis in Section V. Related work , applicability to various FIA proposals and conclusions are presented in Sections VI and VII respectively. II. M OTIVATION The motivation behind STAR was to design a protocol that works in a range of wireless network types, ranging from well connected to disruption tolerant networks. It is well known that temporary path quality variations is an inherent characteristics of all wireless networks. These variation s may be caused by ﬂuctuations in signaltonoise ratio (and henc e the link speed), mobility, channel fading, as well as MAC layer congestion. In addition, energy constrained sensor a nd mobile phone networks may have intermittent disconnection s due to low power and sleep mode operations. In general, cellular, WiFi, multihop mesh, MANET, wireless sensor networks and tactical networks are all affected by some degree of intermittent disconnections. In this aspect, the se networks display characteristics associated with DTN [17] type disconnections although at shorter time scales rangin g from a few seconds to minutes rather than several hours. In addition to disconnections, mobility and channel fading le ad to temporarily poor channel conditions, causing the physic al layer to drop the transmission data rates of active links. Mobile devices may have coverage from multiple networks (e.g. WiFi, cellular and WiMax) with each handoff involvin g signiﬁcant changes in path quality and endtoend bandwidt h. In contrast with complete disconnection, these phenomena have the effect of varying link bandwidth on the endto end path to a mobile device. Based on these considerations,we coin the phrase “generalized Delay Tolerant Networks (gDTN)” to describe the full range of wired and wireless network scenarios of interest. In this classiﬁcation, DTN w ould correspond to a special case of challenged networks with lon g periods of disconnections. Similarly, wellprovisioned w ired networks represent the other extreme where channel quality is nearperfect and disconnections are rare. Our goal is to design a uniﬁed network routing protocol that seamlessly connects the full set of gDTN scenarios includin g DTN and wired networks. At ﬁrst, we will examine the characteristics and design considerations for routing pro tocols proposed for DTN as well as those for MANET and wireless mesh networks. We will then present the design of the uniﬁed approach. The points to note are: 1) DTN routing is often based on historical observation of associations between nodes [18]. This choice is driven by the hypothesis that node mobility and con nection/association probabilities between nodes can be predicted in the long term. 2) MANET and mesh network routing protocols use ﬁrst order metrics like hop based distance from the destina tion [19] [20], transmission time [21], data rate [22] and retransmission count [23]. The objective is to always ﬁnd the best endtoend path to the destination. 3) Since disconnection is a common phenomenon in DTN, routers in DTN store data locally while waiting for the destination route to become available. 4) MANET and mesh network routing protocols react to temporary disconnections or route cost increase by starting route repair and alternate path search. We design STAR: a Storage Aware Routing protocol that borrows principles from both DTN and MANET/mesh net work protocols so that the combination is suitable for all gD TN scenarios. In this paper, we present a comprehensive design along with extensive simulation and emulation results that deﬁned the STAR protocol and was later incorporated in the MobilityFirst GSTAR protocol [13]. We make the following design choices for STAR: 1)Storage Router: We introduce the design of a storage router that allocates additional storage space for all layers of the protocol stack (Section IIIA). 2)Two Dimensional Routing Metric: We design a two dimensional routing metric that makes routing decision based on the current route cost and past history of the cost along the route (Section IV). 3)Temporary Storage: We borrow the DTN concept of temporary data storage when a destination route is unavailable and apply it to the general case where the routing cost is temporarily high as determined from the two dimensional routing metric (Section IV). We perform a detailed simulation based evaluation of STAR and present protocol validation and motivational experime ntal results from a proofofconcept prototype implemented on t he ORBIT [24] testbed (Section V). Results show that STAR performs well in mesh, MANET and DTN scenarios. AlthoughFig. 1. Storage Router the storage and history features allow STAR to function in DTN scenarios, yet STAR is less comparable to various DTN routing protocols than it is to mesh network routing protoco ls. First, unlike most DTN routing protocols, STAR relies on link speed and other physically observable qualities of the communication link can also be used while DTN routing protocols such as PROPHET [25] have used probability of contact as the main indicator of the link quality. Second, ST AR does not use replication based techniques to improve the pro b ability of data delivery to the destination. Most DTN routin g protocols, from epidemic routing [26] to PROPHET [25], rely on some amount of replication to improve success. In sparse networks, given a suitable hypothesis regarding mobility a nd contact probability, any replication based routing is like ly to outperform STAR which is a link state routing protocol. Conversely, random mobility scenarios can be built to make i t hard to ﬁnd a suitable hypothesis regarding contact probabi lity. Since comparison between a link state routing protocol and replication and prediction based routing is rather subject ive, in all our performance analysis, we refrain from comparing STAR with DTN routing protocols and instead use OLSR to benchmark the performance. III. N ETWORK ARCHITECTURE There are two important design choices for a gDTN net work. First, we need a storage capable router and second, a transport protocol that is best suited in our target scenari o which consists of wireless and mobile devices. In this secti on, we present and justify our design choices. A. Storage Router Given the rapidly decreasing cost of semiconductor memory and hard drives, it is economically viable to build routers w ith large storage capacities. This extra storage can be used for in network caching as well as for storing large content in trans it. Figure 1 presents an example design of such a storage router. This router has a terabyte capacity cache to support innetw ork caching of content, 1GB space for network layer storage and100s of megabytes for additional link layer input and output buffers. Such storage routers have also been suggested in th e Cache and Forward [27] architecture to support innetwork caching and temporary storage when the end user disconnects during a content download process [28]. In practice, such a router can also be built using the openﬂow controller [29] with attached disk or solid state storage and the routing protocol may be applied to the openﬂow controller overlay network. This requirement for a storage router is not too far fetched. Most FIA architectures are assuming such storage routers to become more common than the ones that simply ﬁnd routes, store forwarding information and push packets around in the networks. Both MobilityFirst and Named Data Network routers have signiﬁcantly large storage assumptio ns to cache content and network ﬂow information. Our storage router works well in both designs and may be used in either architecture. In this work, we will only use the network laye r temporary storage space and the input and output storage spaces to present performance beneﬁts due to the routing enhancements alone. B. Transport Layer Prior research shows that TCP is inefﬁcient in wireless networks in general [30] and performs poorly in mobile sce narios [31]. Variations of TCP like ITCP [32] and CLAP [33] have suggested that both downstream and upstream TCP connections between a wireless host and the wired network should terminate at the access point (AP) or a proxy gateway. The AP or proxy should then create a separate connection with the wireless host to facilitate the endtoend communicati on. This idea seems proper for static wireless hosts but in mobil e scenarios this technique would require the setup of a new proxy and Mobile IP based forwarding from the original proxy (home agent) to the new proxy (foreign agent) [34]. Moreover, if there is a temporary disconnection, the TCP connection between the AP or proxy and the wireless host may timeout. We assume that there is no special mechanism at the end application and no innetwork caching is used. Therefore, unless the mobile reconnects at the same AP or ﬁnds a route to the AP from the new point of connection, the data transfer process will need to restart from the origi nal server. Clearly, TCP and its variations are not the best choi ces in mobile scenarios. Therefore, hopbyhop based reliable and connectionless transport protocol ideas have been designe d and tested for wireless and mobile networks. There have been several proposals for the hop by hop transport proto col [27] [35] [36] with the general idea to provide transport layer reliability at every hop along the path to the destinat ion. In these protocols, the transport layer data unit (TPDU) may be as large as 1GB and all network routers are responsible for reliably transferring the entire TPDU as a whole from one hop to another. The difference in various versions suggeste d in literature is mainly the reliability mechanism and wheth er the hop by hop reliability is implemented at a special link layer as in the Cache and Forward Architecture [27] or the transport layer implements batch acknowledgement to accou ntfor packets in the TPDU [35]. This hop based transport naturally allows routers to cache the entire ﬁle, more efﬁci ently compared to any endtoend transport. In the latter case, th e individual TPDUs will need to be specially marked to indicat e caching and then ﬁltered and aggregated at the caching route r to reconstruct the original ﬁle. Performance of all hop by hop based transport models has been shown to be better than TCP in wireless and wired scenarios [35] as well as in wired networks with wireless endpoints [27]. Some ﬂavor of hopbyhop transport is also present in the Named Data network (NDN). In NDN, interest packets are propagated hopbyhop along routers and the corresponding data packets follow the reverse route setup b y breadcrumbs left behind by the interest packets. NDN works well in wired networks [37] and has been shown to have application in Vehicular Networks (V ANET) [15] and adhoc networks [14]. Therefore, any hop by hop transport protocol or NDN transport protocol may be used with STAR. We chose a hopbyhop transport protocol with batch acknowledgment s for perhop reliability in our simulation study as well as th e testbed experiments. Adaptation of STAR as a routing protoc ol for NDN is left as future work. IV. STAR: S TORAGE AWARE ROUTING The Storage Aware Routing (STAR) protocol uses a two dimensional routing cost metric that consists of both insta n taneous (short term) and historical (long term) route costs to construct the best routes to the destination. It then consid ers the storage availability on downstream routers to make a store or forward decision. In this section, we will describe the protocol and algorithmic details, particularly (a) the route cost metric used in STAR, (b) the network topology discovery process, (c) the path computation algorithm and (d) the stor e and forward algorithm. Fig. 2. Fixed and variable routing costs on two alternate rou tes A. Routing Cost Metric In any multihop network, the cost of a route has two compo nents: a variable component that primarily determines the q ual ity of the path and a relatively ﬁxed cost that depends on thelength of the path from the source to the destination. Severa l quality metrics such as the transmission success probabili ty (ETX [23]), transmission rate in wireless networks (ETT [21 ] and EDR [22]) and queuing delay(improved ETT [38]) have been proposed in literature to measure spatiotemporal var i ations in link quality. Prior research, in wireless network s, show that routing protocols that minimize the variable cost such as ETX, ETT and EDR of the route provide better per ﬂow throughput in comparison to when shortest path routing is used. However, consider an example scenario shown in Figure 2, where two paths A and B of hopcount 4 and 2 respectively have the same variable cost ( ETX= 4). The probabilities that there will be 4, 3 and 2 transmissions whe n the shorter path (path B) is used are 1/4,1/2and1/4 respectively( ETX= 2⇔Psuccess= 1/2for each link). The probability of four transmissions along path A is always 1. Therefore, path A causes as much interference and contentio n related overhead as path B with a probability 1/4, 1.33×the interference compared to path Bwith probability 1/2and 2× with probability 1/4. Overall, there is a 3/4probability for path A to cause more transmissions and contention related overhead compared to path B. This simple example illustrate s that there may be scenarios where selecting a minimum variable cost path may not be beneﬁcial for the network even though a single ﬂow might fare better. In addition, routes computed using variable costs as the metric tend to experien ce more churn due to frequent changes in the costs. Depending on the timescale of the change, the resulting paths could exhi bit a very high churn. Therefore, we use the hop distance as the primary link cost metric in STAR. However, hop distance fail s to capture link state variations due to physical events such as fading, mobility, congestion and contention that lead to ﬂuctuations in link quality. Therefore, we use hop distance to compute multiple paths to each destination and then use a second metric to allow STAR to rank paths on the basis of such variations. We avoid paths that are much longer than the shortest length path. Therefore, the longest alternative p ath in our work is bounded to one hop more than the shortest path. We propose an expected packet transmission time (EPTT) as a variable link cost metric. We deﬁne EPTT in terms of the relation between the Signal to Interference and Noise Ratio (SINR) and the Bit Error Rate (BER) of the received signal [39]. When the SINR between a transmitter and receive r is high, transmitters may use high bit rate modulation. Wire less standards and the wireless card speciﬁcation sheets deﬁne t he best transmission rate given the value of SINR [40] at the receiver. In practice, this information may be made availab le from the network interface card. We use this information to calculate EPTT as the ratio of packet size in bits to the best transmission rate possible for the signal to be correctly re  ceived. Being a function of SINR, the EPTT metric accurately captures temporal variations in link qualities which may be due to channel fading, interfering transmissions as well as nod e mobility.B. Network Topology Discovery STAR uses the Optimized Link State Routing protocol (OLSR) [41] as its baseline. The network topology informati on is collected using local broadcast of “Hello” messages and network wide relay of “Topology Control (TC)” messages. In order to reduce the number of redundant broadcasts, only a subset of nodes called multipoint relays (MPR) [41] partic i pate in relaying TC messages. The message formats and MPR selection processes are documented in the OLSR RFC [41]. We essentially use the same messaging format as OLSR. In order to relay additional messages needed to compute the two dimensional routing metric, a “Hello” message sent by a nodenkin STAR contains additional ﬁelds: (a) the one hop neighbor list and the best transmission rate rieach neighbor nicould use when communicating with nkand (b) the amount of available storage on node nk. The transmission rate riis calculated from the SINR of the last packet received from neighbor ni. The available storage indicates the total storage capacity less the amount of data waiting to be forwarded. Similarly, the TC messages originated at node nkcontains (a) its own available storage information and (b) informati on from the hello messages from all twohop neighbors. Using the information learned from “Hello” and TC messages, all nodes construct their view of the network connectivity grap h. They use the EPTT reported in the most recent messages as the short term EPTT along the link. Nodes also compute the long term EPTT of each link as a moving average of EPTT reported in subsequent “Hello” and “TC” messages. Each node also includes its available storage information in all mess ages it originales. The information collected through these mes sages are used to populate a table that consists of tuples “Destina tion <Hop distance, previous hop,short term cost, long term cost, storage at previous hop >” for each known destination in the network. The routing control messages are sent as broadcast and are never buffered. Therefore, each received message reﬂects the most current information available to the node. Older messages with stale information are never in circulat ion. Furthermore, when three consecutive messages from node i are not received by node jwithin the expected time duration, instead of deleting the link from its table, node jsets the short term entry for the link i−jto a very high value. The long term cost is frozen until the next update from nodejis received. The scalability of STAR is comparable to that of any link state routing protocol as well as OLSR. Various extensions of OLSR have been proposed to improve the scalability by reducing the routing control trafﬁc, suc h as by using hierarchical routing [42], ﬁsh eye metric [43], clustering [44] and prediction [45]. Any of these extension s are useful as the baseline control messaging protocol for STAR. C. Path Computation STAR searches the graph data structure built using the topology information gathered from control messages to ﬁnd multiple paths to each destination in the network. The hop count metric is use to compute a vector of paths IPi,jbetween each pair of nodes (i,j). The multiple paths are upto qhopslonger than the shortest path. In our experiments, qis set to 1. Since the goal is to ﬁnd multiple paths, a modiﬁed breadth ﬁrst search algorithm [46] is used to build a path vector IPn instead of the standard Dijkstra’s algorithm. Given a pair o f sourceSand destination D, the breadthﬁrst search algorithm works as follows. 1) Assign node S distance 0 to indicate that S is 0 steps away from itself and assign ∞as the distance to all other nodes. Set d←0, and initialize the tree T←S < 0,S,0,0,ωS> 2) For all k∈N, whose assigned distance is d, visit each vertexithat is directly connected to kbut is not the parent of kin the tree. If ihas not been assigned a distance, assign it d+1. Addi/an}bracketle{td+1,k,xki,yki,ωk/an}bracketri}htas a child to node kin the tree T. Ifialready has a ﬁnite distance, it must exist on the tree as a child to another node. We again add the node i/an}bracketle{td+1,k,xki,yki,ωk/an}bracketri}htas a child of node kon the tree. Add the newly found path S−ito the path vector IPS,iif the difference between the minimum and maximum distances in the path vector IPS,iis less than a threshold q. 3) Setd←d+1. 4) IfDis assigned a distance and the difference between the minimum and maximum assigned distances in the path vector IPS,Dis less than qthen repeat from step 2 else stop. Iflis the length of the largest alternate path from Sto Dandmis the average node degree, then step 2 executes Nl=/summationtextl j=1mjtimes and puts the same number of nodes (with duplicates) in the trees. This tree, rooted at S, in the worst case has Das the last leaf node. A reverse traversal from each leaf node to root Sbuildslpaths, with cost leach. Therefore, cost of a reverse traversal from each leaf to S, after the tree is built, costs l·mland gives Nl=ml−1 m−1paths. Thus the cost to ﬁnd paths to Dis amortized to(Nl+l·ml) Nl=O(ml). D. Store and Forward Algorithm All paths to the destination Dare sorted in increasing order of their short term EPTT. The long term EPTT ( y) and short term EPTTs ( x) of the best path i.e., the path with minimum short term EPTT are compared. We choose two thresholds, βandγto determine the tolerance for paths that are slower than usual and for losses due to buffer overﬂow at downstream routers respectively. We describe a forwarding zone which i s the region above the line y=x−βand a storage zone that falls in the region below the line. A path that falls in the forward zone can be used to send ﬁles/data immediately provided that the downstream bottleneck router i.e., the on e with the least storage available among all other downstream routers has sufﬁcient space. The requirement is that the rat io of available to total space is atleast γand the space is sufﬁcient to store the payload being transmitted. If a path is in the storage zone or if the downstream path has low space, ﬁle for the destination is sent to temporary storage on the curre nt router. Figure 3 illustrates this forwarding decision. The choiceFig. 3. Forwarding Decision using the Two Dimensional routi ng cost metric ofβdetermines the tolerance for paths that are slower than usual. Ifβis small, the system more aggressively avoids any path that is slower than than the long term EPTT. Therefore, systems where path quality ﬂuctuates rapidly around a mean, a smaller βis preferable. At the other end of the spectrum, if path quality ﬂuctuates more slowly and hence may remain low for a long time, higher values of βmay be used to avoid delaying data transfer for too long. The choice of γcontrols how often ﬁles will be stored instead of being forwarded. Thi s storage decision not only avoids the use of temporarily sub optimal links but also provides a backpressure that reduces the rate at which trafﬁc is injected into the network from the source. A higher value of γresults in more aggressive ﬂow control at the source while with lower values, the network pushes the data closer to the destination with the risk that i t may be dropped enroute due to lack of space. For example, in heavily loaded networks, a larger value of γwill lead to more effective ﬂow control while under light load, the network wi ll perform better with lower values of γ. In STAR, the congestion information travels upstream at the same rate as periodic ro ute updates travel and hence decision to choose alternate route s can be taken preemptively. Since the backpressure is inb uilt in routing, the time scale of response to congestion is small er compared to explicit congestion notiﬁcations (ECN) [47] in IP routers. The forwarding decision in STAR only uses two indicators of path quality i.e., the expected transmission times and st orage on routers. Other indicators of quality can also be used. For example, the GSTAR protocol in MobilityFirst factors in probabilities of various types of delays such as backpressu re, channel contention and queuing to extend this forwarding de cision [48]. Once the routes are computed, they are ranked base d on the minimum delay metric before making the store and forward decisions. Performance evaluations of GSTAR show some improvement over simple store and forward decisions in certain scenarios. V. P ERFORMANCE EVALUATION We evaluated the performance of STAR in a variety of gDTN scenarios using ns2 [49] based simulations as well as on a proofofconcept prototype on the ORBIT [24] testbed. In this section, we will present the general architectural s etup, deﬁne the performance metrics and present the performance results. A. Protocol Setup We have presented the protocol stack used in this work in Figure 4. The stack shows the transport layer residing right above the network layer and below the application layer. In practice hopbyhop transport protocols can be implemente d as a middle layer between application and the transport laye r. In our implementation, the hopbyhop transport provides a socket interface for the application layer. The transport protocol fragments the application layer ﬁles (of size 12 G B) into transport protocol data units which are maximum 256KB in size. The transport layer then fragments the 256KB TPDU into smaller packets so that they can ﬁt in link layer frames without undergoing IP fragmentation. These smaller datagr ams are sent through a UDP datagram socket and a single batch acknowledgment is requested from the next hop to conﬁrm the receipt of the entire TPDU. Each fragment of the TPDU is encapsulated in network layer packets. The network layer performs link checking in accordance with the forwarding algorithm described in section IV before sending the packet s further down the stack. The next hop acknowledges by sending a bitmap indicating the sequence numbers of any packets tha t need to be retransmitted. When a zero bitmap is received, the segment has been successfully transmitted. B. Performance Metrics We use the following performance metrics for experimental evaluation in various static and mobile wireless scenarios . 1)File streaming throughput : In a DTN scenario, we calculate per hop throughput as the ratio of ﬁle size to the time taken for transmission across each link along the route. We then average the per hop throughput by adding throughput at each hop along the route and di viding by the number of hops. We report this average as the ﬁle streaming throughput. Delays incurred in queues and temporary storage are not used in this calculation. 2)Average ﬁle delays : We calculate the endtoend delay for ﬁle transfers as a sum of total delay including the transmission time, queuing and storage delays incurred by ﬁles that are successfully delivered. We calculate an average endtoend delay over all ﬁles that were delivered during the simulation.(a) HOPSTAR  (b) HOPOLSR  (c) TCPOLSR Fig. 4. Protocol stacks evaluated through ns2 simulations 3)CDF of ﬁle delay : We present the cumulative distri bution of number of ﬁles delivered with respect to the end to end delivery delays for all ﬁles throughout the duration of each simulation run. 4)Average Network throughput : The ratio of number of data bits transmitted through the network over the simulation duration is reported as the average network throughput. 5)Four minute delay : We present the fraction of ﬁles received with less than four minute end to end delay to show the peak number of ﬁles delivered at various offered loads. We chose this metric after observing the delay at saturation point which is around 240 seconds at 10Mbps offered load for all protocol stacks that were simulated. C. NS2 Simulations We used ns2 version 2.33 [49] for all simulations. We used an implementation of the hopbyhop transport protoco l with batch acknowledgement for hopbyhop reliability (Li u et al) [50]. For comparison we used FTP data path at the application and TCP Tahoe implementations available in ns2 . In OLSR experiments, we used the OLSR implementations by Ros et al [51]. We experimented with three protocol stacks shown in Figure 4. We will refer to these stacks as “HOP STAR”, “HOPOLSR” and “TCPOLSR” respectively. The HOPSTAR protocol stack in the simulator executes in the following manner. The hopbyhop transport with perho p batch acknowledgement runs on each router to ensure that the entire transport layer data unit (TPDU) is received reliabl y at every hop. Once a TPDU is successfully received at the next hop, it is queued in the temporary storage space available on the router. When the TPDU reaches the head of the storage queue and there is a suitable route available for the destina tion, it is dequeued from the storage buffer and encapsulated into a network layer datagram. The datagram is then placed in the router’s output buffer, fragmented to ﬁt into link layer fra mes and each fragment is transmitted to the next hop. After the entire TPDU has been transmitted, the sender waits to receiv e an acknowledgement containing a bitmap that indicates the frames that need to be retransmitted. Once a bitmap with all bits set to 0 is received, the TPDU transmission to the next hop is considered successful and the next TPDU transmission may begin. 1) Network, Trafﬁc and Channel Model: We evaluated our work in two stationary and two mobile scenarios. TheTABLE I SIMULATION PARAMETERS Parameter Name Value Link layer frame size 1024 bytes Transmission data rates 1, 2, 5.5, 6, 11 Mbps Storage space 2560 Kbytes File Size 256 Kbytes Storage threshold γ 1280Kbytes Moving average window size 10 Weightage on long term cost ( β) 0.9 Simulation time 1000s Number of simulation runs 10 simulation parameters are shown in Table I. The trafﬁc model used in the simulations is as follows. Each node in the network periodically selects a random ﬁle and transmits it t o a randomly chosen destination. The interval between subse quent ﬁle transfers generated by any node is exponentially distributed. We decrease the mean of the exponential distri  bution to increase the offered load in the network. We also experiment with a bursty trafﬁc model in which ﬁles arrive at exponentially distributed intervals in bursts that last for 100 seconds. Consecutive bursts are followed by quiet perio ds of 200 seconds during which no new trafﬁc is created at that node. The transmission bursts start and end randomly at different nodes so that active trafﬁc is not synchronousl y generated on all nodes. The 802.11b MAC and physical layer implemented by Chen et al [52] was used in all simulations. This implementation provides a full featured implementation of wireless signal re ception with cumulative signal strength from all transmiss ions that are in range to determine capture and collision. Thus, i n all simulations, capture and collision are determined by th e cumulative power of interfering signals that reach a receiv er and not by pairwise comparison. For example, if there are ksimultaneous interfering transmissions during the recept ion of a frame that lasts from time ttot+δt, the sum of signals from the kinterfering transmissions are considered when determining whether the received signal to interferen ce and noise ratio (SINR) is high enough for successful recepti on of the frame. In addition, the interference power is monitor ed throughout the frame reception interval and any change in th e interference level is factored into the computation of SINR . Thus, for successful reception of a frame, the SINR of the frame being received, computed cumulatively over all inter fer ers, must stay above the receive threshold throughout the fr ame reception period. This is more accurate compared to pairwi seTABLE II SIMULATION 1(L INEAR TOPOLOGY ): R ESULTS Parameters OLSR STAR Mean ﬁle arrival times (sec)50 10 1 50 10 1 Average ﬁle de lay (sec)0.678 1.047 2.936 1.634 10.883 5.518 Throughput (Mbps)0.302 0.548 1.417 0.337 0.897 1.765 SINR computation with each competing transmission which overestimates the packet reception probabilities. Preamb le and header processing, packet capture and accurate model of the IEEE 802.11 MAC protocol have also been implemented. We added the auto rate adaptation [53] module to the 802.11 implementation and made necessary changes so that the SINR of received packets can be queried by the network layer to calculate the expected packet transmission time of the link . Since the transport layer implements perhop reliability, 802.11 DCF using RTS and CTS messages is not used, however per frame acknowledgement is still provided by the link layer. W e used the tworay ground [54] based propagation model in all simulations with the exception of simulation 1 where we used an onoff propagation model in addition to the tworay groun d model. The transmission range in all simulations is set to 25 0m and carrier sensing range is 500m. Thus, in the absence of noise and interference, a receiver can be upto 250m away to receive a frame successfully. Under the same conditions, all other nodes that are within 500m of the transmitter can sense the carrier to determine that the channel is busy. All experiments were repeated for 10 runs and an average as well as conﬁdence interval error bar are presented in simulation results. Fig. 5. Simulation 1  Linear Topology with OnOff links: a) Simulation 1: Linear Topology with OnOff Links: We simulate a 10 node topology shown in Figure 5. The goal is to show the beneﬁts of using storeandforward routing under varying link conditions. Therefore, in addition to th e tworay ground propagation loss model with capture and collision, additional variation in link conditions is simu lated by switching the link rates from 1 to 11 Mbps and viceversa at consecutive time intervals uniformly distributed between 20 to 50 seconds. The schedules and duration of these variations a re randomly selected across different links. Results (see Tab le II)show that “HOPSTAR” achieves higher network throughput compared to “HOPOLSR” but at the cost of high endtoend ﬁle delays. The throughput gain is a direct result of reducti on in contention for the wireless medium when nodes decide to store rather than transmit when the link rate is slower than t he long term average. This indicates that the storage aware des ign is good for the network as a whole. At the same time, larger ﬁle delays were observed because ﬁles that incurred longer delays are eventually delivered successfully while in OLSR those ﬁles are likely to be dropped at intermediate queues du e to transmission failures. Fig. 6. Simulation 2  Connectivity graph of nodes in the mesh network: b) Simulation 2: Static Multihop Mesh Network: We simulated a static wireless mesh network with 25 nodes randomly placed in a 500x500m grid. The connectivity graph of a sample network is shown in Figure 6. Nodes in the network generated trafﬁc at an exponentially distributed r ate and the mean interarrival rate of ﬁles was changed to simula te different offered loads. Figure 7(a) shows the CDF of ﬁle de lays at 10Mbps offered load. “HOPSTAR” delivers 932 ﬁles which is 17.8 %more compared to “HOPOLSR” and 6.6× compared to “TCPOLSR”. Figure 7(b) shows that at 10Mbps offered load, 924 ﬁles in “HOPSTAR” are delivered in less than 4 minutes while in “HOPOLSR” and “TCPOLSR” the number is far less (784 and 70 ﬁles respectively). Similarly as shown in Figure 7(c), the overall network throughput achiev ed in “HOPSTAR” is 18% higher than “HOPOLSR” and 2.25 times more than “TCPOLSR” at 10Mbps offered load. These results show that the storage routing concept helps improve the network performance even when the wireless channel conditions are good but the load in the network is high. Much of the above performance beneﬁt (as well as in other simulated scenarios) was seen as a result of the preference to store rather than forwarding along paths that are slower than usual. This feature reduces the duration of interferen ce by choosing links that have higher transmission rate and hen ce are better for spatial reuse if RTS and CTS are not used in the link layer. STAR also prefers storage when when the space in downstream routers is low. This feature acts as a hopbyhop ﬂow control that prevents data loss due to buffer overﬂow on downstream routers in high trafﬁc conditions.0200 400 600 800 100002004006008001000 File Transfer Delay (seconds)Number of files (file size = 256K)     TCP−OLSR HOP−OLSR HOP−STAR (a) CDF of ﬁle delays: mean interarrival time of ﬁles is 5 seconds (offered load = 10Mbps)0 5 10 1502004006008001000 Offered load (Mbps)Number of files (file size = 256K)     TCP−OLSR HOP−OLSR HOP−STAR (b) Number of ﬁles delivered with less than 4 minutes delay0 5 10 1500.511.52 Offered Load (Mbps)Throughput (Mbps) (file size = 256K)     TCP−OLSR HOP−OLSR HOP−STAR (c) Throughout vs. Offered load Fig. 7. Results of Simulation 2a: Static Mesh Network with Ex ponential trafﬁc model TABLE III SIMULATION 3  R ESULTS IN THE DTN AND SPARSE MANET SCENARIO : Parameters OLSR STAR Mean inter arrival time (s) 10 50 10 50 File deliver fraction 72.34 66.67 89.66 79.17 Average ﬁle delay (s) 100.65 109.65 92.28 38.66 File streaming throughput(Mbps) 1.09 1.39 1.7 1.59 In comparison the OLSR routing protocol does not have the concept of storage when the path is slower than average or when the downstream routers have lower storage space. In cas e of “TCPOLSR” where there is an endtoend ﬂow control implemented by TCP, and congestion control is used to thrott le the ﬂow when the network cannot handle the incoming rate. However, as seen in results, the TCP congestion control is to o aggressive. The TCP slow start phase completely throttles t he rate at which the ﬂow enters the network. This leads to lower throughput as the offered load increases. We repeated this simulation under a bursty trafﬁc model. In the same 25 node scenarios as above, we changed the trafﬁc produced by nodes so that they generate trafﬁc by sending ﬁles at exponentiall y distributed interarrival rates in 100 second bursts follo wed by 200 second periods when no new trafﬁc is produced. This process starts randomly at each node and repeats throughout the simulation period. This model more closely represents a webbrowsing trafﬁc where users make requests in between pauses. Results (Figure 8) show that “HOPSTAR” performs better than “HOPOLSR” and “TCPOLSR”. The ﬂow control in STAR acts as a trafﬁc regulator by disallowing a large burst of trafﬁc from entering the network at once and hence improves the network performance. TCPs ﬂow control also works better in this scenario by taking advantage of the time periods when no new trafﬁc is generated during the interval between consecutive bursts. c) Simulation 3: DTN scenario: We simulated a 25 node network in which mobile nodes move within a 2500x2500m area. Nodes follow the Truncated Levy Walk (TLW) [55] mobility model(Figure 9) which represents pedestrian mobi lity on a campus. In the absence of infrastructure nodes, this network represents a sparse MANET or a DTN scenario whereendtoend paths between pair of nodes is not always availab le. Results (Table III) show that “HOPSTAR” can deliver ≈ 80−90% of the ﬁles even in these challenged conditions while “HOPOLSR” falls short in ﬁle delivery fraction, delay as we ll as ﬁle streaming throughput. This observation shows that bo th OLSR and STAR can function in temporarily disconnected scenarios. However, the performance is better when STAR is used. Compared to OLSR, STAR can handle occasional outages in sparse networks when nodes may wander away from communication range of the rest of the network leading to temporary network partitions. In our implementation, bo th OLSR and STAR store data at intermediate nodes when there is no route available and until the mobile nodes move around and reconnect. However, STAR gains an edge over OLSR due to the additional constraint on not using routes when they are worse than average. Thus when a route is found, STAR prefers a route which is more stable or has better link rate compared to the average. This choice results in higher ﬁle streaming throughput. Thus there are fewer retransmission s and hence lower interference when weaker than average links are avoided which also means better spacial reuse leading to higher ﬁle delivery ratio. These results show that STAR work s well in challenged network conditions such as sparse MANET and DTN. d) Simulation 4  Manhattan Mobility Scenario: : We simulate a mobile scenario with 25 nodes within a 500x500m grid. The grid consists of horizontal and vertical streets a nd mobile nodes move along the streets. At street intersection s nodes may turn right, left or go straight with equal prob abilities. The minimum and maximum node speed in this network was set to 5 and 10m/s respectively. This is known as the Manhattan mobility model [56] and it emulates vehicular mobility in an urban environment. Results (Figure 10) show that “HOPSTAR” delivers between 250 to 300 more ﬁles with less than 4 minute delay compared to “HOPOLSR”. “HOP STAR” also achieve higher throughput compared to “TCP OLSR”. D. ProofofConcept Testbed Implementation We have evaluated the “HOPSTAR” protocol stack and compared with “HOPOLSR” and “TCPOLSR” on the OR0200 400 600 800 100002004006008001000 File Transfer Delay (seconds)Number of files (file size = 256K)     TCP−OLSR HOP−OLSR HOP−STAR (a) CDF of ﬁle delays: mean interarrival time of ﬁles is 1 seconds (offered load = 14Mbps)0 5 10 1502004006008001000 Offered load (Mbps)Number of files (file size = 256K)    TCP−OLSR HOP−OLSR HOP−STAR (b) Number of ﬁles delivered with less than 4 minutes delay0 5 10 1500.511.52 Offered Load (Mbps)Throughput (Mbps) (file size = 256K)     TCP−OLSR HOP−OLSR HOP−STAR (c) Throughout vs. Offered load Fig. 8. Results of Simulation 2b: Static Mesh Network with Bu rsty trafﬁc model with burst durations of 100 seconds and int erval between two bursts is 200 seconds 0100020003000 0100020003000050001000015000 X (meters) Y (meters)time (seconds) Fig. 9. Simulation 3 (DTN scenario): Truncated Levy Walk exa mple. Power law slope of ﬂight length = 1 and pause time = 10 seconds BIT [24] wireless testbed to provide a proofofconcept in actual implementation. We used the HOP implementations provided by Li et al [35] and the OLSR implementation with link cost extensions by Tomp [57] respectively as the baseline for the implementation. The expected transmissio n time (ETT) metric [21] is used to compute path cost in both OLSR and STAR. In STAR, the most recently learned ETT is used as the short term cost and a moving average of ETT is maintained as the long term cost. STAR also uses storage information on downstream path to decide whether data shoul d be forwarded or temporarily stored at the current router. As shown in results before, this storage consideration acts as a ﬂow control mechanism that restricts the inﬂux of ﬂow into the network and hence reduces the chance for buffer overﬂows at downstream routers. In addition, the 2D forwarding stra tegy makes opportunistic use of good links. OLSR, however, does not have such mechanism built except that if there is no available route, data is stored at the transport layer at eac h hop instead of being dropped immediately. We performed experiments in three scenarios and the results are presente d in this section.a) Testbed Experiment 1  Mobile node and Access Point:: We emulate a scenario in which a mobile device connects to an access point (AP) to download content (Fig ure 11(a)). Mobility directly results in SINR variations an d leads to variable bit error rate (BER) between the transmitt er and the receiver. The transmitter reacts to higher error rat es by reducing the transmission rate of the link. Therefore, we em u late mobility by periodically switching the transmission r ates of the wireless driver between 1Mbps to 11Mbps as shown in Figure 11(a). We experiment with two protocol stacks: {HOP,STAR,802.11g }and{TCP,OLSR,802.11g }. Trafﬁc is generated by sending data from the AP to the mobile at 5 second intervals. Size of application layer data is varied from 3251024 KBytes to increase the offered load in the network. Results (Figure 11(b)) show that STAR is able to achieve 20Mbps ﬁle streaming throughput which is only 5Mbps short of the theoretical maximum for a 54Mbps data rate with 1KByte limit on the link layer frame size (Figure 2 in [58] shows that 25Mbps is the theoretical maximum). In comparison, TCP provides a mere 3Mbps throughput. Note that the streaming throughput in TCP is equivalent to the network throughput as there is no concept of storage in TCP. This result may be explained as follows: TCP reacts to lower link rates by dropping the congestion window to the minimum by entering the slow start phase. However, the HOP and STAR combination continues to send at the full rate when the link rate is high and temporarily suspends the transmissions and stores the data when the link rate reduces. The switch back to transmission at high speed is much faster than the time taken by the TCP slow start process since it directly uses the network layer feedback to adjust the transmission rate. Therefore, overall HOP and STAR achieve a higher streaming throughput compared to TCP. b) Testbed Experiment 2  Multihop Mesh Network: : In the second experiment, we show how the storage based for warding decision in STAR helps to achieve better performanc e in a multihop mesh network. We create a 12 node multihop topology (Figure 12(a)) in which three sources S1,S2andS3 transmit ﬁles of size 500KB each to corresponding destinati ons0200 400 600 800 100002004006008001000 File Transfer Delay (seconds)Number of files (file size = 256K)    TCP−OLSR HOP−OLSR HOP−STAR (a) CDF of ﬁle transfer delays with mean inter arrival ﬁle transfer rates of 5 seconds (Offered Load = 10Mbps)0 5 10 1502004006008001000 Offered load (Mbps)Number of files (file size = 256K)    TCP−OLSR HOP−OLSR HOP−STAR (b) Number of ﬁles delivered with less than 4 minutes delay0 5 10 1500.511.52 Offered Load (Mbps)Throughput (Mbps) (file size = 256K)    TCP−OLSR HOP−OLSR HOP−STAR (c) Throughput vs Offered load Fig. 10. Results of Simulation 4a: Manhattan Mobility Model with exponentially distributed ﬁle tranfer rates (a) Topology 0 2 4 60510152025 Offered Load (Mbps)File Streaming Throughput (Mbps)   TCP−OLSR HOP−STAR (b) Result Fig. 11. Testbed Experiment 1: Mobile node and Access Point S cenario D1,D2andD3. Each source generates new ﬁle transfers at an exponentially distributed rate with mean λﬁles per second. We increase λat each node to increase the offered load in the network. Two protocol stacks {HOP,OLSR,802.11g }and {HOP,STAR,802.11g }were compared. Figure 12(a) shows that all ﬁles are transferred along the three paths that pass (a) Topology 024681000.511.522.53 Offered Load (Mbps)Throughput (Mbps)    HOP−OLSR HOP−STAR (b) Results Fig. 12. Testbed Experiment 2: Wireless Mesh Network(a) Topology 00.5 11.5 200.511.522.53 Offered Load (Mbps)Throughput (Mbps)    HOP−OLSR HOP−STAR (b) Result Fig. 13. Testbed Experiment 3  Wireless Mesh Network with pe riodically disconnected links: through node C. As the network load increases, the storage space at node C starts ﬁlling up. When upstream nodes in STAR detect the low storage levels along the route, they choose to store instead of forwarding. However, since OLSR does not use storage information to make forwarding deci sions, it continues to push data along the same route which may result in buffer overﬂow at node C when offered load is sufﬁciently high. Therefore, due to the storage metric used in STAR, a better throughput performance is achieved compared to OLSR (Figure 12(b)). c) Testbed Experiment 3: Multihop Mesh with Periodic Disconnections: This experiment validates our claim that STAR can work well even in DTN scenario when the end to end paths between the source and destination do not alwaysexist. We create a scenario shown in Figure 13(a) where the links AB and ED are periodically turned off and on for 40 and 200 seconds respectively. The off states of these links are phase shifted by 150 seconds so that the two links are never “off” at the same time during the experiments. Files are sent at a constant rate of 1 ﬁle in 5 seconds from source S to destination D. STAR works as follows in this network. When the link AB is off, the long term cost for the route is ﬁnite while the short term cost is inﬁnite. A comparison of the two costs indicates that a route to D existed in the past. STAR uses this information to temporarily store the ﬁle whil e waiting for the link to reappear. Similarly, when the link E D is off, STAR is able to route data to D through the alternate path that goes through G. On the other hand, when the link ED is on, STAR opportunistically selects the lower cost pat h to reach D. As seen in Figure 13(b), these choices validate th at STAR can function well in challenged DTN scenarios. TCP does not function at all in this scenario therefore we have no t included the results for “TCPOLSR”. We show that OLSR functions in this scenario if a hopbyhop transport layer i s used because the transport layer also stores data if there is no route available. However, OLSR is unable to switch routes when the storage at downstream routers is low leading to lowe r throughput compared to STAR. VI. R ELATED WORK "
123,Quality of Service-aware Security Framework for Mobile Ad hoc Networks using Optimized Link State Routing Protocol.txt,"All networks must provide an acceptable and desirable level of Quality of
Service (QoS) to ensure that applications are well supported. This becomes a
challenge when it comes to Mobile ad-hoc networks (MANETs). This paper presents
a security framework that is QoS-aware in MANETs using a network protocol
called Optimized Link State Routing Protocol (OLSR). Security & QoS targets may
not necessarily be similar but this framework seeks to bridge the gap for the
provision of an optimal functioning MANET. This paper presents the various
security challenges, attacks, and goals in MANETs and the existing
architectures or mechanisms used to combat security attacks. Additionally, this
framework includes a security keying system to ascertain QoS. The keying system
is linked to the basic configuration of the protocol OLSR through its
Multi-point Relays (MPRs) functionality. The proposed framework is one that
optimizes the use of network resources and time.","  A MANET is an autonomous type of system which has separately connected sets of self  configuring nodes that may be activated by putting to use various techniques e.g. Bluetooth or  WLAN. MANET is autonomous in behaviour because each node is regarded as its h ost and  router at the same time [1]. They rely on direct communication and multi hops for  communication between distant nodes within the network making them scalable and robust.  These advantages make them more flexible to accommodate many nodes, decentrali ze  administration and their setup can be placed anywhere and at any time [2]. Contrary to other  Wireless systems, MANETs do not have a central authority that monitors the forwarding of  traffic. MANET systems consist of an infrastructure less system of asso ciated nodes connect  through wireless links [1]. Nodes move arbitrarily or rather in a random faction [3]. Security in  MANETs is crucial from the node level to the network level. According to [4], because of the  dynamic nature of MANETs, trust can be used as a measure for nodes that want to provide an  acceptable level of trust in that relationship among themselves. Security in a MANET is way too  challenging than in traditional network environments infused with a central controller because of  the dynamic top ological nature and characteristics of MANETs. MANETs are primarily used in  the army and security based applications e.g. covert missions, emergency, and rescue missions  [8] [6] [9]. The availability of network resources, integrity, and confidentiality dep ends on the 92 Computer Science & Information Technology (CS & IT)   security mechanisms that are put in place.  The design of MANETs makes them vulnerable to  security attacks. The vulnerabilities come through non secure boundaries and compromised  nodes although many other factors contribute to the weakening natu re of MANETs. The best  approach to mitigating attacks is prevention and avoidance algorithms, not security mechanisms  that remove attacks as these tend to require more resources. Network resources in MANETs must  be optimally used to achieve Quality of Serv ice.  The needs for the provision of QoS are  increasing with applications that involve voice and video and it is most appropriate to support  these through the implementation of ad hoc network environments. QoS was first brought to  attention in 1994 as a ph enomenon that has the overall requirements of a network connection, as  well as response time during service times, network detriments such as echo, interrupts, signal to  noise ratio and also loudness levels. QoS is generally the network’s assurance to asce rtain a  specific level of execution to a data transmission [10]. To achieve QoS, the concept of routing is  important. Routing is regarded as the act of steering information from a source node to a terminal  node in the network. [10]. One intermediate node w ithin the network is experienced during the  movement of information. The most important aspect is achieving good QoS. It is impossible to  say a characteristic like this one can be completely run over. It is possible to achieve a greater  QoS to such an exte nt that its dynamic nature would not be such a limitation thus a robust and  efficient security framework is needed. The framework would guard against malicious activity in  the network amongst nodes. This work seeks to close that gap by building a framework  that not  only looks at the security but also the Quality of Service in video streaming applications over  MANETs.     This work is arranged as follows: Section 2 discusses the various routing protocols (RPs) in  MANETs, Section 3 is on trust in MANETs and Sect ion 4 presents security  frameworks studies.  Section 5 presents Typical security attacks in MANETs. Section 6 gives a highlight of related  works while Section 7 presents the proposed framework in detail.     2. OPTIMIZED LINK STATE ROUTING FEATURES     2.1. OLSR  Protocol     OLSR is simply the optimization of traditional link state protocol for MANETs. It falls under the  category of proactive routing protocols. With the OLSR protocol, every network node chooses a  neighbouring node set, commonly termed as the multipoint relay s (MPR), which rebroadcasts the  packets that were initially transmitted. To this end, neighbouring nodes that are not found in the  MPR set have the instruction to only read and process the packets [14]. According to Saravanan  and Vijayakuma [18], OLSR keep s tracks in the pathfinding table to provide a route if  necessitated. MPRs are primarily responsible for declaring and forwarding link state information,  forwarding and controlling traffic, providing effective mechanisms for broadcasting control  traffic by  minimizing the frequency of required transmissions [19]. OLSR utilizes two types of  control messages: Hello and Topology Control (TC). Hello messages are used to the information  concerning the link status and the host’s neighbours [20].     2.2. OLSR Architectura l Design     OLSR has a cross layered design just like that of the OSI (Open Systems Interconnection) model  in networks. From a designer’s perspective, there are two relative choices in the design process of  the protocol. The first option is to design the pro tocol by the rules of the reference architecture  and that is the higher layer being able to access services provided by the lower layer with no  consideration of how such service is made available. Secondly, the routing protocols can be Computer Science & Information Technology (CS & IT)                                93  developed in violati on of the original architecture and that is by allowing cross layer  communication between layers. This deliberate violation is called the cross layer design.     3. SECURITY GOALS I N MANET S    The goal of every system is to achieve excellent quality of service and  adherence to security  targets to protect client data or information [24].     3.1. Availability     Availability is one security target for every system. An authorized user will request us of the node  and in an operable state. The node is therefore supposed to provi de its services by its design.  Attacks may seek to disrupt the node’s operation and also use up some of the node’s resources  but the node must be able to survive those attacks and be available when requested     3.2. Confidentiality     This security feature ensures the unavailability of certain features to unauthorized entities or  users. The information is restricted to only authorized personnel. A message that an as the source  will only be decrypted at the destination node. Many cryptographic attacks may try to reve al the  message contents. An ideal system will be able to protect the contents of such information from  unauthorized users.     3.3. Nonrepudiation     This feature ensures that the source node will not be able to interfere with an occurred action like  deny the authe nticity of a message sent. It also facilitates the detection of malicious nodes. Many  of the existing algorithms are based on reputation and trust e.g. CONFIDANT.     3.4. Authentication     Authentication ensures user validation and avoiding impersonation. The malicious node could  impersonate a legitimate node by using the node’s MAC address or even an IP address to obtain  authentication and also launch its attack at a higher level.     3.5. Integrity     Integrity is a security feature that ensures that the original conte nts of the data are maintained and  not altered in any way. An effort to intercept the data being transmitted, either by human beings  or malicious nodes is an act against the trustworthiness of the network. Dropping attacks are  usually launched by a malicio us node but the node is compelled to cooperate in the system.     3.6. Anonymity     This feature is for privatizing the true identity of a node to ensure privacy and confidentiality. In  most cases, the source of packets is kept private.     4. VULNERABILITIES IN MANET S    MANETs are prone to various [13] security vulnerabilities that pose to gain unauthorized access  to the user’s data. Vulnerabilities of a system may be termed as weaknesses possessed by a 94 Computer Science & Information Technology (CS & IT)   system. MANETs are more vulnerable because they rely on wireless tech nology, unlike  traditional wired networks. Attacks in MANETs can be categorically put in two; namely active  and passive attacks. The severity of these attacks differ. Wireless networks are most vulnerable to  all sorts of attacks internally and externally a s compared to [28] traditional networks (wired  networks) due to limited physical security, scalability, mobile nodes, dynamic topology, lack of  centralized management, and threats emanating from compromised nodes. The vulnerability of  the network highlight s a weakness in the security architecture or system. MANETs operate in  very dynamic environments. Security is very important in MANETs even though the  environments’ hostility makes it difficult to achieve most security properties as proposed by  many author s [24].     4.1. Central Controller     The lack of a centralized controller that could act as a monitoring server is one vulnerability that  comes with MANETs. This makes it complex in terms of security provision against attacks as in  most instances the network envir onment is huge and highly dynamic.     4.2. Dynamic Topology     As mentioned earlier, the network environment in MANETs is dynamic. This may, in turn, affect  the trust relationship among nodes. Malicious nodes that may be compromised within the  network are also diff icult to spot as the nodes are mobile.     4.3. Power Limits     Mobile nodes rely solely on battery power and such may pose so many problems. A node may  behave maliciously within the network and could be suspected of being an internal attacker but  only to discover t hat it behaves selfishly because of limited power supply.     4.4. Resource Availability     Resource constraints are the primary reason why some services are not utilized in MANETs. For  example, secure communication is needed but most often it is difficult to provid e it because of  the dynamic environment. Ad hoc security mechanisms and architectures are needed to prevent  attacks from flooding the network.     5. SECURITY ATTACKS I N MANET S    Attacks in MANETs can be categorically put in two; namely active and passive attacks. The  severity of these attacks differ. Wireless networks are most vulnerable to all sorts of attacks  internally and externally as compared to [28] traditional networks (wired networks) due to limited  physical security, scalability, mobile nodes, dy namic topology, lack of centralized management,  and threats emanating from compromised nodes. The vulnerability of the network highlights a  weakness in the security architecture or system.     5.1. Active Attacks     These are known to disrupt the normal operation of  a network [21]. The attacker actively alters  the network’s normal operation. The attacker acts as one of the stations in the network. In this  way, it able to exploit any other node and uses it to its advantage. It can feed nodes fake packets  or even denia l of service (DoS). The active attacker can:  Computer Science & Information Technology (CS & IT)                                95   Fabricate messages    Replay packets    Modify packets    Drop packets    Node Impersonation    Insert infected code     5.2. Passive Attacks     Passive attacks are characterized by their inability to [19] actively participate in causin g harm to  the network. The attacker monitors the network to attain information. They do that so that they  may get node information, for example, how nodes are communicating and their geographical  location within the network. They do not just attack the net work. At first, they acquire enough  information before launching an attack. Once they acquire information, they easily hijack it and  launch an attack. They can decrypt weakly encrypted data, acquire passwords, private and public  keys, monitor communication  routes, and message flow among entities [29]. It may be hard for  the user to identify a passive attack  as it does not necessarily alter anything regarding user data or  traffic.     6. RELATED WORKS ON SECURITY FRAMEWORKS IN MANET S  "
8,Network-wide Configuration Synthesis.txt,"Computer networks are hard to manage. Given a set of high-level requirements
(e.g., reachability, security), operators have to manually figure out the
individual configuration of potentially hundreds of devices running complex
distributed protocols so that they, collectively, compute a compatible
forwarding state. Not surprisingly, operators often make mistakes which lead to
downtimes. To address this problem, we present a novel synthesis approach that
automatically computes correct network configurations that comply with the
operator's requirements. We capture the behavior of existing routers along with
the distributed protocols they run in stratified Datalog. Our key insight is to
reduce the problem of finding correct input configurations to the task of
synthesizing inputs for a stratified Datalog program. To solve this synthesis
task, we introduce a new algorithm that synthesizes inputs for stratified
Datalog programs. This algorithm is applicable beyond the domain of networks.
We leverage our synthesis algorithm to construct the first network-wide
configuration synthesis system, called SyNET, that support multiple interacting
routing protocols (OSPF and BGP) and static routes. We show that our system is
practical and can infer correct input configurations, in a reasonable amount
time, for networks of realistic size (> 50 routers) that forward packets for
multiple traffic classes.","Despite being missioncritical for most organizations, managing a network is surprisingly hard and brittle. A key reason is that network operators have to manually come up with a conguration, which ensures that the underlying distributed protocols compute a forwarding state that satises the operator's requirements. Doing so requires operators to precisely understand: (i)the behavior of each distributed protocol; (ii)how the protocols interact with each other; and (iii) how each parameter in the conguration aects the distributed computation. Because of this complexity, operators often make mistakes that can lead to severe network downtimes. As an illustration, Facebook (and Instagram) recently suered from widespread issues for about an hour due to a misconguration [1]. In fact, studies show that most network downtimes are caused by humans, not equipment failures [2]. Such miscongurations can have Internetwide eects [3]. To prevent miscongurations, researchers have developed tools that check if a given conguration is correct [4, 5, 6, 7]. While useful, these works still requirearXiv:1611.02537v2  [cs.NI]  30 May 2017network operators to produce the congurations in the rst place. Template based approaches [8, 9, 10, 11] along with vendoragnostic abstractions [12, 13, 14] have been proposed to reduce the conguration burden. However, they still require operators to understand precisely the details of each protocol. Recently, SoftwareDened Networks (SDNs) have emerged as another paradigm to man age networks by programming them from a central controller. Deploying SDN is, however, a major hurdle as it requires new network devices andmanagement tools. Further, designing correct, robust and yet, scalable, SDN controllers is challenging [15, 16, 17, 18]. Because of this, only a handful of networks are using SDN in production. As a result, conguring individual devices is by far the most widespread (and default) way to manage networks. Problem Statement: NetworkWide Conguration Synthesis. Ideally, from a network operator perspective, one would like to solve what we refer to as the NetworkWide Conguration Synthesis problem: Given a network speci cationN, which denes the behavior of all routing protocols run by the routers, and a setRof requirements on the networkwide forwarding state, discover a congurationCsuch that the routers converge to a forwarding state compatible withR.That is, the operator simply provides the highlevel requirements R, and the conguration Cis obtained automatically. Distributed vs. Static routing. Relying as much as possible on distributed protocols to compute the forwarding state is critical to ensure network reliability and scalability. A simpler problem would be to statically congure the forwarding entries of each router via static routes (e.g. see [19, 20]). Relying solely on static routes is, however, undesirable for two reasons. First, they prevent routers from reacting locally upon failure. Second, they can be costly to update as routers often have a large number of static entries. Key Challenges. Coming up with a solution to the networkwide synthesis problem is challenging for at least three reasons: (i) Diversity : protocols have dierent expressiveness in terms of the forwarding entries they compute. For instance, the Open Shortest Path First protocol (OSPF) can only direct traf c along shortestpaths, while the Border Gateway Protocol (BGP) can direct trac along nonshortest paths. Conversely, BGP cannot forward trac along multiple paths by default1, while OSPF supports multipath routing and is thus better suited for loadbalancing trac, a feature heavily used in practice. (ii) De pendence: distinct protocols often depend on one another, making it challenging to ensure that they collectively compute a compatible forwarding state. For instance, BGP depends on the networkwide intradomain conguration; and (iii) Feasibility : the search space of congurations is massive and it is thus dif cult to nd one that leads to a forwarding state satisfying the requirements. This Work. In this paper, we provide the rst solution to the networkwide synthesis problem. Our approach is based on two steps. First, we use stratied Datalog to capture the behavior of the network, i.e. the distributed protocols 1While vendorspecic workarounds to make BGP multipath exist, these break the congruency between the control and data plane and could lead to correctness issues. 2ran by the routers together with any protocol dependencies. Datalog is indeed particularly wellsuited for describing these protocols in a clear and declarative way. Here, the xed point of a Datalog program represents the stable forward ing state of the network. Second, and a key insight of our work: we pose the networkwide synthesis problem as an instance of nding an input for a strati ed Datalog program where the program's xed point satises a given property. That is, the network operator simply provides the highlevel requirements Ron the forwarding state (i.e., which is the same as requiring the Datalog program' xed point to satisfy R), and our synthesizer automatically nds an input C to the Datalog program (i.e., which identies the wanted networkwide cong uration). We remark that our Datalog input synthesis algorithm is a general, independent contribution, and is applicable beyond networks. Main Contributions. To summarize, our main contributions are: {A formulation of the networkwide synthesis problem in terms of input syn thesis for stratied Datalog (Section 2). {The rst input synthesis algorithm for stratied Datalog. This algorithm is of broader interest and is applicable beyond networks (Section 5). {An instantiation and an endtoend implementation of our input synthesis al gorithm to the networkwide synthesis problem, along with networkspecic optimizations, in a system called SyNET . {An evaluation of SyNET on networks with multiple interacting widelyused protocols. In addition, we test the correctness of the generated congurations on an emulated network environment. Our results show that SyNET can auto matically synthesize input congurations for networks of realistic size ( >50 routers) carrying multiple trac classes (Section 6). 2 Networkwide Conguration Synthesis We now illustrate our conguration synthesis approach on a simple example. We highlight how, given a network and a set of requirements, we can pose the synthesis problem as an instance of input synthesis for stratied Datalog. 2.1 Motivating Example We consider the simple network topology, depicted in Figure 1(b), composed of 4 routers denoted A,B,CandD. RoutersBandCcan reach the external network Ext, and router Dis directly connected to two internal networks N1and N2. In the following, we use the term trac class to refer to a set of packets (e.g. packets destined to N1) that are handled analogously according to the requirements. In practice, each trac class may contain thousands of IP prexes [21]. Computation of Forwarding State. We rst informally describe how each router's forwarding entries are computed, assuming the conguration is provided. Each router runs both, OSPF and BGP protocols, and in addition can also be congured with static routes. The computation of OSPF is based on nding least cost paths to the internal destinations as well as to all routers in the network, 3Fwd(TC, Router, NextHop) : Route(TC, Router, NextHop, Proto), SetAD(Proto, Router, Cost) minAD(TC, Router, Cost) minAD(TC, Router, min<Cost>) : Route(TC, Router, NextHop, Proto), SetAD(Proto, Router, Cost) Route(TC, Router, Next, ""static"") : SetStatic(TC, Router, NextHop) Route(TC, Router, NextHop, ""ospf"") : BestOSPFRoute(TC, Router, NextHop) (a) Network Specication N (b) TopologyB AC DExt Ext N1 N2 routerlinkexternal network internal networkPath requirements: Path(N1, A, [A,B,C,D]) Path(N2, A, [A,D]) Path(Ext, A, [A,C]) Path(Ext, D, [D,B]) (c) Requirements 'R SetAD(""static"", A, 10) SetAD(""ospf"", A, 20) ... SetStatic(N1, A, B) ... SetOSPFEdgeCost(A, B, 10) SetOSPFEdgeCost(A, C, 5) SetOSPFEdgeCost(A, D, 5) ... (d) Datalog Input I! 10G interface to B interface TenGigabitEthernet1/1/1 ... ip ospf cost 10 ! 10G interface to C interface TenGigabitEthernet1/1/2 ... ip ospf cost 5 ... ! static route to B ip route 10.0.0.0 255.255.255.0 130.0.1.2 (e) Conguration for Router AInput Synthesis Derive Fig. 1: Networkwide Conguration Synthesis. The input is: (a)declarative net work specication Nin stratied Datalog (b)network topology, and (c)routing requirements 'R. The output is: (d)a Datalog input Ithat results in a forward ing state satisfying the requirements. Congurations (e)are derived from I. where cost is the sum of the link weights dened in router congurations. The leastcost paths are then used to generate forwarding entries at each router to all internal destinations. In our example, these internal destinations are N1and N2. In contrast, BGP computes forwarding entries to reach external destinations, Ext in our example. The computed forwarding entries dene the next hop router for each destination. For example, BGP computes an entry at router AforExtwhich forwards packets to a border router (i.e., either BorC). To decide which router the entry should forward to, each BGP router selects the egress point (i.e., border router) to reach an externallylearned prex based on a preference value. This preference is (typically) dened in the conguration of each border router and propagated networkwide. If multiple routers announce the same preference for a prex, internal BGP routers directs trac to the closest egress point, according to the OSPF costs. Once BGP and OSPF have nished computing their forwarding entries, each router takes these entries (along with those dened via static routes) and selects the OSPF, BGP, static route produced forwarding entry with the highest pref erence (in networking terms, higher preference means lower administrative cost) 4dened in its local conguration. The union of all forwarding entries obtained at the routers is referred to as the forwarding state of the network. Conguration Synthesis. Next, we illustrate the opposite direction (and one this work focuses on): given requirements 'R, nd a conguration which the pro tocols use to compute a forwarding state (as described above) that satises 'R. Let us consider the four path requirements given in Figure 1(c). The rst two state that Amust forward packets for the trac classes N1and N2along the pathsABCDandAD, respectively. Note that these two requirements might re ect a security policy in the network or generated by a trac engineering optimization tool [22, 23]. These two requirements cannot be enforced using OSPF alone. The reason is that, as discussed, OSPF works by selecting the leastcost path (by summing the weights on the links) and there is no assignment of weights to links which would lead to leastcost paths that exactly match the two path requirements. Yet, the two requirements can be enforced by: (i)generating a static route based forwarding entry at Ato forward packets for N1toB;(ii)conguring link weights so paths ADandBCDhave the lowest OSPF costs from A toDand, respectively, from BtoD; and (iii) on routerA, congure a higher preference for forwarding entries based on static routes than OSPF forwarding entries. Because a static route forwarding entry is only generated for destination N1(from (i)) and not N2, this means the entry for N1will forward the trac to routerBwhile the entry for N2will be the OSPF generated one (from (ii)). The last two path requirements state that AandDmust forward packets destined to the trac class ExttoCandB, respectively. The two path require ments can by satised by: (i)setting identical BGP router preferences at the local congurations of BandC; and (ii)conguring link weights so that paths ACandDBhave the lowest costs from AtoCand fromDtoB, respec tively. In this way, BGP will use the results from the OSPF leastcost paths to compute its forwarding entries to Ext. This is an example where BGP interacts with OSPF and uses information from its computation. The following is the nal conguration produced by our synthesizer (the synthesizer is discussed in later sections): {weight 10 is assigned to link AB, {weight 5 is assigned to links BC,CD, andAC, {weight 4 is assigned to link DB, {weight 100 is assigned to the remaining links, {a static route based forwarding entry is dened at router Ato forward trac forN1 toB, and {the router preference for all routers is set to 100. In Figure 1(e), we illustrate an excerpt of router A's local conguration. Phrasing the Problem as Inputs Synthesis for Stratied Datalog. A key insight of our work is to pose the question of nding a network conguration as an instance of input synthesis for stratied Datalog. 5First, we declaratively specify the behavior of the network, i.e. the distributed protocols that the routers run, the protocol interactions, and the network topol ogy, as a stratied Datalog program N. As requirements usually pertain to the stable forwarding state, the stratied Datalog encoding captures the stable state of these routing protocols as opposed to intermediate computation steps. Few relevant Datalog rules are given in Figure 1(a); we detail this specication step in Section 4. The resulting Datalog program derives a predicate Fwdthat denes the forwarding entries computed by all routers, where Fwd(TC, Router, NextHop) is derived if Router forwards packets for trac class TCto router NextHop . Second, we can directly express routing requirements as constraints over the predicate Fwd. We denote these constraints with 'Rin Figure 1. Finally, an input Ito the Datalog program Nidenties a networkwide con guration. We formalize the networkwide conguration synthesis problem as: Denition 1. The networkwide conguration synthesis problem is: Input A declarative network specication Nand routing requirements 'R. Output A Datalog input Isuch that [ [N] ]Ij='R, if such an input exists; otherwise, return unsat. In our denition, [ [ N] ]Idenotes the xed point of the Datalog program Nfor the inputI, and [ [N] ]Ij='Rholds if this xed point satises the constraints 'R. Synthesizing inputs for stratied Datalog is, however, a dicult (and, in general, undecidable) problem [24]. The problem is, however, decidable if we x a nite set of values to bound the set of inputs. This is reasonable in the context of networks, where values represent nitely many routers, interfaces, and conguration parameters. To address the problem, we introduce a new iterative synthesis algorithm that partitions the Datalog program Pinto strata P1;:::;P n, nds an input Ii for each stratum Piand then construct an input Ifor the Datalog program P. Each stratum Piis a semipositive Datalog program that enjoys the property that if a predicate is derived by the rules after some number of steps, then it must be contained in the xed point. We describe this algorithm in Section 5. 3 Background: Stratied Datalog We brie y overview the syntax and semantics of stratied Datalog. Syntax. Datalog's syntax is given in Figure 2. We use r,l, andtto denote zero or more rules, literals, and terms separated by commas, respectively. A Datalog program is wellformed if for any rule a l, we have vars(a)vars(l), where vars(l) returns the set of variables in l. A predicate is called extensional if it appears only in the bodies of rules (right side of the rule), otherwise (if it appears at least once in a rule head) it is called intensional . We denote the sets of extensional and intensional predicates of a programPbyedb(P) and idb(P), respectively. A Datalog program Pisstratied if its rules can be partitioned into strata P1;:::;P nsuch that if a predicate poccurs in a positive (negative) literal in the 6(Program) P::=r (Literal) l::=aj:a (Variables) X;Y2Vars (Rule)r::=a l(Predicates) p;q2Preds (Values) v2Vals (Atom)a::=p(t) (Term)t::=Xjv Fig. 2: Syntax of stratied Datalog body of a rule in Pi, then all rules with pin their heads are in a stratum Pj withji(j <i ). Stratication ensures that predicates that appear in negative literals are fully dened in lower strata. We syntactically extend stratied Datalog with aggregate functions such as minand max. This extension is possible as stratied Datalog is equally expressive to Datalog with stratied aggregate functions; for details see [25] Semantics. LetA=fp(t)jtValsgdenote the set of all ground (i.e. variable free) atoms. The complete lattice ( P(A);;\;[;;;A) partially orders the set of interpretationsP(A). Given a substitution 2Vars!Vals mapping variables to values. Given an atoma, we will write (a) for the ground atom obtained by replacing the variables in aaccording to ; e.g.,(p(X)) returns the ground atom p((X)). The consequence operator TP2P(A)!P(A) for a program Pis dened as TP(A) =A[f(a)ja l1:::ln2P;8li2l: A`(li)g whereA`(a) if(a)2AandA`(:a) if(a)62A. An input for Pis a set of ground atoms constructed using P's extensional predicates. Let Pbe a program with strata P1;:::;P nandIbe an input for P. The model of PforI, denoted by [ [ P] ]I, isMn, whereM0=IandMi=TfA2 fpTPijAMi"
50,Ideal Node Enquiry Search Algorithm (INESH) in MANETS.txt,"The different routing protocols in Mobile Ad hoc Networks take after various
methodologies to send the data starting from one node then onto the next. The
nodes in the system are non-static and they move arbitrarily and are inclined
to interface disappointment which makes dependably to discover new routes to
the destination. During the forwarding of packets to the destination, various
intermediate nodes take part in routing, where such node should be an ideal
node. An algorithm is proposed here to know the ideal node after studying the
features of the reactive routing protocols. The malicious node can be
eliminated from the networking function and the overhead on the protocol can be
reduced. The node chooses the neighbor which can be found in less number of
bounces and with less time delay and keeping up the QoS.","An arrangement of versatile nodes that perform essential systems administration works in an  infrastructure less environment is said be a portable specially appointed system (Figure1:  MANET).  Nodes that fall in the correspondence run speak with each other and which don't come in the range  take after the idea of multi hop[1] for correspondence. In the system every node assumes a double  part as a host by the sending and as a switch in directing packets to the destination .    Figure 1.  MANET .    Keeping up security is an essential capacity of any of the routing protocol in each period of the  network function[1]. In light of the non static topological conduct of the system and due to being the  system open which enables the system to develop and contract because of expansion and erasure of  AETiC 2017 , Vol. 1, No. 1  27   the nodes whenever gives chance for the interloper nodes to bother the typical directing procedure.  What's more, if there does not exist a typical guaranteeing authority for validating and ensuring the  nodes then a dependable transmission is unrealistic .  1.1 Security Related Goals a nd Challenges   Security administrations are expected to ensure that the in formation is exchanged over the  system with unwavering quality and furthermore keeping the assets of the framework ensured. To  accomplish the targets, the arrangements of security administrations are: availability, confidentiality,  authenticity, integrity and non repudiation [2, 3].   1.1.1. Availability   Though the framework is experiencing different issues like with data transmission, network  however the accessibility benefit guarantees that still the assets are accessible in an auspicious way.  The unsafe i mpacts of accessibility of a system are asset consumption assaults a nd bundles dropping  proportion.   1.1.2. Confidentiality   The data winning in the system is not to be shared among every single unapproved node and  this is accomplished by Confidentiality. So as to accomplish Confidentiality numerous encryption  methods can be utilized to influence just to the approved nodes can s hare the transmission of data  and the private and public keys.   1.1.3. Authenticity   To demonstrate a node as an honest to goodness client the system benefit utilized is  Authenticity. The nonattendance of this administration can influence any node in the sy stem to  imitate any node, and afterward having an aggregate control catch and control over the total system.   1.1.4. Integrity   The information which is been transmitted in the system can be altered either intentionally  or in  some cases un intentionally . The  Integrity arrange benefit guarantees that the data which is been  transmitted is not changed.   1.1.5. Non Repudiation   This administration ensures that the message transmission hosts been done between the two  gatherings and it can't be denied. Additionally utilizing this administration it helps in recognizing  and confining of traded off nodes in the system.   Imparting thro ugh the system in sheltered and secure way has been a testing errand in light of   • Not being a steady foundation.   • The interfaces in the system are inclined to break and not secure.   • Scarcity or over burden on the framework resources   • The arrange to pology being dynamic.     In this examination the arrangement of the exploration is to consider the different reactive  routing protocols in MANETS and break down the perfect node to forward the packets in the course  to achieve goal. The proposed approach wil l be utilized to upgrade the current reactive routing  protocol by taking out the malicious nodes by utilizing any of the officially characterized system to  dispense with them and locate the perfect node from the accessible nodes to enhance security in whil e  the system capacities are completed. This exploration will principally concentrate on different  reactive routing protocols and the threats and attacks on them. The purposes behind security threats AETiC 2017 , Vol. 1, No. 1  28   are considered for giving an answer to address the diffic ulties of security in the system and do  standard system operations in a secured way.   1. What are the diverse security threats for the reactive routing protocols?   2. What are the explanations behind the threats?   3. Strategies to make the system solid and  secured.   The researcher focuses on the reactive routing protocols. The attacks and threats on these routing  protocols are examined, because of security such malicious node will be deleted from participating  in sending the packet. Presently the explanatio ns behind these sorts of attacks and threats are  examined and the issues in this technique are considered for look into. This examination will be an  enormous commitment in the range of MANETS to enhance security by using the proposed Ideal  Node Enquiry Sea rch (INESH) algorithm in the reactive routing protocols while sending the packets  from source to destination. This could fill in as reference for different scientists to upgrade other class  of routing protocols in view of their conduct to enhance security in MANETS.   1.2 Conceptual Framework / Theoretical Framework   The investigation of working procedure of each of the reactive routing protocol alongside the  attacks and threats on them is examined. There are different directing systems embraced by various  conventions when there are assaults on the conventions. An investigation of purposes behind the  attacks and threats will be directed which makes to introduce the INESH algorithm to upgrade  security in the revelation of courses and upkeep of courses in this ex ploration .    Figure 2 . Conceptual Framework .    2. Literature Review   There are many sorts of routing protocols that have been intended for MANETS [4 8].  Furthermore, the features of the routing protocols are examined from [9].These protocols can be  classifie d as follows .    Figure 3 . Routing Protocols .  AETiC 2017 , Vol. 1, No. 1  29   2.1 Reactive Routing Protocols   2.1.1. Dynamic Source Routing Protocol   The Dynamic Source Routing protocol is a reactive routing protocol which communicates  following two phases namely route discovery and route maintenance [10]. Initially the routes are  discovered for transmitting the packets between source node and the target node. A route cache is  maintained having the information of the recently used routes. Because of the dynamic changes in  the topology, ther e is a chance of routes being broken in the route maintenance phase still it ensures  that the packet is safely transmitted to the target. More over the researcher simulated the protocol  using NS 2 to focus on the performance of this protocol using the metr ics like packet delivery ratio.  It was found that the packet delivery ratio is more when there were malicious nodes than in absence  of malicious nodes .  2.1.2. Ad hoc On Demand Distance Vector Protocol   The AODV protocol explains its functionality [11]. It i s stated that the features of both DSR and  DSDV are combined. The author explains the working of AODV protocol along with the Black hole  attack and its effect on the protocol. Finally to prevent the Black hole attack, a Counter Algorithm is  proposed to mak e the AODV Protocol secure. Performance of the protocol was measured using  metrics like Packet Delivery Ratio and Average End toEnd Delay. A method to identify the malicious  node was explained in order to avoid forwarding of the information to the malicio us node in the  routing table. The solution given did not impose any overhead on the nodes in the network .   1.1.3. Temporally Ordered Routing Algorithm   The Temporally ordered Routing Algorithm is outlined considering the connection inversion  idea and is a c alculation free of circles [12]. This convention works in three stages as takes after: (a)  The principal stage begins with making a route (b) the second stage runs with keeping up the route  and (c) the third stage evacuates all the invalid routes .Comparis on of TORA protocol with other  routing protocols like OLSR, DSDV with the metrics like Throughput, Control Overhead, End to End  Delay and Packet Delivery Ratio and was seen that it is better in performance with varying number  of nodes using NS 2 simulator .   1.1.4. Associativity Based Routing   The Associativity Based Routing protocol does not have loops, free of deadlock and no duplicate  packets [13]. It focuses on route longevity. As there are very few broken communication links and  less need for reconstruct ion of the routes the overhead involved is less. An improved version of ABR  was to optimize the bandwidth and demand to reduce the overhead based on the position  information was proposed. It was concluded that the path setup time was long for the routes wh ich  gave a scope for the future research to improve the ABR Protocol .   1.1.5. Signal Stability based Adaptive Routing Protocol   The working of SSR routing protocol states that the large routing tables are not required for  routing [14]. The network will not be congested with the control messages but a type of denial of  service attack is a threat to this protocol. The Signal Stability Table is maintained that has information  of signal’s strength of all nearby nodes. The protocol was simulated in OmNet  and a me tric known  as CPU usage was considered to measure the performance. It proved that when there are malicious  nodes the usage of CPU was more than in the absence of malicious nodes .  2.2 Reasons for Threats and Attacks   Reasons for threats have been summarized as shown in the following figure . AETiC 2017 , Vol. 1, No. 1  30     Figure 4 . Reasons for Threats and attacks .  3. Methodology   "
218,"Comparison of Random Waypoint & Random Walk Mobility Model under DSR, AODV & DSDV MANET Routing Protocols.txt","Mobile Adhoc Network is a kind of wireless ad hoc network where nodes are
connected wirelessly and the network is self configuring. MANET may work in a
standalone manner or may be a part of another network. In this paper we have
compared Random Walk Mobility Model and Random Waypoint Mobility Model over two
reactive routing protocols Dynamic Source Routing (DSR) and Adhoc On-Demand
Distance Vector Routing (AODV) protocol and one Proactive routing protocol
Distance Sequenced Distance Vector Routing (DSDV) Our analysis showed that DSR,
AODV & DSDV under Random Walk and Random Way Point Mobility models have similar
results for similar inputs however as the pause time increases so does the
difference in performance rises. They show that their motion, direction, angle
of direction, speed is same under both mobility models. We have made their
analysis on packet delivery ratio, throughput and routing overhead. We have
tested them with different criteria like different number of nodes, speed and
different maximum number of connections.","This is the age of Wireless communication systems. These days there is a need of rapid deployment of independent mobile users, for ex ample establishing survivable, dynamic communication for emergency operations, disaster management and military networks, crime management networks etc. These all types of networks are actually based on the mobile adhoc networks. Such networks don’t have a central control but they are decentralized networks. MANET is autonomous collection of mobile nodes that communicate over limited bandwidth and energy constraints. These mobile nodes are in motion so the topology of the entire network changes rapidly and unpredictably over time. All network is managed by the network nodes themselves, as there is no special device or router involved, every nodes itself work as a router to forward the traffic. Routing in these types of networks is a main issue as there is no fix ed infrastructure and paths get changed due to rapid movement of nodes, so routing is a main area where research needs to be done. There is need of some special routing protocols for these types of networks which can automatically recognize the topology changes and which can limit the ex tra overhead of control messages before data transfer as these networks has low bandwidth. MANET Routing protocols are divided into two categories: Proactive and Reactive. Proactive routing protocols are tabledriven protocols and they always maintain current uptodate routing information by sending control messages periodically between the hosts which update their routing tables. The proactive routing protocols use linkstate routing algorithms which frequently flood the link information about its neighbors. [2] Reactive or ondemand routing protocols create routes when they are needed by the source host and these routes are maintained while they are needed. Such protocols use distancevector routing algorithms. [1] Our goal is to carry out a systematic performance study of three routing protocols for ad hoc networks namely Ad hoc On Demand Distance Vector (AODV) Routing protocol, Dynamic Source Routing (DSR) protocol and Distance Sequenced Distance Routing protocol under Random Walk Mobility Model and Random Waypoint Mobility Model.The rest of the paper is organized as follows: Section 2 gives a brief description of the routing protocols used for performance comparison. Section 3 gives description of mobility models used in the paper. Section 4 gives study of previous related work done. In Section 5 we present the setup of the Simulation Environment. Section 6 gives the Results and Analysis of the simulation done, Section 7 is conclusion while at last section 8 provide the references. 2. DE SCRIPTION OF PROTOCOLS 2.1 DSDV Destination Sequenced Distance Vector protocol belongs to the class of proactive routing protocols. This protocol is based on the classical BellmanFord routing algorithm [4] to apply to mobile ad hoc networks. DSDV also has the feature of the distance vector protocol [5] in that each node holds a routing table including the nexthop information for each possible destination. Each entry has a sequence number. If a new entry is obtained, the protocol prefers to select the entry having the largest sequence number. If their sequence number is the same, the protocol selects the metric with the lowest value. Routing information is transmitted by broadcast. Updates have to be transmitted periodically or immediately when any significant topology change is available. Sequence numbers are assigned by destination, means the destination gives a sort of default even sequence number, and the emitter has to send out the next update with this number. Packets are transmitted between the stations of the network by using routing tables which are stored at each station of the network. Each routing table, at each of the stations, lists all available destinations, and the number of hops to each. Each route table entry is tagged with a sequence number which is originated by the destination station. To maintain the consistency of routing tables in a dynamically topology, each station periodically transmits updates, and transmits updates immediately when significant new information is available. Routing information is advertised by broadcasting or multicasting the packets which are transmitted periodically and incrementally as topological changes are detected  for instance, when stations move within the network. Data is also kept about the length of time between arrival of the first and the arrival of best route for each destination. Based on this data, a decision may be made to delay advertising routes which are about to change soon, thus damping fluctuations of the route tables. 2.2 DSR The Dynamic Source Routing (DSR) protocol is an ondemand routing protocol based on source routing. In the source routing technique, a sender determines the ex act sequence of nodes through broadcasted route request Message. When route is found then route reply is made containing the route to destination. The list of intermediate nodes for routing is ex plicitly contained in the packet’s header. In DSR, every mobile node in the network needs to maintain a route cache where it caches source routes that it has learned. When a host wants to send a packet to some other host, it first checks its route cache for a source route to the destination. In the case a route is found, the sender uses this route to propagate the packet. Otherwise the source node initiates the route discovery process. Route discovery and route maintenance are the two major parts of the DSR protocol. 2.3 AODV This protocol perform sRoute Discovery using control messages route request (RREQ) and route reply (RREP) whenever a node wishes to send packets to destination. To control network wide broadcasts of RREQs, the source node uses an expanding ring search technique. The forward path sets up an intermediate node in its route table with a lifetime association RREP. When either destination or intermediate node using moves, a route error (RERR) is sent to the affected source node. When source node receives the (RERR), it can reinitiate route if the route is still needed. Neighborhood information is obtained from broadcast Hello packet. As AODV protocol is a flat routing protocol it does not need any central administrative system to handle the routing process. AODV tends to reduce the control traffic messages overhead at the cost of increased latency in finding new routes. The AODV has great advantage in having less overhead over simple protocols which need to keep the entire route from the source host to the destination host in their messages. The RREQ and RREP messages, which are responsible for the route discovery, do not increase significantly the overhead from these control messages. AODV reacts relatively quickly to the topological changes in the network and updating only the hosts that may be affected by the change, using the RRER message. The Hello messages, which are responsible for the route maintenance, are also limited so that they do not create unnecessary overhead in the network. The AODV protocol is a loopfree and avoids the counting to infinity problem, which were typical to the classical distance vector routing protocols, by the usage of the sequence numbers. [3] 3. MOBILITY MODELS There are two types of mobility models used in the simulation of networks: traces and synthetic models [8,9]. Traces are those mobility patterns that are observed in real life systems. They provide accurate information when they involve a large number of nodes and an appropriately long observation time. However, new network environments like ad hoc networks are not easily modeled if traces have not yet been created. In this type of situation it is necessary to use synthetic models. Synthetic models attempt to realistically represent the behaviors of MNs without the use of traces. Different synthetic entity mobility models for ad hoc networks are [9] 1. Random Walk Mobility Model (including its many derivatives): A simple mobility model based on random directions and speeds. 2. Random Waypoint Mobility Model: A model that includes pause times between changes in destination and speed. 3. Random Direction Mobility Model: A model that forces MNs to travel to the edge of the simulation area before changing direction and speed. 4. A Boundless Simulation Area Mobility Model: A model that converts a 2D rectangular simulation area into a torusshaped simulation area. 5. GaussMarkov Mobility Model: A model that uses one tuning parameter to vary the degree of randomness in the mobility pattern. 6. A Probabilistic Version of the Random Walk Mobility Model: A model that utilizes a set of probabilities to determine the nex t position of an MN. 7. City Section Mobility Model: A simulation area that represents streets within a city. In this paper we are analyzing the first two models. 3.1)The Random Walk Mobility Model It was first described mathematically by Einstein in 1926 [9]. Since many entities in nature move in ex tremely unpredictable ways, the Random Walk Mobility Model was developed to mimic this erratic movement. In this mobility model, an MN moves from its current location to a new location by randomly choosing a direction and speed in which to travel. The new speed and direction are both chosen from predefined ranges, [speedmin ;speedmax ]and[0;2p]respectively. Each movement in the Random Walk Mobility Model occurs in either a constant time interval tor a constant distance traveled d, at the end of which a new direction and speed are calculated. If an MN which moves according to this model reaches a simulation boundary, it “bounces” off the simulation border with an angle determined by the incoming direction. The MN then continues along this new path. Many derivatives of the Random Walk Mobility Model have been developed including the 1D, 2D, 3D, and dD walks. 3.2) Random Waypoint Mobility Model It includes pause times between changes in direction and/or speed. An MN begins by staying in one location for a certain period of time (i.e., a pause time). Once this time ex pires, the MN chooses a random destination in the simulation area and a speed that is uniformly distributed between [minspeed,maxspeed] . The MN then travels toward the newly chosen destination at the selected speed. Upon arrival, the MNpauses for a specified time period before starting the process again. Figure 2 shows an ex ample traveling pattern of an MN using the Random Waypoint Mobility Model starting at a randomly chosen point or position (133, 180); the speed of the MN in the figure is uniformly chosen between 0 and 10 m/s. We note that the movement pattern of an MN using the Random Waypoint Mobility Model is similar to the Random Walk Mobility Model if pause time is zero and [minspeed, maxspeed] =[speedmin, speedmax] . [9] Figure 2: Traveling pattern of an MN using the Random Way point Mobility  Model. 4. RELATED WORK "
170,Contra: A Programmable System for Performance-aware Routing.txt,"We present Contra, a system for performance-aware routing that can adapt to
traffic changes at hardware speeds. While existing work has developed point
solutions for performance-aware routing on a fixed topology (e.g., a Fattree)
with a fixed routing policy (e.g., use least utilized paths), Contra can be
configured to operate seamlessly over any network topology and a wide variety
of sophisticated routing policies. Users of Contra write network-wide policies
that rank network paths given their current performance. A compiler then
analyzes such policies in conjunction with the network topology and decomposes
them into switch-local P4 programs, which collectively implement a new,
specialized distance-vector protocol. This protocol generates compact probes
that traverse the network, gathering path metrics to optimize for the user
policy dynamically. Switches respond to changing network conditions at hardware
speeds by routing flowlets along the best policy-compliant paths. Our
experiments show that Contra scales to large networks, and that in terms of
flow completion times, it is competitive with hand-crafted systems that have
been customized for specific topologies and policies.","Conﬁguring a network to achieve a diverse range of ob jectives, such as routing constraints ( e.g., trafﬁc should go through a series of middleboxes), and trafﬁc engineering (e.g., minimize latency and maximize throughput), is a chal lenging task. To handle this complexity, one approach has been to use SDN solutions, which have a centralized point for management [21, 22]. However, centralized controllers are inherently too slow to respond to ﬁnegrained trafﬁc changes, such as short trafﬁc bursts. In fact, even the soft ware control planes locally on the switches are often limited in their ability to make forwarding decisions fast enough. Recent work has developed load balancing mechanisms that operate entirely in the data plane to enable realtime adaptation [10, 25]. By making use of ﬁnegrained perfor mance information on hardware timescales, these systems can deliver considerable performance beneﬁts over static load balancing mechanisms like ECMP. Unfortunately, exist ing systems, such as Conga [10] and Hula [25], are point so lutions that only work under very speciﬁc assumptions about the network topology, routing constraints, and performance objectives—they only support a “least utilized shortest path” policy on a data center topology. Further, it is not obvioushow to extend them to work in other kinds of networks ( e.g., a WAN) or with more sophisticated policies. In this paper, we describe Contra, a general and pro grammable system for performanceaware routing. Network operators conﬁgure Contra by describing the network topol ogy as well as a highlevel policy that deﬁnes routing con straints and performance objectives. Contra then generates P4 programs for switches in the network, which execute in a fully distributed fashion. Collectively, they implement a specialized version of a distancevector protocol that for wards trafﬁc based on routing constraints and optimizes for the userdeﬁned performance objectives. This protocol op erates by generating periodic probes that traverse policy compliant paths and collect userdeﬁned performance met rics. Switches analyze the incoming probes and rank paths in real time, storing the current best next hop to reach any given destination. Since the programs run in the data plane, switches can react to performance changes quickly. Overall, Contra is designed to achieve the following objectives: General – operates over a wide range of policies Reusable – works correctly for any topology Distributed – does not require central coordination Responsive – adapts to changing metrics quickly Implementable – on today’s programmable data planes Policycompliant – packets only use allowed paths Loopfree – mitigates persistent/transient loops Optimal – converges to best paths under stable metrics Stable – mitigates oscillation under changing metrics Efﬁcient – avoids undue trafﬁc and switch overhead Ordered – limits outoforder packet delivery To achieve all of these objectives, we need to address sev eral challenges. First, to operate over arbitrary topologies, Contra requires new techniques to search the set of possi ble paths for optimal routes. Stateoftheart solutions, such as Conga [10] and Hula [25], assume a treebased data cen ter topology, which makes exploring possible paths, avoid ing forwarding loops, and ﬁnding optimal routes straight forward. Second, link and path metrics can change con stantly, leading to additional challenges for distancevector protocols. In such situations, switches may have unsyn chronized views of the network in transient states, and they may make forwarding decisions based on these inconsistent views, which can result in forwarding loops and/or forward ing paths that violate the routing policy. Third, a na ¨ıve 1arXiv:1902.00849v1  [cs.NI]  3 Feb 2019Objective Key idea(s) Section(s) GeneralLanguage for performanceaware routing2Policies as pathranking functions Reusable Policy analyzed jointly with topology 4.1 Distributed Synthesis of dataplane routing protocol 4.14.2 Responsive & Periodic probes to collect path metrics Implementable Implemented in P4 PolicycompliantProbes and packets carry policy states4.1, 4.2, 4.3Switches keep track of state transitions LoopfreeMonotonicity analysis 2, 5.1, 5.3 Probes carry version numbers Early loop breaking for ﬂowlets Optimal Isotonicity analysis 2, 5.2 Stable & Limit the frequency of probes Efﬁcient Failure detection and metric expiration Ordered Policyaware ﬂowlet switching 5.3 Figure 1: Key ideas in Contra. solution that constantly changes routes can cause transient or even persistent chaos. We draw inspirations from wire less network routing [5, 2, 32], and design mechanisms that leverage programmable data planes to address this. Finally, to mitigate outoforder packet delivery, we develop policy aware ﬂowlet switching [36] to forward ﬂowlets while ensur ing policy compliance. Summary. We make several contributions in the design of Contra, and Figure 1 summarizes the key ideas. We deﬁne a new programming abstraction that views policies as pathranking functions, and generalizes ex isting languages by allowing operators to specify path constraints and dynamic metrics simultaneously. We design a new conﬁgurable, performanceaware, distancevector routing protocol. We develop compilation algorithms that generate per device P4 programs that implement a particular conﬁg uration of the protocol based on user policy. We have built a system prototype, and conducted thor ough experiments to demonstrate that Contra is compet itive with stateoftheart systems that are customized for a speciﬁc topology and routing policy. Nongoals. There has been abundant recent research on ef ﬁcient loadbalancing strategies, especially in data centers. The goal of this work is not to outperform such strategies in the contexts for which they have been manually optimized. Rather, our goal is to facilitate the deployment of such tech niques on a much broader set of networks and with a broader collection of optimization criteria, and to do so without ask ing network operators to take the time, or acquire the exper tise necessary, to write “assemblylevel” P4 programs. 2 Policy language Contra has a highlevel language that can express a wide range of sophisticated policies, which are functions that rank network paths. The goal of the Contra compiler is to ensure that switches always use the best policycompliant paths. The language has two main components: a) matching onpaths using regular expressions, and b) computing path met rics. As a concrete example, consider the following policy: minimize (if A .then path .util else path .lat) It ﬁrst classiﬁes paths using a regular expression ( A:), and then based on the classiﬁcation, it deﬁnes the rank to be ei ther path utilization or latency. Each node will separately choose its best paths according to this function. So node A will always choose the least utilized path, while all other nodes will select the path with the lowest latency. The Contra language can also capture static policies in ex isting systems that are not related to performance. For in stance, FatTire [33] uses regular expressions to classify legal and illegal paths (though it says nothing about the perfor mance of such paths). To route packets through a waypoint W, a FatTire policy would be (.* W .*) , which allows any path through Wbut no other paths. Contra can represent this by mapping all legal paths to 0 and illegal paths to ¥: minimize (if.W.then 0else ¥) This policy will ensure that every node always selects a path through Wif one exists in the network, and drops trafﬁc oth erwise; no path is preferred to a path with rank ¥. As another example, Propane [13] allows users to write policies about failover preferences. A Propane policy (A B D) >> (A C D) indicates a preference for sending traf ﬁc through path A B D and only using A C D if the ﬁrst path is not available ( e.g., a link has failed). In Contra, we can achieve the same effect by ranking paths statically as below. minimize (if A B D then 0else if A C D then 1else ¥) In Contra, it is also possible to rank paths based on multi ple metrics. For example, suppose we prefer that A reaches D via B instead of via C, and we also prefer shorter, less utilized paths. This can be achieved by lexicographically ranking paths, e.g., prefer paths through B ﬁrst, then shortest paths, and ﬁnally, least utilized paths. minimize (if A .B.D then (0,path .len,path .util ) else if A .C.D then (1,path .len,path .util ) else ¥) Ranking paths using regular expressions deﬁnes strict, in violate preferences; however, operators may have softer con straints as well: e.g., one path may be preferred up to a point, but if the utilization is too high then some trafﬁc should be shunted along another path instead. To implement soft con straints, policies may make different choices based on cur rent path performance. For example, to prefer leastutilized paths when the network load is light (utilization of the path is less than 80%), even if those paths are long, but to prefer shortest paths when network load is heavy (and hence to save bandwidth globally), one might use the following policy. minimize (if path .util<.8 then (1, 0, path .util ) else (2,path .len,path .util ) ) 2Policy pol ::= minimize (e) optimization Expressions e::=n constant numeric rank j¥ inﬁnite rank jpath:attr path attribute je1e2 binary operation jifbthen e1elsee2 if statement j(e1;:::; en) tuple Boolean Tests b::=rje1e2jnotbjb1orb2jb1andb2 Regular Paths r::= node idj:jr1+r2jr1r2jr Figure 2: Syntax for Contra policies. Policy Implementation P1. Shortest path routing [4] path.len P2. Minimum utilization [25] path.util P3. Widest shortest paths [26] (path.util, path.len) P4. Shortest widest paths [38] (path.len, path.util) P5. Waypointing [12] if .*(F 1+F2).* then path.util else ¥ P6. Link preference [13] if .*XY .* then path.util else ¥ P7. Weighted link [16] (if .*XY .* then 10 else 0) + path.len P8. Sourcelocal preference [11] if X.* then path.util else path.lat P9. Congestionaware routing [23] if path.util <.8 then (1, 0, path.util) else (2, path.len, path.util) Figure 3: Selected Contra policies. Finally, to steer trafﬁc towards or away from particular links, one may add or subtract weights. For instance, the fol lowing policy demonstrates how to add weight to costly links AB and CD while otherwise using simple shortest paths. minimize ( (if.AB.then 10else 0) + (if.CD.then 20else 0) +path .len) Figure 2 presents the full language syntax, and Figure 3 presents selected policy examples taken from the literature. The key novelty of the language is that it can capture many of thestatic conditions expressed by earlier work such as Fat Tire [33] or NetKAT [12] as well as the relative preferences of Propane [13], and yet also augment such policies with dy namic preferences based on current network conditions. Advanced policy analysis. Contra requires policies to be isotonic (switches have consistent preferences) and mono tonic (metrics do not improve for longer paths), so that switches can converge to best paths. If a policy is non isotonic ( e.g., P9 in Figure 3), then the Contra compiler will decompose it into multiple isotonic subpolicies that can be processed separately. Due to space limitation, we refer inter ested readers to the appendix (A) for more detail. Limitations. Currently, Contra does not support trafﬁc clas siﬁcation, but extending the language with header predicates as in prior work [17, 12] should not present any signiﬁcant intellectual challenge. A more notable limitation involves policies that prioritize one trafﬁc class over another. For instance, B4 [22] prioritizes small, latencysensitive user re quests over large, latencyinsensitive bulk transfers. Cur rently, Contra ranks paths and selects the best path for each ﬂowlet, but does not compare different types of trafﬁc in or der to prefer one over the other. We leave integration of such policies into our framework to future work. 3 Selected Challenges The design of Contra needs to address three key challenges. To illustrate these challenges, we ﬁrst describe a strawman solution that only works on a speciﬁc topology (data center networks) and policy (use least utilized paths). A simple policy on a simple topology. Consider the simple leafspine topology shown in Figure 4(a), where switch S wants to send trafﬁc to switch D using the leastutilized path: minimize (if S.D then path .util else ¥) One strawman solution is to use a distancevector protocol, where each switch propagates link metrics ( i.e., utilization) to its neighbors via periodic probes, and builds up a local forwarding table of “best next hops” to reach other switches. More concretely, at time 1, D sends two probes to A and B carrying utilizations u(AD)=0.1 and u(BD)=0.2, respec tively. Upon receiving a probe, a spine switch updates its metric, and then disseminates the probe to its downstream neighbors. The updated probe metric is the maximum of a) the original probe metric, and b) the utilization of the in bound link from the switch’s neighbor, so the probe always carries the utilization of the bottleneck link on its traversed path. For instance, when B receives the probe from D, it up dates the utilization to 0.3, which is the maximum of a) the original probe metric, u(BD)=0.2, and b) the utilization u(S B)=0.3; when A receives the probe from D, it updates the utilization in the probe to be 0.4, which is the maximum of u(AD)=0.1 and u(SA)=0.4. At time 2, both A and B then disseminate the updated probes to S. Now, S has received probes on both paths SAD (u=0.4) and SBD (u=0.3), and it chooses B as the best next hop to reach D due to its lower utilization. Changes in link metrics are then captured and propagated by the next round of probes. In fact, this solution describes Hula [25], a stateoftheart solution for utilizationaware routing in data centers. Challenge #1: Arbitrary topologies. On a tree topology, simple mechanisms ( e.g., deﬁning a set of “downstream” and “upstream” neighbors for each switch) sufﬁce to ex plore paths and prevent forwarding loops [25], but on a non hierarchical topology, it is insufﬁcient. Consider the sequence of events in Figures 4(b)(e), where S prefers the leastutilized path to D. Suppose that at time 1, D sends out probes to A and S, and A propagates D’s probe to B and S, with the utilizations shown in Figure 4(b); now, both B and S prefer to reach D via A. At time 2, S propa gates A’s probe to B about SAD (u=0.1), so B changes its preference to go through S; B then propagates S’s probe to A 3SDAB0.20.10.30.4S0.1ABD0.70.20.1S0.1ABD0.70.20.1S0.1ABD0.70.20.10.1>0.5 S0.1ABD0.70.20.10.5(a)	Strawman	solution(b)	Arbitrary	topologies	(t=1)(c)	Arbitrary	topologies	(t=2)(d)	Arbitrary	topologies	(t=3) (e)	Arbitrary	topologies	(t=4)S0.1ABD0.10.10.90.20.1S0.1>0.7ABD0.10.10.9>0.10.20.1S0.7ABD0.10.10.1>0.30.20.1(f)	Constrained	routing	(t=1)(g)	Constrained	routing	(t=2)(h)	Constrained	routing	(t=3)0.10.1Figure 4: Supporting sophisticated policies over arbitrary topologies is challenging. (Solid, red arrows represent probes, and dotted, green arrows represent packet forwarding. Links are labeled with performance metrics.) (u=0.2), but it gets delivered only at time 4. At time 3, u(A D) increases to 0.5, which is discovered by a new periodic probe from D to A and S. From A’s perspective, the best path to reach D is still AD, except that now the utilization is 0.5 instead. At time 4, when B’s (old) probe to A arrives with u=0.2, A mistakenly thinks that it should instead reach D via B, not knowing that A is itself on B’s best path to reach D. As a result, a forwarding loop SABS would form, and it willpersist as long as the link utilizations remain stable. In fact, it is wellknown that distancevector protocols can result in forwarding loops on an arbitrary topology. One might consider using a pathvector protocol instead, where probes record the paths they have traversed, so that switches never use paths with loops. However, since probes will be sent out frequently, carrying path information would result in much higher trafﬁc overhead, especially in large networks. Solution. Our solution is inspired by DSDV [32] and a more recent proposal Babel [5], which were originally developed for wireless mesh networks. At a high level, switches as sign version numbers to probes, so that they can identify and avoid using outdated probes. However, even with ver sion numbers, nonmonotonic policies can still create loops within a given probe period. So the Contra compiler ad ditionally performs monotonicity checks on user policies. Finally, when Contra is integrated with ﬂowlet switching, which pins trafﬁc to particular paths to avoid outoforder packet delivery, loops might still form when ﬂowlet entries expire at different times. To address this, Contra lazily de tects and breaks loops by ﬂushing ﬂowlet switching entries. Challenge #2: Constrained routing. Supporting rich rout ing policies that admit waypointing, servicechaining, or other path constraints complicates the protocol implemen tation dramatically. Consider the scenario in Figure 4(f), where the policy is not only to prefer leastutilized paths, but also that trafﬁc should never ﬁrst go through B and then A due to security concerns: minimize (if.BA.then ¥else path .util )Under this policy, S can only send trafﬁc to D via a) SD, b) SAD, or c) SBD; initially, S prefers c) (u=0.1). Now consider the sequence of events shown in Figures 4(f)(h). Suppose that at time 1, the trafﬁc from S arrives at B. At time 2, the u(BD) increases to 0.7, and u(SD) decreases to 0.1, so B updates its best next hop (to reach D) to be S, preferring the path BSD. At time 3, B sends the trafﬁc back to S, which already forms a loop. But things can get even worse: at time 3, u(SD) increases to 0.3, so S changes its preference to be SAD (u=0.2). So the trafﬁc has been forwarded along a path SBSAD, which not only contains a loop but also violates the intended policy. Solution. To address this problem, Contra tags both probes and packets with policy states, which track the paths be ing traversed and whether these paths have satisﬁed the in tended policy. When a switch processes a packet, it relies on the embedded tag to determine a local forwarding ac tion that is compliant with the global, networkwide policy. When a switch changes its path preference locally, it ap plies a new tag on packets so that downstream switches know about the change and process the packets based on the latest preference—somewhat akin to a distributed version of con sistent updates [34]. By tagging packets at the source, differ ent switches can then freely make independent forwarding decisions that optimize for the policy. Challenge #3: Custom performance metrics. Sophisti cated policies may also require a more advanced probe prop agation mechanism. In the mechanism we have discussed so far, a switch only propagates the probe with the best metric to its neighbors; this is due to an implicit assumption that probes arriving at a switch with worse metrics can be safely discarded, because the metrics will only degrade or remain the same as probes are propagated further along a path. How ever, it is only safe to discard probes when a user’s policy isisotonic [20], meaning that downstream nodes respect the preference of the upstream node. Unfortunately, some useful policies are not isotonic [23]. Solution. To address this problem, Contra ﬁrst performs a 4Figure 5: Na ¨ıve solutions may lead to suboptimal paths. Node Auses ABCD even though a better path ABDexists. static program analysis to check if a policy is isotonic. If not, it attempts to decompose a nonisotonic policy into multiple isotonic subpolicies. These different isotonic subpolicies can then be propagated separately in different probes and only recombined and evaluated later at the switch to make the ﬁ nal forwarding decision. To avoid sending a large number of probes, Contra uses a data structure called a product graph to minimize the number of probes while ensuring correctness. 4 Compilation: Stable metrics The goal of the compiler is to generate a particular conﬁgu ration of the Contra protocol that efﬁciently implements the desired policy in the data plane. We describe compilation in two phases. First, in this section, we describe an algorithm that operates as if link metrics do not change , so probes only need to be propagated once. The next section explains how this algorithm is extended to handle changing metrics. Challenge. One key challenge during compilation involves policies with conditional regular expression matches, such as (if r then m1 else m2) , because nodes may rank paths differently based on the branch of the conditional they use. In fact, regular expressions are one source of nonisotonicity: if every node selects the best next hop according to its own preferences alone, other nodes might wind up with subopti mal routes. For example, consider the following policy when applied to the topology in Figure 5: minimize (if(A B D )then 0else path .util ) In this example, Aprefers path ABD over anything else, but Bprefers the least utilized path, which is currently BCD. The correct behavior in this scenario would be for Bto carry A’s trafﬁc along path ABDwhile simultaneously sending its own trafﬁc along path BCD. However, a na ¨ıve (and erroneous) implementation may disseminate probes along the paths DBandDCB1and ask B to decide which path is best. In this case, Bwould use the probe from DCB and discard the one from DB. However, if the latter probe is discarded, Awill not receive information about its preferred route! To avoid this, another na ¨ıve solu tion would be to propagate probes along all possible paths in the network to avoid missing good paths. For instance, B 1Recall that probes travel in the opposite direction to actual trafﬁc.might send every probe it receives to A. However, this would lead to far too many probes, as the number of paths in a graph may be exponential in the number of nodes. Solution. Instead, for a conditional (if r then m1 else m2), if one could determine the path with minimal metric m1that matches rusing one probe, and separately deter mine the path with minimal metric m2that does not match rusing another probe, then nodes could delay choosing their best path until both probes have been received and only then combine the information to make a decision. This is one concrete instance where Contra needs to decompose the non isotonic policy (due to regular expressions) into multiple iso tonic subpolicies. Contra achieves this by creating a compact data structure that combines all regular expressions appear ing in a policy with the network topology, and by sending separate probes for different regular expression matches. 4.1 Finding policycompliant paths Inspired by Merlin [37] and Propane [13], Contra constructs a data structure called a product graph (PG), which com pactly represents all paths allowed by the policy. Policy automata. A policy’s regular expressions deﬁne the different ways the shape of a path can affect its ranking. To process a policy, we ﬁrst convert all such regular expressions into ﬁnite automata. Because probes disseminate informa tion starting from the destination, but policies describe the direction of trafﬁc that ﬂows in the opposite direction, we actually construct an automaton for the reverse of each reg ular expression. Each automaton is a tuple (S;Qi;Fi;q0i;si). Sis the alphabet, where each character represents a switch ID in the network. Qiis the set of states in automaton i. The initial state is q0i.Fiis the set of accepting / ﬁnal states. si:QiS!Qiis the transition function. Consider the example policy shown in Figure 6(b), which a) allows A to send trafﬁc to D via the path ABD, b) allows B to send trafﬁc to D via any path with the least utilization, and c) disallows all other paths. The Contra compiler would generate the automata shown in Figure 6(c). Network topology. The construction of the automata has not considered the actual network topology, so not all au tomaton transitions are legitimate. For instance, although the automaton for D.*B could in principle accept a sequence of transitions DAB , this sequence would never happen on the network shown in Figure 6(a), simply because Dis not di rectly connected to A. Therefore, our compiler merges the topology with the automata and prunes invalid transitions. Product graph (PG). If there are kautomata (one for each regular expression used in the policy), then each state in the PG would have k+1 ﬁelds, (X;s1;;sk), where the ﬁrst ﬁeld Xis a topology location, and siis a state in the ith automaton; there is a directed edge from (X;s1;;sk)to (X0;s0 1;;s0 k), if a) X"
370,Advanced Models for the OSPF Routing Protocol.txt,"We present two formal models for the OSPF routing protocol, designed for the
model checker Uppaal. The first one is an optimised model of an existing model
that allows to check larger network topologies. The second one is a specialised
model for adjacency building, a complex subprocedure of OSPF, which is not part
of any existing model and which is known to be vulnerable to cyber attacks. We
illustrate how both models can be used to discover vulnerabilities in routing
protocols.","The Open Shortest Path First (OSPF) protocol [22] is a widely used, proactive, linkstate routing protocol that distributes routing information throughout a single autonomous system. Similarly to many other routing protocols, it aims to establish shortest paths between network routers while keeping network overhead — messages carrying routing information rather than user data — to a minimum. Although OSPF, as many other routing protocols, is based on ‘simple’ algorithms such as Dijkstra’s shortest path algorithm [9], it seems incredibly hard to ensure that the protocol is functionally correct, see e.g. [21, 14]. To allow formal analysis of OSPF, three detailed formal models have been presented in [10]:1two are formalised in the timed process algebra TAWN [5], which is not only tailored to routing protocols, but also speciﬁes protocols in pseudocode that is easily readable. The difference between the two models lies in the level of detail. The more abstract model is the basis for the third, which presents OSPF as a network of timed automata that can be executed in the model checker U PPAAL [18, 2]. The processalgebraic models do not allow automatic analysis of the protocol, for there is currently no tool support available for TAWN. U PPAAL , however, provides several tools, from simulation to model checking. Unfortunately, the current model faces a combinatorial blow up of the state space that must be addressed before automatic analysis of the protocol becomes feasible. In fact, the current model is already infeasible when analysing networks consisting of three nodes only. Based on the existing U PPAAL model, we advance the modelling efforts for OSPF: 1. We develop a U PPAAL model that is behaviourally equivalent to the model presented in [10] but with a much smaller state space. 2. We develop a new model for adjacency building, a subprocedure of OSPF, which so far has been ignored in formal models. 3. We develop ﬂexible models of adversaries that cover many different attack scenarios. Although the modelling is straightforward, it is extremely powerful and can be used to discover vulnerabilities. 4. We illustrate how this adversarial model can be used in combination with both new models to dis cover vulnerabilities in OSPF. 1Some other models of OSPF exist [24, 19]; see Section 8 and [10] for a discussion.14 Advanced Models for OSPF 2 The Open Shortest Path First (OSPF) Protocol TheOpen Shortest Path First (OSPF) protocol [22] is a linkstate protocol that falls into the group of interior gateway protocols, operating within a single autonomous system. As with any linkstate protocol, OSPF routers (nodes in a network) exchange topological information about onehop links with their neighbours, i.e. the nodes within transmission range. That information is distributed through the network so that (eventually) every router has a complete picture of all available links. This knowledge is used to calculate the shortest/best route between any two nodes, using a variant of Dijkstra’s algorithm [9]. To discover immediate (onehop) neighbours, OSPF uses HELLO messages , which are broadcast pe riodically by all nodes. H ELLO messages consist of the sender’s unique identiﬁcation (ID) and a list of all known onehop neighbours of the sender, i.e. nodes from which the sender has received H ELLO messages. Upon receipt of a H ELLO message, a node updates its own data structures accordingly. The receiver consequently drops that H ELLO message, i.e. H ELLO messages are not forwarded. A node distributes information about its known connections using Link State Advertisements (LSAs). A node stores data concerning connections between other nodes in their LinkState Database (LSDB) . This database represents the router’s current view of the network topology. It contains the most recently received L SAs from each unique originator. Next to the LSDB, every node maintains a list of discovered neighbours, with whom routing information may be exchanged. HELLO messages (or the lack thereof) are also used to determine whether nodes have become inactive or lost connectivity. When a node receives the ﬁrst H ELLO message from a neighbour, it learns of its existence. If the node ﬁnds its own ID listed within that H ELLO message — meaning that the neighbour is aware of the node — it checks whether it needs to form an adjacency with that neighbour. The term adjacency describes the relationship between two neighbouring nodes that exchange all of their topological information — the content of their LSDBs. After information has been shared between two adjacent nodes, they have an identical understanding of the entire network. Nodes not forming an adjacency do not share this information and hence network overhead is reduced. When two nodes recognise that they need to form an adjacency, the node with the larger node ID becomes the master , and the other becomes the slave . It is the master that initiates the exchange of data by sending the necessary information using Database Description (D BD) messages . After that, the two nodes exchange a sequence of D BDmessages. We describe further details about adjacencies in Section 5. Once a node has received a full description of the other node’s LSDB, it compares that description with its own LSDB. To resolve inconsistencies between the two, it sends Link State Request (L SR) mes sages , asking for L SAs containing the newest available information. L SRmessages are answered by Link State Update (L SU) messages ; they contain the requested L SAs. Each receipt of an L SUmessage is acknowledged by a Link State Acknowledgement (L SACK) message . Designated routers are used in combination with adjacencies to further reduce network trafﬁc. As they are not crucial to the understanding of the main functionality of OSPF, we omit the details. 3 Modelling OSPF in UPPAAL One of our aims is to analyse OSPF automatically, both with regards to functional correctness and to discovery of vulnerabilities. A standard tools for analysing and verifying systems automatically is model checking. As there are existing models for U PPAAL , we have chosen to stick with that model checker. UPPAAL [2, 18] is an established model checker, which is frequently used for protocol veriﬁcation, e.g. [3, 26, 25, 13, 12]. U PPAAL analyses networks of timed automata , with clocks supporting theC. Darville, P. H ¨ofner, I. Ivankovic & A. Pam 15 !connect(si p,dip)connect(sip,dip)uc! connect(si p,dip)uc? connect(si p,dip)bc! D=dests connect(sip,dip)  && iselem(di p,D)bc? Figure 1: Model Network Message Passing: unicast and multicast modelling and the analysis of temporal aspects. It provides two synchronisation mechanisms: binary and broadcast channels . In the setting of routing protocols these usually translate to unicast and broadcast communication; the latter presenting the transmission of messages to allneighbours of a node. Hence, when using U PPAAL ’s broadcast mechanism one must consider the network topology to determine the exact set of nodes that are able to receive messages (see below). U PPAAL also provides common data structures, such as arrays, and a Clike programming language to deﬁne updates on these data structures. Networks of Timed Automata The state of the system is determined, in part, by the values of data variables that can be either local or shared between automata. We assume a data structure with several types, variables ranging over these types, operators and predicates. Common Boolean and arithmetic expressions are used to denote data values and statements about them. The automata are extended with clock variables. U PPAAL uses a densetime model where a clock variable evaluates to a real number. All the clocks progress synchronously. Each automaton is a graph, with locations, and edges between locations. Every edge has a guard, optionally a synchronisation label, and an update, which allows local and global data structures to be updated. Synchronisation occurs via socalled channels; for each channel athere is one label a! to denote the sender, and a? to denote the receiver. Transitions without labels are internal; all other transitions use one of the two types of synchronisation. Synchronisation Inbinary handshake synchronisation, an automaton having an edge with a label that has the sufﬁx ! synchronises with another automaton with an edge having the same label with a ?sufﬁx. These two transitions may synchronise if and only if both guards are true in the current state of the system. When the transition is taken, both locations change, and the updates will be applied to the state variables; ﬁrst the updates on the !edge, then the updates on the ?edge. If there is more than one possible pair, then the transition is selected nondeterministically. Inbroadcast synchronisation, one automaton with a !labelled edge synchronises with the set of other automata that all have a matching edge with a ?label. The initiating automaton can change its location, and apply its update, if the guard on its edge evaluates to true. It does not require a second synchronising automaton. Automata with a matching ?labelled edge have to synchronise if their guard is currently true. They change their location and update the system state. The automaton with the !edge will update the state ﬁrst, followed by the other automata in some lexicographic order. If more than one automaton can initiate a transition on an !edge, the choice will be made nondeterministically. Network Communication To model the network mechanisms of unicast, broadcast and multicast — sending to a dedicated set of neighbours — we combine U PPAAL ’s synchronisation with guards. Mes sage contents are exchanged via global data using U PPAAL ’s update mechanism. For communication within routing protocols, unicast is a nodetonode communication with an in built acknowledgmentofreceipt mechanism, which is implemented at a lower layer in the network stack.2More formally, unicast in networking means that a node sipcan only send to another node 2Usually implemented by the link layer of relevant standards such as IEEE 802.11 [16].16 Advanced Models for OSPF dipif (a) both nodes are within transmission range of each other, (b) dipis ready to receive and (c) after attempting to send a message, the node sipis aware of whether transmission was successful. The corre sponding model in U PPAAL is depicted on the top of Figure 1. It uses a unicast channel uc. The network topology is modelled by a Boolean predicate connect . The sender has two successors, one for successful transmission — as we do not model lossy channels, this can be modelled as connect(sip,dip) — and one for failed transmission ( !connect ), which models the actions of a failed sending attempt. The receiving edge is straight forward. Broadcast in networking means sending a message to all other network nodes within transmission range. Similarly to unicast, this is modelled by U PPAAL ’s broadcast mechanism — the broadcast channel is named bc— in combination with the predicate connect . However, the model has to ensure that all nodes within transmission range are in a state where messages can be received. A restricted version of broadcast is multicast: a node siptries to transmit a message to destinations dests , and proceeds regardless of whether any of the transmissions is successful. The corresponding modelling in U PPAAL is shown on the bottom of Figure 1. Here, Dis a global data structure, maintaining the set of intended destinations. Before the actual message transfer occurs, the sender siphas to update D. By doing so, nodes within transmission range of sip can determine whether they are intended recipients, using the Boolean function iselem . 4 Optimising a Model of OSPF Drury et al. [10] have created a U PPAAL model that closely follows the OSPF speciﬁcation [22]; they also take into account the amendments described in [7]. In that model, each network router is modelled by two automata: one describing the core behaviour of OSPF and the other a queue for outgoing messages. The main automaton (Figure 2) is built around a ‘central’ location OSPF pro. This location models an idle state of the protocol — the protocol can stay there indeﬁnitely. As soon as a message is received, the automaton identiﬁes the type of message and acts accordingly. For example, the two transitions in the upper right of Figure 2 model the receipt of an incoming H ELLO message: the automaton checks whether the content of the message shows the node’s ID (see Section 2) and takes the corresponding transition. The automaton uses a clock to send out H ELLO messages periodically (upper left of Figure 2). The receipt of messages does not take time; only the transmission of messages does. When the protocol needs to send a message, this automaton creates the message and passes it, via unicastsynchronisation, to another automaton that models a queue for outbound messages. The queue manages the delivery of the message to corresponding recipients. Each node maintains a data structure for LSDBs, two independent arrays of messages to be sent (as part of the queue automaton) and to be received (part of the main automaton), as well as two clocks, one for each automaton. Each router makes use of four different channels, one for internal communication, one for broadcast, one for unicast, and one for multicast. As often occurs, this model faces a combinatorial blow up of the state space that must be addressed to analyse the protocol automatically. The statespace explosion is caused by multiple factors: 1. Each additional router adds two automata to the network of timed automata. 2. Each additional router adds two clocks to the model, which exponentially increases the complexity. 3. The underlying data structures, messages and message queues signiﬁcantly add to the state space. As a result, checking even simple properties, such as deadlock, fails already on topologies of size three.4 3The diagrams are intended to show the models’ complexity, not to be ‘read’. All models are available at http://marsworkshop.org . 4Deadlock checking failed on a machine with an AMD Ryzen 7 CPU and 64GB RAM.C. Darville, P. H ¨ofner, I. Ivankovic & A. Pam 17 local_time <= start_interval DBD_pro OSPF_prolocal_time <= hellointvl sip:IP isconnected(ip,sip) bcast[sip]? addmsg_inqueue(msgglobal)sip:IP isconnected(ip,sip)  && destsglobal[ip] gcast[sip]? addmsg_inqueue(msgglobal)local_time = 0, initialise() msg_inqueue[0].msgtype==UPD reduce_lsas_msglocal() nextmsg_outqueue()!= NONE && send_idle[ip] imsg[ip]! msgglobal=msg_outqueue[0], destsglobal=dests_outqueue[0], deletemsg_outqueue()!nbrsExist() nbrs[msg_inqueue[0].sip].inactivity_timer=rtdeadcount, generate_send_dbd(msg_inqueue[0].sip), install_lsa(newLSA()), generate_send_upd_single(lsdb[ip]) nbrsExist() generate_send_req(msg_inqueue[0].sip), deletemsg_inqueue()!lsas_is_empty() install_lsas(msg_inqueue[0].lsas), generate_send_upd(msg_inqueue[0].lsas), deletemsg_inqueue() lsas_is_empty() deletemsg_inqueue() msg_inqueue[0].msgtype==REQ  && !nbrsExist() tau[ip]!deletemsg_inqueue()msg_inqueue[0].msgtype==HELLO  && !nbrsExist() tau[ip]!nbrs[msg_inqueue[0].sip].inactivity_timer=rtdeadcount, generate_send_dbd(msg_inqueue[0].sip), install_lsa(newLSA()), generate_send_upd_single(lsdb[ip]), deletemsg_inqueue()msg_inqueue[0].msgtype==HELLO  && nbrsExist() tau[ip]!nbrs[msg_inqueue[0].sip].inactivity_timer=     rtdeadcount, deletemsg_inqueue() upd_required==true tau[ip]!install_lsa(newLSA()), generate_send_upd_single(lsdb[ip]), upd_required=falselocal_time >= hellointvl  && msg_inqueue[0].msgtype==NONE reduce_lifetime_nbrs(), generate_send_hello(), local_time=0 msg_inqueue[0].msgtype==REQ  && nbrsExist() tau[ip]!generate_send_upd_requested(msg_inqueue[0].sip), deletemsg_inqueue()msg_inqueue[0].msgtype==DBD tau[ip]!sip:IP isconnected(ip,sip) ucast[sip][ip]? addmsg_inqueue(msgglobal) Figure 2: An OSPF router as a timed automaton3 To overcome (some of) the problems regarding the state space, we create a single automaton describ ing the entire network. It is depicted in Figure 3. This single automaton models the nondeterministic interaction between routers, rather than actual routers. Data structures of the individual nodes are organised into multidimensional arrays. This allows a single automaton to gain all knowledge of the network and it is no longer necessary to model the concrete content of OSPF messages. We instead model message transmission as a function that extracts information from the sender’s ‘local’ data structures, such as a the LSDB, and updates the ‘local’ data structure of the receiver(s) directly. As the entire model is assembled into a single automaton. We summarise some advantages of our newly developed model, compared to the original model: 1. The content of messages are not modelled; hence a signiﬁcant reduction in the complexity of the required data structures. 2. Only one clock is required rather than 2 N, where Nis the number of routers in a network; the model requires an additional small data structure to manage the periodic sending of H ELLO messages. 3. Message queues and message propagation delays are removed; the model provides similar behaviour through a choice of nondeterministic transitions. A simple automaton is added alongside the main automaton to monitor the model’s clock and notify the main automaton when H ELLO messages need to be sent for each router. Although we did not prove the relationship to the original model of OSPF, the model is carefully designed that it is behaviourally equivalent to the original one.18 Advanced Models for OSPF Initialiser OSPF lsr_on_wire_oracle() && !lsu_on_wire_oracle() propagate_lsr()dbd_on_wire_oracle() && !ongoing_exchange()propagate_dbd(), find_next_lsu_sender()lsu_on_wire_oracle() propagate_lsu(), find_next_lsu_sender()can_lsu() && !ongoing_exchange() && !dbd_on_wire_oracle() generate_and_send_lsu(lsu_ip), propagate_lsu(),find_next_lsu_sender()hello_on_wire_oracle() && !dbd_on_wire_oracle() propagate_hello(), find_next_lsu_sender()can_hello() && !dbd_on_wire_oracle() reduce_lifetime_nbrs(hello_ip), generate_and_send_hello(hello_ip),sent_hello_intvl[hello_ip] = true,hello_ip = next_hello(second_tracker),find_next_lsu_sender()node_idx==N start_timing!node_idx=0, hello_ip = next_hello(0)t : int[0,hellointvl1] node_idx<Ninitialise(node_idx),  choose_hello_intvl(t,node_idx),++node_idx Figure 3: A single automaton for OSPF In a further abstraction, we can replace the (densetime) clock by a bounded integer that takes over the periodic sending of H ELLO messages. We assume that this model is behaviourally equivalent with regards to message sending and data structures, but obviously not regarding timing properties. 5 Adjacency Building The original model of OSPF, as well as the model described above, capture all but one core functionality of OSPF. The missing functionality, adjacency building, is an independent subroutine with no immediate effect on other functionality and hence is usually abstracted away. As discussed in Section 2, adjacency building describes the activities involved when two neighbouring nodes exchange all of their topological information – the content of their LSDBs. After the exchange, the nodes have an identical understanding of the entire network. In this section, we present a new, detailed model of adjacency building. When nodes have been assigned to form an adjacency, they progress through the following six neighbour states : Down :No information has been exchanged between the two nodes. Init:A participating node has recently received a H ELLO message from a neighbour. However, bidirec tional communication is not conﬁrmed yet – the node’s own IP is not part of the H ELLO message. ExStart :This is the ﬁrst step in the adjacencyestablishment procedure; it establishes the master/slave relationship between the nodes. Exchange :The master/slave relationship has been agreed upon, and nodes send D BDmessages sum marising their LSDBs. Loading :Nodes compare the full description of their neighbour’s LSDB with their local data. Missing information is requested via L SRmessages. Full:All requested L SAs have been received. A node’s neighbour state determines which messages it will send to its neighbour, as well as how it responds to messages received.C. Darville, P. H ¨ofner, I. Ivankovic & A. Pam 19 NeighbourExStart() && Messages_Processed() unicast! Generate_Exstart_DBD()NeighbourExchange() && RequestListEmpty() Delete_Message_In_Queue()!RequestListEmpty() unicast! Generate_LSR(), Delete_Message_In_Queue()NeighbourLoading() && RequestListEmpty() LoadingDone(), Delete_Message_In_Queue() (NeighbourExchange() || NeighbourLoading()) && !RequestListEmpty() && Messages_Processed() unicast! Generate_LSR()CanAcceptLSU() && AppropriateLSA() unicast! Install_LSA(), Generate_ACK(),Delete_Requests() ACKMessage() Delete_Message_In_Queue()CanAcceptLSU() && !AppropriateLSA() && !OnRequestList() unicast! Generate_ACK(), Delete_Message_In_Queue() CanAcceptLSU() && !AppropriateLSA() && OnRequestList() unicast! Bad_LSReq(), Increment_Sequence(),Generate_Exstart_DBD(),Delete_Message_In_Queue() !CanAcceptLSU() Delete_Message_In_Queue()CanAcceptLSR() && LSA_Exists() unicast! Generate_LSU(), Delete_Message_In_Queue() CanAcceptLSR() && !LSA_Exists() unicast! Bad_LSReq(), Increment_Sequence(),Generate_Exstart_DBD(),Delete_Message_In_Queue() !CanAcceptLSR()Delete_Message_In_Queue()LSRMessage() LSUMessage()Is_Duplicate() Delete_Message_In_Queue()!Is_Duplicate() unicast! Sequence_Mismatch(), Increment_Sequence(),Generate_Exstart_DBD(),Delete_Message_In_Queue() Is_Duplicate()unicast!Generate_Exchange_DBD(), Delete_Message_In_Queue() !Is_Duplicate()unicast!Sequence_Mismatch(), Increment_Sequence(),Generate_Exstart_DBD(),Delete_Message_In_Queue()!IsMaster()IsMaster() NeighbourLoading() || NeighbourFull() Neighbour_Finished_Sending() && Last_Message()unicast!Exchange_Done(), Generate_Exchange_DBD(),Record_Last_DBD_Message(),Delete_Message_In_Queue() (!Neighbour_Finished_Sending()) || (!Last_Message())unicast!Generate_Exchange_DBD(), Record_Last_DBD_Message(),Delete_Message_In_Queue()!Message_Inconsistencies_Slave() && !Is_Duplicate() Accept_Sequence(), Add_Reqs(),Remove_Acknowledged_Headers()!Finished_Sending() || !Neighbour_Finished_Sending() unicast! Generate_Exchange_DBD(), Record_Last_DBD_Message(),Delete_Message_In_Queue()Finished_Sending() && Neighbour_Finished_Sending() Exchange_Done(), Record_Last_DBD_Message(),Delete_Message_In_Queue() !Message_Inconsistencies_Master() && !Is_Duplicate() Increment_Sequence(), Add_Reqs(),Remove_Acknowledged_Headers() !Is_Duplicate() && Message_Inconsistencies_Slave()unicast!Sequence_Mismatch(), Increment_Sequence(),Generate_Exstart_DBD(),Delete_Message_In_Queue()!Is_Duplicate() && Message_Inconsistencies_Master() unicast! Sequence_Mismatch(), Increment_Sequence(),Generate_Exstart_DBD(),Delete_Message_In_Queue() IsSlaveExStart()unicast!Negotiation_Done(), Become_Slave(),Accept_Sequence(),Generate_Exchange_DBD(),Record_Last_DBD_Message(),Delete_Message_In_Queue() IsMasterExStart()unicast!Negotiation_Done(), Increment_Sequence(),Add_Reqs(),Generate_Exchange_DBD(),Record_Last_DBD_Message(),Delete_Message_In_Queue() Is_Duplicate()unicast!Generate_Exchange_DBD(), Delete_Message_In_Queue()Is_Duplicate() Delete_Message_In_Queue() !IsMaster()IsMaster() NeighbourExchange() !IsSlaveExStart() && !IsMasterExStart()Delete_Message_In_Queue()NeighbourExStart()NeighbourInit() unicast! Two_Way_Received(), Increment_Sequence(),Generate_Exstart_DBD()NeighbourDown() || NeighbourTwoWay() Delete_Message_In_Queue() DBDMessage()TwoWay() && NeighbourInit() unicast! Two_Way_Received(), Delete_Message_In_Queue(),Increment_Sequence(),Generate_Exstart_DBD() TwoWay() && !NeighbourInit() Two_Way_Received(), Delete_Message_In_Queue() !TwoWay() One_Way_Received(), Delete_Message_In_Queue() HelloMessage() Hello_Received() (NeighbourDown() || NeighbourInit() ) && Messages_Processed() && !SentHello unicast! Generate_Hello(), HelloSent()i: int[0,M1] Initialise_Neighbour(DOWN), NeighbourStructure.sequence = i,Initialise_LSDB() unicast? Add_Message_To_Queue(), Flush_Global_Message() Figure 4: Adjacency Building3 Figure 5: Receiving of L SUmessagesOur adjacency model, depicted in Figure 4, mod els the entire adjacency process from the Down state to the Fullstate. Similar to the original model [10], the adjacency model uses one automaton per node. In contrast to the previous model, we do not encounter problems with the state space as adjacency building is an activity between two nodes (two automata). The model closely follows the OSPF standard. Due to its complexity – it would take a lot of space to ex plain all details of the adjacencybuilding process, so they are omitted. The model can be found at http://marsworkshop.org and should be self explanatory. The model does not include a clock, and instead is forced to make progress by using ur gent and committed states within the automata.5The automata exchange messages using binary synchro nisation. To provide some insight in our model, we provide details on the handling of L SUmessages re ceived (Figure 5). The transition from the central state to a committed state ensures that the message received is indeed an L SUmessage. There are four possibilities as to how this message can be handled. The transition guarded by !CanAcceptLSU() corresponds to the case where the node is not in the state Exchange , Loading orFull, and hence any incoming L SUmessage is ignored and deleted. The top two transitions correspond to cases where a node can accept an L SUmessage, but the received message contains outdated or incorrect information. The ﬁnal transition models the default case where the content of the L SU message is more recent than the information stored in the node’s LSDB. In this case, the node updates its LSDB and L SArequest list, and generates an acknowledgement message in response. 5For a formal deﬁnition of urgent and committed locations see [18].20 Advanced Models for OSPF To validate the correctness of our model, we run some sanity checks. Among others we check that adjacencies are always completely established, i.e. both nodes reach the state Full, and that LSDBs are identical when the adjacency is established. Using U PPAAL ’s CTL syntax, these properties correspond to A<>(n1.NeighbourState == FULL && n2.NeighbourState == FULL) and A[]((n1.NeighbourState == FULL && n2.NeighbourState == FULL) imply LSDB Sync()) Here n1andn2are the two nodes forming an adjacency, and LSDB Sync() is a function that checks LSDBs for synchronicity. The CTL formula A<>jis satisﬁed if jholds on some state along all paths, andA[]jis satisﬁed if jholds on all states along all paths (e.g. [11]). We are able to verify these properties for a number of different starting conﬁgurations of the node’s LSDBs. 6 Modelling Adversaries Over the last decades, model checking has become one of the standard tools for analysing and verifying systems, with the main focus on functional correctness, i.e. checking whether a system acts as expected. Although correctness proofs are important, they are only half of the story. With systems connected more than ever, detecting and analysing vulnerabilities of systems are of equal importance. In the general area of security protocols, including cryptographic protocols, modelling adversaries and ﬁnding vulner abilities using model checking techniques are common [20, 4]. With very few exceptions, e.g. [15], ﬁnding vulnerabilities in systems, such as routing protocols, using model checkers is uncommon. In this section, we present ﬁrst attempts to discover vulnerables, using model checking. When mod elling routing attacks we distinguish two different concepts: attack capabilities andattack goals . Attack capabilities deﬁne the behaviour of the adversary. They include properties such as the number of ma licious nodes and connectivities (e.g. [23]). In contrast, an attack goal describes the speciﬁc aim of an attack. This includes general properties such as delivery failure and routing loops, as well as protocol speciﬁc targets such as the destruction of adjacencies. The consequences of (successful) attacks are sometimes also analysed. For example, a routingloop attack yields packet loss. 6.1 Attack Capabilities We model capabilities as one or more separate timed automata. This modular approach allows us to combine the same attacker model with different formalisations of OSPF, or even other routing protocols. Number of Malicious Nodes Thenumber of malicious nodes in the network is one of the capabilities. In our setting, each malicious node (attacker) is modelled by a separate automaton executed in parallel to the model of the routing protocol. For the moment, we restrict ourselves to one malicious node only. Connectivity There exist two reasonable scenarios: (a) a malicious node can only send to its immediate neighbours, similar to a node running an uncorrupted version of OSPF, and (b) a node can inject messages to all nodes in the network, which can be achieved in real networks (e.g. [23]). In both models of OSPF, we characterise connectivity as a Boolean matrix, or equivalently with a Boolean predicate connect , see Section 3. When modelling capability (a), no change is required. For option (b), a minor modiﬁcation of the predicate connect sufﬁces. Technically, the relation is not symmetric any longer. Time of the Attack The third capability is the time point an attack begins . It determines at what point during the lifetime of the network a malicious actor performs the take over of a router and begins an attack. Although this point in time is arbitrary, we only consider two scenarios: (a) the node is alreadyC. Darville, P. H ¨ofner, I. Ivankovic & A. Pam 21 Initialiser OSPF CheckMalLSR CheckMalDBDCheckMalLSUCheckMalHellohello_on_wire.sip >= N mal_hello!!(hello_on_wire.sip >= N) propagate_hello(), find_next_lsu_sender() !(lsu_on_wire.sip >= N) propogate_requested_lsu(), find_next_lsu_sender() lsu_on_wire.sip >= N mal_lsu! !(dbd_on_wire.sip >= N || dbd_recipient >= N) propagate_dbd(), find_next_lsu_sender() dbd_on_wire.sip >= N || dbd_recipient >= N mal_dbd!!(lsr_on_wire.sip >= N || lsr_recipient >= N) propagate_lsr() lsr_on_wire.sip >= N || lsr_recipient >= N mal_lsr!lsr_on_wire_oracle() && !lsu_on_wire_oracle() tau!dbd_on_wire_oracle() && !ongoing_exchange() tau!lsu_on_wire_oracle() tau!can_lsu() && !ongoing_exchange() && !dbd_on_wire_oracle() tau!generate_and_send_lsu(lsu_ip), propagate_lsu(), find_next_lsu_sender()hello_on_wire_oracle() && !dbd_on_wire_oracle() tau!can_hello() && !dbd_on_wire_oracle() tau!reduce_lifetime_nbrs(hello_ip), generate_and_send_hello(hello_ip), sent_hello_intvl[hello_ip] = true, hello_ip = next_hello(second_tracker), find_next_lsu_sender()node_idx==N start_timing! node_idx=0, hello_ip = next_hello(0)t : int[0,hellointvl1] node_idx<N initialise(node_idx),  choose_hello_intvl(t,node_idx), ++node_idx Figure 6: A single automaton for OSPF, modiﬁed for attacks3 malicious when the protocol is initiated, and (b) the attacker gains access to a node after OSPF reaches a steady state, i.e. all adjacencies are established and all nodes have the same view of the network topology. Other possible time points, e.g. the attack starts during initialisation of the protocol, are not consid ered since the likelihood of exploitation during these time periods is basically zero. Adversaries’ Activities The ﬁnal, and arguably most important, capability describes the activities an adversary can perform. They are manifold, sometimes protocolspeciﬁc, and include the following: • type of OSPF messages (D BD, LSR, LSU, . . . ) the attacker is allowed to send; • components of the message which can be manipulated; e.g. the attacker can ‘only’ change the con tent of a message or it can pretend to send the message on behalf of some other node (false identity); • the order of messages sent; . . . For our initial experiments, described below, we use an ‘all mighty’ adversary that can inject any type of message with arbitrary content at any time. We model this behaviour as a nondeterministic automaton. Such an adversary is trivial to run in parallel with the original model of OSPF, featuring individual automata for each router (Figure 2), since concrete messages exist as ﬁrstclass citizens. An ‘all mighty’ attacker in our optimised model requires some minor modiﬁcations as message contents are abstracted away. Figure 6 demonstrates the modiﬁed automaton; each transition for delivering a message is split into two branches. One is used for the exchange of standard OSPF messages, the other allows for the exchange of messages involving a malicious party. It is noteworthy that the new, modiﬁed automaton decouples the OSPF protocol logic from the at tacker logic and allows the same automaton of OSPF to be used for any number of different attack models without modiﬁcation. It also allows the possibility of executing standard OSPF without any malicious nodes – in this case, our new automaton behaves identical to the original model. 6.2 Attack Goals We model an attack goal as a state in the system. The reachability of this state determines if the attack is successful. Of course, it is not required that the attack is successful under all possible scenarios. The formula lsdp[sip][oip] describes sip’s current view of the network topology around node oip, i.e. it lists, among other information, all neighbours of oipthat are known to sip.22 Advanced Models for OSPF Blackhole Attack In this type of attack, the attacker tries to convince one or more nodes to send (data) packets via the attacker so that the packets can be dropped. Any packet routed through the malicious node will suffer from partial or total data loss. These routes can only be established if either nonexistent links are installed in a node’s LSDB or if some links are removed. Both existence and removal is characterised by a malicious/fake topology: E<>(^ sip2S dip2Tlsdb[sip][dip].malicious) (1) for some sets SandT. In case one does not want to encode nonoptimal routes via concrete LSDB entries, one can calculate the shortest routes from a given LSDB. Suboptimal Routes Establishing suboptimal routes means that the number of hops of the established route is greater than the actual shortest path. This attack does not cause packet loss but wastes network resources. As packet routing is based on shortest paths, we can use the same formulas (Eq. (1)) to encode this attack. Adjacency Interruption The ﬁrst two attacks are concerned with OSPF. An attacker can also inject or spoof OSPF messages that prevent nodes which should form an adjacency from completing the synchro nisation process 7 Initial Experiments Using our optimised model, we analyse the above attack goals on very small topologies. These experi ments are not intended to be a systematic analysis of vulnerabilities, but are merely intended to show the power of our approach. 7.1 Blackhole Attack and Suboptimal Routes We report on a number of examples of networks up to size 4, a full, systematic analysis on all topologies up to a much larger size is part of future work. Some topologies used for the experiments are depicted in Figure 7. The solid lines indicate the real topology, the dashed lines stand for the malicious topology. In all cases, the malicious router is node 3, and its (main) victim is node 0. Attacks whose effects get subsequently corrected by the mechanisms of the protocol, in our case OSPF, are called nonpersistent . They can, nevertheless, temporarily affect the way the trafﬁc is routed and can slow down the network trafﬁc. The attacks we discover rely on placing malicious entries in the victims’ LSDBs. Each experiment related to an attack goal is run in two instances (cf. Section 6.1): (a) the attack starts before the network is up and running, i.e. all nodes in the network start with an empty LSDB and the OSPF runs through its initialisation, and (b) the attack starts after OSPF has been initialised, i.e. all LSDBs of all honest nodes contain all truthful information about the topology. In both cases, the attacker starts with an LSDB having malicious version of the topology as content. This LSDB will not change during an attack. The adversary then tries to propagate this false information through the network. In the blackhole attack, the adversary convinces its victim to redirect the trafﬁc through the at tacker node. In the simple topology of Figure 7(a) an adversary can be successful, i.e. the property E<>(lsdb[0][2].malicious && lsdb[0][3].malicious) holds. This is because most of the nodes are one hop neighbours and proper calculation of shortest paths are not needed. In this situation the attack isC. Darville, P. H ¨ofner, I. Ivankovic & A. Pam 23 0 123 1 023 Figure 7: (a) Blackhole (b) Suboptimal routes successful if node 0 believes that there is a connection between nodes 2 and 3 (and no connection be tween 1 and 2). Instead of sending the trafﬁc through node 1, node 0 will then forward the trafﬁc for node 2 through node 3, which will drop it. Suboptimal routes can be installed in many topologies, such as the one depicted in Figure 7(b). As for the previous attack we can simplify the attack goal and use the formula E<>(lsdb[0][1].malicious && lsdb[0][3].malicious) . The attacker convinces node 0 that there is a connection between nodes 1 and 3. Node 0 then sends trafﬁc for node 3 through node 1 (instead of sending it through node 2). Node 1 correctly believes that there is no link between itself and node 3, so it passes trafﬁc through node 2. The network easily recovers from these attacks by receiving further H ELLO messages, or by receiv ing further L SUmessages sent to correct faulty information. Remember that these simple attacks are designed to test our setup, not to do a fullscale analysis of vulnerabilities. 7.2 Tear Down Adjacencies Similarly to our use of the abstract model of OSPF, we perform initial experiments with the detailed model for adjacency building. As before we use a nondeterministic automaton, which can inject arbitrary messages. We also use more limiting attack capabilities that can only inject a certain type of OSPF message. The one for H ELLO messages is depicted in Figure 8. Can_Receive[victim_ip]  && Messages_Processed[fake_ip] && AttackerTurn unicast! Generate_False_HELLO(), AttackerTurn = 0 Figure 8: Injecting H ELLO sOur analysis reveals that adjacencies can be torn down. We sketch this attack; here n1andn2are the two routers involved. • Sending a H ELLO message on behalf of n1(n2) which does not carry the IP address of n2(n1) in its payload resets the adjacency building process by reverting the neighbour state back to Init. • Sending an L SRmessage on behalf of n1orn2which requests an L SAthat does not exist in the recipient’s LSDB reduces the neighbour state to ExStart if it is in a higher state at the time of receiving. In case the neighbour state is Down ,InitorExStart this injection does not have any effect. • Sending a D BDmessage on behalf of n1orn2which meets one of the following criteria will regress to the neighbour state to ExStart if it is in a higher state at the time of receiving: –The D BDsequence number, a unique number which is part of every D BDmessage, does not match the expected sequence number. –The D BD’s master ﬂag is inconsistent with the current connection. –The message has the init ﬂag set – this ﬂag indicates that this D BDis an attempt to initiate a neighbour relationship. Once a node’s neighbour state has been reverted to InitorExStart , it is no longer able to share information with its neighbour. As a consequence, the adjacency needs to be reestablished. One of these attacks can delay the establishment of adjacencies; repeating one of them indeﬁnitely avoids the establishment of24 Advanced Models for OSPF adjacencies entirely. When checking A<>(n1.NeighbourState == FULL && n2.NeighbourState == FULL) UPPAAL generates a trace that falsiﬁes the property, characterising a speciﬁc attack. The above trace demonstrates that adjacency building can be interrupted, but it does not show that it is possible to tear down full adjacencies. In order to demonstrate this, we make very minor adaptations to our model which enable the nodes to start in state Fullwith their LSDBs synchronised. Using the same attacker automata, we use U PPAAL to show that it is possible to regress our node’s neighbour state to Init orExStart . Since U PPAAL does not allow for nested CTL expressions, it is not possible to verify that the nodes are unable to reestablish a state Full. However, once the nodes have regressed to InitorExStart , we are able to apply our earlier ﬁndings, as this is the same conﬁguration as in our ﬁrst experiment. 8 Related Work "
387,"A General, Fault tolerant, Adaptive, Deadlock-free Routing Protocol for Network-on-chip.txt","The paper presents a topology-agnostic greedy protocol for network-on-chip
routing. The proposed routing algorithm can tolerate any number of permanent
faults, and is proven to be deadlock-free. We introduce a specialized variant
of the algorithm, which is optimized for 2D mesh networks, both flat and
wireless. The adaptiveness and minimality of several variants this algorithm
are analyzed through graph-based simulations.","The ongoing downscaling of transitor technology has al lowed to integrate increasingly large numbers of electronic systems in a single chip (i.e. systemonchip). Networkon chip (NoC) provides a communication system between the components of such a systemonchip and has been shown to be a more scalable means of communication than traditional busbased connections [1]. However, these smallscale technologies are expected to be increasingly prone to hardware defects [2]. Also, the use of networkonchip technology has been proposed for challenging applications such as softwaredeﬁned metamaterials, which are deployed in extreme environments in which component failures are more likely to occur [3]. This creates a need for networkonchip routing algorithms which are able to deal with such defects. Additionally, a variety of NoC architectures have been proposed [4]. The heterogenity in network topology is in creased even further by powergating techniques [5] and the introduction of wireless, reconﬁgurable links [6]. Routing P. Stroobant is funded by a Ph.D. grant of Ghent University, Special Research Fund (BOF). S. Abadal and E. Alarc ´on gratefully acknowledge support by the European Commision under grant H2020FETOPEN736876 (VISORSURF).algorithms should be able to handle a variety of network topologies. The contribution of our paper is to propose and evaluate a routing protocol with the following properties: Our algorithm achieves full fault coverage : whenever a path between a transmitting node and the destination exist, a route will be found. This is in contrast to some methods (see Section II), which require to deactivate healthy nodes that are part of a ‘fault region’. The presented routing scheme is topologyagnostic , i.e. it works (in principle) on any topology. However, increas ingly complex topologies require longer address sizes. Network layouts with a high regularity allow for a more efﬁcient address representation (see Section IVC). No routing table is required by the algorithm. Thus, no hardware for such tables must be provided, which limits the area overhead of an implementation. The algorithm is fully distributed : there is no single point of failure in the network The proposed method is deadlock free , and no virtual channels are required When several paths between the source and destination nodes are possible, the routing method typically allows forwarding nodes some choice in the selection of the next hop. Combining this freedom with local congestion information may allow routers to adapt the route in order to aim at a lower congestion rate. This adaptiveness is analysed in Section V. However, in use cases which require that all packets arrive in order, the algorithm can be made deterministic as well. Whilst in operation, some newly occurring component (node or link) failures do not require to reconﬁgure the routing algorithm. This property can be leveraged to achieve no reconﬁguration overhead when turning 9781538685525/18/$31.00 ©2018 IEEEarXiv:1811.11262v1  [cs.NI]  25 Oct 2018off parts of the chip to save power using powergating techniques [5] . There is no guaranteed minimal path length , that is, the length of some of the paths generated by the algorithm may suboptimal. Longer paths result in an increased latency, and thus should be avoided. Section V evaluates the performance of the algorithm in terms of path length. To the best of our knowledge, our work is the ﬁrst topology agnostic routing algorithm which provides full fault coverage without requiring the area overhead that comes with routing tables. This comes from the fact that we are the ﬁrst ones to propose the use of spanning trees for greedy routing in networkonchip. Our work is structured as follows: an overview of related work on fault tolerant routing techniques for networksonchip is given in Section II. Subsequently, Section III explains the routing technique in its most general formulation, and provides proofs and insights in the properties of the routing method. Next, Section IV argues how to optimize this algorithm for (hierarchical) grids. After this, Section V presents some key metrics for the proposed algorithm in a 2D mesh network setting. Finally, Section VI summarizes our work. II. R ELATED WORK "
403,IoT Data Discovery: Routing Table and Summarization Techniques.txt,"In this paper, we consider the IoT data discovery problem in very large and
growing scale networks. Through analysis, examples, and experimental studies,
we show the importance of peer-to-peer, unstructured routing for IoT data
discovery and point out the space efficiency issue that has been overlooked in
keyword-based routing algorithms in unstructured networks. Specifically, as the
first in the field, this paper investigates routing table designs and various
compression techniques to support effective and space-efficient IoT data
discovery routing. Novel summarization algorithms, including alphabetical,
hash, and meaning-based summarization and their corresponding coding schemes,
are proposed. We also consider routing table design to support summarization
without degrading lookup efficiency for discovery query routing. The issue of
potentially misleading routing due to summarization is also investigated.
Subsequently, we analyze the strategy of when to summarize to balance the
tradeoff between the routing table compression rate and the chance of causing
misleading routing. For the experimental study, we have collected 100K IoT data
streams from various IoT databases as the input dataset. Experimental results
show that our summarization solution can reduce the routing table size by 20 to
30 folds with a 2-5% increase in latency compared with similar peer-to-peer
discovery routing algorithms without summarization. Also, our approach
outperforms DHT-based approaches by 2 to 6 folds in terms of latency and
traffic."," Summarization of numerical values can also be done intuitively by union of individual ranges [5]. For summarizing keywords, a natural extension of these methods is alphabetical based summarization, which compresses multiple keywords into their longest common prefix. However, alphabetical based method depends on how likely we can find proper keyword groups that can be summarized into common prefixes. If the group of keywords that can be summarized does not show up together in a routing table, then it will be difficult to compress the table. In fact, experimental results show that the effectiveness of alphabetical based summarization is limited. To avoid the dependency on keyword distributions, we can use hashing to randomize the set of keywords in the system to a uniformly distributed coding space to allow summarization to occur more uniformly. Accordingly, we also consider the hash based summarization in this paper. When considering keyword distributions carefully, we can see that relevant keywords may have some regionalized appearance. For example, some cities are major manufacturing sites for certain products, such as Detroit for automotive manufacturing, Chicago for steel industry, etc. Specific sensor data streams for production line monitoring for particular industries may include many semantically similar keywords. In a smart city setting, sensors with similar functionalities, such as traffic observation, pollution monitoring, trash tracking, etc., may be used throughout the city. The descriptors for these sensor data streams will also have significant similarities. To achieve potentially better routing table compression by making use of the regionalized keyword similarity distributions, we also consider the meaning based summarization to summarize IoT data descriptors with similar keywords and expect that it will yield a better compression ratio. Is summarization for keywords feasible? With keywords indexing the routing tables, how do we know which keywords (routing table entries) can be aggregated? This is straightforward for IP based routing, for numerical ranges, and for the alphabetical based method, but difficult in other approaches. Having keywords such as temperature, pressure, flow rate, etc., in a routing table, how do we know whether they can be summarized? No work has specifically addressed this issue.  We design novel coding schemes to maintain parentchild summarization relations to enable the identification of the child keywords that can be summarized and the parent keyword to be summarized into. These coding schemes can further improve space efficiency of the routing tables. Thus, we allow routing information to be summarized instead of thrown away to achieve space efficiency as well as routing effectiveness. How to know when to summarize? Unlike IP based routing, where same domain prefixes have a high probability of implying the same routing directions, keyword based summarization does not have the same implication. Assume that a parent keyword 𝑝 has three child keywords 𝑥, 𝑦, and 𝑧 (i.e., 𝑥, 𝑦, and 𝑧 can be summarized into 𝑝). During summarization, how do we know 𝑝 has three child keywords? This is an issue even for alphabetical based summarization. Again, we need to maintain the ontology at each routing node, which is not feasible. Also, should we require that summarization to 𝑝 can only be done when all the 3 child keywords appear in the routing table (full coverage) or allow a partial set of these keywords to be summarized into 𝑝 (partial coverage). With IP addressing, this is less a problem due to its domain based design. But in keyword based routing, requiring full coverage reduces the routing table compression ratio and allowing partial coverage may result in misleading routing. In this paper, we not only analyze the impact of the “coverage” threshold, but also develop novel schemes to compute coverage for truly realizing the summarization strategies. Discovery routing table. We develop novel data structures and algorithms for the routing tables to further enhance space efficiency in routing and facilitate efficient lookup for query routing and efficient table updates for routing information updates and summarization. Experimental study. We crawled the web, obtained 100K IoT data streams, and extracted their descriptors [7]. Accordingly, we conducted indepth experiments to study the performance of our summarization strategies under different settings. We also compared our approach with DHTbased and other unstructured routing solutions in largescale IoT networks. Experimental results show that our summarization solutions yield great space efficiency for routing tables. A preliminary version of this paper appears in [8]. In the rest of the paper, Section 2 discusses the related literature. Section 3 formally defines our multiattribute annotation model and our discovery routing problem. Section 4 discusses the three summarization strategies and the algorithmic designs to realize them. Section 5 considers the summarization coverage issue and discusses the schemes to enable coverage computation. Section 6 discusses handling the IoTDBN growth. Section 7 introduces novel designs of the routing table and the routing algorithms to realize the proposed summarization techniques in a space and timeefficient way. Experimental results are presented in Section 8 and 9. Section 10 concludes the paper. 2 RELATED WORKS Centralized IoT data discovery solutions [8], [9] require a tremendous amount of resources to maintain the information of all the IoT data sources worldwide. With the fastgrowing number of IoT devices and their corresponding raw and processed data, the scalability may become a concern. More importantly, if the change rate of the IoT data streams is significant, it will take a lot higher communication cost to keep the centralized information up to date. Also, locality sometimes is important in the discovery process. Thus, peertopeer (p2p) discovery still plays an important role. There are two major directions in p2p data discovery, DHT based and unstructured routing, which were mainly designed for document search. DHT based solutions for MAA based data discovery. A lot of works in keyword based discovery in peertopeer HIEU TRAN ET AL.:  IOT DATA DISCOVERY: ROUTING TABLE AND SUMMARIZATION TECHNIQUES 3  "
407,A Survey of Energy Efficient Schemes in Ad-hoc Networks.txt,"Ad hoc network is a collection of different types of nodes, which are
connected in heterogeneous or homogeneous manner. It is also known as
self-organizing-wireless network. The dynamic nature of ad hoc networks make
them more attractive, which is used in many different applications. Every coin
has two sides: one is the advantage part and other is disadvantages, in the
same manner nature of ad hoc network make it more attractive from one side in
other hand there are some issues too. Energy efficiency is a core factor which
effects on ad hoc network in terms of battery life, throughput, overhead of
messages, transmission error. For solving issues of energy constraints,
different mechanisms are proposed by various researchers. In this paper, we
survey various existing schemes which attempt to improve energy efficiency of
different types of ad hoc routing protocol to increase network lifetime.
Furthermore we outline future scope of these existing schemes which may help
researches to carry out further research in this direction."," Collection of the different nodes (i.e . PDAs , various   types’ sensors  and laptop ) in either homogeneous or  heterogeneous manner is known as ad hoc network [ 1].These  nodes have dynamic nature so that they can move in any  direction randomly [1 ]. Selforganizing and self configuring  nature and instant response whenever application needed make  an ad hoc network more reliable and  attractive for  today’s  world  [2].There are various types of ad hoc networks  like  MANET, VANET, WSN etc.  Here network refer as a  heterogeneous system in which combination of tiny nodes and  actuators with general purpose computing elements [3].   Ad hoc netwo rks are very attractive for tactical  communication in military and law enforcement. They are also  expected to play an important role in civilian forums such as  convention centres, conferences, and electronic classrooms  [2]. Many other application are also there, which are  monitoring air pollution, detection of fore st fire, water quality  observation , Disaster management, habitat monitoring, target  tracking, security management, home automation and traffic  control, earthquake warning and monitoring the enemy  territory, agro sensing, medical field etc.  There are many aspects which effect on the ad hoc  network like energy consumption, number of nodes in  network, security threats, and availability of resources etc. The  energy constrain is the important issues in ad hoc  network.There are many terms which will effect on the energy  efficiency of the network such as physical damage, limited  resources, limited transmission power, limited battery power,  routing overhead etc.   The rest of the paper is d escribe as: Sectio n 2 describes   various methods used f or reducing energy consumption,  Section 3 presents related work  and finally, in section 4  conclusion is mentioned.     II. METHODS TO REDUCE EN ERGY CONSUMPTION   "
336,Performance comparison of various routing protocols in different mobility models.txt,"Mobile Ad hoc Network (MANET) is a infrastructure less network in which two
or more devices have wireless communication which can communicate with each
other and exchange information without need of any centralized administrator.
Each node in the ad hoc network acts as a router, forwarding data packets for
other nodes. The main issue is to compare the existing routing protocol and
finding the best one. The scope of this study is to test routing performance of
three different routing protocols (AODV, OLSR and DSDV) with respect to various
mobility models using NS2 simulator. In this paper the parameters used for
comparison are packet delivery fraction (PDF), average end to end delay (AEED),
normalized routing load (NRL) and throughput.","A Mobile Ad Hoc Network is a collection of mobile nodes with no pre established  infrastructure, self organizing w ireless network which forms a temporary network [1].            Figure 1: Infrastructured and ad hoc networks.   Each of the nodes has a wireless interface and communicates each other over either radio or  infrared signals.  In ad hoc networks [2] all nodes are mobile and can be connected dynamically in an arbitrary  manner. One  area of research, which has been a focal point of research in Ad hoc  networks, is Routing. Generally, Adhoc routing protocols can be classified broadly into two  categories, these are Proac tive, Reactive.  A brief classification of Ad hoc routing protocols is  given in F igure 2.                                   Table Driven routing protocols  (Proactive)  In table driven / proactive routing protocols  [4], nodes periodically exchange routing information and atte mpt to keep u ptodate routing  information [5 ]. Proactive protocols are called so because they have to maintain information  about routing prior to its use. Information about routes is maintained in tables called routing  tables and when topology changes the se tables are updated.   On Demand routing protocols  (Reactive)  In on deman d/ reactive routing protocols [6 ],  nodes only try to find a route to a destination when it is actually needed for communication.   Proactive protocols are named so, because routing table [7] is not maintained  in it. When  communication between nodes  is required then r oute is discovered in o ndemand manner.   Many routing protocols have been proposed, but just few comparison studies have been  performed. Almost all available comparative studi es have performed simulations for proactive  and reactive protocols by varying number of nodes, network topology, and network density.  This paper focuses on varying mobility speed from low to high by keeping other parameters like  pause time, number of nodes , mobile connections, simulation duration constant. This study is  performed by varying mobility speed and measuring different quantitative metrics in different  mobility models i.e. RPGM and RWPM. Reference Point Group Mobility (RPGM) model  shows  the random  motion of mobile nodes associated with a group  [3]. Random Waypoint  Model (RWPM) assumes that each host is initially placed at random position within the  simulation area. As the simulation progresses, each host possess at its current location for a  determ inable period called the pause time [3].   The remainder of the paper is organized as follows. After presenting the related work in section  2, section 3 presents routing in MANET. Section 4 presents mobility models. Section 5  describes simulation environment . The results of our simulation are analyzed in section 6.  Finally, section 7 concludes the paper.   2. RELATED WORK  "
303,Broadcasting Real-Time Flows in Integrated Backhaul and Access 5G Networks.txt,"This paper studies the problem of broadcasting real-time flows in multi-hop
wireless networks. We consider that each packet has a stringent deadline, and
each node in the network obtains some utility based on the number of packets
delivered to it on time for each flow. We propose a distributed protocol, the
delegated-set routing (DSR) protocol, that incurs virtually no overhead of
coordination among nodes. We also develop distributed algorithms that aim to
maximize the total system utility under DSR. The utility of our DSR protocol
and distributed algorithms are demonstrated by both theoretical analysis and
simulation results, where we show that our algorithms achieve better
performance even when compared against centralized throughput optimal policies.","Mutlihop broadcasting in wireless networks, which entails disseminating information to every device in the system via retransmissions at multiple nodes, is an im portant mechanism to coordinate devices in networked systems. Furthermore, many applications of broadcast communications are safetycritical, and timely deliverie s of information is crucial to maintain the robustness and safety of the system. For example, multihop broadcast ing is needed to disseminate timely safety information among connected vehicles in vehicular ad hoc networks (VANETs), to announce control decisions in networked control systems and Internet of Things (IoT), and to exchange locations and ﬂight paths among unmanned aerial vehicles (UAVs) for Unmanned Aircraft System Trafﬁc Management (UTM). The cellular infrastructure that will enable these time critical broadcast wireless applications will be 5G net works that are currently being designed to support ultralow latency, ultrahigh throughput communications . These networks will utilize the highly directional and high bandwidth mmwave band, which suffers from high attenuation and sensitively to fading. This requires the relatively dense deployment of small base stations at spac ings of about 250m. However, providing ﬁber backhaul to all of these base stations is prohibitively expensive. An important development in this context is Integrated Access and Backhaul (IAB) [1], [2], under which there are a few base stations with ﬁber backhaul that act as gateways to many others that are connected via a mm wave wireless mesh backhaul. This mmwave backhaulcreates a directional wireless network between the nodes, but routing across these is highly dynamic and subject to the vagaries of the wireless channel. The same mmwave spectrum also is used to provide access to endusers, i.e., both access and backhaul are integrated over mmwave. Motivated by the above features of emerging networks, this paper studies the problem of designing algorithms for broadcasting realtime ﬂows with strict perpacket end toend deadlines in directional wireless mesh networks. Here, realtime ﬂow imposes a strict deadline for each of its packets, and packets that cannot be delivered before their respective deadlines are dropped from the system. From the IAB perspective, our goal is to ensure that each broadcast packet is delivered to an appropriate IAB base station before its deadline, at which point it is immedi ately transmitted to its respective end user. Each IAB node in the network then obtains some utility based on the timeaverage number of ontime packets that it receive from each ﬂow. The goal of this paper is to maximize the total timelyutility of the whole network. There are several important challenges that need to be addressed for broadcasting realtime ﬂows in such multihop mmWave networks. First, since it is difﬁcult to coordinate a large network in realtime, centralized algorithms that require the instant knowledge of the state of each node and packet are usually infeasible to imple ment. Hence, we need distributed algorithms, where each node makes decisions using its local information. Second, as mentioned above, transmissions in the mmWave band can be unreliable. Finally, broadcasting algorithms need t o explicitly address the deadline requirement of each ﬂow. Main Results and Organization In this paper, we propose a new protocol for broad casting in multihop mmWave networks, namely, the delegatedset routing (DSR) protocol. DSR has two impor tant features: First, it is a distributed protocol where all the required coordination among nodes can be conveyed in the headers of packets once the topology of the net work is known. Hence, there is virtually no overhead of coordination after topology creation process. Second, DSR allows each node to dynamically change its transmission strategies based on the deadlines of its packets and ran dom events, such as transmission failures, it experiences.Relaxing the link utilization constraint (number of tran missions allowed per time slot) to an average one, and using dual decomposition techniques, we also propose a distributed algorithm that aims to maximize the to tal systemwide utility under DSR. This algorithm only requires minimal and infrequent information exchange among nodes. We analytically prove that our algorithm achieves the optimal total utility under an average link ca pacity constraint. The key novelty lies in a natural decom position into packetbypacket and linkbylink updates that need minimal coordination. These lead to a steepest ascenttype control associated with each packet, and a subgradient type of update at links. This algorithm also gives rise to a simple index policy when link utilization constraints of all links need to be satisﬁed at every instant . We evaluate our algorithms through simulations on rep resentative network graphs. We compare our algorithms against recent studies on throughput optimal algorithms, including one that is designed speciﬁcally for broadcast, and one that is universal in terms of being able to support unicast, multicast and broadcast. We show that despite some of these algorithms being centralized and complex, our algorithm, which is designed speciﬁcally for simplicit y and delay optimality, achieves better performance. The paper is organized as follows. Section II reviews existing studies on broadcasting and multihop networks. Section III describes our system model for multihop net works with realtime broadcast ﬂows. Section IV describes the additional structure imposed by the DSR protocol, as well as an epochwise approach to policy selection. Section V applies dualdecomposition, which turns out to be the basis of our distributed algorithm. Section VI proposes distributed algorithms that optimize DSR, as well as the index policy that can ensure hard capacity constraints are met. Section VII presents our simulation results. Finally, Section VIII concludes the paper. II. R ELATED WORK "
386,Effect of Mobility and Traffic Models on the Energy Consumption in MANET Routing Protocols.txt,"A Mobile Ad hoc Network (MANET) is a group of mobile nodes that can be set up
randomly and formed without the need of any existing network infrastructure or
centralized administration. In this network the mobile devices are dependent on
battery power, it is important to minimize their energy consumption. Also
storage capacity and power are severely limited. In situations such as
emergency rescue, military actions, and scientific field missions, energy
conservation plays an even more important role which is critical to the success
of the tasks performed by the network. Therefore, energy conservation should be
considered carefully when designing or evaluating ad hoc routing protocols. In
this paper we concentrated on the energy consumption issues of existing routing
protocols in MANET under various mobility models and whose connections
communicate in a particular traffic model (CBR, Exponential, and Pareto). This
paper describes a performance comparison of the AODV, DSR and DSDV routing
protocols in term of energy consumed due to packet type (routing/MAC) during
transmission and reception of control packets. The mobility models used in this
work are Random Waypoint, Manhattan Grid and Reference Point Group. Simulations
have been carried out using NS-2 and its associated tools for animation and
analysis of results."," A Mobile Ad hoc Network is a group of two or more  devices or nodes or terminals with wireless communications  and networking competence that communicate with each  other  without the help of any centralized administrator [9].  Also the wireless nodes that can form a network to exchange  information according to their need at that time are an  infrastructure less  network  of mobile devices connected  by wireless  links. The nodes in this type of networks are  generally power constrained because they depend on limited  battery resourc es, whereas wireless communications consume  a lot of energy. Without the resource, power, mobile devices  will become useless. So, maximizing the lifetime of batteries    Man uscript received  on February 2013      Said EL KAFHALI , Computer, Networks, M obility and Modeling  laboratory/ Department of Mathematics and Computer / FST, Hassan 1st  University, Settat, Morocco / ENGN Research group, Africa and Middl e  East.  Abdelkrim HAQIQ , Computer, Networks, M obility and Modeling  laboratory/ Department of Mathematics and Computer / FST, Hassan 1st  University, Settat, Morocco / ENGN Researc h group, Africa and Middle  East.   of each host and entire network is an important issue,  especially for MANET, which is sup ported by batteries only.   Routing packets is one of the main problems in Mobile  Adhoc Network. In order to facilitate communication within  the network, a routing protocol is used to discover routes  between nodes. The primary goal of such a MANET routing  protocol is correct and efficient route establishment between a  pair of nodes so that messages may be delivered in a timely  manner. Although establishing efficient routes is an important  goal, a more challenging goal is to provide energy  consumption routing  protocols, since a critical limiting factor  for a mobile node is its operation time, restricted by battery  capacity. However, the wireless link only routing path in a  MANET makes energy savings difficult to achieve. The  corresponding reduction of nodes’ l ifetime directly affects the  network lifetime since mobile nodes  themselves collectively  form a network infrastructure for routing in a MANET.    In mobile ad hoc network, energy consumption is an  important issue as most mobile host operates on limited  battery resources. Conservation energy is, therefore, critical  in order to prolong the lifetime of the network. There are two  main consumers of energy on a MANET node, namely, the  central processing unit and the radio (transmitter/receiver). A  mobile node not only consumes its battery energy when it is  actively sending or receiving packets, but it also consumes  battery energy when idle and listening to the wireless medium  for any possible communication requests from other nodes.  Thus, energy efficient routing p rotocols minimize either the  active communication energy which is required to transmit  and receive data packets or the energy consumed during  inactive periods. In terms of protocols that belong to the  former category, the active communication energy may be   reduced by adjusting the radio power of each node just  enough to reach the receiving node, and no more. Generally  proactive protocols consume more energy due to large routing  over heads and reactive protocols suffer from route discovery  latencies.   The mo bility model plays a very important role in  determining the protocol performance in MANET. Thus, it is  essential to study and analyze various mobility models and  their effect on MANET protocols. In our first work [23], we  simulated AODV, DSR and DSDV routi ng protocols using  Manhattan Grid Mobility Model and their performances are  analyzed in terms of Packet Delivery Fraction (PDF),  Average end to end Delay and Throughput, in different  environments specified by varying network load, mobility  rate and number of nodes. In the present analysis, we compare  the energy consumption of these protocols under different  mobility models using CBR, Pareto and Exponential traffic Effect of Mobility and Traffic Models on the  Energy Consumption in MANET Routing  Protocols     Said EL KAFHALI , Abdelkrim HAQIQ    Effect of Mobility and Traffic Models on the Energy Consumption in MANET Routing Protocols      243   models. The main aim of this paper is to determine the  combination of routing protocol, traffi c mode l and mobility  model which allows a minimum of energy consumption with  various average speeds.   The remainder of this paper is  organized as follows: section  II review s the related work. In section III  we give a brief  description of the stud ied routing pro tocols. Section IV   present s the mobility models. Section V  presents the details of  the simulation tools and environments. Simulation results and  analysis are described in section VI. Finally, section VII   presents our conclusions.   II. RELATED WORK   "
228,On the Benefits of Multi-hop Communication for Indoor 60 GHz Wireless Networks.txt,"The spectrum-rich millimeter wave (mmWave) frequencies have the potential to
alleviate the spectrum crunch that the wireless and cellular operators are
already experiencing. However, compared with traditional wireless communication
in the sub-6 GHz bands, due to small wavelengths most objects such as human
body, cause significant additional path losses (up to 20dB), which can entirely
break the mmWave link. Also, mmwave links suffer from limited range of
communication. In this paper, we resort to network layer solutions to
demonstrate the benefits of multi-hop routing in mitigating the blockage issue
and extending communication range in mmWave band. To this end, we develop a
hop-by-hop multi-path routing protocol that finds one primary and one backup
next-hop per destination in order to guarantee reliable and robust
communication under extreme stress conditions. System-level simulations based
on the IEEE802.11ad specifications demonstrate that the proposed routing
protocol provides a reliable end-to-end throughput performance, while
satisfying the latency requirements.","Due to the emerging applications and the need for higher capacity, current sub6 GHz wireless spectrum is not enough to cope with the recent demands for high data rate applications ranging from augmented/virtual reality to wireless HD video streaming. Millimeter wave (mmWave) bands – between 30 GHz to 300 GHz – have been contemplated as a solution to mitigate the existing spectrum scarcity in the sub6 GHz. How ever, enabling mmWave wireless systems in general requires properly dealing with the channel impairments and propaga tion characteristics of the high frequency bands. In particular, due to the high propagation losses, mmWave provides a limited range of communications. Also, high penetration, reﬂection and diffraction losses reduce the available diversity and limit nonlineofsight (NLOS) communications. Due to the small wavelength of mmWave, most objects in the propagation environment lead to blocking and reﬂection as opposed to scattering and diffraction as in the sub6 GHz bands. To experimentally investigate the effect of human blockage on mmWave links, we conducted a set of measurements in the 30 GHz band with a stationary transmitter and a mobile receiver that moves away from the transmitter with the speed of 1 m/s [1]. From the results shown in Fig. 1, we observe that during human blockage intervals (denoted by “HB”), the received signal strength falls to almost zero. This is consistent with the measurement results in [2] that suggest human body can increase the path loss by more than 20 dB. 0 100 200 300 400 500 600 700 800 900 1000 Time (ms)00.511.522.53Signal strength×104 LOS HBLOS HBLOS REFFig. 1: Received mmWave signal strength under line of sight (LOS), human blocker (HB), and reﬂection (REF) [1]. Currently, there is arguably an adequate understanding of physical layer issues and signal characterization [3, 4] as well as MAC layer designs for mmWave systems [5]. By contrast, the upper layers of the protocol stack are still largely unexplored and the existing protocols are not tailored for the mmWave bands. Multihop networking can be a viable solu tion to mitigate the issue of limited range of communications as well as the sensitivity to blockage. Notwithstanding the beneﬁts, multihop communication adds additional overhead by requiring exchange of metadata (e.g., route discovery messages), which is more challenging due to directional com munication in mmWave bands. In addition, it is not clear that multihop networking satisﬁes the latency requirements due to extra processing, queuing, and channel access latency at relay nodes. For instance, the IEEE 802.11ay usecase document speciﬁes the latency and jitter requirements of less than 5ms for 8K UHD wireless transfer at smart homes as well as for augmented reality/virtual reality headsets and other highend wearable devices [6]. In this paper, we investigate the performance of multi hop mmWave communication for indoor 60 GHz applications and demonstrate the beneﬁts of multihop routing protocols for blockageprone and rangelimited mmWave links. Due to the nature of usecases for indoor mmWave systems (e.g., realtime high data rate applications), a blocked link should quickly be detected and replaced by an alternative link. As such, we propose a hopbyhop multipath routing protocol that is efﬁcient and fast in switching to a reserved readyto use path towards the destination. We implement the proposed protocol on top of the 802.11ad PHY and MAC speciﬁcation, and investigate its performance under different scenarios.arXiv:2009.00205v2  [cs.NI]  3 Sep 2020II. R ELATED WORK "
270,Evaluating Wireless Reactive Routing Protocols with Linear Programming Model for Wireless Ad-hoc Networks.txt,"In Wireless Ad-hoc Networks, nodes are free to move randomly and organize
themselves arbitrarily, thus topology may change quickly and capriciously. In
Mobile Ad-hoc NETworks, specially Wireless Multi-hop Networks provide users
with facility of quick communication. In Wireless Multi-hop Networks, routing
protocols with energy efficient and delay reduction techniques are needed to
fulfill users demands. In this paper, we present Linear Programming models to
assess and enhance reactive routing protocols. To practically examine
constraints of respective Linear Programming models over reactive protocols, we
select AODV, DSR and DYMO. It is deduced from analytical simulations of Linear
Programming models in MATLAB that quick route repair reduces routing latency
and optimizations of retransmission attempts results efficient energy
utilization. To provide quick repair, we enhance AODV and DSR. To practically
examine the efficiency of enhanced protocols in different scenarios of Wireless
Multi-hop Networks, we conduct simulations using NS-2. From simulation results,
enhanced DSR and AODV achieve efficient output by optimizing routing latencies
and routing load in terms of retransmission attempts.","In Wireless Multi hop Networks (WMhNs), links frequently change due to wireless nature.  Routing protocols are used to provide accurate routes. The protocols are divided into two main  categories based on their routing operations to accurately discover and compute routes; reactive and  proactive. Protocols belong to the former category calculate and make available route(s) when data  demand arrives, whereas, the protocols in the later category calculate routes periodically and are independent from data demands.   In [1], authors evaluate AODV [2][3] and DSR [4][5] wit h respect to the varying number of  Constant Bit Rate (CBR) resources. The authors in [6], evaluate performance of DSR and AODV with varying number of sources (10 to 40 sources with different pause times). Problem from a different  perspective in [7], using a simulation model with a dynamic network size and is practically examined  for Destination Sequence Distance Vector (DSDV) [8], AODV, DSR and Temporally Ordered  Routing Algorithm (TORA)  [9].  In WMhNs, reactive protocols are responsible to find accurate rou tes and provide quick  repair after detecting route breakages. This work is devoted to study routing capabilities of three reactive protocols named as AODV, DSR and DYnamic MANET On demand (DYMO) [10] in  different network cases of WMhNs. The contribution of  this work includes: (i)  construction of  LP_model for WMhNs requirements and analytical simulations of the models for selected protocols, (ii) enhancements in AODV and DSR, (iii)  performance evaluation of the selected routing protocols  with respect to framework of network constraints (iv)  analytical analysis of mobility, traffic rates and  scalability properties of the selected routing protocols using NS 2. Javaid et al., 2013     II. RELATED WORK AND MOTIVAT ION   "
175,Evaluating Wireless Proactive Routing Protocols under Mobility and Scalability Constraints.txt,"Wireless Multi-hop Networks (WMhNs) provide users with the facility to
communicate while moving with whatever the node speed, the node density and the
number of traffic flows they want, without any unwanted delay and/or
disruption. This paper contributes Linear Programming models (LP_models) for
WMhNs. In WMhNs, different routing protocols are used to facilitate users
demand(s). To practically examine the constraints of respective LP_models over
different routing techniques, we select three proactive routing protocols;
Destination Sequence Distance Vector (DSDV), Fish-eye State Routing (FSR) and
Optimized Link State Routing (OLSR). These protocols are simulated in two
important scenarios regarding to user demands; mobilities and different network
flows. To evaluate the performance, we further relate the protocols strategy
effects on respective constraints in selected network scenarios.","  There are increasing interests in efficient routing in Wireless Multi hop Networks (WMhNs).  Due to self organizing and self configuring characteristics and absence of any infrastructural support  made WMhNs an intense prospect in armed forces, disaster recovery areas, commerce, education and  in many other appli cations. However, because of limited processing ability of nodes and constrained  energy, the design of routing strategy in WMhNs is a challenging issue. The states of links are changing frequently broken due to wireless nature. Therefore, efficient routing is a big challenge in  WMhNs.   Linear Programming is a mathematical technique which is used in computer modelling   (simulation) to find the best possible solution in allocating limited resources to achieve maximum profit or minimum cost. However, it is applicable only where all relationships are linear (see linear relationship), and can accommodate only a limited clas s of cost functions.   WMhNs need efficient routing protocols which deal with dynamic topology producing less  routing overhead. Many routing protocols have been proposed up till now. They are divided into two classes on the basis of their driven modes: table driven protocols and on demand driven protocols. In  former category protocols, route discovery is originated from the traditional routing protocol, in which routing information between nodes is exchanged periodically, and each node maintains recent topological information. However, to provide paths quickly, high costs of routing overhead in terms of control packets are required to construct the routing tables with incorporated routing information. The main principle behind on demand driven protocols is tha t the process of routing starts only when there  are data to be sent. Therefore, routes are discovered only when the data request  arrives.   In WMhNs, reactive protocols are responsible to find accurate routes and provide quick repair  after detecting link bre akages, whereas proactive protocols provide pre computed routes without any  delay of finding routes. This work is devoted to study the routing capabilities of three proactive protocols named as a Destination Sequence Distance Vector (DSDV) [1 ] [2], Fish eye State Routing Javaid et al., 2013     (FSR) [3][4] and Optimized Link State Routing (OLSR) [5][6] in different network cases of WMhNs.   This paper contributes LP_models for performance parameters to evaluate selected routing  protocols. We first list all the possible constraints of WMhNs for objective functions; throughput, cost  of energy and cost of time. We evaluate selected protocols against these constraints. Moreover, we  have also enhance default parameters of DSR and OLSR to achieve efficient performance. The contribution of  this work includes: (i) construction of LP_models for WMhNs (ii) performance  evaluation of selected protocols with respect to framework of network constraints, (iii) enhancement in DSR’s and OLSR’s default parameters, and (iv) analytical analysis of the m obility, traffic rates and  scalability properties of selected  routing protocols with 95% of confidence interval using NS 2.  II. RELATED WORK   "
83,Integrated Routing Protocol for Opportunistic Networks.txt,"In opportunistic networks the existence of a simultaneous path is not assumed
to transmit a message between a sender and a receiver. Information about the
context in which the users communicate is a key piece of knowledge to design
efficient routing protocols in opportunistic networks. But this kind of
information is not always available. When users are very isolated, context
information cannot be distributed, and cannot be used for taking efficient
routing decisions. In such cases, context oblivious based schemes are only way
to enable communication between users. As soon as users become more social,
context data spreads in the network, and context based routing becomes an
efficient solution. In this paper we design an integrated routing protocol that
is able to use context data as soon as it becomes available and falls back to
dissemination based routing when context information is not available. Then, we
provide a comparison between Epidemic and PROPHET, these are representative of
context oblivious and context aware routing protocols. Our results show that
integrated routing protocol is able to provide better result in term of message
delivery probability and message delay in both cases when context information
about users is available or not.","The opportunistic network is an extension of Mobile Ad  hoc Network (MANET). Wireless networks‟ properties, such  as disconnection of nodes, ne twork partitions, mobility of users  and links‟ instability, are seen as exceptions in traditional  network. This makes the design of MANET significantly more  difficult [1].   Opportunistic networks [2] are created out of mobile  devices carried by people, with out relying on any preexisting  network topology. Opportunistic networks consider  disconnections, mobility, partitions, etc. as norms instead of the  exceptions. In opportunistic network mobility is used as a  technique to provide communication between discon nected  „groups‟ of nodes, rather than a drawback to be solved .  In opportunistic networking a complete path between two  nodes wishing to communicate is unavailable  [3].  Opportunistic networking tries to solve this problem by  removing the assumption of physi cal end toend connectivity  and allows such nodes to exchange messages. By using the  storecarry andforward paradigm [4 ] intermediate nodes store messages when there is no forwarding opportunity towards the  destination, and exploit any future contact oppo rtunity with  other mobile devices to bring the messages closer and closer to  the destination .  Therefore routing is one of the most compelling challenges.  The design of efficient routing protocols for opportunistic  networks is generally a difficult task due  to the absence of  knowledge about the network topology. Routing performance  depends on knowledge about the expected topology of the  network [5 ]. Unfortunately, this kind of information is not  always available. Context information is a key piece of  knowled ge to design efficient routing protocols. Context  information represents users‟ working address and institution,  the probability of meeting with other users or visiting particular  places. It represents the current working environment and  behavior of users.  It is very help full to identify suitable  forwarders based on context information about the destination.  We can classify the main routing approaches proposed in the  literature based on the amount of context information of users  they exploit. Specifically,  we identify two classes,  corresponding to context oblivious and context aware  protocols .  Protocols in Context oblivious routing class as Epidemic  Routing Protocol [6 ] are only solution when context  information about users is not available. But they genera te high  overhead, network congestion and may suffer high contention.  Context based routing provides an effective congestion control  mechanism and with respect to context oblivious routing,  provides acceptable QoS with lo wer overhead. Indeed,  PRoPHET [7 ] is able to automatically learn the past  communication opportunities determined by user‟s movement  patterns and exploit them efficiently in future. This autonomic,  selflearning feature is completely absent in Context oblivious  routing schemes. But context ba sed routing protocols provide  high overhead, message delay and less success full message in  absence of context information about users. We have proved  this by implementing epidemic and PROPHET routing  protocols in presence and absence of context informatio n. We  found epidemic is better in absence of context information  while PROPHET gives better result in presence of context  information. Therefore I decided to combine feature of these  both protocols into a single integrated routing protocol, which  will perf orm better in both cases when context information  about user is available or not . (IJACSA) International Journal of Advanced Computer Science and Applications,   Vol. 2, No.3, March  2011   86 | P a g e   http://ijacsa.thesai.org/  This paper represents our integrated routing protocol, and  evaluates it through simulations. The rest of the paper is  organized as follows. Section 2 describes main routing  protocols of context oblivious and context based routing class  which are epidemic and PROPHET, and describe some related  work. In section 3 our proposed scheme is presented. In section  4 the simulation setup is given for routing protocols.  Comparison and Re sult of epidemic, PROPHET and integrated  routing protocols can be found in section 5. Finally section 6  discusses conclusion and looks into future work .   II. RELATED WORK   "
278,Treatment of Reactive Routing Protocols Using Second Chance Based On Malicious Behavior of Nodes in MANETS.txt,"Mobile nodes of various routing protocols in Mobile Ad hoc Networks follow
different strategies in transmission and receiving of data. Security, packet
delivery and routing overhead are important concerns for any protocol during
designing them. The presence and absence of malicious nodes in the network
affect a lot on the performance of the protocol. This research is mainly
focused on the study of the threats, attacks and reasons for malicious behavior
of nodes in the network for reactive routing protocols in MANETS. DSR and AODV
are the two reactive routing protocols that were considered for the study to
propose a second chance strategy to be given to the nodes considering the
reason for malicious behavior to improve the packet delivery ratio and reduce
the routing overhead in the network. A simulative study has been conducted
using Ad hoc Simulator (ASIM) considering the DSR and AODV routing protocols in
the presence of malicious nodes and in the absence of malicious nodes which
showed that the packet delivery ratio is low and routing overhead is high in
the absence of malicious nodes. The second chance strategy proposed considers
the reasons for malicious behavior and helps the node to get reintegrated in
the network to improve the packet delivery ratio and reduce the routing
overhead.","A set of mobile nodes that perform basic networking  functions in a infrastructure less environment is said be a  mobile ad hoc network (MANET). In the networ k each node  helps another node in forwarding or routing packets to the  destination.    Maintaining security is an important function of any of the  routing protocol in each phase of the networking function [1].  Because of the non static topological behavior o f the network  and due to being the network open which allows the nodes to  be added and deleted from the network anytime gives chance  for the intruder nodes to disturb the normal routing process.  And if there does not exist a common regulatory authority for  authenticating and guaranteeing the nodes then a reliable  transmission is not possible.      SECURITY RELATED GOALS AND CHALLENGES:   Security services are needed to make sure that the data is  transferred over the network with reliability and also the  keeping the resources of the system protected. To attain the  objectives, the categorizations of security services are:   availability, confidentiality, authentication, integrity and non  repudiation [2, 3].   • AVAILABILITY:   Though the system is suffering from  variou s problems like with bandwidth, connectivity but the  availability service ensures that still the resources are available  in a timely manner. Availability of a network can prove to  harmful for example when the packets are dropped and by  resource depletion a ttacks.   • CONFIDENTIALITY:  The information prevailing in  the network is not to be shared among all unauthorized nodes  and this is achieved by Confidentiality. In order to achieve  Confidentiality many encryption techniques can be used to  make only the autho rized nodes can share the transmission of  information and the private and public keys.    • AUTHENTICITY:   To prove a node as a legitimate user  the network service used is Authenticity. The absence of this  service can make any node in the network impersonate  any  node, and then having a total control capture and control over  the complete network.   • INTEGRITY:   The data which is been transmitted in the  network can be modified either wontedly or sometimes  unwontedly. The Integrity network service ensures that the  information which is been transmitted is not modified.   • NON REPUDIATION:   This service guarantees that the  message transmission has been done between the two parties and it cannot be denied. Also using this service it helps in  detecting and isolating of compromised nodes in the network.   Communicating through the network in safe and secure  way has been a challenging task because of    Not being a stable infrastructure.    The links in the network are prone to break and not  secure.    Scarcity or overload on the system resources    The network topology being dynamic.   A study of the various on demand routing protocols  in  MANETS has been done to analyze the threats and types of  attacks in the routing protocols along with the reasons for the  nodes to be malicious. The proposed approach will be used to  reintegrate the node back into network which were previously  as malici ous.  II. REVIEW OF LITERATURE   To have a secure transmission various  secure routing  protocols have been designed for MANETS [4, 5, 6, 7, 8]. The  features and functionality of  the routing protocols are studied  from [9].  Based on their type and the functions they perform,  the protocols are categorized as follows.   Ad hoc Routing Protocols   Category  Type  Name of protocol   Flat Routing  Proactive  OLSR   DSDV   WRP   Reactive  DSR   AODV   TORA   ABR   SSR  Hierarchical  Routing    HSR   CGSR   ZRP  LANMAR   Geographic  Position assisted  Routing    GEOCAST   LAR   DREAM   GPSR     A. Reactive Routing Protocols:   i. Dynamic Source Routing Protocol : The Dynamic Source Routing protocol a reactive routing  protocol has two phases namely route discovery and route  maintenance [10]. Initially the routes are discovered for  transmitting the packets between source node and the target  node. A route cache is mai ntained having the information of  the recently used routes. In the route maintenance phase it  ensures that the packet is safely transmitted to the target as  there is a chance of routes being broken due to the dynamic  nature of the topology. More over the r esearcher simulated the  protocol using NS 2 to focus on the performance of this  protocol using the metrics like packet delivery ratio in the  presence of malicious nodes and in the absence of the  malicious nodes. It was found that the packet delivery ratio in  the presence of malicious nodes is more than in absence of  malicious nodes.     ii. Ad hoc On Demand Distance Vector Protocol :  The AODV protocol explains its functionality [11]. It is  stated that the features of both DSR and DSDV are combined.  The author expla ins the working of AODV protocol along with  the Black hole attack and its effect on the protocol. Finally a  Counter Algorithm is proposed to prevent the Black hole attack  on make the AODV Protocol secure. Metrics like Packet  Delivery Ratio and Average End toEnd Delay was used to  measure the performance of the protocol. A method to identify  the malicious node was explained in order to avoid forwarding  of the information to the malicious node in the routing table.  The solution given did not impose any overhe ad on the nodes  in the network.     iii. Temporally Ordered Routing Algorithm:   The Temporally ordered Routing Algorithm works using  the link reversal concept and this algorithm ensures that it  results in no loops [12]. Th e functionality of this protocol  works in three phases as follows: (a) Phase – I creates the route  initially  (b) Phase – II concentrates on the maintenance of the  routes  and (c) Phase – III deletes the routes that are proved to  be invalid . TORA protocol was compared with other routing  protocols li ke DSDV, OLSR with the metrics like Control  Overhead, Packet Delivery Ratio, End to End Delay and  throughput that it is better in performance with varying number  of nodes using NS 2 simulator.      iv. Associativity Based Routing:   The Associativity Based Routing protocol does not have  loops, free of deadlock and no duplicate packets [13]. It  focuses on route longevity. As there are very few broken  communication links and less need for reconstruction of the  routes the overhead involved is less. An improved version of  ABR was to optimize the bandwidth and demand to reduce the  overhead based on the position information was proposed. It  was concluded that the path setup time was long for the routes  which gave a scope for the future research to improve the ABR  Protocol.     v.  Signal Stability based Adaptive Routing  Protocol:   The working of SSR routing protocol states that the large  routing tables are not required for routing [14]. The network  will not be congested with the control messages but a type of  denial of service at tack is a threat to this protocol. The Signal  Stability Table is maintained that has information of signal’s  strength of all nearby nodes. The protocol was simulated in  OmNet and a metric known as CPU usage was considered to  measure the performance. It pro ved that in the presence of  malicious node the usage of CPU was more than in the absence  of malicious nodes.   B. TYPES OF ATTACKS:   Attacks are broadly classified into two categories as Passive  attacks and Active attacks based on whether the operation in  the network is disturbed or not [15].   Passive attacks allow the unauthorized node to snoop the  data without altering it. The main target of the intruder node is  to steal any information that is being transmitted which in turn  makes the confidentiality to fail.  These types of attacks are  very difficult to detect but can be prevented by using powerful  encryption mechanisms.   Active attacks modify or even delete the data which is  being transmitted through the network. The affect of these  types of attacks is that it  brings down the performance of the  network. The following is a brief description of various active  attacks.   Sybil Attack:  In this type of attack the intruder node  pretends to have multiple identities and modifies and alters the  information by directly com municating with the legitimate  nodes [16].   Resource Consumption Attack:  A malicious node in this  attack always consumes the system resources like the  bandwidth, battery power, memory, access points etc. A form  of replication of packets makes the nodes to c onsume  bandwidth and also the battery power.   Black Hole attack:  The intruder node in this attack  announces that to reach any other node, it has t he nearest path  in the network. When ever the intruder node receives a request  to reach the destination, this no de replies saying that it has the  shortest route. If this reply message reaches to the node which  initiated the request earlier than the actual node then the route  is established and hence the intruder node has found the place  between two actual communicat ing nodes causing denial of  service behaving as man in the middle.   Worm Hole attack:  The attacker in the worm hole attack  broadcasts to the other nodes as a neighbor after hearing  transmission of packet from some node. The malicious node  now forwards the p acket to another location creating a worm  hole. These types of attacks prove to be very dangerous [17].     III. METHODOLOGY   "
337,"Nation-State Routing: Censorship, Wiretapping, and BGP.txt","The treatment of Internet traffic is increasingly affected by national
policies that require the ISPs in a country to adopt common protocols or
practices. Examples include government enforced censorship, wiretapping, and
protocol deployment mandates for IPv6 and DNSSEC. If an entire nation's worth
of ISPs apply common policies to Internet traffic, the global implications
could be significant. For instance, how many countries rely on China or Great
Britain (known traffic censors) to transit their traffic? These kinds of
questions are surprisingly difficult to answer, as they require combining
information collected at the prefix, Autonomous System, and country level, and
grappling with incomplete knowledge about the AS-level topology and routing
policies. In this paper we develop the first framework for country-level
routing analysis, which allows us to answer questions about the influence of
each country on the flow of international traffic. Our results show that some
countries known for their national policies, such as Iran and China, have
relatively little effect on interdomain routing, while three countries (the
United States, Great Britain, and Germany) are central to international
reachability, and their policies thus have huge potential impact.","Internet routing is typically studied at the Autonomous System (AS) level. This is by design. Traditionally, ASes control their own internal networks and set their own policies for the routing, ltering, and monitoring of trac, placing policy in the hands of the organiza tions that own them. Recently, groups of ASes have begun to act under common policies, issued by their country's government. Examples include Internet cen sorship [1], wiretapping [2], and protocoldeployment mandates [3, 4]. For instance, Chinese, British, and Pakistani ISPs are required (or strongly encouraged) to lter content deemed socially oensive. Although cen soring techniques dier, all three countries are known to block trac at the IP level (e.g., by ltering based on IP addresses and URLs in the data packets, or perform ing internal prex hijacks [5, 6, 7]), which could aect the international trac they transit. Some countries,such as the United States and Sweden, wiretap interna tional trac, where even encrypted trac is vulnerable to tracanalysis attacks [8]. Finally, governments can attempt to force the deployment of protocols, such as the deployment of IPv6 and DNSSEC in federal agen cies of the United States. It is unclear what eect any particular country's poli cies have on the rest of the Internet. Typically, censor ship is applied to prevent domestic users from reach ing disagreeable content. However, some censorship techniques (such as ltering based on IP addresses or URLs) may aect all trac traversing an AS. In ad dition, ASes might intentionally, or accidentally as in the recent YouTube outage [6], apply censorship poli cies to international trac. How many networks outside of the country would be prevented from viewing Web pages simply because their trac traverses one of these networks? Which international trac is vulnerable to warrantless wiretapping by the United States or Swe den? And, nally, how feasible is it to avoid directing trac through a given country with objectionable poli cies by using alternative routes? To answer these questions, we must study the ag gregate eect of national policies on the  ow of inter national trac, rather than analyzing individual ASes in isolation. In this paper we take initial steps toward understanding interdomain routing at the nationstate level. We are particularly interested in understanding the in uence that each country's ASes have over reach ability between other countries. The resulting data and measurement techniques could be useful to many com munities. First, those regions of the world with strong dependencies on particular countries could use our re sult to guide changes in how they connect to the rest of the Internet. Second, overlay networks (such as Re silient Overlay Networks [9]) could use our results to de termine how best to circumvent specic countries, help ing to ensure that data are delivered intact, and avoid snooping. Third, our results would be helpful to policy makers to understand what impact their decisions could have on the global Internet. There are two primary challenges in this work. The 1arXiv:0903.3218v1  [cs.NI]  18 Mar 2009rst is to dene suitable metrics for quantifying the importance, or centrality, of each country to Internet reachability. The second is to accurately infer the data needed to compute these metrics, and validate them. We adapt the betweenness centrality metric from statis tical physics as a rst approximation of country central ity. Betweenness centrality is typically used as a naive trac estimator at each node in a graph. We adapt be tweenness centrality to estimate the impact each coun try has on reachability between other countries, dening country centrality (CC) in Section 4. Our metrics take as input the countrylevel paths be tween each pair of IP addresses in the Internet. This is a signicant challenge because of the many levels of in ference required to produce a countrylevel interdomain path. First, ASes select routes using the Border Gate way Protocol (BGP) [10], which chooses routes based on undisclosed routing policies, rather than simply us ing the shortest path. Fortunately, this is a wellstudied problem and several inference algorithms exist for infer ring ASlevel routes. A second challenge arises because an individual AS may span many countries. This leads us to consider routing at the IP prex level, which re quires understanding how packets traverse each AS. Fi nally, each path must be converted to a countrylevel path by mapping IP addresses to prexes, and then prexes to countries (e.g., using routing registry data). There is a risk of introducing signicant, and possibly compounding, error in each step of the process. How ever, we present empirical evidence to suggest that our centrality metric is robust to the measurement noise, and that our results are meaningful. Our inference techniques allow us to estimate the cen trality of each country, where CC values range from 0 (implying no in uence) to 1 (the theoretical maximum). Our results show that countries known for censorship, such as Great Britain, China, Australia, and Iran, have CC values of 0.29, 0.07, 0.07, and 1.12e05 respectively. These results suggest that, of the countries that censor Internet trac, only some have signicant impact on global routing. In particular, the countries that have received the most publicity for their censorship, such as China, have signicantly less impact on international trac than, say, Great Britain, which also censors traf c. We also show that the United States and Sweden (nations known to permit warrantless wiretapping) have CC values of 0.74 and 0.02; even if ASes actively prefer BGP routes that avoid the United States, the CC value only drops from 0.74 to 0.55. With national policies on the rise, we believe that researchers, ISPs, and policy makers will soon need to understand the impact that these policies can have on other countries, networks, and even individual IP pre xes. Our major contribution is the development of a framework for studying interdomain routing at the Figure 1: Example AS topology with AS paths. Paths 1 and 2 both route between the same pair of ASes (A and B), but their AS paths are dif ferent, depending on the destination prex. The same AS path can also have distinct country level paths, for example paths 1 and 3. nationstate level. This includes identifying and ad dressing the many challenges of inferring the country level paths, developing network centrality metrics ap propriate for the problem, validating the methods, and reporting initial results. The paper is organized as follows. In the next sec tion we brie y discuss the Internet's topology and the correct granularity for measuring country paths. In Sec tion 3 we design, implement, and validate the Country Path Algorithm (CPA) for inferring countrypaths from a pair of source and destination IP addresses. The algo rithm has several stages, as it must rst infer the inter domain path, and then intradomain paths, and nally determine the country path. Next, Section 4 reviews betweenness centrality and presents two extensions for measuring a country's in uence over global reachability. These metrics take as input the global measurements produced by the CPA. In Section 5, we apply our infer ence techniques to sample data sets of traceroutes and AS paths, as well as inferred paths between all known IP prexes. This helps validate that our metrics are robust to inference error. We also present initial results characterizing the data produced by the CPA. Next, we discuss future work and other possible challenges in country level analysis in Section 6, we review related work in Section 7, and nally conclude in Section 8. 2. AN APPROPRIATE GRANULARITY FOR ANALYZING COUNTRYLEVEL PATHS The Internet is currently comprised of roughly 30,000 Autonomous Systems, which are typically independently operated, multihomed networks. Each AS is allocated IP address space, which is a contiguous blocks of IP ad 2dresses called IP prexes. The interdomain routing pro tocol that allows ASes to reach one another's prexes is called the Border Gateway Protocol (BGP). BGP is a policy based protocol that selects and propagates AS paths according to local policies (e.g., economic rela tionships), rather than path performance (e.g., short est path routing). Example policies include customer provider in which the customer pays the provider for transit, and peerpeer in which the participating ASes transit each other's customer trac to their own cus tomers. Lixin Gao showed that these policies can aect routing propagation [11]. For instance, most customers would not be willing to provide transit from one of their providers to another. Gao observed that ASes typically follow the valleyfree rule, which states that routes re ceived from a provider or peer should only be propa gated to customers. For our experiments it is necessary to inference all of the countrypaths between each pair of IP addresses. Since IP addresses are allocated to ASes, we could de termine the countrypaths between each pair of ASes and use that information to determine all paths between each pair of IP addresses. One immediate problem is that some ASes span more than a single country. A sec ond issue is that in many cases there are multiple paths between two ASes, depending on where trac enters the AS and on the destination prex in question. For example, in Figure 1 AS A uses path 1 to reach prex 1 at AS B, but uses path 2 to reach prex 2 at the same destination AS. AS B might split its trac like this to balance its trac load between two providers (ASes C and E). A second possible approach would cluster together the prexes with the same AS paths between AS pairs, and infer a path for one prex from each cluster. This is known as a BGP Atom [12, 13]. Although this approach can enumerate the best ASpaths between AS pairs, it does not encompass the full diversity of countrylevel paths. Two destination prexes with the same AS path may have dierent underlying country level paths. For instance, in Figure 1 AS paths 1 and 3 are the same, however they terminate in dierent coun tries (United States in path 1 Australia in path 3). After ruling out the rst two approaches, we resorted to inferring the countrylevel paths between each pair of IP prexes, the nest level of measurement available. There are over 290,000 prexes in today's routers, re sulting in over 84 billion country paths that need to be inferred and analyzed. We also study all of the available alternate paths that exist from one prex to another, re sulting in more than 465 billion country path inferences that need to be performed. The large number of in ferences places signicant constraints on the inference algorithm's complexity. For instance, simply running Dijkstra's shortest path algorithm to determine the intraceroute =C1z}|{ ipsrc;ip2;ip3;C2z}|{ ip4;ip5;ip6;C3z}|{ ipdst traceroute =ipsrc;ip2|{z} AS1;ip3;ip4;ip5;|{z} AS2ip6;ipdst|{z} AS3 Countrypath Inference Algorithm: (ipsrc;ipdst)!(AS1;AS 2;AS 3)!(C1;C2;C3) Figure 2: Traceroutes, ASpaths, and country paths. A traceroute is the list of IP addresses of the routers that a packet traverses from ipsrc toipdst. Each router belongs to an AS, and each router is in a country C. The Country Path Al gorithm takes a source and destination IP ad dress as input, infers the interdomain ASpath between the two addresses, and then infers the countrypath between them. tradomain path of each AS in each path is too slow. 3. THE COUNTRY PATH ALGORITHM The metrics described in Section 4 analyze country level paths to determine which countries can potentially interfere with the communication of others. In this sec tion we present the Country Path Algorithm (CPA) for inferring the countrylevel paths between any two IP addresses. There are two steps to the procedure. The rst infers the interdomain path between the ad dresses, and the second step predicts the countrypath from the ASpath. We use a slightly modied version of Qiu et al.'s [14] ASpath heuristic for the rst step which is described in 3.1, and introduce the rst country path predictor in the second step, presented in 3.3. An overview of the CPA algorithm is shown in Figure 2. The ASpath to countrypath heuristic requires infor mation about known traceroutes and their correspond ing ASpaths and countrypaths as input. We show how to infer these paths from a traceroute in Subsection 3.2. 3.1 Preﬁx Pair to ASpath The rst step in the country path algorithm is to map prex source/destination pairs to their appropriate AS paths. Of the recent ASpath inference methods [14, 15, 16, 17], only Qiu's provides prexlevel predictions and is fast enough for our needs. 3.1.1 A Modiﬁed Version of Qiu’s Heuristic Qiu's heuristic simulates the propagation of BGP routes across an AS topology, as if each AS had a single router. The propagation model is a simplied model of the ac tual BGP protocol. In it, each router selects its best path to the destination prex after receiving a route 31: KnownPath(p, G, prePaths): 2:while queue.length >0do 3: u POP(queue,0) 4: for all v2peers(u) do 5: Pu ribIn(u)[p][0] 6: iflegitimatePath((v)+ Pu)then 7: tmppath  ribIn(v)[p][0] 8: update ribIn(v)[p]  with (v) + Pu 9: sort(ribIn(v)[p]) 10: iftmppath = path(v)[p][0] and v 2queue then 11: append(queue,v) 12:return ribIn Figure 3: Pseudocode of Qiu's inference algo rithm. Line 6 was modied to propagate paths to predetermined ASes. 1: ComparePath( P1= (u; v1; :::); P2= (u; v2; :::)): 2:ifP1.ulen6=P2.ulen then 3: return P1.ulen  P2.ulen 4:ifjP1j6=jP2jthen 5: returnjP1j"
105,A Spectrum Aware Mobility Pattern Based Routing Protocol for CR-VANETs.txt,"Cognitive radio technology offers an important function in the efficient
utilization of the radio spectrum. Besides, it is expected that CR-enabled
vehicular ad-hoc networks (CR-VANETs) enrich the communication performance of
the existing vehicular networks (VANETs). However, to ensure efficient
performance in a multi-hop communication, the routing protocol in CR-VANETs
needs to consider the autonomous mobility of the vehicles as well as the
stochastic availability of the channels. Hence, this paper introduces a
spectrum-aware mobility pattern based reactive routing protocol for CR-VANET.
The proposed protocol accommodates the dynamic behavior and selects a stable
transmission path from a source node to the destination. Therefore, the
proposed protocol is outlined as a weighted graph problem where the weight for
an edge is measured based on a parameter termed as NHDF (Next-hop Determination
Factor). The NHDF implicitly considers mobility patterns of the nodes and
channel availability to select the optimum path for communication. Therefore,
in the proposed routing protocol, the mobility pattern of a node is defined
from the viewpoint of distance, speed, direction, and node's reliability.
Furthermore, the spectrum awareness in the proposed protocol is measured over
the number of shared common channels and the channel quality. It is anticipated
that the proposed protocol shows efficient routing performance by selecting
stable and secured paths from source to destination. Simulation is carried out
to assess the performance of the protocol where it is witnessed that the
proposed routing protocol outperforms existing ones.","With the speedy advancement of wireless technologies, endless applications are expected to be deployed in every sphere of modern life. However, the radio spectrum scarcity becomes one of the major concerns with the amplifying demand in wireless applications. In such a situation, cogni tive radio technology plays a major part by utilizing the radio spectrum efﬁciently [1]. Coined by J. Mitola III, Cognitive Radio Network (CRN) is an intelligent wireless system that gathers information of the radio environment and controls i ts operational parameters i.e., transmission power, modulat ion strategy, etc. accordingly [2]. Primary User (PU) and Sec ondary User (SU) are two types of users involved in the CR system, where the PUs are the licensed users and SUs are the unlicensed users. Hence, in CRN, SU has to use the spectrum opportunistically without interrupting the P U’s communication. On the other hand, the growing number of wheels on the road has outlined the necessity for the Intelligent Tran sportation System (ITS) to avoid the collision, monitor traf  ﬁc, ensure road safety, etc. Consequently, vehicular adho c network (V ANET) has appeared to be the technology for these emerging vehicular applications by ensuring Vehicle to Vehicle (V2V) communication. In, the vehicular nodes are equipped with onboard units for sensing, transmitting and receiving messages [3]. This onboard arrangement in the vehicle provides appropriate decisions to avoid any distur bance or mishaps based on various information such as trafﬁc statu s, vehicles’ speed, etc. Moreover, it is anticipated that the C R enabled vehicular network shows enriched communication efﬁciency than existing vehicular networks (V ANETs). Besides, in CRV ANET, the performance of the network highly depends on the underlying routing protocols. Moreov er, similar to any other CRN, one of the important aspects of routing in CRV ANET is to utilize spectrum efﬁciently for vehicular communication. Furthermore, due to the dynamic vehicular movements and the changing availability of the ra dio channels, routing in CRV ANETs is quite challenging. Con sequently, communication researchers are showing profoun d interest over the last few years on the routing protocols for CRV ANETs. Hence, due to the dynamic altering topology, a reliable and efﬁcient route selection for multihop commun i cation still remains an open research issue. This paper presents a routing protocol for CRV ANET that is deﬁned as a weighted graph problem. Distance, speed, direction, link quality, and reliability are considered as param eters for route selection in the proposed reactive protocol to enable faster and reliable data communication. The propose d routing protocol introduces a parameter called NHDF (Next hop Determination Factor) to select a routing path. Here, NHDF value is associated with the number of common idle channels and transmitting weight value ( ξT). Hence, by calculating distance through RSSI (Received Signal Strength Indicator), the source node can estimate the location of the neighbor closest to forwarding the data to the destination. Vehicular speed and direction are measured for improving th e performance during high mobility as the location of the node s may vary, so this may cause link failure and packet drop. In this case, by calculating speed and angle, the neighborin g nodes location can be predicted in the future and the packet is transmitted to the next neighbor. In the proposed routing protocol, link quality has been deﬁned from the viewpoint of delay where three types of delays are proposed namely backoff, switching and queuing delay for estimating linkweight which ensures route stability with a minimum link failure. A Reliable route selection mechanism is also propo sed for detecting a selﬁsh node or any external threads so that the neighboring nodes can trust received messages during the exchange of data. Route maintenance is also described in the proposed routing protocol when multiple routes are discovered during route selection or any link failure occur s during data transmission. To evaluate the performance of th e proposed protocol, simulation results are compared with ot her protocols in terms of throughput, packet delivery ratio, an d communication delay. The rest of the article is organized as follows. Section II depicts a brief discussion on existing routing protocols in CR V ANET and highlights their strengths and limitations based on the routing metrics. A network model for the proposed protocol is discussed in section III and Section IV explains the proposed routing protocol. Next, simulation results an d performance analyses of the proposed protocol are discusse d in section V. Finally, the paper ends with the conclusion and future work in section VI. II. RELATED WORK "
450,Energy aware routing scheme for mobile ad hoc network using variable range transmission.txt,"This paper discusses a new energy aware routing scheme which uses variable
transmission range. The protocol has been incorporated along with the route
discovery procedure of AODV as a case study. Both the protocols are simulated
using Network Simulator and comparisons are made to analyze their performance
based on energy consumption, network lifetime and number of alive nodes metrics
for different network scenarios. The results show that EAR makes effective node
energy utilization.","A Mobile Ad hoc  Network (MANET) is a network formed without any cent ral administration. It  consists of nodes that use a wireless interface to send & receive packet data. These nodes in the  network are mobile and can serve as routers and hos ts, thus can forward packets on behalf of  other nodes and run user applications. This allows people and devices to seamlessly inter network in areas with no preexisting communication  infrastructure. Significant examples of  MANET include establishing survivable dynamic commu nications for emergency/rescue  operations, disaster relief efforts, military netwo rks, business indoor application, home  intelligence devices [1].    Developing routing protocols for MANETs has been a challenging task because of its dynamic  topology, bandwidth constrained wireless links and resource (energy) constrained nodes. Many  proactive and reactive protocols have been proposed  which try to satisfy various properties, like:                                                    1 Pinki Nayak is also a research scholar at Banasthal i University, Banasthali, Rajasthan, India  International Journal of Ad hoc, Sensor & Ubiquitou s Computing (IJASUC) Vol.3, No.4, August 2012   54         efficient utilization of bandwidth, battery capacit y, fast route convergence, optimization of  metrics (like throughput and endtoend delay), and  freedom from loops.  This paper tries to address the problem of energy e fficient routing to increase the lifetime of the  network. Mobile hosts, today are powered by battery , therefore efficient utilization of battery  energy becomes very important. The energy resources  of actively participating nodes get  depleted faster than other nodes, which in some cas es, may lead to partitioning of the network,  thus decreasing the lifetime of the network. For th is reason, reducing the energy consumption is  an important issue in ad hoc wireless networks [2].  The three major ways of increasing the life  of a node are efficient battery management, transmi ssion power management and system power  management. In this paper, a scheme has been propos ed to minimize the energy consumption at  the nodes, thus maximizing the network lifetime. Tr ansmission power control approach is used  to adjust the power levels at node. Common power le vels are used during Route Discovery.  New power levels are calculated between every pair of nodes based on distance.  The rest of the paper is organized as follows.  Sec tion 2 presents a discussion on the related  work in energy aware routing protocols. Section 3 g ives a brief description of the existing  routing protocols.  In section 4, the detailed work ing of the proposed EAR is discussed. Section  5 includes the simulation environment setup used in  NS2 simulator. The simulation results are  explained in section 6. Finally, section 7 gives co nclusions.  2.  RELATED WORK   "
281,"CAIR: Using Formal Languages to Study Routing, Leaking, and Interception in BGP.txt","The Internet routing protocol BGP expresses topological reachability and
policy-based decisions simultaneously in path vectors. A complete view on the
Internet backbone routing is given by the collection of all valid routes, which
is infeasible to obtain due to information hiding of BGP, the lack of
omnipresent collection points, and data complexity. Commonly, graph-based data
models are used to represent the Internet topology from a given set of BGP
routing tables but fall short of explaining policy contexts. As a consequence,
routing anomalies such as route leaks and interception attacks cannot be
explained with graphs.
  In this paper, we use formal languages to represent the global routing system
in a rigorous model. Our CAIR framework translates BGP announcements into a
finite route language that allows for the incremental construction of minimal
route automata. CAIR preserves route diversity, is highly efficient, and
well-suited to monitor BGP path changes in real-time. We formally derive
implementable search patterns for route leaks and interception attacks. In
contrast to the state-of-the-art, we can detect these incidents. In practical
experiments, we analyze public BGP data over the last seven years.","Measuring, modeling, and analyzing the routing be tween Autonomous Systems (ASes) have gained increas ing importance over the last decade [17,44,58], as the Internet infrastructure has become business critical and investigations of cyber security incidents intensied. To day the question of route integrity is prevalent in dayto day operations and a clear understanding of how data should  ow is urgently desired to quickly detect anoma lies. However, modeling Internet routing is still a major challenge due to the complex decision making in the Internet backbone. This work contributes a rigorous approach to route modeling and analysis.The Internet interdomain routing system selects those paths from the topologically possible paths that are economically feasible and comply to individual policies. Path vectors in BGP represent the outcome of this hybrid decision process without revealing its underlying rules explicitly. As such, BGP eectively hides most of its operational semantics from observers and successfully withstands the quest for a simple explanatory model [50]. The collection of all locally valid paths is essentially what we can learn at any given observation point. These paths are represented by our Constructible Automata for Internet Routes (CAIR) . CAIR oers two key advantages over existing solutions: a)By preserving policyrelated information in its rout ing model, CAIR can reliably detect interception attacks or route leaks as they violate policies. b)CAIR is an ecient yet complete representation of the observable interdomain routing, which opens up the eld for new analyses|even in realtime. Interprovider connections are traditionally modeled as a graph [44]. BGP peerings that show up in AS paths are considered valid links between nodes (ASes). Network graphs adequately represent connectivity in terms of router links or AS peerings. For the analysis of policyin uenced routing, though, such graphs tend to oversimplify the real situation. Realistic routing paths are selected on a perprex basis and often in uenced by local routing policies. In particular, network graphs falsely imply transitivity over individual links and thus introduce additional, potentially nonexistent (sub)paths. Therefore, graph models cannot diagnose policy viola tions such as route leaking or complex anomalies such as interception attacks. In this paper, we solve the fundamental transitivity problem in graphs ( x2) for Internet routes. We remain with the concept of (contextdependent) path vectors and introduce a nite route language (x3) to model BGP data. Starting from an alphabet of AS numbers and 1arXiv:1605.00618v1  [cs.NI]  2 May 2016prexes, we formally construct a complete description of the observable routing system. With corresponding route automata (x4), we show how to put this con cept into practical use. Using incrementally minimized nitestate automata ( x6), we arrive at a most ecient representation of the path vector space, which outper forms network graphs. Route automata are policyaware: They represent the full characteristics of the observable routing policies and, at the same time, reduce complex ity to realtime compliant processing. With CAIR, we can further derive formal detection patterns for route anomalies and apply these to real BGP data. In our analysis of realworld incidents ( x5), we focus on two intricate anomalies. First, we search for intercep tion attacks, in which an adversary falsely attracts trac while maintaining a backhaul path to its victim to re lay eavesdropped packets. Second, we study (ab)normal routing changes and gain insight into customer ASes that erroneously advertise transit in a socalled route leak . We validate our approach with wellknown incidents and identify 22 so far unknown cases of interception. 2. BACKGROUND AND INTUITION We approach CAIR by describing a gap we currently face in network modeling and analysis in connection with common graph models. We then illustrate with some background why a model based on formal languages and automata can actually close this gap. For detailed background on formal languages we refer to [31]. 2.1 Motivating Example: Interception Attacks Interception attacks are characterized by a subtle in jection of illegitimate prex routes to redirect trac destined for a victim to the attacker. To search for such events we need patterns and data models. A cru cial factor is to sustain global connectivity by relaying all communication back to the victim. Implementing such an attack in the Internet is feasible and has been demonstrated in practice [12, 30, 46]. A malicious AS needs to be connected to the Internet via at least two upstream ISPs. The rst ISP is used to attract trac by advertising the victim's address space or a part thereof, also called a hijacking attack . The second ISP serves to preserve a stable backhaul path from the attacker to the victim. To implement the backhaul path, the attacker includes all ASes between himself and his victim in the malicious BGP announcement. As a consequence, all of these ASes discard the announcement due to loop prevention, and a stable link from the attacker to the victim's AS remains intact. Figure 1 illustrates the corresponding change in trac forwarding. Our key observation to derive a search pattern for interception attacks is that an arbitrary ISP Tnormally redistributes allroutes of a distant ASValong the same ways [2, 22] (Figure 1a). From a BGP policy point of V U T S AInternet P/22(a) Regular trac  ow P/24 P/24V U T S AInternet P/22 (b) Interception Figure 1: Attacker Aintercepts subprex P=24. view, however, the attack induces a specic policy for the redirected prex. In our example, Sforwards trac to V via the malicious AS Aonly for the prex under attack, but reaches all other prexes of the victim directly via T (Figure 1b). It is worth mentioning that the attacker can easily hide his own identity by not adding his AS number to the AS_PATH attribute of forged BGP messages, as it is common practice with route servers [34], for instance. To diagnose the dierence, data models are needed to express route diversity. Unfortunately, common graph models lack this capability. 2.2 The Need for CAIR Consider a routing table extract that includes routes to three IP prexes P1"
235,Secure IoT Routing: Selective Forwarding Attacks and Trust-based Defenses in RPL Network.txt,"IPv6 Routing Protocol for Low Power and Lossy Networks (RPL) is an essential
routing protocol to enable communications for IoT networks with low power
devices. RPL uses an objective function and routing constraints to find an
optimized routing path for each node in the network. However, recent research
has shown that topological attacks, such as selective forwarding attacks, pose
great challenges to the secure routing of IoT networks. Many conventional
secure routing solutions, on the other hand, are computationally heavy to be
directly applied in resource-constrained IoT networks. There is an urgent need
to develop lightweight secure routing solutions for IoT networks. In this
paper, we first design and implement a series of advanced selective forwarding
attacks from the attack perspective, which can flexibly select the type and
percentage of forwarding packets in an energy efficient way, and even bad-mouth
other innocent nodes in the network. Experiment results show that the proposed
attacks can maximize the attack consequences (i.e. number of dropped packets)
while maintaining undetected. Moreover, we propose a lightweight trust-based
defense solution to detect and eliminate malicious selective forwarding nodes
from the network. The results show that the proposed defense solution can
achieve high detection accuracy with very limited extra energy usage (i.e.
3.4%).","With the rapid adoption of Internet of Things (IoT) devices around the world [1], many of these devices are resource constrained [2]. Since the existing Internet Protocols (IP ) are too complex to be directly implemented on resource constrained IoT devices [3], the Internet Engineering Task Force (IETF) designs a lightweight IPv6 protocol with a seri es of core protocols to ensure efﬁcient and secure communica tions, such as IPv6 over Lowpower Wireless Personal Area Networks (6LoWPAN) [4] and Routing Protocol for Low Power and Lossy Networks (RPL) [5]. In particular, RPL, as the core routing protocol for resource constrained IoT networks, has been adopted by a variety of applications, suc h as healthcare [6], smart grid [7], and smart city [8], etc. Due to its popularity, RPL becomes an attractive attack tar get [9]. One attack that can cause massive damage to the RPL network is selective forwarding attack [10], where attacke rs interrupt network data ﬂows by selectively dropping networ k packets. Compared to blackhole attacks which simply drop all packets, selective forwarding attacks are more decepti ve †: Corresponding authorand can remain undetected for a longer time, causing long term damage to the network. Despite their impact, existing selective forwarding attacks are still lack of ﬂexibility in terms of dynamically identifying victim nodes and adjusting pack et forward rates according to the state of the network. On the other hand, there are three major types of defense mechanisms against selective forwarding attacks on RPL. The ﬁrst type is to build a multipath routing network to ensure the integrity of information transmission [11]. The se mechanisms often require excessive resources to maintain the backup paths for nodes. The second type is distributed defen se mechanisms, which deploy a monitor module on individual nodes [12]. However, these defense mechanisms often lead to signiﬁcant extra energy consumption at the monitoring nodes. In addition, it is challenging to ensure that all the monitor ing nodes are longterm reliable and honest in reporting their neighbors’ behaviors. The third type is the centralized def ense mechanisms [13], where a central node is employed to monitor and analyze malicious behaviors in the network. Neverthele ss, the central node has to be deployed at a core location in the network to ensure coverage across the entire network, and may be easily misled by complex badmouthing attacks . In this work, we aim to advance current studies from both the attack and defense perspectives. Speciﬁcally, from the attack aspect, we propose an advanced selective forwarding attack model, which can dynamically launch three types of malicious behaviors: (1) ﬂexibly dropping packets from se lected types of protocols, (2) adjusting the packet forward rate based on the average network packet forward rate to stay stealthy, and (3) dynamically selecting speciﬁc children n odes for badmouthing attacks. Furthermore, these attack behav iors can be combined to signiﬁcantly increase the damages to the network and reduce the risk of being detected by stateofth e art defense mechanisms. Furthermore, from the defense aspect, we propose a novel centralized trustbased defense mechanism to combat selec tive forwarding attacks in RPL networks. Compared to distribute d defense mechanisms, the proposed scheme can signiﬁcantly save the energy consumption for anomaly detection by de ploying the defense computation only at the root node. Unlik e other centralized defense schemes, the proposed scheme tak es advantage of RPL’s treebased network topology to evaluate the trustworthiness of nodes and avoids the introduction of a trusted thirdparty node. Furthermore, by carefully desig ning the detection/notiﬁcation module, the proposed scheme can2 effectively balance the tradeoff between detection delay and energy consumption. The main contributions of this paper are as follows. •This work proposes an advanced selective forwarding attack with three types of behaviors against RPL network. Malicious nodes in the proposed attack model cannot only ﬂexibly choose the type of packets to drop, but also control the packet forward rates dynamically. As a result, these attackers are able to launch more stealthy attacks to avoid being detected. Furthermore, malicious nodes can also badmouth other normal nodes to cause false alarms in the system. The experiment results show that it can effectively evade RPL selfdefense mechanism and state oftheart defense mechanisms. •This work proposes a novel centralized trustbased de fense mechanism. In particular, the proposed trust model integrates a selftrust value, which reﬂects a node’s trustworthiness in its packet forwarding behavior, and a treebased descendant trust value, which takes ad vantage of the RPL network topology to prevent bad mouthing attacks. Furthermore, the proposed defense mechanism is deployed on the root node, which can effectively reduce the total energy consumption caused by distributed anomaly monitoring scheme, and eliminate the security risks caused by the introduction of third party devices. Experiment results show that the proposed scheme achieves high detection accuracy and low energy consumption. •This work proposes a novel anomaly report mechanism. Instead of using UDP packets, ICMPv6 control message is chosen to send information about malicious nodes. The reporting mechanism only starts when root node detects the malicious behaviors in the network. This reporting mechanism cannot only ensure that nodes in the network can be notiﬁed promptly, but also avoid causing information broadcast storms. The rest of this paper is organized as follows. Section II discusses existing selective forwarding attacks and defen se mechanisms in RPL networks. Section III introduces pre liminaries of the RPL protocol. Section IV and V discuss the proposed selective forwarding attack and the defense mechanism in details. The results of the experiment are give n in Section VI, followed by a conclusion in Section VII. II. RELATED WORK "
385,Game theoretic path selection to support security in device-to-device communications.txt,"Device-to-Device (D2D) communication is expected to be a key feature
supported by 5G networks, especially due to the proliferation of Mobile Edge
Computing (MEC), which has a prominent role in reducing network stress by
shifting computational tasks from the Internet to the mobile edge. Apart from
being part of MEC, D2D can extend cellular coverage allowing users to
communicate directly when telecommunication infrastructure is highly congested
or absent. This significant departure from the typical cellular paradigm
imposes the need for decentralised network routing protocols. Moreover,
enhanced capabilities of mobile devices and D2D networking will likely result
in proliferation of new malware types and epidemics. Although the literature is
rich in terms of D2D routing protocols that enhance quality-of-service and
energy consumption, they provide only basic security support, e.g., in the form
of encryption. Routing decisions can, however, contribute to collaborative
detection of mobile malware by leveraging different kinds of anti-malware
software installed on mobile devices. Benefiting from the cooperative nature of
D2D communications, devices can rely on each other's contributions to detect
malware. The impact of our work is geared towards having more malware-free D2D
networks. To achieve this, we designed and implemented a novel routing protocol
for D2D communications that optimises routing decisions for explicitly
improving malware detection. The protocol identifies optimal network paths, in
terms of malware mitigation and energy spent for malware detection, based on a
game theoretic model. Diverse capabilities of network devices running different
types of anti-malware software and their potential for inspecting messages
relayed towards an intended destination device are leveraged using game
theoretic tools. An optimality analysis of both Nash and Stackelberg security
games is undertaken, including both zero and non-zero sum variants, and the
Defender's equilibrium strategies. By undertaking network simulations,
theoretical results obtained are illustrated through randomly generated network
scenarios showing how our protocol outperforms conventional routing protocols,
in terms of expected payoff, which consists of: security damage in inflicted by
malware and malware detection cost.","Demand for anytimeanywhere wireless broadband connectivity and increas ingly stringent Quality of Service (QoS) requirements pose new research chal lenges. As mobile devices are capable of communicating in both cellular (e.g. 4G) and unlicensed (e.g. IEEE 802.11) spectrum, the DevicetoDevice (D2D) net working paradigm has the potential to bring several immediate gains. Network ing based on D2D communication [1, 2, 3, 4, 5] not only facilitates wireless and mobile peertopeer services, but also provides energy ecient communications, locally ooading computation, ooading connectivity, and high throughput. The most emerging feature of D2D is the establishment and use of multihop paths to enable communications among nonneighbouring devices. In multihop D2D com munications, data are delivered from a source to a destination via intermediate (i.e. relaying) devices, independently of operators' networks. 1.1. Motivation To motivate the D2D communication paradigm, we emphasise the need for localised applications . These run in a collaborative manner by groups of devices at a location where telecommunications infrastructures: (i) are not present at all, e.g. underground stations, airplanes, cruise ships, parts of a motorway, and mountains; (ii) have collapsed due to physical damage to the base stations or insucient available power, e.g. areas aected by a disaster such as earthquake; or (iii) are over congested due to an extremely crowded network, e.g. for events in stadiums, and public celebrations. Furthermore, relay by device can be lever aged for commercial purposes such as advertisements and voucher distributions for instance in large shopping centres. This is considered a more ecient way of promoting businesses than other traditional methods such as email broadcast ing and SMS messaging due to the immediate identication of the clients in a 2surrounding area. Home automation and building security are another two areas that multihop data delivery using D2D communications is likely to overtake our daily life in the near future while multihop D2D could be also leveraged towards the provision of anonymity against cellular operators [6]. A key question related to multihop D2D networks is, which route should the originator of some data choose to send it to an intended destination? . This has been exhaustively investigated in the literature of wireless and mobile ad hoc routing with wellknown protocol to be among others AODV [7], DSR [8], and OLSR [9]. A thorough survey of standardisation eorts in this eld has been published by Ramrekha et al. [10]. Due to the myriad number of areas D2D communications are applicable to, devices are likely to be an ideal target for attackers who aim to infect devices with malware. Authors in [11] point out that malware in current smartphones and tablets have recently rocketed and established its presence through advanced techniques that bypass security mechanisms of devices. Malware can spread, for instance, through a Multimedia Messaging System (MMS) with infected attach ments, or an infected message received via Bluetooth aiming at stealing users' per sonal data or credit stored in the device. An example of a wellknown worm that propagates through Bluetooth was Cabir, which consists of a message containing an application le called caribe.sis . Apart from malware infection, Khuzani et al. [12] have investigated outbreaks of malware (i.e. malware epidemics) mainly by adopting the notion of D2D communication. Finally, social engineering at tacks against mobile phones is one of the most serious threats, as presented in a relevant survey here [13]. For thorough surveys on mobile malware one may refer to [11, 14]. 1.2. Innovation In a nutshell,this paper presents a novel routing protocol, for D2D commu nications, that supports malware detection in an optimal way by using non cooperative game theoretic tools, which have been extensively used in the secu rity literature (e.g. [15]) and in D2D routing (e.g. [16]). Game theory has also been used for other than routing purposes [17], [18, 19] in D2D networks. In this paper we only focus on security games and we tackle a decisionmaking routing challenge, in D2D networks, in presence of an adversary who injects malware into the network, after she has compromised a gateway that connects the D2D network with the cloud. This assumption is fairly realistic given the vast power attackers have in their hands these days to successfully exploit vulnerabilities of modern gateways. Our underlying network has been inspired by the Mobile Edge Computing (MEC) (also refer to as Fog Computing) paradigm as a step towards addressing security within the realm of an increasingly important area of 5G. 3Our protocol, called iRouting (abbreviating \intelligent Routing""), is de signed upon the theoretical analysis of a simple yet illuminating twoplayer se curity game between the Defender , which abstracts a D2D network, and the Attacker , which abstracts any adversarial entity that wishes to inject malware into the D2D network. We have proven that the Defender's equilibrium strategies leave the network better o, in terms of expected payo , which is a combination ofsecurity damage and malware detection cost (i.e. cycles process units). Note thatiRouting can work on top of underlying physical and MAC layer protocols [20, 21]. It is worth noting that this paper does not tackle secure routing issues in traditional ways. For a survey of secure routing protocols for wireless ad hoc networks, see [22, 23]. Such protocols mainly aim at enabling condentiality, and integrity of the communicated data and they do not consider underlying collaborative malware detection. 1.3. Progress beyond relevant work This paper extends, in a signicant manner, the results initially presented in [24]. The exact dierences are summarized below. [24] assumes a pure devicetodevice network while in this paper the device todevice network has been enriched with a part of mobile edge comput ing. The network devices request services from the MEC server and multi hopping enables communication between the MEC server and the dierent devices to overcome proximity issues due to the latter being outside the transmission range of the server. In this paper, the security challenge is how to safely utilise MEC services where a clusterhead (i.e. MEC server) might be compromised by an adversary. Although this does not introduce any new challenge in terms of malware detection and routing, it is an as sumption that places the idea of the paper within mobile edge computing and 5G architectures. This paper assumes dierent mobile operating systems and these can be infected with dierent types of malware as opposed to [24], which goes as far as considering just a set of malicious messages that are sent from the attacker's device to infect the legitimate devices. This also has the eect of dening, in this paper, the Malware Detection Game whereas in [24], the dened game is called Secure Message Delivery Game. In [24], a confusion matrix is dened to determine how the dierent devices of the network can detect malicious messages. In this paper here we take a more realistic, in the terms of cyber security, approach where for each device there is a probability to be compromised by malware. Therefore, 4each route has, in turn, a penetration level, which is the probability the route to be compromised due to one or more devices on it being vulnerable. In [24], the details about the interdependencies of malicious message de tectors is not discussed, while in our paper here we explicitly say that each control detects dierent signs of malware and no interdependencies , in terms of detection capabilities, are assumed, i.e. we have assumed that an antimalware control is the minimal piece of software that detects certain malicious signs. In [24], the Attacker is not assumed to monitor the network before launching a malware attack (no reconnaissance) while in our paper here the Attacker surveils the network before injecting malware giving us a Stackelberg game to study. In [24], only Nash Equilibria (NE) and maximin strategies have been stud ied. On the other hand, our paper here derives Strong Stackelberg Equi libria (SSE) and shows the relationship among three of them; SSE, NE and maximin. Not only that, but this paper exhibits much larger depth of mathematical analysis referring also to best responses of players. Finally, it proves the equality of strategies of dierent games, such zerosum and nonzero sum across all strategic types (Nash, Stackelberg, maximin). Although Panaousis et al. [24] has investigated both zero sum and nonzero sum games, where in the latter the utility of the Attacker is a positive ane transformation (PAT) of the defender's utility, in this paper we go beyond that. We show the equality of the dierent strategies holds in a more generic (i.e. than the PAT case) payo structure where the Attackers utility is a strictly positive scaling of the Defender's utility. All simulations in [24] were numeric; as well as they do not compare the performance of the proposed routing protocol with other devicetodevice routing protocols. For the purposes of our paper here we have undertaking a network simulation to compare the proposed protocol with legacy routing protocols using the OMNeT++ network simulator. In this way we have simulated physical and linklayer network characteristics. In our paper here, we have considered, in our simulations, the ecacies of some of the mostrecent realworld antimalware controls against realworld malware types as opposed to the purely numeric assignment to the dierent variables. In our simulations here, we have included a new Attacker type, called Weighted, which allows the adversary to distribute her resources propor 5tionally, over the dierent routes, aiming at the highest expected dam age. This type of Attacker was not simulated in [24]. 1.4. Main assumptions Our analysis assumes that each device has some malware detection capabili ties (e.g. antimalware software). Therefore, a device is able to detect malicious applicationlevel events. In other words, each device has its own detection rate which contributes towards the overall detection rate of the routes that this de vice is part of. In order to increase malware detection, the route with the highest detection capabilities must be selected to relay the message to the destination. However, due to the dierent malware types available to attackers, these days, such a decision is not trivial. One could argue that if we know the probability of a malware type to be chosen, we can develop a proportional routing strategy, which will distribute security risks across the dierent routes by choosing routes in a proportional, to their malware detection capabilities, manner. Since this knowledge can not be taken for granted in addition to the volatile nature of such statistics, in this paper we use game theory to optimise routing decisions to support malware detection in D2D networks, regardless of the probability of the dierent malware to be used by the Attacker. 1.5. Outline The remainder of this paper is organised as follows: In Section 2, we review related work with more emphasis to be given in papers at the intersection of game theory, security, and routing for wireless ad hoc networks (i.e. prominent example of D2D networking). In Section 3, we present the system and game models, while in Section 4, we devise game solutions. In Section 5, we undertake optimality analysis which leads to a list of theoretic contributions. Section 6 describes, in detail, the iRouting protocol, and in Section 7, we compare iRouting against other routing protocols. Finally, Section 8 provides concluding remarks and points towards future research. 2. Related work "
388,StableMoE: Stable Routing Strategy for Mixture of Experts.txt,"The Mixture-of-Experts (MoE) technique can scale up the model size of
Transformers with an affordable computational overhead. We point out that
existing learning-to-route MoE methods suffer from the routing fluctuation
issue, i.e., the target expert of the same input may change along with
training, but only one expert will be activated for the input during inference.
The routing fluctuation tends to harm sample efficiency because the same input
updates different experts but only one is finally used. In this paper, we
propose StableMoE with two training stages to address the routing fluctuation
problem. In the first training stage, we learn a balanced and cohesive routing
strategy and distill it into a lightweight router decoupled from the backbone
model. In the second training stage, we utilize the distilled router to
determine the token-to-expert assignment and freeze it for a stable routing
strategy. We validate our method on language modeling and multilingual machine
translation. The results show that StableMoE outperforms existing MoE methods
in terms of both convergence speed and performance.","In recent years, largescale Transformers (Devlin et al., 2019; Dong et al., 2019; Raffel et al., 2020; Clark et al., 2020; Bao et al., 2020; Brown et al., 2020) have shown a striking ability to model lan guages. However, with the model scale grow ing, the training speed will go slower, and the extremely large memory requirement also intro duces a heavy burden of engineering. Mixture of Experts (MoE) (Jacobs et al., 1991; Jordan and Ja cobs, 1994; Shazeer et al., 2017), in a much easier way, enables Transformers to scale up the number of parameters meanwhile introducing an affordable Contribution during internship at Microsoft Research.computational overhead. MoEbased Transform ers have a set of expert modules, and only a few experts will be activated for each input token. In this way, we can expand the model scale by adding expert modules, which will keep the computational and memory overhead within a tolerable range. Most existing MoE methods (Lepikhin et al., 2021; Fedus et al., 2021; Lewis et al., 2021) decide the tokentoexpert routing according to the dynam ically changing token representations. However, we point out that they face the routing ﬂuctuation problem. As shown in Figure 1, the same input may be assigned to different experts along with training. However, during inference, only one expert will be activated for the input. The routing ﬂuctuation problem tends to harm sample efﬁciency because the same input updates different experts while only one is ﬁnally used. Taking BASE Layer (Lewis et al., 2021) as an example, during the whole training process, we examine the tokentoexpert assignment for tokens in the validation set. For an input token, we deﬁne the last ﬂuctuation step as the last step where its target expert is different from the ﬁnal step. We plot the cumulative token percentage with regard to the last ﬂuctuation step (annotated as its percentage accounting for all training steps) in Figure 2. We ﬁnd that the last ﬂuctuation step of 40.9% tokens exceeds 20%, which means 40.9% tokens do not have a stable target expert when 20% of all training steps have been done. Furthermore, 29.1% tokens still change their target experts after half of the whole training process, and 15.4% tokens even change the target expert after 80% of all training steps, which is nearing the training ending. These statistics prove that the routing ﬂuctuation problem indeed exists in previous MoE methods. In this paper, we propose STABLE MOEwith two training stages to address the routing ﬂuctua tion problem. In the ﬁrst training stage, we follow the learningtoroute paradigm and aim to learn aarXiv:2204.08396v1  [cs.LG]  18 Apr 2022Training Epochs Expert 3Inference 𝑒1 𝑒2 𝑒3 … … Transformer BlocksTransformer Blocks The car  isExpert 2 Expert 1 Expert 3 Transformer BlocksTransformer Blocks Expert 2 Expert 1 Expert 3 Transformer BlocksTransformer Blocks Expert 2 Expert 1 Transformer BlocksTransformer Blocks Expert 2 Expert 1 Expert 3 The  car is The  car  is The  car isFigure 1: Illustration of the routing ﬂuctuation problem. The same input is assigned to different experts along with training. However, during inference, only one expert is sparsely activated for the input. The routing ﬂuctuation tends to harm sample efﬁciency because the same input updates different experts while only one is used. 0% 20% 40% 60% 80% 100% Last Fluctuation Step0%20%40%60%80%100%Cumulative Token Percentage(20%, 40.9%) (50%, 29.1%) (80%, 15.4%) Figure 2: Cumulative token percentage with re gard to the last ﬂuctuation step of tokens for BASE Layer (Lewis et al., 2021). A substantial portion of to kens still change their target experts even if the training is nearing the end. balanced and cohesive routing strategy. We design a balance loss to guarantee the assignment is bal anced. In addition, inspired by Lewis et al. (2021), we adopt a sigmoid gating mechanism, which en ables the task objective to propagate supervised sig nal back to the routing strategy, to facilitate learn ing a more cohesive assignment. As the routing strategy is being learned, we synchronously dis till it into a lightweight router decoupled from the backbone model. In the second training stage, we utilize the distilled router to determine the token toexpert assignment. The distilled router is frozen in this stage to provide a stable routing strategy, which addresses the routing ﬂuctuation problem in the remaining training. We conduct experiments on language modeling and multilingual machine trans lation. The results show that STABLE MOEout performs existing MoE methods in terms of both convergence speed and performance. Our contributions are summarized as follows:(1) We point out the routing ﬂuctuation problem in existing learningtoroute MoE methods. (2) We propose STABLE MOEto address the routing ﬂuctuation problem. (3) We conduct substantial ex periments under various settings to show the advan tages of STABLE MOEover existing MoE methods. 2 Background: MixtureofExperts for Transformers We ﬁrst introduce the MoE mechanism designed for Transformers (Vaswani et al., 2017). Given a standardLlayer Transformer model and an input sequenceXcontainingTtokens, the Transformer outputHLis calculated by HL= [hL 1;hL 2;:::;hL T]; (1) hl t= FFN ul t +ul t; (2) ul 1:T= selfatt hl"
288,Efficient Algorithms to Enhance Recovery Schema in Link State Protocols.txt,"With the increasing demands for real-time applications traffic in net- works
such as video and voice a high convergence time for the existing routing
protocols when failure occurred is required. These applications can be very
sensitive to packet loss when link/node goes down. In this paper, we propose
two algorithms schemas for the link state protocol to reroute the traffic in
two states; first, pre-calculated an alternative and disjoint path with the
primary one from the source to the destination by re-routing traffic through
it, regardless of the locations of failure and the number of failed links.
Second, rerouting the traffic via an alternative path from a node whose local
link is down without the need to wait until the source node knows about the
failure. This is achieved by creating a new backup routing table based on the
original routing table which is computed by the dijkstra algorithm. The goal of
these algorithms is to reduce loss of packets, end-to-end delay time, improve
throughput and avoiding local loop when nodes re-converge the topology in case
of failure.","  Internet Protocol (IP) can use various types of rou ting protocols, such as, Link State (LS) and  Distance Vector Routing Protocols (DSDV). The LS Pr otocol has been successful over the past  few years, because it provides networks with numero us optimization techniques which lead to  fast convergence enhancements. In case of failure, the LS protocol needs to reupdate the  routing table to divert the failure affected traffi c along another path around the failure to  destination which takes seconds. In real time appli cations such as VOIP, the fast rerouting  mechanism is considered one of the most important s olutions for alleviating congestion, as well as  reducing delay and the packet loss in the network w hen routers start to reconverge the topology  after the topology has been changed due the link/no de failure. The recovery mechanism comes  with appropriate solutions to avoid local loop in t he network between nodes by finding an  alternative backup path for delivering packets to t heir destination. By precomputing an  alternative  backup  path,  traffic  can  pass  thr ough  it  in case any link on the primary path fail s  without  having to wait for updating of the routing  table. The main purpose of the IP fast reroute  mechanism  is  to  address the slow convergence tim e networks when failure occurs in the network.  Currently,  the  convergence  time  is  100’s  of  a millisecond or even 10’s of seconds in the Border  International Journal of UbiComp (IJU), Vol.2, No.3 , July 2011  54  Getaway   Protocol   (BGP)  network,  which  is  un satisfactory  [9].  Each node associated with a  failure  needs  to recompute a new shortest path, update the routing table via the routing  protocol and then propagate these updates for all n odes associated with the malfunction. In  addition,  the recovery mechanism has to address th e period spent upon the problem with respect  to the  time  required to detect the failure and co mpute the new shortest path. The Open Shortest  Path  First (OSPF) routing protocol is used as a dy namic link state protocol for TCP/IP or UDP  traffic  and  is  designed to update topological in formation by sending a Link State Advertisement  (LSA) based on the presence of a failure. Table 1 i llustrates the default and minimum times for  the routing protocol to recompute a new shortest p ath.    Timer  Default   Value  Minimum  Value   Notification  timer  2s  10ms   Link  state  Pac ket  (LSP)   generation  timer  50ms  1ms   Shortest  path  computation  timer  5.5s  1ms   Processing  phase  Typical   values  Processing  phase  Typical  values   LSP  processing  10ms/hop   SPF  computation  100   400  ms   For warding  information  update  20  entries  / ms     Table 1: COMPONENTS OF THE FAILURE RESTORATION TIME  [11]    Microloops can occur between nodes, however, which  do not receive notification when a failure  occurs. The effect of this can lead to increasing t he utilization of the links, which may exceed the  link capacity. In case of failure, the source will keep sending packets until it receives a  notification that a failure has occurred. In this p aper, we pro pose and describe two new  algorithms that can create a backup routing table w ith a loop back free in the network. The first  algorithm is called an Alternative Routing Table Fu ll Path (ARTFP), which reroutes the traffic  from source to its destination through an alternati ve disjoint path to the primary one. This backup  path contains a backup nexthops not connected with  any node on the primary path. The second  algorithm is called an Alternative Routing Table Co nnected Path (ARTCP), which reroutes the  traffic from the node where it is connected directl y to the failure on the primary path, and it can  reroute the traffic through the backup routing tabl e to the destination. We have concentrated on  the original routing table, which is constructed by  the LS protocol to create the backup routing  table in order to find all possible alternative rou tes to the destination excluding all primary routes   between source and destination for each node on the  topology.    This paper is organized as follows: Section 2 discu sses the related work for ART algorithms.  Section 3 explains the mechanism of the algorithms.  Section 4 introduces the basic concept for  the ARTCP and ARTFP algorithms in details. Section 5 explains the result and section 6  concludes how ART algorithms can be improved and th e direction of any future work.    2.  RELATED WORK   "
264,"A Comprehensive Performance Analysis of Proactive, Reactive and Hybrid MANETs Routing Protocols.txt","A mobile Ad-hoc network (MANET) is a dynamic multi hop wireless network
established by a group of nodes in which there is no central administration.
Due to mobility of nodes and dynamic network topology, the routing is one of
the most important challenges in ad-hoc networks. Several routing algorithms
for MANETs have been proposed by the researchers which have been classified
into various categories, however, the most prominent categories are proactive,
reactive and hybrid. The performance comparison of routing protocols for MANETs
has been presented by other researcher also, however, none of these works
considers proactive, reactive and hybrid protocols together. In this paper, the
performance of proactive (DSDV), reactive (DSR and AODV) and hybrid (ZRP)
routing protocols has been compared. The performance differentials are analyzed
on the basis of throughput, average delay, routing overhead and number of
packets dropped with a variation of number of nodes, pause time and mobility.","  Mobile Adhoc Networks (MANETs) are self configuring  networks consisting of mobile nodes that are  communicating through wireless links. There is a cooperative engagement of a collection of mobile nodes  without the required  intervention of any centralized access  point or existing infrastructure. The nodes move  arbitrarily; therefore, th e network may experience  unpredictable topology change s. It means that a formed  network can be deformed on the fly due to mobility of nodes. Hence, it is said that an adhoc wireless network is  self organizing and adaptive. Due to infrastructure less and  self organizing nature of ad hoc networks, it has several  applications in the area of commercial sector for emergency rescue operations and disaster relief efforts. MANETs also provides a solution in the field of military  battlefield to detect movement of enemies as well as for  information exchange among military headquarters and so  on [1]. Also, MANET provides an enhancement to cellular  based mobile network infrastructure. Nowadays, it is an  inexpensive alternative for data exchange among cooperative mobile nodes [2].  For communication among two nodes, one node has to  check that the receiving node is with in the transmission range of source (Range of a node is defined with the  assumption that mobile hosts uses wireless RF transceivers  as their network interface), if yes, then they can communicate directly otherwise, with the help of intermediate nodes communication will take place. Each node will act as a host as we ll as a router. All the nodes  should be cooperative so th at exchange of information  would be successful. This cooperation process is called as routing [3, 4].   Due to the presence of mobility, the routing  information will have to be changed to reflect changes in link connectivity. There are several possible paths from  source to destination. The routing protocols find a route  from source to destination and deliver the packet to correct destination. The performance of MANETs is related to  efficiency of the MANETs routing protocols [5] and the  efficiency depends on several factors like convergence  time after topology changes, bandwidth overhead to enable  proper routing, power consumption and capability to handle error rates.   The figure 1 shows the prominent way of  classifying MANETs routing protocols. The protocols may be categorized into two type s, Proactive and Reactive.  Other category of MANET routing protocols which is a combination of both proactiv e and reactive is referred as  Hybrid.            Figure 1 Classification of MANET routing protocols  Proactive routing protocols: In it, all the nodes  continuously search for routing information with in a  network, so that when a route is needed, the route is  already known. If any node wants to send any information to another node, path is known, therefore, latency is low.  However, when there is a lot of node movement then the  cost of maintaining all topology information is very high [6].    Reactive Routing protocols:  Whenever there is a need of  a path from any source to destination then a type of query  reply dialog does the work [7, 8].Therefore, the latency is  high; however, no unnecessary control messages are  required.  IJCSI International Journal of Computer Science Issues, Vol. 8, Issue 6, No 3, November 2011  ISSN (Online): 16940814  www.IJCSI.org   433   Hybrid routing protocols:  These protocols incorporates  the merits of proactive as well as reactive routing protocols. A hybrid routing protocol should use a mixture  of both proactive and reactiv e approaches. Hence, in the  recent years, several hybrid r outing protocols are proposed  like ZRP, ZHLS, SHARP and NAMP etc [7, 9].  In recent years, a variet y of routing protocols  have been proposed and a comp arative analysis of routing  protocols has been done either on the basis of simulation results by different simulators like OPNET, NS2, OMNET++ etc. or analytically . In some cases, the  comparative analysis is done between reactive routing  protocols based on some performance metrics and in other  cases between proactive routing protocols. Few  researchers have done the simulation based comparison between on demand   and table driven routing protocols.  The present paper comparatively analyzes all three  categories of MANETs routing protocols namely, proactive, reactive and hybrid protocols. In order to  compare the protocols, we selected the representative  protocols from each category; DSDV from proactive, ZRP  from hybrid, and AODV and DSR from the reactive. The performance metrics considered are throughput , average  delay , routing overhead and number of packets dropped .  The performance differentials are analyzed by varying number of nodes, pause time and mobility using NS2 simulator.   The rest of the paper is organized as follows. The related  work has been discussed in section 2. Section 3 provides a brief summary about these protocols. In the section 4, the  simulation environment, performance metrics used and  results have been discussed. Section 5 concludes the present exposition.     2. Related Work  "
119,On Data-centric Forwarding in Mobile Ad-hoc Networks: Baseline Design and Simulation Analysis.txt,"IP networking deals with end-to-end communication where the network layer
routing protocols maintain the reachability from one address to another.
However, challenging environments, such as mobile ad-hoc networks or MANETs,
lead to frequent path failures and changes between the sender and receiver,
incurring higher packet loss. The obligatory route setup and maintenance of a
device-to-device stable path in MANETs incur significant data retrieval delay
and transmission overhead. Such overhead exaggerates the packet loss manifold.
  Named Data Networking (NDN) can avoid such delays and overhead and
significantly improve the overall network performance. It does so with direct
application-controlled named-data retrieval from any node in a network instead
of reaching a specific IP address with protocol message exchange. However,
existing works lack any explicit or systematic analysis to justify such claims.
Our work analyzes the core NDN and IP architectures in a MANET at a baseline
level. The extensive simulations show that NDN, when applied correctly, yields
much lower data retrieval latency than IP and can lower the network
transmission overhead in most cases. As a result, NDN's stateful forwarder can
significantly increase the retrieval rate, offering a better trade-off at the
network layer. Such performance comes from its caching, built-in multicast, and
request aggregation without requiring an IP-like separate routing control
plane.","The use of broadcastbased selflearning in an IPbased network is a reasonably common technique, broadcasting the ﬁrst packet and waiting for a response. The returning response packet allows the network to learn a path between a senderreceiver pair for future packet exchange. However, unlike in a wired network, wireless mobile adhoc networks (MANET) present signiﬁcant communication challenges. Not only do they have issues like wireless channel contention and interference, but they also suffer from frequent link breakage due to mobility. As a result, [1] proposed the AODV routing protocol for MANETs, designed on top of the broadcastbased selflearning philosophy. It was also a reactive routing pro tocol that minimizes the frequent routing message exchange in proactive routing protocols (e.g., OLSR [2]). Although proactive protocols exchange these messages to compute and maintain forwarding paths, they cause signiﬁcant collision and contention in the wireless channel. AODV reduces the proactive routing overhead by only sending control messages when there is trafﬁc to transmit. However, path discovery and maintenance still lead to addedlatency before actual data exchange can occur. Thus, latency also plays a crucial role in the overall MANET performance because wireless links can break between path discovery and data exchange. Higher latency and transmission overhead from discovery and maintenance lead to higher packet loss. While there has been lots of research in this area, most of the proposed solutions are still built on top of the traditional IP architecture, which requires the discovery and maintenance of a working path between the sending and receiving hosts. Maintaining such working paths is inherently challenging in a MANET environment. Named Data Networking (NDN) [3] is an emerging Internet architecture that moves away from IP’s addressbased pointto point communication model to a datacentric communication model. NDN packets do not carry any address; instead, they carry the name of the content that consumer nodes want to retrieve. A consumer sends an Interest (i.e., a request packet) to the network, and the network returns a Data (i.e., a response packet) whose name matches what was requested by the Interest. Data can come from any node in the network, including data producers and caches. NDN’s broadcastbased selflearning can be a better ﬁt for MANET than IP because (1) data discovery and link breakage detection can be achieved us ing the Interest/Data exchange without extra control messages to reduce collision, contention, and most importantly, retrieval latency; (2) since data can be cached and retrieved from any node, the Interest does not have to reach the original producer; thus, the impact of link/path breakage can be signiﬁcantly mitigated; (3) multicast is achieved in NDN without any extra mechanism, which is a tremendous advantage since multicast in IP MANET is still a challenging problem. The selflearning forwarding by [4] is also a broadcast based discovery technique employing NDN as the underlying architecture. Their work shows how NDN can be deployed in a wired local network and suggests a promising MANET design. There have also been some research proposing NDN based MANET routing and forwarding protocols [5]–[8]. However, the impact of the architecture on MANET forward ing performance has not been systematically investigated nor fully understood. In this paper, we conducted comprehensive simulations to compare the packet delivery performance of NDN and IP in a MANET at the network layer and bridge the gap between promises andsimulated results for NDN in MANET. We use AODV [1] in IP and our proposed DataarXiv:2105.07584v1  [cs.NI]  17 May 2021centric Adhoc Forwarding (DAF) in NDN as the network layer protocol for routing/forwarding. These two protocols use similar mechanisms to discover paths or contents, and we do not apply any optimization techniques beyond the basic protocol. Therefore our results provide a baseline comparison between NDN and IP, reveal their architectural differences, and point to further optimizations. Our simulations show DAF outperforming AODV in this aspect, especially under mobility. The main reason is that DAF does away with routing protocol by relying on Interest/Data exchange to discover data and detect failures. It signiﬁcantly reduces the latency and, in most cases, the transmission overhead as well, which are two of the most challenging factors in an IPbased MANET routing. As a result, DAF vastly improves the data retrieval success rate by properly utilizing NDN as its underlying architecture. The beneﬁts of NDN are even more prominent for manytoone and manyto many communication due to its builtin caching and multicast. The evaluation of NDN and IP’s performance in the MANET environment illustrates their architectural differences. It demonstrates that NDN’s datacentric design is a better ﬁt for MANET, where maintaining paths between two moving nodes is inherently challenging and sometimes unnecessary. With a new underlying architecture, many potential techniques can be considered to optimize NDNbased MANET perfor mance in the future. II. R ELATED WORKS "
45,A Program Logic for Verifying Secure Routing Protocols.txt,"The Internet, as it stands today, is highly vulnerable to attacks. However,
little has been done to understand and verify the formal security guarantees of
proposed secure inter-domain routing protocols, such as Secure BGP (S-BGP). In
this paper, we develop a sound program logic for SANDLog-a declarative
specification language for secure routing protocols for verifying properties of
these protocols. We prove invariant properties of SANDLog programs that run in
an adversarial environment. As a step towards automated verification, we
implement a verification condition generator (VCGen) to automatically extract
proof obligations. VCGen is integrated into a compiler for SANDLog that can
generate executable protocol implementations; and thus, both verification and
empirical evaluation of secure routing protocols can be carried out in this
unified framework. To validate our framework, we encoded several proposed
secure routing mechanisms in SANDLog, verified variants of path authenticity
properties by manually discharging the generated verification conditions in
Coq, and generated executable code based on SANDLog specification and ran the
code in simulation.","In recent years, we have witnessed an explosion of services provided over the Internet. These services are increasingly transferring customers' private information over the network and used in missioncritical tasks. Central to ensuring the reliability and security of these services is a secure and ecient Internet routing infrastructure. Unfortunately, the Internet infrastructure, as it stands today, is highly vulnerable to attacks. The Internet runs the Border Gateway Protocol (BGP), where routers are grouped into Autonomous Systems (AS) administrated by Internet Service Providers ( ISPs). Individual ASes exchange route advertisements with neighboring ASes using the pathvector protocol. Each originating AS 2012 ACM CCS: [Theory of computation ]: Logic|Logic and verication; [ Security and privacy ]: Network security|Security protocols. Key words and phrases: Declarative networking; Program logic; Routing protocols. LOGICAL METHODSl IN COMPUTER SCIENCE DOI:10.2168/LMCS11(4:19)2015c  C. Chen, L. Jia, H. Xu, C. Luo, W. Zhou, and B. T. Loo CC  Creative Commons2 C. CHEN, L. JIA, H. XU, C. LUO, W. ZHOU, AND B. T. LOO SANDlog(Program(Annota/ons(SANDlog(Compiler(Code((genera/on(Veriﬁca/on(condi/on(genera/on(Executable(protocol(Proof(obliga/ons(Theorem(prover(Simulator((Emulator)( The round objects are code (proofs), which are the input or output of the framework. The rectan gular objects are software components of the frame work. Figure 1: Architecture of a unied framework for implementing and verifying secure routing protocols. rst sends a route advertisement (containing a single AS number) for the IP prexes it owns. Whenever an AS receives a route advertisement, it adds itself to the AS path, and advertises the best route to its neighbors based on its routing policies. Since these route advertisements are not authenticated, ASes can advertise nonexistent routes or claim to own IP prexes that they do not. These faults may lead to long periods of interruption of the Internet; best epitomized by recent highprole attacks [ 10,25]. In response to these vulnerabilities, several new Internet routing architectures and protocols for a more secure Internet have been proposed. These range from security extensions of BGP (SecureBGP (SBGP) [ 19], psBGP [ 31], soBGP [ 32]), to \cleanslate"" Internet architectural redesigns such as SCION [ 33] and ICING [ 23]. However, none of the proposals formally analyzed their security properties. These protocols are implemented from scratch, evaluated primarily experimentally, and their security properties shown via informal reasoning. Existing protocol analysis tools [ 7,12,14] are rarely used in analyzing routing protocols because they are considerably more complicated than cryptographic protocols: they often compute local states, are recursive, and their security properties need to be shown to hold on arbitrary network topologies. As the number of models is innite, modelcheckingbased tools, in general, cannot be used to prove the protocol secure. To overcome the above limitations, we explore a novel proof methodology to verify these protocols. We augment prior work on declarative networking (NDLog) [ 21] with cryptographic libraries to provide compact encoding of secure routing protocols. We call our language SANDLog (stands for Secure and Authenticated Network DataLog ). We develop a program logic for reasoning about SANDLog programs that execute in an adversarial environment. The properties proved on a SANDLog program hold even when the program interact with potentially malicious programs in the network. Based on the program logic, we implement a verication condition generator (VCGen), which takes as inputs the SANDLog program and userprovided annotations, and outputs intermediary proof obligations as a Coq le, where proof can be lled. VCGen is integrated into the SANDLog compiler, an cryptographyaugmented extension to the declarative net working engine RapidNet [ 27]. The compiler is able to translate our SANDLog specication into executable code, which is amenable to implementation and evaluation. We choose to use a declarative language as our specication language for two reasons. First, it has been shown that declarative languages such as NDLog can specify a variety of network protocols concisely [ 21]. Second, SANDLog is the specication language for both verication and generating lowlevel implementations. As a result, verication and empirical evaluation of secure routing protocols can be carried out in a unied framework (Figure 1). We summarize our technical contributions:A PROGRAM LOGIC FOR VERIFYING SECURE ROUTING PROTOCOLS 3 (1)We dene a program logic for verifying SANDLog programs in the presence of adversaries (Section 3). We prove that our logic is sound. (2)We implement VCGen for automatically generating proof obligations and integrate VCGen into a compiler for SANDLog (Section 4). (3)We encode SBGP and SCION in SANDLog, verify path authenticity properties of these protocols, and run them in simulation (Section 5). Compared to our conference paper [ 9] in FORTE 2014, we have added the new case study of SCION, a cleanslate Internet architecture for interdomain routing. We encode SCION in SANDLog, simulate the code in RapidNet, and verify variants of route authenticity properties. We also provide a comparison between SBGP and SCION. It shows that SCION's security guarantee in routing is similar to SBGP, as they both use layered signatures to protect advertised path from being tampered with by an attacker. SCION, however, enforces stronger security properties during data forwarding, enabling an AS to authenticate an upstream neighbor. On the other hand, SBGP does not provide any guarantee regarding data forwarding, which means an AS could forward packets coming from any neighbor. SANDLog specication and formal verication of both solutions can be found online ( http://netdb.cis.upenn.edu/secure_routing/ .) 2.SANDLog We specify secure routing protocols in a distributed declarative programming language called SANDLog. SANDLog is an extension to Network Datalog (NDLog) [ 21], which is proved to be a compact and clean way of specifying network routing protocols [ 22]. SANDLog inherits the expressiveness of NDLog, and is augmented with security primitives (e.g. asymmetric encryption) necessary for specifying secure routing protocols. 2.1.Syntax. SANDLog's syntax is summarized in Figure 2. A typical SANDLog program is composed of a set of rules, each of which consists of a rule head and a rule body. The rule head is a predicate, or tuple (we use predicate and tuple interchangeably). A rule body consists of a list of body elements which are either tuples or atoms (i.e. assignments and inequality constraints). The head tuple supports aggregation functions as its arguments, whose semantics will be introduced in Section 2.2. SANDLog also denes (and implements) a number of cryptographic functions, which represent common encryption operations such as signature generation and verication. Intuitively, a SANDLog rule species that the head tuple is derivable if all the body tuples are derivable and all the constraints represented by the body atoms are satised. SANDLog distinguishes between base tuples and derived tuples. Base tuples are populated upon system initialization. Rules for populating base tuples are denoted as b. To support distributed execution, a SANDLog program prog is parametrized over the node it runs on. Each tuple in the program is supposed to have a location specier, written @, which species where a tuple resides and serves as the rst argument of a tuple. A rule head can specify a location dierent from its body tuples. When such a rule is executed, the derived tuple is sent to the remote node represented by the location specier of the head tuple. We discuss the operational semantics of SANDLog in detail in Section 2.2. To specify security operations in secure routing protocols, our syntax denition also includes cryptographic functions. Figure 3 gives detailed explanation of these functions. Users can add additional cryptographic primitives to SANDLog based on their needs.4 C. CHEN, L. JIA, H. XU, C. LUO, W. ZHOU, AND B. T. LOO Crypt func fc ::fsign asym|fverify asym Atom a ::x:t|t1bopt2 Terms t ::x|c||fp~tq|fcp~tq Predicate pred ::ppagHq|ppagBq Body Elem B ::ppagBq|a Arg List ags :: | ags;x|ags;c Rule Body body :: | body;B Body Args agB ::@;ags Rule r ::ppagHq:body Head Args agH ::agB|@;ags;Fagrxxy;ags Base tp rules b ::ppagHq: Program prog pq::b1;;bn;r1;;rk Figure 2: Syntax of SANDLog An example program. In Figure 4, we show an example program for computing the shortest path between each pair of nodes in a network. sis the location parameter of the program, representing the ID of the node where the program is executing. Each node stores three kinds of tuples: linkp@s;d;cqmeans that there is a direct link from stodwith cost c;pathp@s;d;c;pqmeans that pis a path from stodwith costc; and bestPathp@s;d;c;pq states thatpis the lowestcost path between sandd. Here, linkis a base tuple, whose values are determined by the concrete network topology. path and bestPath are derived tuples. Figure 4 only shows the rules common to all network nodes. Rules for initializing the base tuple linkdepend on the topology and are omitted from the gure. In the program, rule sp1computes all onehop paths based on direct links. Rule sp2 expresses that if there is a link from stozof cost c1and a path from stodof cost c2, then there is a path from ztodwith cost c1+c2 (for simplicity, we assume links are symmetric, i.e. if there is a link from stodwith cost c, then a link from dtoswith the same cost calso exists). Finally, rule sp3aggregates all paths with the same pair of source and destination (sandd) to compute the shortest path. The arguments that appear before the aggregation denotes the groupby keys. We can construct a more secure variant of the shortest path protocol by deploying signature authentication in the rules involving crossnode communications (e.g. sp2). In the following rule sp21, a signature sigfor the path becomes an additional argument to thepath tuple. When node sreceives such a tuple, it veries the signature of the path fverifypp1;sig;pkq. Whenssends out a path to its neighbor, it generates a signature by as signing sig:fsignpp;skq. Here fsignandfverify are userdened asymmetric cryptographic functions (e.g. RSA). Function Description fsign asym( info,key) Create a signature of infousing key fverify asym( info,sig,key)Verify that sigis the signature of infousing key fmac( info,key) Create a message authentication code of infousing key fverifymac( info,MAC ,key)Verify infoagainst MAC using key Figure 3: Cryptographic functions in SANDLogA PROGRAM LOGIC FOR VERIFYING SECURE ROUTING PROTOCOLS 5 sp1pathp@s;d;c;pq:linkp@s;d;cq;p:rs;ds: sp2pathp@z;d;c;pq:linkp@s;z;c 1q;pathp@s;d;c 2;p1q;c:c1"
80,Detection of Cooperative Black Hole Attack in Wireless Ad Hoc Networks.txt,"A mobile ad hoc network (MANET) is a collection of autonomous nodes that
communicate with each other by forming a multi-hop radio network and
maintaining connections in a decentralized manner. Security remains a major
challenge for these networks due to their features of open medium, dynamically
changing topologies, reliance on cooperative algorithms, absence of centralized
monitoring points, and lack of clear lines of defense. Protecting the network
layer of a MANET from malicious attacks is an important and challenging
security issue, since most of the routing protocols for MANETs are vulnerable
to various types of attacks. Ad hoc on-demand distance vector routing (AODV) is
a very popular routing algorithm. However, it is vulnerable to the well-known
black hole attack, where a malicious node falsely advertises good paths to a
destination node during the route discovery process but drops all packets in
the data forwarding phase. This attack becomes more severe when a group of
malicious nodes cooperate each other. The proposed mechanism does not apply any
cryptographic primitives on the routing messages. Instead, it protects the
network by detecting and reacting to malicious activities of the nodes.
Simulation results show that the scheme has a significantly high detection rate
with moderate network traffic overhead and computation overhead in the nodes.","A MANET is a collection of wireless hosts that can be  rapidly deployed as a multihop packet radio networ k  without the aid of any established infrastructure o r  centralized administrator. Such networks can be use d to  enable next generation battlefield applications, in cluding  situation awareness systems for maneuvering war fig hters,  and remotely deployed unmanned microsensor network s.  MANETs have some special  characteristic features such as  unreliable wireless media (links) used for communic ation  between hosts, constantly changing network topologi es and  memberships, limited bandwidth, battery, lifetime, and  computation power of nodes etc. While these charact eristics  are essential for the flexibility of MANETs, they i ntroduce  specific security concerns that are absent or less severe in  wired networks. MANETs are vulnerable to various ty pes of  attacks. These include passive eavesdropping, activ e  interfering, impersonation, and denialofservice. Intrusion  prevention measures such as strong authentication a nd  redundant transmission can be used to improve the s ecurity  of an ad hoc network. However, these techniques can  address  only a subset of the threats. Moreover, they are co stly to  implement. The dynamic nature of ad hoc networks re quires  that prevention techniques should be complemented b y  detection techniques, which monitor security status  of the  network and identify malicious behavior.  One of the most critical problems in MANETs is the  security vulnerabilities of the routing protocols. A set of  nodes in a MANET may be compromised in such a way t hat  it may not be possible to detect their malicious be havior  easily. Such nodes can generate new routing message s to advertise nonexistent links, provide incorrect lin k state  information, and flood other nodes with routing tra ffic, thus  inflicting Byzantine failure in the network. One of  the most  widely used routing protocols in MANETs is the ad hoc on demand distance vector  (AODV) routing protocol [1]. It is a  source initiated ondemand routing protocol. Howeve r,  AODV is vulnerable to the wellknown black hole att ack. In  [2], the authors have assumed that the black hole n odes in a  MANET do not work as a group and have proposed a  solution to identify a single black hole. However, their  proposed method cannot be applied to identify a coo perative  black hole attack involving multiple malicious node s. In this  paper, a mechanism is proposed to identify multiple  black  hole nodes cooperating as a group in an ad hoc netw ork.  The is an extension of our previous work [3], which   is a  modified AODV protocol that makes use of a data routing  information  table  (Section III). Extensive simulations have  been done for evaluating the performance of the pro tocol.    The rest of the paper is organized as follows. Sect ion II  discusses some related work in security mechanism i n  routing for MANETs. Section III gives an overview o f  AODV protocol and the cooperative black hole attack .  Section IV describes the proposed security protocol  and the  associated algorithm. Section V presents the import ant  results obtained in simulation. Section VI conclude s the  paper while highlighting some future scope of work.   II.  RELATED WORK   "
192,Streaming multimedia over WMSNs: an online multipath routing protocol.txt,"Routing is a challenge to Wireless Multimedia Sensor Networks (WMSNs) for
supporting multimedia applications due to nodes' energy constraints and
computational capabilities, and the ways sensor nodes obtain forwarding
information. In this paper, we propose an online multipath routing protocol
that uses nodes' positions to make forwarding decisions at each hop. Real-time
decisions are made without any need to have the entire network topology
knowledge. The protocol achieves load-balancing and minimises nodes' energy
consumption by utilizing: (a) smart greedy forwarding scheme for selecting next
hop, and (b) walking back forwarding scheme to bypass network holes.
Performance comparisons of the proposed protocol (schemes) are made with TPGF
and GPSR. The results show that our schemes: (a) maximise the overall network
lifespan by not draining energy from some specific nodes, (b) provide QoS
delivery for video streams by using best nodes along the route, and (c) scale
better in high density WMSN.","  With the advancement in miniaturization and the  availability of low cost hardware, the computing nodes  embed various kinds of sensing and capturing elements  including microphones and video cameras. Hence, the use  of ubiquitous Wireless Multimedia Sensor Networks  (WMSNs) is becoming a reality  (Akyildiz et. al, 2002;  Gurses and Akan , 2005; Misra et. al, 2008; Shu and Chen ,  2010) .   WMSNs are generally used for surveillance applications,  intrusion detection, environmental and building monito ring,  etc. These applications imposes additional challenges such  as energy efficient data processing both within node and in  network, audio/video bandwidth/rate adaptation to  overcome the variations in networking conditions, Quality  of Service (QoS) delive ry to meet application specific  requirements and routing and selecting appropriate paths for  continual delivery of multimedia streams. Due to the  distributed and dynamic nature of these types of networks,  the design of a critical information infrastructure  based on a  WMSN raises many other challenges such as ensuring  confidentiality and the integrity of the data stream,  providing the means for node authentication and access  control, securing routing and node grouping  (Aivaloglou et.  al, 2008) . Among all the se challenges, our work focuses on  the routing and path selection issues taking into account  energy constraints and QoS delivery needs.   Generally, routing in wireless sensor networks (WSN) is  a challenging task. A comprehensive survey of routing  protocols in WSN is given in  (AlKaraki and Kamal, 2004) .  A large number of research works exists to enable energy  efficient routing in WSN. In fact, we can find different  routing techniques that try to achieve energy efficiency and  to provide a best quality of serv ice. One example is the  multi channel transmission in WMSNs. In (Vassis et. al,  2006) , authors have evaluated the performances of routing  (routing delays) when using a single and multi channel  communications in a wireless sensor and actor networks.  The aut hors showed that the multi channel scheme performs  better than the single channel scheme especially for higher  volumes of generated traffic putting the light on the  important need to parallel transmissions in a wireless  multimedia sensor network, where del ay and packets loss  are stringent constraints.   In higher layers of the communication protocols stack,  performances evaluations of routing protocols for WMSNs  suggests multipath routing approach to maximize the  throughput of streaming multimedia traffic. Th is is to utilize  diverse paths to route packet streams towards the  destinations in order to avoid draining the energy of nodes  along a specific route. In (Li et. al , 2010) , the authors  propose a multipath routing protocol based on the well  known routing pr otocol Directed Diffusion (Intanagonwiwat et. al , 2000)  that reinforces multiple routes with high link  quality and low latency. In (Vidhyapriya and Vanathi,  2007) , the authors focused on two key questions regarding  multipath routing in WMSNs: (a) how many paths are  needed? And (b), how to select these paths? The authors  then proposed a multipath routing mechanism in order to  provide a reliable transmission environment with low  energy consumption by utilizing the energy availability and  the received signal s trength of the nodes to identify multiple  routes from the source to the destination. In (Maimour,  2008) , the author addresses the problem of interfering paths  in a WMSN and considers both intra session as well as  intersession  interferences. The author pro poses an  incremental path creation mechanism where additional paths  are set up only when required (typically in case of  congestion or bandwidth shortage). In (Huang and Fang,  2008) , authors propose MCMP (MultiConstrained  MultiPath) routing protocol in orde r to guarantee a better  QoS in terms of delay and reliability. Unlike end toend  QoS schemes used in WSNs , the authors utilize a multiple  paths creation mechanism based on local link information.   Other examples of multipath routing protocols for WMSNs  include: MPMPS ( Multi Priority Multi Path Selection )  (Zhang  et. al , 2008)  and TPGF ( TwoPhase Geographical  Greedy Forwarding ) (Shu et. al , 2008).  However, these  “offline multipath” protocols have to explore the multiple  routes that may exist between the source  and the destination  before the actual data delivery phase . They may not be well  adapted for large scale highly dense network deployments  and for networks with frequent node mobility.   Geographic routing is the process in which each node is  aware of its geographic coordinates and uses the position of  packet’s destination to perform routing decisions. These  types of routing scales better for WSNs. Greedy Perimeter  Stateless Routing (GPSR)  (Karp and Kung, 2000) was  defined as a geographic routing protocol i n order for the  network to scale in large size networks, i.e., to  accommodate a large number of nodes having very low  exchange of route state information and maintenance. The  advantage of this protocol is that each node only gathers the  topology informatio n about its immediate neighbors. Thus,  its greedy forwarding relies on local knowledge for  selecting the closest next hop node to the destination. This  process ends up with continuous selection of the same path  that leads to fast depletion of the energy of  the nodes along  the selected route and premature dying of these nodes.   In this paper, we examine the benefit of geographic  routing along with “online” multi path route selection  process (i.e. multiple routes are created as packets advance  towards the dest ination) and propose a new routing protocol  called AGEM (Adaptive Greedy compass Energy aware  Multipath)  that takes into account both node’s energy  constraints and QoS needs of audio and video streams.   The design of AGEM is driven by the following factors :  3    1 Alternative paths:  multimedia applications are delay  sensitive and have delay and delay variation  constraints. Multimedia traffic should be delivered  satisfying these requirements. In typical networks,  shortest paths are heavily used for the delivery of this  traffic types w hereas other appropriate routers that  could satisfy these traffic requirements are under  utilized.   2 Load balancing : In order to maximize the lifetime of  WSN nodes and to avoid depletion of nodes’ energy  and consequently node’s failures, load balancing and  multipath delivery across the network must be  considered during the design of a routing protocol.   3 Multipath transmission : Packets in a multimedia  stream are generally large in size and the transmission  requirements can be several times higher than the  maximum transmission capacity of sensor nodes if a  single path is used for routing these packets.    4 Online decisions : As the topology may change from  time to time, it is more appropriate to make the routing  decisions in a distributed manner and in real time. T his  is due to the fact that offline routing processes cannot  react to topology changes and result in forwarding  packets to unavailable nodes or towards disconnected  routes.   5 Node selection process : in densely deployed networks,  different neighbors may be se lected as candidate for  packet forwarding. To deduce an appropriate selection,  the node selection process should take into account,  node’s energy, its distance to the destination and  packet’s QoS requirements.   The rest of this paper is organized as follows. Section II  reviews the related work in the area of WSN routing that  influenced the design of our proposed protocol. Section III  presents the functionalities of proposed AGEM protocol.  Section IV provides the results of performance evaluations  of our proposed protocol in comparison with GPSR. Finally,  section V presents our conclusions.       2 Related Work   "
86,Node Disjoint Multipath Routing Considering Link and Node Stability protocol: A characteristic Evaluation.txt,"Mobile Ad hoc Networks are highly dynamic networks. Quality of Service (QoS)
routing in such networks is usually limited by the network breakage due to
either node mobility or energy depletion of the mobile nodes. Also, to fulfill
certain quality parameters, presence of multiple node-disjoint paths becomes
essential. Such paths aid in the optimal traffic distribution and reliability
in case of path breakages. Thus, to cater various challenges in QoS routing in
Mobile Add hoc Networks, a Node Disjoint Multipath Routing Considering Link and
Node Stability (NDMLNR) protocol has been proposed by the authors. The metric
used to select the paths takes into account the stability of the nodes and the
corresponding links. This paper studies various challenges in the QoS routing
and presents the characteristic evaluation of NDMLNR w.r.t various existing
protocols in this area.","A Mobile Ad Hoc  Networks (M ANETs) [1 , 2] is  collectio n of mobile/se mi mobile nodes with  no existing  preestablished infrastructure, f orming a t emporary  network. Such networks are characte rized by: Dynam ic  topologies, e xistence o f bandwidth constrained and  variable capac ity links, ene rgy constrained ope rations,   and highly prone to security th reats. Du e to all th ese  featu res rou ting is a major issue in ad hoc networks. T he  routing pr otocols fo r ad hoc networks have bee n  classified as Proactive/tabl e driven e.g. Destin ation  Sequence d Distance Vect or (D SDV) [3], Optimized Link  State Ro uting (O LSR)[4 ], Reactive/Onde mand, e.g.  Dynamic Sou rce R outing Protocol (DSR) [5] , Ad hoc OnDem and Distance Vector routing protocol (AODV)  [6], Tem poral ly Ord ered Routing Al gorithm (TOR A)[4]  and Hybrid, e.g. Zone R outing Protocol (ZR P) [7],  Hybrid Ad hoc Routing Protocol (HARP) [23].     Quality o f   Serv ice (Qo S) based routing is defined in  RFC 2386 [8] as a ""R outing mechani sm under which  paths for flows are determined based on some knowledge  of resou rce av ailab ility in the network as wel l as th e Qo S  requirem ent of fl ows."" The main objecti ves of QoS  based routing are[8]:Dynamic det ermination of  feasi ble  paths for acc ommodating the QoS of the given flow  under policy constraints such  as p ath cost, pr ovider  selectio n , optimal utiliza tion of resources fo r improving  total net work throughput and grace ful performance  degradation d uring ov erload conditions gi ving better  throughput. Qo S rou ting strategies a re classified as   source r outing, distributed routing a nd hierarc hical  routing [9].    QoS based routing becom es chal lenging in MANET s, as  nodes s hould keep an uptodate information a bout link  status. Also, due to the dynamic nat ure of MANETs ,  main taining the p recise link state in form ation is v ery  diffic ult. Fina lly, the reserved resource m ay not be   guaranteed because of th e mobilitycau sed path breakage  or power depletion o f the mobile host s. QoS routing  should rapidly find a feasi ble new route to recover the  servi ce. Our motive in this pape r is to design a r outing  techni que, which con siders all three above problems  together. We defin e a m etric that atte mpts to maintain a  balance between  mobility a nd energy con straints in  MANET s. We use Dynamic Source R outing (DSR) [5],  as the base protocol to design our model.      IJCSI International Jour nal of Co mputer  Scienc e Issues,  Vol. 7, Issue 1, No . 2, January  2010  ISSN ( Online) : 16940784  ISSN ( Print): 1694 0814 19 2. Related Works   "
460,Private Location Sharing for Decentralized Routing services.txt,"Data-driven methodologies offer many exciting upsides, but they also
introduce new challenges, particularly in the realm of user privacy.
Specifically, the way data is collected can pose privacy risks to end users. In
many routing services, a single entity (e.g., the routing service provider)
collects and manages user trajectory data. When it comes to user privacy, these
systems have a central point of failure since users have to trust that this
entity will not sell or use their data to infer sensitive private information.
Unfortunately, in practice many advertising companies offer to buy such data
for the sake of targeted advertisements.
  With this as motivation, we study the problem of using location data for
routing services in a privacy-preserving way. Rather than having users report
their location to a central operator, we present a protocol in which users
participate in a decentralized and privacy-preserving computation to estimate
travel times for the roads in the network in a way that no individuals'
location is ever observed by any other party. The protocol uses the Laplace
mechanism in conjunction with secure multi-party computation to ensure that it
is cryptogrpahically secure and that its output is differentially private.
  A natural question is if privacy necessitates degradation in accuracy or
system performance. We show that if a road has sufficiently high capacity, then
the travel time estimated by our protocol is provably close to the ground truth
travel time. We validate the protocol through numerical experiments which show
that using the protocol as a routing service provides privacy guarantees with
minimal overhead to user travel time.","Big Data and datadriven methodologies have shown promise in improving the eciency, safety and adaptability of mobility services. However, certain types of data sharing can also lead to privacy risks for users. In this paper we focus on merits and risks of sharing location data. We discuss how location data is useful for determining congestion levels in routing services (e.g., Google Maps, Apple Maps, Waze), and we discuss user privacy risks involved with location sharing. With this as motivation we show how a protocol for decentralized location sharing can mitigate privacy risks while retaining some of the merits of location information for routing services. 1arXiv:2202.13305v2  [cs.CR]  14 Mar 2022Private Location Sharing for routing services Tsao, Yang, Gopalakrishnan, Pavone Figure 1: In most routing services, users give their location data in exchange for route recommen dations. Routing services often sell this data in data marketplaces. Third parties who buy location data from these routing services will be able to infer preferences, habits, and schedules of users who frequently interact with routing services. Repeated exposure to conventional location sharing can lead to privacy risks for users. In many current routing services, users provide their location data in exchange for routing recommendations. While users often only provide a small amount of their location data each time that they use a rout ing service, if a user regularly uses routing services, the data they share over many interactions can be stitched together to form a more complete picture of the user's routines, behaviors, preferences, etc. User privacy in such settings thus requires trust that the routing services will not share user data with other entities. However in practice, advertising companies oer to buy this user data to build user proles for the sake of targeted advertising. As a result, even though users only share small amounts of their location data in each interaction with a routing service, a single entity may end up with a large amount (likely more than the user is comfortable with) of their location data (see Fig. 1). While location sharing presents privacy challenges, it also provides utility for routing services. Location information is helpful because congestion levels of a road can be estimated from the number of vehicles on the road. A key insight toward addressing privacy challenges is that the congestion level only depends on aggregate location information; what matters is the number of vehicles on a road, not which particular users are on the road. This suggests that aggregation procedures can be used to protect individual user location while still providing the location information needed for routing services. 1.1 Statement of Contributions Motivated by this observation, in this paper we propose a decentralized location sharing protocol where users on the road will periodically compute and announce the trac counts (e.g., approximate number of vehicles traveling on each road) of the transportation network in a decentralized and privacypreserving manner. Since only the total number of vehicles on each road is announced, the location of individual users is not discernible by observers, which is contrary to many current location sharing setups where users give their individual location data directly to routing services. With this protocol, user privacy does not rely on a trusted data custodian, and there are no single 2Private Location Sharing for routing services Tsao, Yang, Gopalakrishnan, Pavone Figure 2: A visualization of the routing service protocol described in Algorithm 1. Users traveling in the transportation network share their location data in a privacypreserving way to estimate the trac counts in a decentralized manner (upper left). These counts are then used to estimate travel times (right). When a user requests a route from the routing service, a shortest path is computed using the estimated travel times (lower left). points of failure. Furthermore, assuming the roads in the network are suciently large, we can prove that the travel time estimates produced by the protocol will be close to the estimates produced by the ground truth with high probability. This result showcases an interesting complementarity between dierential privacy and delay functions used in travel time estimation. In low trac situations, dierential privacy constraints lead to poor accuracy for trac count estimation. However, delay functions are insensitive for small inputs and can thus tolerate the poor accuracy. On the other hand, delay functions are very sensitive in high trac situations, and dierential privacy can provide high accuracy in these settings. Thus when a delay function is composed with a dierentially private mechanism, the two compensate for the others' weaknesses to yield accurate and private travel time estimates. We corroborate this insight using numerical experiments which show that the protocol provides a privacypreserving routing service with minimal overhead to the travel time of users. 1.2 Related Work "
282,"Multipath IP Routing on End Devices: Motivation, Design, and Performance.txt","Most end devices are now equipped with multiple network interfaces.
Applications can exploit all available interfaces and benefit from multipath
transmission. Recently Multipath TCP (MPTCP) was proposed to implement
multipath transmission at the transport layer and has attracted lots of
attention from academia and industry. However, MPTCP only supports TCP-based
applications and its multipath routing flexibility is limited. In this paper,
we investigate the possibility of orchestrating multipath transmission from the
network layer of end devices, and develop a Multipath IP (MPIP) design
consisting of signaling, session and path management, multipath routing, and
NAT traversal. We implement MPIP in Linux and Android kernels. Through
controlled lab experiments and Internet experiments, we demonstrate that MPIP
can effectively achieve multipath gains at the network layer. It not only
supports the legacy TCP and UDP protocols, but also works seamlessly with
MPTCP. By facilitating user-defined customized routing, MPIP can route traffic
from competing applications in a coordinated fashion to maximize the aggregate
user Quality-of-Experience.","Contemporary end devices are normally equipped with multi ple network interfaces, ranging from datacenter blade serv ers to user laptops and handheld smart devices. Exploiting all available interfaces, applications can adopt multipath tr ans missions to achieve higher and smoother aggregate through put, resilience to trafﬁc variations and failures on indivi dual paths, and seamless transition between different networks . While each application can implement its own multipath tran s mission at the application layer, it is more desirable to pro  vide multipath transmission services from the lower networ k protocol stack so that all applications can beneﬁt. Recentl y,Multipath TCP (MPTCP) has been proposed and attracted lots of attention from academia and industry [1–5]. IETF pro  posed RFC 6182 speciﬁcally for multipath TCP in 2011 . In MPTCP, if a pair of nodes have multiple endtoend IP paths, each TCP session is carried by multiple subﬂows, each of which is an independent regular TCP connection on one of the available paths. TCP packets generated by the sender are dispatched to different subﬂows and transmitted over diffe r ent paths. At the receiver end, all packets coming from dif ferent subﬂows are put back for reconstructing the original TCP data stream. MPTCP allows all TCPbased applications enjoy the multipath gain in a transparent fashion. However, UDPbased applications cannot beneﬁt from it. In this paper, we share our experience of orchestrating multipath transmission from the network layer of end device s, and present a complete design of Multipath IP Transmission (MPIP). There are several advantages of implementing mul tipath transmission at the network layer: Broader Coverage. MPIP can transmit IP packets generated by any TCP or UDP based application. Being transparent to the upper layers, MPIP can beneﬁt all user applications with  out changing the application and transport layer protocols . Better View and Coordination. The network layer can di rectly measure network status and promptly capture various dynamic events, such as interface and network changes. Sinc e all application trafﬁc go through the network layer, MPIP ca n efﬁciently piggyback network measurement on the existing application trafﬁc for inband measurement , without generat ing extra probing trafﬁc. The obtained network information and routing intelligence can be shared cross all applicatio ns. MPIP can adjust the transmission strategies for all applica  tions in a coordinated fashion to maximally satisfy the di verse application and user needs. More Flexible Routing. With MPTCP, trafﬁc allocated to a path is determined by the rate achieved by the TCP subﬂowon that path, i.e., routing is simply determined by conges tion control along multiple paths. This is too rigid and lim ited for applications with diverse throughput and delay nee ds, and users with different resource and economic constraints . MPIP instead can implement any customized multipath rout ing to satisfy application and user needs. Lower Complexity. MPIP can eliminate redundant network probings and routing adjustments attempted by individual a p plications and sessions. From the implementation point of view, similar to MPTCP, MPIP only requires changes on end devices. MPTCP has to work with the complexity resulted from the stateful TCP implementation. The legacy IP proto col is stateless and its implementation is much simpler than the legacy TCP. This leaves more design space for MPIP. Meanwhile, MPIP also faces additional challenges. First of all, due to the stateless nature of IP, there is no existing session and path management mechanisms at network layer. Secondly, to work with multiple paths, MPIP constantly need s feedbacks about the availability and performance of each path. However, the legacy IP does not provide endtoend feedbacks. Thirdly, various middleboxes, e.g., NAT route rs, arebynomeans transparent . They change and verify IP and TCP headers, and drop packets which they believe are “un orthodox"" according to the legacy TCP/IP protocol. Multi path transmission unavoidably leads to outoforder packe t delivery. This will cause problem for running legacy TCP over MPIP. Finally, MPIP design and implementation should minimize the overhead and complexity added to the network layer. We address those challenges in our MPIP design and implementation. The contribution of our work is threefold : (1) We develop a complete design to implement multi path transmission at the network layer, consisting of signaling, session and path management, multipath IP source routing, and NAT traversal. Our MPIP de sign not only can be used by the legacy TCP and UDP protocols, but also works seamlessly with MPTCP. (2) MPIP supports diverse multipath routing strategies. Forallpaths mode, we design a delaybased rout ing algorithm for MPIP to balance the loads of avail able paths. We also develop a userdeﬁned multi path routing framework, through which customized routing strategies, such as selectedpaths andsingle path, can be realized by MPIP to satisfy diverse ap plication/user needs. (3) We implement MPIP in Linux and Android kernels. We evaluate its performance using controlled lab ex periments and Internet experiments. We demonstrate that MPIP can transparently achieve various multi path gains at the network layer. It works seamlesslyApplication socket transport MPIP IP11IP12Node A Application socket transport MPIP IP21IP22Node B session IP Paths Figure 1: Example of MPIP Transmission with legacy transport layer protocols and popular ap plications. It can signiﬁcantly improve user Quality ofExperience (QoE) using easily conﬁgurable mul tipath routing strategies. The rest of the paper is organized as follows. The seman tics of MPIP is presented in Section 2. The complete MPIP design is developed in Section 3. Special issues related to TCP are addressed in Section 4. In Section 5, we report the experimental results. Related work is summarized in Sectio n 6. The paper is concluded in Section 7. 2 SEMANTICS MPIP works at the network layer on end devices. The basic building blocks are: Node, Session, and Path . •Node refers to an end device with potentially multi ple network interfaces, each of which gets assigned with a private or public IP address. MPIP also works with nodes with single network interface. •Session is a transport layer ﬂow between two nodes served by MPIP. A session is established at the trans port layer, using the legacy TCP or UDP protocol, or even the new MPTCP protocol. •Path is an endtoend IP route available for a ses sion. For each session, MPIP can use any interface on one node to transmit packets to any interface on the other node. If the two nodes have mandninter faces respectively, the number of possible paths is mn. With the legacy IP, each session is associated with only one IP (interface) and one port number on each node. The routing decision is based on destination IP address. MPIP employs customized sessionbased routing, and transmits pack ets of each session using any combination of the available paths. For the example in Figure 1, node A and node B are MPIPenabled. They use the legacy application layer and 2transport layer. Each node has two interfaces (and the asso ciated IP addresses). There are four endtoend IP paths, as illustrated in Figure 1. When an application on node A opens a TCP/UDP connection to node B, MPIP will treat this con nection as a new session. For each packet going from A to B, MPIP will choose one of the four available paths to send it out. To do that, MPIP will change the source and destina tion IP addresses as well as the port numbers of the packet so that it can be forwarded to the corresponding interface of th e chosen path on node B. When node B receives the packet, it will ﬁrst check which session it belongs to, then modify the IP address and port number back to the original values of the session. Finally, the packet will be passed to the corr e sponding TCP/UDP socket. The whole process is transparent to TCP/UDP session. If MPIP can simultaneously utilize the four paths by dispatching different packets to different pa ths, TCP /UDP throughput can be improved. Also the session can work normally as long as one path is available, which means TCP/UDP session will not be interrupted even if the default interfaces assigned to the session by the OS are disconnecte d. This makes handovers between different networks seamless and transparent to the transport and application layers. In general, MPIP routes packets from one session using several modes: (1)allpaths mode: packets are dispatched concurrently to all the available paths. Each packet will be trans mitted along one of the paths. MPIP Routing deter mines the trafﬁc splitting ratios among paths. This mode can potentially utilize the bandwidth available on all paths to achieve higher session throughput. (2)selectedpaths mode: packets are routed on a sub set of paths that meet the requirements of the appli cation. Selectedpaths mode avoids the inclusion of bad paths that will drag down the application perfor mance. Path selection is applicationspeciﬁc and can be adapted by MPIP based on both application and network dynamics. (3)singlepath mode: at any time, packets are only routed over one selected path, which can change during the course of the session. MPIP will handle seamless handover between paths, without interrupting the ses sion. Singlepath mode eliminates path quality dis parity, such as outoforder packet delivery, by sac riﬁcing the throughput gain, compared with the all paths and selectedpaths modes. (4)protectedpath mode: a missioncritical packet can be simultaneously transmitted on multiple paths. The receiver will pass the ﬁrst arrived copy to the upper layer and discard the subsequent redundant copies. It sacriﬁces bandwidth for resilience. For example, for TCP over two lossy wireless links, ACK packets can be transmitted using the protectedpath mode.3 MPIP DESIGN To realize the gain of MPIP, there are several major design components: Signaling Channel ,Handshake ,Session Man agement ,Path Management ,MPIP Routing , and NAT Traver sal. Our design only changes the IP protocol at the network layer and is transparent to the transport and application la y ers. To keep the simplicity of IP protocol, MPIP is still impl e mented as connectionless, while maintaining some feedback information of the available paths necessary for MPIP rout ing. We achieve this by simply keeping track of several key tables. 3.1 Signaling Channel Table 1: Control Message Block Source Session Local IP CM Node ID ID Address List Flags Path Feedback Packet Path ID Path ID Timestamp Delay In TCP protocol, ACK packets are used to feedback infor mation from the receiver. Due to its connectionless design, IP protocol doesn’t have its builtin endtoend feedback cha n nel. MPIP routing algorithms do need realtime information about the availability and performance of endtoend paths . We need a signaling channel for MPIP. Instead of transmit ting extra signaling packets, we piggyback MPIP control in formation to each MPIP packet. For each packet sent out by MPIP, we add an additional control message (CM) data block at the end of user data. The size of the CM block is 25bytes, a small overhead for typical data packets of 1000+bytes. Considering the throughput gain and robustness brought by MPIP, the overhead of CM block is well acceptable. Packet size may exceed the link MTU after attaching the CM block. We force the transport layer to reduce the size of each segment, e.g. decreasing the MSS value for TCP connection, to make sure the CM block ﬁts within the MTU limit. The information contained in a CM block of a packet is shown in Table 1. Source Node ID is a globally unique ID of the sending node of this packet. Since each node has multiple interfaces , and their IP addresses may change over time, we should not use interface IP addresses to identify a node. To have a semi static node ID, we instead use the MAC address of a NIC (preferable more static ones) on the node to be its ID. Local IP Address List carries all local IP addresses on the sending node. This list will be used to construct MPIP paths. CM Flags encodes the MPIP functionality of the packet. With different values of CM Flags , different actions will be operated when the packet is received. Other ﬁelds will be explained in the following sections. 3Figure 2: MPIP Handshake 3.2 Handshake Table 2: MPIP Availability Dest. IP Dest. Port MPIP Query Address Number Availability Count IP1 P1True 2 IP2 P2False 5 As an extension of IP, MPIP needs to be backward com patible. To take advantage of MPIP, both end nodes of a ses sion need to be MPIP enabled. Locally, every node main tains a table (Table 2) to record the availability of MPIP on remote nodes. Due to the existence of NAT, two nodes may share the same IP address, this is why we have to index each entry using the combination of IP address and port num ber. The MPIP handshake process is illustrated in Figure 2. When a node receives a packet from the transport layer, it ﬁrst checks locally whether the destination address and por t number has an entry in Table 2. If yesand MPIP availabil ity isTrue , then the packet will be sent out using MPIP; if MPIP availability is False , it will be sent out as a normal IP packet to be backward compatible. If there is no entry found in the table, besides sending out the packet as a normal IP packet, MPIP makes a copy of the packet and inserts the CM block with Fla/afii10069.itals _Enable . This value is used for MPIP query. When the packet is received by a MPIPenabled node, the re ceiver adds the sender’s IP address and port number into its own MPIP availability table with value of True , then sends back a conﬁrmation packet to the sender with Fla/afii10069.itals _Enabled . When the sender receives the conﬁrmation, it will add the receiver’s address and port number to its local MPIP avail ability table. For TCP connections, the conﬁrmation packet generated by MPIP receiver maybe blocked by NAT device if its sequence number is not properly set. We solve this prob  lem by piggybacking it on a duplicated regular TCP packet. Please refer to our technical report for more detail [6]. In Table 2, the column Query Count maintains the number of query messages that have been sent out to each destination .If the number is larger than a threshold value, it assumes tha t the destination doesn’t support MPIP, and marks the avail ability in the table as False . Table 3: Node ID vs IP address and Port Node ID IP Address Port Number ID1 IP11 P11 ID1 IP12 P12 ID2 IP21 P21 ID2 IP22 P22 After the MPIP handshake, a node can start to learn the in terfaces available on each MPIPenabled remote node. Each node maintains a node ID to IP address and port number map ping table (Table 3). Every time a MPIP packet is received, the receiver extracts the sender’s node ID from the packet’s CM block, and IP address and port number from the packet header. The three tuple is then written into the mapping tabl e. 3.3 Session Management MPIP conducts sessionbased routing. Session management takes care of the addition and removal of TCP and UDP ses sions. At the transport layer, each session is identiﬁed by t he traditional 5tuple: source and destination IP addresses and port numbers, and protocol type. Since MPIP can transmit a packet from a session using different source and destinatio n IP address/port numbers than the session’s original ones, w e can no longer use IP addresses/port numbers to associate a MPIP packet with a transport layer session. Instead, we will use session ID and node ID carried in the CM block to iden tify the session of a MPIP packet. We need a table to corre late the two different session mapping schemes employed by MPIP and the legacy transport layer. This is achieved throug h the session information table, as in Table 4. The table maintains one entry for each session to each re mote node. For each entry, the socket information, namely IP addresses and port numbers, are the original ones from the transport layer. A session’s socket information will no t be changed even if the IP addresses and port numbers that are initially assigned to the session are no longer active. T his is for seamless handovers between networks. After the MPIP availability handshake has been success fully completed, when sending out a packet, the sender check s Table 4 to see whether a proper session entry has been gen erated. If not, MPIP generates a new session ID and adds a new entry to Table 4. The IP addresses, port numbers and protocol are extracted from the packet header, and the desti  nation node ID is obtained from Table 3. After this, all pack ets belong to the session will carry the session’s ID in its CM block. On the receiver end, whenever a MPIP packet is re ceived, the receiver extracts the source node ID and session 4Table 4: Session Information Table Dest. Session Source Source Destination Destination Protocol Next Update Node ID ID IP Port IP Port Sequence No Time ID1SID1SIP1SPORT 1DIP1DPORT 1 TCP S1 T1 ID1SID2SIP1SPORT 2DIP1DPORT 2 UDP 0 T2 ID2SID1SIP2SPORT 3DIP2DPORT 3 TCP S2 T3 ID2SID2SIP2SPORT 4DIP2DPORT 4 UDP 0 T4 ID from its CM block. If there is no entry found in its session information table, it will generate a new entry and populate it with the source node ID, session ID, and socket informa tion carried in the packet header, with swapped source and destination IP/port addresses. This will make sure that bot h sides of the same session use the same session id. Note that, due to NAT, for the same session, the IP addresses and port numbers seen by a remote node might be different from the values on a local node. This won’t cause any confusion as long as the session ID and node ID combination is unique. Removal of a session is done by expiration based on the session’s Update Time in Table 4. The column Next Sequence Nois used for TCP outoforder process which will be ex plained in Section 4.2. 3.4 Path Management After a session is registered with MPIP, the next step is to explore all the available paths for the session. One simple solution is to have each node send their local IP addresses to the other end using the Local Address List in CM block. Then any pair of IP addresses on the two ends can be used as a path for MPIP transmission. However, this only works if all interfaces on both ends have public IP addresses. If one node is behind a NAT, its local IP addresses cannot be used directl y to establish IP paths. To solve this problem, we again have to identify paths using a combination of IP address and port number on both ends. Consequently, the path management has to be done for each session individually. 3.4.1 Establishment. MPIP maintains a path informa tion table on each node, as in Table 5, to record the available paths for each session. Each entry contains the ID of the re mote node and the session ID. Each path is allocated with a path ID, which is unique on the local node. The source and destination IP and port addresses are the addresses carried in the header of MPIP packet, NOT necessarily the same as those allocated to the session at the transport layer. Givenmandninterfaces at each end node, there are to tallymnpossible paths. After the MPIP handshake, each node tries to send out packets from each of its local inter face to each of the known interface on the remote node. If a packet with a certain combination of source and destination IP/port addresses can get through, the node will add the pathANAT1 B NAT2/angbracketleftsip1,sp1/angbracketright/angbracketleftdip1,dp1/angbracketright /angbracketleftsip2,sp2/angbracketright /angbracketleftdip2,dp2/angbracketright/angbracketleft/hatwidestsip2,/hatwidestsp2/angbracketright/angbracketleft/hatwidestsip1,/hatwidestsp1/angbracketrightavailable paths to B   /angbracketleftsip1,sp1/angbracketright ⇔ /angbracketleftdip1,dp1/angbracketright /angbracketleftsip2,sp2/angbracketright ⇔ /angbracketleftdip1,dp1/angbracketright /angbracketleftsip1,sp1/angbracketright ⇔ /angbracketleftdip2,dp2/angbracketright /angbracketleftsip2,sp2/angbracketright ⇔ /angbracketleftdip2,dp2/angbracketright/angbracketleftdip1,dp1/angbracketright ⇔ /angbracketleft/hatwidestsip1,/hatwidestsp1/angbracketright /angbracketleftdip2,dp2/angbracketright ⇔ /angbracketleft/hatwidestsip1,/hatwidestsp1/angbracketright /angbracketleftdip1,dp1/angbracketright ⇔ /angbracketleft/hatwidestsip2,/hatwidestsp2/angbracketright /angbracketleftdip2,dp2/angbracketright ⇔ /angbracketleft/hatwidestsip2,/hatwidestsp2/angbracketrightavailable paths to A   Figure 3: MPIP Path Establishment with NAT to path information table. Let’s explain the process throug h the example in Figure 3. Node A initiates a session with node B. The IP and port addresses allocated to the session at the transport layer are /an}bracketle{tsip1,sp1/an}bracketri}htand/an}bracketle{tdip1,dp1/an}bracketri}hton A and B re spectively. Without loss of generality, let’s assume the se s sion can be established correctly with legacy IP. Then on both ends, MPIP records the new session, and adds the de fault path between /an}bracketle{tsip1,sp1/an}bracketri}htand/an}bracketle{tdip1,dp1/an}bracketri}htfor the session in Table 5. Since A knows B is MPIPenabled, it also tries to send the same packet from its other local interface with IP addresssip2by changing its source addresses to /an}bracketle{tsip2,sp2/an}bracketri}ht. When B receives the packet, possibly due to NAT, the source IP and port addresses in the packet might be different from /an}bracketle{tsip2,sp2/an}bracketri}ht, say/an}bracketle{t/hatwidestsip2,/hatwidersp2/an}bracketri}ht. Then B examines the Source Node IDandSession ID in the packet’s CM block, it knows this is a MPIP transmission for the same session but from a different interface. B adds for the session a new path with destination address of /an}bracketle{t/hatwidestsip2,/hatwidersp2/an}bracketri}htin its path information table. Now B will also send back packets to A’s second interface, using de s tination addresses /an}bracketle{t/hatwidestsip2,/hatwidersp2/an}bracketri}ht. When A receives the packet, it conﬁrms the connectivity of its local path between /an}bracketle{tsip2,sp2/an}bracketri}ht and/an}bracketle{tdip1,dp1/an}bracketri}ht, and adds it to its path information table. Sim ilarly, if B has another interface with public address dip2, A will obtain the new address from the Local Address List in the CM block of packets from B to A. Then A can establish more IP paths to this new address using a similar process. 5Table 5: Path Information Table Dest Session Path Src Src Dest Dest Minimum RealTime RealTime Maximum Path Node ID ID ID IP Port IP Port Path Delay Path Delay Queuing Delay Queuing Delay Weight ID SID1PID11sip1sp1dip1dp1Dmin11 D11 Q11 Qmax11 W11 ID SID1PID12sip2sp2dip1dp1Dmin12 D12 Q12 Qmax12 W12 ID SID2PID21sip1sp1dip1dp1Dmin21 D21 Q21 Qmax21 W21 ID SID2PID22sip2sp2dip2dp2Dmin22 D22 Q22 Qmax22 W22 3.4.2 Monitoring. To facilitate path selection, MPIP con tinuously monitors the performance of active paths. Given that packet losses in the current Internet are rare, we mainl y focus on path delay in our current design. Due to asymmetric routing and unequal congestion levels along two directions of the same path, instead of measuring the roundtrip delay of a path, we measure the oneway path delay to infer the path quality on each direction. In Table 5, all ﬁelds related to network delay will be calculated by oneway path delay feedback from the remote node. When node Asends out a packet, it chooses a path from Table 5 and sets Packet Times tamp with its local system time T1. After node Breceives this packet, it calculates the oneway delay for the path from Ato BasT2−T1, whereT2is B’s local time when receiving the packet. In practice, the absolute value of path delay calcu lated here isn’t the real delay value because of the clock dif  ference between node Aand node B. But our path selection algorithms depend on the relative ordering and variations o f path delays, instead of their absolute values. Clock differ ence between nodes has little impact. Bthen sends back the path delay information in the CM block of the next packet going back toA, which records the path delay value into the col umn RealTime Path Delay in Table 5. Path delay values are smoothed using a simple moving average algorithm. More details can be found in our technical report [6] 3.4.3 Dynamic Path Addition and Removal. As mul tipath feature enabled on a device, IP addresses of interfac es change dynamically. A mobile device can connect to differ ent access points (WiFi hotspot/Cellular Tower) during a se s sion. Its IP addresses can be changed, removed or added back dynamically. To make the changes transparent to ap plications, MPIP supports dynamic addition and removal of paths from Table 5. When IP address change happens on one node, it sets Fla/afii10069.itals _IP_Chan/afii10069.itale in the CM block of its next outgoing packet. After receiving a packet with this ﬂag, the receiver knows that IP address on the sender has changed, it removes all path entries related to the changed IP address in Table 5. Meanwhile, the entry for this session in Table 4 remains unchanged. The path that sends out the IP change no tiﬁcation will be added back to the aforementioned tables as the only path of the session. Also, the sender does the same reset for this session. After all these resets, there is only onepath left for this session, all the other available paths wil l be added back through the procedure in Section 3.4.1. Similarl y, when a new interface becomes available, new IP paths from it can be added using the the mechanism in Section 3.4.1. 3.4.4 Periodical Heartbeat. Table 5 should be updated continuously on both sides. During the lifetime of a TCP session, both sides send packets to each other at a high fre quency. However UDP doesn’t have this builtin feedback mechanism and in some UDP applications, all trafﬁc is one way without acknowledgement, which means that the sender can’t get feedback information through piggyback. To solve this problem, a periodical heartbeat mechanism is introduc ed to keep Table 5 fresh. More details can be found in our tech nical report [6]. 3.5 Multipath IP Source Routing Given all paths available for a session, every time one node needs to send out a packet, it chooses the most suitable path from Table 5. MPIP offers different routing strategies to sa t isfy the diverse needs of applications. 3.5.1 Allpaths Mode. Many applications, e.g., web, ﬁle transfer, and video streaming, can beneﬁt from highthroug hput transmissions. MPIP can concurrently transmit packets alo ng multiple paths to achieve higher throughput than the tradi tional single path routing. With MPTCP, the transmission rate along each TCP subﬂow is controlled by the TCP con gestion control algorithms. Since MPIP works under rate con  trol schemes from transport and application layers, it will be redundant and possibly conﬂicting to implement ﬁnegraine d rate control for each MPIP path at the network layer. Instead , the main design goal of MPIP routing is to balance load along concurrent paths using endtoend path delay feedbac k and probabilistic packet dispatching algorithm. As in Table 5, we maintain a Path Weight (W) for each active path. Each packet will be dispatched to a path kwith the probability P(k), which is calculated as: P(k)=Wk/summationtext.1N i=1Wi. (1) 6Path weight is the only criterion for path selection and dete r mines the performance of MPIP load balancing. In our pro totype, we use realtime oneway path delay to dynamically update path weights. Endtoend path delay consists of propagation delay, trans  mission delay, processing and queueing delay. While propa gation delay and transmission delay are mostly constant, pr o cessing and queue delay are timevarying and increase with congestion level. We maintain the minimum path delay to represent the constant portion of endtoend path delay, an d use the difference between realtime and minimum delay to infer the queuing delay, which reﬂects the congestion level along the path. We then adjust the weight of each path using the realtime queuing delay. In Table 5, RealTime Path Delay Dis collected using re ceiver feedbacks as described in Section 3.4.2. Every time a new path delay sample Dis received, the other three delay metrics are updated as follows. (1)Minimum Path Delay: Dmin=min{Dmin,D}; (2)RealTime Queuing Delay: Q=D−Dmin; (3)Maximum Queuing Delay: Qmax=max{Qmax,Q}. During our experiments, we found that calculating the weigh t of each path independently according to its realtime queuin g delay can result in large ﬂuctuations. We instead adjust the weights of all paths together based on their queueing delay variations as in Algorithm 1. Nis the number of paths that be Algorithm 1 Path Weight Adjustment. 1:Qa/v.alt/afii10069.ital=/summationtext.1N i=1Qi N; //average delay among all paths 2:ifQi≤Qa/v.alt/afii10069.italthen 3:Wi=Wi+S; //increase weight for low delay path 4: ifWi>1000 then 5:Wi=1000 ; //upper bound for path weight 6: end if 7:else 8:Wi=Wi−S; //decrease weight for high delay path 9: ifWi<1then 10:Wi=1; //lower bound for path weight 11: end if 12:end if 13:return ; long to one session, QiandWiare queuing delay and weight of pathi, andSis the adjustment granularity. Initially, every path has the same path weight of1000 N. In each iteration, the path weight increases or decreases by Sbased on whether its queuing delay is higher or lower than the average delay. The maximum weight is 1000 , and the minimum is 1. This way, we keep all live paths in consideration. Heavily con gested paths will not be completely eliminated. Instead the ywill have the minimum weight, and their weights will be in creased after congestion is relieved. Algorithm 1 is execut ed periodically, the length of each period is deﬁned as a conﬁg urable system parameter T. Now we have two conﬁgurable parameters: the adjustment stepsize Sand interval T. Larger Sand shorter Treact faster to congestion level changes, but generate larger ﬂuctuations; while smaller Sand longer T can result in smaller ﬂuctuation but sluggish response. In o ur system, for the path weight range of 1∼1000 , we setSto 10andTto100ms. During our evaluation, this conﬁguration achieves good balance between ﬂuctuation and convergence. 3.5.2 Userdeﬁned Multipath Routing. Not all appli cations take throughput as the ﬁrst priority. For a live vide o streaming session, as long as the throughput is higher than the video rate, delay is more critical for the streaming qual ity. Even for the same application, different data may have diffe r ent QoS requirements. In the example of video calls, such as WebRTC, audio stream has low volume but are very sensi tive to delay, video stream has high volume and can be less sensitive to delay than audio. To address the diverse needs o f applications, we design MPIP to support userdeﬁned routin g schemes, including selectedpaths ,singlepath andprotected path. Users can inform MPIP of their desired multipath rout ing policies by conﬁguring a routing table as illustrated in Table 6. Each line of the table is a customized routing rule Table 6: Userdeﬁned Multipath Routing Table IP Port Start End Routing Address Number Protocol Size Size Priority ∗ 22 TCP 0200Rf 192.168.1.25222 UDP 200∗Tf 192.168.1.25221 UDP 0500Rf for outgoing packets. Each rule matches a set of packets and the routing priority for the matched packets. Packet match ing is done using destination IP address, port number, proto  col, and the range of packet length. We currently deﬁne two types of routing priorities: throughputﬁrst Tf, and respon siveness ﬁrst Rf. Outgoing packets with Tfpriority will be dispatched to available paths using the allpaths mode pre sented in Section 3.5.1. Outgoing packets with Rfpriority will always be sent to path with the lowest delay using the singlepath mode. For example, based on the ﬁrst row of Ta ble 6, for any TCP connection with destination port 22(ssh session), if the packet length is smaller than 200bytes, the packet will be forward to the lowest delay path. The second row deﬁnes that all UDP packets going to a remote host with packet size larger than 200bytes should be forwarded using allpaths mode. The third row speciﬁes that for a UDP packet going to the same remote host, but a different port number, if the packet size is less than 500, it will be forwarded to 7the lowest delay path instead. The current implementation employs rigid packet matching rules and has limited routing policies. Under the same basic framework, we will extend it to incorporate more ﬂexible and more userfriendly packet matching rules and more diverse routing policies with ﬁner granularity in our future work. 4 TCPRELATED ISSUES By deviating from the default singlepath transmission, MP IP also brings some new issues for the upper layer protocols, es  pecially TCP, such as NAT checking and outoforder packet delivery. It is also intriguing to explore the coexistence of MPIP with multipath transmissions at upper layers, such as MPTCP. We now present solutions to TCPrelated issues. 4.1 NAT Checking Based on our experiments and other studies, e.g. [1], NAT de vices are by no means transparent, and conduct all kinds of mapping, veriﬁcation, and dropping to endtoend sessions , especially TCP. One immediate obstacle introduced by NAT to MPIP is that many NAT devices drop a TCP packet if they don’t have a record about the TCP connection that the packet belongs to. This doesn’t cause a problem for MPTCP since each subﬂow in MPTCP is a legitimate TCP connection, and all packets of a subﬂow, including the threeway handshake packets establishing the subﬂow, traverse the same NAT. In MPIP, if we transmit TCP packets on a path different from the original one through which the TCP connection is estab lished, NAT devices along the path are not aware of the con nection and will drop these packets before they arrive at the destination. We provide two solutions. 4.1.1 Fake TCP Handshake. To work around a NAT device that drops packets of a TCP connection established on a different path, we construct a fake TCP threeway hand shake on the NAT’s path before sending packets over. All handshake packets have CM Flags set toFla/afii10069.itals _HS. They are dropped after being processed by MPIP. As shown in Table 1, the ﬁeld Local Address List carries all local IP addresses. Also, the node that initiates the connection is considered a s the client. When the client receives the IP address list of th e server, it sends out a SYN packet along each possible path to the server except the original one which was used to initiate the real TCP connection. When the server receives a SYN packet, it replies with a SYNACK packet. After the client sends out the ﬁnal ACK packet to the server, the threeway handshake is completed successfully. After this, NAT route rs along the path have a record about this fake TCP connection, will pass TCP packets assigned to the path. 4.1.2 UDP Wrapper. The other solution is UDP wrap per. During our experiments, most NAT devices don’t verifysocket information of UDP packets. We make use of this fea ture and transmit a TCP packet inside a UDP packet to pass NAT checking. At the sender side, every time the network layer gets a TCP packet from transport layer, MPIP chooses a path to send the packet out as shown in Section 3.4. If the chosen path isn’t the original path, we encapsulate the whol e TCP packet into an UDP packet by adding a forged UDP header using the corresponding IP addresses and port num bers of the chosen path. At the receiver end, MPIP can tell this UDP packet is a carrier for a TCP packet instead of a reg ular UDP packet by checking the Protocol ﬁeld of the path in Table 4. After removing the UDP header, the original socket information will be extracted from Table 4 to be ﬁlled into the TCP and IP headers. 4.2 Outoforder Packet Processing Different interfaces take different network accesses and d if ferent Internet paths to reach the same destination. Packet s sent over multiple interfaces/paths can arrive at the desti na tion node out of order. This is not a problem for protocols like UDP, but for TCP, outoforder packet delivery will sig  niﬁcantly degrade its performance. When TCP works over MPIP, if the delay difference between multiple paths is sig niﬁcant, we can expect a lot of outoforder packets. To re solve this problem, for each session in Table 4, if it is TCP protocol, MPIP maintains the sequence number Sof the next inorder packet of the session to be received. MPIP also main  tains a separate buffer Bfor each active session to store out oforder packets. Whenever a new packet is received, if the sequence number is larger than S, it will be stored in B; if the sequence number equals to S, MPIP checks how many consecutive packets are stored in B, starting from sequence numberS. Then MPIP pushes all consecutive packets to the transport layer and update Saccordingly. If one packet is lost or delayed for a long time, all subsequent packets will get stuck in the buffer. As a result, TCP layer will assume that all packets are lost, this will result in catastrophe. To avo id this, we limit the buffer size. All the packets in the buffer w ill be pushed up once the buffer is full. In our prototype, we set the maximum buffer size to 100packets. 4.3 MPTCP over MPIP MPTCP exploits the multipath gain at the transport layer. A MPTCP session employs multiple subﬂows, each of which is a legitimate TCP connection over a single IP path. When MPTCP runs over MPIP, each TCP subﬂow can now uti lize multiple paths. For the example in Figure 1, a MPTCP session can have 4subﬂows. MPIP will treat each subﬂow as an independent TCP session, and will create 4paths for each subﬂow. As a result, there are totally 4sessions and 16 8paths managed by MPIP. Now MPTCP and MPIP work to gether to adapt the trafﬁc allocated to each path. When con gestion accumulates on one path, MPIP will ﬁrst notice the high queuing delay on that path, reduce the path weight and shift packets to less congested paths. The load balancing co n ducted by MPIP at the network layer makes the congestion variations along different paths less perceivable for MPTC P subﬂows so that MPTCP can make better use of subﬂows to achieve higher throughput. We will demonstrate this using MPTCP+MPIP experiments in Section 5.1.1. 5 PERFORMANCE EV ALUATION To evaluate the performance of the proposed design, we im plement MPIP in Linux kernel 3.10.11in Ubuntu system. The prototype is designed for IPv 4. The main functionality is implemented in three new ﬁles with more than 5,000lines of code. We modiﬁed “ip_input.c” and “ip_output.c” under IPv4folder to embed MPIP features into the existing TCP/IP stack. MPIP is also implemented into Android system 6.0.1 with kernel version 3.10.73. For all TCP experiments, we use CUBICTCP [7]. MPTCP version 0.92is used in our evalua tion. We use Iperf/Iperf3 to generate trafﬁc. 5.1 Controlled Lab Experiments In our lab, we install the prototype on two desktop comput ers, which are connected directly to a router. Each desktop has two100Mbps NICs, leading to 4paths with aggregate ca pacity of 200Mbps. We use tc (trafﬁc control) tool in Linux to control bandwidth and delay on each path. 5.1.1 TCP over MPIP . To test the effectiveness of MPIP loadbalancing, we enable only two parallel paths between the two desktops so that they don’t share any NIC to prevent trafﬁc coupling. To make it more intuitive, we limit the band  width of path 1to40Mbps and path 2to20Mbps. From the throughput trend in Figure 4(a), both paths converged close to their capacities and remained stable for the whole experi  ment. Next we compare path failure response time of TCP over MPIP and MPTCP over IP. In Figure 4(b), bandwidth of both paths are set to 40Mbps. In the middle of the experiment, we disconnect one path by unplugging the cable from one NIC to emulate path failure. Both MPIP and MPTCP shift trafﬁc to the surviving path quickly. However, when we plug in the cable after 40seconds, MPTCP always suffers a 10 20seconds delay to reestablish the subﬂow at the transport layer. Different from MPTCP, MPIP promptly detects the re activated NIC at the network layer and establishes a new IP path to ramp up the throughput. Multipath transmission is vulnerable to outoforder pack et delivery. To test the effectiveness of MPIP’s packet reorde r ing mechanism, we inject extra 10ms propagation delay topath1and2ms delay to path 2through the network emula tortc. In 4(c), with MPIP reordering disabled, TCP performs poorly with the average throughput around 50Mbps, and a large number ( 3,353) of retransmissions are detected. To the contrast, when MPIP reordering is enabled, TCP throughput is stable and approaches the aggregate capacity of the two paths, and no packet retransmission is detected. As mentioned in Section 4.3, MPIP should be compati ble with MPTCP. Three groups of experiments are conducted for different combinations of multipath transmission at tr ans port and network layers, namely, MPTCP/IP, TCP/MPIP, and MPTCP/MPIP. For the ﬁrst group (normal), two available paths with 40Mbps bandwidth each are conﬁgured; for the second group (extra delay), an extra 10ms delay is added to path1; at last, bandwidth of path 1is limited to 20Mbps. In Figure 4(d), the boxplots for throughputs of all combina tions are plotted. MPTCP/IP throughput is stable and close to the capacity in all cases. TCP/MPIP and MPTCP/MPIP throughputs are little lower but still close to the capacity . Their throughput variances are close larger than MPTCP. Thi s demonstrates that the interaction between MPIP load balanc  ing and upper layer congestion control needs further study and ﬁnetuning. 5.1.2 UDP over MPIP . To evaluate how UDPbased ap plications, such as Real Time Communications, can beneﬁt from MPIP, we run WebRTC video chat over MPIP and col lect applicationlevel performance by capturing the stati stics windows of WebRTCinternals embedded in Chrome, then extracting data from the captured windows using WebPlot Digitizer [8]. We ﬁrst conﬁgure two IP paths between two lab machines without bandwidth limit, and then run WebRTC video call between the two machines. To test the robustness of MPIP against path failures, one path is disconnected in the middle of experiment. As illustrated in Figure 5, if We bRTC video chat is running over legacy IP, when the original path is disconnected at 72 second, video throughput drops sharply in Figure 5(a), video freezes for few seconds be fore video ﬂow migrates to the other path. This demonstrates that while WebRTC can recover from path failure at the ap plication layer, its response is too sluggish and user QoE is signiﬁcantly degraded by a few seconds freezing. With MPIP, video streams continuously without interruption. In addition, to demonstrate how WebRTC beneﬁts from MPIP multipath throughput gain, we limit the bandwidth of each path to1Mbps. Comparison presented in Figure 5(b) illus trates that with the help of MPIP, WebRTC video through put improves from 600Kbps to1200 Kbps. We then introduce additional delays of 50ms and80ms to the two paths respec tively. MPIP then use singlepath mode to route audio pack ets to the path with shorter delay, while video packets are routed using allpaths mode. Figure 5(c) shows clearly that 9Seconds0 10 20 30 40 50 60Mbps 020406080 Path 1 Path 2 Total (a) Load BalancingSeconds20 40 60 80 100 120Mbps 4050607080 MPIP MPTCP (b) Path Throughput under failureSeconds0 10 20 30 40 50 60Mbps 020406080 with reordering w/o reordering (c) MPIP ReorderingNormal Extra Delay Bandwidth Limit50607080 MPTCP MPIP MPIP & MPTCP (d) MPIP and MPTCP Figure 4: TCP over MPIP Performance Seconds0  20 40 60 80 100 120Mbps 00.511.522.53 with MPIP w/o MPIP (a) Video Rate under Path FailureSeconds0  20 40 60 80 100 120Kbps 400 600 800 100012001400 with MPIP w/o MPIP (b) Video Rate under Bandwidth LimitSeconds0  20 40 60 80 100 120ms 20406080100 with Customized Routing w/o Customized Routing (c) WebRTC Audio DelaySeconds0  20 40 60 80 100 120FPS 242628303234with Customized Routing w/o Customized Routing (d) WebRTC Video Frame Rate Figure 5: WebRTC Performance over MPIP: (a)(b), allpaths m ode; (c)(d), singlepath for audio, allpaths for video. Figure 6: MPIP works with YouTube through Proxy audio delay is reduced by 30ms while the video quality is not affected as illustrated in Figure 5(d). 5.2 Internet Experiments Besides the controlled lab experiments, we also conduct ex periments on the Internet to evaluate MPIP’s compatibility with real applications and various middle boxes, e.g. NAT routers, inside ISP and CSP networks. 5.2.1 Y ouTube Video Streaming. Firstly, we measured YouTube video performance to see whether video stream ing applications can beneﬁt from MPIP. Since it’s not easy to install MPIP on YouTube servers, we conﬁgure a MPIP proxy using Squid on Ubuntu. Three NICs are installed onthe proxy server. As illustrated in Figure 6, one NIC is con nected to Internet, and the other two are connected to a MPIP client machine with two paths in an emulated network. While YouTube can run over Google’s Quick UDP Inter net Connections (QUIC) protocol, but the Squid proxy does not support QUIC. In our experiments, YouTube still runs over HTTP/TCP. The minimum throughout required to stream a720P resolution video is no less than 2.5Mbps and that for 1080 P is4.5Mbps. We limit the bandwidth of each path to 3Mbps so that the aggregate capacity is sufﬁcient for YouTube 1080 P video. We enable YouTube adaptive streaming where video quality is determined automatically based on the net work condition. Figure 7(b) shows that initial video reso lution will always be conﬁgured to 720P even if MPIP is running to provide 6Mbps aggregation bandwidth. However, with MPIP, YouTube can quickly build up the video preload buffer, see 7(a). When the preload buffer length exceeds 50 seconds, YouTube increases video resolution from 720P to 1080 P around30seconds into the experiment. At the 60th sec ond, we manually fastforward the video outside the preload buffer coverage, then video resolution in both cases drop on e level down and recover back to the previous level about 20 seconds later. Video frame rate can be sustained at 30FPS 10Seconds0  20 40 60 80 100 120Seconds 0102030405060 with MPIP w/o MPIP (a) Video Buffer HealthSeconds0  20 40 60 80 100 120Resolution 4807201080 with MPIP w/o MPIP (b) Video ResolutionSeconds0  20 40 60 80 100 120FPS 05101520253035 with MPIP w/o MPIP (c) Video Frame RateSeconds0  20 40 60 80 100 120Kbps 0100020003000400050006000with MPIP w/o MPIP (d) Video Throughput Figure 7: Youtube Video Adaptation with MPIP Client Seconds0  30 60 90 120 150 180Seconds 020406080 Compete PhaseCoordinate PhaseVideo only Phase (a) Video Buffer HealthSeconds0  30 60 90 120 150 180Kbps 0100020003000400050006000 Compete PhaseCoordinate PhaseVideo only Phase (b) Video ThroughputSeconds0  30 60 90 120 150 180FPS 051015202530 Compete PhaseCoordinate PhaseVideo only Phase (c) Video Frame Rate Figure 8: Youtube 720p Video performance with Application C oordination except when the fastforward happens (Figure 7(c)). And as long as the preload buffer length goes over 40seconds, YouTube video client will pause video chunk request from the server. This explains frequent MPIP throughput dips in Figure 7(d). Video playback is smooth due to preload buffer. 5.2.2 Coordination between Applications. Applications running on the same machine compete for network resources. In this part, we demonstrate that MPIP can select paths for ap  plications in a coordinated fashion to maximize the aggrega te performance. We reused the testbed in Figure 6 with 2Mbps bandwidth limit for each path and introduced 20ms extra de lay to one path. Experiments were conducted in three phases with MPIP enabled all the time. At the beginning, besides the YouTube video session, another ﬁle downloading session is added to transmit data from MPIP proxy server to client. Initially MPIP operates in the allpaths mode and establishes two paths for each session to acquire more bandwidth. Due to the path delay difference, outoforder packet deliveri es limit the TCP throughput for both sessions. Sixty seconds into the experiment, MPIP applies coordinated routing for the two sessions: both sessions are routed using the single path mode, with the video session assigned to the path with shorter delay and the ﬁle downloading session assigned to the other path. As illustrated in Figure 8, coordinated rout ingsigniﬁcantly improve the performance of the video session: video throughout increases by 400Kbps (from 1,500Kbps to 1,900Kbps), value of FPS stabilizes around 20without freez ing, and buffer length accumulates to 10seconds. Meanwhile, the average throughput of the downloading session drops from2.51Mbps to1.89Mbps. Since users are more sensitive to video quality than the ﬁle downloading throughput, the co  ordinated routing presumably improves the overall user ex perience. Sixty seconds later, we terminated the download ing session. From Figure 8(a), 8(b) and 8(c), we observe that both the video throughput and preload buffer length increas e signiﬁcantly, while FPS of the video doesn’t change much. Longer preload buffer length leads to more stable video play  back. 5.3 Android Experiments We use a Nexus 5X phone located in California to test An droid MPIP. The phone is equipped with one cellular inter face and one WiFi interface. We use it to download data from a server located in New York City with one public IP address. We ﬁrst connect the phone to a corporate ISP through WiFi and AT&T CSP through 4G cellular. Without MPIP, the phone can achieve average bandwidth of 4.5Mbps 11Seconds0 10 20 30 40 50 60Mbps 02468WiFi AT&T Cellular Total (a) WiFi and CellularSeconds0 10 20 30 40 50 60Mbps 02468TMobile Hotspot AT&T Cellular Total (b) Two Cellular Networks Figure 9: MPIP over Wireless through WiFi and 4.3Mbps through cellular respectively. The average RTTs of WiFi and cellular are 76.2ms and155.9ms. When MPIP is enabled, as illustrated in Figure 9, Android MPIP can concurrently transmit data on both paths going through different ISP/CSP and reach aggregate throughput of7.5Mbps in the face of large delay disparity. Next we re place the corporate WiFi router with a hotspot hosted by an other phone connected to TMobile cellular network. As all data through the hotspot are forwarded by another phone, the average RTT on the TMobile path increases dramatically to 349.2ms and the average bandwidth is only 1.52Mbps. Figure 9(b) demonstrates that even when one cellular path has bad performance, MPIP still manages to multiplex bandwidth fro m two CSPs to achieve higher aggregate throughput. 6 RELATED WORK "
226,Enabling Adaptive Rate and Relay Selection for 802.11 Mobile Ad Hoc Networks.txt,"Mobile ad hoc networks (MANETs) are self-configuring wireless networks that
lack permanent infrastructure and are formed among mobile nodes on demand.
Rapid node mobility results in dramatic channel variation, or fading, that
degrades MANET performance. Employing channel state information (CSI) at the
transmitter can improve the throughput of routing and medium access control
(MAC) protocols for mobile ad hoc networks. Several routing algorithms in the
literature explicitly incorporate the fading signal strength into the routing
metric, thus selecting the routes with strong channel conditions. While these
studies show that adaptation to the time-variant channel gain is beneficial in
MANETs, they do not address the effect of the outdated fading CSI at the
transmitter. For realistic mobile node speeds, the channel gain is rapidly
varying, and becomes quickly outdated due the feedback delay. We analyze the
link throughput of joint rate adaptation and adaptive relay selection in the
presence of imperfect CSI. Moreover, for an 802.11 network that employs
geographic opportunistic routing with adaptive rate and relay selection, we
propose a novel method to reduce the effect of the feedback delay at the MAC
layer in the presence of Rayleigh fading. This method exploits channel
reciprocity and fading prediction and does not require significant modification
to the existing 802.11 frame structure. Extensive network simulations
demonstrate that the proposed approach significantly improves the throughput,
delay, and packet delivery ratio for high mobile velocities relative to
previously proposed approaches that employ outdated CSI at the transmitter.","Rapid node mobility in MANETs can result in dramatic  channel variation, or fading, that degrades link lifetime and  network throughput [1]. Routing and MAC protocols that  exploit fading channel stateinformation (CSI) at the  transmitter ha ve the potential to improve upon conventional  routing protocols and have attracted the attention of  researchers , e.g. [ 27]. These methods explicitly incorporate  the fading signal strength to select the route or next hop with strong channel condit ions. Combine d adaptive routing and   adaptive rate selection was investigated in [ 36]. While these  studies show that adapting to the time variant channel gain is  beneficial in MANETs, most do not focus on the effect of outdated CSI at the transmitter.   Channel aware r outing and MAC approaches can be  viewed as a subclass o f adaptive transmission techniques   where  the transmitted signal varies with fading and multiple  access interference. T o realize the potential of adaptive transmission, the transmitter needs accurate CSI for the  upcoming transmission frame. The CSI is usual ly estimated at  the receiver and fed back to the transmitter. However, unless  the mobile speed is very low, the estimated CSI cannot be used directly to select the parameters of adaptive transmission  systems since it quickly becomes outdated due to the rapid  channel variation caused by multipath fading. To enable adaptive transmission for mobile radio systems, prediction of  future fading channel samples has been investigated  [8].  While fading prediction was extensively studied for cellular  radio systems, it  has only recently attracted the attention of  researchers in the ad hoc networking l iterature, e.g. to  improve the interface between the physical and the MAC layer [ 911] and to enable channel aware routing [ 12].  However, the prediction algorithms impleme nted or assumed  in these papers are based on the predictors employed in the  cellular radio research  and are  not realistic. W hile the  accuracy/performance/complexity trade offs of prediction  enabled adaptive transmission are well understood in cellular  systems, these results are not indicative of the throughput,  delay, outage probability, packet delivery ratio, etc. of  channel adaptive MANET protocols. Fading prediction  techniques for MANETs need to take into account the   network topology, multiple network la yers, moving receivers  and transmitters, packet based transmission, noise, and  interference. Moreover, prediction errors, and imperfect CSI  in general, should be taken into account in the protocol design and analysis.   In this paper, we investigate adaptive rateandrelay  selection for the IEEE 802.11 network  with Greedy Perimeter  Stateless Routing (GPRS) [ 13]. A progress throughput  product metric was employed  in [4]. This metric favors next  hop relays with strong  instantaneous link power and good  progress to the destination. Significant throughput degradation was demonstrated in [ 4] for fast vehicular speeds  due to the outdated CSI caused by the feedback delay from the candidate relay nodes. In this paper, we develop a method  to reduce the CSI delay significantly by exploiting channel reciprocity possible in the IEEE 802.11 systems due to half  duplex transmission. The CSI error is further reduced using fading prediction . The effect of outdated CSI is analyzed  analytically, and OmNet ++ [14] simulations are employed to  demonstrate  the impact of the proposed CSI reduction on the   network throughput and endtoend delay .   This research  was supported by the ARO grant W911NF 1010394 and NSF  grant CNS 1018447 . 2   II. CHANNEL ADAPTIVE RATE AND RELAY  SELECTION   Our system is  based on the adaptive rate andrelay selection  protocol  described in [ 4]. It employs the IEEE 802.11b  Distributed Coordination Function  (DCF ) at the MAC layer  and Greedy Perimeter Stateless Routing (GPSR) proto col [13]  at the routing layer . The routing protocol selects up to  L next hop relay candidates by averaging the Signal to Interference andNoise Ratio (SINR)  from the received HELLO messages  of the neighboring node s, broadcast at intervals of 1.5 seconds  by all the nodes . The routing layer then passes the information  of the next hop re lay candidates to the MAC layer,  which   transmits a  Multiple Request ToSend (MRTS) packet t o the  nexthop candidates , as illustrated in Figure 1 . If this request  is successfully received, and the relay is available to receive a  packet, it responds with a clear tosend (CTS)  packet , which  contains  its position information and the received  SINR . To  avoid collisions, the responses are sent  in the specified order,  and the “best” relay is then selected by the transmitter.    To make relay selections at the routing and MAC layers,  the progress throughput product metric is computed as   {},max ( ) lli lliZλγ        (1)   where il is the data rate for  the relay l=1…L (L is the total  number of next hop relay candidates), γ l is the SINR of the  relay link l, () lilλγ  is the expected thr oughput to relay l  at  data rate i l, and Zl is the progress offered by to relay l towards  the destination. The above routing metric aims to achieve a  balance by selecting routes that provide the best tradeoff between packet progress and link throughput.   III. LINK PERFORMANCE  ANALYSIS FOR  IMPERFECT   CSI  In a fixed rate system, one of the four available data rates in  the IEEE  802.11b physical layer  is employed , i.e. 1, 2, 5.5,  and 11 Mbps. T he average throughput for Rayleigh fading  channels using data rate i  is the n given by  [4]  , 01() ()i si iP fdD∞ λ= γ γ γ∫   (2)  where ,()siPγis the probability of successfully transmitting a  packet at data rate i , Di is the duration of the transmission (in  seconds) i ncluding the acknowledgement (ACK), and ( ) exp( / ) /fγ = −γ γ γ is the probability density function  (pdf) of the SNR for the  Rayleigh fading channel , where  γis  the average SNR.  The probability of a successful packet  transmission  can be approximated as   ,,() [ 1 () ]N si bi PPγ= − γ     (3)  where,()biPγis the bit error probability at SNR γ and data rate  i, and N  is the total number of bits to be transmitted including  ACK.    The performance of the rate andrelay adaptive metric that  maximizes the throughput in a system with L relays was  analyzed for ideal CSI  in [4]. This analysis is extended to the  imperfect CSI case below and provides insight into the  performance of t he progress andthroughput product  metric  (1). Assuming ideal CSI, the link throughput of  rateandrelay  adaptation  is [4]  , 0()max ( )si IDEALiiPfdD∞γλ = γγ ∫,  (4)  where the probability density function  of γ (the maximum  SNR among L  relays) is given by   / /1( ) (1 )L Lf ee−γ γ −γ γ −γ= −γ.  While  (4) assumes ideal CSI , to utilize adaptive rate and  relay selection  in practice , received SNR has to  be fed back to  the t ransmitter, and thus becomes outdated due to the  feedback delay.  Even with estimation and prediction, the  outdated CSI is imperfect. Th is estimation error needs to be  taken into account in the throughput computation. Assuming  the Minimum Mean Square Error (MMSE) estimate of the  actual SNR γ  given the outdate d SNR ˆγ, the throughput  of the  rateandrelay adaptive system  is   ,ˆ()ˆ( ) maxsi iiP Dγλγ= .             (5)  While the metric ( 5) is simple, it is sub optimal since it  does not employ the information about the estimation accuracy . The optimal metric is given by   , 01ˆˆ() m a x () ( | )O siiiPf dD∞ λ γ= γ γγ γ∫,  (6)  where the conditional pdf of γ given ˆγis [15],  () 0ˆ2 11ˆˆ( | ) I exp(1 ) (1 ) (1 )fγγ−γ γ = γ+γ  γ −ρ γ −ρ γ −ρ  ,  (7)  where I 0(∙) is the zerothorder modified Bessel function,  01≤ρ≤ is the cross correlation between γ and ˆγ, andγis the  average symbol SNR. Assuming unit variance for the signal power, the normalized mean square error (NMSE) σ 2 is given  by    σ2 = 1ρ      (8)  The average o ptimal and sub optimal throughput s using  adaptive rate and relay selection  are   0ˆ ˆˆ() ()OO fd∞ λ=λγ γγ∫ and   0ˆ ˆˆ() ()fd∞ λ= λγ γ γ∫,  (9)    MRTS   Address 1   Address 2   .  .  .  Address L  CTS 1   Source Addr   Position   SINR  CTS L   Source Addr   Position   SINR Forwarding   Node Candidate   Relays  .  .  .    Figure 1: Polling cu rrent position and CSI [ 4]. 3   respectively, where t he density function of ˆγfor Lthorder  relay  selection diversity  is [15,Error! Bookmark not  defined. ]    221ˆˆ (1 ) (1 ) 2ˆ() 1 (1 )L Lf ee−−γ −γ γ −σ γ −σ γ= − γ −σ  (10)  Figure 2 shows the average link throughput (in packets/  second) vs. the avera ge symbol SNR for fixed rate  systems   (2) and channel adaptive systems  with ideal CSI (4 ). These  results differ from those in [ 4] and were obtained using  the  Bit Error Rate (BER ) approximations for the 802.11b  modulation methods in [ 16,17].  In Figure 3 , we plot the  average throughput with imperfect  CSI as a function of the  NMSE for average symbol SNR = 15dB for the optimal and  the suboptimal metric s (9 ). As the N M S E  →  0 , these  equations tend to the throughput with the  ideal CSI ( 4) shown  in Figure 2 . On the other hand , as the NMSE increases the  correlation between  γ and ˆγdecreases. As a result ,  ˆ()Oλγ tends  to max ( )iiλγ ), i.e. the maximum among the  throughputs of fixed rate methods (2) for given SNR, (e.g. 5.5  Mbps  for the average SNR = 15 dB  in agreement with Figure  2). On the other hand, since ˆ0γ→ as NMSE 1→, the  suboptimal throughput ˆ()λγ  (5) tends to  zero. We observe  that the suboptimal metric has near optimal performance for  NMSE < 0.01 , but degrades rapidly beyond this threshold. In  the remainder of the paper we employ a simple suboptimal  metric   {},ˆ max ( ) lli lliZλγ   and focus on reducing the CSI error to achieve reliable  transm ission . IV. IMPROVED CSI QUALITY USING CHANNEL   RECIPROCITY  AND  FADING PREDICTION   It was demonstrated in Section III that accurate CSI is  essential to enable  adaptive rate and relay selection. In this  section, we focus on pr actical approaches for improving the  quality of the  CSI at the MAC layer.   Consider the adaptive  rateand relay selection protocol [4] at the MAC layer of  802.11 summarized in Section II . In this protocol , the next  hop relay candidates measure the SINR while receiving the  MRTS packet  and sen d it back to the sender in the CTS  packet . As the CSI is obtained during reception of the MRTS  packet,  we refer to this scheme as RTS CSI. An example  timeline of this  MRTS CTS exchange for L  = 4 next hop  candidat es is illustrated in Figure 4.  The time delay in the  measured CSI from the RTS packet to  the actual CSI during  transmission of data packet  is τMRTS = 2ms. Note that this  delay denotes the time interval by which the channel measurement gets outdated.  As L increases , this delay  increases  causing degradation in performance for higher  Doppler frequencies  [4,7].   In this paper, we propose a novel  method of CSI estimation  at the transmitter that exploits the reciprocity in the channel to  reduce the time delay by which the channel measurement gets  outdated. Due to halfduplex transmission in the 802.11  networks, both directions of transmission utilize the same  carrier frequency. Thus, the complex channel gain is identical  at a given time at both ends of the  wireless link.  The sender  can measure CSI for each potential relay link using the CTS  signal . We term this  method CTS CSI. As the CTS packets  are transmitted sequentially , the delay τ l for the lth CTS packet   can be quantified as,    τl = (L – l )(T SIFS + T CTS) + T SIFS      (11)  where T SIFS is the duration of the short inter frame space  (SIFS) interval, and T CTS is the duration of the CTS packet.   As illustrated in Figure 4, employing channel reciprocity  reduces the time delay between the measured CSI and actual  CSI by estimating the SINR during reception of the CTS  packet at the transmitter side with a peak delay of τ1 = 1.5ms 0 10 20 30 400100200300400500600700800 Average symbol SNR (dB)Average link throughput (packets/sec)    Rateandrelay Adaptation Fixed Rate2 Mbps 1 Mbps11 MbpsL = 3L = 4 L = 2 L = 15.5 Mbps   Figure 2: Average throughput vs. average symbol SNR. Fixed rate and rate  andrelay selection methods with perfect CSI. Rayleigh fading channel.    1031021010100200300400500600700 NMSEAverage link throughput (packets/sec)    Suboptimal metric Optimal metricL = 3 L = 2 L = 1L = 4 Fixed Rate (5.5 Mbps)   Figure 3: Average throughput vs. NMSE, rate andrelay selection, Rayleigh  fading with average symbol SNR = 15 dB.  4   for the first CTS packet  as compared to RTS CSI wherein the  SINR is estimated at the receiver side during reception of the  MRTS packet with a delay of τ MRTS = 2ms.  However, there is still a delay τ l for the lth CTS packet   between measuring the C SI and utilizing  it for rate andrelay  selection when transmitting the data  packet. We employ the  MMSE complex fading channel prediction [ 8] during the  reception of the lth CTS packet to predict the ch annel τl  seconds ahead in time to  compensate for this delay.   To realize the predictor, p ilot symbo ls spaced 10 data  symbols apart , are inserted in the CTS packet . Since the CTS  packet  contai ns 496 symbols at the 1  Mbps rate,  50 pilot  symbols  at rate fpred = 100 k Hz are utilized . While this pilot  rate is too high  when the objective is to overcome the  feedback delay for the frequency division duplex systems  [8],  it is sufficient in the half duplex system that employs CTS  CSI due to small delays  τl. We assume that the SNR of the  pilot symbols is 30 dB. This effective pilot SNR can be achieved using noise reduction [ 18] when the actual SNR ≈  20 dB, the value used in the network simulations in Section  V. Assuming the carrier frequency 2.4 GHz and flat Rayleigh  fading channel, Figure 5 shows the analytical mean square  error (MSE) performance of the RTS CSI ( outdated CSI  without prediction) and CTS  CSI method for  a system with  L  "
468,Route Packing: Geospatially-Accurate Visualization of Route Networks.txt,"We present route packing, a novel (geo)visualization technique for displaying
several routes simultaneously on a geographic map while preserving the
geospatial layout, identity, directionality, and volume of individual routes.
The technique collects variable-width route lines side by side while minimizing
crossings, encodes them with categorical colors, and decorates them with glyphs
to show their directions. Furthermore, nodes representing sources and sinks use
glyphs to indicate whether routes stop at the node or merely pass through it.
We conducted a crowd-sourced user study investigating route tracing performance
with road networks visualized using our route packing technique. Our findings
highlight the visual parameters under which the technique yields optimal
performance.","Visualizing several routes on a geographic map while preserving the geospatial layout of the routes is a challenging task. Routes may overlap or cross each other, merge and depart again, share the same edge but have opposite directions, and have different semantics, speeds or volumes. Many stateoftheart techniques tend to use visual or data grouping techniques—such as edge bundles [1, 2], ﬂow map layouts [3], and metro maps [4, 5]— that not only cluster entities into groups but also simplify their exact movement paths into schematic maps. Based on the same principles as Harry Beck’s tube map from 1931 [6], these techniques reduce complex paths into straight lines and organize haphazardly scattered nodes onto a regular grid to facilitate comprehension and legibility. But what if we are truly interested in the exact geospatial position and layout of a particular path? Consider a supplychain network of multiple trucks transporting goods from a distribution center to a set of receiving sites on a daily basis, such as for afast food restaurant chain. What if we need to be able to distinguish individual routes, even when they temporarily merge together on the same physical road, only to separate again? What if we need to be able to follow a route that passes several nodes (i.e., restaurants) without stopping before reaching its destination? And what if we also need to preserve the temporal order and volume of goods being transported on each individual route? What if there is a high risk of ﬂooding (or other kinds of risks) in the covered area, and the planners need to route the trucks while overlaying maps with ﬂood (or other kinds of risk) maps to mitigate the delivery risk? Distorting the nodes and routes into schematic maps in such scenarios at best slows the human decisionmaker down, and may lead to confusion or poor planning. These additional constraints conﬂict with the visual and data aggregation techniques reviewed above, highlighting that current techniques are illequipped to handle situations in which the geospatial layout provides indispensable geographic context. Compared to schematic maps (e.g., metro maps [4, 5]), geospatiallyaccurate maps (henceforth referred to as geoaccurate) preserve the exact geographic location of entity paths and are thus more understandable to humans. For instance, London Underground publishes a geoaccurate metro map [7], particularly after Guo [8] estimated that up to 30% of London travelers take wrong routes with the schematic metro map. Geoaccurate maps can be particularly important for tasks where location is critical to decisionmaking. For example, supplychain companies monitor road conditions of speciﬁc locations when a hurricane may block their delivery routes [9]. Similarly, Google Maps provides trafﬁc and accident locations on the map (for a single route) to help users select a fast and safe route. Although geoaccurate maps are important in decisionmaking, research on how such maps can be best visualized remains limited, especially on visualizing several routes. In this paper, we present a novel technique for geoaccurate visualization of routes called route packingarXiv:1909.10173v1  [cs.HC]  23 Sep 2019(A)(A) (B)(B)Figure 1. Route packing for a supplychain network consisting of multiple individual routes (distinguished by categorical color encoding). Routes that share the same road for part or all of their stretch are packed rather than merged into a single line, preserving their identity. Glyphs on routes and on nodes indicate the direction of the route and whether they pass or stop at a specic node. (Figure 1) that groups multiple routes sharing the same geographic space sidebyside without bundling them (while minimizing crossings), thereby preserving the identity of each individual route. While similar to metro maps [5], route packing does not simplify routes into straight or diagonal lines, but instead preserves their length, direction, and geospatial layout, making it useful for logistics planning and applications where geographic context is important. The route packing algorithm is sufﬁciently ﬂexible to encode volume (such as amount of goods, trafﬁc, or cost) into the width of the graphical line representing each route. To indicate whether a route stops at a speciﬁc node or merely passes it by, we use glyph decorations on nodes. Route packing is appropriate for visualizing 1020 routes simultaneously (typical of supplychain planning scenarios), enabling decision makers to compare the routes while preserving geographic context. Figure 1 presents an exemplar supply chain network from a fast food company, with ﬁve trucks delivering products to 20 stores, where each truck stops at 5–9 stores. We also evaluate our route packing technique using a crowdsourced user study involving more than 100 participants. Since no directlycomparable visualization technique exists in the literature, we opted to measure user performance using variations in route packing design. We applied the design choices proposed byHolten et al. [10, 11] for visualizing directed nodelink diagrams to route packing, comparing visual perception for arrows, tapered routes, and transparency. Our ﬁndings show that redundant encoding using both arrows and tapered lines resulted in the best performance for tracing routes in the network. 2. Related Work "
55,A mechanized proof of loop freedom of the (untimed) AODV routing protocol.txt,"The Ad hoc On-demand Distance Vector (AODV) routing protocol allows the nodes
in a Mobile Ad hoc Network (MANET) or a Wireless Mesh Network (WMN) to know
where to forward data packets. Such a protocol is 'loop free' if it never leads
to routing decisions that forward packets in circles. This paper describes the
mechanization of an existing pen-and-paper proof of loop freedom of AODV in the
interactive theorem prover Isabelle/HOL. The mechanization relies on a novel
compositional approach for lifting invariants to networks of nodes. We exploit
the mechanization to analyse several improvements of AODV and show that
Isabelle/HOL can re-establish most proof obligations automatically and identify
exactly the steps that are no longer valid.","Mobile Ad hoc Networks ( MANETs ) and Wireless Mesh Networks ( WMNs) are selfconﬁguring wireless networks for mobile devices. Their nodes are reactive systems that cooperate to pass data packets from one node to another towards each packet’s ultimate destination. This global service must satisfy certain cor rectness properties—for example, that data packets are never sent in circles. Proofs of such properties tend to be long and complicated, often involving many case distinctions over possible messages sent and combinations of Boolean pred icates over internal data structures. For example, the only prior existing proof1 of loop freedom of the Ad hoc Ondemand Distance Vector ( AODV) routing protocol—one of the four protocols currently standardized by the IETF MANET working group, and the basis of new WMN routing protocols such as HWMP in the IEEE 802.11s wireless mesh network standard [14]—is about 18 pages long and requires around 40 lemmas to prove the ﬁnal statement [8]. This proof is based on a processalgebraic model. Mechanizing process calculi and processalgebraic models in an Interactive Theorem Prover ( ITP) like Isabelle/HOL [20] can now almost be considered routine [1, 9, 11, 13]. However, a lot of this work focuses on process calculi 1Earlier, and simpler, proofs appear in [2,22] and [26], but none of them is complete and valid for AODVas standardized in [23]. We justify this statement in Section 9.arXiv:1505.05646v1  [cs.NI]  21 May 20152 T. Bourke, R.J. van Glabbeek, and P. Höfner themselves—for example, by treating variable binding [1] or proving that bisimu lation is a congruence [11,13]. While the study of security protocols has received some attention [7], comparatively little work has been done on mechanizing the application of such calculi to the practical veriﬁcation of network protocols. In this paper, however, we focus on an application and mechanize the proof of loop freedom of AODV, a crucial correctness property. Our proof uses standard transitionsystem based techniques for showing safety properties [15,16], as well as a novel compositional technique for lifting properties from individual nodes to networks of nodes [4]. We demonstrate these techniques on an example of signiﬁcant size and practical interest. The development described in this paper builds directly on the aforemen tioned model and penandpaper proof of loop freedom of AODV[8]. While the process algebra model and the ﬁne details of the original proof are already very formal, the implication that transfers statements about nodes to statements about networks involves coarser reasoning over execution sequences. Our mecha nization simpliﬁes and clariﬁes this aspect by explicitly stating the assumptions madeofothernodesandbyreformulatingtheoriginalreasoningintoaninvariant form, that is, by reasoning over pairs of states rather than sequences of states. Given that a proof already exists and that mechanization can be so time consuming, why do we bother? Besides the added conﬁdence and credibility that come with having even the smallest details fastidiously checked, the real advan tage in encoding model, proof, and framework in the logic of an ITPis that they can then be analysed and manipulated (semi)automatically. Section 8 describes howweexploitedthisfacttoverifyvariationstothebasicprotocol,andSection9 argues that such models aid review and repeatability. We expect that the work described will serve as a convenient and solid base for showing other properties of the AODVprotocol and studying other protocols, and, eventually, to serve as a speciﬁcation for reﬁnement proofs. Finally, although any such work beneﬁts from the accumulation of technical advances and engineering improvements to ITPs, we argue that it cannot yet be considered routine. The paper is structured as follows. In Section 2 we informally describe the AODVprotocol. Section 3 brieﬂy states the theorem of loop freedom of AODV in the form given to Isabelle/HOL. The following three sections explain the meaning of this statement: Section 4 describes how the model of AODVin the process algebra AWN(Algebra for Wireless Networks) [8] is translated into Is abelle/HOL; Section 5 describes the formalization of network properties such as loop freedom; and, Section 6 explains our formalization of invariance of network properties. Section 7 summarizes how we proved the theorem in Isabelle/HOL. Section 8 describes several improvements of AODV, proposed in [8], and illus trates the use of Isabelle/HOL in proving loop freedom of these variants. Once the original proof has been mechanized, Isabelle/HOL can reestablish most proof obligations for these improvements automatically, and identify exactly the steps that are no longer valid and that need to be adjusted. A detailed discussion of related work follows in Section 9, followed by concluding remarks. There is only space to show the most important parts of our mechanization of the process algebra AWNand of the model of AODV. Comparing these partsA mechanized proof of loop freedom of AODV 3 A sn=2B sn=1 D sn=1C sn=1 dip dsn dsk flag hops nhip precrtA:dip dsn dsk flag hops nhip prec rtB: dip dsn dsk flag hops nhip prec rtC: dip dsn dsk flag hops nhip precrtD:A 2 kno val 1 A ∅ A 2 kno val 1 A ∅B 0 unk val 1 B ∅ D 0 unk val 1 D ∅B 0 unk val 1 B ∅ A 2 kno val 2 B ∅C 1 kno val 1 C {A} C 1 kno val 2 B ∅ Fig.1: Example AODVinstance. before [8, §§4–6] and after mechanization in Isabelle/HOL, should give suﬃcient clues about the remaining parts. By focusing mainly on the application (loop freedom of AODV), we only show a glimpse of our proof method. A compan ion paper [4] presents the technical details of the mechanization of AWNand the associated framework for compositional proof. Source ﬁles of the complete mechanization in Isabelle/HOL are available online [5]. 2 The AODV routing protocol The purpose of AODV[23] is to route data packets between nodes. Figure 1 shows an example network with four nodes addressed A,B,C, andD. Each node maintains a local sequence number (sn) and arouting table (rt). Imagine that the former are all set to 1, that the latter are all empty, and that Awants to send data to C. No route is known, so Aincrements its snto 2 and broadcasts a Route Request ( rreq) message to its neighbours BandD. Both neighbours immediatelyaddaroutingtableentrywiththe destination address (dip)asA,the destination sequence number (dsn) as 2, as sent by A, thedestinationsequence number status (dsk) as ‘known’ ( kno), theroute status (ﬂag) as ‘valid’ ( val), the number of hops to the destination (hops) as 1, the next hop address (nhip) asA, and an empty set of precursors (nodes known to be interested in this route). Since neither BnorDhas a routing table entry for C, they both in turn forward the rreqmessage to their neighbours, which causes Ato add entries forBandD, andCto add an entry for B. Since (forwarded) rreqs only include thesnof the originating node— Ain this case—the dsnanddskﬁelds of these new entries are set to 0 and ‘unknown’ ( unk), respectively. Node Calso adds an entry for Ato its routing table, with hop count 2 and next hop B. SinceCis the destination, it replies to the request with a Route Reply ( rrep) message, which is destined for Aand unicast to B. On receipt, Bupdates its rtwith a route toC(adding Aas precursor) and forwards the message to A. When Areceives this message it updates its rtand starts forwarding data packets to CviaB. All established routing table entries are summarized in Figure 1. Besides this basic scenario, AODValso supports early generation of rrep messages by ‘intermediate nodes’ [23, §6.6.2]: whenever an intermediate node has information about a route to the destination, rather than forwarding the4 T. Bourke, R.J. van Glabbeek, and P. Höfner rreqmessage, it generates an rrepmessage and sends it back to the originator of the rreqmessage. AODValso supports Route Error ( rerr) messages for invalidating routes (sent to the ‘precursor nodes’ associated with each entry). AODVfeatures various timing requirements to expire packets and entries, and to limit sending rates, as well as optional extensions, such as ‘gratuitous rreps’ to improve bidirectional eﬃciency, and ‘local repair’ of routes on link loss. The model we mechanize includes the core functionality of AODV, but not timing details or optional features [8, §3]. 3 Loop freedom Routing protocols must continue to correctly route data even as nodes appear, disappear, and move. It is essential that they maintain loop freedom : the absence of cycles across diﬀerent routing tables. For instance, the example network would have a cycle if Dcame into range of B,Bupdated its route for Cto pass via D, andDadded a route for CviaA. Proofs of loop freedom when route replies are only generated by destination nodes are relatively subtle, but they become really delicate when intermediate nodes may also generate rrepmessages. The main result shown in our mechanization is: Theorem 1 ( AODVloop freedom). For any wellformed network term n, closed (pnet ( i. paodv ihhqmsg) n)jj=netglobal (.8dip. irreﬂ ((rtgraph dip)+)). Most of this paper is concerned with explaining the various elements of this statement and its proof in Isabelle/HOL. In sum, the variable nrepresents any well formed term describing a network instance—a term is well formed iﬀ all nodes therein have distinct addresses. It is mapped to an automaton by the functions pnetandclosed. A node with address icomprises an instance of the protocol, paodv i, reading messages from a queue process, qmsg. All reachable states of this model are shown to satisfy the formula at right of the ‘ jj=’, which (1) maps a state structured like the network term into a function from each node address to that node’s local state ( netglobal), (2) abstracts this map into a directed graph with an arc from one node to another when the former has a valid routing table entry for a given dipto the latter ( rtgraph), and ﬁnally, (3) claims that the transitive closure of each such graph is irreﬂexive. 4 Modelling AODV In Isabelle/HOL we formalize AODVfollowing the model from [8], which is expressed in a process algebra called AWN[8, §4]. In AWN, a network instance running a protocol is modelled in ﬁve layers, from the bottom up: (1) sequential processes, (2) local parallel composition at a single network node, (3) nodes of the form ip:P:Rwithipthe node’s address, Rthe set of reachable neighbours, andPthe process running on the node, (4) partial networks of nodes, and, (5) networks closed to further interaction. The behaviour of each layer is deﬁned by Structural Operational Semantics ( SOS) rules over either process terms or lower layers. By including initial states, the ﬁrst layer deﬁnes an automaton andA mechanized proof of loop freedom of AODV 5 p1p2call(pn) {l} [ [u] ]p {l}hgip {l}unicast(s ip, smsg).p.q {l}broadcast(s msg).p {l}groupcast(s ips, smsg).p {l}send(s msg).p {l}receive(u msg).p {l}deliver(s data).p (a) Term constructors for (’s, ’p, ’l) seqp . ’ = u ((, {l}[ [u] ]p),, (’, p))2seqpsos"
64,Five-Nines Reliable Downward Routing in RPL.txt,"After a decade of research in low-power data collection, reaching arbitrary
nodes has received comparatively little attention. The leading protocol for
low-power IPv6 routing, RPL, is no exception, as it is often studied in
multipoint-to-point scenarios. As a result, downward routing (from root to
node) is still notoriously difficult, holding back the emergence of Internet of
Things applications that involve actuation. In this paper, we focus on
achieving industrial-grade reliability levels (1e-5 failure rate) in downward
routing with RPL. We make every packet count, and classify the different causes
of packet loss. We show how to mitigate each source of packet loss, by (1)
introducing a gradient metric that favors reliable links, (2) increasing
neighborhood awareness for accurate link selection, and (3) ensuring a robust
routing state maintenance and packet forwarding. We demonstrate RPL downward
routing with loss rates in the order of 1e-5 in four different testbeds up to
352 nodes, in both sparse and dense settings. We also validate our solution on
top of a low-power TSCH scheduler, and achieve sub-percent low duty cycles and
a channel utilization of 0.07% at every node, spread over 16 channels.","As the ﬁeld of lowpower wireless communication ma tures, the focus started shifting from besteffort to reli able communication. Industrial monitoring applications now routinely achieve at least ﬁve nines of reliability (99.999%, or 1e5 failure rate) [10, 11]. Such a level of reliability, if brought to the broader Internet of Things realm, would enable a whole new class of applications, where communication success is the norm. Interactive systems, control loops and reliable ﬁle transfer would all beneﬁt from a more robust infrastructure. We focus on IETF’s lowpower IPv6 stack, in partic ular 6LoWPAN, RPL, and 6TiSCH, which is a leadingset of standards for the interoperable Internet of Things (IoT). Such lowpower IPv6 networks are gaining mo mentum because of their openness, and application ag nosticism. They also bring addressable hosts, which caters for a broad range of scenarios, where nodes from different vendors can connect as IP hosts and interact via applicationlayer protocols on top. Reliability is also critical for these applications, increasing user conﬁdence in the technology. After years of research and industrial advances, low power data collection can now be done reliably, be it with RPL [16] or other routing protocols [10, 23, 15]. Floodingbased solutions [19, 35, 27] achieve a high re liability by eliminating the need for routing, but they are not ideallysuited for lowpower IPv6, as discussed inx6. Downward routing (from root to node), on the other hand, remains a challenge [3, 26]. In RPL, down ward routing with loss rates in the range of 1e3 ( three nines ) has been reported [16]. While this may be sufﬁ cient for some applications, it is two orders of magnitude off the 1e5 goal. Reaching a failure rate of 1e5 requires to make ev ery packet loss count. Through tracedriven simulations and largescale experiments, we identify the different threats to packet delivery in RPL downward routing. We conﬁrm a number of known causes of loss such as link asymmetry and link probing issues, but also identify and tackle new ones, e.g., the inherent reliability limitations of ETX or the inconsistent routing state problem. We ﬁnd that to enable robust routing, one needs a rout ing metric geared towards reliability and link symmetry rather than a besteffort metric such as ETX. Second, we show that such a metric is of no use without an accurate view of the wireless environment at every node, and pro pose a link probing mechanism that allows RPL nodes to maintain fresh link estimates and keep the topology reliable at all times. Third, once a reliable metric and probing are in place, routing state inconsistencies turn out to be the reliability bottleneck. While this probarXiv:1710.02324v1  [cs.NI]  6 Oct 2017lem does not affect upward routing where nodes sim ply forward to their current parent, it is detrimental to downward routing. We advocate source routing through RPL’s nonstoring mode as a mitigation strategy to this problem. Finally, a factor that was negligible before be comes the main cause of packet loss: the IEEE 802.15.4 duplicate detection mechanism, based only on 8bit se quence numbers, causes occasional spurious drops (at a rate of about 1e4). By eliminating this source of losses we achieve downward routing in several testbeds (sparse and dense, and up to 352 nodes) with a loss rate in the range of 1e5 and below. This paper makes the following contributions: We conduct an indepth analysis of all causes of packet loss in RPL downward routing; Via tracedriven simulations and testbed experiments, we characterize different relevant aspects, such as how link metrics affect reliability and asymmetry, or the degree of inconsistency in the routing state; We present a set of reliability mechanisms that elimi nate or mitigate all causes of packet losses by (1) gear ing topology construction towards reliable downward routing and (2) increasing the consistency of both link estimates and the routing state; We present a thorough experimental evaluation of RPL, where we demonstrate loss rates below 1e5. The evaluation involves four testbeds up to 352 nodes, both sparse and dense. It includes results with a low power TSCH scheduler. We report on 850 onehour experiments, one 2week deployment, and in total over 12 million packets sent endtoend. 2 State of the Art Lowpower Wireless Networking Many protocols for lowpower wireless networks build a gradient anchored at a root, typically used as the sink of a data collection network. Examples of such include CTP [23], Dozer [4], ORW [36] or OppCast [37]. Traditionally, the focus is energyefﬁciency, latency, and reliability. Reliability in the range of 90% to 99% is regarded as sufﬁcient in a besteffort context. The domain of industrial automation is more focused on guaranteed performance, with reliability as a ma jor goal. Solutions such as TSMP, WirelessHART or TSCH (part of IEEE802.15.42015 [24]) enable solid lowpower mesh networks with high reception rates [45]. For instance, Pottner et al. achieved 99.95% reliabil ity in a 15node testbed [40], Pister et al. reported 99.97% to >99.99% reliability [39], while Doherty et al.demonstrated 99.9995% delivery over 49 nodes [10]. The works above focus exclusively on data collection, while we tackle reliable routing to arbitrary nodes.Data dissemination protocols such as Drip/CodeDrip [29] or Pando [12] were proposed, that disseminate a payload from the sink to all nodes. These focus on efﬁcient ﬂooding, sometimes with network coding and other techniques, rather than on establishing onetoone routes. On the other hand, bulk transfer protocols such as Flush [32], PIP [41] or BF [17] focus on reliable forwarding over an existing path; these are orthogonal to the routing protocol. A radically different approach was introduced in 2011 with Glossy [20], a network ﬂooding primitive that ex ploits constructive interference. LWB [19] was then designed to support multiple trafﬁc patterns on top of Glossy. The approach is appealing as it rules out the need for a routing protocol – instead, all packets are sent re peatedly over the entire network. LWB achieves delivery ratios in the range of 99.98%. Even higher delivery ra tios were recently reported by Crystal [27]. These proto cols, however, work best as integrated solutions, and are not geared towards IPv6 networks with generally larger payloads and interactive trafﬁc patterns, unknown at de ployment time. They also result in an inherently higher channel utilization; a disadvantage when it comes to net work coexistence. Downward Routing in RPL RPL [46], the standard protocol for lowpower IPv6, was built on ideas from CTP [23], extended with downward routing and other features. The protocol builds a gradient for upward rout ing (node to root), and uses the reverse path to route downward (root to node) and reach any node. RPL offers two distinct modes of operation: storing and nonstoring mode. In storing mode , nodes maintain routing tables locally, with enough information to reach their subtree. Packets are routed upward until reaching an ancestor of the destination, where it engages down ward routing. In nonstoring mode , the root maintains a complete view of the topology, but other nodes do not keep any routing state. Packets are routed all the way up to the root, and then sourcerouted down to the destina tion. This is done using an IPv6 sourcerouting header, which contains the path from root to destination (in a compressed form). RPL was evaluated extensively [22], with a focus on delay and throughput [1] or the repair mechanism [44]. Koet al. [34] proposed an interoperability analysis of TinyOS’ and Contiki’s RPL implementations. The paper has key insights in achieving high performance in hetero geneous environments. As far as reliability is concerned, in the aforementioned works, loss rates in the range of a few percent are generally reported. The PRL link selection is done by children towards their parent. When there is no upward trafﬁc to update link estimates, or when links are asymmetric, the link from parent to child may be compromised. This was 2observed experimentally on several occasions [33, 31]. ORPL [15] proposed to use opportunistic routing in RPL, reaching downward reliability in the 99% range. Hy dro [8] is conceptually close to RPL but with the abil ity to combine source routing with local routing tables. Current extensions of RPL are also going in this direc tion, enabling the border router to remotely manage the nodes’ routing table [43]. A complementary approach in making RPL more re liable is to exploit more robust MAC layers. MiC MAC [38] applied channel hopping to lowpower lis tening RPL networks, and reported delivery ratios of about 99%. Orchestra [16] proposed a scheduling tech nique to exploit TSCH in RPL networks. In a 98node testbed, it achieved delivery ratios of 99.997% in data collection, 99.98% in downward routing. As these are the highest delivery ratios reported on RPL so far, we select TSCH (with Orchestra) as the MAC layer for the experiments in this paper, both in trafﬁcintensive and powersaving scenarios. Note that our focus is on the layers above MAC; TSCH is only used to enable testbed experimentation under realistic settings. RPL has a number of limitations that were pointed out in the past, some of them tackled in this paper. Iova et al.[25] reported on the inherent tradeoff between sta bility and link quality, which we further characterize and mitigate with our metric. Dawans et al. [7] discussed the problem of keeping link estimates accurate, which we address with probing. An analysis of RPL by Clausen et al.[6] discusses, among other topics, link asymmetry and neighbor unreachability detection – two problems we tackle in this paper. Finally, in this paper, we eval uate a simple extension of ETX that prioritizes reliable links; other more advanced metrics [28, 30] with various performance goals could be considered in future work. To the best of our knowledge, this paper is the ﬁrst to focus on reliability in downward routing, aiming for losses in the 1e5 range (99.999% delivery). It character izes in detail the different causes of loss, some of them already wellknown, others not so much, and introduces new mitigation strategies. We also carry out the largest public experimental validation of RPL to date, in four different testbeds, sparse and dense, and up to 352 nodes. 3 Preliminary Study Goal We start by characterizing the level of reliability achieved in a stateoftheart implementation of RPL, in a largescale testbed. We instrument the communication stack to keep track of all packets with unique identiﬁers, and we log the journey of every single packet as it travels through layers and hops. We then dissect the runs ofﬂine, count losses and assign them to different causes.Cause of Loss Loss Count Loss Rate MAClayer drop 42 4e3 (0.36%) Route not found 32 3e3 (0.27%) Spurious duplicate 8 7e4 (0.07%) Total 82 7e3 (0.70%) Table 1: Preliminary Study: summary of the losses in a RPL downward routing run. Total packets sent: 11,730. Setup For our study, we select Contiki [13] since it features one of the most mature 6LoWPANRPL stacks [45]. We use the IoTLAB testbed in Grenoble, with 352 M3 nodes equipped with a 2.4 GHz 802.15.4 radio [2]. We select node 240 as the root, in the middle of the deployment. We run RPL in storing mode of oper ation, with Objective Function MRHOF and metric ETX (the default in Contiki). The RPL topology built on top yields an average radius of 6.7 hops (distance to the node that is farthest from the root). As the focus is on downward routing, we have the root send four packets per second to a randomly selected node. We need such a high trafﬁc load in order to collect enough data for statistically signiﬁcant loss rates num bers (further discussed in x5.1). All experiments are run for one hour, and we always exclude the ﬁrst 5 minutes to leave time for initial convergence. We select TSCH as the MAC layer, as it enables high levels of reliability with RPL and is readily available in Contiki [16, 14]. As the focus here is not on MAC scheduling or energy, we use the simplest possible TSCH schedule, which consists of a single shared slot in a slot frame of length 1. Nodes basically wake up at every slot (10ms) to listen or contend for transmission. We select such a schedule for its trafﬁc capacity, as we need a high load in order to collect enough data points for statistical signiﬁcance. We evaluate lowpower settings in x5.5. Results For the purpose of this preliminary study, we simply select the run that yields a median endtoend Packet Delivery Ratio (PDR). The losses in this partic ular run are summarized in Tab. 1. Overall, 99.3% of the packets were successfully routed endtoend, from root down to any node. Out of 11,755 packets sent, 82 were lost, falling into three categories: Cause #1 – MAClayer drop: the main cause of loss is when the MAC layer discards a packet after 8 failed retries (default in Contki). Note that the system is pro visioned such as it does not saturate, that is, the MAC queues (of length 24) never get full. Cause #2 – Route not found: the next loss cause is routing inconsistency, i.e., the packet reached a node that was not able to ﬁnd a route to the destination. Cause #3 – Spurious duplicate: the last cause of loss is packets classiﬁed as duplicate while they are not, 3ETXETX2ETX3ETX4LR Metric1016101410121010108106104102100E2E Loss Rate(a) ETXETX2ETX3ETX4LR Metric020406080100Link PRR (%) (b) ETXETX2ETX3ETX4LR Metric01234567Hops (#) (c) ETXETX2ETX3ETX4LR Metric020406080100120140Parent Switches (#) (d) Figure 1: Tracedriven simulation: characterization of different link metrics. The traditional metric ETX is not best when it comes to endtoend reliability. More reliable metrics, however, result in more hops and parent switches. due the IEEE 802.15.4 1 byte sequence number. In the remainder of the paper, we will show how to eliminate the second and third causes, and mitigate MAClayer drops down to 0–1 loss per experiment. 4 Design: Reliability Mechanisms We propose a number of mechanisms aimed at enhancing the reliability of the RPL mesh. We address the causes of loss identiﬁed in x3, characterize the underlying prob lems through tracedriven simulation and testbed experi ments, and introduce suitable mitigation mechanisms. We ﬁrst focus on link metrics, that is, what reliabil ity can be achieved through optimal route selection, and what is the impact of asymmetric links. This helps mit igate the ﬁrst cause of loss, MAClayer drops. Second, we turn our attention to protocol aspects to make link estimation robust at runtime, and to ensure robust route dissemination and packet forwarding. This eliminates the second and third causes of loss: inconsistent routing state and spurious duplicates. 4.1 Link Metrics and Route Reliability Problem ETX [9], the metric traditionally used to build lowpower mesh ( e.g., in RPL and CTP), is designed to optimize performance (throughput, latency, energy) rather than reliability. For instance, a hop with 50% PRR (ETX=2) will be deemed equivalent to two perfect hops (ETX=1+1=2). When reliability is the ﬁrst goal, the lat ter should be clearly preferred, as it yields an endtoend delivery ratio of 100% against 50% for the former. Formally, the endtoend delivery ratio (PDR) for a given node nis denoted: PDR (n) =Õ x2path (n)PRR x!parent (x)1+R where path (node )is the set of nodes in the path from n to the root (including nbut excluding the root), PRR x!yis the packet reception rate of the link x!y,parent (x) is the RPL parent of node xandRis the number of MAC retries. The endtoend loss rate is LR(n) =1"
243,M-BEHZAD: Minimum distance Based Energy efficiency using Hemisphere Zoning with Advanced Divide-and-Rule Scheme for Wireless Sensor Networks.txt,"Routing Protocols are engaged in a vigorous fashion to boost up energy
efficiency in WSNs. In this paper, we propose a novel routing protocol; Minimum
distance Based Energy efficiency using Hemisphere Zoning with Advanced
Divide-and-Rule scheme (M-BEHZAD), to maximize network lifespan, throughput and
stability period of the sensors deployed in an un-attended network zone. To
accomplish these objectives, static clustering technique along with threshold
conscious transmissions have been used. The robustness of our proposed scheme
lies in its Cluster Heads (CHs) selection and network field division which we
are introducing as 'Hemisphere Zoning (HZ)'. We have implemented 3-Tier
architecture to minimize the communication distance which not only leads to a
better network performance but also significantly reduces the energy and
coverage holes, and results in a longer stability period. We have also utilized
Uniform Random Model (URM) to compute packets dropped to make our scheme a more
practical approach. Results from comprehensive simulations using MATLAB
validate its applicability.","Wireless Sensor Networks (WSNs) consist of randomly  deployed and limited energy nodes that are capable of sensing  different attributes in real time and can provide efficient and  reliable communication using a microwave link. These  nodes  sense data and forw ard it to Base Station (BS) using direct  and/or multi hop communication. BS  then processes and  forwards it to the end users.  WSNs have different type of nodes  such as acoustic, underwater, seismic, visual, radar, thermal  and many others . Their application includes, but not limited to,   military, healthcare, environmental and commercial.    Optimization of energy consumption to elongate network  lifetime has been one of the hot research topics in WSNs. To  address this problem, much of the work has been done duri ng  recent years where efficient utilization of energy, by proposing  robust protocols, was the main target . Clustering is  of the  technique that’s  used to avoid inefficient use of energy.  Clustering may be dynamic or static. In dynamic clustering,  cluster and number of nodes associated with cluster vary. In  static clustering, cluster and number of nodes associated with  cluster remain fixed throughou t the network lifespan.    WSN may be either proactive  or reactive based on its nature .  In the former  case, nodes periodically switch on their sensors  and transmitters, sense the required attribute from environment  and transmit it. Thus, these are well suite d for periodic data  monitoring applications.  In the latter case 1, the sensors  respond   instantaneously  to abrupt  or extreme  changes in a specific attribute and keep t heir transmitters off otherwise. H ence, these  are suitable  for time critical applications.    Generally, s ensors in WSNs a re equipped with some am ount  of initial energies.  Based on th is amount , WSNs may be  homogenous or heterogeneous.  In homogenous networks , all  the nodes deployed in  network field have  same initial energies .  In heterogeneous network, the initial energies of some nodes  are different by a certain factor  and as a result those are called  advanced nodes . Heterogeneous senso r networks may be two  level  or multilevel .   In this paper, we propose and evaluate a  new reactive  and  less energy hunger  clustering protocol ; MBEHZAD :  Minimum distance Based Energy efficiency using Hemisphere  Zoning with Advanced Divide andRule scheme  for  heterogeneous WSNs . We utilize reactive as well as  heterogeneous characteristics of the  wireless sensor network to  ultimately prolong network lifetime.  Additionally, Hemisphere  Zoning  (HZ)  is introduced  for network field division.    Rest of the paper i s organized as follows: section II presents  the related work, while  motivation is presented  briefly  in  Section III. Section IV deals  with detailed implementation of   our proposed approach, i.e.  MBEHZAD . Simulations, results  and discussions  are explained  in Section V, and finally section  VI concludes the paper.   II. RELATED WORK  "
361,iMOD LEACH: improved MODified LEACH Protocol for Wireless Sensor Networks.txt,"Increased use of Wireless sensor Networks (WSNs) in variety of applications
has enabled the designers to create autonomous sensors, which can be deployed
randomly, without human supervision, for the purpose of sensing and
communicating valuable data. Many energy-efficient routing protocols are
designed for WSNs based on clustering structure. In this paper, we have
proposed iMODLEACH protocol which is an extension to the MODLEACH protocol.
Simulation results indicate that iMODLEACH outperforms MODLEACH in terms of
network life-time and packets transferred to base station. The mathematical
analysis helps to select such values of these parameters which can suit a
particular wireless sensor network application.","  Wireless Sensor Networks offer unique benefits and versatility in terms of lowpower and lowcost rapid  deployment for applications which do not require human supervision. Nodes in WSNs are usually battery operated sensing devices with limited energy resources. Thus energy  efficiency is one of the most important issues and  designing powerefficient protocols is critical for prolongin g the lifetime. WSNs have been considered for certain  applications with limited power, reliable data transfer, short range communication, and reasonably low cost such  sensing applications [1].  Many energyefficient routing protocols are designed based on clustering structure. The clustering  technique can also used to perform data aggregation, which combines data from source nodes into set of meaningful  information [2]. Many routing protocols have originated since the development of this field in which LEACH [3],  DEEC [2], TEEN, SEP and PEGASIS are some of them. LEACH, of them, proved to be more promising and  became a benchmark in the designing of other protoc ols like AsLEACH [4], Enhanced LEACH [5], LEACHCC  [6], AdLEACH [7] and MODLEACH [8] are some of them.   In this paper, we have considered MODLEACH protoc ol as the reference and considered such parameters  like p (probability of choosing a CH), s (software threshold) and h (hard threshold) which have been used in this  protocol to further enhance the performance of the MODLEACH protocol. As our protocol outperforms the  functionality of the protocol, hence the name is given as iMODLEACH (Improved Modified LEACH). We varied  the values of the p,s and h parameters and analyzed their effect on th e performance of the ne twork mathematically  and then verified those with the help of simulations. The results clearly indicate that our protocol iMODLEACH  outperforms MODLEACH in terms of network lifetime and packets transferred to base station. The analysis helps  to select such values of these parameters which can suit a particular wireless se nsor network application.      2. Related Work  "
20,Cross Layer Adaptation for QoS in WSN.txt,"In this paper, we propose QoS aware MAC protocol for Wire- less Sensor
Networks and its cross layer extension to network layer for providing QoS in
delay sensitive WSN scenarios. In WSNs, there can be two types of traffic one
is event driven traffic which requires immedi- ate attention and another is
periodic reporting. Event driven traffic is classified as Class I(delay
sensitive) traffic and periodic reporting is clas- sified as Class II(Best
Effort) Traffic. MAC layer adaptation can take place in terms of (i) Dynamic
contention window adjustment per class, (ii) Reducing the delay suffered by
difference in Sleep schedules(DSS) of communicating nodes by dynamically
adjusting Duty Cycle based on Utilization and DSS delay of class I traffic,
(iii) Different DIFS (DCF Inter Frame Spacing) per class, (iv) Adjusting all
the three schemes pro- posed above simultaneously. Cross layer extension is
also proposed, in which MAC layer uses network layer's next hop information for
better adaptation of duty cycle based on DSS delay. Routing protocols can uti-
lize MAC layer parameter DSS delay to select the routes which offer least DSS
delay latency, there by minimizing the overall end-to-end delay.","  WSNs are deployed for critical  monitoring applications, some of these  applica  tions are delaysensitive  and have stringen t requiremen t on endtoend latencie s.  Apart  from this  delaysensitive  traffic,  they  also support  periodic  reporting of  environmen t to their  base stations. WSNs deplo ymen t for forest fire monitoring  is one of the type of applications that we are emphasizing  on. This calls for QoS  specific mechanisms  to be in place for supporting the application requiremen ts.  There  has  been a lot  of research  and  developmen t carried  out  in architecture,  protocol design, energy saving and location in WSNs, but only a few studies have  been done regarding  network  efficiency (i.e. Quality  of Service  QoS) in WSNs.   We consider SMAC[1], as one of the  widely accepted  MAC layer implemen  tations in WSNs and use it as our base MAC protocol for implementing the QoS  features at MAC level. SMAC pays no attention  to latency  and end to end delay,  and nodes form virtual  clusters  in terms of their common sleepwakeup sc hedule  to reduce control overhead. For supporting delaysensitive traffic and periodic  reporting for above mentioned  application requirements, our prototype defines   2  Adaptation of MAC Layer  and  Network  Layer for QoS in WSN     two classes of traffic classI(immediate attention) and classII(periodic  reporting)  respectively. In our prototype, we propose to adjust  MAC level parameters Con  tention  Window[7], DIFS[7], Sleep schedu les  of nodes[1],[2] to provide  QoS for  the classes of traffic specified. In [9] MAC level parameters are adjusted for QoS  guarantees, In [2], duty  cycle is being adapted, but  efficien t QoS classes specific  way of adapting duty  cycle in case of SMAC[1], and  adapting MAC level pa  rameters Contention Window and  DCF  IFS in case of Sensor Networks  is our  contribution, that this paper prop oses.   MAC layer  is responsible  for scheduling  and  allocation  of the  shared  wire  less channel,  which eventually  determines the link level QoS parameters namely  MAC delay.  To maintain the  per  class service guarantees in dynamic  environ  ment, MAC layer is made adaptive  to curren t network conditions.  The prop osed  dynamic  adaptation of the  behavior  of MAC layer is done by,  (i)  dynamic ally  varying  the  contention  window  based  on the  class  of traffic,  (ii)Reducing the  delay  suffered by Difference in Sleep Schedules(DSS)  of communicating no des  by  dynamically   adjusting Duty  Cycle  based  on  Utilization and  DSS delay  of  class I traffic, (iii) By differentiating the DCF  Inter  Frame  Spacing for differen t  class of Traffic, (iv) Combining  all the  three  proposed  schemes for MAC Layer  Adaptation. [12], reports  the premilimnary version of the work presented  in this  paper.  Cross layer extension  to curren t MAC layer adaptation is also proposed.  In  this,  MAC layer can be adjusted to use network  layer next  hop information for  adjusting the  duty  cycle more  efficiently, next  hop  information is broadcasted  with  the  SYNC packets  used in SMAC[1]. So that only those  nodes which are  next  hops of many  other  nodes should  increase  their  duty  cycle based  on uti  lization  and  DSS delay.  In second cross layer mechanism,  we focus on routing  protocols, in this link costs can include DSS delay parameter of underlying  MAC  layer into consideration while route  calculation. So, only those routes  are chosen  which offer least overall DSS delay and in turn  least endtoend dela y.  The rest of the paper is organized  as follows. In section   2 we briefly discuss  about the related  work. Section  3 describes our proposed scheme for MAC layer  adaptation. Section    4 discusses  about  the  cross  layer  extensions.  Section    5  presents  the simulated  results to show the the efficiency of our proposed sc heme.  Section  6 concludes the paper.      2  RELATED WORK   "
430,Eliminating Tight Coupling using Subscriptions Subgrouping in Structured Overlays.txt,"Advertisements and subscriptions are tightly coupled to generate publication
routing paths in content--based publish/subscribe systems. Tight coupling
requires instantaneous updates in routing tables to generate alternative paths
which prevents offering scalable and robust dynamic routing in cyclic overlays
when link congestion is detected. We propose, OctopiA, first distributed
publish/subscribe system for content--based inter--cluster dynamic routing
using purpose--built structured cyclic overlays. OctopiA uses a novel concept
of subscription subgrouping, which divides subscriptions into disjoint sets
called subscription subgroups. The purpose--built structured cyclic overlay is
divided into identical clusters where subscriptions in each subgroup are
broadcast to an exclusive cluster. Our advertisement and subscription
forwarding algorithms use subscription subgrouping to eliminate tight coupling
to offer inter--cluster dynamic routing without requiring updates in routing
tables. Experiments on a cluster testbed with real world data show that OctopiA
reduces the number of saved advertisements in routing tables by 93%,
subscription broadcast delay by 33%, static and dynamic publication delivery
delays by 25% and 54%, respectively.","Content–based Publish/Subscribe (pub/sub) systems provide asyn chronous dissemination of data in event–based distributed appli cations [ 13]. A publisher publishes the data in form of publica tion, while a subscriber registers its interest in form of a subscrip tion to receive publications of interest [ 6][10]. In broker–based pub/sub systems, a dedicated overlay network formed by a set ofbrokers , is used to connect publishers and subscribers anony mously. Pub/sub is an active research area that attracts attention from industry [ 9,12,15,16,21,29] and academia [ 2–4,8,18,18– 20,24,26,28,30]. In advertisement–based pub/sub systems, a publisher ﬁrst broadcasts an advertisement message about the data it wants to publish. The advertisement is saved in Subscription Routing Table (SRT) at each broker to form an advertisement–tree rooted at the publisher. To form publication routing paths, a subscription is forwarded in reverse direction to brokers that forwarded adver tisements matching that subscription. Subscriptions are saved in Publication Routing Table (PRT) [6,10] (in rest of this paper, an advertisement–based pub/sub system is referred to as pub/sub ). Tight coupling indicates that an advertisement and matching sub scription have to be saved in routing tables of the same broker to generate publication routing paths. A subscription has to be reissued when tree of the matching advertisement changes (or the advertise ment is reissued) for some reason. Most pub/sub systems use acyclic topologies which provide a single routing path between a pair of publisher and subscriber. This offers limited ﬂexibility to deal withnetwork condition like link congestion. Multiple paths may be avail able in a cyclic overlay, only one path at a time can be used for content–based routing with almost no support for dynamic routing [6]. We argue that tight coupling requires instantaneous updates in routing tables to generate new routing paths to avoid congested links in cyclic overlays [ 17]. Updates in routing tables generate extra trafﬁc, cause message loss, and impede in–broker processing thus un suitable for large networks and delay sensitive applications. Pub/sub systems that use cyclic overlays face additional challenges. (i) API calls create a large number of updates in routing tables because there are no covering techniques available for cyclic overlays — subscribe orunsubscribe calls require adding or removing the corresponding subscription in all PRTs, which may cause severe congestion [5, 7]. The worst impact is expected when a publisher calls unadvertise and not only the corresponding advertisement has to be removed from all SRTs but subscription–trees of the matching subscriptions may also be removed or pruned. (ii) An advertisement has to be unique identiﬁed to avoid message loops. (iii) Advertisement broadcast generates extra Inter–broker Message (IMs) to detect and discard duplicates. (iv) Generating routing paths of minimum lengths is difﬁcult, and to the best of our knowledge, never addressed before (cf. Sec. 2). Indeed, a new architecture is needed to address current research challenges in pub/sub systems that use cyclic overlay. We introduce OctopiA , a distributed pub/sub system, which of fers inter–cluster dynamic routing by eliminating tight coupling. OctopiA is based on a novel concept called Subscription Subgroup ing(orSubgrouping ), which creates disjoint subsets of subscriptions, where each subset is known as Subscription Subgroup (orSubgroup ) (cf. Sec. 5). Subgrouping requires that each subgroup should have distinct subscriptions. For example, for subgroups S1andS2, there exists no subscription ssuch that s2S1\S2. To realize subgroup ing,OctopiA leverages a new Structured Cyclic Overlay Topology (SCOT) to formulate clusters of brokers where the number of clusters is equal to the number of subgroups. A cluster–level subscription broadcast algorithm forwards subscriptions in a subgroup to brokers in a cluster. Advertisements are forwarded to a set of brokers, called aregion , and create advertisement–trees of length 1 (these patterns of subscription and advertisement forwarding eliminate tight coupling). OctopiA does not assign identiﬁcations to advertisements and gen erates no extra IMs. Since subscriptions in a subgroup are conﬁned to one cluster, subscribe orunsubscribe calls generate updates in routing tables of brokers of only one cluster without effecting net work trafﬁc in other clusters. Similarly, advertise orunadvertise generate updates in routing tables of only one region without ef fecting network trafﬁc in other regions. This pattern of forwarding subscription and advertisement improves throughput of a pub/sub in face of concurrent churn events. As subscriptions are conﬁned to only one cluster, inter–cluster publication routing may generatearXiv:1611.08743v4  [cs.DC]  8 Jul 2017false positives because some clusters may receive publications but have no interested subscribers. An added novelty in OctopiA is the use of a bit–vector to eliminate false positives . This paper makes the following contributions. Sec. 2 provides details of background issues in pub/sub systems that use cyclic over lays. Sec. 3 provides a comprehensive overview of the Structured Cyclic Overlay Topology (SCOT) used by OctopiA . Additional structural properties induced in SCOT to offer dynamic routing are discussed in Sec. 4. The novel concept of Subscription Subgrouping is discussed in Sec. 5. Advertisement and subscription broadcast algorithms in clustered SCOT are discussed in Sec. 6 and 7, re spectively. Sec. 8 presents our bit–vector (or Cluster Index Vector) mechanism to avoid false positives. Algorithms for static and inter cluster dynamic routing of publications are discussed in Sec. 9. Evaluation and comparison with identiﬁcation–based (or TID–based [22]) state–of–the–art is presented in Sec. 10. 2 BACKGROUND ISSUES This section describes issues related to handling message loops or cycles in pub/sub systems. Advertisement–tree Identiﬁcation : Cycles generate duplicate ad vertisements, subscriptions, and publications and it is important to detect and discard them. In the advertisement broadcast, each broker saves the advertisement in the form of fadvertisement, lasthop gtu ple where the lasthop indicates the last sender (publisher or broker). Fig. 1(a) shows that Broker 5 may receive the advertisement of P twice from brokers 4 and 2, which generates cycles [ 22]. To resolve this issue, the host brokers of publishers assign a Unique Identiﬁ cation (UI) to each advertisement, which is used by other brokers to detect duplicates [ 5,17,22]. In Fig. 1(a), broker 5 discards the advertisement of P when received from broker 2 (assuming that it has already received the advertisement from broker 4). UIs require extra in–broker processing, increase delivery delays and payload of messages [22]. Extra Inter–broker Messages (IMs) : Similar to duplicates in the previous issue in Fig. 1(a), Broker 6 discards the duplicate when received from Broker 3. This indicates that despite using UIs, ex tra IMs still generate to detect duplicates. The number of these extra IMs could be 80% of the total network trafﬁc generated in advertisement broadcast [ 22]. This considerably effects the network performance when churn rate of publishers is high. Advertisement–tree Length : In an acyclic overlay, advertisement broadcast generates a unique advertisement–tree even if the adver tisement is issued multiple times (after calling unadvertise from the same broker). Advertisement broadcast in cyclic overlays is an uncontrolled process, which selects the ﬁrst available link (or broker) as the next destination. This may generate advertisement– trees of larger lengths when load on the links and brokers is uneven. Multiple advertisement calls from the same broker may generate mul tiple advertisement–trees with different lengths. To the best of our knowledge, no advertisement broadcast algorithm exists that guar antees advertisement–trees of shortest lengths. An overlay link in this paper is represented as lhsource ;destinationi, where the source identiﬁes message sending broker and the destination represents the message receiving broker. As Fig. 1(b) shows that the length of the advertisement–tree of P is twice of the length in Fig. 1(a). Thisis due to uneven load on the overlay links lh1;4iandlh2;5iat the time P issued the advertisement. Broker 5 receives the advertise ment from Broker 6 and discards a duplicate when received from Broker 2. Similarly, Broker 4 discards a duplicate received from Broker 1 (assuming that it has already received the same advertise ment from Broker 5). Length of the publication routing path (or the subscription–tree) in this case is also larger than Fig. 1(a). Although P and S are hosted by brokers of R1, each publication is processed by brokers in the other two regions to reach Broker 4. This indicates that control over length of the advertisement–tree can reduce pub lication delay. Hop count to generate shortest advertisement–trees is not a suitable method because it can generate large number of updates in subscription–trees if the advertisement with least hop count is received as duplicate. Ideally, an advertisement–tree should always has the shortest length, even if some links have high loads when the advertisement is issued. Binding UI : A subscription is bounded to UI of a matching adver tisement to avoid cycles in publications routing [ 22]. A subscription may be bounded to more than one UIs depending on the number of matching advertisements. A broker may receive multiple copies of the same subscription bounded with multiple UIs and coming from different paths. This particular case is explained in Fig. 1(c), where S is interested in publications from P1, and P2. The subscription of S, which is received twice by Broker 2 from the last hops (Broker 3 and Broker 5), bound to UIs of advertisements of P1 and P2. Each publication has to carry UI of the corresponding advertisement–tree for routing to the next destination [22]. Single Routing Path : Only one path activated by the advertisement and subscription is available for routing publications, which poses a serious challenge in offering dynamic routing. A naive approach would suggest generating alternative routing paths instantaneously, however, this requires a large number of updates in routing tables to alter advertisement– and subscription–trees [ 6,17]. In Fig. 1(a), if the link lh1;4ibecomes unavailable, alternative routing paths can be created by removing the link lh1;4i, and adding the link lh2;5i orlh3;6iin the advertisement–tree. This requires calling unadver tiseto eliminate the current advertisement–tree and then generating the desired advertisement–tree using some controlled advertisement broadcast algorithm which is complex for cyclic overlays. In par allel to this, S should be informed to unsubscribe andresubscribe to receive publications from P. The whole process of removing old and adding new links requires updates in SRTs and PRTs, which is inefﬁcient for large network settings. Dynamic routing is also supported using overlapping advertisement–trees [ 22]. In Fig. 1(c), advertisement–trees of P1 and P2 overlap at Broker 2, which in dicates that Broker 2 can select least loaded link from lh2;3iand lh2;5ito forward a publication from P1 or P2 (recall that subscrip tion of S matches with advertisements of P1 and P2). However, this approach requires overlapping advertisement–trees, which are not al ways possible because subscribers and publishers are anonymous to each other. A dynamically selected path may not have more brokers with overlapping advertisement–trees. In the above example, only one broker can support dynamic routing while a number of brokers have to save the subscription twice [22]. 2Adv. trees of P , P1 Adv. tree of P2 Sub. tree of S Region separator Overlay link Overloaded overlay link1 2 3 4 5 6 SPR1 R2 R3 (a)Advertisement and subscription broadcast in a cyclic overlay when load on the overlay links is normal.1 2 3 4 5 6 SPR1 R2 R3 (b)Advertisement and subscription for warding when the links lh2;5iandlh3;6i are congested.1 2 3 4 5 6 P2P1 SR1 R2 R3 (c)Overlapping advertisements and subscription forwarding to support dynamic publication rout ing. Figure 1: A cyclic overlay of six brokers is divided into three geographical regions R1,R2and R3. Each region contains two brokers: (R1contains brokers 1 and 4; R2has brokers 2 and 5; R3has brokers 3 and 6). In (a) and (b), the subscriber S is interested in receiving publications from the publisher P. In (c), S is interested in receiving publications from the publishers P1 and P2. 3 STRUCTURED CYCLIC TOPOLOGY In this section, we describe how Structured Cyclic Overlay Topolo gies (SCOT) are created using Cartesian Product of Undirected Graphs (CPUG) [27]. 3.1 Preliminaries A graph is an ordered pair G=VG;EG, where VGis a ﬁnite set of vertices and EGis a set of edges or links that connect two vertices inG. The number of vertices of G(called order ) isjGj(orjVGj). Similarly, the number of edges in GiskGk(orjEGj). A graph in which each pair of vertices are connected by an edge is called a complete graph . The diameter of a graph G, represented as diam(G) , is the shortest path between the two most distant nodes in G. A graph product is a binary operation that takes two small graph operands—for example GVG;EGandHVH;EH—to produces a large graph whose vertex set is given by VGXVH. Many types of graph products exist, but we ﬁnd the Cartesian product most suitable for contentbased routing. Other products, for example, the Direct product and the Strong product can be used but their rulebased interconnection of vertices increases node degree and makes rout ing complex. The CPUG of two graphs GVG;EGandHVH;EHis denoted by GH, with vertex set VGHand set of edges EGH. Two vertices g;h2VGHandg0;h02VGHare adjacent if g=g0and hh02EGHorgg02EGHandh=h0. Formally, the sets of vertices and edges of a CPUG are given as [14]. VGH=fg;hjg2VG^h2VHg (1) EGH=fhg;hg0;h0ijg=g0;hh02EH _gg02EG;h=h0g) (2) The operand graphs GandHare called factors of GH. CPUG is commutative—that is, GH=HG. Although CPUG of nnumber of graphs is possible, we are concerned with CPUG of only two graphs. 3.2 Structured Cyclic Overlay Topology TheStructured Cyclic Overlay Topology (SCOT) is aCPUG of two graphs. One graph, represented by Ga f, is called SCOT acyclic factor , while the second graph operand, represented by Gc f, is called SCOT connectivity factor . A SCOT has two important properties: (i)Acyclic Property emphasizes that the Ga fmust be an acyclic graph, and (ii) Connectivity Property requires that Gc fmust be acomplete graph. These properties augment a SCOT with essential characteristics that are used for generating advertisement–trees of shortest lengths and control message cycles efﬁciently. Va fandVc f are the sets of vertices of Ga fandGc f, while Ea fandEc fare the sets of edges of Ga fandGc f, respectively. For a singleton graph of vertex setfhgVc f, the graph Gh a fgenerated by Ga ffhgis called aGh a f"
220,A Wireless Sensor Network Air Pollution Monitoring System.txt,"Sensor networks are currently an active research area mainly due to the
potential of their applications. In this paper we investigate the use of
Wireless Sensor Networks (WSN) for air pollution monitoring in Mauritius. With
the fast growing industrial activities on the island, the problem of air
pollution is becoming a major concern for the health of the population. We
proposed an innovative system named Wireless Sensor Network Air Pollution
Monitoring System (WAPMS) to monitor air pollution in Mauritius through the use
of wireless sensors deployed in huge numbers around the island. The proposed
system makes use of an Air Quality Index (AQI) which is presently not available
in Mauritius. In order to improve the efficiency of WAPMS, we have designed and
implemented a new data aggregation algorithm named Recursive Converging
Quartiles (RCQ). The algorithm is used to merge data to eliminate duplicates,
filter out invalid readings and summarise them into a simpler form which
significantly reduce the amount of data to be transmitted to the sink and thus
saving energy. For better power management we used a hierarchical routing
protocol in WAPMS and caused the motes to sleep during idle time.","Sensor networks are dense wireless networks of small, lowcost sensors, which collect and  disseminate environmental data. Wireless sensor networks facilitate monitoring and controlling  of physical environments from remote locations with better accuracy [1]. They have  applications in a variety of fields such as environmental monitoring, indoor climate control,  surveillance, structural monitoring, medical diagnostics, disaster management, emergency  response, ambient air monitoring and gathering sensing information in inhospitable locations [2,  3, 4, 5]. Sensor nodes have various energy and computational constraints because of their  inexpensive nature and adhoc method of deployment. Considerable research has been focused  at overcoming these deficiencies through more energy efficient routing, localization algorithms  and system design.  In this paper we proposed a wireless sensor network air pollution monitoring system (WAPMS)  for Mauritius. Indeed, with the increasing number of vehicles on our roads and rapid  urbanization air pollution has considerably increased in the last decades in Mauritius. For the  past thirty years the economic development of Mauritius has been based on industrial activities  and the tourism industry. Hence, there has been the growth of industries and infrastructure  works over the island. Industrial combustion processes and stone crushing plants had  contributed to the deterioration of the quality of the air. Further, the economic success of 	 	  	  	  	     32 Mauritius has led to a major increase in the number of vehicles on the roads, creating additional  air pollution problem with smoke emission and other pollutants.   Air pollution monitoring is considered as a very complex task but nevertheless it is very  important. Traditionally data loggers were used to collect data periodically and this was very  time consuming and quite expensive. The use of WSN can make air pollution monitoring less  complex and more instantaneous readings can be obtained [6, 7]. Currently, the Air Monitoring  Unit in Mauritius lacks resources and makes use of bulky instruments. This reduces the  flexibility of the system and makes it difficult to ensure proper control and monitoring.  WAPMS will try to enhance this situation by being more flexible and timely. Moreover,  accurate data with indexing capabilities will be able to obtain with WAPMS. The main  requirements identified for WAMPS are as follows:   1. Develop an architecture to define nodes and their interaction   2. Collect air pollution readings from a region of interest  3. Collaboration among thousands of nodes to collect readings and transmit them to a gateway,  all the while minimizing the amount of duplicates and invalid values  4. Use of appropriate data aggregation to reduce the power consumption during transmission  of large amount of data between the thousands of nodes  5. Visualization of collected data from the WSN using statistical and userfriendly methods  such as tables and line graphs  6. Provision of an index to categorize the various levels of air pollution, with associated  colours to meaningfully represent the seriousness of air pollution  7. Generation of reports on a daily or monthly basis as well as realtime notifications during  serious states of air pollution for use by appropriate authorities   At present, our scientific understanding of air pollution is not sufficient to be able to accurately  predict air quality at all times throughout the country. This is where monitoring can be used to  fill the gap in understanding. Monitoring provides raw measurements of air pollutant  concentrations, which can then be analysed and interpreted. This information can then be  applied in many ways. Analysis of monitoring data allows us to assess how bad air pollution is  from day to day, which areas are worse than others and whether levels are rising or falling. We  can see how pollutants interact with each other and how they relate to traffic levels or industrial  activity. By analysing the relationship between meteorology and air quality, we can predict  which weather conditions will give rise to pollution episodes.    2. RELATED WORKS   "
151,Resilience Enhancement at Edge Cloud Systems.txt,"It is becoming common practice to push interactive and location-based
services from remote datacenters to resource-constrained edge domains. This
trend creates new management challenges at the network edge, not least to
ensure resilience. These challenges now need to be investigated and overcome.
In this paper, we explore the use of open-source programmable asset
orchestration at edge cloud systems to guarantee operational resilience and a
satisfactory performance level despite system incidents such as faults,
congestion, or cyber-attacks. We discuss the design and deployment of a new
cross-level configurable solution, Resilient Edge Cloud Systems (RECS). Results
from appropriate tests made on RECS highlight the positive effects of deploying
novel service and resource management algorithms at both data and control
planes of the programmable edge system to mitigate against disruptive events
such as control channel issues, service overload, or link congestion. RECS
offers the following benefits: i) the switch automatically selects the
standalone operation mode after its disconnection from the upper-level
controllers; ii) deployment of edge virtualized services is made, according to
client requests; iii) the client requests are served by edge services and the
related traffic is balanced among the alternative on-demand routing paths to
the edge location where each service is available for its clients; iv) the TCP
traffic quality is protected from unfair competitiveness of UDP flows; and v) a
set of redundant controllers is orchestrated by a top-level multi-thread
cluster manager, using a novel management protocol with low overhead.","Programmable networking concepts including Software  Defined Networking (SDN) offer excellent prospects for  highly adaptable and fast management of network resources  and data flows [1] in many modern networking scenarios such  as Internet of Things (IoT) enabled healthcare systems [2] or  PeertoPeer (P2P) energy trading in intelligent transportation  systems [3]; these are typically hybrid systems joining  communication and computational edge resources.  Nevertheless, SDN also brings potential problems such as  increasing management complexity and as a target for attack,  potentially com promising the desired resilience of such  systems [4][5]. In fact, an SDN based system could  experience significant degradation of its performance due to  various system threa ts or congestion at both data forwarding  and control levels. Consequently, it is appropriate to explore  suitable programmable solutions to mitigate  unexpected  system faults  [6], congestion  [7], or cyber attacks [8].   A. BACKGROUND   The background of current research work as well as the  main  operating scenario are now presented. The emerging  dataintensive, interactive, and location sensitive user services  such as 5G, IoT, augmented reality, and vehicle tovehicle  communications [9] force computational resources being  moved from remote clouds [10] to edge clouds [11] in order  to diminish the data and service access latency, to provide the  edge network infrastructure with local scalable processing,  and even to run local sel fadaptable algorithms [12]. The  higher heterogeneity and scarcity of edge resources must not  impair the upcoming demand for reliable and efficient edge  services. Therefore, we propose RECS  (Resilient Edge Cloud  Systems ), a programmable serverless system [13] that  orchestrates both elastic networking and computing resources  for enhancing the operational resilience of local ondemand  virtualized services at edge network domains, shown  in Fig. 1.   VOLUME XX, 2017  9    B. CONTRIBUTION  AND NOVELTY   This work  proposes practical solutions to mitigate the negative  effects on the system performance imposed by system  menaces or high loads . These solutions are deployed with a  cross layer design at distinct vertical levels of the SDN based  system (see Fig. 2), viz. data forwarding, switching logic, and  resilience management, aiming to build up a more resilient  SDN assisted system for edge computing network scenarios.  In a nutshell, the main aims of this contribution  are to design,  implement, and evaluate diverse prog rammable solutions to  satisfy a set of goals , as follows: i) increase the resilience of a  SDN based system after communication failures  between  network devices and their controllers  by using a suitable   switch functional mode ; ii) mitigate congestion situat ions at  the network server side , providing an elastic supply of  virtualized services  that follows load variation ; iii) overcome  congested links and collaborate with other solutions towards  the most effective use of system available resources ; and iv)  balan ce control workload among  SDN controllers and  increase resilience at the system control level. By coherently  integrating diverse programmable solutions, our SDN based  work is a novel orchestrator for edge cloud distributed  resources, enhancing system opera tional resilience in  challenging cases such as faults, congestion, or attacks. We  also envisage the minimization of deployment and operational  costs of the network infrastructure owned by a specific  Internet provider .    FIGURE 1.   RECS   a programmable serverless computing system providing on  demand edge resources and elastic virtualized services with enhanced resilience   C. STRUCTURE   The paper structure is as follows. After the introduction,  Section II analyses related work, highlightin g the novel  aspects of our work. Section III discusses the design of RECS .  The deployment of RECS  is in Section IV, and Section V  broadly evaluates the proposed system. Section VI  summarizes the discuss ion about  the main evaluation results  and describes how our proposal can be applied to real life  scenarios. Finally, Section VII concludes the paper  with some  suggestions for future research directions.        II. RELATED WORK   "
61,Experimentally-based Cross-layer Optimization for Distributed Wireless Body-to-body Networks.txt,"We investigate cross-layer optimization to route information across
distributed wireless body-to-body networks, based on real-life experimental
measurements. At the network layer, the best possible route is selected
according to channel state information (e.g., expected transmission count, hop
count) from the physical layer. Two types of dynamic routing are applied:
shortest path routing (SPR), and cooperative multi-path routing (CMR)
associated with selection combining. An open-access experimental dataset
incorporating `everyday' mixed-activities is used for analyzing and comparing
the cross-layer optimization with different wireless sensor network protocols
(i.e., ORPL, LOADng). Negligible packet error rate is achieved by applying CMR
and SPR techniques with reasonably sensitive receivers. Moreover, at 10% outage
probability, CMR gains up to 8, 7, and 6 dB improvements over ORPL, SPR, and
LOADng, respectively. We show that CMR achieves the highest throughput
(packets/s) while providing acceptable amount of average end-to-end delay (47.5
ms), at -100 dBm receive sensitivity. The use of alternate paths in CMR reduces
retransmissions and increases packet success rate, which significantly reduces
the maximum amount of end-to-end delay and energy consumption for CMR with
respect to other protocols. It is also shown that the combined channel gains
across SPR and CMR are gamma and Rician distributed, correspondingly.","Wireless body area networks (BANs) are often speciﬁcally designed for healthcare scenarios to autonomously connect various medical sensors and actuators located on, in, around or/and near the human body to monitor physiological signals. Although, BAN applications span a wide area from military, ubiquitous health care, sports, entertainment to many more [1], advanced professional health care management is one of the main purposes of the BAN concept. However, the underlying technology is still at an early stage of deployment and typically based on very speciﬁc wireless communications technologies [2]. The IEEE 802:15:6BAN Standard aims to enable lowpower communication to be reliable and practical for inbody/onbody nodes to serve a variety of medical and nonmedical applications [3]. Now patients with BANs can be monitored while carrying out their regular everyday activities, without being tethered to monitoring devices. Samiya M. Shimly, David B. Smith, and Samaneh Movassaghi are with the Research School of Engineering, The Australian National University (ANU), Canberra, ACT 0200, Australia. They are also with CSIRO (Commonwealth Scientiﬁc and Industrial Research Organisation) Data61, Australia. email: fSamiya.Shimly, David.Smith, Samaneh.Movassaghi g@data61.csiro.au This research is supported by an Australian Government Research Training Program (RTP) scholarship.With the anticipated growth in the number of people using BANs, their coexistence will be a concern in the near future, where reliable communications is vital in healthcare scenarios particularly. When multiple closelylocated BANs coexist, the potential internetwork communication and cooperation across BANs lead to the investigation and design of wireless bodytobody networks (BBNs) [4], [5]. The main motivation behind BBNs is to make use of bodytobody (B 2B) com munications to overcome the problems of coexistence and general performance degradation for closely located BANs. As stated in [4], a bodytobody network is theoretically a mesh network that uses people (with bodyworn sensors) to transmit or relay data within a limited geographic area, by creating their own centralized or decentralized network connection. This type of selforganizing, intelligent network could provide costeffective solutions for remote monitoring of a group of patients wearing BAN sensors, for instance, by relaying physiological data/information up to the access point of the medical service, without depending on any external coordination. Some of the many target applications that can be beneﬁted through BBN include: precision monitoring of athletes; facilitating rescue/medical teams in a disaster area; communication between groups of soldiers on a battleﬁeld; and communication in densely populated areas such as city centers, concerts and sports venues. The notion of BBN is more dynamic and potentially larger scale than that of individual BANs, where each BAN member can join and/or leave the network seamlessly, without the need for any centralized infrastructure. Hence, dynamic routing is necessary to enable routers to select paths according to realtime logical network layout changes by periodic or on demand exchange of routing information. Additionally, due to the postural body movements affecting BANs as well as their mobility, so that these BBNs are mobile, the use of networks incorporating infrastructure such as backbone routers would generally be very costly and unfeasible. Also, even in indoor BAN coexistence with mobile people, while deploying a backbone router is possible to some extent, the connection between a BAN hub and the router can be blocked by any obstacle or may go out of range because of the movement (e.g., postural changes or mobility). Specially, people having mobility issues can incur lifethreatening risks, as these type of outages can be for a longer period of time with only a simple postural change. In such cases, a cooperative path through a nearby BAN hub, which is in the range of both source and destination hubs/backbone router, can greatly help to improve the situation. It is envisioned that in the case of unavailable or outofrange network infrastructures, the BAN coordinators along with the BAN sensors can exploit cooperative and multiarXiv:1701.08605v4  [cs.NI]  19 Jan 20192 hop bodytobody communications to extend the endtoend network connectivity [6]. In this paper, we seek to address the general performance of closely located BANs while utilizing bodytobody com munications to extend endtoend network connectivity across BANs without central coordination and interference mitiga tion. Hence, we perform and analyze energy efﬁcient cross layer optimization across the physical and network layers for twotiered communications, with onbody BANs at the lower tier and a BBN at the upper tier to enable real time, reliable human monitoring and communications across narrowband BANs . The method is applied to an experimental radio measurement dataset1recorded from ‘everyday’ mixed activities and a range of measurement scenarios with people wearing radios. The extensive radio channel data was captured using NICTA2developed wearable channel sounders/radios. We compare the results of cooperative multipath routing (CMR) with shortest path routing (SPR) and other stateof theart WSN protocols (i.e., ORPL [8], LOADng [9]). Our key ﬁndings in this paper, based on empirical results derived from reallife measurements [7], are as follows: Negligible (almost 0%) packet error rate (less than 10%, thus fulﬁlling the requirement of the IEEE 802:15:6 Standard [3]) is achieved with reasonably sensitive re ceivers for both shortest path routing (SPR) and coop erative multipath routing (CMR) in a dynamic environ ment associated with mobile subjects, using the available nodes/hubs as relays. CMR provides up to 8dB,7dB, and 6dB performance improvement over ORPL3, SPR, and LOADng3, respec tively, at 10% outage probability. ETX (Expected Transmission Count) or hop count metric (used in SPR, CMR, and LOADng in a mesh) can perform better than EDC (Expected Duty Cycles) metric (used in ORPL with DODAG4topology) in case of any toany routing among BANs. CMR outperforms other protocols in case of throughput (packets/second) by providing 95% successful packet delivery ( 19packets/s at a packet transmission rate of 20Hz). The maximum amount of endtoend delay is the lowest for CMR ( 135 ms) with respect to other protocols and also below the IEEE 802:15:6latency requirement (¡ 250 ms) for nonmedical applications. Also, the average end toend delay for CMR ( 47:5ms) is an acceptable amount (¡125ms) for BAN medical applications. CMR consumes more energy on average than other techniques due to the cooperative combining at route hops, although the maximum energy consumption with CMR is much lower than other protocols (except SPR with hop restriction). 1available in http://doi.org/10.4225/08/5947409d34552 [7] 2National Information and Communications Technology Australia (NICTA) has been incorporated into Data61, CSIRO. 3We have implemented these protocols (i.e., ORPL, LOADng) in MATLAB and applied on the same measurement dataset (used in this paper) to compare with SPR and CMR. 4Destination Oriented Directed Acyclic Graph [10], [11].CMR produces the lowest amount of average endtoend delay with respect to other protocols, when estimated with lower receive sensitivity (e.g., "
177,"Monitor, Detect, Mitigate: Combating BGP Prefix Hijacking in Real-Time with ARTEMIS.txt","The Border Gateway Protocol (BGP) is globally used by Autonomous Systems
(ASes) to establish route paths for IP prefixes in the Internet. Due to the
lack of authentication in BGP, an AS can hijack IP prefixes owned by other ASes
(i.e., announce illegitimate route paths), impacting thus the Internet routing
system and economy. To this end, a number of hijacking detection systems have
been proposed. However, existing systems are usually third party services that
-inherently- introduce a significant delay between the hijacking detection (by
the service) and its mitigation (by the network administrators). To overcome
this shortcoming, in this paper, we propose ARTEMIS, a tool that enables an AS
to timely detect hijacks on its own prefixes, and automatically proceed to
mitigation actions. To evaluate the performance of ARTEMIS, we conduct real
hijacking experiments. To our best knowledge, it is the first time that a
hijacking detection/mitigation system is evaluated through extensive
experiments in the real Internet. Our results (a) show that ARTEMIS can detect
(mitigate) a hijack within a few seconds (minutes) after it has been launched,
and (b) demonstrate the efficiency of the different control-plane sources used
by ARTEMIS, towards monitoring routing changes.","The interdomain routing in the Internet takes place over the globally adopted Border Gateway Protocol (BGP) [1]. Autonomous Systems (ASes) use BGP to advertise routing pathsforIPpreﬁxestotheirneighboringASes. SinceBGPis adistributedprotocolandauthenticationofadvertisedro utes isnotalwaysfeasible,itispossibleforanAStoadvertisei l legitimateroutepathsforIP preﬁxes. These pathscanprop agate and “infect” many ASes, or even the entire Internet, impacting thus severely the Internet routing system and/or economy[2–6]. Thisphenomenon,called BGPpreﬁxhijacking ,isfrequently observed [6], and usually caused by router misconﬁgura tions [2,3] or malicious attacks [4–6]. Some examples of real BGP hijacking cases include: (a) a Pakistan’s ISP in 2008,duetoamisconﬁguration,hijackedtheYouTube’spre ﬁxesanddisrupteditsservicesformorethan 2hours[2];(b) China Telecom mistakenly announced ∼37000IP preﬁxes(corresponding to 15%of the whole BGP table) in 2010, causing routing problems in the Internet [3]; and (c) hack ersperformedseveralhijackingattacks,througha Canadia n ISP, to redirect trafﬁc and steal thousands dollars worth of bitcoinsin2014[4]. Topreventpreﬁxhijackings,severalproactivemechanisms forenhancingthe BGP securityhave beenproposed[7–11]. These mechanisms need to be globally deployed to be ef fective. However,despite the standardizationefforts[9, 10], theirdeploymentisslowduetopolitical,technical,andec o nomic challenges, leaving thus the Internet vulnerable to BGP hijacks. Therefore,currently,reactivemechanismsareusedforde fending against preﬁx hijackings: after a hijacking is de tected,networkadministratorsarenotiﬁed(e.g,throughm ail inglists[12],ordedicatedservices[13]),inordertoproc eed to manual actions towards its mitigation (e.g., reconﬁgure routers, or contact other ASes to ﬁlter announcements). A number of systems have been proposed for detecting preﬁx hijacking,basedoncontrolplane(i.e.,BGPdata)and/orda ta plane (i.e,. pings/traceroutes)information[12–18]. Mos t of them, are designed to operate as thirdparty services (exte r nal to an AS) that monitor the Internet, and upon the de tection of a suspicious incident, notify the involved ASes. Although this approach has been shown to be able to detect suspicious routing events in many cases, two main issues stillremainunsolved: (i)thedetectionmightnotbeaccura te, since the suspicious routing events might not correspond to hijacks, but be caused by, e.g., trafﬁc engineering; and (ii ) themitigationisnotautomated,increasingthussigniﬁcan tly thetime neededtoresolvea hijack. In this paper, we propose a reactive mechanism/system, which we call ARTEMIS ( Automatic and RealTime dEtec tion and MItigation System )1, that aims to be operated by an AS itself, rather than a thirdparty, to timely detect and mitigate hijackings against its ownpreﬁxes in an automatic way. ARTEMIS (i) exploits the most recent advances in controlplane monitoring to detect in near realtime preﬁx hijackings, and(ii) immediatelyproceedsto their automat ic mitigation(Section2). We thenconductseveralrealhijackingexperimentsinthe 1A demo of ARTEMISistoappear inACMSigcomm 2016 [19]. 1Internet using the PEERING testbed and analyze the effect of various network parameters (like, type of hijacking, hi jacker / defenderAS location and connectivity) on the per formanceofARTEMIS.Weshowthatitispossibletodetect and mitigate preﬁx hijacking within few seconds from the momenttheoffendingannouncementisﬁrst made. Thisisa major improvementcomparedto presentapproaches,which require slow procedures, like manual veriﬁcation and coor dination. The timely mitigation of ARTEMIS, prevents a hijackingfromspreadingtojust,e.g.,20%50%oftheASes that wouldbeaffectedotherwise(Section3). Finally, we discuss related work in hijacking detection systems and measurement studies, and compare it to our study, in order to highlight the new capabilities that are of  fered with ARTEMIS (Section 4). We conclude our paper bydiscussingthepotentialforfutureapplicationsandext en sionsofARTEMIS(Section5). 2. ARTEMIS In this section, we ﬁrst present the different sources that are used by ARTEMIS for controlplane monitoring (Sec tion 2.1), and then describe the detection (Section 2.2) and mitigation (Section2.3)services. 2.1 ControlPlane DataSources For the monitoring service, ARTEMIS combines multi ple controlplanesourcesto (a) accelerate the detection o f a hijacking (i.e., minimum time of all sources), and (b) have a more complete view of the Internet (i.e., from the van tage points of all the sources). ARTEMIS receives control plane information from publicly available sources, namely , the BGPmon tool [15], the livestreaming service of RIPE RIS [20],andthePeriscopeplatform[21]. Remark:ARTEMIS supportsthe BGPstream tool [22] as well. However,duringourexperiments,theBGPstream ser vicewasunavailable,and,thus,wedonotuseitinthispaper . In the following, we present the main features of these controlplanesources. BGPmon [15] is a tool that monitors BGP routing infor mation in realtime. It is connected to, and collects BGP updates and routing tables (RIBs) from BGP routers of: (a) the RouteViews sites and (b) a few dozen of peers around theworld;atthetimeweconductedourstudy,BGPmonhad 43vantage points, in total. BGPmon providesthe live BGP data,asanXMLstream. RIPE RIS streaming service [20]. The RIPE’s Routing Information System (RIS) is connected to route collectors (RCs) in several locations around the world, and collects BGP updates and RIBs. In the standard RIPE RIS [23], the data can be accessed via the raw ﬁles (in MRT format) or RIPEstat. The delay for BGP updates is ∼5minand ∼8hfor RIBs. Recently, RIPE RIS offers a streaming ser vice[20]thatprovidesliveinformationfrom 4RCsviaweb sockets. The live streaming service of RIPE RIS, which we use in ARTEMIS, has currently 3RCs in Europe and 1RCinAfrica;all ofthemarelocatedin largeIXPs. Periscope [21] is a platform that provides a common in terface for issuing measurements from Looking Glass (LG) servers. ThroughPeriscope,ausercansendacommandtoa numberofchosenLGstoaskforcontrolplane( showipbgp ) or dataplane ( traceroute/ping ) information. The status and the outputof the measurementscan be retrievedat any time (even before its completion). Periscope currently provide s accessto 1691LGservers. BGPstream [22] is an opensource framework for live (andhistorical)BGPdataanalysis. Itenablesuserstoquic kly inspect raw BGP data from the commandline,or througha Python and C/C++ API. BGPstream provideslive access to RouteViews and RIPE RIS data archives. While the delay of acquiring the data from these two services is consider able (5min and15min, respectively,for BGP updates), BG Pstream recently introduced a service for live access to a stream of BGP datafromBMPenabledRouteViewscollec tors(withonly ∼1mindelay). Intotal,BGPstreamreceives datafrom 76routecollectors,fromall itsproviders. 2.2 PreﬁxHijackingDetectionwithARTEMIS ThedetectionserviceofARTEMISaimstodetecthijacks in (i)realtime and (ii)without false positives , while moni toringthe(iii) entireInternet ina (iv)lightweight fashion. The detection service continuously receives from the 3 controlplane sources (see Section 2.1) information about the BGP route paths for the monitored preﬁxes, as they are seen at the different vantage points (e.g., route collector s, LG servers). This routing information is compared with a localﬁle thatdeﬁnesthelegitimateoriginASNsforeachIP preﬁxthatisownedbytheoperatorofARTEMIS;anyviola tion denotes a hijacking. Since operatorhas full knowledge on the legitimate originASNs for its preﬁxes, the detectio n servicereturns nofalse positives . With the combinationof 3sources,the detectioncantake place when an illegitimate route path is received by any of thesources. Thisisalwaysfasterthanusingonlyonesource , and can decrease the time needed for detection. Using mul tiple sources gives also the possibility to beneﬁt from the large number of vantage points they have aroundthe globe. This is important, because a hijacking might affect only a part of the Internet, due to BGP policies and shortestpath routing[12,24]. Finally, ARTEMIS aims to impose limited load on the usedthirdpartyservices,sothatpotentially100sASes(t hat runARTEMIS)couldusetheminparallel. ARTEMISneeds to receive only the data (i.e., the part of the BGP tables, or speciﬁc BGP updates) that correspond to the local preﬁxes. As a result, the imposed load is low , since (a) BGPmon and RIPE RIS (as well as, BGPstream) are services/tools de signedandoptimizedtoprovidestreamsoflivedatatomany users simultaneously, (b) and Periscope has already a limit in the rate of requests to avoid overloading of LG servers. Similarly, theconsumptionofnetworkresourcesisverylow , 2allowingthusasingleAS to monitormanypreﬁxes. 2.3 Automatic Preﬁx Hijacking Mitigation Thegoalsofamitigationmechanismaretobe(i) fastand (ii)efﬁcient,and(iii)have lowimpact ontheInternetrouting system. Currentlymitigationreliesonmanualactions,e.g.,after a network administrator is notiﬁed for a preﬁx hijacking, she proceeds to reconﬁguration of the BGP routers, or contacts other administrators to ﬁlter the hijacker’s announcement s. Asitbecomesevident,thismanualinterventionintroduces a signiﬁcant delay (e.g., in the YouTube hijacking incident i n 2008 [2], a couple of hours were needed for the mitigation of the problem). Hence, our primary focus is to accelerate themitigation. Tothisend,weimplementanautomaticmit igation mechanism, which starts the mitigation immediately afterthedetection,i.e.,withoutmanualintervention. Speciﬁcally,whenARTEMISdetectsahijackinginapre ﬁx,let10.0.0.0/23 ,itproceedstoitsdeaggregation:itsends a command to the BGP routers of the AS to announce the twomorespeciﬁcpreﬁxes,i.e., 10.0.0.0/24 and10.0.1.0/24 . ThesubpreﬁxeswilldisseminateintheInternetandreest ablish legitimate route paths, since more speciﬁc preﬁxes are pre ferred by BGP. Preﬁx deaggregation, as described above, is efﬁcient for /23or less speciﬁc (i.e., /22, /21, ... ) pre ﬁxes. However, when it comes to hijacking of /24preﬁxes, the deaggregationmight not be always efﬁcient, since pre ﬁxesmorespeciﬁcthan /24areﬁlteredbymostrouters[25]. Althoughthis is a shortcomingof the deaggregationmech anism, it is not possible to overcomeit in an automatic way (manualactionsareneeded);toourbestknowledge,onlyso lutions that require the cooperation of more than one ASes couldbeapplied[26,27]. ThedeaggregationmechanismofARTEMIS,increments the number of entries in the BGP routing table by 1per hi jacked preﬁx. However, since the number of concurrent hi jackings is not expected to be large, and the duration of a hijackingislimited,theimposedoverheadislow. Finally,sinceARTEMISmonitorscontinuouslythecontrol plane of the Internet, frommany vantagepoints, it becomes possibletomonitorinrealtimetheprocessofthemitigati on. This enables a network administrator to see how efﬁcient the mitigation is, and if needed to proceed to further (e.g., manual)actionsortorelyexclusivelyonthe deaggregatio n mechanism. 3. EVALUATIONWITHA REAL AS In this section, we conduct experiments in the Internet, toinvestigate(a)theoverallperformanceofARTEMIS,and (b) the efﬁciency of the different sources presented in Sec tion 2.1 for monitoring the controlplane of the Internet. I n Section3.1weprovidethedetailsforthesetupofourexper iments,andpresentthe resultsinSection3.2. 3.1 Experimental SetupIn our experiments, we conduct realhijackingsin the In ternet. We use the PEERING testbed [28,29], which pro videsthepossibilitytoannounceIPpreﬁxesfromrealASNs totheInternet;boththeIPpreﬁxesandtheASNsareowned byPEERING,hence,ourexperimentshavenoimpactonthe connectivityofotherASes. Speciﬁcally,wecreateavirtualASinPEERING,andcon nectittooneormorerealnetworks. ThisAS(whichwecall “legitimate”AS)announcesanIPpreﬁxandusesARTEMIS to continuously monitor this preﬁx. We also create another virtual AS (the “hijacker”AS) in PEERING, connect it to a real network in a different location, and hijack the preﬁx of thelegitimateAS. 3.1.1 ThePEERINGtestbed PEERING is a testbed that enablesresearchersto interact with the Internet’s routing system. It connects with severa l real networks at universities and Internet exchange points around the world. The users of PEERING can announce IP preﬁxes using multiple ASNs owned by PEERING as the originAS. In our experiments,we use the connectionsof PEERING to three real networks/sites (Table 1)2. We are given autho rizationtoannouncethepreﬁx 184.164.228.0/23 (aswellas, its subpreﬁxes),anduse the AS numbers 61574(forthe le gitimateAS)and 61575(forthehijackerAS). 3.1.2 Typesofpreﬁxhijackingattack We test ARTEMIS in two different types of hijacking at tacks: (a)exactpreﬁxhijacks,and(b)subpreﬁxhijacks. Exact preﬁx hijacking is a common attack type where the hijacker announces the same preﬁx that is announced by the legitimate AS. Since shortest route paths are typi cally preferred, only a part of the Internet that is closer to the hijacker(in numberofAShops)switches to routepaths towards the hijacker. Exact preﬁx hijacks typically infect a fewtensorhundredsofASes[12],fromsmallstubnetworks to large tier1 ISPs [24]. In our experiments, the legitimat e ASannouncesthepreﬁx 184.164.228.0/23 ;thenthehijacker announcesthe same preﬁx. To mitigatethe attack,the legit imateAS,announcesthesubpreﬁxes 184.164.228.0/24 and 184.164.229.0/24 . Subpreﬁx hijacking contributes around 10% of all sta ble hijackings in the Internet [12]. The hijacker announces a more speciﬁc preﬁx, which is coveredby the preﬁx of the legitimate AS. Since in BGP more speciﬁc preﬁxesare pre ferred,theentireInternet switchestoroutingtowardsthehi jackerfortheannouncedsubpreﬁx. WeconﬁgureARTEMIS to monitor the 184.164.228.0/22 preﬁx3. The hijacker an nouncesthepreﬁx 184.164.228.0/23 .Theattackismitigated 2PEERINGpeerswith 88organizationsinAMSIX[29]. Statistics for the number providers, customers, and peers for each AS ar e from [30]. 3Since we have access only to the /23preﬁx, we do not announce the/22preﬁx;we onlyassume itis announced. However, this does not affect the outcome of the experiments. 3Table1: PEERINGsites Organization Location ASN #providers #customers #peers AMSAmsterdamInternetExchange(AMSIX) Amsterdam,NL 1200   509 ISI LosNettosRegionalNetwork LosAngeles(CA),US 226 4 19 19 GAT GeorgiaInstituteofTechnology Atlanta(GA),US 2637 4 1 6 bydeaggregatingthehijackedpreﬁx,i.e.,thelegitimate AS announcesthetwo /24preﬁxes. 3.1.3 Experiments Theexperimentprocesscomprisesthe followingsteps: (1)The legitimate AS ( AS61574) announces the IP preﬁx, andwe wait 20minforBGP convergence. (2)The hijacker AS ( AS61575)announcesthe IP preﬁx (or, subpreﬁx). (3)ARTEMISdetectsthe hijacking. (4)ARTEMIS starts the mitigation, i.e., the legitimate AS announcesthedeaggregatedsubpreﬁxes. (5)We monitor the mitigation process for 30min, and end the experimentbywithdrawingallannouncements. We conduct experiments for a number of different sce narios, varyingthe (a) location/site of the legitimate and hi jackerASes,and(b) numberofupstreamproviders ofthele gitimate AS. We repeat each scenario/experiment 10times. TheexperimentstookplaceinMayJune2016. Remark:WhilenormallyARTEMISproceedsimmediately after a hijacking detection to its mitigation, in some exper i ments we add a 30mindelay betweensteps 3 and 4, i.e., we defer the mitigation. This allows us to investigate the efﬁ ciencyofthedifferentcontrolplanesources,i.e.,howmu ch time eachofthemneedstodetectthe hijacking. 3.1.4 Conﬁgurationofthecontrolplanesources BGPmon provides to ARTEMIS a stream of all the up dates it receives from its peers. Hence, conﬁguration is not needed;ﬁlteringanddetectionareinternalservicesofART EMIS. RIPERIS needsonlytheinformationaboutthemonitored preﬁx,andreturnstoARTEMISonlytheBGPmessagesthat correspondtoannouncementsforthispreﬁx. InPeriscope ,duetothelimitontherateofmeasurements per user, only a subset of the total 1691 LG servers can be used. To conform to the ratelimit, we use 18LG servers, which we select based on theirperformance(responsetime, availability)andlocation. Theselectedsetconsistsof 11LGs inEurope, 2inAsia,4inNorthAmerica,and 1inAustralia. 3.2 Results 3.2.1 Performanceofcontrolplanesources The performance of ARTEMIS depends on the control plane sources it uses. Therefore, to obtain an initial under  standingaboutthecapabilitiesandlimitationsofARTEMIS , we present in Fig. 1 experimental results that demonstrate the efﬁciency and characteristics of the different control plane sources in hijacking detection (Fig. 1(a)) and mitiga  tionmonitoring(Fig.1(b)). Fig. 1(a) shows how much time is needed by BGPmon, RIPE RIS, and Periscope to observe an illegitimate route, afterithasbeenannouncedfromthehijackerAS.Wepresent the distribution of the times (among different experiments ) forbothattacktypes: preﬁxandsubpreﬁxhijacking. A ﬁrst observation is that the streaming services (BGP mon and RIPE RIS) observe the hijack in ≤1min in most cases, and are signiﬁcantly faster than Periscope ( 12min), whichmonitorsthecontrolplanebyperiodicallyissuingm ea surementsfromLGservers. Thisisduetotheresponsedelay of the LGs, as well as, a limit in the minimum time interval betweenconsequentmeasurementsimposedbyPeriscope. The detection delay in the subpreﬁx attack case (SP) is on average lower than in preﬁx hijacking (P). This is be cause a subpreﬁx hijacking appears in the whole Internet, whereas preﬁx hijacking affects only a fraction of it. This partial infection of the Internet can be faster observed by BGPmon that has morevantage pointsthan RIPE RIS, as is indicatedbythelowermeanvalueandvarianceofBGPmon inthe preﬁxhijackingcase. In Fig. 1(b), we show the mitigation progress as it has beenobservedbythe ASeswith a vantagepoint,i.e.,an RC feed or an LG server,in all sources. The averagenumberof ASes that have been infected by the hijacker and switched back to the legitimate routes, are 29and15in the SP and P case, respectively. Despite the differences, both attacks can bequicklymitigated; 45%(SP)and50%(P)oftheASesre establish legitimate routes in 10sec after the mitigation was launched, while almost complete mitigation is achieved in less than 1min. Furthermore, Figs. 1(a) and 1(b) hint to an interesting tradeoff: more vantage points (and, thus, ASe s) can be monitored by Periscope, however, this comes with anincreaseinthedetectiondelaycomparedtoBGPmonand RIPE RIS. 3.2.2 Effectofnetworkconnectivity We now proceed to test the efﬁciency of ARTEMIS un der various scenarios of network connectivity. Fig. 2 illus  trates the effect of the (i) hijacker site and (ii) number of upstream providers of the legitimate AS4. In the preﬁx hi jackingcase(Fig.2(a)),whenthehijackingistriggeredby a well connectedsite, asin the case of AMS that it peerswith 88real networks,the detectionof the hijackingcan be done in around 10sec. When the connectivity of the hijacker AS 4Our results do not signiﬁcantly variate with the location of the legitimate ASor the number ofupstream providers of the hija cker. 4P SPP SPP SP050100150time (sec)    BGPmon RIPE RIS Periscope (a) detection delay0 50 100 150051015202530 time (sec)number of ASes    subprefix prefix (b) mitigationdelay Figure1: (a)Boxplotsofthedetectiondelayofthedifferen t controlplanesourcesamongallthepreﬁx(P)andsubpreﬁx (SP) hijacking experiments. (b) Number of ASes (with a vantage point) that switched back to the legitimate AS (y axis)vs. thetimethe mitigationhasbeenlaunched(xaxis) . is low,asin the GATcase that thereareless thana dozenof directly connected networks, the detection delay is always higher than 15sec and can need up to 1min (the average de tection delay is around 30sec). These ﬁndings are intuitive and consistent with the conclusions of the simulation study in [24]; adding to this, they quantify for the ﬁrst time the effectsofthehijacker’sconnectivitywith realexperimen ts. InFig.2(a),wecanalsoobservethatwhentheconnectiv ityofthelegitimateASincreases,i.e., 2upstreamproviders, thedetectiondelay(slightly)increasesaswell. Thisisdu eto thefactthatwith 2upstreamproviders,moreASesarecloser tothelegitimateAS(intermsofAShops)thanthehijacker, and thus the effect of preﬁx hijacking is lower (and, conse quently,its detectionbecomesmoredifﬁcult). In contrast to the preﬁx hijackingcase, when the hijacker announces a subpreﬁx (Fig. 2(b)), the connectivity of the involvednetworksdoesnotplayacrucialrole. Theeffectof the hijacking is large and the detection is always completed within10sec,andonaverageit needsonly 3sec! Remark:In [12] it is shown that the “detection delay” of Argus (a stateoftheart hijacking detection system) is l ess than10sec for>60%hijacks. However,this delay, let Tdd, refers to the time needed to infer that an observation of an illegitimate route corresponds to a hijacking attack; i.e. , if ArgususesthesamecontrolplanesourcesasARTEMIS,the total detection delay of Argus is TArgus=TARTEMIS + Tdd≥TARTEMIS . 3.2.3 Gainsofautomaticmitigation Afterpresentingthehijackingdetectionefﬁciency,westu dy the gains of the automatic mitigation of ARTEMIS. Specif ically, Fig. 3 shows the percentage of infected ASes in re lation to the time since the hijacking has been launched. Eachcurvecorrespondstoadifferent“mitigationstarttim e” Tstart, i.e., the time between the hijacker’s announcement and the deaggregation. The two bottom lines5correspond 5Withblue and red; or, 10sec and30sec inFig. 3(a), and 5secand 10secinFig.3(b).1/AMS 2/AMS 1/GAT 2/GAT0102030405060time (sec)    1 upstream / hijacker: AMS 2 upstream / hijacker: AMS 1 upstream / hijacker: GAT 2 upstream / hijacker: GAT (a) preﬁxhijacking1/AMS 2/AMS 1/GAT 2/GAT0102030405060time (sec)    1 upstream / hijacker: AMS 2 upstream / hijacker: AMS 1 upstream / hijacker: GAT 2 upstream / hijacker: GAT (b) subpreﬁxhijacking Figure 2: Boxplots of ARTEMIS detection delay in scenar ios with different hijacker location andnumberof upstream providers of the legitimate AS. Results for the cases of (a) preﬁxand(b)subpreﬁxhijacking. 0 50 100 150 200 25000.20.40.60.81percentage of infected ASes time (sec)   10sec 30sec 1min 2min (a) preﬁxhijacking0 50 100 150 200 25000.20.40.60.81percentage of infected ASes time (sec)   5sec 10sec 1min 2min (b) subpreﬁxhijacking Figure 3: Percentage of “infected” ASes (seen by the controlplanesources), i.e., ASes that route trafﬁc to the hi jacker, (yaxis) vs. the time since the hijacking has been launched(xaxis). to the near realtime automatic mitigation with ARTEMIS (we selected representative scenarios; cf. Fig. 2). The two toplinesareassumedtocorrespondtoatimely(butnotreal time)mitigation,e.g.,withmanualactions. As it can be seen, ARTEMIS can signiﬁcantly decrease the impact of a hijacking. For instance, in scenarios where thedetectiondelayofARTEMISis 10sec,thefractionofin fectedASesis 20%and50%inthepreﬁxandsubpreﬁxhi jacking,respectively,whileevenatimelymitigationstar ting 1minafterthehijackingisnotabletopreventtheinfectiono f allASes. Moreover,withARTEMIStheattackiscompletely mitigatedin Ttotal≤2min,whereasamitigationthatstarted after all ASes are infected (i.e., top two lines) needs aroun d 1.5minafterthedetection ,i.e.,Ttotal=Tstart+1.5min. ThisfastandeffectivemitigationthatARTEMIScanachieve , is particularly important for short hijacking attacks, who se frequency increases [12], and which can still cause serious problems[4]. 4. RELATED WORK "
199,Efficient Packet Forwarding Approach in Vehicular Ad Hoc Networks Using EBGR Algorithm.txt,"VANETs (Vehicular Ad hoc Networks) are highly mobile wireless ad hoc networks
and will play an important role in public safety communications and commercial
applications. Routing of data in VANETs is a challenging task due to rapidly
changing topology and high speed mobility of vehicles. Conventional routing
protocols in MANETs (Mobile Ad hoc Networks) are unable to fully address the
unique characteristics in vehicular networks. In this paper, we propose EBGR
(Edge Node Based Greedy Routing), a reliable greedy position based routing
approach to forward packets to the node present in the edge of the transmission
range of source/forwarding node as most suitable next hop, with consideration
of nodes moving in the direction of the destination. We propose Revival
Mobility model (RMM) to evaluate the performance of our routing technique. This
paper presents a detailed description of our approach and simulation results
show that packet delivery ratio is improved considerably compared to other
routing techniques of VANET.","  Inter vehicle communication (IVC) is attracting  considerable attention from the research community and  the automotive industry. It is beneficial in providing  intelligent transportation system (ITS) as well as drivers  and passenger’s assistant services. VANETs is a form of  mobile ad hoc network providing communications among  nearby vehicles as well as between vehicles and nearby  fixed equipment, usually described as roadside equipment.  VANETs have similar or different radio interface technologies, employing short range to medium range  communication systems. The radio range of VANETs is  several hundred meters, typically between 250 and 300  meters. In US, the Federal Communications Commission  (FCC) has allocated 75 MHz in 5.9 GHz band for licensed  Dedicated Short Ran ge Communication (DSRC) for  vehicle tovehicle and vehicle to infrastructure  communications. In Europe, the Car to Car  Communication Consortium (C2C CC) has been initiated  by car manufacturers and automotive OEMs (original equipment manufacturers), with t he main objective of  increasing road traffic safety and efficiency by means of  intervehicle communication.     2. Related Work   "
283,Automated Composition of Security Protocols.txt,"Determining if two protocols can be securely composed requires analyzing not
only their additive properties but also their destructive properties. In this
paper we propose a new composition method for constructing protocols based on
existing ones found in the literature that can be fully automatized. The
additive properties of the composed protocols are ensured by the composition of
protocol preconditions and effects, denoting, respectively, the conditions that
must hold for protocols to be executed and the conditions that hold after
executing the protocols. The non-destructive property of the final composed
protocol is verified by analyzing the independence of the involved protocols, a
method proposed by the authors in their previous work. The fully automatized
property is ensured by constructing a rich protocol model that contains
explicit description of protocol preconditions, effects, generated terms and
exchanged messages. The proposed method is validated by composing 17 protocol
pairs and by verifying the correctness of the composed protocols with an
existing tool.","Security protocols are “communication protocols dedi cated to achieving security goals” (C.J.F. Cremers and S. Mauw) [1] such as conﬁdentiality, integrity or availabilit y. Achieving such security goals is made through the use of cryptography. The explosive development of today’s In ternet and the technological advances made it possible to implementandusesecurityprotocolsinawiderangeofapplicationssuchassensornetworks,electroniccommerceor routingenvironments. Security protocols have been intensively analyzed throughout the last few decades, resulting in a variety of dedicated formal methodsand tools [2, 3, 4]. The majority ofthese methodsconsidera DolevYaolikeintrudermodel [5,6]tocapturetheactionsavailabletotheintruderthath as completecontroloverthenetwork. Byanalyzingeachindi vidualprotocolinthepresenceofthisintruder,thelitera ture has reportednumeroustypes of attacks [3, 7]. However, in practice, there can be multiple protocols running over the same network, thus the intruder is given new opportunities to construct attacks by combining messages from several protocols,also knownasmultiprotocolattacks[8]. Designing new protocols, thus, becomes a challenging task if we look at the numberof attacks that have been dis coveredovertheyears[7]aftertheprotocolshavebeenpub lished. Inthelastfewyearstheuseofprotocolcomposition [8,9,10]hasbeensuccessfullyappliedtocreatenewproto cols based on existing [11, 12, 13] or predeﬁned protocols [9]. Inthispaperweproposeanewcompositionmethodthat, asopposedtoexistingapproaches[9,11,12,13,14]canbe fullyautomatizedbyeliminatingthehumanfactor. Inorder tocreateanautomatedcompositionmethod,weneedanen riched protocol model that contains enough information to compose the protocol preconditions and effects and an ap proach for the veriﬁcation of the correctness of the ﬁnal, composedprotocol. Preconditions denote the set of properties that must be satisﬁed for the protocol to be executed, while the effects denote the set of properties resulting from the protocol ex ecution. By composing preconditions and effects (i.e. PEcomposition),wegenerateanewprotocolsequencethaten sures the satisfaction of the protocol preconditions and th e propagationofgeneratedinformationthrougheffects. TheprotocolsequencegeneratedbythePE composition mustbe correct,in thesense that it must maintainthesecu rity properties of the original protocols. In order to verif y this, we use an approach developed in our previous work [15] that veriﬁes the independence of the involved proto cols. Protocol independence,called participant chain com  position(i.e. PC composition)ensuresthat the intruderca n not replay messages from one protocol to another to con struct new attacks while running the protocols in the same environment. This property also ensures the correctness of thecomposedprotocol. Thepaperisstructuredasfollows. Insection2wedeﬁne an enriched protocol model that includes explicit descrip tion of protocolpreconditions,effects, generatedtermsa nd exchangedmessages. Insection 3 we providea description of the proposed composition method and a brief presenta tion of the independence veriﬁcation method proposed in ourpreviouswork[15]. Theproposedcompositionmethod hasbeenappliedin the compositionprocessof severalpro tocols, part of these experimental results are given in sec tion 4. We relate our work to others found in the literature in section 5 and we end with a conclusion and future work insection6. 2 Protocol model Protocolparticipantscommunicatebyexchanging terms constructed from elements belonging to the following ba sic sets:P, denoting the set of participant names; N, de noting the set of random numbers or nonces(i.e. “number once used”); K, denoting the set of cryptographic keys; C, denoting the set of certiﬁcates and M, denoting the set of userdeﬁnedmessagecomponents. In order for the protocol model to capture the message component types found in security protocol implementa tions[17,18]wespecializethebasicsetswiththefollowin g subsets: •PDN⊆P, denoting the set of distinguished names; PUD⊆P, denoting the set of userdomain names; PIP⊆P, denoting the set of userip names; PU= {P\{PDN∪PUD∪PIP}},denotingthesetofnames thatdonotbelongto theprevioussubsets; •NT, denoting the set of timestamps; NDH, denot ing the set of random numbers speciﬁc to the Difﬁe Hellman key exchange; NA={N\ {NDH∪NT}}, denotingtheset ofrandomnumbers; •KS⊆K, denoting the set of symmetric keys; KDH⊆ K, denoting the set of keys generated from a Difﬁe Hellman key exchange; KPUB⊆K, denoting the setofpublickeys; KPRV⊆K, denotingtheset ofprivate keys. To denote the encryption type used to create crypto graphicterms,wedeﬁnethefollowing functionnames : FuncName ::=sk(symmetricfunction ) |pk(asymmetricfunction ) |h(hashfunction ) |hmac(keyedhashfunction ) The encryption and decryption process makes use of cryptographic keys. Decrypting an encrypted term is only possible if participants are in the possession of the decryp  tion key pair. In case of symmetric cryptography, the de cryption key is the same as the encryption key. In case of asymmetriccryptography,thereisapublicprivatekeypai r. Determining the corresponding key pair is done using the function−1:K→K. The abovedeﬁned basic sets and function names are usedinthedeﬁnitionof terms,wherewealsointroducecon structorsforpairingandencryption: T::=.|R|N|K|C|M|(T,T)| {T}FuncName (T), wherethe ‘.’ symbolisusedtodenoteanemptyterm. Having deﬁned the terms exchangedby participants, we can proceed with the deﬁnition of a nodeand aparticipant chain. To capture the sending and receiving of terms, the deﬁnition of nodes uses signed terms . The occurrence of a term with a positive sign denotes transmission, while the occurrenceofatermwithanegativesigndenotesreception. Deﬁnition 1. Anodeis any transmission or reception of a term denotedas /a\}bracketle{tσ,t/a\}bracketri}ht, witht∈Tandσoneofthesymbols +,−. Anodeiswrittenas −tor+t. Weuse(±T)todenote a set of nodes. Let n∈(±T), then we deﬁne the function sign(n)to map the sign and the function term(n)to map theterm correspondingtoa givennode. Deﬁnition 2. Aparticipant chain is a sequence of nodes. We use(±T)∗to denotethe set of ﬁnite sequencesof nodes and/a\}bracketle{t±t1,±t2,...,±ti/a\}bracketri}httodenoteanelementof (±T)∗. In order to deﬁne a participant model we also need to deﬁne the preconditions that must be met such that a par ticipant is able to execute a given protocol. In addition, we also need to deﬁne the effects resulting from a participant executinga protocol. Preconditions and effects are deﬁned using predicates applied on terms: CONTERM:T, denoting a term that must bepreviouslygenerated(preconditions)orit isgener  ated(effects); CONPARTAUTH :T, denotinga participant that must be previously authenticated (preconditions) or a participant that is authenticated (effects); CONCONF:T,denoting that a given term must be conﬁdential (precon ditions) or it is kept conﬁdential (effects); CONINTEG: T, denoting that for a given term the integrity property must be provided (preconditions) or that the protocol en sures the integrity property for the given term (effects); CONNONREP :T, denotingthat foragiventermthenon repudiation property must be provided (preconditions) or that the protocol ensures the nonrepudiation property for the given term (effects); CONKEYEX:T, denoting that a key exchange protocol must be executed before (precondi tions)orthatthisprotocolprovidesakeyexchangeresulti ng thegiventerm(effects). The set of preconditioneffect predicates is denoted by PRCCand the set of preconditioneffect predicate sub sets is denoted by PRCC∗. Next, we deﬁne predi cates for each type of term exchanged by protocol partic ipants. These predicates are based on the basic and spe cialized sets provided at the beginning of this section. We use theTYPEDN:Tpredicate to denote distinguished name terms, TYPEUD:Tto denote userdomain name terms,TYPEIP:Tto denote userip name terms, TYPEU:Tuser name terms, TYPENT:Tto de note timestamp terms, TYPENDH:Tto denote Difﬁe Hellman random number terms, TYPENA:Tto de note other random number terms, TYPENDH:T×T× T×P×Pto denote DifﬁeHellman symmetric key terms (term,number 1,number 2, participant 1,participant 2), TYPEKSYM:T×P×Pto denote symmetric key terms(term,participant 1,participant 2),TYPEKPUB: T×Pto denote public key terms (term,participant ), TYPEKPRV:T×Pto denote private key terms (term,participant ),TYPECERT:T×Pdo denote cer tiﬁcate terms (term,participant )andTYPEMSG:Tto denoteuserdeﬁnedterms. The set of type predicates is denoted by PRTYPEand the set of type predicatesubsets is denotedby PRTYPE∗. Based on the deﬁned sets and predicates we are now ready todeﬁnetheparticipantandprotocolmodels. Deﬁnition 3. Aparticipant model is a tuple /a\}bracketle{tprec,eff,type,gen,part,chain /a\}bracketri}ht,whereprec∈PRCC∗ is a set of precondition predicates, eff ∈PRCC∗is a set of effect predicates, type∈PRTYPEis a set of type predicates, gen∈T∗is a set of generatedterms, part∈P is a participant name and chain∈(±T)∗is a participant chain. We use the MPARTsymbol to denote the set of all participantmodels. Deﬁnition4. Aprotocolmodel isacollectionofparticipant models such that for each positive node n1there is exactly one negative node n2withterm(n1) =term(n2). We use theMPROT symboltodenotethesetofallprotocolmodels.3 Compositionofprotocol models The composition process involves composing in a ﬁrst stagetheprotocolpreconditionsandeffectsfollowedbyth e composition of participant chains. In this section we ﬁrst formulatethe conditionsneededfor the preconditioneffe ct (PE) composition which involves establishing the satisfac  tion of protocol preconditions and the veriﬁcation of the nondestructive properties of protocol effects. This is fo l lowedbytheprotocolchain(PC)compositionforwhichwe constructacanonicalmodelandverifytheindependenceof theinvolvedparticipantchains. 3.1 Composition of preconditions and ef fects In the compositionprocessof two security protocolswe ﬁrstneedtocomposethepreconditionsandeffects. Inother words,weneedtoestablishiftheknowledgeneededbypro tocolparticipantstorunagivenprotocol,expressedthrou gh the form of precondition predicates, is available and if the set ofpreconditionandeffectpredicatesisnondestructi ve. In order to establish if the set of preconditions corre spondingtoaprotocolcanbesatisﬁedbasedonagivencon text and the effects corresponding to another protocol we usethepredicate PARTPREC:T∗×PRCC∗×PRCC∗. The context denotes the initial knowledge available to par ticipants when running the protocol. For two participant models, ς1=/a\}bracketle{tprec1,eff1,type1,gen1,part1,chain 1/a\}bracketri}ht andς2=/a\}bracketle{tprec2,eff2,type2,gen2,part2,chain 2/a\}bracketri}ht, the PARTPRECpredicateisdeﬁnedas PARTPREC(ctx,eff1,prec2) =  True, ifeff1⊆prec2∪, {∪{CONTERM(t)|t∈ctx}}, False, otherwise . The nondestructive property applies only for the CONCONFbecausethe absenceof anotherproperty,such as integrity or nonrepudiation, does not affect the previ ous properties. In order to establish if the preconditions andeffectsoftwoparticipantmodelsaredestructiveweuse the predicate PARTNONDESTR :PRCC∗×PRCC∗× PRCC∗whichholdsonlyifallconﬁdentialtermsfromone participant model maintain their conﬁdentiality property in the second participant model also. Thus, the predicate is deﬁnedas PARTNONDESTR (eff1,prec2,eff2) =  True, ifEF1/\e}atio\slash=CONCONF∨ ifEF1=CONCONF∧t1=t2then ∃EF2(t2) :EF2=CONCONF, ∀EF1(t1)∈eff1∧∀PR2(t2)∈prec2, False, otherwise .Based onthe abovegivenpredicateswe can state that in orderto composethepreconditionsandeffectscorrespond ing to two participant models we need to establish if the predicates PARTPRECandPARTNONDESTR hold. The preconditioneffect (PE) composition is expressed throug h the use of the operator ≺PE ς:MPART×MPART → MPART, which generates a new participant model based ontwogivenparticipantmodels. Byusingthisoperator,we not only express the PE composition of participant models butalsotheorderinwhichthegivenparticipantmodelsap pearintheﬁnal,composedparticipantmodel. Thus,wecan statethatgiventwoparticipantmodels, ς1andς2,forwhich thePEcompositionrequirementsaresatisﬁed,wehavethat ς1≺PE ςς2/\e}atio\slash=ς2≺PE ςς1. If the operatoris applied on two participantmodelsthatcannotbecomposed(i.e. oneofthe twopredicatesdoesnothold),theresultistheemptypartic  ipant model, denoted by φς=/a\}bracketle{tφ,phi,φ,φ,., /a\}bracketle{t/a\}bracketri}ht/a\}bracketri}ht, whereφ denotesanemptyset. The PE composition requirements of two participant modelscanbeeasilyextendedtoformtherequirementsfor thePE compositionoftwo protocolmodels. Theserequire ments include applying the ≺PE ςoperator on pairs of participant models for which the names are equal. We ex press the PE composition of two protocol models through the use of the ≺PE ξ:MPROT ×MPROT →MPROT operator. For this operator also, we can state that given two protocolmodels, ξ1andξ2, forwhichthe PE composi tion requirementsare satisﬁed, we have that ξ1≺PE ξξ2/\e}atio\slash= ξ2≺PE ξξ1. Incaseofprotocolmodelsthatcannotbecom posed, the result is denoted by the empty protocol model φξ=φ. 3.2 Composition of participant chains The PC composition makes use of a canonical model that focuses on terms that can be veriﬁed by protocol par ticipants. For each term the canonical model provides a correspondingsyntactical representationthroughthe use of basic types . These denote the terms that can be veriﬁed by protocol participants also including a representation f or termsthatcannotbeveriﬁedbecauseoflimitedparticipant knowledge. The veriﬁcation process makes use of these types to decide if attacks can be constructed on each pro tocolmodelbyusingtermsextractedfromtheotherconsid eredprotocolmodels. Inordertocomposetwoparticipantchainsthesemustbe instance independent andcanonical independent . The ﬁrst conditionreferstothenondestructivepropertiesofprec on ditionsandeffectswhilethe secondconditionrefersto ver  ifying the independence of the involved participant chains based on the canonical model. The veriﬁcation of the in dependence property of protocol models has been covered by the authors in their previous work [15]. If protocolsareindependent,thentheymaintaintheirsecuritypropert ies when they are run in the same context. By using this prop ertyinthecompositionprocess,protocolsmaintaintheirs e curityproperties,resultingnewprotocolswithaccumulat ed properties. In the remaining of this section we brieﬂy present the canonical model and the protocol independence property proposedinourpreviouswork. Thebasictypes weconsiderarebasedonthespecialized basicsetsintroducedin theprotocolmodel: BasicType ::=pDN|pUD|pIP|pU|nT|nDH |nA| K |m|c|u, where the given symbols correspond to participant distin guished names, userdomain names, userip names, other user names, timestamps, DifﬁeHellman random numbers, otherrandomnumbers,keys,userdeﬁnedterms,certiﬁcates andunknownterms,respectively. Theunknown typeucorresponds to terms that can not be validated because of limited participant knowledge. By includingthisinformationinthespeciﬁcationweareablet o detect subtle typeﬂaw attacks using a syntactical compar ison of typed terms, that otherwise would require the con structionofa statespacethatcanbecomeratherlargeifwe considertheexistenceofmultipleprotocolsinthesamesys  tem[16]. Based on the deﬁned basic terms we can now proceed withthedeﬁnitionof canonicalterms : T::=.|BasicType |(T,T)| {T}FuncName (T). A canonical node is deﬁned as a signed canonical term usingthefollowingdeﬁnition. Deﬁnition 5. Acanonical node is any transmission or re ception of a canonical term denoted by /a\}bracketle{tσ,t/a\}bracketri}ht, witht∈ T andσoneofthesymbols +,−. Weuse(±T)todenoteaset ofcanonicalnodes. Let n∈(±T),thenwedeﬁnethefunc tioncsign(n)tomapthesignandthefunction cterm(n)to mapthecanonicaltermcorrespondingtoagivencanonical node. Before we proceed with the deﬁnition of canonical chains and canonical participant models we need to deﬁne classiﬁers . These are attached to participantchains and are used to transform canonical terms received from other par ticipants based on local participant knowledge. We deﬁne twosuchclassiﬁers: Classifier ::=CLP|CLV. The ﬁrst classiﬁer CLPdenotes the processing chain corresponding to a participant. This chain contains canon ical terms that correspond to participant knowledge. The second classiﬁer CLVdenotes the virtual chain used totransform received terms from the transmitted form to the receivedformbasedontheknowledgeofthereceivingpar ticipant. Deﬁnition 6. Acanonical participant chain is a sequence ofcanonicalnodes. A classiﬁed canonicalparticipantchain is a pair /a\}bracketle{tCL,lcc/a\}bracketri}ht, whereCL∈Classifier andlcc∈ (±T)∗. We use(±T)∗todenoteaset ofcanonicalpartici pantchains. Deﬁnition 7. Acanonical participant model is a pair /a\}bracketle{tpart,sl cc/a\}bracketri}ht, wherepart∈Pis a participant name and slcc∈(Classifier ×(±T)∗)∗isasetofclassiﬁedcanon icalparticipantchains. We use MPARTC to denotetheset ofallcanonicalparticipantmodels. Next, we deﬁne a canonical protocol model as a set of canonicalparticipantmodels. Deﬁnition 8. Acanonical protocol model is a collection of canonical participant models such that for each posi tivecanonicalnode n1thereis exactlyonenegativecanon ical node n2withcterm(n1) =cterm(n2). We use the MPROTC symbol to denotethe set of all canonicalproto colmodels. Based on the described protocol and canonical models, we proved, through the form of a proposition, that if two protocol models are instance independent and their corre spondingcanonicalmodelsarecanonicalindependent,then the intrudercan not construct attacks using terms extracte d from other protocols. In order to verify this we used an intrudermodelbasedontheDolevYao[5,6]modeltocap turethe powersthatcanbe usedbyanintruder. If two protocol models are independent, then their par ticipant chains can be composed. We use the ≺PC ς: MPART×MPART →MPART operator to denote the PC composition of protocol chains and the ≺PC ξ: MPROT ×MPROT →MPROT operator to denote the PC composition of protocol models. For the ﬁrst operator we useφςto denote the emptyparticipantmodel,while for thesecondoperatorweuse φξtodenotetheemptyprotocol model. IftwoprotocolmodelscanbecomposedPEandPC,then they can be composed. The composition operator we use to denote the composition of protocol models is ≺C: MPROT ×MPROT →MPROT, for which the generated emptyprotocolmodelisdenotedby φξ. By sequentially composing several protocol models the resultingprotocolmodelprovidesauniﬁedset ofprecondi tions and effects and a uniﬁed set of participantchains. By composing iprotocols, the resulting sequence is written as ξ1≺Cξ2≺C...≺Cξi.3.3 Composition algorithm The proposed composition method can be applied on protocolpairsor entire protocolsequences. Let SEQ1and SEQ2be two protocol sequences, where each sequence is constructed by subsequently applying the ≺Cop erator on protocol pairs, and n,m, two symbols denoting the number of protocols in the ﬁrst and in the second se quence,respectively. Then,thecompositionalgorithmmus t ensurethatthenewcomposedsequencemaintainsthesecu rity propertiesof the original protocolsand that the knowl  edgeavailable to protocolparticipantsallowsthe executi on of the new sequence. Verifying if protocols from the two sequencesmaintaintheirsecuritypropertiesrequiresapp ly ing thePARTNONDESTR predicate on each protocol pair and the veriﬁcation of the independence of the participant chains by using the PC composition operator ≺PC ς. As shown in Algorithm 1, if one of these conditions is not satisﬁed, the execution is stopped, symbolized using the @InterruptExecution keyword. If the protocol properties are not destructive, the execu tion of the composition algorithm continues with the com position of protocol components. The ﬁnal protocol is de noted by ξ, which, initially, contains a participant model withtheeffects PRINITandtypes TINIT. Thesedenotethe initial knowledge for protocol participants, extracted fr om thecontext ctx, auniﬁedcontextconstructedfromthecon textscorrespondingthethetwo sequences. The composition process locates the position of each protocolintheﬁnal sequencebyusingthecompositionop erator≺C ς. If the result is φς, the protocols can not be composedand anotherpair is selected. Finally,the remain ingprotocolsare addedtothesequence. 4 Experimental results In order to validate the proposed method we generated severalnewcomposedprotocols,basedonexistingones. In order to verify if the new protocols accumulated the prop erties of the initial protocols, i.e. the composition is non  destructive, we applied the method proposed in this paper. However, such a veriﬁcation is not enough for validating a methodthatmustensurethecorrectnessoftheresultedpro tocols, as shown by the large number of attacks discovered onprotocolslongaftertheyhavebeenpublished[3,7]. Havingtheseinmind,weturnedtoexistingprotocolver iﬁcation tools. The purpose of the veriﬁcation was to de termine if new attacks became available on the composed protocols. One of the few tools allowing the veriﬁcation of multiprotocol attacks is Scyther [4], which is the only tool currently available that also detects typeﬂaw attack s [19,20],commonlyfoundinmultiprotocolenvironments.Algorithm1 Compositionsteps {Veriﬁcationofnondestructiveproperties } forallξ1∈SEQ1andξ2∈SEQ2do forallς1∈ξ1andς2∈ξ2do Letς1=/a\}bracketle{tprec1,eff1,type1,gen1,part1,chain 1/a\}bracketri}ht, ς2=/a\}bracketle{tprec2,eff2,type2,gen2,part2,chain 2/a\}bracketri}ht, c1=PARTNONDESTR (eff1,prec2,eff2), c2=PARTNONDESTR (eff2,prec1,eff1) ifc1=False∨c2=False∨ς1≺PC ςς2=φς then @InterruptExecution end if end for end for {Compositionofprotocolsequences } Leti= 1,j= 1 Letξ={/a\}bracketle{tφ,PRINIT,TINIT,φ,.,φ/a\}bracketri}ht} whilei≤n∧j≤mdo Letξibetheithelementof SEQ1 Letξjbethejthelementof SEQ2 ifξ≺C ξξi/\e}atio\slash=φξthen ξ=ξi≺C ξξ,i=i+1 elseifξi≺C ξξ/\e}atio\slash=φξthen ξ=ξ≺C ξξi,i=i+1 end if ifξ≺C ξξj/\e}atio\slash=φξthen ξ=ξj≺C ξξ,j=j+1 elseifξj≺C ξξ/\e}atio\slash=φξthen ξ=ξ≺C ξξj,j=j+1 end if end while {Addremainingprotocols } whilei≤ndo ξ=ξ≺C ξξi,i=i+1 end while whilej≤mdo ξ=ξ≺C ξξj,j=j+1 end whileWe have applied our method on several pairs of secu rity protocols deﬁned in the library maintained by Clark and Jacob [21], for which there is also an online version available[22]. Throughourexperimentswecomposedpro tocol pairs such as CCITT X.509 v1 (i.e. X509v1) and CCITTX.509v1c(i.e. X509v1c),BANConcreteRPC(i.e. BANRPC)andLoweB(i.e. LoweBAN),LoweDenning Sacco (i.e. LDS) and KaoChow v1 (i.e. KCv1), Lowe Kerberos (i.e. LoweKerb) and NeumanStubblebine (i.e. NeumanS),HwangNeumanStubblebine(i.e. HNS) and NeumanStubblebine, NeedhamSchroeder (i.e. NeedhS) and CCITT X.509 v1, LoweNeedhamSchroeder (i.e. L NS) and ISO9798,OtwayRees (i.e. OtwayR) and Lowe BAN, YahalomLowe (i.e. YL) and KaoChow v1, as showninTable1. Thenondestructivepropertyofthecom posedprotocolwasvalidatedusingthe Scythertool. In Table 1, S1 indicates the protocol composition se quence P1P2, while S2 indicates the sequence P2P1. We used “Y” to indicate the successful composition of a se quence and “N” the failure of the composition process. By applyingtheproposednondestructivityconditionswehav e discovered several new multiprotocol attacks. For exam ple, in case of the protocol pair YahalomLowe and Kao Chow, we discovered a new attack that gives the intruder thepossibilitytoreplayvalidmessagesfromtheKaoChow v1 (i.e. KCv1) protocol into the YahalomLowe(i.e. YL) protocol. We have created a composed protocol and used the Scyther tool to verify it. The result was that 2 new at tackswerepossible. Aftercorrectingtheproblembyadding additionaltermsto the protocolsmessagesin orderfor par ticipantsto be able to verifythe validityof these messages , the Scyther tool did not detect any attacks, which was also conﬁrmedbyourmethod. 5 Related work "
160,R4: A Framework for Route Representation and Route Recommendation.txt,"Route recommendation is significant in navigation service. Two major
challenges for route recommendation are route representation and user
representation. Different from items that can be identified by unique IDs in
traditional recommendation, routes are combinations of links (i.e., a road
segment and its following action like turning left) and the number of
combinations could be close to infinite. Besides, the representation of a route
changes under different scenarios. These facts result in severe sparsity of
routes, which increases the difficulty of route representation. Moreover, link
attribute deficiencies and errors affect preciseness of route representation.
Because of the sparsity of routes, the interaction data between users and
routes are also sparse. This makes it not easy to acquire user representation
from historical user-item interactions as traditional recommendations do. To
address these issues, we propose a novel learning framework R4. In R4, we
design a sparse & dense network to obtain representations of routes. The sparse
unit learns link ID embeddings and aggregates them to represent a route, which
captures implicit route characteristics and subsequently alleviates problems
caused by link attribute deficiencies and errors. The dense unit extracts
implicit local features of routes from link attributes. For user
representation, we utilize a series of historical navigation to extract user
preference. R4 achieves remarkable performance in both offline and online
experiments.","Route recommendation plays an important role in navigation service, since it affects travel experience of users. When a user requests a route planning from an origin to a destination, navigation service will gather hundreds of available routes and then select several of them to recommend to the user. The user chooses one route and enjoys his travel accompanying with the navigation service. If the user deviates from the chosen route as shown in Figure 1, it implies user dissatisfaction with the route to a certain extent. Since user satisfaction is determined by route characteristics and user preference, the representations of route and user are two vital parts of route recommendation. The sparsity of routes makes route representation a challenging task. It is not practical to assign a unique ID to each route as other recommendation systems do to an item, such as YouTube recommen dations (Covington et al., 2016), Wide &Deep framework (Cheng et al., 2016) and DIN (Zhou et al., 2018). The reason is that routes are combinations of links and the number of combinations could be close to inﬁnite, where link is deﬁned as the concatenation of a road segment and its following action (e.g., going forward and turning left). Besides, the representations of a route under different scenarios, such as different trafﬁc conditions, could be different. These facts make routes severely sparse, enlarging difﬁculty of learning route representation. Moreover, sufﬁcient and accurate link attributes are signiﬁcant for route representation. However, some route characteristics cannot be depicted by existing statistical features. For example, if there are a lot of cars parked on both sides of a road, it is not very easy to drive through it. Finding a feature to describe such characteristic is a complicated task. Besides, data errors occasionally appear in link *These authors contribute equally.arXiv:2110.10474v2  [cs.AI]  25 Oct 2021OD origindestinationalternativeroutechosenrouteusertrajectorydeviation OD origindestination usertrajectorydeviationalternativeroutechosenrouteFigure 1: Deviation. As long as the user trajectory deviates from the chosen route, it will be regarded as a deviation, whether the user deviates to an alternative route (left) or a route which is not displayed (right). attributes. For instance, a blocked road is mistakenly identiﬁed as a passable road. These problems also make it challenging to acquire precise route representation. In addition to route representation, user representation is also pivotal in route recommendation. Tradi tional recommendations utilize historical useritem interactions to extract user preference for items. For example, if a user frequently clicks on a set of items recently, there is a high probability that he will buy one of them. However, as aforementioned, routes are severely sparse. It implies that the interactions between users and routes are sparse as well. Hence, it is not feasible to learn user representation from historical userroute interactions. To address above issues, we propose a novel framework R4. In addition to routelevel features, R4 introduces linklevel features to obtain route representation. A sparse &dense network is designed to generate two types of route representations. The sparse unit learns link ID embeddings and aggregates them to represent a route. It is capable of discovering implicit characteristics of the route, which subse quently alleviates problems caused by link attribute deﬁciencies and errors. For the dense part, we refer to the ideas of residual network (He et al., 2016) and sentence CNN (Rakhlin, 2016). A deep residual network is applied to capturing different levels of route local features (i.e., detours) and then aggregating them to represent a route. With regard to user representation, a series of user historical navigation are utilized to extract user preference. After that, DCNV2 (Wang et al., 2020) is adopted to generate com bination features from two types of route representations and user representation. R4 achieves superior performance on both ofﬂine and online experiments. We carry out an analysis on link embeddings and ﬁnd out that they contain information of link static attributes, which validates the effectiveness of route representation in R4. Furthermore, a similarity unit is designed to expose hidden characteristics of links. It learns similarity scores between link ID embed dings and vectors of link static attributes. A smaller similarity value implies more hidden information contained in the ID embedding of a link. By conducting analysis on links with small similarity values, we discover some hidden features, which proves that R4 has the ability to capture implicit characteristics in addition to static attributes of links. Meanwhile, these hidden features could be helpful in discovering new attributes or correcting data errors in link attributes. This procedure can provide more sufﬁcient and accurate link static features, which in return beneﬁts route representation learning. Thus, the contribution of this paper is fourfold: • A learning framework R4 is proposed for route representation and route recommendation, and itachieves remarkable performance on both ofﬂine and online experiments. • To the best of our knowledge, we are the ﬁrst to introduce link IDs in route representation. • The sparse &dense network proposed in this paper represents a route from both link IDs and link attributes, which can be applied to route representation in any scenario. • The similarity unit is designed to expose implicit characteristics of links, which is helpful in ﬁnding new attributes and correcting attribute errors, and in return, provides sufﬁcient and accurate link data for route representation learning. 2 Related Work "
53,Multi-Entanglement Routing Design over Quantum Networks.txt,"Quantum networks are considered as a promising future platform for quantum
information exchange and quantum applications, which have capabilities far
beyond the traditional communication networks. Remote quantum entanglement is
an essential component of a quantum network. How to efficiently design a
multi-routing entanglement protocol is a fundamental yet challenging problem.
In this paper, we study a quantum entanglement routing problem to
simultaneously maximize the number of quantum-user pairs and their expected
throughput. Our approach is to formulate the problem as two sequential integer
programming steps. We propose efficient entanglement routing algorithms for the
two integer programming steps and analyze their time complexity and performance
bounds. Results of evaluation highlight that our approach outperforms existing
solutions in both served quantum-user pairs numbers and the network expected
throughput.","Quantum networks enable to generate, transmit and com pute quantum information (qubits) in addition to classical data between quantum (ebits) processors [25]. It supports massive quantum applications in both quantum computing and quantum communication systems, such as distributed quantum computing [26], [27], quantum communication [28], quantum machine learning [29] and quantum key distribution [30]. Several quantum systems have been constructed, such as longdistance link (40 kilometers) teleportation over the ﬁber link [31], the mobile quantum network [33], and the integrated entanglement system through satellites which can support the entanglement over 4600 kilometers [32]. Entanglement is an essential component of most quantum applications mentioned above. For example, the quantum key distribution system has provable security for the distributed information [25] by taking advantage of the entanglement and nocloning theorem [34]. Supporting the longdistance entanglement is fundamental for quantum networks. However, the entanglement process is probabilistic and not stable. Dif ferent from binary ebits in traditional communication, qubits created by photons are extremely fragile. The successful entanglement rate among qubits decreases exponentially with the transmission length. Hence, to enable longdistance entan glement of quantum users in the quantum network, quantum switches are placed in the network as relays to supply end toend entanglements for multiple quantum users that demandthem [6], [42]. Quantum switches are equipped with quantum memories (qubits) and have the ability to perform multiqubits measurement (swapping) [42]. Theentanglement routing problem about how to build long distance entanglement through quantum switches is crucial in the quantum network. Thoughtful design for the entanglement routing in the quantum network can boost the network perfor mance by efﬁciently utilizing resources, e.g., switch memories. While largescale quantum networks have not been im plemented out of the lab due to physical and experimental challenges, it is still valuable to investigate the entanglement routing problem from the network layer for the future. The entanglement routing problem has been drawing great at tention in previous studies. [7], [14], [36], [40]–[42] study the entanglement routing problem or theoretical entanglement performance on the special network topologies such as a single switch, single entanglement path, rings, grids, or spheres. [1], [15] consider a general quantum network for multiple quantum users pairs entanglement. However, their strategy is a greedy algorithm to maximize the throughput of the quantum user pair one by one which might assign too many resources to limited quantum users, and other quantum users are neglected. The proposed algorithm incurs high time complexity and lacks the performance guarantee. Moreover, most existing works treat the transmission link capacity as the main bottleneck of the network. However, the switch resource (the number of qubits) is the limitation of the quantum network in reality instead of the transmission link capacity. A most recent quantum processor can only have up to 8 qubits [18]. An optical ﬁber cable can contain up to 25 cores, each core can be used as an independent link for the entanglement. Multiple optical ﬁber cables can be placed between quantum switches. Hence, the transmission link has enough capacity to serve the entanglement demands for the quantum users in current quantum networks. In this paper, we consider a general quantum network structure and present a comprehensive entanglement process for multiple pairs of quantum users. Our goal is to maximize the number of quantumuser pairs and the expected network throughput at the same time . Our contributions are as follows: 1) We describe the detailed multientanglement routing process for multiple quantumuser pairs as the ofﬂine and the online stages. 2) We formulate the problem as two integer linear program ming problems that are both NPComplete.zBoth authors contributed equally to this research.arXiv:2205.15501v1  [cs.NI]  31 May 20223) We design the routing protocol by proposing efﬁcient algorithms with lower time complexity and performance guarantees. 4) Results of evaluation highlight that our approach can improve the number of served quantumuser pairs 85% and the expected throughput 27% in average compared with existing works. To the best of our knowledge, this is the ﬁrst paper to maximize the network served quantumuser pairs number and expected throughput simultaneously. The organization of the paper is as follows: we ﬁrst in troduce the background of the quantum network and the multientanglement routing process in Section II. Then, we present the quantum network model and formulate the rout ing entanglement process as two integer linear programming problems in Section III based on the routing process intro duced in Section II. The entanglement routing algorithms are proposed in Section IV and Section V for two integer linear programming problems, respectively. We conduct extensive simulations to discuss and analyze the performance of our proposed algorithms and compare them with previous work in Section VI, followed by related work in Section VII the conclusion in Section VIII. II. Q UANTUM NETWORK BACKGROUND In this section, we introduce some basic quantum network backgrounds, including quantum network components and multirouting entanglement processes. A. Quantum Communication 1) Qubit: In the quantum network or quantum computing, a qubit is the basic unit to represent quantum information. A qubit can be an electron or a photon or a nucleus from an atom. A qubit is described by its state [25]. Different from an ebit in the classical Internet representing 0 or 1, a qubit can present a coherent superposition of both. 2) Entanglement: Entanglement is a phenomenon that a group of qubits expresses a high correlation state which can not be explained by individual qubits states. In this paper, we consider the simplest case of two qubits entanglement which is bipartite entangled states. In quantum physic, a simple way to entangle two independent qubits is by using CNOT gate [8]. When the entanglement qubits number is two, Bellstate measures (BSMs) can be applied to measure the entanglement. 3) Teleportation: If a pair of entanglement quibts are shared by two nodes, the secret information can be transmitted from one node to another one with the help of quantum measurement. This process is called teleportation. An example is illustrated in Figure 1. Fig. 1. A Teleportation Example. The source node teleport a qubit by a pair of entanglement qubits.4) Entanglement Swapping: Figure 2 presents an example of swapping. If Alice shares an entangled qubit pair (Bell pair) with the middle node Carol, and Carol shares another entangled qubit pair with Bob, Carol can teleport its qubit entangled with Alice to Bob, then Alice and Bob are entangled directly [9]. Fig. 2. A Swapping Example. B. Quantum Network Components With these basic concepts, we ﬁrst introduce several impor tant components in the quantum network. 1) Quantum Users: A quantum user has demands to en tangle with another user in the quantum network for quantum communication. We assume that there is a direction between a pair of quantum users intending to be entangled. The user who intends to entangle with another user is called a source node. Another user who tried to be entangled is called a destination node. 2) Quantum Switches: The quantum switch is a node with quantum memories to work as relays for the entanglement process in the quantum network [10], [42]. They can either transmit qubits or establish the entanglement at distant nodes without physically sending an entangled qubit by swapping. 3) Quantum Links: Quantum links are the links used for connecting quantum switches and quantum users. In this paper, we assume that the quantum network is connected by optical ﬁber cables among quantum switches and quantum users. The successful entanglement generation probability is related to the material and the length of the quantum link, i.e., p=e"
272,A Semi-distributed Reputation Based Intrusion Detection System for Mobile Adhoc Networks.txt,"A Mobile Adhoc Network (MANET) is a cooperative engagement of a collection of
mobile nodes without any centralized access point or infrastructure to
coordinate among the peers. The underlying concept of coordination among nodes
in a cooperative MANET has induced in them a vulnerability to attacks due to
issues like lack of fixed infrastructure, dynamically changing network
topology, cooperative algorithms, lack of centralized monitoring and management
point, and lack of a clear line of defense. We propose a semi-distributed
approach towards Reputation Based Intrusion Detection System (IDS) that
combines with the DSR routing protocol for strengthening the defense of a
MANET. Our system inherits the features of reputation from human behavior,
hence making the IDS socially inspired. It has a semi-distributed architecture
as the critical observation results of the system are neither spread globally
nor restricted locally. The system assigns maximum weightage to self
observation by nodes for updating any reputation values, thus avoiding the need
of a trust relationship between nodes. Our system is also unique in the sense
that it features the concepts of Redemption and Fading with a robust Path
Manager and Monitor system. Simulation studies show that DSR fortified with our
system outperforms normal DSR in terms of the packet delivery ratio and routing
overhead even when up to half of nodes in the network behave as malicious.
Various parameters introduced such as timing window size, reputation update
values, congestion parameter and other thresholds have been optimized over
several simulation test runs of the system. By combining the semi-distributed
architecture and other design essentials like path manager, monitor module,
redemption and fading concepts; Our system proves to be robust enough to
counter most common attacks in MANETs.","The term adhoc networks dates back to the 1970’s where an adhoc network was ﬁrst setup as a part of certain defense research projects. With advances in microelectronics technol ogy and networking protocols, it has been possible to integrate mobile nodes and various other network devices into a single unit called an adhoc node. Further, interconnection of these nodes wirelessly is termed as an adhoc network . MANET s are different from conventional networks. A MANET is formed by an autonomous system of mobile nodes that are selfconﬁguring and have no constraints, such as a ﬁxed infrastructure or a central administration system. Nodes in MANET s are both routers and terminals. They are dynamic in the sense that each node is free to join and leave the network in a nondeterministic way. In addition, they do not have a clearly deﬁned physical boundary, and therefore, no speciﬁc entry orexit point. Such a network can thus be rapidly deployed and can provide the amount of ﬂexibility and adaptability which is otherwise unattainable under adverse circumstances. Although MANET is a very promising technology, challenges are slowing its development and deployment. Nodes in adhoc networks are in general limited in battery power, memory and CPU capacity. Hence the transmission ranges of these devices are also limited and nodes have to rely on neighbor nodes in the network to route the packet to its destination. They are sometimes referred to as multihop networks, where a hop is a direct link between two nodes. Adhoc networks have found applications in emergency rescues, battleﬁeld operations, mobile conferenc ing, national crisis, home and community networking, disaster recovery etc. The ﬂexible structure and volatile environment of MANET s results in signiﬁcant node misbehavior. Not only does it degrade the overall network performance, but, it also becomes difﬁcult to detect intruders on grounds of mobility and vulner ability of the nodes. Thus, there is a serious need for a robust IDSfor MANET s. Some fundamental problems of MANET s must be kept in mind while designing any security solution. Firstly, it is often very hard to differentiate intrusions and normal operations or conditions in MANET s because of the dynamically changing topology and volatile physical environment. Secondly, mobile nodes are autonomous units that are capable of roaming independently in an unrestricted geographical topology. This means that nodes with inadequate physical protection can be captured, compromised or hijacked. Thirdly, decisionmaking in adhoc networks is usually decentralized and many adhoc network algorithms rely on the cooperative participation of all nodes. Most adhoc routing protocols are also cooperative in nature and hence can be easily misguided by false routing information. Without any counter policy, the effects of mis behavior have been shown to dramatically decrease network performance. In this paper, we propose a new technique based on reputation for efﬁciently solving the problem of intrusion detection. The next section gives a brief background about routing related issues in MANET s, section III entails a discussion of some related efforts which is followed by the system design overview in section IV . Section V describes the protocol andarXiv:1006.1956v2  [cs.NI]  11 Jun 2010the following section VI talks about its implementation details. Simulation results and optimization procedures for parameters such as window size are given in the section VII. The last section presents some concluding remarks. II. B ACKGROUND In order to understand the nature of attacks on MANET s, we ﬁrst need to look at the routing protocols for these networks. They have been classiﬁed under two main categories  Proactive and Reactive routing protocols. Proactive protocols work with tables that are used to store routing information and updates are triggered to propagate any information about changes throughout the whole network. The obvious advantage is that routes to any destination node are always available without the overhead of generating a route request whenever the need for a route arises. But, an extra overhead is always a major issue before deploying a proactive routing protocol, because it generally affects the overall throughput and power usage. DestinationSequenced Distance Vector (DSDV ) [1], Wireless Routing Protocol ( WRP) [2], Cluster Gateway Switch Routing ( CGSR ) [3] are some common examples. On the other hand, Reactive routing protocols are ondemand i.e. a route discovery mechanism is initiated whenever there is a need for setting up a path for communication between a source and a destination node. The source node initiates route discovery by ﬂooding the network successively with route queries. The destination node on receiving a route request ( RREQ ) addressed to it, sends back a route reply ( RREP ) message as unicast to the source node either through the discovered route or by initiating another route request. Generally, ondemand routing requires less overhead than tabledriven routing; but it incurs a path discovery delay whenever a new path is needed. Dynamic Source Routing protocol ( DSR) [4], Adhoc OnDemand Distance Vector Routing ( AODV ) protocol [5], Temporally Ordered Routing Algorithm ( TORA ) [6], AssociativityBased Routing (ABR) [7], Signal Stability Routing ( SSR) [8], ZoneBased Hierarchical Link State Routing Protocol ( ZRP) [9] are a few examples. Attacks are possible on reactive protocols like DSR due to lack of builtin security measures and the assumption of honest coordination and cooperation among nodes and with the protocol. We will outline a few attacks by nodes below, the others are discussed in detail by Sonja Buchegger et. al. [10]: Dropping all packets not destined to it or performing only partial dropping. Partial dropping can be restricted to speciﬁc types, such as only data packets or route control packets or packets destined to speciﬁc nodes. Sending forged routing packets, an attacker can create a socalled black hole, a node where all packets are discarded or all packets are lost. Modifying the nodes list in the header of a RREQ or a RREP to misroute packets and adding incorrect routes inthe route cache of other nodes. Decreasing the hop count DSR(TTL) when receiving a packet, so that the packet will never be received by the destination. This attack could be detected by the previous node in route by enhanced passive acknowledgment. Initiating frequent RREQ to consume bandwidth and en ergy and to cause congestion. III. R ELATED WORK "
33,QoSIP: A QoS Aware IP Routing Ptotocol for Multimedia Data.txt,"Conventional IP routing protocols are not suitable for multimedia
applications which have very stringent Quality-of-Service (QoS) demands and
they require a connection oriented service. For multimedia applications it is
expected that the router should be able to forward the packet according to the
demand of the packet and it is necessary to find a path that satisfies the
specific demands of a particular application. In order to address these issues,
in this paper, we have presented a QoS aware IP routing protocol where a router
stores information about the QoS parameters and routes the packet accordingly.
  Keywords: IP Routing Protocol, Quality of Service (QoS) parameter, QoSIP,
Selective Flooding.","     QoS routing is the routing technique where packet is routed  from source to destination selecting the path that satisfies the  QoS (i.e., Bandwidth and Delay) requirements. Multimedia data are sensitive to bandwidth and delay.  Resource  reservation is a necessity for guaranteed endtoend  performance for multimedia applications. However, resource reservation is not well supported in the current routing protocols used in IP network layer. Also, the data packets of  these applications could follow different paths and reach the  destination out of order, which is not desirable.    Again, multimedia applications demand guaranteed amount  of work resources like bandwidt h, delay, buffer space, CPU  time etc. So, packets need to be routed based on their different QoS requirements, which are not supported by the  current IP network. Packets are often routed over paths that  are unable to support their requirements, while alternate paths with sufficient resources exist. Hence, there is a need for QoS  aware IP routing, which will satisfy the above requirements.  The goal of such QoS aware routing algorithm is to find a path in the network that satisfies the given requirements.     In order to address the abovementioned issues, in this  paper, we have proposed a new packet forwarding technique for designing a QoS aware IP routing protocol (QoSIP). In the proposed packet forwarding technique best path will be  calculated on the fly whenever a path selection is necessary.  For updating state information in the routing table of a router the routers will use “Class based triggering” and the router  will maintain state information up to its twodegree  neighborhood to bind the flooding. From the performance evaluation of the proposed QoS aware IP routing protocol, it is expected to decrease the computational cost by a large amount and to reduce the protocol overhead to improve the  network utilization as well as to fulfill the QoS requirements  for packet. The motivation for using a path selection process,  based on these requirements is for the hope that it will increase both the services received by users and the overall  network efficiency.      The rest of the paper is organized as follows: Section 2 illustrates a review on the related works that have been done  on QoS aware IP routing protocols, Section 3 elaborates the  proposed QoS aware IP routing protocol (QoSIP), Section 4 presents the simulated result of the proposed QoS aware IP  routing protocol using the network simulator NS2, Section 5  performs the performance evaluation of the proposed protocol and Section 6 concludes the paper.    2. Related Works  "
54,D4RL: Datasets for Deep Data-Driven Reinforcement Learning.txt,"The offline reinforcement learning (RL) setting (also known as full batch
RL), where a policy is learned from a static dataset, is compelling as progress
enables RL methods to take advantage of large, previously-collected datasets,
much like how the rise of large datasets has fueled results in supervised
learning. However, existing online RL benchmarks are not tailored towards the
offline setting and existing offline RL benchmarks are restricted to data
generated by partially-trained agents, making progress in offline RL difficult
to measure. In this work, we introduce benchmarks specifically designed for the
offline setting, guided by key properties of datasets relevant to real-world
applications of offline RL. With a focus on dataset collection, examples of
such properties include: datasets generated via hand-designed controllers and
human demonstrators, multitask datasets where an agent performs different tasks
in the same environment, and datasets collected with mixtures of policies. By
moving beyond simple benchmark tasks and data collected by partially-trained RL
agents, we reveal important and unappreciated deficiencies of existing
algorithms. To facilitate research, we have released our benchmark tasks and
datasets with a comprehensive evaluation of existing algorithms, an evaluation
protocol, and open-source examples. This serves as a common starting point for
the community to identify shortcomings in existing offline RL methods and a
collaborative route for progress in this emerging area.","Figure 1: A selection of pro posed benchmark tasks.Impressive progress across a range of machine learning applica tions has been driven by highcapacity neural network models with large, diverse training datasets (Goodfellow et al., 2016). While reinforcement learning (RL) algorithms have also beneﬁted from deep learning (Mnih et al., 2015), active data collection is typi cally required for these algorithms to succeed, limiting the extent to which large, previouslycollected datasets can be leveraged. Of ﬂine RL (Lange et al., 2012) (also known as full batch RL), where agents learn from previouslycollected datasets, provides a bridge between RL and supervised learning. The promise of ofﬂine RL is leveraging large, previouslycollected datasets in the context of Website with code, examples, tasks, and data is available at https://sites.google.com/view/ d4rl/ 1arXiv:2004.07219v4  [cs.LG]  6 Feb 2021sequential decision making, where rewarddriven learning can produce policies that reason over temporally extended horizons. This could have profound implications for a range of application domains, such as robotics, autonomous driving, and healthcare. Current ofﬂine RL methods have not fulﬁlled this promise yet. While recent work has investigated technical reasons for this (Fujimoto et al., 2018a; Kumar et al., 2019; Wu et al., 2019), a major challenge in addressing these issues has been the lack of standard evaluation benchmarks. Ideally, such a benchmark should: a)be composed of tasks that reﬂect challenges in realworld applications of datadriven RL, b)be widely accessible for researchers and deﬁne clear evaluation protocols for reproducibility, and c)contain a range of difﬁculty to differentiate between algorithms, especially challenges particular to the ofﬂine RL setting. Most recent works (Fujimoto et al., 2018b; Wu et al., 2019; Kumar et al., 2019; Peng et al., 2019; Agarwal et al., 2019b) use existing online RL benchmark domains and data collected from training runs of online RL methods. However, these benchmarks were not designed with ofﬂine RL in mind and such datasets do not reﬂect the heterogenous nature of data collected in practice. Wu et al. (2019) ﬁnd that existing benchmark datasets are not sufﬁcient to differentiate between simple baseline approaches and recently proposed algorithms. Furthermore, the aforementioned works do not propose a standard evaluation protocol, which makes comparing methods challenging. Why simulated environments? While relying on (existing) realworld datasets is appealing, evalu ating a candidate policy is challenging because it weights actions differently than the data collection and may take actions that were not collected. Thus, evaluating a candidate policy requires either col lecting additional data from the realworld system, which is hard to standardize and make broadly available, or employing offpolicy evaluation, which is not yet reliable enough (e.g., the NeurIPS 2017 Criteo Ad Placement Challenge used offpolicy evaluation, however, in spite of an unprece dentedly large dataset because of the variance in the estimator, top entries were not statistically distinguishable from the baseline). Both options are at odds with a widelyaccessible and repro ducible benchmark. As a compromise, we use highquality simulations that have been battletested in prior domainspeciﬁc work, such as in robotics and autonomous driving. These simulators allow researchers to evaluate candidate policies accurately. Our primary contribution is the introduction of Datasets for Deep DataDriven Reinforcement Learning (D4RL): a suite of tasks and datasets for benchmarking progress in ofﬂine RL. We fo cus our design around tasks and data collection strategies that exercise dimensions of the ofﬂine RL problem likely to occur in practical applications, such as partial observability, passively logged data, or human demonstrations. To serve as a reference, we benchmark stateoftheart ofﬂine RL algo rithms (Haarnoja et al., 2018b; Kumar et al., 2019; Wu et al., 2019; Agarwal et al., 2019b; Fujimoto et al., 2018a; Nachum et al., 2019; Peng et al., 2019; Kumar et al., 2020) and provide reference implementations as a starting point for future work. While previous studies (e.g., (Wu et al., 2019)) found that all methods including simple baselines performed well on the limited set of tasks used in prior work, we ﬁnd that most algorithms struggle to perform well on tasks with properties crucial to realworld applications such as passively logged data, narrow data distributions, and limited human demonstrations. By moving beyond simple benchmark tasks and data collected by partiallytrained RL agents, we reveal important and unappreciated deﬁciencies of existing algorithms. To facilitate adoption, we provide an easytouse API for tasks, datasets, and a collection of benchmark imple mentations of existing algorithms ( https://sites.google.com/view/d4rl/ ). This is a common starting point for the community to identify shortcomings in existing ofﬂine RL methods, and provides a meaningful metric for progress in this emerging area. 2 R ELATED WORK "
85,Mapping Matters: Application Process Mapping on 3-D Processor Topologies.txt,"Applications' performance is influenced by the mapping of processes to
computing nodes, the frequency and volume of exchanges among processing
elements, the network capacity, and the routing protocol. A poor mapping of
application processes degrades performance and wastes resources. Process
mapping is frequently ignored as an explicit optimization step since the system
typically offers a default mapping, users may lack awareness of their
applications' communication behavior, and the opportunities for improving
performance through mapping are often unclear. This work studies the impact of
application process mapping on several processor topologies. We propose a
workflow that renders mapping as an explicit optimization step for parallel
applications. We apply the workflow to a set of four applications, twelve
mapping algorithms, and three direct network topologies. We assess the
mappings' quality in terms of volume, frequency, and distance of exchanges
using metrics such as dilation (measured in hop$\cdot$Byte). With a parallel
trace-based simulator, we predict the applications' execution on the three
topologies using the twelve mappings. We evaluate the impact of process mapping
on the applications' simulated performance in terms of execution and
communication times and identify the mappings that achieve the highest
performance in both cases. To ensure the correctness of the simulations, we
compare the pre- and post-simulation results. This work emphasizes the
importance of process mapping as an explicit optimization step and offers a
solution for parallel applications to exploit the full potential of the
allocated resources on a given system.","The growing amount of computing elements in HPC systems inherently presents a new bottleneck in terms of the necessary communication for data distribution as well as controlling the application processing elements, e.g., tasks, threads, and processes. Therefore, the performance of parallel applications highly depends on their communi cation behavior. Nowadays, parallel applications execute on a broad range of parallel computing ar chitectures, from large supercomputers to embedded lowpower architectures. When these applications execute on parallel systems, their communication time is aected by how intensely their processing elements exchange data, by the capacity and per formance of the network links, and by the placement of processing elements on the computing resources . Application placement is typically the result of a mapping algorithm. Ecient application placement on modern hardware architectures is of paramount importance for performance [12,24,29,39,48]. A poor choice of the mapping algorithm may lead to larger communication latencies and, therefore, to signicant performance loss and en ergy waste. A plethora of communication and/or topologyaware mapping algorithms emerged over the years in the literature to improve application process placement (see [29] for a recent overview). Process mapping, also known as topology mapping or application process place ment, is an active area of research with a vast history that includes algorithms whose performance benets have been recorded in numerous situations. For instance, com munication and/or topologyaware mapping techniques combine information about the target application (its communication pattern orvirtual topology ) and the target system (its physical topology ) to take mapping decisions following a performance ob jective, e.g., minimizing dilation ,distance ,volumedistance , or congestion [29]. Other approaches simply employ spacelling curves (SFCs) [13] which essentially generate mappings based on common communication patterns. Given the need to achieve high performance and mitigate resource waste, many application developers and users face the following questions: 1.How can one verify if an application is suering from poor communication per formance? 2.How much does process mapping impact an application's performance on a given system? 3.Which mapping algorithm is the highest performing for a given application{ system pair? The absence of simple answers to these questions has severe consequences. While a na ve process mapping may lead to performance loss, an inapt mapping may cause 2longer execution times in addition to the overhead associated with generating the map ping itself. Over time, such performance loss for one or several applications translates into congested or wasted resources and increased energy consumption. Moreover, per forming repeated experiments to identify the highest performing mapping algorithm is neither sustainable nor scalable. This results in process mapping often being ignored as an explicit application optimization step. In this work, we study the impact of application process mapping on several proces sor topologies. We propose a work ow to support mapping as an explicit application optimization step. We apply the work ow to four applications, mapped using twelve mapping algorithms, executing on three direct network topologies. This work makes the following contributions: (i) it proposes a generic work ow to support process mapping as an explicit application optimization step; (ii) it provides an analysis on the predicted mapping benet for a given application{system pair; and (iii) it contributes a Pythonbased library with wellknown topology mapping algorithms from the literature. This work is organized as follows. The work related to application optimization through careful placement is reviewed in Section 2. The generic work ow for mapping applications onto processor topologies is introduced and described in Section 3. The application characteristics and evaluation metrics are presented in Section 4, while the processor topologies and network models are discussed in Section 5. Section 6 provides a description of the mapping algorithms. The design of performance experiments and their evaluation and analysis are presented in Section 7. Section 8 concludes the work and outlines future work directions. 2 Related Work "
333,A Lightweight and Attack Resistant Authenticated Routing Protocol for Mobile Adhoc Networks.txt,"In mobile ad hoc networks, by attacking the corresponding routing protocol,
an attacker can easily disturb the operations of the network. For ad hoc
networks, till now many secured routing protocols have been proposed which
contains some disadvantages. Therefore security in ad hoc networks is a
controversial area till now. In this paper, we proposed a Lightweight and
Attack Resistant Authenticated Routing Protocol (LARARP) for mobile ad hoc
networks. For the route discovery attacks in MANET routing protocols, our
protocol gives an effective security. It supports the node to drop the invalid
packets earlier by detecting the malicious nodes quickly by verifying the
digital signatures of all the intermediate nodes. It punishes the misbehaving
nodes by decrementing a credit counter and rewards the well behaving nodes by
incrementing the credit counter. Thus it prevents uncompromised nodes from
attacking the routes with malicious or compromised nodes. It is also used to
prevent the denial-of-service (DoS) attacks. The efficiency and effectiveness
of LARARP are verified through the detailed simulation studies.","A mobile adhoc network (MANET) is a multihop wireless network, a temporary and without  infrastructure in which the nodes can move randomly. These MANETS are able to extend their  wireless transmission range of each node by multihop packet forwarding. So these MANETS  are suited for the situations in which pre deployed infrastructure support is not available. An ad  hoc network doesn’t have any fixed infrastructure like base stations or mobile switching centers.  Mobile nodes which are within the radio range to each other can communicate directly through  wireless links, whereas the nodes which are far away depend on other nodes to communicate  messages as routers. In an ad hoc network the node mobility causes frequent changes of the  network topology. Mobile ad hoc networks have their applications in both military and civilian  circumstances due to their selforganizing and selfconfiguring potentials.  The routing aspects of MANETs are discussed earlier, while the research activities about  security in MANETs are in their beginning stage. Apart from the regular network problems  MANETs creates new security problems. Ad hoc networks use all the available nodes for  routing and forwarding to increase the throughput of the total network.  Therefore when more 	 	  	  	   	      17 nodes participate in packet routing, it increases the total bandwidth and decreases the possible  routing paths and also the possibility of network partition.   When a node is overloaded, selfish, malicious or broken it may misbehave by not approving to  forward packets. An overloaded node does not have the CPU cycles, buffer space or available  network bandwidth to forward packets. A selfish node expects other nodes to forward packets  because it is not willing and does not have direct interest to spend its battery life, CPU cycles or  available network bandwidth to forward packets. A malicious node introduces a denial of  service attack by dropping packets. A broken node prevents it from forwarding packets by  having a software fault.  The mobile ad hoc network needs more security mechanisms than in fixed networks. Through  the compromised nodes attackers can interrupt into the network. When the nodes join or leave  the network, and roam in the network often, then the network topology becomes highly  dynamic. Mobile users request security services when they move from one place to another due  to its dynamic nature. To achieve protection and high network performance, a powerful security  solution is needed, otherwise   · The security system may misbehave when an attacker infiltrates the security system.   · The network performance may be degraded by the misbehavior of the nodes.  · The malicious nodes can work as routers and stops the network from delivering the  packets correctly when they are not protected properly.     For example, the malicious node can declare faulty routing updates which are spread through all  over the network or it may drop the packets which are passing across them. A very important  security issue in ad hoc network is to protect the operations of their network layer from  malicious attacks. In a distributed computer systems, there are lot of familiar attacks which  include    · Denial of Service: Due to overload or malfunction the network service is not available  · Information theft:  Through an illegal instance, information is read.   · Intrusion: Through an unauthorized person, access is achieved to some restricted  service.  · Tampering: Through an unauthorized person, the modification is achieved.  In this paper, we propose to develop a Lightweight and Attack Resistant Authenticated Routing  Protocol (LARARP) for mobile ad hoc networks, which will mitigate the routing misbehavior of  nodes in mobile ad hoc networks.   The protocol involves:  · The destination node authenticates the source node  · The destination node authenticates every intermediate node listed in the packet header 	 	  	  	   	      18 · The source and destination node confirm the correctness of node’s sequence in the node  list  · Well behaving nodes are rewarded by more credits and misbehaving nodes are  punished by reducing the credits    2. RELATED WORK  "
116,Enhanced aodv route discovery and route establishment for qos provision for real time transmission in manet.txt,"MANET is a temporary connection of mobile nodes via wireless links having no
centralized base station. We developed a protocol with an enhanced route
discovery mechanism that avoids the pre-transmission delay. When a source node
wants to communicate with another node, it broadcast RREQ. EAODV give priority
to the source node of real time transmission. When RREQ packet send to neighbor
node, for real time transmission it accept route request on priority basis and
the drop ratio of packets decreased, then throughput increases by receiving
more packets at destination and delivery ratio also increased through these QOS
improved.","  Wireless ADHOC network is distributed network havi ng no centralized infrastructure, each  node forward data packets in routing, sometimes oth er normal nodes may become router or  gateway. The first wireless ADHOC networks were th e “packet radio” networks (PRNETs),  developed by DARPA in 1970. This network overcome t he problem of fixed centralized  infrastructure in the environment where single cent ralized node and fixed nodes via wired links,  does not work accurately. This ADHOC network is ve ry useful in Emergency conditions, ease  of deployment, speed of deployment and decreased de pendence on infrastructure.    There are three basic types of wireless ADHOC netw ork: MANET, Wireless mesh network and  Wireless sensor network.MANET [1] is a combination of independent mobile nodes that are  connected with wireless links (radio waves) to perf orm peertopeer communication. MANET  may operate in a standalone fashion, or may be conn ected to the other larger network like  Internet. Applications of MANETs include military u se in  battle  fields,  where a  centralized   command  center  is  not only  infeasible  but also  undesirable; and disaster management  scenarios, where on the run, communication between various rescue teams is required in the  absence of any existing communication infrastructur e. There are three major protocols used for  MANET are: Proactive (table driven), Reactive (ond emand) and Hybrid (both proactive and  reactive) which are discussed below.         International Journal of Computer Networks & Commun ications (IJCNC) Vol.6, No.2, March 2014  80  1.1  Proactive (table driven)     This type of protocols maintains fresh lists of des tinations and their routes by periodically  distributing routing tables throughout the network.  The main disadvantages of such algorithms  include: Respective amount of data for maintenance,  slow reaction on restructuring and failures.  Examples of proactive are DSDV (destination sequenc ed distance vector) and OLSR (Optimized  Link State Routing).    1.2  Reactive (ondemand)     This type of protocols finds a route on demand by f looding the network with Route Request  packets. Determine route if and when needed Source initiates route discovery. Examples are DSR  (dynamic source routing) and AODV (adhoc on demand  distance vector).    1.3  Hybrid    This category is called as Adaptive; Combination of  proactive and reactive. Example ZRP (zone  routing protocol)    AODV [2] is efficient for both unicast and multicas t routing, it builds routes between nodes only  when desired (ondemand) by source nodes, routes ar e maintain as long as these are needed by  source.  AODV has four types of messages: RREQ (rou te request), RREP (route reply), RERR  (route error) and hello message.     These messages are used in establishing the route b etween source and destination. If node wants  to send data packet to some destination, it first c hecks the route to that destination from source, if   there is no route is present between source and des tination. Then, first by route discovery method  route is established between source and destination  for data delivery. Source node broadcast  RREQ message to its neighbors, node which receive R REQ may send RREP to source if it is  destination node or it has route to destination wit h corresponding sequence number greater than or  equal to that contained in the RREQ. Otherwise, it rebroadcasts the RREQ. Nodes keep track of  the RREQ's source IP address and broadcast ID. If t hey receive a RREQ which they have already  processed, they discard the RREQ and do not forward  it. When source node receive RREP  message from destination node route is established between source and destination, then HELLO  message generate by source to destination through n ewly discovered route to check before the  data transmission, then source send data through th is route to destination. If due to any reason  topology change or node die, then link failure occu rs and RERR message send to source.  After  receiving the RERR, if the source node still desire s the route, it can reinitiate route discovery.  The rest of this paper is organized as follows. Rel ated work and problem definition is presented in  Section II. The solution and design is covered in S ection III, followed by implementation results  and performance evaluation in Section IV. This pape r is concluded in Section V while the  references are given towards the end of this paper.     2.  RELATED WORK   "
384,On Routing Optimization in Networks with Embedded Computational Services.txt,"Modern communication networks are increasingly equipped with in-network
computational capabilities and services. Routing in such networks is
significantly more complicated than the traditional routing. A legitimate route
for a flow not only needs to have enough communication and computation
resources, but also has to conform to various application-specific routing
constraints. This paper presents a comprehensive study on routing optimization
problems in networks with embedded computational services. We develop a set of
routing optimization models and derive low-complexity heuristic routing
algorithms for diverse computation scenarios. For dynamic demands, we also
develop an online routing algorithm with performance guarantees. Through
evaluations over emerging applications on real topologies, we demonstrate that
our models can be flexibly customized to meet the diverse routing requirements
of different computation applications. Our proposed heuristic algorithms
significantly outperform baseline algorithms and can achieve close-to-optimal
performance in various scenarios.","Modern communication networks are increasingly equipped with innetwork computational capabilities and services. SoftwareDefined Networking (SDN) [1] [2] technology can decouple data plane and control plane, and the routing decision can be made in a centralized fashion rather than hopbyhop, utilizing more information for better routing decision. Traffic flows traversing such networks are processed by different types of middleboxes inflight. For example, in a 5G [3] core network, traffic from/to mobile user devices must pass through special network elements, including eNodeB, serving gateways, and packet data network gateways. To improve security and/or boost application performance, an applica tion flow may also traverse other types of middleboxes for applicationspecific processing, e.g., intrusion detection and prevention, content caching to reduce latency and network traffic, rendering of VR/AR objects to offload user devices, object detection from video/lidar camera data acquired by autonomous vehicles, etc. In a cloudnative network, to im prove performance and resilience, middleboxes are replicated throughout the network, and can be elastically provisioned on commodity servers through Network Function Virtualization (NFV) [4] [5]. Routing is a critical component of networking. The main goal of the traditional network routing is to forward user traffic to their destinations with the lowest possible delay, while maintaining the networkwide load balance and resilience. Routing in networks with embedded computational services is significantly more complicated. It has to find a path for each flow that simultaneously has sufficient bandwidth andcomputation resources to meet the flow’s traffic and computa tion demands. Load balance and resilience have to be main tained on both communication links and computing nodes. To further complicate matters, applicationspecific computational services will introduce diverse additional routing requirements. Some application flows have to traverse multiple types of middleboxes in certain preset orders, and the routing path may have to contain cycles. The traffic volume of a flow might increase or decrease after processing, consequently, the flow conservation law no longer holds. Some applications require the computation to be done on a single computation node, while some applications can split their computation load to multiple paths and multiple nodes to achieve the parallelization gain. How traffic and computation are split directly impacts the load balance and resilience of the whole network. The existing routing models cannot directly address these new challenges and requirements. The goal of our study is to comprehensively explore the design space of routing in networks with embedded computational services. We develop a set of routing opti mization models and derive lowcomplexity heuristic routing algorithms for diverse computation scenarios. Towards this goal, we made the following contributions. 1) For routing with nonsplittable flows, we show that the problem is NPHard, and develop a loopfriendly mixed integer program (MIP) model to characterize the interplay between traffic routing, computation load distribution, and network delay performance. We further design a MetricTSP type of heuristic algorithm to achieve closetooptimal performance. 2) When flows can be arbitrarily split, we prove the equiv alence between the routing with computational services problem and the regular routing problem using the segment routing idea. We develop a Linear Program (LP) routing optimization model by extending the classic MultiCommodityFlow (MCF) model to work with heterogeneous middleboxes and traffic scaling resulting from the processing. The LP model can be further extended to study the joint optimization of traffic routing and computation resource provisioning. 3) For comeandgo dynamic traffic demands, we convert the online routing problem into a flow packing prob lem, and develop a primaldual type of online routing algorithm with performance guarantees. 4) We evaluate the developed models and algorithms us ing emerging computation applications over real net work topologies. Through extensive experiments, we demonstrate that our models can be flexibly customized to meet the diverse routing requirements of differentarXiv:2210.03338v2  [cs.NI]  6 Jun 20232 computation applications. Our algorithms significantly outperform baseline routing algorithms, and can achieve closetooptimal performance in various scenarios. II. R ELATED WORK "
97,Analysis Of Possible Attack On AODV Protocol In MANET.txt,"Mobile Ad Hoc Networks (MANETs) consist of wireless mobile nodes which
coordinate with each other to form temporary network without its pre-existing
infrastructure. AODV is popular Ad-hoc distance vector routing reactive
protocol which is used to find correct & shortest route to destination. Due to
openness, dynamic, infrastructure-less nature, MANET are vulnerable to various
attacks. One of these possible attacks is a Black Hole Attack in which a mobile
node falsely replies to the source node that it is having a shortest path to
the destination without checking its routing table. Therefore source node send
all of its data to the black hole node and it deprives all the traffic of the
source node. In this paper, We are proposing a technique to detect and prevent
the multiple black hole nodes from MANET so that source to destination
communication can be made easily. We also analysed the performance of the
network in terms of number of packets sent, received, throughput, energy of
network before attack and after detection & prevention of Attack. From these
analysis, we can conclude that performance decreased due to attack can be
improved after detection & prevention black hole attack in MANET.","Mobile Ad Hoc Network s (MANETs)  is a self configuring  network of wireless mobile nodes that formed network  capabl e of dynamic changing topology. Each node in the  network acts as a router, forwarding data packets to other  nodes [1]. MANET have many potential applications such a s  military services in battlefield, disaster relief operations and in  commercial environments .  Routing in MANET is complex due to its mobility of nodes  and dynamic changing topology as compared to traditional  wired networks. Limited bandwidth and battery m akes routing  in MANET more challenging. Due to these fundamental  characteristics of MANET, it is susceptible to various kinds of  attacks like eaves dropping with malicious intent, spoofing of  control or data packets, malicious modification of the packet  contents and Denial of service attack like worm hole, sink  hole, black and gray hole attacks [7].  These are all network  layer attacks. So routing security is one of the important issue  for which researchers want to contribute. Routing protocol  plays vital ro le in security of the network. AODV is routing  protocol designed and used for MANET to establish route on    demand. It does not need to maintain routes which are not  active.  In this paper, We attempt to provides a solution to detect  the multiple black hole nodes present and prevent them from  the network. In particular , we are focusing on AODV  protocol in MANET .This solution are not only provide  protection mechanism against black hole attack but also  consequently improve the performance of the network   compa ring with the existing approaches  after detection and  prevention of attack. The analysis shows that how severe the  attack is and its effects on MANET.    II. BLACK HOLE ATTACK IN  AODV PROTOCOL   Adhoc On Demand Distance Vector (AODV) Routing  Protocol is used for  finding a path to the destination in a n ad  hoc network. To find the path to the destination all mobile  nodes have to work in cooperation using the routing control  messages. There are three types of routing control messages in  AODV protocol Rout e Requests  (RREQs) , route Reply  (RREP),  Route Error ( RERR) used to find a path to the  destination [1]. The AODV routing protocol uses a destination  sequence number for each route entry.  The destination  sequence number is generated by the destination when a  connection  is requested to it. The principle of this protocol is  greater the destination sequence number, fresher is the route  [1]. Small hop count is selected at the stage when most of the  nodes have same retransmission time. When the source node S  want to communic ate with destination D as shown in the  figure1,it broadcasts RREQs messages to the neighbour  nodes.  These neighbours  check their routing table whether there is a  path to the destination or not.  If it is not then they also forward  RREQs of the source node u ntil message is received by the  intermediate node having path to destination or destination  node itself. If the node having a path to destination receives  RREQ, it send route reply message to the source node. In this  way, source node select the shortest pa th to the destination  node with the greater sequence number of route reply message.  If any link  break occurs then RERR message send to source  node.                                                                                            In Black Hole Attac k in MANET, here we assume malicious  node M As Source  S broadcasts its RREQs to connect with  destination D, all intermediate node check their routing table  whether there is a path to the destination D.  Here Node M as  malicious does not check its routing ta ble and send false route  reply packet to the source S with greater forged sequence  number [3] than expected that it is having a path to destination  D. As malicious node M does not check its route table, this International Journal of Engineering Trends and Technology  (IJETT) – Volume  11 Number 6 – May 2014  ISSN:  2231 5381                     http://www.ijettjournal.org   Page 307    reply reach the source no de faster than the norm al nodes [6]  source node select this path and send all of its data to the node  M. The node M receive this data packets and deprive from the  destination node.As this packets never reach to the destination  node D the attack is called as a black hole attack [ 2].                  \                  Fig1. Black Hole Attack                                                 RREQ            RREP     III. RELATED WORKS   "
131,Expeditious Saliency-guided Mix-up through Random Gradient Thresholding.txt,"Mix-up training approaches have proven to be effective in improving the
generalization ability of Deep Neural Networks. Over the years, the research
community expands mix-up methods into two directions, with extensive efforts to
improve saliency-guided procedures but minimal focus on the arbitrary path,
leaving the randomization domain unexplored. In this paper, inspired by the
superior qualities of each direction over one another, we introduce a novel
method that lies at the junction of the two routes. By combining the best
elements of randomness and saliency utilization, our method balances speed,
simplicity, and accuracy. We name our method R-Mix following the concept of
""Random Mix-up"". We demonstrate its effectiveness in generalization, weakly
supervised object localization, calibration, and robustness to adversarial
attacks. Finally, in order to address the question of whether there exists a
better decision protocol, we train a Reinforcement Learning agent that decides
the mix-up policies based on the classifier's performance, reducing dependency
on human-designed objectives and hyperparameter tuning. Extensive experiments
further show that the agent is capable of performing at the cutting-edge level,
laying the foundation for a fully automatic mix-up. Our code is released at
[https://github.com/minhlong94/Random-Mixup].","Mixup, a data augmentation strategy to increase a deep neu ral network (DNN)’s predictive performance, has drawn a lot of attention in recent years, along with the numerous initia tives made to pushing various deep learning models to move up the stateoftheart leaderboard on multiple benchmarks and different applications. The pioneering idea, Input Mix up, introduced by (Zhang et al. 2018), simply interpolates two samples in a linear manner and has been proven to play a signiﬁcant role in improving a model’s predictive perfor mance with hardly any additional computing cost. Recently, theoretical explanations for how Input Mixup enhances ro bustness and generalization have been studied (Zhang et al. 2021b). Building upon the empirical success of these mixup methods, the community has explored multiple directions to further improve the mixup idea. Manifold Mixup (Verma et al. 2019) extends the original mixup by mixing at a ran dom layer in the model. AugMix (Hendrycks et al. 2020) Figure 1: Illustration of our proposed method RMix. Arbi trary Mixup linearly interpolates images or employs a cut andpaste strategy. Saliencyguided Mixup preserves the rich supervisory signals of the images. Our method RMix works by combining the ﬁnest aspects of both approaches and demonstrates its effectiveness on a variety of tasks. ﬁrst augments the images by different combinations of aug mentation techniques, then ﬁnally mixes them together to increase the robustness of DNNs. CutMix (Yun et al. 2019) uses a spatial copyandpastebased strategy on other sam ples to create the new mixedup sample and has also been used widely in various applications. Among the rich family of mixup extensions, a popular branch in it is mixup methods that leverage the informa tion of saliency maps , because intuitively, one way to im prove the efﬁciency of mixup would be to replace its ran dom procedure with a directed procedure guided by some additional knowledge, and a saliency map appears to be a natural choice for such knowledge. Probably driven by the same intuition, the community has investigated the saliencybased mixup idea deeply in re cent years, such as SaliencyMix (Uddin et al. 2021), PuzarXiv:2212.04875v2  [cs.CV]  17 Dec 2022zleMix (Kim, Choo, and Song 2020), and CoMixup (Kim et al. 2021). SaliencyMix generates the saliency map, and then employs the cutandpaste strategy of CutMix. Puz zleMix further introduces secondary optimization objectives that ﬁrst optimize the saliency map, then optimize the trans port plan in order to preserve the rich supervisory signals of the image. CoMixup extends PuzzleMix’s idea by fur ther introducing objectives to ﬁnd the most suitable image to mix in the whole batch. We observe that each ”direction” of image combining has its own advantages and disadvantages. Arbitrary Mixup techniques, such as Input Mixup and CutMix, offer fast training speed and simplicity while maintaining competi tive performance. Contrarily, Saliencyguided Mixup , like PuzzleMix and CoMixup, compromises speed and simplic ity in favor of accuracy, expected calibration error, and ro bustness to adversarial attack. Over time, signiﬁcant efforts have been proposed to further improve the saliencyguided direction with minimal focus on the other (Uddin et al. 2021; Kim, Choo, and Song 2020; Kim et al. 2021; Venkatara manan et al. 2022), resulting in an unexplored randomness domain. We raise the question: is it feasible to have a method that is expeditious, simple, and effective at the same time? In this paper, we identify a straightforward learning heuristic that sits in the middle of two paths. Our throughout the examination of saliencyguided methodologies suggests that they typically fall under a threestep optimization: First, calculate the saliency of the image. Then, mix the images in accordance with a secondary optimization objective. Fi nally, train the DNN with mixed images and labels. Roughly speaking, all three levels require the same amount of training time, making the training takes at least three times longer. We notice that, by swapping out the second step with a randomnessdriven mixing approach, we are able to design a strategy that gives a competitive performance with state oftheart methods while maintaining the speed and ease of implementation of an arbitrary mixup. We name our method RMix and empirically validate its performance on four different tasks : image classiﬁcation, weakly supervised object localization, expected calibration error, and robustness to adversarial attack. On all bench marks, RMix shows an improvement or onpar performance with stateoftheart methods. In summary, our contributions in this paper are as follows: • We begin by demonstrating that our implementation of arbitrary mixup is capable of outperforming saliency guided mixup, indicating that existing attempts have not yet fully investigated the effectiveness of randomization. (Section: Background and Motivation). • Motivated by the superiority of each mixup direction over one another, we propose a novel method RMix that combines the two mixup routes and eliminates a third of the computational complexity (Section: RMix). With regard to four benchmarks on different model ar chitectures: image classiﬁcation, weakly supervised ob ject localization, robustness to adversarial attack, and ex pected calibration error (Section: Experiments), we high light that RMix performs better or equally well as stateoftheart approaches. • Finally, to answer the question of whether coupled ran domness and saliency are sufﬁcient to the gain of R Mix or whether there exists a superior decision proto col, we present several experiments in the case of Rein forcement Learning controlled mixup scenario. Our Re inforcement Learning agent adapts and chooses the mix up rules based on the performance of the classiﬁers, aim ing to reduce reliance on humandesigned objectives and hyperparameter tuning of mixup in general. We validate its effectiveness on CIFAR100 image classiﬁcation task and ﬁnd that it performs competitively with other base lines. (Section: Ablation Studies). 2 Background and Motivation In this Section, we provide background knowledge about mixup training, and empirical results serving as motivation for our method. 2.1 Mixup Background LetC;W;H;N denote the number of channels, image width, image height, and number of classes, respectively. We assume that W=Hfor simplicity, and will use only W from now on. Let x2X;x2RCWWbe the input im age andy2Y;y2f0;1gNbe the output label. Let f(;c) denote a classiﬁer speciﬁed by parameter c. LetDbe the distribution overXY . In mixup based data augmentation, the goal is to optimize the model’s loss `:XY !R given the mixup function for the inputs h(), for the labels g(), and the mixing distribution, usually Beta (;)with the scalar parameter , as follows: minimize E (x0;y0);(x1;y1)2DE Beta`(h(x0;x1);g(y0;y1);c)) (1) Mixup typically requires two tuples of imageslabels. In put Mixup (Zhang et al. 2018) deﬁnes h(x0;x1) =x0+ (1"
402,GOSPF: An energy efficient implementation of the OSPF routing protocol.txt,"Energy saving is currently one of the most challenging issues for the
Internet research community. Indeed, the exponential growth of applications and
services induces a remarkable increase in power consumption and hence calls for
novel solutions which are capable to preserve energy of the infrastructures, at
the same time maintaining the required Quality of Service guarantees. In this
paper we introduce a new mechanism for saving energy through intelligent switch
off of network links. The mechanism has been implemented as an extension to the
Open Shortest Path First routing protocol. We first show through simulations
that our solution is capable to dramatically reduce energy consumption when
compared to the standard OSPF implementation. We then illustrate a real-world
implementation of the proposed protocol within the Quagga routing software
suite.","In this paper we present an extension of the OSPF protocol specically conceived to optimize the overall energy consumption of the network. The al gorithm we devised represents our engineering approach to the solution of the well known (though still open) issue of dynamic network topology adaptation to improve energy eciency. The paper starts with a thorough analysis of the cur rent achievements in the socalled green networking eld, with special regard to those approaches which have focused on the exploitation of smart energy aware routing strategies. We then highlight the major contributions of our proposal, which is based on an analytical model that takes also into account the dynamics of the trac load the network is subject to and proposes a solution based on a Corresponding author Email address: spromano@unina.it (S.P. Romano) Preprint submitted to Journal of Network and Computer Applications July 4, 2022arXiv:2207.00035v1  [cs.NI]  30 Jun 2022fully distributed paradigm. In order to assess the performance achieved by this solution, we discuss the results of an experimental campaign based on simula tions and built around an extremely realistic scenario associated with realworld trac proles and network topology, as inspired by the GARR Italian research network infrastructure. The rest of the paper is structured as follows. In section 2 we present related works dealing with energy ecient networking, with a focus on reengineering and dynamic adaptation approaches. In section 3 we provide a formal context for the denition of the problem at hand, namely the dynamic (and timeaware) adaptation of the network topology driven by energy eciency considerations. Given the above mentioned theoretical frame, in section 4 we present our pro posal for Green OSPF (GOSPF), an energy ecient extension of the wellknown Open Shortest Path First (OSPF) routing protocol, whose performance is thor oughly assessed in section 5. In section 6 we move from theory to practice, by presenting a realworld implementation of the GOSPF protocol within the Quagga routing protocol suite. Finally, section 8 summarizes the main results of our current eorts and indicates the most interesting directions of our future work. 2. Related Work "
1,SoS-RPL: Securing Internet of Things Against Sinkhole Attack Using RPL Protocol-Based Node Rating and Ranking Mechanism.txt,"Through the Internet of Things (IoT) the internet scope is established by the
integration of physical things to classify themselves into mutual things. A
physical thing can be created by this inventive perception to signify itself in
the digital world. Regarding the physical things that are related to the
internet, it is worth noting that considering numerous theories and upcoming
predictions, they mostly require protected structures, moreover, they are at
risk of several attacks. IoTs are endowed with particular routing disobedience
called sinkhole attack owing to their distributed features. In these attacks, a
malicious node broadcasts illusive information regarding the routings to impose
itself as a route towards specific nodes for the neighboring nodes and thus,
attract data traffic. RPL (IP-V6 routing protocol for efficient and low-energy
networks) is a standard routing protocol which is mainly employed in sensor
networks and IoT. This protocol is called SoS-RPL consisting of two key
sections of the sinkhole detection. In the first section rating and ranking the
nodes in the RPL is carried out based on distance measurements. The second
section is in charge of discovering the misbehavior sources within the IoT
network through, the Average Packet Transmission RREQ (APT-RREQ). Here, the
technique is assessed through wide simulations performed within the NS-3
environment. Based on the results of the simulation, it is indicated that the
IoT network behavior metrics are enhanced based on the detection rate,
false-negative rate, false-positive rate, packet delivery rate, maximum
throughput, and packet loss rate.","There is a rising effort for connecting large physical objects in short distances on the internet  utilizing the IPV6 protocols to create the internet of things. Standardizing the routing protocols of  lossy and low power networks (RPL) has recently made an IoT routing protocol. RPL was originally  intended to be used in lossy and low power (LLN)  networks. Within RPL, a Destination Oriented  Directed Acyclic Graph (DODAG) is created among the nodes in 6LoWPAN which supports one  way traffic to the destination, two way traffic between devices, and two way traffic between the  devices and the destinati on. Also, IPV6 is called on over Low Power Wireless Personal Area  Networks 6LoWPAN, which is a wireless sensor network using the compressed IPV6 protocol for  networking and IEEE 802.15.4 as the physical layer and data link protocol. Dissimilar to normal  independent WSN networks, the devices confined in IoT are available everywhere. Therefore, they  encounter attacks from both the internet and inside the network [1 2].       A physical object is able to potentially connect to the IoT utilizing IPV6. For IoT, m ultiple  applications exist. The scope of the applications includes home security management and home  automation, environmental monitoring, smart energy management, and monitoring, industrial  automation, transportation tracking, security and military, smart  cities, and medical supervision. In  the real world, implementation of IoT requires secure connections as a significant challenge due to  the heterogeneousness of IoT tools: some resources are limited while others can connect to powerful  IP hosts. Also, the  connections between devices in the IoT essentially need to be secure end to end  (E2E) connections. This means to emphasize the integrity and confidentiality of the messages from  the source to the destination. Because there are several attacks, like the si nkhole attack, providing  IoT security is very important.        In this paper, the main objective is to design a defense mechanism against sinkhole attacks  between IoT devices which operates using node rating and ranking. In this scenario, we tried to  realis tically provide IoT tools arranged in an enterprise scenery affected by real world sinkhole, and  executing genuine attacks. For replicating a characteristic structural data flow, we gathered the  traffic data from IoT tools connected through Wi Fi to variou s access points, the wire connected to a  central switch and connected to a router as well. To sniff the network traffic, we carried out port  mirroring on the switch to record the data utilizing Wireshark. We evaluated our discovery technique  as realistical ly as possible and deployed all elements of two botnets (Fig. 1) in our isolated lab to use  them for infecting 9 commercial IoT tools.     Fig. 1 Lab setup for detecting IoT sinkhole  attacks .      The rest of this study is adjusted as: Section 2 explains related work . Section 3 explains security  attacks of IoT network . In Section 4, we explain the proposed method the SoS RPL schema. Section 5  includes evaluations of simulation experiment results. Ul timately, we provide the conclusion  in  Section 6.      2 Related works   "
383,Quality of Service Provisioning in Manet Using a Cross-Layer Approach for Routing.txt,"Deployment of multimedia applications warrants provisioning of Quality of
Service (QoS) in MANET. However, limited battery power, other resource
constraints and mobility of nodes make QoS provisioning difficult to achieve in
MANET. This difficulty can be overcome by using a cross-layer approach for
routing. In [1] Patil et al., proposed a cross-layer routing protocol named
Cost Based Power Aware Cross Layer - AODV (CPACL-AODV) which overcomes the
limitation of battery power of nodes. Though many similar energy efficient and
cross-layer routing protocols have been proposed for MANET, none of them
handles QoS. A novel MANET routing protocol, Type of Service, Power and
Bandwidth Aware AODV (TSPBA-AODV), which overcomes resource constraints and
simultaneously provides QoS guarantees using a cross-layer approach, is
proposed in this paper. In addition the effect of variation in nodes' mobility
on performance of TSPBA-AODV is compared with that of CPACL-AODV [1] for two
different types of network traffic. As shown by the results of simulations
performed, TSPBA-AODV performs better than CPACL-AODV for MANET in which nodes
move with small speeds (speeds up to 40 Km/hr approx.). In addition the effect
of variation in data sending rate of nodes on performance of the protocols is
also studied. As shown by the results of simulations performed, TSPBA-AODV
performs better than CPACL-AODV for all variations in data sending rate of
nodes.","Highly dynamic nature and varied usefulness of MANE T have provoked great interest in  research community for its study. MANET has a uniqu e capability of forming an infrastructure less network on the fly without need of any central  administration. Earlier the use of MANET  was limited to emergency situations such as natural  disasters, military conflicts, emergency  medical facilities, etc. However, proliferation of multimedia applications over internet has also  affected MANET and warranted provisioning of QoS in  it. This requirement can be met by  designing a crosslayer routing protocol in such a way that QoS can be provisioned. Earlier the  cost function used for making routing decisions in MANET was hop count. However since,  MANET works under various constraints, such as limi ted battery power and frequently  changing topology, the routing protocol can be effe ctive only if it is designed by taking care of  crosslayer parameters such as battery lifetime, ap plication type, bandwidth, etc. Several cross layer aware routing cost functions have been propos ed by researchers for routing in MANET.  Such cost functions can be divided into three types :   (1) Type 1  Monotonically increasing function : A cost function which increases monotonously  with time for a node. For example fraction of initi al battery power utilized, etc.   (2) Type 2 – Fluctuating function : A cost function which doesn’t show monotonic vari ation, but  rather shows fluctuations by either increasing or d ecreasing. For example bandwidth utilization,  fraction of message queue occupied, etc.  International Journal of Computer Networks & Commun ications (IJCNC) Vol.3, No.3, May 2011   82       (3) Type 3 – Hybrid function : A cost function which is combination of Type 1 an d Type 2 cost  functions.  If nodes are taken to be identical and overall cost  function of path is calculated as sum of cost  function of nodes along a path (taking average is n ot much justified as a very long path can have  better average), then irrespective of cost function  chosen hop count will implicitly decide routes  in the beginning because cost function for individu al nodes will be almost in same range  initially. However in case of cost function of the Type 1, due to monotonous increase in cost  function with time, at a later stage routing will n o more be dependent on hop count, but this  can't assure quality of service. For example  a pa th with better sum of battery utilization can be  longer and congested compared to a path with sustai nable battery power but having lesser  congestion or length and so lesser delay. On the ot her hand if cost function is taken to be of the  second type then we are actually ignoring the resou rce constraints of MANET such as limited  power supply.  In this paper we propose a novel protocol named Typ e of Service, Power and Bandwidth Aware  AODV (TSPBAAODV) that uses a Type 3 cost function.  The scenario we are assuming is that  we have a large No. of mobile nodes in a small area , so that hop count is not a matter of concern  but rather QoS provisioning in dynamic environment is the matter of concern. Earlier most of  the protocols used either Type 1 or Type 2 cost fun ction. Recently a protocol named CPACL AODV [1] was proposed by Patil et al., which uses c ost function of Type 1, based on battery  utilization. We compared performance of our protoco l (TSPBAAODV) with CPACLAODV  (implemented with assumption that energy loss due t o transmission or receipt is directly  proportional to size of the packet dealt with).  Rest of the paper is organized as follows. Section 2 gives a brief overview of related works.  Section 3 describes TSPBAAODV. Section 4 discusses  about the simulation environment used,  performance metrics evaluated and the results obtai ned. Finally, section 5 concludes our paper.  2.  RELATED WORKS   "
401,An Efficient Cluster-based Routing Protocol in Cognitive Radio Net-work.txt,"Cognitive Radio Networks (CRNs) are being studied intensively and gaining
importance as spectrum is the heavily underutilized. CRN has the capability to
exploit smartly the unutilized frequency spectrum. Recently, the research
community started to work in the area of cognitive radio routing. In a flat
topology, all nodes are of the same level and functionality, thus making it
simple and efficient for smaller networks. However, when the network is large
with sparse nodes, the routing information becomes more complex making
cluster-based techniques really relevant to tackle such situations. In a
cluster-based routing, all nodes in the network are dynamically organized into
partitions called groups or clusters. In each cluster, a cluster head is chosen
to help in the data transmission management and to maintain cluster membership
information. This paper proposes a novel routing protocol for cognitive radio
ad hoc networks (CRAHNs) based on clustering model which amends swiftly to the
topological changes and establishes the routing efficiently. Our proposed
approach is thoroughly evaluated through simulation study. The results state
the suitability of the proposed protocol for cognitive radio ad hoc networks
and demonstrate that it has better performance in terms of finding the
source-destination route, reducing the amount of messages that are transmitted
all over the network and minimizing the routing delay.","Cognitive Radio is an emerging and promising technology that aims to increase the  overall utilization of radio resources by enabling the dynamic allocatio n of some po r tions of the wireless spectrum. Unlicensed users, through cognitive radio devi ces, can  opportunistically operate over the current u nused parts of licensed bands called white  spaces, spectrum holes, or spectrum opportunity [1].   The network mai nly consists of two types of users: licensed and  unlicensed users. Licensed users are also known as primary users (PU) and unl icensed users are known  as secondary user (SU). SU‟s access spectrum conditionally which means when prim a ry users are inactive [2] .  Although more than ten years have passed, the research on cognitive radio ne tworks  has mainly focused on physical and medium access issues [3, 4], including the defin i tion of effective spectrum sensing, decision and sharing mechanisms. However, r e cently the research community has started working on cogn itive radio routing.   The routing protocols determine how messages can be forwarded, from a source  node to a destination node which is out of the range of the former, using other m obile  nodes of the network.  Routing, which includes for example maintenance and disco v ery of routes, is one of the very challenging areas in commun ication [5].   In this paper, we are interested  in the routing problem in a cognitive radio ad hoc  network by proposing a novel routing p rotocol based on clustering mech anism  which  can take advantages  of both  reactive and proactive  protocols . In a cluster based  routing, all nodes in the network are dynamically organized into partitions called  groups or clu sters. These clusters are then comb ined into larger partitions to help  maintain a relatively stable network topology. The nodes that have been elec ted as  cluster heads have the necessary intelligence to organize route forwarding and route  maintenance proc edure.   The rest of the paper is orga nized as follows. Se ction 2 describes the related works in  this area. Section 3 presents the proposed approach and the r esults of an extensive  performance evaluation are provided in Section 4. Finally, in Section 5 some concl u sions and future works are dra wn.  2. RELATED WORKS   "
435,Designing an Efficient Delay Sensitive Routing Metric for IEEE 802.16 Mesh Networks.txt,"Quality of Service provisioning is one of the major design goals of IEEE
802.16 mesh networks. In order to provide quality delivery of delay sensitive
services such as voice, video etc., it is required to route such traffic over a
minimum delay path. In this paper we propose a routing metric for delay
sensitive services in IEEE 802.16 mesh networks. We design a new cross layer
routing metric, namely Expected Scheduler Delay (ESD), based on HoldOff
exponent and the current load at each node of the network. This proposed metric
takes into account the expected theoretical end-to-end delay of routing paths
as well as network congestion to find the best suited path. We propose an
efficient distributed scheme to calculate ESD and route the packets using
source routing mechanism based on ESD. The simulation results demonstrate that
our metric achieves reduced delay compared to a standard scheme used in IEEE
802.16 mesh, that takes hop count to find the path.","The IEEE 802.16 standard, known as “ Air Interface for  Fixed Broadband Wireless Access System s” [1] is the next  generation Wireless Metropolitan  Area Network (WMAN)   that targets at providing last mile wireless broadband access.  The IEEE 802.1 6 technology can operate in two modes  Point to Multi point (PMP) and Mesh mode . While the  standard currently defines five classes of services for PMP  mode, but there is no QoS provisioning mechanism  mentioned in mesh mode. Most of the QoS requirements  take delay as an important parameter for providing quality  delivery of traffic. The traditional 802.16 mesh network uses  standard Dijkstra's or Bellman Ford's shortest path algorithm  which is not suitable for delay sensitive services.   There are many routing m etrics available  in the context  of IEEE 802.11 multi hop ad hoc netw orks, such as ETX,  ETT and ML. These metrics are computed using the  handshaking property (DATA ACK) of IEEE 802.11 DCF  based MAC. The scheduling mechanism in IEEE 802.16  uses an election b ased scheme for contention resolution,  which is different from 802.11 DCF based contention resolution technique. So the ACK based delay or loss  computation is not applicable to  802.16 mesh network.  Furthermore, the deterministic election based scheduling i n  IEEE 802.16 cooperative mesh mode introduces extra  scheduler d elay at each node, in terms of HoldO ff time and  contention time. So cross layer properties such as MAC layer  delay and routing delay over multiple hops play an important  role in routing decisi on. Most of the current works in IEEE  802.16 consider interference based optimization to find the  proper routing decision, but they do not use cross layer  inputs to find the path between the source and the  destination.   In this paper we propose a cross layer routing metric to  provide quality delivery of delay sensitive services. Our  scheme is based on an important parameter used in the MAC  layer scheduling of IEEE 802.16 Mesh Distributed  Coordinated Scheduler, called the Hold Off Exponent . In [2],  Cao et al.  proposed a mathematical model for performance  evaluation of IEEE 802.16 mesh distributed coordinated  scheduler. From the mathematical model proposed by them,  we see that a suitably chosen HoldO ff exponent can improve  the scheduler performance dramatically by minimizing the  number of waiting slots between two transmissions. We use  this mathematical expectation to find out the minimum delay  path between a source and a destination. We also consider  the congestion at a netwo rk node while designing the metric.  Hence this delay aware cross layer routing metric is quite  suitable for next generation wireless mesh networks.  Simulation results show that our proposed metric works  better than standard routing algorithm that takes hop  count as  a routing metric.   II. RELATED WORKS   "
110,Communication-Safe Web Programming in TypeScript with Routed Multiparty Session Types.txt,"Modern web programming involves coordinating interactions between browser
clients and a server. Typically, the interactions in web-based distributed
systems are informally described, making it hard to ensure correctness,
especially communication safety, i.e. all endpoints progress without type
errors or deadlocks, conforming to a specified protocol.
  We present STScript, a toolchain that generates TypeScript APIs for
communication-safe web development over WebSockets, and RouST, a new session
type theory that supports multiparty communications with routing mechanisms.
STScript provides developers with TypeScript APIs generated from a
communication protocol specification based on RouST. The generated APIs build
upon TypeScript concurrency practices, complement the event-driven style of
programming in full-stack web development, and are compatible with the Node.js
runtime for server-side endpoints and the React.js framework for browser-side
endpoints.
  RouST can express multiparty interactions routed via an intermediate
participant. It supports peer-to-peer communication between browser-side
endpoints by routing communication via the server in a way that avoids
excessive serialisation. RouST guarantees communication safety for endpoint web
applications written using STScript APIs.
  We evaluate the expressiveness of STScript for modern web programming using
several production-ready case studies deployed as web applications.","Web technology advancements have changed the way peo ple use computers. Many services that required standalone applications, such as email, chat, video conferences, or even games, are now provided in a browser. While the Hypertext Transfer Protocol (HTTP) is widely used for serving web pages, its RequestResponse model limits the communication patterns — the server may not send data to a client without the client first making a request. The WebSocket Protocol [12] addresses this limitation by providing a bidirectional channel between the client and the server, akin to a Unix socket. Managing the correct usage of WebSockets introduces an additional concern in the de velopment process, due to a lack of WebSocket testing tools, requiring an (often adhoc) specification of the communica tion protocol between server and clients. A B S Suggest Query Available Quote OK Confirm No Reject Full Fullalt alt Restart Figure 1. Travel Agency Protocol as a Sequence Diagram Consider the scenario in Fig. 1, where an online travel agency operates a “travelling with a friend” scheme (ignoring 1arXiv:2101.04622v1  [cs.PL]  12 Jan 2021CC ’21, March 2–3, 2021, Virtual, USA Anson Miu, Francisco Ferreira, Nobuko Yoshida, and Fangyi Zhou the blue dashed arrows). It starts when a traveller ( B) sug gests a trip destination to their friend ( A), who then queries the travel agency ( S) if the trip is available. If so, the friends discuss among themselves whether to accept or reject the quoted price. If the trip was unavailable, the friends start again with a new destination. An implementation of the travel agency protocol may contain programming errors, risking communication safety . For example, the following implementation of the clientside endpoint for traveller Asending a quote to traveller B. 1<input type= 'number 'id='quote '/> 2<button id= 'submitQuote '>Send Quote to B</button> 3<script> 4document.getElementById( 'submitQuote ') 5 .addEventListener( 'click ', () => { 6 const quote = document.getElementById( 'quote ').value; 7 travellerB.send({ label: 'quote ', quote }); 8 travellerB.onMessage( /* go to different screen */ ); 9 /* ...snip... */ }); </script> There are subtle errors that violate the communication pro tocol, but these bugs are unfortunately left for the developer to manually identify and test against: Communication Mismatch Whilst the input field man dates a numerical value (Line 1) for the quote, the value from the input field is actually a string . IfBexpects a number and performs arithmetic operations on the received payload from A, the type mismatch may be left hidden due to implicit type coercion and cause unintended errors. Channel Usage Violation AsBmay take time to respond, Acan experience a delay between sending the quote and receiving a response. Notice that the button remains active after sending the quote — Acould click on the button again, and send additional quotes (thus reusing the communication channel), but Bmay be unable to deal with extra messages. Handling Session Cancellation An additional concern is how to handle browser disconnections, as both travellers can freely close their browsers at any stage of the protocol. Sup pose Stemporarily reserves a seat on A’s query. If Acloses their browser, the developer would need to make sure that A notifies Sprior to disconnecting, and Sneeds to implement recovery logic (e.g. releasing the reserved seat) accordingly. To prevent these errors and ensure deadlockfreedom, we propose to apply session types [14,15] into practical interac tive web programming. The scenario described in Fig. 1 can be precisely described with a global type using the typing discipline of multiparty session types (MPST) [ 15]. Welltyped implementations conform to the given global protocol , are guaranteed free from communication errors by construction . Whereas session type programming is wellstudied [ 1], its application on web programming, in particular, interactive web applications, remains relatively unexplored. Integrat ing session types with web programming has been piloted by recent work [ 13,20,24], yet none are able to seamlessly implement the previous application scenario: Fowler [13]uses binary (2party) session types; and King et al . [20] re quire each nonserver role to only communicate to the server, hence preventing interactions between nonserver roles (cf. talking to a friend in the scenario). The programming lan guages used in these works are, respectively, Links [ 8] and PureScript [ 28], both not usually considered mainstream in the context of modern web programming. The Jolie lan guage [ 24] focuses more on the server side, with limited support for an interactive front end of web applications. This paper presents a novel toolchain, Session TypeScript (STScript ), for implementing multiparty protocols safely in web programming. STScript integrates with modern tools and practices, utilising the popular programming language Type Script , front end framework React.js and back end runtime Node.js . Developers first specify a multiparty protocol and we generate correctbyconstruction APIs for developers to implement the protocol. The generated APIs use WebSocket to establish communication between participants, utilising its flexibility over the traditional HTTP model. When de velopers use our generated APIs to correctly implement the protocol endpoints, STScript guarantees the freedom from communication errors, including deadlocks, communication mismatches, channel usage violation or cancellation errors. Our toolchain is backed by a new session theory, a routed multiparty session types theory (RouST ), to endow servers with the capacity to route messages between web clients. The new theory addresses a practical limitation that WebSocket connections still require clients to connect to a prescribed server, constraining the ability for interclient communica tion. To overcome this, our API routes interclient messages through the server, improving the expressiveness over pre vious work and enabling developers to correctly implement multiparty protocols, as we show with blue dashed arrows in Fig. 1. In our travel agency scenario, the agency plays the server role: it will establish WebSocket channels with each participant, and be tasked with routing all the messages between the friends. We formalise this routing mechanism asRouST and prove deadlockfreedom of RouST and show a behaviourpreserving encoding from the original MPST to RouST . The formalism and results in RouST directly guide a deadlockfree protocol implementation in Node.js via the router, preserving communication structures of the original protocol written by a developer. Finally, we evaluate our toolchain ( STScript ) by case stud ies. We evaluate the expressiveness by implementing a num ber of web applications, such as interactive multiplayer games (Noughts and Crosses ,Battleship ) and web services ( Travel Agency ) that require routed communication. Contributions and Structure of the Paper. § 2 presents an overview of our toolchain STScript , which generates APIs for communicationsafe web applications in TypeScript from multiparty protocol descriptions. § 3 motivates how the gen erated code executes the multiparty protocol descriptions, 2CommunicationSafe Web Programming in TypeScript with Routed Multiparty Session Types CC ’21, March 2–3, 2021, Virtual, USA Figure 2. Overview of the toolchain STScript and present how STScript prevents common errors in the context of web applications. § 4 presents RouST , multiparty session types (MPST) extended with routing , and define a tracepreserving encoding of the original MPST into RouST . § 5 evaluates our toolchain STScript via a case study of Noughts and Crosses and performance experiments. § 6 gives related and future work. Appendix includes omitted code, definitions, performance benchmarks and detailed proofs. The artifact accompanying this paper [ 23] is available via DOI or at https://github.com/ STScript2020/cc21artifact , containing the source code of STScript , with implemented case studies and performance benchmarks. See Appendix A for details about the artifact. 2 Overview In this section, we give an overview of our code generation toolchain STScript (Fig. 2), demonstrate how to implement the travel agency scenario (Fig. 1) as a TypeScript web appli cation, and explain how STScript prevents those errors. Multiparty Session Type Design Workflow. Multiparty session types (MPST) [ 15] use a topdown design method ology (Fig. 3). Developers begin with specifying the global communication pattern of all participants in a global type or a global protocol . The protocol is described in the Scrib ble protocol description language [ 16,31,34]. We show the global protocol of the travel agency scenario (in § 1) in Fig. 4. The Scribble language provides a userfriendly way to de scribe the global protocol in terms of a sequence of message exchanges between roles. A message is identified by its label (e.g.Suggest ,Query , etc), and carries payloads (e.g. number , string , etc). The choice syntax (e.g. Line 4) describes pos sible branches of the protocol – in this case, the Server mayA Global Type 𝐺 Projection onto each Participant 𝑇A Local Type forA𝑇B Local Type forB𝑇S Local Type forS Figure 3. Topdown MPST Design Methodology 1global protocol TravelAgency(role A, role B, role S) 2{ Suggest(string) from B to A;//friend suggests place 3 Query(string) from A to S; 4 choice at S 5 { Available(number) from S to A; 6 Quote(number) from A to B;//check price with friend 7 choice at B 8 { OK(number) from B to A; 9 Confirm(credentials) from A to S; } 10 or { No() from B to A; 11 Reject() from A to S; } } 12 or { Full() from S to A; Full() from A to B; 13 do TravelAgency(A, B, S); } } Figure 4. Travel Agency Protocol in Scribble respond to the query either with Available , so the customer continues booking, or with Full , so the customer retries by restarting the protocol via the dosyntax (Line 13). In this scenario, we designate the roles AandBasclient roles, and role Sas a server role . Participating endpoints can obtain their local views of the communication proto col, known as local types , via projection from the specified global type (Fig. 3). The local type of an endpoint can be then used in the code generation process, to generate APIs that arecorrect by construction [17, 20, 35]. The code generation toolchain STScript (Fig. 2) follows the MPST design philosophy. In STScript , we take the global protocol as inputs, and generate endpoint code for a given role as outputs, depending on the nature of the role. We use the Scribble toolchain for initial processing, and use an endpoint finite state machine (EFSM) based code generation technique targeting the TypeScript Language. Targeting Web Programming. TheTypeScript [2] pro gramming language is used for web programming, with a static type system and a compiler to JavaScript. TypeScript programs follow a similar syntax to JavaScript, but may contain type annotations that are checked statically by the TypeScript typechecker. After typechecking, the compiler converts TypeScript programs into JavaScript programs, so they can be run in browsers and other hosts (e.g. Node.js ). To implement a wide variety of communication patterns, we use the WebSocket protocol [12], enabling bidirectional communication between the client and the server after con nection. This contrasts with the traditional requestresponse model of HTTP, where the client needs to send a request and the server may only send a response after receiving the 3CC ’21, March 2–3, 2021, Virtual, USA Anson Miu, Francisco Ferreira, Nobuko Yoshida, and Fangyi Zhou 1 2 34 5 67 89B?Suggest S!QueryS?FullB!Full S?Available B!Quote B?Ok B?NoS!Confirm S!Reject Figure 5. EFSM for TravelAgency roleA request. WebSockets require an endpoint to listen for connec tions and the other endpoint connecting. Moreover, clients, using the web application in a browser, may only start a connection to a WebSocket, and servers may only listen for new connections. The design of WebSocket limits the ability for two clients to communicate directly via a WebSocket (e.g. Line 2 in Fig. 4). STScript uses the server to route messages between client roles, enabling communication between all participants via a star network topology. An important aspect of web programming is the interac tivity of the user interface (UI). Viewed in a browser, the web application interacts with the user via UI events, e.g. mouse clicks on buttons. The handling of UI events may be imple mented to send messages to the client (e.g. when the “Submit” button on the form is clicked), which may lead to practical problems. For instance, would clicking “Submit” button twice create two bookings for the customer? We use the popular React.js UI framework for generating client endpoints, and generate APIs that prevent such errors from happening. CallbackStyle API for Clients and Servers. Our code generation toolchain STScript produces TypeScript APIs in acallback style [35] tostatically guarantee channel linearity. The input global protocol is analysed by the toolchain for wellformedness, and an endpoint finite state machine (EFSM) is produced for each endpoint. We show the EFSM for role A in Fig. 5. The states in the EFSM represent local types (sub ject to reductions) and transitions represent communication actions (Symbol !stands for sending actions, ?for receiving). In the callback API style, type signatures of callbacks are generated for transitions in the EFSM. Developers imple ment the callbacks to complete the program logic part of the application, whilst a generated runtime takes care of the communication aspects. For callbacks, sending actions cor respond to callbacks prompting the payload type as a return type, so that the returned value can be sent by the runtime. Dually, receiving actions correspond to callbacks taking the payload type as an argument , so that the runtime invokes the callback with the received value. Implementing the Server Role. In the travel agency pro tocol, as shown in Fig. 4, we designate role Sas the server role. The server role does not only interact with the two clients, but also routes messages for the two clients. The routing will be handled automatically by the runtime, sav ing the need for developers to specify manually. As a result, the developer only handles the program logic regarding the Figure 6. IDE AutoCompletion for Successor State server, in this use case, namely providing quotes for holiday bookings and handling booking confirmations. 1import { Session, S } from ""./TravelAgency/S""; 2const agencyProvider = (sessionID: string) => { 3 const handleQuery = Session.Initial({ 4 Query: async (Next, dest) => { 5 // Provide quotes for holiday bookings 6 const res = await checkAvailability(sessionID, dest); 7 if (res.status === ""available"") { 8 return Next.Available([res.quote], Next => ...); 9 } else { return Next.Full([], handleQuery); } }, }); 10 return handleQuery; }; All callbacks carry an extra parameter, Next , which acts as afactory function for constructing the successor state. This empowers IDEs to provide autocompletion for developers. For example, the factory function provided by the callback for handling a Query message (Line 4) prompts the permitted labels in the successor send state, as illustrated in Fig. 6. Implementing the Client Roles. To implement client roles, merely implementing the callbacks for the program logic is not sufficient — unlike servers, web applications have interactive user interfaces, additional to program logic. As mentioned previously, our code generation toolchain tar gets React.js for client roles. For background, the smallest building blocks in React.js arecomponents , which can carry properties (immutable upon construction) and states (muta ble). Components are rendered into HTML elements, and they are rerendered when the component state mutates. To bind the program logic with an interactive user in terface, we provide component factories that allow the UI component to be interposed with the current state of the EFSM. Developers can provide the UI event handler to the component factory, and obtain a component for rendering. The generate code structure enforces that the state transition strictly follows the EFSM, so programmer errors (such as the double “submit” problem) are prevented by design. 1render() { 2 const OK = this.OK( 'onClick ', () => [this.state.split]); 3 const NO = this.No( 'onClick ', () => []); 4 return (... 5 <NO><Button color= 'secondary '>No</Button></NO> 6 <OK><Button color= 'primary '>OK</Button></OK> ...); } 4CommunicationSafe Web Programming in TypeScript with Routed Multiparty Session Types CC ’21, March 2–3, 2021, Virtual, USA Using the send state component in the FSM for the end point Bas an example, Line 2 reads, “generate a React com ponent that sends the OKmessage with this.state.split as payload on a click event”. It is used on Line 6 as a wrapper for a stylised <Button> component. The runtime invokes the handler and performs the state transition, which prevents the double “submit” problem by design. Guaranteeing Communication Safety. Returning to the implementation in § 1, we outline how STScript prevents common errors to enable typesafe web programming. Communication Mismatch All generated callbacks are typed according to the permitted payload data type specified in the protocol, making it impossible for traveller Ato send the quote as a string by accident. Channel Usage Violation The generated clientside run time requires the developer to provide different UI compo nents for each EFSM state – once traveller Asubmits a quote, the runtime will transition to, thus render the component of, a different EFSM state. This guarantees that, whilst waiting for a response from traveller B, it is impossible for traveller Ato submit another quote and violate channel linearity. Handling Session Cancellation If either traveller closes their browser before the protocol runs to completion, the generated runtimes leverage the events available on their WebSocket connections to notify (via the server) other roles about the session cancellation. The travel agency can imple ment the error handler callback (generated by STScript ) to perform cleanup logic in response to cancellations. 3 Implementation In this section, we explain how the generated code executes the EFSM for Node.js andReact.js targets. We also present how STScript APIs handle errors in a dynamic webbased environment (for complete code, see Appendix E). Session Runtime. The session runtime executes the EFSM in a manner permitted by the multiparty protocol descrip tion. The runtime keeps track of the current state, performs the required communication action (i.e. send or receive a message), and transitions to the successor state. The runtime provides seams for the developer to inject the callback imple mentations, which define applicationspecific concerns for the EFSM, such as what message payload to send (and dually, how to process a received message). This design conceals the WebSocket APIs from the developer and entails that the developer cannot trigger a send or receive action, so STScript canstatically guarantee protocol conformance. Executing the EFSM in Node.js .Each state of the EFSM is characterised by a (generated) State class and a type de scribing the shape of the callback (supplied by the developer). To allow the server to correctly manage concurrent sessions, the developer can access a (generated) session ID when imple menting the callbacks. STScript also generates IO interfacesfor each kind of EFSM state – send, receive, or terminal. The generated State class implements the interface correspond ing to the type of communication action it performs. 1next(state: State.Type) { 2 switch (state.type) { 3 case 'Send ': return state.performSend( 4 this.next, this.cancel, this.send); 5 case 'Receive ': return state.prepareReceive( 6 this.next, this.cancel, this.registerMessageHandler); 7 case 'Terminal ': return; }} The session runtime for Node.js is a class that executes the EFSM using a state transition function parameterised by the State class of the current EFSM state. As the IO interfaces constitute a discriminated union , the runtime can parse the type of the current EFSM state and propagate the appropriate IO functions (for sending or receiving) to the State class. In turn, the State class invokes the callback supplied by the developer to inject program logic into the EFSM, perform the communication action (using this.send orthis.registerMessageHandler ), and invoke the state transition function ( this.next ) with the successor state. Notably, the routed messages are completely absent be cause the generated code transparently routes messages with out exposing any details. As messages specify their intended recipient, the runtime identifies messages not intended for the server by inspecting the metadata, and forwards them to the WebSocket connected to the intended recipient. Executing the EFSM in React.js .Each state in the EFSM is encoded as an abstract React component. The developer implements the EFSM by extending the abstract classes to provide their own implementation – namely, to build their user interface. Components for send states can access com ponent factories to generate React components that perform a send action when a UI event (e.g. onClick ,onMouseOver ) is triggered. Components for receive states must implement abstract methods to handle all possible incoming messages. The session runtime for React.js is a React component, instantiated using the developer’s implementation of each EFSM state. Channel communications are managed by the runtime, so the developer’s implementations cannot access the WebSocket APIs, which prevents channel reuse by con struction. The runtime renders the component of the current EFSM state and binds the permitted communication action through supplying component properties. Error Handling. An error handling mechanism is critical for web applications. Clients can disconnect from the session due to network connectivity issues or simply by closing the browser. Similarly, servers may also face connectivity issues. Upon instantiating the session runtime, STScript requires developers to supply a cancellation handler to handle local exceptions (e.g. errors thrown by application logic) and global session cancellations (e.g. disconnection events by another 5CC ’21, March 2–3, 2021, Virtual, USA Anson Miu, Francisco Ferreira, Nobuko Yoshida, and Fangyi Zhou endpoint). The session runtime detects cancellation by lis tening to the close event on the WebSocket connection, and invokes the cancellation handler with appropriate arguments on a premature close event. We parameterise the cancellation handlers with additional information (e.g. which role discon nected from the session, the reason for the disconnection) to let developers be more specific in their error handling logic. Cancellation Handlers for Servers. Server endpoints define cancellation handlers through a function, parame terised by the session ID , the rolewhich initiated the cancel lation, and (optionally) the reason for the cancellation — if the serverside logic throws an exception, the handler can access the thrown error through the reason parameter. 1const handleCancel = async (sessionID, role, reason) => { 2 if (role === Role.Self) { 3 console.error( `${sessionID}: internal server error `); } 4 else { await tryRelease(sessionID); }}; 5// Instantiate session runtime 6new S(wss, handleCancel, agencyProvider); Using the Travel Agency scenario introduced in § 1, if the customer prematurely closes their browser before respond ing to a Quote , the server can detect this (Line 4) and release the reservation to preserve data integrity. Cancellation Handlers for Clients. Browserside end points also define cancellation handlers through a function parameterised in the same way as those in Node.js , but must return a React component to be rendered by the session runtime. In the context of the Travel Agency scenario, the customer can render a different UI depending on whether the server disconnected or their friend closed their web browser prematurely. Browser endpoints can also respond to cancel lations emitted by other clientside roles: when a browser endpoint disconnects, the server detects this and propagates the cancellation to the other clientside roles. 4RouST : Routed Session Types This section defines the syntax and semantics of RouST and proves some important properties. We show the sound and complete trace correspondence between a global type and a collection of endpoint types projected from the global type (Theorem 4.6). Using this result, we prove deadlock freedom (Theorem 4.7). We then show that, in spite of the added routed communications, RouST does not overserialise communications by proving communication preservations be tween the original MPST and RouST (Theorem 4.11). These three theorems ensure that STScript endpoint programs are communicationsafe, always make progress, and correctly conforms to the userspecified protocol. 4.1 Syntax of Routed Multiparty Session Types We define the syntax of global types𝐺andlocal types (orend point types )𝑇in Definition 4.1. Global types are also knownasprotocols and describe the communication behaviour be tween all participating roles (participants), while local types describe the behaviour of a single participating role. We shade additions to the original (or canonical ) multiparty ses sion type (MPST) [9, 11, 15, 30] in this colour . Definition 4.1 (Global and Local Types) .The syntax of global andlocal types are defined below: 𝐺::=end|t|𝜇t.𝐺 |p→q:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼 |p−sq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼𝑇::=end|t|𝜇t.𝑇|p↩→q:{𝑙𝑖:𝑇𝑖}𝑖∈𝐼 |p⊕{𝑙𝑖:𝑇𝑖}𝑖∈𝐼|p⊕⟨q⟩{𝑙𝑖:𝑇𝑖}𝑖∈𝐼 |p&{𝑙𝑖:𝑇𝑖}𝑖∈𝐼|p&⟨q⟩{𝑙𝑖:𝑇𝑖}𝑖∈𝐼 Global Types. p→q:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼describes a direct com munication of a message 𝑙𝑖from a role ptoq. We require thatp≠q, that labels 𝑙𝑖are pairwise distinct, and that the index set𝐼is not empty. The message in the communica tion can carry a label among a set of permitted labels 𝑙𝑖 and some payload. After a message with label 𝑙𝑖is received byq, the communication continues with 𝐺𝑖, according to the chosen label. For simplicity, we do not include payload types (integers, strings, booleans, etc) in the syntax. We write p→q:𝑙:𝐺for single branches. For recursion, we adopt anequirecursive view [ 27, §21], and use 𝜇t.𝐺and tfor a recursive protocol and a type variable . We require that re cursive types are contractive (guarded) , i.e. the recursive type 𝜇t.𝐺progresses after the substitution 𝐺[𝜇t.𝐺/t], prohibiting types such as 𝜇t.t. We use endto mark the termination of the protocol, and often omit the final end. To support routed communication, we allow messages to be sent through a router role . Arouted communication p−sq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼describes a router role scoordinating the communication of a message from ptoq:qoffers pa choice in the index set 𝐼, butpsends the selected choice 𝑙𝑖to the router sinstead. The router forwards the selection from ptoq. After qreceives p’s selection, the communication continues with 𝐺𝑖.sranges over the set of roles p,q,···, but we use sby convention as the router is usually some server. The syntax for routed communication shares the same properties as direct communication, but we additionally require that p≠q≠s. We use pt(𝐺)to denote the set of participants in the global type 𝐺. Example 4.2 (Travel Agency) .The travel agency protocol, as shown in Fig. 4, is described by the global type 𝐺travel in the original MPST, and 𝐺𝑅 travelinRouST . 𝐺travel=𝜇t.B→A:𝑆𝑢𝑔𝑔𝑒𝑠𝑡 . A→S:𝑄𝑢𝑒𝑟𝑦. S→A:  𝐴𝑣𝑎𝑖𝑙𝑎𝑏𝑙𝑒 : A→B:𝑄𝑢𝑜𝑡𝑒 . B→A:𝑂𝐾:A→S:𝐶𝑜𝑛𝑓𝑖𝑟𝑚 𝑁𝑜:A→S:𝑅𝑒𝑗𝑒𝑐𝑡 𝐹𝑢𝑙𝑙 :A→B:𝐹𝑢𝑙𝑙 . t   𝐺𝑅 travel=𝜇t.B−SA:𝑆𝑢𝑔𝑔𝑒𝑠𝑡 . A→S:𝑄𝑢𝑒𝑟𝑦. S→A:  𝐴𝑣𝑎𝑖𝑙𝑎𝑏𝑙𝑒 : A−SB:𝑄𝑢𝑜𝑡𝑒 . B−SA:𝑂𝐾:A→S:𝐶𝑜𝑛𝑓𝑖𝑟𝑚 𝑁𝑜:A→S:𝑅𝑒𝑗𝑒𝑐𝑡 𝐹𝑢𝑙𝑙 :A−SB:𝐹𝑢𝑙𝑙 . t  6CommunicationSafe Web Programming in TypeScript with Routed Multiparty Session Types CC ’21, March 2–3, 2021, Virtual, USA Local Types. We first describe the local types in the orig inal MPST theory. q&{𝑙𝑖:𝑇𝑖}𝑖∈𝐼stands for branching and q⊕{𝑙𝑖:𝑇𝑖}𝑖∈𝐼stands for selection . From the perspective of p, branching (resp. selection) offers (resp. selects) a choice among an index set 𝐼to (resp. from) q, and communication continues with the corresponding 𝑇𝑖. Local types 𝜇t.𝑇,tand endhave the same meaning as their global type counterparts. We add new syntax to express routed communication from the perspective of each role involved. The local type p&⟨s⟩{𝑙𝑖:𝑇𝑖}𝑖∈𝐼is arouted branching : the current role is offering a choice from an index set 𝐼top(the intended sender), but expects to receive p’s choice via the router role s; if the message received is labelled 𝑙𝑖,qwill continue with local type𝑇𝑖. The local type q⊕⟨s⟩{𝑙𝑖:𝑇𝑖}𝑖∈𝐼is arouted se lection : the current role makes a selection from an index set𝐼toq(the intended recipient), but sends the selection to the router role s; if the message sent is labelled 𝑙𝑖,pwill continue with local type 𝑇𝑖. The local type p↩→q:{𝑙𝑖:𝑇𝑖}𝑖∈𝐼 is arouting communication . The router role orchestrates the communication from ptoq, and continues with local type𝑇𝑖depending on the label of the forwarded message. We keep track of the router role to distinguish between rout ing communications from normal selection and branching interactions. Endpoint Projection. The local type 𝑇of a participant p in a global type 𝐺is obtained by the endpoint projection of𝐺 onto p, denoted by 𝐺as𝐺↾p. Definition 4.3 (Projection) .The projection of 𝐺onto r, written𝐺↾ris defined as: (p−sq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼)↾r =  q⊕⟨s⟩{𝑙𝑖:𝐺𝑖↾r}𝑖∈𝐼 ifr=p p&⟨s⟩{𝑙𝑖:𝐺𝑖↾r}𝑖∈𝐼 ifr=q p↩→q:{𝑙𝑖:𝐺𝑖↾r}𝑖∈𝐼ifr=s ⊓𝑖∈𝐼𝐺𝑖↾r otherwise(𝜇t.𝐺)↾r =( 𝜇t.(𝐺↾r)if𝐺↾r≠t′ end otherwise end↾r=end t↾r= t The projection(p→q:{𝑙𝑖:𝐺𝑖)}𝑖∈𝐼↾ris defined similar to (p−sq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼)↾rdropping s(in the resulting local type) and the third case. Amerge operator (⊓) is used when projecting a communi cation onto a nonparticipant. It checks that the projections of all continuations must be “compatible” (see Definition B.2). Example 4.4 (Merging Local Types) .Two branching types from the same role with disjoint labels can merged into a type carrying both labels, e.g. A&𝐻𝑒𝑙𝑙𝑜. end⊓A&𝐵𝑦𝑒.end= A&{𝐻𝑒𝑙𝑙𝑜 :end;𝐵𝑦𝑒:end}. The same is not true for selec tions, A⊕𝐻𝑒𝑙𝑙𝑜. end⊓A⊕𝐵𝑦𝑒.endis undefined. 𝐺1=A→B:𝐺𝑟𝑒𝑒𝑡 :A→C:𝐻𝑒𝑙𝑙𝑜 . end 𝐹𝑎𝑟𝑒𝑤𝑒𝑙𝑙 :A→C:𝐵𝑦𝑒 . end 𝐺2=A→B:𝐺𝑟𝑒𝑒𝑡 :C→A:𝐻𝑒𝑙𝑙𝑜 . end 𝐹𝑎𝑟𝑒𝑤𝑒𝑙𝑙 :C→A:𝐵𝑦𝑒 . end The global type 𝐺1can be projected to role C, but not𝐺2.Wellformedness. In the original theory, a global type 𝐺 iswellformed (orrealisable ), denoted wellFormed(𝐺), if the projection is defined for all its participants. wellFormed(𝐺)def=∀p∈pt(𝐺).𝐺↾pexists We assume that the global type 𝐺is contractive (guarded). InRouST , we say that a global type is wellformed with respect to the role sacting as the router . We define the charac teristics that smust display in 𝐺to prove that it is a router, and formalise this as an inductive relation,𝐺⊛s(Defini tion 4.5), which reads sis a centroid in 𝐺. The intuition is thatsis at the centre of all communication interactions. Definition 4.5 (Centroid) .The relation 𝐺⊛s(sis the cen troid of𝐺) is defined by the two axioms end⊛sand t⊛s and by the following rules: 𝐺⊛s 𝜇t.𝐺⊛ss∈{p,q}∀𝑖∈𝐼.𝐺𝑖⊛s p→q:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼⊛sr=s∀𝑖∈𝐼.𝐺𝑖⊛s p−rq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼⊛s For direct communication, smust be a participant and a centroid of all continuations. For routed communication, s must be the router and be a centroid of all continuations. Now we define of wellformedness of a global type 𝐺inRouST with respect to the router s(denoted wellFormed𝑅(𝐺,s)): wellFormed𝑅(𝐺,s)def=(∀p∈pt(𝐺).𝐺↾pexists)∧𝐺⊛s 4.2 Semantics of RouST This subsection defines the labelled transition system (LTS) over global types for RouST , building upon [11]. First, we define the labels (actions) in the LTS which dis tinguish the direct sending (and reception) of a message from the sending (and reception) of a message viaan intermediate routing endpoint. Labels range over𝑙,𝑙′,···are defined by: 𝑙::=pq!𝑗|pq?𝑗|via⟨s⟩(pq!𝑗)|via⟨s⟩(pq?𝑗) The label via⟨s⟩(pq!𝑗)represents the sending (performed byp) of a message labelled 𝑗toqthrough the intermediate router s. The label via⟨s⟩(pq?𝑗)represents the reception (initiated by q) of a message labelled 𝑗send from pthrough the intermediate router s. The subject of a label𝑙, denoted by subj(𝑙), is defined as: subj(via⟨s⟩(pq!𝑗))=subj(pq!𝑗)=p; and subj(via⟨s⟩(pq?𝑗))=subj(pq?𝑗)=q. LTS Semantics over Global Types. The LTS semantics model asynchronous communication to reflect our imple mentation. We introduce intermediate states (i.e. messages in transit) within the grammar of global types: the con struct p⇝q. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼represents that the message 𝑙𝑗 has been sent by pbut not yet received by q; and the con struct p⇝ sq. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼represents that 𝑙𝑗has been sent from pto the router sbut not yet routed to q. We define the LTS semantics over global types, denoted by 𝐺𝑙−−→𝐺′, in Fig. 7. [ Gr1] and [ Gr2] model the emission and reception of a message; [ Gr3] models recursions; [ Gr4] and [ Gr5] model causally unrelated transmissions — we only enforce the syntactic order of messages for the participants involved 7CC ’21, March 2–3, 2021, Virtual, USA Anson Miu, Francisco Ferreira, Nobuko Yoshida, and Fangyi Zhou [Gr1] p→q:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼pq!𝑗−−−−−−−−→ p⇝q. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼 [Gr2] p⇝q. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼pq?𝑗−−−−−−−−→𝐺𝑗 ∀𝑖∈𝐼.𝐺𝑖𝑙−−→𝐺′ 𝑖subj(𝑙)∉{p,q} [Gr4] p→q:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼𝑙−−−−−−−−→ p→q: 𝑙𝑖:𝐺′ 𝑖	 𝑖∈𝐼 𝐺𝑗𝑙−−→𝐺′ 𝑗subj(𝑙)≠q∀𝑖∈𝐼\{𝑗}.𝐺′ 𝑖=𝐺𝑖 [Gr5] p⇝q. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼𝑙−−−−−−−−→ p⇝q. 𝑗: 𝑙𝑖:𝐺′ 𝑖	 𝑖∈𝐼𝐺[𝜇t.𝐺/t]𝑙−−→𝐺′ [Gr3] 𝜇t.𝐺𝑙−−→𝐺′[Gr6] p−sq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼via⟨s⟩(pq!𝑗)−−−−−−−−→ p⇝sq. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼 [Gr7] p⇝sq. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼via⟨s⟩(pq?𝑗)−−−−−−−−→𝐺𝑗 ∀𝑖∈𝐼.𝐺𝑖𝑙−−→𝐺′ 𝑖subj(𝑙)∉{p,q} [Gr8] p−sq:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼𝑙−−−−−−−−→ p−sq: 𝑙𝑖:𝐺′ 𝑖	 𝑖∈𝐼 𝐺𝑗𝑙−−→𝐺′ 𝑗subj(𝑙)≠q∀𝑖∈𝐼\{𝑗}.𝐺′ 𝑖=𝐺𝑖 [Gr9] p⇝sq. 𝑗:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼𝑙−−−−−−−−→ p⇝sq. 𝑗: 𝑙𝑖:𝐺′ 𝑖	 𝑖∈𝐼 Figure 7. LTS over Global Types in RouST in the action 𝑙. [Gr6] and [ Gr7] are analogous to [ Gr1] and [Gr2] for describing routed communication, but uses the “routed intransit” construct instead. [ Gr8] and [ Gr9] are analogous to [ Gr4] and [ Gr5]. An important observation from [ Gr8] and [ Gr9] is that, for the router, the syntactic order of routed communication can be freely interleaved between the syntactic order of direct communication. This is crucial to ensure that the router does not overserialise communication. See Example 4.13 for an LTS example. Relating Semantics of Global and Local Types. We prove the soundness and completeness of our LTS semantics with respect to projection. We take three steps following [11]: 1.We extend the LTS semantics with configuration(®𝑇,®𝑤), a collection of local types ®𝑇with FIFO queues between each pair of participants ®𝑤. 2.We extend the definition of projection, to obtain a config uration of a global type (a projected configuration ), which expresses intermediate communication over FIFO queues. 3.We prove the trace equivalence between the global type and its projected configuration (i.e. the initial configura tion of𝐺,(®𝑇,®𝜖), where®𝑇={𝐺↾p}p∈Pare a set of local types projected from 𝐺and𝜖is an empty queue). The proof is nontrivial: due to space limitations, we omit the semantics of local types, configurations and global con figurations, and only state the main result (see Appendices B and C). Theorem 4.6 (Sound and Complete Trace Equivalence) .Let 𝐺be a wellformed canonical global type. Then 𝐺is trace equivalent to its initial configuration. Theorem 4.7 proves traces specified by a wellformed global protocol are deadlockfree , i.e. the global type either completes all communications, or otherwise makes progress. Note that this theorem implies the deadlockfreedom of con figurations by Theorem 4.6. Theorem 4.7 (Deadlock Freedom) .Let𝐺be a global type. Suppose𝐺is wellformed with respect to some router s, i.e.wellFormed𝑅(𝐺,s). Then we have: ∀𝐺′. 𝐺→∗𝐺′=⇒(𝐺′=end)∨∃𝐺′′,𝑙.(𝐺′𝑙−−→𝐺′′) 4.3 From Canonical MPST to RouST We present an encoding from the canonical MPST theory (no routers) to RouST . This encoding is parameterised by the router role (conventionally denoted as s); the intuition is that we encode all communication interactions to involve s. If the encoding preserves the semantics of the canonical global type, then this encoding can guide a correct protocol implementation in Node.js vias, preserving communication structures of the original protocol without deadlock. RouterParameterised Encoding. We define the router parameterised encoding on global types, local types and LTS labels in the MPST theory. We start with global types, as presented in Definition 4.8. The main rule is the direct communication: if the communication did not go through s, then the encoded communication involves sas the router. Definition 4.8 (Encoding on Global Types) .The encoding of global type 𝐺with respect to the router role s, denoted by J𝐺,sK, is defined as: Jend,sK=endJt,sK=tJ𝜇t.𝐺,sK=𝜇t.J𝐺,sK Jp→q:{𝑙𝑖:𝐺𝑖}𝑖∈𝐼,sK=( p→q: 𝑙𝑖:J𝐺𝑖,sK	 𝑖∈𝐼ifs∈{p,q} p−sq: 𝑙𝑖:J𝐺𝑖,sK	 𝑖∈𝐼otherwise Local types express communication from the perspective of a particular role, hence the encoding takes two roles. Definition 4.9 (Encoding on Local Types) .The encoding of local type 𝑇(from the perspective of role q) with respect to the router role s, denoted by J𝑇,q,sK, is defined as: Jend,q,sK=endJt,q,sK=tJ𝜇t.𝑇,q,sK=𝜇t.J𝑇,q,sK Jp⊕{𝑙𝑖:𝑇𝑖}𝑖∈𝐼,q,sK=( p⊕ 𝑙𝑖:J𝑇𝑖,q,sK	 𝑖∈𝐼ifs∈{p,q} p⊕⟨s⟩ 𝑙𝑖:J𝑇𝑖,q,sK	 𝑖∈𝐼otherwise Jp&{𝑙𝑖:𝑇𝑖}𝑖∈𝐼,q,sK=( p& 𝑙𝑖:J𝑇𝑖,q,sK	 𝑖∈𝐼ifs∈{p,q} p&⟨s⟩ 𝑙𝑖:J𝑇𝑖,q,sK	 𝑖∈𝐼otherwise 8CommunicationSafe Web Programming in TypeScript with Routed Multiparty Session Types CC ’21, March 2–3, 2021, Virtual, USA Lemma 4.10 (Correspondence between Encodings) .The projection of an encoded global type J𝐺,sK↾ris equal to the encoded local type after projection J𝐺↾r,r,sK, with respect to router s, i.e.∀r,s,𝐺."
306,High Throughput Cryptocurrency Routing in Payment Channel Networks.txt,"Despite growing adoption of cryptocurrencies, making fast payments at scale
remains a challenge. Payment channel networks (PCNs) such as the Lightning
Network have emerged as a viable scaling solution. However, completing payments
on PCNs is challenging: payments must be routed on paths with sufficient funds.
As payments flow over a single channel (link) in the same direction, the
channel eventually becomes depleted and cannot support further payments in that
direction; hence, naive routing schemes like shortest-path routing can deplete
key payment channels and paralyze the system. Today's PCNs also route payments
atomically, worsening the problem. In this paper, we present Spider, a routing
solution that ""packetizes"" transactions and uses a multi-path transport
protocol to achieve high-throughput routing in PCNs. Packetization allows
Spider to complete even large transactions on low-capacity payment channels
over time, while the multi-path congestion control protocol ensures balanced
utilization of channels and fairness across flows. Extensive simulations
comparing Spider with state-of-the-art approaches shows that Spider requires
less than 25% of the funds to successfully route over 95% of transactions on
balanced traffic demands, and offloads 4x more transactions onto the PCN on
imbalanced demands.","Despite their growing adoption, cryptocurrencies suffer from poor scalability. For example, the Bitcoin [5] network processes 7 transactions per second, and Ethereum [14] 15 transactions/sec ond, which pales in comparison to the 1,700 transactions per second achieved by the VISA network The lead author can be contacted at vibhaa@mit.edu 1arXiv:1809.05088v5  [cs.NI]  23 Mar 2020[57]. Scalability thus remains a major hurdle to the adoption of cryptocurrencies for retail and other largescale applications. The root of the scalability challenge is the inefﬁciency of the underlying consensus protocol: every transaction must go through full consensus to be conﬁrmed, which can take anywhere from several minutes to hours [44]. A leading proposal among many solutions to improve cryptocurrency scalability [23, 32, 41] relies on socalled payment channels . A payment channel is a cryptocurrency transaction that escrows or dedicates money on the blockchain for exchange with a prespeciﬁed user for a pre determined duration. For example, Alice can set up a payment channel with Bob in which she escrows 10 tokens for a month. Now Alice can send Bob (and only Bob) signed transactions from the escrow account, and Bob can validate them privately in a secure manner without mediation on the blockchain ( x2). If Bob or Alice want to close the payment channel at any point, they can broadcast the most recent signed transaction message to the blockchain to ﬁnalize the transfer of funds. The versatility of payment channels stems from payment channel networks (PCNs), in which users who do not share direct payment channels can route transactions through intermediaries for a nominal fee. PCNs enable fast, secure transactions without requiring consensus on the blockchain for every transaction. PCNs have received a great deal of attention in recent years, and many blockchains are looking to PCNs to scale throughput without overhauling the underlying consensus protocol. For example, Bitcoin has deployed the Lightning network [15, 10], and Ethereum uses Raiden [18]. For PCNs to be economically viable, the network must be able to support high transaction throughput . This is necessary for intermediary nodes (routers) to proﬁtably offset the opportunity cost of escrowing funds in payment channels, and for encouraging enduser adoption by providing an appealing quality of payment service. But, a transaction is successful only if all channels along its route have sufﬁcient funds. This makes payment channel routing , the protocol by which a path is chosen for a transaction, of paramount importance. Existing payment channel routing protocols achieve poor throughput, for two main reasons. First, they attempt to route each incoming transaction atomically and instantaneously, in full. This approach is harmful, particularly for larger transactions, because a transaction fails completely if there is no path to the destination with enough funds. Second, existing routing protocols fail to keep payment channels balanced . A payment channel becomes imbalanced when the transaction rate across it is higher in one direction than the other; the party making more transactions eventually runs out of funds and cannot send further payments without “reﬁlling” the channel via either an onchain transaction (i.e., committing a new transaction to the blockchain) or coordinated cyclic payments between a series of PCN nodes [40]. Most PCNs today route transactions naively on shortest paths with no consideration for channel balance; this can leave many channels depleted, reducing throughput for everyone in the network. We describe a third problem, the creation of deadlocks in certain scenarios, in x3. In this paper we present Spider , a multipath transport protocol that achieves balanced, high throughput routing in PCNs, building on concepts in an earlier position paper [52]. Spider’s design centers on two ideas that distinguish it from existing approaches. First, Spider senders “packetize” transactions, splitting them into transactionunits that can be sent across different paths at different rates. By enabling congestioncontrollike mechanisms for PCNs, this packetswitched approach makes it possible to send large payments on lowcapacity payment channels over a period of time. Second, Spider develops a simple multipath congestion control algorithm that promotes balanced 2channels while maximizing throughput. Spider’s senders use a simple onebit congestion signal from the routers to adjust window sizes, or the number of outstanding transactionunits, on each of their paths. Spider’s congestion control algorithm is similar to multipath congestion control protocols like MPTCP [60] developed for Internet congestion control. But the routing problem it solves in PCNs differs from standard networks in crucial ways. Payment channels can only route transactions by moving a ﬁnite amount of funds from one end of the channel to the other. Because of this, the capacity of a payment channel — the transaction rate that it can support — varies depending on how it is used; a channel with balanced demand for routing transactions in both directions can support a higher rate than an imbalanced one. Surprisingly, we ﬁnd that a simple congestion control protocol can achieve such balanced routing, despite not being designed for that purpose explicitly. We make the following contributions: 1. We articulate challenges for highthroughput routing in payment channel networks ( x3), and we formalize the balanced routing problem ( x5). We show that the maximum throughput achievable in a PCN depends on the nature of the transaction pattern: circulation demands (participants send on average as much as they receive) can be routed entirely with sufﬁcient network capacity, while demands that form Directed Acyclic Graphs (DAGs) where some participants send more than they receive cannot be routed entirely in a balanced manner. We also show that introducing DAG demands can create deadlocks that stall all payments. 2. We propose a packetswitched architecture for PCNs ( x4) that splits transactions into transaction units and multiplexes them across paths and time. 3. We design Spider ( x6), a multipath transport protocol that (i) maintains balanced channels in the PCN, (ii) uses the funds escrowed in a PCN efﬁciently to achieve high throughput, and (iii) is fair to different payments. 4. We build a packetlevel simulator for PCNs and validate it with a smallscale implementation of Spider on the LND Lightning Network codebase [15]. Our evaluations ( x7) show that (i) on circulation demands where 100% throughput is achievable, compared to the stateofthe art, Spider requires 25% of the funds to route over 95% of the transactions and completes 1.3 1.8x more of the largest 25% of transactions based on a credit card transactions dataset [34]; (ii) on DAG demands where 100% throughput is not achievable, Spider ofﬂoads 78x as many transactions onto the PCN for every transaction on the blockchain, a 4x improvement over current approaches. 2 Background Bidirectional payment channels are the building blocks of a payment channel network. A bidirec tional payment channel allows a sender (Alice) to send funds to a receiver (Bob) and vice versa. To open a payment channel, Alice and Bob jointly create a transaction that escrows money for a ﬁxed amount of time [47]. Suppose Alice puts 3 units in the channel, and Bob puts 4 (Fig. 1). Now, if Bob wants to transfer one token to Alice, he sends her a cryptographicallysigned message as serting that he approves the new balance. This message is not committed to the blockchain; Alice simply holds on to it. Later, if Alice wants to send two tokens to Bob, she sends a signed message to Bob approving the new balance (bottom left, Fig. 1). This continues until one party decides to 3close the channel, at which point they publish the latest message to the blockchain asserting the channel balance. If one party tries to cheat by publishing an earlier balance, the cheating party loses all the money they escrowed to the other party [47]. AliceBobTxn2Alice(3) AliceBobOpenChannel(1) AliceBobTxn1Bobç(2) AliceBobCloseChannel(4) Figure 1: Bidirectional payment channel between Alice and Bob. A blue shaded block indicates a trans action that is committed to the blockchain. Figure 2: In a payment channel network, Alice can transfer money to Bob by using intermediate nodes’ channels as relays. There are two paths from Alice to Bob, but only the path (Alice, Charlie, Bob) can support 3 tokens. A payment channel network is a collection of bidirectional payment channels (Fig. 2). If Alice wants to send three tokens to Bob, she ﬁrst ﬁnds a path to Bob that can support three tokens of payment. Intermediate nodes on the path (Charlie) will relay payments to their destination. Hence in Fig. 2, two transactions occur: Alice to Charlie, and Charlie to Bob. To incentivize Charlie to participate, he receives a routing fee. To prevent him from stealing funds, a cryptographic hash lock ensures that all intermediate transactions are only valid after a transaction recipient knows a private key generated by Alice [18].1Once Alice is ready to pay, she gives that key to Bob out ofband; he can either broadcast it (if he decides to close the channel) or pass it to Charlie. Charlie is incentivized to relay the key upstream to Alice so that he can also get paid. Note that Charlie’s payment channels with Alice and Bob are independent: Charlie cannot move funds between them without going through the blockchain. 1The protocol called Hashed Timelock Contracts (HTLCs) can be implemented in two ways: the sender generates the key, as in Raiden [18] or the receiver generates the key, as in Lightning [47]. Spider assumes that the sender generates the key. 4(a)Underutilized channels  (b)Imbalanced channels (c)Deadlock Figure 3: Example illustrating the problems with stateoftheart PCN routing schemes. 3 Challenges in Payment Channel Networks A major cost of running PCNs is the collateral needed to set up payment channels. As long as a channel is open, that collateral is locked up, incurring an opportunity cost for the owner. For PCNs to be ﬁnancially viable, this opportunity cost should be offset by routing fees, which are charged on each transaction that passes through a router. To collect more routing fees, routers try to process as many transactions as possible for a given amount of collateral. A key performance metric is therefore the transaction throughput per unit collateral where throughput itself is measured either in number of transactions per second or transaction value per second. Current PCN designs exhibit poor throughput due to naive design choices in three main areas: (1)how to route transactions,(2) when to send them and, (3) deadlocks . Challenge #1: How to route transactions? A central question in PCNs is what route(s) to use for sending a transaction from sender to destination. PCNs like the Lightning and Raiden networks are sourcerouted.2Most clients by default pick the shortest path from the source to the destination. However, shortestpath routing degrades throughput in two key ways. The ﬁrst is to cause underutilization of the network. To see this, consider the PCN shown in Fig. 3a. Suppose we have two clusters of nodes that seek to transact with each other at roughly the same rate on average, and the clusters are connected by two paths, one consisting of channels a"
440,Distributed Routing in a Quantum Internet.txt,"We develop new routing algorithms for a quantum network with noisy quantum
devices such that each can store a small number of qubits. We thereby consider
two models for the operation of such a network. The first is a continuous
model, in which entanglement between a subset of the nodes is produced
continuously in the background. This can in principle allows the rapid creation
of entanglement between more distant nodes using the already pre-generated
entanglement pairs in the network. The second is an on-demand model, where
entanglement production does not commence before a request is made. Our
objective is to find protocols, that minimise the latency of the network to
serve a request to create entanglement between two distant nodes in the
network. We propose three routing algorithms and analytically show that as
expected when there is only a single request in the network, then employing
them on the continuous model yields a lower latency than on the on-demand one.
We study the performance of the routing algorithms in a ring, grid, and
recursively generated network topologies. We also give an analytical upper
bound on the number of entanglement swap operations the nodes need to perform
for routing entangled links between a source and a destination yielding a lower
bound on the end to end fidelity of the shared entangled state. We proceed to
study the case of multiple concurrent requests and show that in some of the
scenarios the on-demand model can outperform the continuous one. Using
numerical simulations on ring and grid networks we also study the behaviour of
the latency of all the routing algorithms. We observe that the proposed routing
algorithms behave far better than the existing classical greedy routing
algorithm. The simulations also help to understand the advantages and
disadvantages of different types of continuous models for different types of
demands.","The goal of a quantum internet [1]–[4] is to enable the transmission of quantum bits (qubits) between distant quan tum devices to achieve the tasks that are impossible using classical communication. For example, with such a network we can implement cryptographic protocols like longdistance quantum key distribution (QKD) [5, 6], which enables secure communication. Apart from QKD, many other applications in the domain of distributed computing and multiparty cryptography [7] have already been identiﬁed at different stages of quantum network development [8]. Like the classical internet, a quantum internet consists of the network components like physical communication links, and eventually routers [2, 9]–[11]. However, due to funda mental differences between classical and quantum bits, these components in a quantum network behave rather differentlythan their classical counterparts. For example, qubits cannot be copied, which rules out retransmission as a means to over come qubit losses [12]. To nevertheless send qubits reliably, a standard method is to ﬁrst produce quantum entanglement between a qubit held by the sender and a qubit held by the receiver. Once this entanglement has been produced, the qubit can then be sent using quantum teleportation [12, 13]. This requires, in addition, the transmission of two classical bits per qubit from the sender to the receiver. Importantly, teleportation consumes the entanglement, meaning that it has to be reestablished before the next qubit can be sent. When it comes to routing qubits in a network, one hence needs to consider routing entanglement [1, 14]–[17]. An important tool for establishing entanglement over long distances is the notion of entanglement swapping. If two nodesAandBare both connected to an intermediary noder, but not directly connected themselves by a physical quantum communication channel such as ﬁber, then Aand Bcan nevertheless create entanglement between themselves with the help of r. First,AandBeach individually create entanglement with r. This requires one qubit of quantum storage atAandBto hold their end of the entanglement, and two qubits of quantum storage at r. Noderthen performs anentanglement swap [13, 18, 19], destroying its own entan glement with AandB, but instead creating entanglement betweenAandB. This process can be understood as node rteleporting its qubit entangled with Aonto nodeBusing the entanglement that it shares with B. In turn, using this process iteratively, node rcan with the assistance of Aand B, also establish entanglement with nodes that are far away in the physical communication network. Any node rcapable of storing qubits can thus simultaneously be entangled with as many nodes in the network as it can store qubits in its quantum memory. Such a node may function as an entanglement router by taking decisions for which of its neighbours it should perform an entanglement swap operation for sharing an entangled link between a source sand a destinatione(see [20] for a longer introduction). In the domain of quantum information we use the term quantum state to represent the state of a multiqubit quan tum system. A pure nqubit quantum state j nican be mathematically described as a unit vector in a Hilbert space Hof dimension 2n. The entangled target state j +i=arXiv:1907.11630v1  [quantph]  26 Jul 20191p 2(j00iAB+j11iAB)is a pure quantum state of two qubits AandB. Annqubit mixed state nonHis a Hermitian operator with unit trace. nis called as density matrix. A mixed state is a generalisation of a pure state that can model noisy quantum states, and the density matrix representation of a pure statej iisj ih j, whereh jis the transpose of the complex conjugate of j i. In this paper, we use the quantity, known as ﬁdelity to measure the closeness between two quantum states. The ﬁdelity between a target pure state j iand a mixed state is deﬁned as F(;j ih j) =h jj i. The mixed state has a unit trace and j iis a unit vector, which implies 0F(;j ih j)1. Moreover, F(;j ih j) = 1 if and only if =j ih j. This implies that two states with high ﬁdelity are close to each other. In this paper, we mostly consider the depolarising channels and for this type of channels, if a node rperforms a noise free entanglement swap operation between two entangled links with ﬁdelity F1,F2then the ﬁdelity of the resulting entangled state is at least F1F2[21]. A quantum network may generate entanglement on the demand only when a request arrives, which we call the on demand model. In this case, the routing problem reduces to routing entanglement on the physical communication graph (Gph= (V;E ph)) corresponding to the ﬁbres (or freespace links) connecting the quantum network nodes. This means that entanglement is produced by two nodes connected in Gphfollowed by entanglement swapping operations along a path in this graph1. Two such neighbour nodes in Gph are called physical neighbours of each other. However, we may also preestablish entanglement between two nodes which do not share a physical connection, in anticipation of future requests. Such preshared entanglement forms a virtual link [20]. Two such nodes, who are not directly connected by a physical link but share an entangled link or a virtual link, are called virtual neighbours of each other. Here, we consider routing on the virtual graph given by preshared entanglement ( G= (V;E)). This virtual graph may have much lower diameter than the underlying physical one. Such virtual links are in spirit similar to forming an overlay network in peertopeer networks [26]–[34], with the important distinction that the graph is highly dynamic: each virtual link can be used only once and it must be reestablished before further use. This can be a very time consuming process. What’s more, due to short lifetimes of quantum memories the virtual graph is continuously changing as virtual links expire after some time even if they have not been used. Of course, on both graphs, one can nevertheless apply classical algorithms to select a path from the sender to the 1In this case the nodes discover a path from a source sto a destination einGphand use any entanglement distribution scheme (e.g. the schemes proposed in [9, 19, 21]–[25]) in a repeater chain for generating entanglement between sande.receiver, along which entanglement swapping is performed to create an end to end link. The performances of the centralised shortest path routing algorithms [35] are highly dependent on the network topology. If the topology changes rapidly then keeping the routing tables up to date becomes challenging. This type of situation also occurs in classical delaytolerant networks [36]–[40]. Usually, for this type of network, the distributed routing algorithms [37]–[40] always perform bet ter than the centralised shortest path algorithm [35]. Hence, in this paper, we address the routing problem by modifying existing classical distributed routing algorithms. The main challenge for designing such algorithms is that the nodes need to decide which operation to perform (entanglement generation or entanglement swap) based on local information. Analysing those routing algorithms for multiple demands is also a challenging task. In this paper we use the mathematical tools from classical routing theory [41]–[44] for computing the latency of our proposed routing algorithms for single source and destination pairs. We use numerical simulations for analysing the performances in case of multiple source and destination pairs. II. R ELATED WORK "
369,An Axiomatic Approach to Routing.txt,"Information delivery in a network of agents is a key issue for large, complex
systems that need to do so in a predictable, efficient manner. The delivery of
information in such multi-agent systems is typically implemented through
routing protocols that determine how information flows through the network.
Different routing protocols exist each with its own benefits, but it is
generally unclear which properties can be successfully combined within a given
algorithm. We approach this problem from the axiomatic point of view, i.e., we
try to establish what are the properties we would seek to see in such a system,
and examine the different properties which uniquely define common routing
algorithms used today.
  We examine several desirable properties, such as robustness, which ensures
adding nodes and edges does not change the routing in a radical, unpredictable
ways; and properties that depend on the operating environment, such as an
""economic model"", where nodes choose their paths based on the cost they are
charged to pass information to the next node. We proceed to fully characterize
minimal spanning tree, shortest path, and weakest link routing algorithms,
showing a tight set of axioms for each.","The proper way to distribute power, disseminate information, or establish hierarchies in organizations is an issue encountered whenever there is a large enough network of agents that needs to interact in an orderly manner. For example, when trying to establish efﬁcient lines of communications between agents which all need to reach a central hub, there are various properties we may desire in our system. We might want the system to be able to handle small changes in connections without causing disruptions throughout the network; we may want it to be ﬂexible when we change its parameters so that various routing options are possible, and more. Indeed, the search for the right communication structure has played a role in early work on the foundations of the area of multiagent systems [7, 15, 5], based on classical work in organization theory [8, 16]. More concretely, examining networking, one of the most important aspects of the design of a com munication network is the way it routes information through its physical links. Routing protocols, such as those used in packet switching networks, circuit switching, or adhoc networks are designed with many goals in mind. They must adapt to changing network conditions, withstand failures, and operate in a distributed fashion while constructing a “good” routing scheme. Nodes in the network are, in fact, autonomous agents that can control the ﬂow of information through them and can choose to forward it according to their own considerations. Agents may be controlled by different economic entities (such as in the internet, where different internet service providers control some of the routers), and may route according to complex preferences that are derived from economic relations [9, 14]. Even in the co operative localnetwork setting where all routers are controlled by a single network operator, different considerations such as bandwidth utilization, latency, and the risks of link failures come into play.O. Lev, M. Tennenholtz & A. Zohar 195 The multitude of previous treatments of the problem suggest a myriad of routing protocols, each with their own beneﬁts and shortcomings. In contrast, this work examines the routing problem through the lens of the axiomatic approach , which seeks to formulate different elementary properties that are desirable in this context. One approach to an axiomatic treatment, which we take in this work, is that of characterization: a set of elementary properties is shown to uniquely determine some routing algorithm, and hence the routing outcome on any speciﬁc graph. From the designer’s perspective, such a result implies a great deal – any additional property that is not already achieved by the protocol cannot be added to it without giving up on another basic property. The approach thus provably bounds the design space of algorithms and makes explicit the choices made when selecting one over the other. As we are not aware of any previous axiomatic treatment of routing, we focus our attention on a domain that most closely resembles the internet as it is built today, and focus our efforts within this do main on what one may consider classic, or natural routing schemes. In particular, we assume that routing choices are independent of the congestion on links (such is the case in the internet, where routing proto cols such as BGP ﬁrst establish paths, and congestion control protocols such as the one embedded into TCP manage the load on each ﬂow’s path and ensures that rates are throttled to match the bottleneck of the ﬂow). Furthermore, as with internet routing where routers decide on the next hop of each packet us ing a routing table that maps its destination to the next hop, routing choices made to different destinations are done independently. Finally, packets addressed to the same destination are not split between different paths, and are routed in the same manner regardless of their source. These choices, which greatly restrict the power of any routing algorithm may seem arbitrary, but are in fact derived from realworld design considerations. For example, the need to quickly forward packets towards their destination at each router mandated that most routing be done in specialized hardware. No complex computation is performed (only a lookup into a routing table) and no deep inspection of the packet is performed. Keeping routing simple has made it fast and robust. More advanced routing schemes that have been proposed in the literature may split trafﬁc, allow routing choices to depend on the source of the packet or its previous hops, or may even change the routes in response to link congestion. These are notoriously difﬁcult to coordinate and to implement. We leave treatment of these more advanced schemes to future work. Our set of axioms or “desirable properties” are also motivated by similar considerations. For ex ample, one of the fundamental features we desire in our algorithms is one of robustness , which is the ability of a system to endure changes in the network without creating disruption in parts of the network that have not undergone changes. A different feature, which might be desirable only in certain cases, is “ﬁrst hop” , which is particu larly relevant for diffuse networks with independent nodes. It means, broadly, that network nodes care only about their immediate surroundings, or the “next step” in the network data transfer. Such a property might be relevant when nodes pursue an “economic model”, paying for transferring information, and hence only caring about the cost they need to pay to move their information to the next node, and fol lowing that, they have no preference on the route the information should pass en route to its destination. Other properties, desirable only in some cases include an indifference between two parallel paths, as long as they change their weights by the same amount concurrently. Ultimately, after devising our axioms we successfully fully characterized 3 natural routing algo rithms: Minimum spanning tree: A tree with the smallest overall weight is a result, among others, of the “ﬁrst hop” axiom (the “economic model”). Shortest path: A tree where each node has the shortest possible path to its destination is a result,196 An Axiomatic Approach to Routing among other axioms, of viewing as immaterial to the routing decision any parallel paths which change their weight by the same amount. Weakest link tree: A tree where each node takes the path with the maximal “lightest” weight available to it. This results from considering higher edgeweights as beneﬁcial (e.g., representing bandwidth which one wishes to increase in contrast to delay that one wishes to decrease), and from considering designers that choose between parallel paths in a slightly different manner. We proceed to review relevant previous research and then continue to deﬁne our model and expand on the axioms, which are motivated with a brief explanation and presented formally. Following that we show (and prove) our characterization of the minimal spanning tree, the shortest path tree, and the weakest link tree. 2 Related Work "
27,Dynamic Index NAT as a Mobility Solution in OMNeT++.txt,"Mobility in wireless networks causes a major issue from the IP-addressing
perspective. When a Mobile Node (MN) moves to another subnet, it will probably
get assigned a new IP address. This causes a routing problem since the MN will
not be reachable with its previous IP address known to the other communication
party. Real time applications might suffer from connection drops, which is
recognized as inconvenience in the currently used service, unless some solution
is provided. An approach to maintain session continuity while traversing
heterogeneous networks of different subnet addresses is proposed. Here, a
cross-layer module is implemented in OMNeT++ with NAT functionality to provide
a seamless handover. A proof of concept is also shown with analogy to the
Mobile IPv6 protocol provided in INET.","Wireless communication networks can be categorized as heterogeneous based on different aspects, like having an infrastructure, type of radio access technology, and subnet address. While nowadays communication devices are equipped with multiple interfaces and due to the evolving applications and usage scenarios that require IP connectivity anywhere anytime, switching the connection to another access point (handover) and getting assigned a new IP address is a common communication scenario. In this paper, we try to handle this issue from the network layer point of view and observe its impact on running applica tions and the provided Quality of Service (QoS). Nevertheless, we also present our design for vertical handover (VHO) management module, which is however not yet provided with performance analysis. The module manages VHO from above the link layer and between independent wireless interfaces. For a running session, changing the IP address introduces a routing problem where the MN is not available any more for its communication party, unless a robust mobility solution is deployed. Our proposed approach makes use of the fact that due to the limited address space of IPv4 and the increased number of IPconnected users, Network Address Translation (NAT) became a de facto standard in almost all communica tion networks. This work implements our concept previously presented in a use case in [1]. Also it contributes to the INET framework of OMNeT++ [2] by implementing NAT operation in network layer with an update mechanism achieved through a cross layer module as will be described in more details later.Performance results are provided in comparison to the known mobility solution (MIPv6) provided in INET. The program code introduced here is a part of a PhD research work and can be available for sharing after the defense of the PhD, to be presented as a VHO protocol contributing to the INET framework. II. R ELATED WORK "
347,A Route Optimization technique for registered and unregistered CN's in NEMO.txt,"As the demand of, requesting the Internet without any disturbance by the
mobile users of any network is increasing the IETF started working on Network
Mobility (NEMO). Maintaining the session of all the nodes in mobile network
with its home network and external nodes can be provided by the basic Network
Mobility support protocol. It provides mobility at IP level to complete
networks, allowing a Mobile Network to change its point of attachment to the
Internet, while maintaining the ongoing sessions of the nodes of the network.
The Mobile Router (MR) manages the mobility even though the nodes don't know
the status of mobility. This article discusses few basic concepts and
limitations of NEMO protocol and proposes two ways to optimize the NEMO routing
technique for registered and unregistered Correspondent Nodes (CN) of the
Mobile Network Node (MNN).","INTERNET access requirement in heterogeneous        environments is increasing. The success of cellular  communication shows the interest of users in  mobility access. These networks are expected to provide not only voice serv ices, and also the data  services. IP is the base technology for future  networks, which can provide all kind of services with different access modes like fixed and mobile. But IP  was not designed for supporting mobility of users  and terminals. The IETF has defined some IPlayer protocols that enable terminal mobility in IPv4 and  IPv6 [1] networks.  But, these protocols do not  support the movement of a complete network that  moves as a whole and changing its point of  attachment to the fixed infrastructure, that is,  network mobility. The IETF created a working group: NEMO (Network Mobility), with the aim of  extending existing host mobility solutions to enable  the movement of networks in IPv6.   Basically IP networks were not designed in  terms of supporting fo r mobility or mobile  environments. IP addresses are locators that specify, based on a routing system, how to reach the terminal  that is using that address, it can also part of the end point identifiers of a communication, and upper layers use the identifiers of the peers of a  communication to identify it.   The IETF has been working for the problems in  terminal mobility; the NE MO group in IETF comes  up with IP layer solutions for both IPv4 and IPv6 that  enable the movement of terminals without stopping their ongoing sessions. These solutions are even  being completed with proposals that improve the efficiency of the base solution, particularly in micro mobility environments. The issue of terminal  mobility has been analyzed recently in [2].   The first step in adaptation of mobile networks is  terminal mobility support in IP networks, but there  exists also the need of supporting the movement of a  complete network that changes its point of attachment to the fixed in frastructure, maintaining  the sessions of every device of the network: what is  known as network mobility in IP networks. In this case, the mobile network will have at least a router  called as Mobile Router (MR) that connects to the  fixed infrastructure, and the devices of the mobile network will obtain connectivity to the exterior  through this MR. The IP terminal mobility solution  does not support the movement of networks, because of that, the IETF NEMO WG [3] was created to  specify a solution, at the IP layer, to enable network  mobility in    IPv6.  Some of the applications, which use the Internet  access, are,  (i) Public transportation systems: These systems  would let passengers in trains, planes, ships,  etc to access the network.  (ii) Personal networks: Electronic devices carried  by people, such as PDA’s, photo cameras, etc.  would connect through a cellular phone acting  as the MR of the personal network.  (iii) Vehicular scenarios: Future cars will benefit  from having Internet connectivity, not only to  enhance safety, but also to provide personal communication, entertainment, and Internet based services to passengers  The NEMO working group was developed the  basic solution to the network mobility problem in  IPv6 networks by modifying the IPv6 host mobility JOURNAL OF COMPUTING, VOLUME 2, ISSUE 5, MAY 2010, ISSN 21519617  HTTPS://SITES.GOOGLE.COM/SITE/JOURNALOFCOMPUTING/  WWW.JOURNALOFCOMPUTING.ORG   71 solution (MIPv6). But the so lution has to be flexible  to deal with different mobile networks  configurations, in particular, networks containing  different subnets and nested mobile networks.     2 RELATED WORK   "
96,Entanglement Routing over Quantum Networks Using Greenberger-Horne-Zeilinger Measurements.txt,"Generating a long-distance quantum entanglement is one of the most essential
functions of a quantum network to support quantum communication and computing
applications. The successful entanglement rate during a probabilistic
entanglement process decreases dramatically with distance, and swapping is a
widely-applied quantum technique to address this issue. Most existing
entanglement routing protocols use a classic entanglement-swapping method based
on Bell State measurements that can only fuse two successful entanglement
links. This paper appeals to a more general and efficient swapping method,
namely n-fusion based on Greenberger-Horne-Zeilinger measurements that can fuse
n successful entanglement links, to maximize the entanglement rate for multiple
quantum-user pairs over a quantum network. We propose efficient entanglement
routing algorithms that utilize the properties of n-fusion for quantum networks
with general topologies. Evaluation results highlight that our proposed
algorithm under n-fusion can greatly improve the network performance compared
with existing ones.","Quantum information science is viewed as the next sci entific breakthrough that will propel scientific and economic developments for the whole society in the near future, since quantum applications have shown capabilities far beyond the traditional approaches. Specifically, quantum computing algorithms can lead to an exponential speedup compared to traditional computing algorithms; see for example Shor’s algorithm [1] and quantum linear system algorithms [2]. Quantum computing algorithms also allow information to be generated, stored, and transmitted at a high level of privacy, security, and computational clout that is impossible to achieve with today’s traditional methods [3]. The great potential of quantum applications has attracted considerable research attention in academia and huge investments from governments and industries. For instance, the US Department of Energy has announced that it would provide 625 million US dollars over the next five years to support multidisciplinary quantum information science [4]. The European Commission has launched a tenyear, onebillioneuro, flagship project to boost European quantum technology research [5]. In the broad context of quantum information science, quan tum networks are expected to be promising nextgeneration networks [6]. Several trail quantum networks have been de ployed in labs, such as longdistance link (40 kilometers)teleportation over the fiber link [7], the mobile quantum network [8], and the integrated entanglement system through satellites which can support the entanglement over 4600 kilo meters [9]. A fundamental feature of quantum networking, termed entanglement, is important for both formal analysis and physical implementation of quantum computing and communi cation. ""Entanglement"" refers to a group of qubits (a basic unit to represent quantum information) whose quantum states such as position, momentum, spin, polarization, etc. are correlated, even when the particles are separated by a large distance. Entanglement between qubits is an essential component of most quantum applications in quantum networks. Supporting longdistance entanglement between qubits is critical for quantum networks. However, the successful entan glement rate decreases dramatically as the distance between qubits increases. Meanwhile, processors in the same group trying to be entangled may be too distant from each other to be directly connected through links. Entanglementswapping is an important method that can establish an entanglement path between those pairs of quantum processors that had not shared an entanglement. In this way, certain processors in a network that do not participate in the current entanglement can work as relays through entanglementswapping to supply endtoend entanglement. Such a processor is called a switch. This paper studies a key problem in quantum networks, called entanglement routing , whose goal is to achieve efficient longdistance entanglement over a quantum network through entanglementswapping. The entanglement routing problem has recently drawn great attention and a few motivating results have been obtained. Studies have proposed entanglement routing algorithms and corresponding theoretical analyses for some special classes of network topologies [10]–[15]. Improvements for arbitrary network topologies have been made in [16]–[18]. In these existing quantum routing algorithms, however, switches are restricted to perform a classic swapping method [19] that implements socalled Bell State Measurements (BSMs). A BSM is based on two qubits and thus can only fuse two entanglement links. Figure 1a shows an example that BSM can fuse two quantum links by entangling two qubits in the processor. A few recent works [20], [21] allow switches to perform multiqubit joint GreenbergerHorneZeilinger(GHZ) mea surements in the GHZ basis, which can fuse n≥2successful entanglement links simultaneously and thus called nfusion.‡Both authors contributed equally to this research.arXiv:2306.16671v2  [cs.NI]  3 Jul 2023Fig. 1b illustrates a case where a processor takes 3GHZ measurements that can enable the processor to fuse three successful entanglement links. Clearly, nfusion is a more general entanglementswapping method subsuming the classic BSMbased swapping method (i.e., 2fusion) as a special case. Implementing nfusion with n≥3is in principle no harder than 2fusion (BSMs) in switch memories [21]. Meanwhile, n fusion provides the network with more choices and flexibility for individual switches to generate entanglement for quantum users, which may greatly impact the network entanglement performance. However, the existing works [20], [21] only consider a single quantumuser pair in special grid networks, and their results are limited to 3 and 4fusion measurements. Therefore, a comprehensive study for quantum entanglement routing based on nfusion is still missing in the literature. (a)  (b) Fig. 1. (a) A BSM measurement in the switch that fuses two quantum links by connecting two qubits. (b) A 3GHZ measurement in a switch that fuses three quantum links by connecting three qubits. In both figures, the small blank circle in the switch denotes free qubits that are not entanglement, the small green circle in the switch denotes entangled qubits, the orange line indicates the quantum links to be fused, and the blue line shows the connection between qubits to fuse quantum links. To fill the gap just described, this paper considers gen eral network topologies, nfusion entanglementswapping with arbitrary integer n≥2, and multiple quantumuser pairs simultaneously. To the best of our knowledge, this is the first work of a comprehensive entanglement routing design over a general quantum network topology with multiple quantum user pairs where switches can take a general entanglement swapping method, nfusion, with novel models, metrics, and algorithms. The specific goal is to maximize the entanglement rate of the network, i.e., the expected number of shared quantum states between quantumuser pairs. Our contributions are as follows: 1) We present a novel comprehensive entanglement routing model and detailed entanglement process where switches takenfusion for multiple quantumuser pairs to share quantum states in a general network topology. 2) We propose novel routing metrics under nfusion mea surement to evaluate network performance and optimize them by algorithm design. 3) We design efficient entanglement routing algorithms to allocate paths for sharing quantum states between quantumuser pairs. 4) We perform a series of simulations that demonstrate that under the same network setting, our novel nfusion algorithm not only improves the performance up to 6× compared with the existing classic swapping algorithms but also significantly outperforms the existing nfusion ones in terms of the network entanglement rate.This paper provides a foundation for further investigation of n fusion as a swapping method to support quantum applications. The rest of this paper is organized as follows. Section II introduces the necessary quantum background needed in the paper and Section III presents the network model. We pro pose algorithm designs in Section IV. We conduct extensive simulations to discuss and analyze the performance of our proposed algorithms and compare them with previous ones in Section V, followed by related work in Section VI the conclusion in Section VII. II. B ACKGROUND In this section, we will introduce some important quantum terminologies and mechanisms that we will use in this paper. A. Basic Terminologies Qubit: A qubit is a basic unit to represent quantum infor mation, which can be an electron or a photon or a nucleus from an atom, and be described by its state [22]. Different from an ebit in classical computing which represents 0 or 1, a qubit can present a coherent superposition of both 0 and 1. Entanglement: Entanglement is a phenomenon that a group of qubits expresses a high correlation state which cannot be expressed by the states of individual qubits. nqubits can maximally be entangled as a nGHZ state, i.e.,|0⟩⊗n+|1⟩⊗n √ 2. The Bell State that contains the exact two qubits can be viewed as a special case of the nGHZ state, where n= 2. B. Entanglementswapping Entanglementswapping is a quantum operation in which if two processors each has a different qubit entangled with another common processor, then the qubits of these two pro cessors can be entangled directly with the help of the common processor. In this paper, we consider a general entanglement swapping operation called nfusion [20], [21]. nfusion can project nmeasured qubits onto one of the 2nGHZ states by taking GHZ measurements. In a quantum network, this operation allows switches to fuse nsuccessful entanglement links simultaneously. Figure 2 shows an example that a three party processor set gets entangled as a 6GHZ state through GHZ measurements in a switch. For the interior of a switch, nfusion entangles its qubits as shown in Figure 1b. Fig. 2. A 3fusion swapping in a processor over 3 independent processor sets. When n= 1, the operation takes as a singlequbit Pauli measurement [23], which removes a qubit in the measurement axis and results in a (n−1)GHZ state from a nGHZ state. When n= 2 , the operation is a classic swapping procedure by taking BSMs over two qubits that were produced independently and never previously interacted [19]. Taking a n≥3fusion is in principle no harder than a classic swapping(i.e.,n= 2) [21], but it will bring more choices and flexibility for the entanglement among switches. The entangled quantum state shared between a quantum user pair can support teleportation which is a quantum opera tion to secretly transfer a quantum state from one processor to another processor. The transmitted quantum information can be either a single qubit [24] or a GHZ state [25]. III. Q UANTUM NETWORK MODEL In this section, we will introduce the quantum network model based on facts from practical physical experiments, and related studies about quantum entanglement routing to reflect practical quantum networks. A. Network Component We consider a general network topology where switches takenfusion entanglementswapping for the entanglement. We first introduce four main components of the quantum network. 1. Quantumusers. A quantumuser is a quantum processor that tries to establish entanglement with other processors by sharing the same quantum state. The processor includes two sets of qubits: one set for performing quantum computing tasks and the other for communication, specifically for entangling with other quantumusers through swapping. In this paper, we consider a scenario where a quantum state can only be shared between two quantumusers, enabling them to perform teleportation. There are multiple quantumuser pairs in the network. Each quantumuser can use different qubits to en tangle with different quantumusers simultaneously. However, each qubit of a quantumuser can only at most be involved in one quantum state. The set of quantumusers is denoted as U={ui}U i=1. 2. Quantum switches. Quantum switches are quantum processors that work as relays to support remote entanglement through entanglementswapping. Unlike quantumusers, which have both computing and communication qubits, quantum switches only have qubits for communication and are used solely for entanglementswapping. The set of switches is de noted as V={vi}V i=1. In this model, we assume that switches are capable of performing up to cvqubit GHZ measurement, where cvis the number of qubits in the solid memory of switch v∈ V. Additionally, the switches are equipped with traditional computing and communication devices, allowing them to communicate with one another via optical fibers and perform traditional computing tasks. 3. Quantum links. The quantum link over the optical fiber connects two switches to support the entanglement. If the quantum link is successfully established, the neighboring switches share a Bell pair|00⟩+|11⟩√ 2. The successful entan glement probability over the quantum link is determined by the link length and the physical material of the optical fiber, represented by p=e−αL, where αis a constant dependent on the physical material and Lis the length the quantum link between switches. The network is abstracted as an undirected graph, denoted as G= (V,E), where V={U ∪ V} denotesthe set of quantum switches and quantum users. Let eijdenote the edge between switches or users vi∈Vandvj∈V, and E={eij} ⊂ { (vi, vj) : vi, vj∈V}denote the set of edges. Since several optical fiber cables can be placed between switches and each cable has independent cores that can be used as quantum links, there could be multiple quantum links over the same edge for one quantum state. These quantum links for one quantum state are referred to as a quantum channel. Additionally, multiple quantum channels for different quantum states can coexist on the same edge. The optical fibers can also be used to transmit traditional information over the network, i.e., an ebit that presents 0 or 1. 4. A center server for traditional computing and communication The center server plays a crucial role in maintaining network information such as network topology, connections, etc., and relaying information to the switches. The communication process between the center server and the switches may operate in an honestbutcurious manner, meaning that the server will not have access to the content of the communication. The center server will also perform computational tasks to support the entanglement process, such as precalculating routes for quantumuser pairs. Network topology. We model a quantum network with Uquantumusers and Vswitches as an undirected graph G= (V,E), where V={U ∪V} , andE={eij} ⊂ { (vi, vj) : vi, vj∈V}denotes the set of the quantum links. The topology of the graph is arbitrary. Figure 3 shows an example of the proposed quantum network. The topology of the quantum network is relatively stable, with network information being readily available to all switches. Fig. 3. An Example of Network. B. Entanglement Process In this model, we briefly outline the entanglement process in which switches utilize nfusion entanglementswapping. Phase I is to design detailed routes for the entanglement. The routes are computed by classic computing devices in the center server since the computing time for tasks such as routing problems is currently still much shorter in the classical computing domain than in the quantum domain. The center server uses the available network information, including quantum states to be shared for quantumuser pairs,network topology (switch placement and connections), and switch information (the number of qubits in each processor), to design the routes. Phase II is the preparation phase for the entanglement. The network sends designed routes to switches. All switches will be timesynchronized to ensure that all links are available simultaneously for the selected paths. Phase III is to take entanglement. First, the network at tempts to generate quantum entanglement over the quantum links based on the fixed routing paths calculated in Phase I. Second, switches take entanglementswapping operations to fuse successful entanglement links for the entanglement. C. Routing Matrices We define the entanglement rate as the expected number of quantum states (including Bell states and GHZ states) shared between quantumuser pairs in the quantum network under nfusion to quantify the performance. Entanglement rate of a quantum channel. Given two neighboring switches vi, vj, let wdenote the width of the quantum channel which indicates the number of parallel quantum links placed between two switches for one quantum state to be shared. As shown in Figure 4, the width of the edge between Alice and Carol is 2. The entanglement rate between two adjacent switches equals the probability to build at least one successful entanglement link for a quantum state, i.e.,P= 1−(1−pij)w, where pij=e−αLijis the successful entanglement probability over a single link with the Euclidean length Lij. In Figure 4, let pdenote the successful entanglement probability of a single quantum link and all links have the same rate, then, the entanglement rate between Alice and Carol is 1−(1−p)2. Entanglement rate of a path. For a path A= {v1, v2,···, vl}, where ldenotes the distance of A(i.e., the number of edges), the entanglement rate for a quantum state is determined by the successful entanglementswapping probability of each switch in a path, and the entanglement rate of each edge. Formally, the entanglement rate of path A isPA= Πl−1 i=2qiΠl j=1Pj(j+1). In Figure 4, the entanglement rate of a path between Alice and Bob is (1−(1−p)2)pq, where qis the successful entanglementswapping probability of Carol to take nfusion to fuse three quantum links. Fig. 4. Entanglement example 1: a path. Qubits in black are entangled through red internal links in switches and orange links between switches. Entanglement rate of a flowlike graph. To generate a quantum state shared between a quantumuser pair, a flow like graph may be constructed, which is defined as follows: Definition 1. A flowlike graph is a symmetric flow graph connecting two quantumusers for one shared quantum state, which contains paths sharing overlapped nodes or edges. In a symmetric flow graph, the overlapped node contained by morethan one path for the same shared quantum state is called the branch node. Fig. 5. Entanglement example 2: two flowlike graphs for two shared quantum states between a quantumuser pair. qubits in green are entangled through red internal links in switches and gray links between switches. An example of flowlike graphs is shown in Figure 5. A switch as a branch node belongs to different paths simul taneously that connect two quantumusers for one quantum state, where each path leads to an independent direction for the entanglement. For example, switch 3 is a branch node that has two paths for one shared state whose qubits are in black; but switch 4 is not a branch node even if it belongs to two paths because two paths belong to two different shared quantum states. For any two different quantum states between the same quantumuser pair, their flowlike graphs do not share any quantum links including internal links within switches and links between switches on the edge. Calculating the entanglement rate for a shared quantum state in a flowlike graph requires traversing every branch node and every path through every branch node. The calculation process starts with one quantumuser traversing all edges and switches one by one. Let ˆG={U1, U2, ϱ}denote a flowlike graph between quantumuser U1andU2for sharing the quantum state ϱ. We assume that user U1is the root node. Starting from user U1, neighboring nodes of user U1along the direction from user U1to user U2are called child nodes. Every child node of node Ahas its own child nodes. P{a,b,ϱ}represents the entanglement rate from node ato node bforϱ. When we fix quantum state ϱ, the notation is shortened as Pa,b, where node aand node bare two nodes in ˆG={U1, U2, ϱ}and node ais has a shorter distance to user U1compared with node b.Fa,bdenotes the set of all paths starting from node a and ending at node binˆG={U1, U2, ϱ}.Cadenotes the set of all child nodes of node ain a symmetric flow graph. Then the entanglement rate of ˆG={U1, U2, ϱ}can be computed via a recursive process: P{U1,U2}= 1−Y u∈CU1"
291,Compact Oblivious Routing.txt,"Oblivious routing is an attractive paradigm for large distributed systems in
which centralized control and frequent reconfigurations are infeasible or
undesired (e.g., costly). Over the last almost 20 years, much progress has been
made in devising oblivious routing schemes that guarantee close to optimal load
and also algorithms for constructing such schemes efficiently have been
designed. However, a common drawback of existing oblivious routing schemes is
that they are not compact: they require large routing tables (of polynomial
size), which does not scale.
  This paper presents the first oblivious routing scheme which guarantees close
to optimal load and is compact at the same time -- requiring routing tables of
polylogarithmic size. Our algorithm maintains the polynomial runtime and
polylogarithmic competitive ratio of existing algorithms, and is hence
particularly well-suited for emerging large-scale networks.","1.1 Motivation With the increasing scale and dynamics of large networked sy stems, observing and reacting to changes in the workload and reconﬁguring the routing accord ingly becomes more and more dif ﬁcult. Not only does a larger network and more dynamic worklo ad require more ﬁnegrained monitoring and control (which both introduce overheads), a lso the process of rerouting traﬃc itself (see e.g. [12]) can lead to temporary performance deg radation and transient inconsistencies. Oblivious routing provides an attractive alternative whic h avoids these reconﬁguration overheads while being competitive , i.e., while guaranteeing route allocations which are almo st as good as adaptive solutions. It is hence not surprising that oblivio us routing has received much attention over the last two decades. Indeed, today, we have a good under standing of fast (i.e., polynomial time) and “competitive” oblivious routing algorithms (ach ieving a polylogarithmic approximation of the load, which is optimal). However, while oblivious routing seems to be the perfect par adigm for emerging large networked systems, there is a ﬂy in the ointment. Oblivious routing alg orithms require large routing tables: namely polynomial in the network size. This is problematic, as fast memory in ro uters is expensive, not only in terms of monetary costs but also in terms of power c onsumption. The goal of this paper is to design oblivious routing schemes which only require small routing tables (which are compact ), and that at the same time still guarantee a closetooptim al load.1.2 The Problem in a Nutshell The network is given as an undirected graph G= (V, E) with nvertices. The edges Eare weighted by a capacity function cap : V×V→R+ 0; if{x, y} ∈E, the function returns 0, otherwise a positive value. Theoblivious routing problem is to set up a unit ﬂow for each sourcetarget pair ( s, t)∈V×Vthat determines how demand between sandtis routed in the network G. This unit ﬂow is prespeciﬁed without knowing the actual demands. When a demand vector /vectordis given that speciﬁes for each pair of vertices the amount of traﬃc to be sent, the demandvector is routed by simply scaling the unit ﬂow between a pair ( s, t) by the corresponding demand dstbetween the two vertices. This means that traﬃc is routed along precomputed paths and that no pathselection is done dynamically. The congestion Cobl(G,/vectord) resulting from a given oblivious routing scheme, is then co mpared to the optimal possible congestion Copt(G,/vectord) that can be obtained for demand vector /vectordinG. The competitive ratio of the oblivious routing scheme is deﬁned as max /vectordCobl(G,/vectord) Copt(G,/vectord) In this paper, we are mainly interested in compact solutions which minimize the number of required forwarding rules. We say that an oblivious routing scheme is compact if the number of rules required for a vertex vis in O(polylog( n)·∆), where nis the number of vertices in the network and ∆ the maximal vertex degree of G. In other words, a polylogarithmic number of rules are required per link . In addition to the competitive ratio, the runtime, and the t able size, we are also interested in the required vertex labels (i.e., their s ize) and the required packet header size. 1.3 Our Contributions This paper presents the ﬁrst compact oblivious routing scheme. Our approach builds upon an oblivious path selection scheme based on classic decomposi tion trees, which is then adapted to improve scalability, and in particular, to ensure small rou ting tables and message headers, while preserving polynomial runtime and a polylogarithmic compe titive ratio. We present two diﬀerent implementations of our approach and our results come in two diﬀerent ﬂavors accordingly (more detailed theorems will follow): Theorem 1. There exist polynomialtime algorithms which achieve a pol ylogarithmic competitive ratio w.r.t. the congestion and require routing tables of po lylogarithmic size for 1. networks with arbitrary edge capacities which have a deco mposition tree of bounded degree, and for 2. arbitrary networks with uniform edge capacities. Our algorithms only require small (polylogarithmic) heade r sizes and vertex labels. Networks for which there are decomposition trees of small de gree include for example (constant degree) grids or graphs that exclude a minor of constant size . The exact requirements that a decomposition tree has to fulﬁll will be given later. 12 Algorithm and Analysis This section describes an oblivious path selection scheme f or general undirected networks that obtains close to optimal congestion and can be implemented w ith routing tables and routing headers of small size. In a nutshell, our algorithm leverages a path s election scheme for general networks that guarantees a good competitive ratio w.r.t. congestion , and then adapts it so that it can be implemented with small space requirements. We discuss the t wo phases of this algorithm in turn. 2.1 Oblivious Path Selection Scheme There exist essentially two path selection schemes that cou ld be used as a basis for our approach. First, there is the original result by Räcke [30] who showed t hat oblivious routing with a polyloga rithmic competitive ratio is possible in general networks, using a hierarchical path selection scheme (cf. Section 2.1) that guarantees a competitive ratio of O(log3n). Second, we could use the result by Räcke et al. [33] that computes a hierarchical decompositio n in nearly linear time, which also gives a hierarchical path selection scheme albeit with weaker par ameters than [30]. The result in [30] has been improved to a competitive ratio of O(logn) with a diﬀerent scheme in [31]. The latter scheme can be roughly viewed as a convex combination of spanning tre es1A path between a vertex sand a vertex tis chosen by sampling a random spanning tree and then choosin g the path between s andtin this tree. In this paper, we will build upon the original result [30] whi ch we call the hierarchical path selection scheme . The challenge with implementing the path selection mechan ism in [33, 31] space eﬃciently is that the number of spanning trees is quite large (polynomial in n). It seems diﬃcult to avoid that a vertex in the graph has to store some information for every tree, which yields routing tables of polynomial size. The hierarchical path selection scheme is based on a hierarc hical decomposition of the graph G= (V, E). The vertex set Vis recursively partitioned into smaller and smaller pieces until all pieces contain just single vertices of G. We will refer to the pieces/subsets arising during this partitioning process as clusters . To such a recursive partitioning corresponds a decompositi on tree T= (VT, ET). A vertex xin this tree corresponds to cluster Vx⊆Vand there is an edge between a parent node pand a child node cif the cluster Vcarises from partitioning Vp. The root rofTcorresponds to the subset Vr=Vand the leaf vertices correspond to singleton sets {v}, v∈V. In order to simplify the notation and description we assume t hat all leaf vertices in Thave the same distance to the root (this could e.g., be achieved by int roducing dummy partitioning steps in which a set is partitioned into itself). We use hto denote the height of the tree. Let for a vertex v∈V,aℓ(v) denote the ancestor of {v}on level ℓof the tree, where the level of a vertex is its distance from the root. Here we use {v}as a shorthand for “the leaf node that corresponds to cluster {v}” . The ℓweight of vis the weight of all edges incident to vthat leave the cluster Vaℓ(v). Formally wℓ(v) :=/summationtext e={v,x}:x/∈Vaℓ(v)cap(e). We extend this deﬁnition to subsets of Vby setting wℓ(U) :=/summationtext u∈Uwℓ(u) for every subset U⊆V. We also introduce for every cluster Sin the decomposition tree a weight function wS:S/ma√sto→R+ 0 and a weight function out S:S/ma√sto→R+ 0. For a level ℓcluster Swe deﬁne wS:=wℓ+1↾Sand outS:=wℓ↾S. Note that out Scounts edges that connect vertices of Sto vertices outside of Swhile wSalso counts edges that connect diﬀerent subclusters of S. We refer to wSas the clusterweight ofSand to out Sas the borderweight ofS. 1This is not entirely correct as the trees are not proper spann ing trees but the diﬀerence is not important for the above discussion. 2Using this weight deﬁnition, we deﬁne a concurrent multicommodity ﬂow problem (CMCF problem) for every cluster Sin the decomposition tree. For every (ordered) pair ( u, v) there is a demand of wS(u)wS(v)/wS(S). Informally speaking, this means that every vertex inject s a total ﬂow that is equal to its wSweight and distributes this ﬂow to the other vertices in S, proportionally to the wSweight of these vertices. We will use the decomposition tre eTin [30] with the following properties: •the height of TisO(logn), and •for every cluster Sin the decomposition tree, the CMCFproblem for Scan be solved with congestion at most C=O(log2n)inside S. Now suppose that we are given a decomposition tree with these properties. The path selection in [30] is then performed as follows. Suppose that we want to c hoose a path between vertices sand tinG. Let xsandxtdenote the leaf vertices in Tthat correspond to singleton clusters {s}and{t}, respectively. Let xs=x1, x2, . . . , x k=xtdenote the vertices in the tree on the path from xstoxt. We ﬁrst choose a random vertex vifrom each cluster Vxiaccording to the clusterweight, i.e., the probability that vis chosen is wVxi(v)/wVxi(Vxi). Note that v1=sandvk=tas the corresponding clusters just contain a single vertex. It remains to select a path that connects the chosen vertices. Suppose we want to connect two consecutive vertices vpandvc, where Vxpis the parent cluster ofVxc. We choose an intermediate vertex αinside Vxcaccording to the borderweight of Vxc, i.e., the probability that vis chosen is out Vxc(v)/outVxc(Vxc). We then consider the solution to the CMCFﬂow problems for VxcandVxp. The ﬁrst solution contains a ﬂow f(c, α) between vxcand α, and the second contains a ﬂow f(p, α) between vxpandα. We sample a random path from each ﬂow. Concatenating these two paths, gives a ﬂow between vcandvp. For the following analysis we call the subpath between xcandαthelower subpath and the path between αandxptheupper subpath . Concatenating all vertices viin the above manner gives a path between xsandxt. In the following we analyze the expected load generated on an edge due to this p ath selection scheme under the condition that an optimal algorithm can route the demand wit h congestion Copt. For completeness and as we will need to modify this proof later, we repeat the fo llowing observations from [30]. Lemma 2. The expected load on an edge is at most O(h·C·Copt). Proof. Fix an edge efor which both endpoints are contained in some cluster S. Let S1,. . . ,Sr denote the childclusters of S. We ﬁrst analyze the total demand that we have to route betwee n a pair of vertices ( a, b)∈S×Sdue to an upper subpath where ais chosen as the intermediate vertex αandbis chosen as a random vertex from the parent cluster S. Assume a∈Sifor some child cluster Si. Then the probability that we choose aasαis Pr[ ais chosen] = out Si(a)/outSi(Si). The probability that we choose bas the random endpoint in Sis Pr[ bis chosen] = wS(b)/wS(S). Note that any message for which we route between the child clu sterSiand the parent cluster S has to leave or enter the cluster Si. Therefore the total demand for these messages can be at most Copt·outSi(Si), as otw. an optimum congestion of Coptwould not be possible. Hence, the expected demand for pair aandbis only outSi(Si)Copt·Pr[ais chosen] ·Pr[bis chosen] = out Si(Si)Copt·outSi(a) outSi(Si)·wS(b) wS(S) =wS(a)·wS(b) wS(S)·Copt,(1) where we used the fact that out Si(a) =wS(a), which holds since Siis a direct childcluster of S. 3Now we analyze the demand that is induced for a pair ( a, b)∈S×Sdue to the lower part of a message between Sand its parent cluster. We assume that ais chosen as the intermediate vertex αandbis chosen as a random node in the childcluster S. The probability that ais chosen as intermediate vertex is Pr[ ais chosen] = out S(a)/outS(S) and the probability that bis chosen is Pr[bis chosen] = wS(b)/wS(S). Every such message has either to leave or enter cluster S. Hence, the total demand for these messages induced on pair ( a, b) is at most outS(S)Copt·Pr[ais chosen] ·Pr[bis chosen] = out S(S)Copt·outS(a) outS(S)·wS(b) wS(S) ≤wS(a)·wS(b) wS(S)·Copt,(2) where we used the fact that out S(a)≤wS(a). Combining Equation 1 and Equation 2 gives that the messages i nvolving cluster Sinduce a demand of only 2 wS(a)·wS(b)/wS(S)·Coptbetween vertices aandbfrom S. Since we route this demand according to the multicommodity ﬂow solution of the C MCFproblem for cluster S, the resulting load is at most 2 C·Copton any edge inside cluster S, while edges not in Shave a load of zero. Summing the load induced by messages for all clusters a nd exploiting the fact that an edge is at most contained in hdiﬀerent clusters, gives a maximum load of 2 hC·Copt, i.e., a competitive ratio of 2 hC. 2.2 Implementation A: Decomposition Trees with Small Degre e We now present a space eﬃcient implementation of the above pa th selection scheme. In the following, we will assume that the maximum degree of the decomposition t reeTis small. The basic building block for our implementation is a method t hat given a random starting point v∈Schosen according to the clusterweight of S(i.e., the probability of choosing viswS(v)/wS(S)), routes to a random node vi∈Sichosen according to the border weight of Si. Here Siis either a childcluster of S(in case we want to communicate downwards in the tree) or Si=S(in case we want to communicate upwards). In the following we use Si, i∈ {1, . . . , r }to denote the child clusters of SandS0=Sto denote Sitself. Let G[S] denote the subgraph induced by vertices in S. For every i∈ {0, . . . , r }we compute a single commodity ﬂow fiinG[S] as follows. We add a supersource sand connect it to every vertex v∈Swith an edge of capacity wS(v)·outSi(Si) and a supertarget tto which every vertex in v∈Sconnects with capacity out Si(v)·wS(S). Note that all source edges together have the same capacity as the targe t edges. We compute a maximum stﬂow in G[S] after scaling the capacities of edges in G[S] up by wS(S)·C. This ﬂow will saturate edges from sand to tas these form the bottleneck in the network and, hence, it will have a value of wS(S)·outSi(Si). This follows from the fact that in G[S] (without scaling) every node can inject a ﬂow of out S(v)wS(S) and distribute it so that a node v′receives outS(v)wS(v′) of this ﬂow and the congestion is only wS(S)·C. We store the ﬂow fiin a distributed manner at the vertices of S, as follows. Fix v∈S. For every edge we store how much ﬂow enters or leaves v. In order to route from the clusterdistribution ofSto the borderdistribution for Si,i∈ {0, . . . , r }, we choose random outgoing links (where a link is taken with probability proportional to the outgoion g ﬂow) until the chosen link is the super target t. When we want to route from the borderdistribution of sito the clusterdistribution of S, we take random incoming links (where a link is chosen with pr obability proportional to the incoming ﬂow), until the chosen link corresponds to the supe rsource s. The proof of the following claim is analogous to Lemma 2. 4Claim 3. The expected load of an edge due to the path selection scheme i s only O(h·deg(T)·C·Copt). Proof. Suppose that the optimum congestion is Copt. The total traﬃc that the scheme has to route between the clusterdistribution of Sand the borderdistribution of Siis only out Si(Si)·Copt. We route this traﬃc according to ﬂow fiof value out Si(Si)wS(S). Hence, the maximum load of an edge in G[S] (according to original capacity) is C·Copt. Since a cluster Smay have deg( T) many ﬂows fiand an edge is contained in hdiﬀerent clusters the claim follows. Claim 4. The path selection scheme can be implemented with routing ta bles of size O(deg( v) deg( T)(log m+ log W)), labels of length O(hlog(deg( T))), and header length O(hlog(deg( T))). Proof. Since the capacities in the ﬂow problem for fiare all integral, the ﬂow solution will be integral [13]. Suppose that the original capacities of the g raph are integers in the range {1, . . . , W }. After scaling the capacity of graph edges in G[S], these have a capacity of at most wS(S)·W·C (note that we assume that Cis integral). Edges from sand to thave a capacity of wS(v) out Si(Si) andwS(S) out Si(v), respectively. Using the fact that wS(S) and out Si(Si) are at most mW, and d, C≤mwe get that a number describing the ﬂow value along an edge can be encoded with log2(m2W2) =O(log(m) + log( W)) many bits. Hence, a node vhas to store only O(deg( v) deg( T)(log m+ log W)) many bits. For the routing scheme we relabel the vertices. We number the children of a vertex in the tree and encode a leaf vertex by its path from the root. This genera tes labels of O(hlog(deg( T))) bits. The routing algorithm now only needs to have the label of the s ource vertex and the target vertex and a marker that marks where in the tree the routing currentl y is. In summary, and leveraging the decomposition tree, we have d erived the following result: Theorem 5 (Decomposition Trees of Small Degree) .For decomposition trees of constant degree, there exists a polynomialtime algorithm which achieves a c ompetitive ratio of O(log3n), requires routing tables of size O(deg( v) deg( T)(log m+log W)), labels of length O(hlog(deg( T))), and header sizes of O(hlog(deg( T))). 2.3 Implementation B: Uniform Capacities In this section we present a diﬀerent implementation of the h ierarchical routing scheme, for scenarios where the decomposition trees can be of arbitrary degree but where network capacities are uniform. Again the basic building block is to route from a node chosen a ccording to the clusterdistribution of some cluster Sto the border distribution of Siwhere either Si=SorSiis a childcluster of S. Assume that every edge in the graph Ghas capacity 1. We round the outgoing capacity out Si(Si) of a childcluster Si,i≥0 to the next larger power of 2 and denote the rounded value wit h/bar⌈blSi/bar⌈bl. We also reorder the children w.r.t. this value, i.e., S1is the childcluster with smallest /bar⌈blSi/bar⌈blvalue. Since there are at most mpossible values for out Si(Si), there are only log mpossible values for /bar⌈blSi/bar⌈bl. There are only/parenleftbigr+log m logm/parenrightbigpossibilities to choose the /bar⌈blSi/bar⌈blvalues of the rchildren of cluster S. Hence, we can store these with O(log(m)·log(r)) many bits. In addition we store the value of /bar⌈blS0/bar⌈bl, which requires O(log log m) bits, and the value of wS(S) which requires O(logm) bits. In order to design the routing scheme for an individual clust er, we embed a hypercube of di mension d:=⌈log2(/summationtext i≥0/bar⌈blSi/bar⌈bl)⌉. We ﬁrst order the hypercube nodes in an arbitrary way and the n 5reserve a (ith) range of/bar⌈blSi/bar⌈blconsecutive hypercube nodes for every i≥0. Note that we store the (rounded) size of all children and that it is straightforwar d to compute the ranges assigned to any ifrom this information. Then we map the hypercube nodes to nodes of S. First we map hypercube nodes in the ith range to nodes with out Si(v)>0 such that each node receives at least out Si(v) and at most 2 out Si(v) hypercube nodes. Hypercube nodes that remain unmapped afte r this step (i.e., nodes that do not fall within any range) are mapped arbitrarily subject to the constraint that a cluster node v does not receive more than 4 wS(v) hypercube nodes. This can easily be done as the number of hypercube nodes (2d) is at most 4/summationtext i/summationtext v∈SioutSi(v) = 4( wS(S) + out S(S))≤8wS(S). Observation 6. There are at most 8wS(v)hypercube nodes mapped to any graph node. For the embedding we set up a concurrent multicommodity ﬂow p roblem as follows. For every edge {x, y}of the hypercube that is mapped to endpoints {vx, vy}, we introduce a demand of 1 between vxandvyin both directions. Then every node sends and receives a tota l traﬃc of at most 8d·wS(v). By adding fake traﬃc we can turn this instance into a balanc ed multicommodity ﬂow instance in which every vertex sends and receives a traﬃc of e xactly 8 d·wS(v). We can solve this multicommodity ﬂow instance with congesti on at most 16 dCinside the cluster Sby using Valiant’s trick [36, 23] of sending to random interm ediate destinations and using the fact that each ﬂow can send a traﬃc of wS(v) to random destinations with congestion C. 2.3.1 Using the Hypercube How do we exploit the embedded hypercube? If during the routi ng scheme we are required to send a message from a cluster node vpto a cluster node vc∈Siwe proceed as follows. Instead of choosing an intermediate node αaccording to probability distribution out Si(v)/outSi(Si) we choose a random hypercube node from the ith range. Then we route a message inside the hypercube to this node. For this we let the message start at a random hyperc ube node from the nodes that are mapped to vp. Note that this means that the probability that the message is sent to node αlies between outSi(α)//bar⌈blSi/bar⌈bland 2 out Si(v)//bar⌈blSi/bar⌈blas the hypercube nodes in the ith range are not mapped com pletely uniformly. For the second part of the message we proceed analogously in t he hypercube of Si. We let the message start at a random hypercube node mapped to αand choose a random hypercube node as its target. Again due to the nonuniform mapping, the target distributi on on Si(i.e., wSi(v)/wSi(Si)) is not reached exactly, but deviations by a constant factor might o ccur. This only inﬂuences the congestion of a single step by a constant factor, but it could be problema tic if we used this approach along a path in the tree: in each step the distribution would change b y a constant factor. Therefore, we add an additional step that ﬁxes the distribut ion over Si. We embed an additional hypercube HSfor every cluster Swith dimension ⌈log2(wS(S))⌉. The mapping is done such that each clustervertex v∈Sreceives exactly wS(v) hypercube nodes among the ﬁrst wS(S) nodes from HS(the remaining nodes are distributed uniformly). Since eve ry node in the cluster Sstores the value of wS(S), we can route from a node v∈Sto a random node chosen according to distribution wS(v)/wS(S), by just selecting a random hypercube node from the ﬁrst wS(S) nodes. 2.3.2 Analysis We showed that the congestion for submessages that involve cluster Sis small. There are two types of such messages: 61. messages that start at an intermediate node (distributed according to the border weight of Sifor some i≥0) and are sent to a random node v∈Sdistributed according to the cluster weight of S; and 2. messages that start at a random node v∈Sand are sent to some intermediate node. It was shown that the total traﬃc that is sent between a pair viandv, where vis distributed according to the cluster weight of Sandviis distributed according to the border weight of Si, is only out Si(vi)wS(v)/wS(S)·Copt. In our new scheme this changes slightly. For messages of the s econd type the source is distributed as before but the target may have a slightly diﬀerent distrib ution (as we choose a random hypercube node in the ith range). For messages of the ﬁrst type already the source m ay have a slightly diﬀerent distribution (as we choose a random hypercube node from some range in the hypercube for a child or parentcluster). Also the target distribution is slight ly skewed as we choose a random hypercube node as the target. But since the distributions are only changed by a constant fa ctor this diﬀerence does not re ally inﬂuence our analysis. We still have the property that t he traﬃc between viand vSis Θ(out Si(vi)wS(v)/wS(S)·Copt). The second diﬀerence is that the traﬃc is not sent according t o the CMCFproblem for cluster Sbut it is instead sent along the hypercube. Note that due to th e embedding of the hypercube, a cluster node v∈Sihas Θ(out Si(v)) = Θ( wS(v)) hypercube nodes in the ith range mapped to it (i.e., hypercube nodes are balanced perfectly up to constan t factors). Hence the demand between viandvwill be split among Θ(out Si(vi)wS(v)) pairs in the cube. Therefore the demand for every pair in the cube is only Θ( Copt/wS(S)) = Θ( Copt/2d). This means that at most a traﬃc of O(Copt) starts and ends at every vertex and routing this traﬃc using V aliant’s trick gives a congestion ofO(dCopt) in the hypercube. Since we embedded the hypercube with cong estion O(dC), the congestion of a graph edge will be O(d2C·Copt) (as each hypercube node has degree d), which gives rise to the following lemma. Lemma 7. Implementation B guarantees a maximum expected load of O(hd2C·Copt). Proof. The lemma follows by applying the previous argument for each level of the tree. It remains to bound the edgeload induced by the rerandomiz ation steps. The total traﬃc that is send to a cluster Sin the tree is at most (/summationtext iout(Si))·Copt= Θ( wS(S)·Copt). For each such message we require a rerandomization, because in our c urrent scheme, it is only distributed approximately according to the clusterweight of S. However by design each vertex receives exactly a wS(v)/wS(S)fraction of the rerandomization messages, and a Θ( wS(v)/wS(S))fraction of messages start at v, since the messages are approxi mately distributed according to clusterweight. Sending t hese messages along the hypercube intro duces congestion Θ( d·Copt) in the cube and Θ( d2C·Copt) due to the embedding. Lemma 8. Implementation B requires space O(hClog(m) log log( m) deg( v))bits at every vertex and a label and header length of O(hlog(deg( T))). Proof. A vertex v∈Shas to store the approximate size /bar⌈blSi/bar⌈blof the childclusters of S. Summing this over all levels gives O(hlog(m)·log(r)) bits. In addition one has to encode the embedding of the hypercubes. The congestion of the solution to the concur rent multicommodity ﬂow problem for embedding a hypercube is O(dC). This fractional solution will encode a ﬂow for every hyper cube edge. Using a standard randomized rounding approach, we can route the ﬂows to paths with a congestion of O(dC+ log( m)) = O(dC). This is done as follows. For every pair {x, y}we take the 7unit ﬂow and ﬁrst decompose this unit ﬂow into ﬂowpaths. The n we choose for every pair one of the ﬂowpaths at random (proportional to its weight). Let Xi(e) denote the random variable that describes whether the ﬂow path for the ith pair includes edge e. By design the above process guarantees E[Xi(e)] = fi(e), where fi(e) is the ﬂow for pair ithat goes through edge e. The total load on edge eis/summationtext iXi(e). This is a sum of negatively correlated random variables wi th expectation µ=O(dC). Using Lemma 10 (in the appendix) with δ= 3 ln( m)/µgives that with constant probability, no edge exceeds load O(dC+ log m). Therefore only O(deg( v)dC) paths traverse a vertex v(recall that C≥logm). For every path, we need to store the outgoing edge and the id of the paths on this edge. This requires (log2(deg( v))+log2(dC)) bits for every path and O(ddeg(v)Clog(ddeg(v)C)) bits in total. Multiply ing with the height and using d= Θ(log m) gives O(hlog(m)·(log(deg( T)+deg( v)Clog log( m))) = O(hClog(m) log log( m) deg( v)) bits. The header and labellength is analogous to Implementatio n A. We just use the roottoleaf path in the tree as a label and a header consists of the sourcelabe l, the targetlabel, and a marker. In summary we derived the following result: Theorem 9 (Compact Oblivious Routing for Uniform Capacities) .For arbitrary networks of uniform capacities, there exists a polynomialtime oblivi ous routing algorithm which is O(log3n) competitive, and which requires O(hClog(m) log log( m) deg( v))bits at every vertex and a label and header length of O(hlog(deg( T))). 3 Related Work "
232,Anarchy in Tor: Performance Cost of Decentralization.txt,"Like many routing protocols, the Tor anonymity network has decentralized path
selection, in clients locally and independently choose paths. As a result,
network resources may be left idle, leaving the system in a suboptimal state.
This is referred to as the price of anarchy, where agents acting in their own
self interest can make poor decisions when viewed in a global context. In this
paper we explore the cost of anarchy in Tor by examining the potential
performance increases that can be gained by centrally optimizing circuit and
relay selection using global knowledge. In experiments with both offline and
online algorithms, we show that centrally coordinated clients can achieve up to
75% higher bandwidth compared to traditional Tor. Drawing on these findings, we
design and evaluate a decentralized version of our online algorithm, in which
relays locally distribute information enabling clients to make smarter
decisions locally and perform downloads 10-60% faster. Finally, we perform a
privacy analysis of the decentralized algorithm against a passive and active
adversary trying to reduce anonymity of clients and increase their view of the
Tor network. We conclude that this decentralized algorithm does not enable new
attacks, while providing significantly higher performance.","Tor [7] is one of the most popular and widely used low latency anonymity systems, with 2 million daily clients supported by a network of over 6000 volunteer relays. Tor clients tunnel traﬃc through a sequence of 3 relays called acircuit. Traﬃc sent over the circuit is encrypted so that no single relay can learn the identity of both the client and destination. With a limited amount of re sources available from the volunteer relays, it is impor tant to distribute traﬃc to utilize these resources as ef ﬁciently as possible. Doing so ensures high performance *Corresponding Author: John Geddes: University of Minnesota, Email: geddes@cs.umn.edu Mike Schliep: University of Minnesota, Email: schliep@cs.umn.edu Nicholas Hopper: University of Minnesota, Email: hop per@cs.umn.eduto latency sensitive applications and attracts potential clients to use the network, increasing anonymity for all users. Similar to ordinary routing, clients make decisions locally based on their view of the network. In Tor, direc tory authorities are centralized servers that keep track of all relays and their information. Clients download this information, stored in consensus ﬁles and server descriptors, every few hours from the directory author ities. With this information clients create 10 circuits to have available, selecting relays for the circuits at ran dom weighted by the relays bandwidth. When the client starts using Tor to send traﬃc, it then selects the circuit in best standing to use for the next 10 minutes. Since it can take the directory authority up to 24 hours to properly update relay information and distribute it to clients, much research has focused on how clients can make better decisions, such as considering latency [2] or relay congestion [37] when selecting relays and circuits. The main issue with leaving network decisions to clients is that local incentives can lead clients to make decisions that theybelieve will maximize their perfor mance, when actually these decisions result in a global suboptimal state with overall client performance suﬀer ing. In these situations it is common to compare what happens when decisions are made with global knowl edge. This can be achieved by centrally processing re quests as they are made, or performing decisions oﬄine when the entire set of requests is known a priori. The performance gap that results from using decentralized compared to centralized decision making is called the price of anarchy . While Tor clients are not necessarily selﬁsh, they are making local decisions without context of the state of the global network. In this paper we analyze the price of anarchy in the Tor network. We develop both oﬄine and online centralized algorithms that optimize relay and circuit selection decisions made by clients. Using the global view of all active circuits in the Tor network, thealgorithmsareabletomoreintelligentlyselectwhich circuits clients should use for each download they per form, resulting in signiﬁcant performance improvements to clients. While these are not necessarily protocols that should be run in practice, it allows us to bound the ac tual price of anarchy in Tor. This demonstrates the po tential improvements that better resource allocation in Tor could achieve. arXiv:1606.02385v2  [cs.CR]  13 Jun 2016Anarchy in Tor: Performance Cost of Decentralization 2 In this paper we make the following major contri butions: – Using a modiﬁed client model, we create a genetic algorithm to compute the optimal oﬄine circuit se lection for a given sequence of download requests. Since the algorithm is given access to the full se quence of requests before processing, this allows us toestablishtheoptimalperformanceforagivennet workandload.Thisservesasabaselineforthecom petitive analysis of other algorithms. – In addition, we develop an online centralized al gorithm that processes download requests serially. Based on a delayweighted capacity routing algo rithm the centralized circuit selection tries to avoid low bandwidth bottlenecks when assigning circuits to requests. – Using techniques from the centralized algorithm, we develop a decentralized algorithm that results in similar resource allocations, with relays releasing a smallamountofinformationtoallowclientstomake smarter circuit selection choices. – We perform privacy analysis on the decentralized circuit selection algorithm that considers both in formation that can be learned from a passive adver sary, and examines how an active adversary could attempt to abuse the algorithm to increase their view of the network. – All algorithms are analyzed in a large scale simu lated environment using the Shadow simulator [15]. This allows us to precisely compare the eﬀects and performance gains achieved across the diﬀerent cir cuit selection algorithms. 2 Background In this section we discuss some of the Tor architec ture, basics on how the clients operate and send data through the network, and related work on increasing performance in Tor. 2.1 Tor Architecture When a client ﬁrst joins the Tor network, it downloads a list of relays with their relevant information from a directory authority. The client then creates 10 circuits through a guard, middle, and exit relay. The relays used for each circuit are selected at random weighted bybandwidth. For each TCP connection the client wishes to make, Tor creates a streamwhich is then assigned to a circuit; each circuit will typically handle multiple streams concurrently. The Tor client will ﬁnd a viable circuit that can be used for the stream, which will be then be used for the next 10 minutes or until the circuit becomes unusable. Internal to the overlay network, relay pairs establish a single TLS connection for allcommunication between them. To send traﬃc through a circuit, data is packed into 512byte onioncrypted cells using secret keys ne gotiated with each relay during the circuit building pro cess. Once a relay has received a cell, it peels oﬀ its layer of encryption, ﬁnds the next relay on the circuit to send to, and places it on a circuit queue where it waits to be sent. After a cell has traversed the entire circuit, the exit recovers the initial data sent by the client and is forwarded to the end destination. 2.2 Related Work "
206,Analyzing Incentives for Protocol Compliance in Complex Domains: A Case Study of Introduction-Based Routing.txt,"Formal analyses of incentives for compliance with network protocols often
appeal to game-theoretic models and concepts. Applications of game-theoretic
analysis to network security have generally been limited to highly stylized
models, where simplified environments enable tractable study of key strategic
variables. We propose a simulation-based approach to game-theoretic analysis of
protocol compliance, for scenarios with large populations of agents and large
policy spaces. We define a general procedure for systematically exploring a
structured policy space, directed expressly to resolve the qualitative
classification of equilibrium behavior as compliant or non-compliant. The
techniques are illustrated and exercised through an extensive case study
analyzing compliance incentives for introduction-based routing. We find that
the benefits of complying with the protocol are particularly strong for nodes
subject to attack, and the overall compliance level achieved in equilibrium,
while not universal, is sufficient to support the desired security goals of the
protocol.","Michael P. Wellman, Tae Hyung Kim, and Quang Duong Computer Science & Engineering, University of Michigan June 4, 2013 Abstract Formal analyses of incentives for compliance with network protocols often appeal to game theoretic models and concepts. Applications of gametheoretic analysis to network security have generally been limited to highly stylized models, where simpliﬁed environments enable tractable study of key strategic variables. We propose a simulationbased approach to game theoretic analysis of protocol compliance, for scenarios with large populations of agents and large policy spaces. We deﬁne a general procedure for systematically exploring a structured policy space, directed expressly to resolve the qualitative classiﬁcation of equilibrium behavior as compliant or noncompliant. The techniques are illustrated and exercised through an exten sive case study analyzing compliance incentives for introductionbased routing. We ﬁnd that the beneﬁts of complying with the protocol are particularly strong for nodes subject to attack, and the overall compliance level achieved in equilibrium, while not universal, is sufﬁcient to support the desired security goals of the protocol. 1 Incentive Analysis of Network Protocol Compliance Designers of a network security protocol typically start from an interest in properties satisﬁed by a system assuming all participants comply with the protocol. This is often followed by consider ation of whether compliance can be imposed or enforced in some way, or more ﬂexibly whether autonomous agents would voluntarily comply, or whether they can be incentivized to do so. The behavior of interacting autonomous agents is the province of game theory , which provides a general mathematical framework for characterizing rational decisions in a multiagent environment [Leyton Brown and Shoham, 2008]. Solution concepts such as Nash equilibrium offer a basis for predicting what rational agents will do when faced with strategic decisions.1 Consider a system of Nagents, where agent ichooses a strategy sifrom a set of available strate giesS. (We do not need to assume symmetry, but do so now for descriptive simplicity.) A protocol Presented at the Twelfth Workshop on the Economics of Information Security , Washington, DC, June 2013. 1This is not to say that such predictions will be very accurate, nor even the best one can do. We consider equilibrium as a starting point, but advocate bringing in behavioral theories [Camerer, 2003] or indeed any other information that may be predictive for a particular scenario. To a large extent we cast our methods in terms of general solution concepts , so that they can be adapted to account for such information when it is available and formalizable in such terms. 1arXiv:1306.0388v1  [cs.GT]  3 Jun 2013can be deﬁned as a partition of Sinto the compliant strategies,SC, and the noncompliant strategies, SN.2A strategy proﬁle s= (s1;:::;sN)is compliant if siis inSCfor alli. More generally, we may characterize the level of compliance of a (mixed) proﬁle based on how many (in expectation) agents’ strategies are compliant. The straightforward way to address the compliance question for a particular environment is to solve the associated game with respect to some appropriate solution concept (e.g., equilibrium deﬁnition), and assess the (level of) compliance of solution proﬁles. Gametheoretic modeling has seen increasing application to problems in networking [Han et al., 2011, Srivastava et al., 2006] and security in particular [Grossklags et al., 2008, Roy et al., 2010, Vratonjic et al., 2010]. Some of this work addresses protocol compliance speciﬁcally, for exam ple, ˇCagalj et al. [2005] analyze incentives to comply with random packet deferment in CSMA/CA protocols. They conclude that selﬁsh nodes invariably violate the protocol in equilibrium, and pro pose methods to recover efﬁciency (essentially another level of protocol, for which compliance is an equilibrium) through enforceable cooperation among the violators. In this and other studies, the game model is necessarily a highly stylized version of the underlying network scenario. Well crafted stylized models can produce valid and valuable insights, but always raise questions about whether their implications hold for richer environments that would be intractable for gametheoretic analysis. Often, researchers further evaluate their results through simulation studies. For example, Vratonjic et al. [2012] model a contentmonetization game as a twoplayer interaction between a web publisher and user, and then evaluate the derived publisher strategy in simulation over a het erogeneous population of users. Combining gametheoretic analysis with simulation can especially increase conﬁdence when the simulation environment relaxes assumptions imposed for tractability in the gametheoretic model, as in the analysis by Chen and Leneutre [2007] of wireless networks where nodes may tamper with contention windows. For many network security protocols, it is not apparent how to deﬁne stylized environments that faithfully capture incentive issues of interest yet support tractable gametheoretic treatments. For example, the set Sof possible strategies may be too large (e.g., highly dimensional), or the scenarios as most naturally deﬁned may include too many players, or excessively complex dynamics and information structures. Hope always remains for clever modeling or algorithmic ideas to get beyond such obstacles, but in the meantime it is inappropriate to avoid systematic analysis of incentives in these domains. We therefore pursue a simulation approach, not as mere adjunct of gametheoretic analysis, but as a means to gametheoretic modeling. The basic idea is to explore a restricted space of heuristic strategies, employing simulation to estimate payoffs that can then be incorporated in a game model. Because the search is (purposely) restricted, this technique should not be expected to precisely characterize solutions to the underlying game. For the question at hand—protocol compliance— however, we are not necessarily interested in characterizing exactly what the participating agents will do. Rather, we ask the coarser question of whether their behavior is consistent with the speciﬁed protocol. The novel methodological contribution of this work is a procedure that directs exploration of strategy space toward answering this compliance incentive question. The application driving our development of the procedure is a network protocol, introduction based routing , designed to incentivize responsible management of connection paths [Frazier et al., 2011]. We brieﬂy describe this protocol in the next section. Section 3 follows with a detailed de scription of our empirical gametheoretic methods for analyzing protocol compliance in complex 2Our search procedure generalizes this to consider compliance a matter of degree, but we adopt the binary distinction here to simplify the motivating discussion. 2domains. The results of applying these methods to the casestudy domain are presented in Sec tion 4. Our study provides evidence for substantial but not universal compliance with the protocol in equilibrium. The analysis further suggests that whereas the realized compliance level is sufﬁcient to support the basic security goals of the protocol in these scenarios, additional incentives applied to nodes not directly subject to attack could improve overall compliance signiﬁcantly. 2 Case Study: IntroductionBased Routing The introductionbased routing (IBR) protocol represents a promising approach to deterring ma licious behavior on networks [Frazier et al., 2011]. By requiring an explicit connection before transmitting a message, IBR participants exert enhanced control over network activity. New con nections are formed exclusively through introduction by parties with existing connections to the requested endpoints, ensuring that there is a trail of responsibility behind every decision to accept a new communication partner. Ensuring quality connections requires that participants pay attention to evidence of misbehavior, maintain reputation assessments for their connections, and propagate misbehavior reports throughout the network. The protocol does not employ any form of global rep utation mechanism, but rather relies on each node to maintain summary assessments of the nodes it has received information about. The goal of strategic analysis in this domain is to establish whether network participants have adequate incentive to follow the rules of the IBR protocol. Even if one accepts the security claims of IBR proponents, the question of individual beneﬁts to IBR compliance is an open question. An incentive analysis aims to determine whether or under what conditions nodes would indeed choose to comply, given full autonomy over that decision in service of their own interests. AlBayaty and Kreidl [2013] show, under certain assumptions on attacks and detection, that the optimal policy for deciding whether to close or continue a connection based on feedback reports takes the form of a reputation threshold policy, just as IBR dictates. This bolsters conﬁdence in compliance plausibility, but leaves open several modes by which individual nodes may still choose not to comply, for exam ple by failing to propagate attack information or indiscriminately introducing connections despite previous experience. Further modeling and analysis may illuminate the incentive tradeoffs for each element of the IBR policy, though this will likely prove tractable only for highly simpliﬁed network environments. As established through extensive simulation studies [Frazier et al., 2011], IBR networks are highly resistant to attack when all nonmalicious nodes follow the protocol. We seek to validate in these same rich simulation environments that following the protocol is a reasonable behavior to expect from these nodes. To do so, we ﬁrst need to deﬁne what it means to comply with the protocol. We start with the compliant policy recommended by the protocol designers, which includes a set of usermodiﬁable parameters, such as reputation thresholds for making and accepting introductions, thresholds for terminating existing connections, and amounts to increment or decrement reputations based on various forms of positive or negative feedback. Strategies in a speciﬁed region of this parameter space are classiﬁed as compliant (members of SC), and those outside the region are considered noncompliant ( SN). Whether IBR compliance is individually beneﬁcial clearly depends on the context of compliance decisions made by others. To reason about whether the IBR protocol is likely to be adopted by a community, the beneﬁts at any given level of compliance by others can help us assess the plausibility of alternate adoption paths. The game modeling approach pursued here can in principle provide a 3basis for reasoning not only about the existence of compliant equilibria, but also the dynamics of adoption that might lead to such equilibria. 3 Methods "
356,Assessing the Impact of Mobile Attackers on RPL-based Internet of Things.txt,"The Internet of Things (IoT) is becoming ubiquitous in our daily life. IoT
networks that are made up of devices low power, low memory, and low computing
capability appears in many applications such as healthcare, home, agriculture.
IPv6 Routing Protocol for Low Power and Lossy Network (RPL) has become a
standardized routing protocol for such low-power and lossy networks in IoT. RPL
establishes the best routes between devices according to the requirements of
the application, which is achieved by the Objective Function (OF). Even though
some security mechanisms are defined for external attackers in its RFC, RPL is
vulnerable to attacks coming from inside. Moreover, the same attacks could has
different impacts on networks with different OFs. Therefore, an analysis of
such attacks becomes important in order to develop suitable security solutions
for RPL. This study analyze RPL-specific attacks on networks using RPL's
default OFs, namely Objective Function Zero (OF0) and the Minimum Rank with
Hysteresis Objective Function (MRHOF). Moreover, mobile attackers could affect
more nodes in a network due to their mobility. While the security solutions
proposed in the literature assume that the network is static, this study takes
into account mobile attackers.","IoT has become one of the most revolutionary concepts of this century with the advancements in sensor and networking technologies. The adoption of the IPv6 protocol standard has led to the emergence of numerous IoT devices that are capable of communicating with each other and with remote machines through the Internet. It is estimated that total installed base of IoT devices will reach around 75 billion in 2025 [ 1]. IPconnected IoT devices have recently opened the door to the development of several lifeenhancing applications. These include healthcare monitoring, smart cities, transportation and logistics, military and defense, robots, and the like. Low Power and Lossy Networks (LLN) in IoT are characterized by high packet loss and low throughput. Due to the characteristics of LLN, traditional routing protocols, even those proposed for WSNs are not applicable to LLNs. Therefore, the Internet Engineering Task ForceRouting over LLN (IETFRoLL) group designed an IPv6based routing protocol speciﬁc for the LLNs: RPL, which operates on the IEEE 802.15.4 standard using IPv6 over Lowpower Wireless Personal Area Network (6LoWPAN) adaptation layer. RPL makes use of OF in order to build an optimal route between the IoT devices (or nodes) in the network. There are different routing metrics employed in OFs that play key role in selecting parent node and hence routes to the root nodearXiv:2303.16499v1  [cs.CR]  29 Mar 2023or destination nodes. These include Expected Transmission Count (ETX), hop count, energy, and the like [ 2]. There is no obligation to use a speciﬁc OF metric; it often depends on the requirements of IoT applications. The appropriate selection of OFs is very important because it signiﬁcantly affects the performance of the network including packet delivery ratio, endtoend delay, power consumption. Although various kinds of OFs have been proposed until far, OF0 and MRHOF are known as standard OFs deﬁned for the RPL. RPL ensures efﬁcient routing among IoT devices on LLN, and that’s why, it is adopted as the standard routing protocol today. However, there are a number of signiﬁcant challenges faced by RPL. The ﬁrst is that the RPL protocol is vulnerable to attacks (particularly to insider attacks) that aim to consume resources of IoT devices and hence reduce the lifetime of the network. The other is that RPL does not support mobility, it is speciﬁcally designed for static networks. Considering the fact that most of the application scenarios in IoT such industrial automation involve the use of mobile nodes attached to agents such as workers, robots, products, and the like, this can be regarded as one of the major drawbacks of RPL. Therefore, new improvements on RPL have been explored by researchers [ 3,4]. Such improvements should be carried out for providing its security as well, since the existence of mobile attackers could severely damage the network. This is one of the main objectives of the current study. This study explores the performance of RPL under attack. Although some analysis is carried out for a particular type of attack, such as rank attack [ 5], version number attack [ 6,7]; this study differs from these studies by taking into account both OF and mobility that could change the effect of attacks on networks. Moreover, this study does not focus on a particular attack but covers different types of attack namely version number, DIS ﬂooding, worst parent attacks are included in this study. As stressed earlier, the mobility of the nodes can harm the RPLoperated network with changing rates depending on several factors. Among them, the OF used in the network and the density of mobile nodes are priori because they are highly correlated to the performance of RPL. This becomes alarming when there are attack nodes present in the network. From this point of view, this study will provide a great insight to the researcher studying to enhance RPL towards the mobility and to develop security solutions. This is the continuation study of [ 8] which analyze attacks on static networks only. To the best of our knowledge, this is the ﬁrst study that thoroughly analyzes the performance of RPL on networks with varying mobile attacker densities and with different OFs. RPL is analyzed under different network scenarios by using the following performance metrics: packet delivery ratio, power consumption, overhead, and latency. The rest of the paper is organized as follows. The background information that covers an overview of RPL, the standard/default objective functions used in RPL, and attacks targeting RPL is given in Section 2. Section 3 summarizes the studies in the literature that analyze attacks and consider mobility in RPL security. The experimental settings are introduced, and the experimental results are discussed in Section 4. Finally, Section 5 concludes the study. 2 Background 2.1 Overview of RPL RPL creates a topology called Destination Destination Oriented Directed Acyclic Graph (DODAG). DODAG is a DAG rooted at single destination. A network can operate on one or more RPL instances where multiple DODAGs can take part. The role of each instance is to deﬁne an objective function to calculate the optimum path within the DODAG. A DODAG is built by using the following RPL control packets: •DODAG Information Object (DIO): It is initiated and broadcast only by the root node. DIO packets carry network information (e.g., instance ID, version number). Each of the receiving nodes adds the sender to its parent list, calculates its own rank value, which states its position in the graph with respect to the root node, and ﬁnally, it forwards DIO to its neighbors. DIO packets are relayed throughout the graph and play a major role in constructing the default upward routes. The transmission interval of the DIO packets should be well adjusted. The lower the interval is the higher the overhead leading to shorter lifetime of the network; the higher the interval is, however, the lower the responsiveness to the network’s inconsistencies. The management of transmission rate of DIO packets by the nodes is governed by an algorithm in RPL called trickle timer . This algorithm enables DIO packets being broadcast more frequently initially to make DODAG stable, and increases the time interval to avoid unnecessary propagation of DIO packets in the network. The timer is reset when an inconsistency is reported by the nodes, causing the DIO packets being broadcast instantly again. •DODAG Information Solicitation (DIS): It is used as a solicitation for having DIO information when a new node is to join the DODAG. DIS packets are broadcast by the new node to its neighbors. •Destination Advertisement Object (DAO): It is used for the construction of the downward routes from the root to sensor nodes. Based on the mode of operation, the child unicasts DAO packets either to root node 2in nonstoring mode or to its selected parent node in storing mode so that it records downward routes in its routing table for the subDODAG. •Destination Advertisement Object Acknowledgement (DAOACK): Upon receiving DAO packets from a parent node, DAOACK packets are sent to the the sender node as an acknowledgement. 2.2 Objective functions in RPL RPL objective function is used for the calculation of rank value assigned to each node in the network. Therefore, it implicitly governs the selection of the preferred parent of the nodes in the network, and consequently, determines the routing path that is optimal with respect to the utilized OF. The packets are forwarded in the selected routes according to three trafﬁc patterns: pointtopoint, pointtomultipoint, and multipointtopoint. Objective functions differ with respect to the RPL instances; hence, different OFs could be simultaneously used within an RPL network by different instances. For example, one can take ‘hop count’ into consideration to build routes of a DODAG, the ‘residual energy’ of the nodes can be used for ﬁnding the routes of another DODAG in the same network. The selection of appropriate objective functions is critical and changes in accordance with the requirements of the application. Even though there have been a number of OFs proposed in the literature so far, OF0 [ 9] and MRHOF [ 10] are proposed as the default OFs in RPL: 2.2.1 OF0 OF0 takes the hop count between the root node and a sensor node into account for the calculation of the rank value of that node. Therefore, it aims to minimize the number of hops to reach to the root node by choosing the node that has the lowest rank from its reachable neighbors as its parent. When OF0 is used as the objective function in the network, for a given node n, the rank of this node can be calculated using (1). R(n) =R(p) +RI (1) R(n)is the new rank of node n,R(p)is the rank of the preferred parent node, and RIstands for the rank increase metric that is calculated by using (2). RI= (RfSp+Sr)MHRI (2) Rfis a conﬁgurable rank factor and it uses 1 as the default value. Spis the step of the rank, and Sris the maximum value assigned to the rank level. MHRI stands for MinHopRankIncrease which is a constant value deﬁned as 256 in RFC6550 [11]. 2.2.2 MRHOF Unlike to OF0, a number of link and nodebased additive routing metrics can be easily integrated into MRHOF. The rank value ( R(n)in Eq. 1), and hence the routing path, is determined according to the employed routing metric which is stored in the ‘metric container’ suboption in the DIO packet. By using one of these routing metrics (e.g., latency, RSSI, and etc.), MRHOF ensures the lowestcost path in the LLN. Two metrics are integrated into MRHOF in this study: MRHOF with ETX (MRHOFETX), which is a linkbased metric, and MRHOF with energy (MRHOFENERGY), which is a nodebased metric. MRHOFETX chooses the paths with the lowest number of transmission value by considering ETX values of the links. The ETX value of the links is calculated using (3). ETX =1 DfDr(3) Dfis the probability that the neighbor will reach the packet and Dris the probability that the acknowledgment packet will be received. MRHOFENERGY chooses the path that provides the maximum remaining energy for the RPL nodes. Energy metric of the nodes is calculated using (4). ENERGY =Pmax Pnow(4) 3where Pmax is deﬁned as the targeted maximum power, and it is calculated from the initial energy of node divided by the targeted lifetime; Pnow, however, is the actual power of node. 2.3 RPL speciﬁc attacks RPL attacks can vary according to what they primarily target, and they are categorized accordingly: attacks targeting network resources, network topology, and network trafﬁc [ 12]. The basic goal of network resource attacks is to use the resources of legitimate nodes and/or the network, resulting in poor network performance. This type of attack can speed the consumption of a node’s battery power, use node memory, and cause a delay in the remaining necessary processes. DIS ﬂooding and version number attacks are in the class of attacks that target network resources. RPL attacks can also be used to disrupt the network’s topology and worst parent attack is one of the this type of attack. Lastly, there are attacks aimed to disrupt network communication and this category’s major goal is to direct network trafﬁc to a speciﬁed node. In this study, we have studied version number, DIS ﬂooding, and worst parent attacks. •Version Number: Version number in DIO packets is used by the DODAG root to perform global repair, and it is increased only by the root node. In the attack scenario, the malicious node illegitimately increases the incoming version number, causing unnecessary rebuilding of DODAG. In our attack scenario, a malicious node illegitimately increases version number by one in every minute, before forwarding incoming DIO messages to its neighbors. •DIS Flooding: It is a typical RPLspeciﬁc DoS attack that targets consuming network resources. In order to make nodes or links unavailable in LLNs, attacker continuously sends large amount of control packets. This attack is often performed by sending DIS packets after receiving a DIO packet from a node. By doing so, the DIS ﬂooding attack brings about network congestion and overloading of RPL nodes. In our attack scenario, malicious node multicasts the DIS message to its neighbor nodes every 500 milliseconds. •Worst Parent: As stated earlier, an RPL node chooses its own parent node according to the rank value determined by the objective function, which ensures the ‘best parent’ for that RPL node. However, in this attack scenario, attacker node contrarily chooses the worst parent, resulting in nonoptimized routing path and hence leading LLN to show very poor performance. 3 Related Works "
36,Routing Diverse Crowds in Emergency with Dynamic Grouping.txt,"Evacuee routing algorithms in emergency typically adopt one single criterion
to compute desired paths and ignore the specific requirements of users caused
by different physical strength, mobility and level of resistance to hazard. In
this paper, we present a quality of service (QoS) driven multi-path routing
algorithm to provide diverse paths for different categories of evacuees. This
algorithm borrows the concept of Cognitive Packet Network (CPN), which is a
flexible protocol that can rapidly solve optimal solution for any user-defined
goal function. Spatial information regarding the location and spread of hazards
is taken into consideration to avoid that evacuees be directed towards
hazardous zones. Furthermore, since previous emergency navigation algorithms
are normally insensitive to sudden changes in the hazard environment such as
abrupt congestion or injury of civilians, evacuees are dynamically assigned to
several groups to adapt their course of action with regard to their on-going
physical condition and environments. Simulation results indicate that the
proposed algorithm which is sensitive to the needs of evacuees produces better
results than the use of a single metric. Simulations also show that the use of
dynamic grouping to adjust the evacuees' category and routing algorithms with
regard for their on-going health conditions and mobility, can achieve higher
survival rates.","The advancement in information technology (IT) has fa cilitated the emergence of complex emergency management systems (EMS) [1] based on insitu wireless sensor networks (WSN). However, in most of the applications, routing algo rithms use a single criterion to choose paths for all evacuees without considering their speciﬁc requirements due to variance on age, mobility, level of resistance to hazard etc. For instance, evacuees such as sick people or aged people need to choose the safest paths that will be well ahead of the spreading hazard while for others may prefer the quickest paths without hazard. In this paper, we propose a multipath routing algorithm to tailor different services to diverse categories of evacuees. Moreover, the category that an evacuee belongs to can shift in terms of their ongoing physical conditions. We use the concepts of the Cognitive Packet Networks (CPN) to search escape paths for the evacuees in a building based on predeﬁned metrics. The remainder of this paper is organised as follows. In the next section we review the literature relevant to our work. Section III presents the concept of CPN and its variations for the evacuee routing problem. The routing metrics used in CPN as well as dynamic grouping mechanisms are then introduced in Section IV and Section V, respectively. The simulationmodels and assumptions are described in Section VI and the experimental results are presented in Section VII. Finally, we draw conclusions in Section VIII. II. R ELATED WORK "
465,MHCL: IPv6 Multihop Host Configuration for Low-Power Wireless Networks.txt,"Standard routing protocols for Low power and Lossy Networks are typically
designed to optimize bottom-up data flows, by maintaining a cycle-free network
topology. The advantage of such topologies is low memory footprint to store
routing information (only the parent's address needs to me known by each node).
The disadvantage is that other communication patterns, like top-down and
bidirectional data flows, are not easily implemented. In this work we propose
MHCL: IPv6 Multihop Host Configuration for Low-Power Wireless Networks. MHCL
employs hierarchical address allocation that explores cycle-free network
topologies and aims to enable top-down data communication with low message
overhead and memory footprint. We evaluated the performance of MHCL both
analytically and through simulations. We implemented MHCL as a subroutine of
RPL protocol on Contiki OS and showed that it significantly improves top-down
message delivery in RPL, while using a constant amount of memory (i.e.,
independent of network size) and being efficient in terms of setup time and
number of control messages.","The main function of a lowpower wireless network is usually some sort of data collection. Applications based on data collection are plentiful, examples include environment monitoring [1], ﬁeld surveillance [2], and scientiﬁc observation [3]. In order to perform data collection, a cyclefree graph structure is typically maintained and a convergecast is implemented on this network topology. Many operating systems for sensor nodes (e.g. Tiny OS [4] and Contiki OS [5]) implement mechanisms (e.g. Collection Tree Protocol (CTP) [6] or the IPv6 Routing Protocol for LowPower and Lossy Networks (RPL) [7]) to maintain cyclefree network topologies to support datacollection applications. In some situations, however, data ﬂow in the opposite direction — from the root, or the border router, towards the leaves becomes necessary. These situations might arise in network conﬁguration routines, speciﬁc data queries, or applications that require reliable data transmissions with acknowledgments. For example, in the context of Internet of Thinks, or smart 1arXiv:1606.02674v1  [cs.NI]  8 Jun 2016homes, one can imagine a lowpower wireless network connecting the appliances and other electric devices of a home to a gateway, or a border router. While away from home, one might wish to connect to the refrigerator at home to check whether one is out of milk and should buy some on the way home. In order to deliver this request, a message would need to be sent to the IPv6 address of the refrigerator. This message would ﬁrst be delivered to the home gateway and then be routed downwards through the multihop wireless network connecting the appliances. Each node in this network would act as a router and decide which way to forward the message, so that it reaches the refrigerator. Even though topdown data trafﬁc is typically not the main target of lowpower multihop wireless networks, it is enabled by some popular routing protocols in an alternative operating mode, so that routes are optimized for bottomup trafﬁc, but topdown trafﬁc is still possible. In the RPL protocol, for example, nodes maintain a DAG (Directed Acyclic Graph) topology, in which each node keeps in memory a small list of parent nodes, to which it forwards data upwards to the root. If a node wants to act not just as a source but a destination, it sends a special message upwards through the DAG, and the intermediate nodes (if they operate in the socalled storing mode) add an entry for this destination in the routing table created speciﬁcally for downward routing. The size of each such table is potentially O(n), where nis the size of the subtree rooted at the routing node. Given that memory space may be highly constrained in lowpower wireless networks, all routes often cannot be stored, and packets must therefore be dropped. This results in high message loss and high memory footprint. In order to reduce the size of the routing table, it would be desirable to aggregate several addresses of closely located destination nodes in a single routing table entry. However, because IPv6 addresses typically have their last 64 bits derived from the unique MAC address of each node, they are basically random and contain no information about the network topology. In this work we propose MHCL: a Multihop Host Conﬁguration strategy that explores cyclefree network structures in Lowpower wireless networks to generate and assign IPv6 addresses to nodes. The objective is to enable efﬁcient and robust topdown data trafﬁc with low memory footprint, i.e., small routing tables. We propose and analyze two strategies: Greedy (MHCLG) and Aggregation (MHCLA) address allocation. In the MHCLG approach, each node, starting with the root and terminating with the leaves, partitions the address space available or assigned to it by a parent (in case of the root, it could be the last 64 bits of the gateway’s IPv6 address) into equallysized address ranges and assigns them to its children (leaving a reserve address pool for possible future connections). The MHCLA approach contains an initial aggregation phase, in which nodes compute their number of descendants.Once the root receives the aggregated number of descendants of each of its (immediate) children, it allocates an address range of size proportional to the size of the subtree rooted at each child node (also leaving a reserve address space for future connections). Once a node receives an address range from its (preferred) parent, it partitions it among its own children, until all nodes receive an IPv6 address. MHCL partitions the available IPv6 address space hierarchically, based on the topology of the underlying wireless network. As a result, routing tables for topdown data trafﬁc are of size O(k), where kis the number of (immediate) children of each routing node in a cyclefree network topology. The protocol uses Trickleinspired [8] timers to adjust the communication routines and quickly adapt to dynamics in the network’s topology but not ﬂood the network with too many control messages. We implemented MHCL as a subroutine of RPL protocol in Contiki OS and analyzed its performance through simulations using a network simulator provided by Contiki [9]. Our results indicate that MHCL signiﬁcantly improves topdown message delivery of RPL, while being efﬁcient in terms of setup time and number of control messages. We also evaluated how robust our strategy is to some network dynamics, such as transient link and node failures. The rest of this paper is organized as follows. In Section 2, we brieﬂy describe how address conﬁguration and topdown data ﬂows are implemented in 6LoWPAN. In Section 3 we describe the MHCL protocol: we deﬁne two IPv6 address partitioning strategies and describe the communication routines and messages used. In Section 4 we analyze the time and message complexity of MHCL. In Section 5 we present our experimental results. In Section 6 we discuss related work, and in Section 7 ﬁnish with some concluding remarks. In case of DAG, where a node might have multiple parents, the preferred parent is used for descendants aggregation purposes. 22. 6LOWPAN 6LoWPAN (IPv6 over Low power Wireless Personal Area Networks) are comprised of lowcost wireless communication devices with limited resources, compatible with the IEEE 802.15.4 standard. In these networks, packet losses can be very frequent and links can become unusable for some time due to a variety of reasons. IPv6 address assignment: Between the (global) IPv6 network and a 6LoWPAN there is a border router, or gateway, that performs IPv6 header compression. The 128 bits of an IPv6 address are divided into two parts: the network preﬁx (64 bits) and the host address (64 bits). The 6LoWPAN header compression mechanism omits the network preﬁx bits, since they are ﬁxed for a given 6LoWPAN. Since the remaining 64 bits can handle a very large address space (up to 1:81019), 6LoWPAN offers compression options for the host address (typically only 16 bits are used). Similarly to IPv4, there are two ways to conﬁgure an address: static and dynamic. Static address allocation has to be conﬁgured manually at each device. Dynamic address allocation is performed by DHCPv6 (Dynamic Host Conﬁguration Protocol version 6). Since the network is multihop, this requires a DHCPv6 server and several retransmission agents to be deployed somewhere in the network. Once the DHCPv6 server assigns a global address to a node, it starts running the routing protocol (e.g. RPL). RPL (Acyclic Topology): RPL [7] is a distance vector routing protocol speciﬁcally designed for 6LoWPAN. The foundation of the protocol is building and maintaining an acyclic network topology, directed at the root (the border router). Therefore, a DestinationOriented Directed Acyclic Graph (DODAG) is created. The graph is constructed by the use of an Objective Function (OF) which deﬁnes how the routing metric is computed (by using the expected number of transmissions (ETX) or the current amount of battery power of a node, for example). The root starts the DODAG construction by advertising messages of type DIO (DODAG Information Object). When a node decides to join the DODAG, it saves a list of potential parents, ordered according to respective link qualities, and sets the ﬁrst parent in the list as its preferred parent. Then, the node computes its rank, which is a metric that indicates the coordinates of the node in the network hierarchy and is used to avoid routing loops. During the setup phase and in the event of a failure, nodes update their preferred parents. The Trickle algorithm [8] is used to adapt the sending rate of messages to the network topology dynamics. In a network with stable links the control messages will be rare, whereas an environment in which the topology changes frequently will cause RPL to send control information more often. When this process stabilizes, the data collection can start. RPL (Downward Routing): RPL speciﬁes two modes of operation for downward routing: storing and nonstoring. Both modes require messages of type DAO (Destination Advertisement Object) to be sent by nodes that wish to act as destinations. In the storing mode, this information is forwarded upward to preferred parents and each RPL router stores routes to its destinations in a downward routing table. The memory necessary to store such a table is O(n), where nis the size of the subtree rooted at the node. Since memory capacity is constrained in 6LoWPAN, often only a small portion of all routes can be stored in the routing tables, causing packets to be dropped. In the nonstoring mode, nodes do not have storage capacity, so the DAO messages are sent directly to the root. The root is the only node that stores the downward routing information. To send messages, source routing is then used. Consequently, the network suffers greater fragmentation risk and data message loss, and the capacity of the network is excessively consumed by source routing [10]. 3. MHCL: IPV6 MULTIHOP HOST CONFIGURATION FOR LOWPOWER WIRELESS NETWORKS The goal of MHCL (IPv6 Multihop Host Conﬁguration for Lowpower wireless networks) is to implement an IPv6 address allocation scheme for downward trafﬁc that has low memory footprint, i.e., needs small routing tables. The address space available to the border router, for instance the 64 leastsigniﬁcant bits of the IPv6 address (or a compressed 16bit representation of the latter), is hierarchically partitioned among nodes connected to the border router through a multihop cyclefree topology (implemented by standard protocols, such as RPL [7] or CTP [6]). Each node receives an address 3range from its parent and partitions it among its children, until all nodes receive an address. Since the address allocation is performed in a hierarchical way, the routing table of each node can have kentries, where kis the number of its (direct) children. Each routing table entry aggregates the addresses of all nodes in the subtree rooted at the corresponding child node. In order to decide how the available address space is partitioned, nodes need to collect information about the topology of the network. Once a stable view of the network’s topology is achieved, the root starts distributing address ranges downwards to all nodes. Note that the notion of stability is important to implement a coherent address space partition. Therefore, MHCL has an initial setup phase, during which information about the topology is progressively updated, until a (predeﬁned) sufﬁciently long period of time goes by without any topology changes. To implement this adaptive approach, we use Trickleinspired timers to trigger messages, as we explain in detail in Section 3.3. Note that, once the network reaches an initial state of stability, later changes to topology are expected to be of local nature, caused by a link or a node failure, or a change in the preferred parent of a node. In these cases, the address allocation does not need to be updated, since local mechanisms of (best effort) message resubmission can be used to improve message delivery rates. This is conﬁrmed by our experimental results in Section 5. In the (atypical) event of nonlocal and permanent topology changes in the network, the MHCL algorithm has to be restarted by the root. In this section, we describe the main components of MHCL: the IPv6 address space partitioning (Section 3.1), the message types (Section 3.2), the communication routines and timers (Section 3.3), and the routing table and forwarding routine (Section 3.4). 3.1. IPv6 address space partition The routing operation in computer networks is strongly inﬂuenced by the network topology and the semantics of the addresses. When the network is big enough to make the hosts unable to maintain entries in a routing table for every router and host in the network, usually, the addresses are hierarchically structured [11]. One way to encode hierarchical addresses is to preassign positions and lengths to each ﬁeld. The hierarchical addressing allows preﬁx aggregation, which enables contiguous IPv6 addresses or preﬁxes to be aggregated into a single preﬁx [12]. However, if the hierarchical structure of the topology doesn’t match the hierarchical structure of the address, some addresses may be underutilized (in a sparse network, for example), while other may be overﬂowed. That address space insufﬁciency is the main problem with ﬁxed position address ﬁelds. Because of this, instead of working with preﬁxes, we decided to perform a hierarchical partition of the available address space among nodes connected to the border router through a multihop cyclefree topology. We propose two address space partitioning strategies: Greedy (MHCLG) and Aggregate (MHCLA). In the greedy approach, each node nicounts the number kof its (direct) children (nodes whose preferred parent is ni); waits until it is assigned an address range by it parent (if niis not the root); partitions the address space available to it into kaddress ranges of equal size, leaving a reserve pool, say r%of its address space for possible future/delayed connections (parameter rcan be conﬁgured according to the expected number of newly deployed nodes in the network); and then distributes the resulting address ranges to its children (see Figure 1). Note that MHCLG uses only onehop topology information, which allows it to have a relatively fast setup phase. In the aggregate approach, each node nicounts the total number of its descendants, i.e., the size of the subtree rooted at itself, and propagates it to its parent.yMoreover, nisaves the number of descendants of each child. Once the root has received the (aggregate) number of descendants of each child, it partitions the available address space into kranges of size proportional to the size of the subtree rooted at each child, also leaving a portion of r%as reserve (see Figure 2). Each node nirepeats the space partitioning procedure upon receiving its own address space from the parent and sends the proportional address ranges to the respective children. The idea is to allocate larger portions to larger subtrees, which yIn order to avoid double counting nodes with multiple parents in a DAG structure, such as the one used in RPL, only the preferred parent of each node is considered. 4  0 to 255   176 to 255  16 to 95   21 to 57  96 to 175   58 to 94  1 3 1 3 1 3  1 2 1 2 Figure 1. MHCLG (Greedy address space partition). 8bit address space at the root and 6:25% reserve pool for future/delayed connections.   0 to 255   208 to 255  16 to 183  27 to 151  184 to 207   152 to 182  70%  10% 20%  80% 20%  Figure 2. MHCLA (Aggregate address space partition). 8bit address space at the root and 6:25% reserve pool for future/delayed connections. becomes important in especially large networks, because it maximizes the address space utilization. Note that this approach needs information aggregated along multiple hops, which results in a longer setup phase. 3.2. Messages MHCL uses four message types, which we implemented by modifying the DIO and DAO message types deﬁned in the RPL protocol: DIO MHCL ,DIOACK MHCL ,DAO MHCL , andDAOACK MHCL . Messages of type DIO MHCL are sent along downward routes, from parent to child. This message is used for address allocation and contains the address and corresponding address partition assigned to a child node by its parent. The message is derived from the DIO message type used in RPL, with ﬂagﬁeld set to 1(in RPL the ﬂag is set to 0) and child node’s address (which is the ﬁrst address in the allocated IPv6 range) and the allocated address partition size sent in the options ﬁeld (see Figure 3). Note that the size of the ﬁrst address and the size of the allocated address partition can have a length predeﬁned by the root, according to the overall address space (we used a value of 16 bits, because the compressed host 5  RPL InstanceID  Version  Number   Reserved  Rank   DODAGID  (128 bit)   Node Address  0                7                 15                       23                     31 bit   Partition Size  G 0 MOP  Prf DTSN  Flag  1  Option(s)...  Figure 3. DIO MHCL message.   RPL InstanceID  K D Reserved  DAO  Sequence   DODAGID  (128 bit)   Option(s)...  Flag  1  Number of Descendants  0                7   8  9  15                        23                     31 bit   Figure 4. DAO MHCL message. address has 16 bits). This information is sufﬁcient for the child node to decode the message and execute the address allocation procedure for its children. Messages of type DIOACK MHCL are identiﬁed by the ﬂagﬁeld set to 2and are used to acknowledge the reception of an allocated address range through a DIO MHCL message. If no acknowledgment is received (after a timer of type DIO mingoes off, see Section 3.3), then the parent tries to retransmit the message. 6Messages of type DAO MHCL , as in RPL, are used in the upward routes, from child to parent. This message has two functions: in the greedy approach it informs the preferred parent of a node that the latter is the former’s child; in the aggregate approach, it carries the number of a node’s descendants, used in the aggregation phase. We modiﬁed the DAO RPL message by setting the ﬂagﬁeld to 1and sending the number of respective descendants in the options ﬁeld (Figure 3). DAOACK MHCL messages are used to acknowledge the reception of a DAO MHCL message. 3.3. Communication routines and timers The greedy approach MHCLG is comprised of the following onehop communication routines: 1.Inform preferred parent: If a node is not the root, it must inform its preferred parent that it is one of its children and requires an address (or range of addresses), sending a DAO MHCL message. A node must wait until the list of potential parents is stabilized and only then inform the chosen parent. MHCL uses Trickleinspired timers to make such decisions (see Algorithm 1). In Algorithm 1, two constants are used: DIO min is a timer used by RPL for a node to set the minimum waiting time before sending a DIO message. spChild is astabilization parameter used to decide when the preferred parent is stable (refer to Table I for parameter values used in the simulations). Once the parent choice becomes stable, the local variable parentDefined is set to TRUE and a DAO MHCL is send to the parent to inform about the decision (lines 12–18, Algorithm 1). 2.Count children: Each nonleaf node must receive preferred parent messages ( DAO MHCL ) from its children, save the list of childrenz, update the counter of children, and acknowledge the packet reception of each child (by sending aDAOACK MHCL ). The counting process goes on until the information becomes stable, which is controlled by parameter spParent . Once the number of children becomes stable, the local variable childrenDefined is set to TRUE (line 13, Algorithm 2). 3.Receive address range: If a node is not the root, it must wait until it receives the address range allocated to it by its parent (in a DIO MHCL message) and acknowledge it by sending a DIOACK MHCL message. 4.Send address range to children: The address space partition and allocation is started by the root, once it determines the number of (direct) children ( childrenDefined is TRUE). The available address space is partitioned equally between the known children (keeping a reserve for future or delayed connections, as explained in Section 3.1). Once the address space is partitioned, the corresponding address range is sent in a DIO MHCL message to each child (see Algorithm 3). For nonroot nodes, once the number of children is known and the address space has been received from the parent (in a DIO MHCL message), the address partitioning is done in the same way. 5.Delayed connections: if aDAO MHCL message from a new child node is received after the address space had already been partitioned and assigned, then the address allocation procedure is repeated using the reserved address space. The aggregate approach MHCLA ﬁrstly executes an aggregation procedure to compute the total number of descendants of each node. If a node is not the root, and it has deﬁned who the preferred parent is (parentDeﬁned is TRUE) it starts by sending a DAO MHCL message with count = 0(see Algorithm 4). Then it waits for DAO MHCL messages from its children, updates the number of descendants of each child, and propagates the updated counter to the parent until its total number of descendants is stable. If a node is the root, then it just updates the number of descendants of each child by receiving DAO MHCL messages until its total number of descendants is stable (see Algorithm 5). Parameters spLeaf and spRoot are used to deﬁne stabilization criteria in nonroot nodes and the root node, respectively. Once the aggregation phase is completed, the root’s local variable descendantsDefined is set to TRUE, and the address allocation process is started by the root and propagated toward the leaves, as in the greedy approach (see Algorithm 3). zNote that in standard implementations of acyclic structures in protocols such as RPL and CTP, a node does not save a list of children, but only a list of potential parents 7Algorithm 1 MHCL: Preferred parent timer 1:parentDeﬁned = FALSE; 2:maxTime = spChildDIO min; 3:timer = rand( 1=2DIO min,DIO min]; .reset timer 4:while NOT parentDeﬁned do 5: ifNOTROOT andTIMEROFF then 6: ifPARENTCHANGED then 7: reset timer; 8: else 9: iftimer < maxTime then 10: timer *= 2; .double timer 11: else 12: parentDeﬁned = TRUE; .MHCLGA 13: ifMHCLG then .greedy approach 14: sendDAO MHCL to parent; 15: ifNODAOACK MHCL then 16: sendDAO MHCL to parent; .retry 17: end if 18: end if 19: end if 20: end if 21: end if 22:end while Algorithm 2 MHCLG: Children counter timer 1:childrenDeﬁned = FALSE; 2:maxTime = spParentDIO min; 3:timer = rand( 1=2DIO min,DIO min]; .reset timer 4:count = 0; .counts number of children by receiving DAO MHCL messages 5:while NOT childrenDeﬁned do 6: ifTIMEROFF then 7: ifCOUNTCHANGED then 8: reset timer; 9: else 10: iftimer < maxTime then 11: timer *= 2; 12: else 13: childrenDeﬁned = TRUE; 14: end if 15: end if 16: end if 17:end while 3.4. Routing tables and forwarding After the address allocation is complete, each (nonleaf) node stores a routing table for downward trafﬁc, with an entry for each child. Each table entry contains the ﬁnal address of the address range allocated to the corresponding child, and all table entries are sorted in increasing order of the ﬁnal address of each range. In this way, message forwarding can be performed in linear time using one comparison operation per table entry (see Algorithm 6). Of course, binary search could also be used, but considering that routing table size is limited by the number of direct children of a node, we opted for simplicity. 8Algorithm 3 MHCL: IPv6 address distribution 1:STABLE = FALSE; 2:ifMHCLG then .Greedy MHCLG 3: STABLE = childrenDeﬁned; 4:else .Aggregate MHCLA 5: STABLE = descendantsDeﬁned orNOTROOT; 6:end if 7:ifSTABLE and(ISROOT orRECEIVED DIO MHCL )then 8: partition available address space; 9: foreach child cido 10: sendDIO MHCL toci; .send IPv6 “range” 11: ifNODIOACK MHCL then 12: sendDIO MHCL toci; .retransmit 13: end if 14: end for 15:end if Algorithm 4 MHCLA: Aggregation timer (nonroot nodes) 1:maxTimeLeaf = spLeafDIO min; 2:timer = rand( 1=2DIO min,DIO min]; .reset timer 3:count = 0; .counts total number of descendants by receiving DAO MHCL messages 4:while NODIO MHCL FROMPARENT do 5: .while has not received IPv6 address range 6: ifNOTROOT andTIMEROFF then 7: ifparentDeﬁned and(count < 1)then 8: sendDAO MHCL to parent; 9: .trigger aggregation 10: end if 11: ifCOUNTCHANGED then 12: sendDAO MHCL to parent; 13: reset timer; 14: else 15: iftimer < maxTimeLeaf then 16: timer *= 2; 17: end if 18: end if 19: end if 20:end while 4. COMPLEXITY ANALYSIS We now turn our attention to the time ( Time (MHCL )) and message ( Message (MHCL )) complexity of MHCL, assuming a synchronous communication model with pointtopoint message passing, i.e., that all nodes start executing the algorithm simultaneously and that time is divided into synchronous rounds, such that, whena message is sent from node v to its neighbor uat timeslot t, it must arrive at ubefore timeslot t+ 1. Note that MHCL requires that an underlying acyclic topology (say tree T) has been constructed by the network before the address allocation starts, i.e., every node knows who its preferred parent is ( parentDefined ==TRUE ). The greedy approach MHCLG has two phases: (1) a onehop communication routine, run in parallel at all nodes, in which each node informs its preferred parent about its decision, the parent sends an acknowledgment, and, by the end of this routine, every node knows how many children it has; (2) a broadcast from the root to all nodes in the tree Tof address allocation information, each message being acknowledged by the recipient of the address range. The time complexity of routine (1) 9Algorithm 5 MHCLA: Aggregation timer (Root) 1:descendantsDeﬁned = FALSE; 2:maxTimeRoot = spRootDIO min; 3:timer = rand( 1=2DIO min,DIO min]; .reset timer 4:count = 0; .counts total number of descendants by receiving DAO MHCL messages 5:while NOT descendantsDeﬁned do 6: ifISROOT andTIMEROFF then 7: ifCOUNTCHANGED then 8: reset timer; 9: else 10: iftimer < maxTimeRoot then 11: timer= 2; 12: else 13: descendantsDeﬁned = TRUE; 14: end if 15: end if 16: end if 17:end while Algorithm 6 MHCL: Message forwarding 1:i= 0; 2:while IPv6"
234,SynKB: Semantic Search for Synthetic Procedures.txt,"In this paper we present SynKB, an open-source, automatically extracted
knowledge base of chemical synthesis protocols. Similar to proprietary
chemistry databases such as Reaxsys, SynKB allows chemists to retrieve
structured knowledge about synthetic procedures. By taking advantage of recent
advances in natural language processing for procedural texts, SynKB supports
more flexible queries about reaction conditions, and thus has the potential to
help chemists search the literature for conditions used in relevant reactions
as they design new synthetic routes. Using customized Transformer models to
automatically extract information from 6 million synthesis procedures described
in U.S. and EU patents, we show that for many queries, SynKB has higher recall
than Reaxsys, while maintaining high precision. We plan to make SynKB available
as an open-source tool; in contrast, proprietary chemistry databases require
costly subscriptions.","Commercial chemistry databases, such as Reaxys3 are invaluable tools for chemists, who issue struc tured SQLlike queries to retrieve precise infor mation about chemical reactions described in the literature. Large, highquality datasets are also cru cial for synthetic route planning (Klucznik et al., 2018), automation (Coley et al., 2019b; Collins et al., 2020), and machine learning approaches to retrosynthesis (Coley et al., 2019a). In addition to proprietary, manually curated databases such as Reaxys, recent work has begun to use automatically extracted data from reactions described in patents (Tetko et al., 2020), however existing databases are limited to basic reaction information, and do not 1Introduction video: https://screencastomatic. com/watch/c3jVQsVZwOV 2Code:https://github.com/bflashcp3f/SynKB . 3https://www.elsevier.com/solutions/reaxysinclude important details such as concentrations or order of additions (Coley et al., 2019b). The lack of highquality data has been identiﬁed as a key challenge in developing recommendation models for reaction conditions (Struble et al., 2020). In this paper, we present SYNKB, a working sys tem that demonstrates the application of modern NLP methods to extract large quantities of struc tured information about chemical synthesis proce dures from text. SYNKBhas a number of advan tages with respect to existing chemistry databases such as Reaxys: (1) We show that by automatically extracting information from millions of synthesis procedures described in U.S. and European patents using stateoftheart NLP methods, we can achieve signiﬁcantly higher recall than existing chemistry databases while maintaining high precision. In §3, we demonstrate SYNKB’s coverage is comple mentary to Reaxys; see Figure 2 for details. (2) SYNKB’s novel graph search supports better cover age of reaction conditions than existing chemistry databases; this includes concentrations, reaction times, order of the addition of reagents, catalysts, etc. (3) We will make SYNKBavailable as open source software on publication, in contrast, most existing chemistry databases are proprietary, with the notable exception of Lowe (2017), which we compare to in §3. We have built an online demo, which can be viewed at the following URL: https://tinyurl. com/synkb . We will also release the source code and patentbased extractions used to build SYNKB on publication. 2SYNKB SYNKB is an opensource system that allows chemists to perform structured queries over large corpora of synthesis procedures. In this section, we present each component of SYNKB, as illustrated in Figure 1. Our corpus collection is ﬁrst presented in §2.1. Section 2.2 describes how a corpus of sixarXiv:2208.07400v2  [cs.CL]  6 Oct 2022(6 million synth. procedures)US06169084   Preparation of (2methyl4(4methyl1piperazinyl)10Hthieno[2,3b][1,5]benzodiazepine)dihydrate E. 1. A 0.5 g sample of technical grade olanzapine was suspended in ethyl acetate (10 mL) and toluene (0.6 mL). 2. The mixture was heated to 80° C. until all the solids dissolved. 3. The solution was cooled to 60° C. and water (1 mL) was added slowly.    … 7. TGA mass loss was 10.5%. 8. Yield: 0.3 g.Synthesis ProceduresSemantic SearchQ: What solvents are used in the reactions that produce (2methyl4(4methyl1piperazinyl…? Patent IDSolventFull ProcedureUS06169084ethyl acetate / tolueneA 0.5 g sample of…………Q: What amount is ethyl acetate at when used to suspend olanzapine? Patent IDAmountFull ProcedureUS0616908410 mLA 0.5 g sample of…………Extracted Information2. Slot Filling (procedurelevel)Patent IDReagentSolventProductYield…US06169084olanzapineethyl acetate / toluene(2methyl4(4methyl..)0.3 g………………….1. Shallow Semantic Parsing (operationlevel)Figure 1: Overview of our semantic search system S YNKB, which searches over 6 million chemical synthesis procedures collected from patents. Users can enter structured queries to retrieve procedures concerning procedure level or operationlevel information. million procedures is annotated with sentencelevel action graphs, in addition to protocollevel slots relevant to chemical reactions, including starting materials, solvents, reaction products, yields, etc. After automatically annotating and indexing, we experiment with the semantic search capabilities enabled by S YNKB in §2.3. 2.1 Corpus Collection We extract structured representations of synthetic protocols from a corpus of chemical patents (Bai et al., 2021), which includes over six million chem ical synthesis procedures extracted from around 300k U.S. and European patents (written in En glish). The U.S. portion of this corpus comes from an opensource corpus of chemical synthe sis procedures (Lowe, 2017), which covers 2.4 million synthetic procedures extracted from U.S. patents (USPTO4, 19762016). For the European portion, we apply the Lowe (2017) reaction identi ﬁcation pipeline to European patents. Speciﬁcally, we download patents from EPO5(19782020) as XML ﬁles and select patents containing the IPC (International Patent Classiﬁcation) code ‘C07’ for 4https://www.uspto.gov/ learningandresources/bulkdataproducts 5https://www.epo.org/searchingforpatents/ data/bulkdatasets.htmlprocessing as they are in the category of organic chemistry. Next, the synthesis procedure identiﬁer developed by Lowe (2012), a trained Naive Bayes classiﬁer, is applied to the Description section of all selected patents. As a result, we obtain another 3.7 million procedures from European patents. 2.2 Extracting Reaction Details from Synthetic Procedures To facilitate semantic search, we automatically annotate the corpus of 6 million synthetic proce dures described above with semantic action graphs (Kulkarni et al., 2018) in addition to chemical reac tion slots (Nguyen et al., 2020) using Transformer models that are pretrained on a large corpus of scientiﬁc procedures (Bai et al., 2021). Shallow Semantic Parsing. We ﬁrst perform sentencelevel annotation, where each step in the procedure is annotated with a semantic graph (Tamari et al., 2021). Nodes in the graph are ex perimental operations and their typed arguments, whereas labeled edges specify relations between the nodes (see the example shallow semantic parse in Figure 1). Here we use the CHEM SYNframe work (Bai et al., 2021), which covers 24 types of nodes (such as Action ,Reagent ,Amount ,Equip ment , etc.) and 17 edge types (e.g. Actson andMeasure ). With these annotated semantic graphs, users can search for operationlevel information, for example, the amount of DMFwhen used as a sol vent to dissolve HATU (this will be further discussed in §3). Following Tamari et al. (2021), we split semantic graph annotation into two subtasks, Men tion Identiﬁcation (MI) for node prediction and Ar gument Role Labeling (ARL) for edge prediction. We use the same ﬁnetuning architectures as in Tamari et al. (2021). Models are ﬁnetuned on the CHEM SYNcorpus, which consists of 992 chemical synthesis procedures extracted from patents, and the resulting performance (averages across ﬁve ran dom seeds) is shown in Table 1. We select model checkpoints via the Dev set performance out of ﬁve random seeds, and use the selected checkpoint for inference on our 6 million synthetic procedures. Slot Filling. In the second task, we annotate pro cedures from a protocol perspective, i.e., identify ing key entities playing certain roles in a protocol, which can be queried in a slotbased search. We use theCHEMU training corpus proposed in Nguyen et al. (2020). This dataset includes 10 predeﬁned slot types concerning chemical compounds and re lated entities in chemical synthesis processes such asStarting Material ,Solvent , and Product . Similar to the Mention Identiﬁcation task, we treat Slot Filling as a sequence tagging problem. However, the input in Slot Filling is the entire protocol, rather than a single sentence, as in mention identiﬁcation. We ﬁnetune models on the CHEMU dataset (see Table 1 for results), and then run inference on the chemical patent corpus using the learned model. ProcBERT. We use ProcBERT (Bai et al., 2021), a BERTbased model that is pretrained on in domain data (scientiﬁc protocols), as the backbone for all of our models, and develop taskspeciﬁc ﬁnetuning architectures on top of it. The com parison between ProcBERT and other pretrained models is presented in Table 1. Because ProcBERT is pretrained using indomain data, we ﬁnd that it outperforms both BERT large(Devlin et al., 2019) and SciBERT (Beltagy et al., 2019) on all three tasks. 2.3 Semantic Search SYNKBoffers search modalities speciﬁc to each of these two forms of annotation, i.e., semantic action graphs and chemical reaction slots, along with features designed to support practical use. TheAnnotation Task DatasetPretrained Model BERT large SciBERT ProcBERT Mention IdentiﬁcationCHEM SYN95.26 0.1 95.82 0.2 95.97 0.2 Argument Role Labeling 92.87 0.5 93.27 0.2 93.57 0.2 Slot Filling C HEMU 95.10 0.2 95.63 0.1 96.19 0.1 Table 1: Test set F 1scores of ﬁnetuned models for the three annotation tasks. These numbers, averages across ﬁve random seeds with standard deviations as subscripts, are taken from our previous work Bai et al. (2021). Models using ProcBERT for contextual embed dings perform the best on all three tasks and are used for automatic annotations on six million synthesis pro cedures to construct S YNKB. SYNKB(ours) USPTOLowe Reaxys License Open source Open source Subscription # Procedures (mill.) 6 2.4 57 # Entity Types 24 8 10 # Relation Types 17   Annotation Automatic Automatic Manual Table 2: Comparison between our S YNKB and two performant databases. Our S YNKB provides more ﬁne grained annotations (more entity types and unique rela tion annotations) than the other two systems and covers more procedures than USPTOLowe, a database built using the largest opensource synthesis procedure cor pus (Lowe, 2017). ﬁrst type of query supported by SYNKBisseman tic graph search , which allows users to search for synthesis procedures based on the semantic parse of the constituent operations. We adapt the graph query formalism proposed originally for syn tactic dependencies in ValenzuelaEscárcega et al. (2020).6Formally, the input query G"
72,RTXP : A Localized Real-Time Mac-Routing Protocol for Wireless Sensor Networks.txt,"Protocols developed during the last years for Wireless Sensor Networks (WSNs)
are mainly focused on energy efficiency and autonomous mechanisms (e.g.
self-organization, self-configuration, etc). Nevertheless, with new WSN
applications, appear new QoS requirements such as time constraints. Real-time
applications require the packets to be delivered before a known time bound
which depends on the application requirements. We particularly focus on
applications which consist in alarms sent to the sink node. We propose
Real-Time X-layer Protocol (RTXP), a real-time communication protocol. To the
best of our knowledge, RTXP is the first MAC and routing real-time
communication protocol that is not centralized, but instead relies only on
local information. The solution is cross-layer (X-layer) because it allows to
control the delays due to MAC and Routing layers interactions. RTXP uses a
suited hop-count-based Virtual Coordinate System which allows deterministic
medium access and forwarder selection. In this paper we describe the protocol
mechanisms. We give theoretical bound on the end-to-end delay and the capacity
of the protocol. Intensive simulation results confirm the theoretical
predictions and allow to compare with a real-time centralized solution. RTXP is
also simulated under harsh radio channel, in this case the radio link
introduces probabilistic behavior. Nevertheless, we show that RTXP it performs
better than a non-deterministic solution. It thus advocates for the usefulness
of designing real-time (deterministic) protocols even for highly unreliable
networks such as WSNs.","AWSNiscomposedofnodesdeployedinanareainordertomonitorparameters oftheenvironment. Thosenodesareabletosendinformationtodedicatednodes called sinks, without the need of a ﬁxed network infrastructure, in a multihop fashion. Every node is able to forward messages from the other nodes. They usually run on batteries so they should consume as little energy as possible in order to increase the network lifetime. Because WSNs can contain thousands of nodes, the cost of a node should be as low as possible, this leads to design nodes with poor capabilities (computation, radio, memory, etc...). In the past few years WSNs have been a very active research ﬁeld which has led to interesting contributions at all communication layers. This is due to the great expectations put in WSN applications. In fact, lots of applications have been proposed in the literature, such as volcano monitoring [30], air pollution monitoring [20], landslide detection [25] and so on. Due to the previously mentioned characteristics of WSNs, network proto cols have been designed mainly in order to reduce energy consumption and to provide autonomous network mechanisms. Nevertheless some applications need more than these characteristics. Indeed, critical applications require more re liability and the respect of time constraints. For instance the aforementioned landslide detection application should give guarantees on the delivery of alert messages. Protocols which can deliver messages with guaranteed endtoend delay are called realtime protocols. They are usually classiﬁed into two cate gories, soft realtime and hard realtime: in the ﬁrst case, some messages can miss the deadline with no consequences (video) while in the second case, the delay constraint should be always respected whatever the circumstances are because of the possible impact on human life, on the environment or on the ﬁnancial cost. Due to the probabilistic nature of the radio links in WSNs, strict time constraint is not acheivable, thus the time bound must be associated to a given reliability. This parameter is thus a main concern in the design of a WSN realtime protocol. Hard realtime constraints cannot be met with the current WSN protocols of the literature either because of their lack of determinism which implies un bounded delays or low reliability, or because they do not take into account the aforementioned characteristics of WSNs. In this paper we propose, a new localized realtime crosslayer protocol, RTXP. This protocol aims at giving a bound on the endtoend delay in a WSN. In order to handle realtime requirements, deterministic mechanisms must be in troduced at MAC and routing layers. The interactions between these two layers must also be carefully controlled in order to avoid unexpected and unbounded delays. We thus claim that a crosslayer design where MAC and routing layers share information should be preferred. Our approach is to bound the duration of one hop1and the number of hops to reach the sink. To avoid unbounded delays and unbounded route lengths, the access to the medium and the choice of the forwarder must be deterministic. Our approach is based on a suitable Virtual Coordinate System (VCS) [23]. This VCS allows the nodes to get in formation on their distance to the sink in number of hops. It also diﬀerentiates nodes having the same hopcounts in order to improve the forwarder selection. 1We deﬁne the duration of one hop to be the time needed for a node to access the medium and send a packet RR n °7978RTXP 4 Finally, it gives a unique identiﬁer to the nodes in a 2hop neighborhood in or der to deterministically access the medium. The VCS is constructed with local information (the neighbors of a node) and it is the only information used by RTXP. Our proposition is thus localized, no global view of the system is needed, the approach is therefore more scalable than centralized solutions. Under harsh channel conditions, no hard realtime guarantee can be given whatever the protocol used, because a message may need an inﬁnite number of retransmissions to be correctly transmitted (even if the probability of this event is low). Indeed, even if the protocol is deterministic, the radio link introduces probabilities. In the paper we show that a deterministic protocol allows to achieve better performances (notably reliability) than non realtime solutions. Insection2wediscusstheadvantagesanddrawbacksofexistingWSNsMAC and routing protocols for realtime applications. In section 3 we introduce the hypothesis and the requirements of our solution. In section 4 we present the details of our proposition, RTXP. In section 5 we give theoretical bound on the endtoend delay and the capacity of the protocol. Section 6 presents simulation parameters and results, we compare RTXP to a centralized solution and a non realtime protocol. In section 7, we conclude on the protocol properties and performances and we present our future works. 2 Related work "
398,Attention routing between capsules.txt,"In this paper, we propose a new capsule network architecture called Attention
Routing CapsuleNet (AR CapsNet). We replace the dynamic routing and squash
activation function of the capsule network with dynamic routing (CapsuleNet)
with the attention routing and capsule activation. The attention routing is a
routing between capsules through an attention module. The attention routing is
a fast forward-pass while keeping spatial information. On the other hand, the
intuitive interpretation of the dynamic routing is finding a centroid of the
prediction capsules. Thus, the squash activation function and its variant focus
on preserving a vector orientation. However, the capsule activation focuses on
performing a capsule-scale activation function.
  We evaluate our proposed model on the MNIST, affNIST, and CIFAR-10
classification tasks. The proposed model achieves higher accuracy with fewer
parameters (x0.65 in the MNIST, x0.82 in the CIFAR-10) and less training time
than CapsuleNet (x0.19 in the MNIST, x0.35 in the CIFAR-10). These results
validate that designing a capsule-scale operation is a key factor to implement
the capsule concept.
  Also, our experiment shows that our proposed model is transformation
equivariant as CapsuleNet. As we perturb each element of the output capsule,
the decoder attached to the output capsules shows global variations. Further
experiments show that the difference in the capsule features caused by applying
affine transformations on an input image is significantly aligned in one
direction.","Convolutional neural networks(CNNs) have had much success in computer vision tasks [8] [13] [3] [6]. The convo lutional layer is an effective method to extract local features due to its local connectivity and parameter sharing with spa tial location. However, the convolutional layer has a lim ited ability to encode a transformation. For example, if the convolutional layer is combined with a maxpooling layer, the extracted feature is local translation invariant. As CNN models become deeper [3] [15], the receptive ﬁeld of eachfeature is getting larger. Then, the information loss from the translation invariance also increases. To overcome the transformation invariance of CNNs, the transforming autoencoder [4] uses the concept of ”capsule”. A capsule is a vector representation of a feature. Each cap sule not only represents a speciﬁc type of entity but also de scribes how the entity is instantiated, such as precise pose and deformation. In other words, the capsules are transfor mation equivariant. The CapsuleNet [12] is a novel method that implements the idea of the capsules. By introducing the dynamic rout ing algorithm and squash activation function 1, CapsuleNet uses vectoroutput capsules as a basic unit instead of scalar output features. squash (sj) =jjsjjj2 1 +jjsjjj2sj jjsjjj(1) where sjis a preactivation capsule. However, CapsuleNet has a room for development. The number of parameters of CapsuleNet is much larger than that of comparable perfor mance CNNbased models. Also, the dynamic routing is an iterative process. The reported accuracy of CapsuleNet on the benchmark datasets like CIFAR10 is inferior to state oftheart CNN models. [18] In this paper, we propose a convolutional capsule net work architecture comprised of building blocks of CNNs. We substitute the dynamic routing and squash capsule activation function of CapsuleNet[12] with attention rout ing and capsule activation. In the attention routing, the log probabilities of agreement coefﬁcients between the lth layer and the (l+ 1) th layer are learned by a scalarproduct be tween the capsules of the lth layer and the kernel of con volution. The kernel of convolution serves as an approxi mation of the reference vector to perform routing. By re placing an iterative process of the dynamic routing with forwardpass convolution, the attention routing is fast while maintaining spatial information. Two important properties of squash activation function 1 is that the squash activation function preserves a vector orientation and is a capsulewise activation function, not an elementwise activation function such as ReLU or tanh . The dynamic routing is an unsuperarXiv:1907.01750v4  [cs.CV]  13 Nov 2019Conv T ransformPrimary Caps Layer ...Input dwh... d'w'h' nConv Caps Layer Fully Conv Caps Layer Conv3x3,  BNConvolution layer n'Length OperationCaps ActivationConv T ransform Caps ActivationAttention RoutingConv T ransform Caps ActivationAttention RoutingFigure 1. Overview of AR CapsNet. AR CapsNet is composed of primary caps layer, conv caps layer, and fully conv caps layer. BN denotes the batch normalization. Conv Transform and Caps Activation denotes the convolutional transform and capsule activation respectively. vised algorithm to ﬁnd a centroidlike output capsule of the prediction capsules. Therefore, the squash activation func tion and its variant 2 [18] focus on preserving a capsules orientation. squash variant (sj) = 1"
307,FLBRA: Fuzzy Logic Based Routing Algorithm for Indoor Wireless Sensor Networks.txt,"Considering the context of building management systems with wireless sensor
networks monitoring environmental features, this paper presents a proposal of a
Fuzzy Logic Based Routing Algorithm (FLBRA) to determine the cost of each link
and the identification of the best routes for packet forwarding. We describe
the parameters (Received Signal Strength Indicator - RSSI, Standard Deviation
of the RSSI and Packet Error Rate - PER) for the cost definition of each path,
the sequence of identifying best routes and the results obtained in simulation.
As expected in this proposal, the simulation results showed an increase in the
packet delivery rate compared to RSSI-based forward protocol (RBF).","  Wireless sensor  networks (WSN) have been a widely used solution for monitoring systems,  including, for example, Building Management Systems (BMS). The sensors are responsible for  monitoring aspects of the environment, capturing data such as temperature, lighting and powe r  consumption [1]. Through this monitoring, management strategies and control of lighting, and  HVAC (heating, ventilation, and air conditioning) are applied seeking greater efficiency in  resource use.     However, when it comes to an application of WSN in a dynamic environment, such as offices,  subject to constant physical changes, either due to the inclusion of new obstacles like furniture  and walls as well as the movement of people throughout the space, the design of the wireless  network should take into co nsideration the possibility of constant reconfiguration of the network.  These reconfigurations are necessary since such changes in the environment generate impacts on  the initial performance of the WSN [2].     In this scenario, it is important to identify so lutions to meet the demands of reliability and to  overcome the indoor environment constraints. To do so, in order to minimize the impacts of  changes in the environment, this paper presents a strategy for network reconfiguration, by  dynamically changing the  routes of communication between the sensors, aiming the continuous  communication between the sensors and the base station. The proposal makes use of fuzzy logic  to assign costs to links considering the relation between RSSI, Standard Deviation of the RSSI ,  and Packet Error Rate.    International Journal of Computer Science & Information Technology (IJCSIT) Vol 6, No 5, October 201 4      86 The organization of this paper includes the description of related work, describing routing  solutions based on RSSI in Section 2. Section 3 describes a brief background on Fuzzy Logic.  The description of our solution, with the pr oposed algorithm, is shown in Section 4. Section 5  presents the discussion of the simulation results. Finally the conclusion in Section 6.    2. RELATED WORKS   "
312,Performance Evaluation of Ad Hoc Multicast Routing Protocols to Facilitate Video Streaming in VANETS.txt,"Vehicular Ad Hoc Network (VANET) is a type of mobile ad hoc network (MANET)
that facilitates communication among vehicles. VANET provides inter-vehicular
communications to serve for the application like road traffic safety and
traffic efficiency. Infotainment service has been an anticipating trend in
VANETs, and video streaming has a high potential in VANET. Although, this
emerging technology is trending, there are still some issues like QoS
provisions, decentralized medium access control, node coverage area, and
finding and maintaining routes due to highly dynamic topology. These issues
make multicast communication difficult in VANETs. Numerous routing protocols
and routing strategies have been projected to cope with these issues. Lots of
work has taken place to assess and measure the performances of these protocols
in VANETs but these protocols are rarely analyzed for performance under stress
of real time video multicast. In this study two different multicast routing
protocols viz. Multicast Ad hoc On Demand Distance Vector (MAODV) and Protocol
for Unified Multicasting through Announcements (PUMA) are evaluated for
facilitating video streaming in VANETS. The protocols are examined against the
QoS parameters such as Network Throughput, Packet Delivery Ratio (PDR), Average
end to end Delay, and Normalized Routing Load (NRL). Variable Bit Rate (VBR)
traffic is used to evaluate the performances of protocol. PUMA, at the end,
showed better performance against different QoS provisions in different
scenarios","ecent advancements in communication are enabling the  design and implementation of networks those ca n be  deployed in various kinds of environments, this network  is called an Ad Hoc Network. An infrastructure less network  comprising different number of communication nodes  describes an ad hoc network, where a node may be any  communication device [12]. Sort of these networks are very  useful where traditional wired networks cannot be deployed,  such as battlefields, disastrous areas etc. Mobile Ad Hoc  Network (MANET) is one such ad hoc network with no Base  Station or Access Point available fo r passing messages among  nodes, the nodes are mobile and wirelessly communicate to  each other without banking on pre established infrast ructure  [19]. Participating node in a MANET might be any equipment  with wireless interface embodied in it. Every participating  node may also work as router for passing the messages  between distant nodes.  Because nodes are mobile, there’s no  bound on the movement of nodes, and each node changes its  links frequently.   Specifically when talking about VANET,  Vehicular Ad Hoc  Network, it is also a MANET where moving vehicles act as  nodes to create a mobile network [49]. The participating  vehicles are turned either into router or host resulting in a  wider network as the small distant vehicles jo in each other  [9].  VANETs have received a lot of interest in the applications like  road traffic safety and traffic efficiency [15].  Because there  are vehicles working as nodes VANETs have high mobility  among the nodes causing highly dynami c topology.  Furthermore in the absence of basic infrastructure each node is  responsible for finding the path for its data to be transmitted.  The routing protocol is set of rules for establishment and maintenance of paths among mobile nodes. VANET in its  nature is of highly dynamic topology; nodes join and leave the  network frequently causing periodic connectivity information  requirement in order to have a reliable status of the network.  Consequently, the aim of a routing protocol is to discover right  path a mong mobile nodes so that data can be delivered  reliably. Furthermore, the established path for communication  should be the one with minimum overhead and bandwidth  consumption. During previous decades different routing  protocols are projected for VANETs  [29].  In this study we have evaluated  the performances of two  prominent ad hoc multicast protocols viz. Multicast Ad hoc  OnDemand Distance Vector (MAODV) a tree based protocol,  and Protocol for Unified Multicasting through  Announc ements (PUMA) that is mesh based. The protocols  will be evaluated under stress of video traffic (VBR) in  VANETs with multicast mode of communication.     II. RELATED WORK  "
202,Dynamical Jumping Real-Time Fault-Tolerant Routing Protocol for Wireless Sensor Networks.txt,"In time-critical wireless sensor network (WSN) applications, a high degree of
reliability is commonly required. A dynamical jumping real-time fault-tolerant
routing protocol (DMRF) is proposed in this paper. Each node utilizes the
remaining transmission time of the data packets and the state of the forwarding
candidate node set to dynamically choose the next hop. Once node failure,
network congestion or void region occurs, the transmission mode will switch to
jumping transmission mode, which can reduce the transmission time delay,
guaranteeing the data packets to be sent to the destination node within the
specified time limit. By using feedback mechanism, each node dynamically
adjusts the jumping probabilities to increase the ratio of successful
transmission. Simulation results show that DMRF can not only efficiently reduce
the effects of failure nodes, congestion and void region, but also yield higher
ratio of successful transmission, smaller transmission delay and reduced number
of control packets.","Wireless sensor networks (WSNs) have very br oad application prospects in military disaster  monitoring, environmental and ecological monitoring, earthquake, fire emergencies, medical systems,  urban transportation and security monitoring [1]. In most of the applications, especially in emergent  situations, realtime and fault tolerance characteris tics are highly required. Nodes in WSN are prone to  failure due to energy depletion, hardware failu re, communication link errors, malicious attack, etc. [2].  Faulttolerance is the ability of a system to deliver a desired level of functionality in the presence of  faults. Extensive work has been done on fault tole rance and it has been one of the most important  research topics in WSNs. Fault tolerance in a WSN sy stem may exist at hardware layer, software layer,  network communication layer, and application layer [2].  In this paper, we focus on the fault tolerance  in realtime routing protocol level. To guarantee the real time performance of the nodes, each data  packet is constrained in a time interval in which it mu st be sent to the destination node. If time expires,  the data packet has to be discarded. Once node fa ilure or congestion occurs, large amounts of data  packets will be discarded, which may cause disast rous consequences. Consequently, it is more  significant and challenging to provide both realtim e and fault tolerance characteristics in WSN  routing protocol.   Existing realtime fault tolerant WSN routing pr otocols adopt hopbyhop transmission mode [35],  where the next hop node is selected based on the tr ansmission time estimation or the relations of the  distance among the current node, neighbor node and si nk node. Failure nodes are treated as an empty  area (VOID), and data packets are sent to the sink node via bypass. However, these methods do not  predict network congestion in advance [1], and the remaining transmission time of the data packet is  only used for checking the validity of the data packets. When a data packet cannot be transmitted to the next hop node, it will be automatically discarde d at once, which wastes the transmission energy.  Moreover, the upper stream node cannot receive the feedback information from the current node and  thus affect the subsequent transmission.  In this paper, a dynamical jumping realtime fau lttolerant routing protocol is proposed, namely  DMRF. Each node utilizes the remaining transmission time of the data packets and the state of the  forwarding candidate node set to dynamically se lect the next hop. Once node failure, network  congestion or void region occurs, the transmission m ode will switch to jumping mode, which aims at  reducing the transmission time delay and ensuring the da ta packets to be sent to the destination node  within the specified time limit. According to th e feedback information from the downstream node,  each node dynamically adjusts the jumping proba bilities to increase the ratio of successful  transmission.   The remainder of this paper is organized as fo llows. Section 2 introduces related work. Section 3  provides the application scenario of DMRF protocol. Section 4 presents the DMRF protocol in detail.  Section 5 provides the feasibility proof and perfor mance analysis of DMRF. The performance of  DMRF is evaluated in Section 6. Section 7 concludes the paper and outlines some future work.  2. Related Work  "
208,Power Assignment Problems in Wireless Communication.txt,"A fundamental class of problems in wireless communication is concerned with
the assignment of suitable transmission powers to wireless devices/stations
such that the resulting communication graph satisfies certain desired
properties and the overall energy consumed is minimized. Many concrete
communication tasks in a wireless network like broadcast, multicast,
point-to-point routing, creation of a communication backbone, etc. can be
regarded as such a power assignment problem.
  This paper considers several problems of that kind; for example one problem
studied before in \cite{Carrots, Bilo} aims to select and assign powers to $k$
of the stations such that all other stations are within reach of at least one
of the selected stations. We improve the running time for obtaining a
$(1+\epsilon)$-approximate solution for this problem from
$n^{((\alpha/\epsilon)^{O(d)})}$ as reported by Bilo et al. (\cite{Bilo}) to
$O(n+ {(\frac{k^{2d+1}}{\epsilon^d})}^{\min{\{2k, (\alpha/\epsilon)^{O(d)}
\}}})$ that is, we obtain a running time that is \emph{linear} in the network
size. Further results include a constant approximation algorithm for the TSP
problem under squared (non-metric!) edge costs, which can be employed to
implement a novel data aggregation protocol, as well as efficient schemes to
perform $k$-hop multicasts.","Wireless network technology has gained tremendous importa nce in recent years. It not only opens new application areas with the availability of highbandwi dth connections for mobile devices, but also more and more replaces so far ’wired’ network installat ions. While the spatial aspect was already of interest in the wired network world due to cable co sts etc., it has far more inﬂuence on the design and operation of wireless networks. The power r equired to transmit information via radio waves is heavily correlated with the Euclidean dis tance of sender and receivers. Hence problems in this area are prime candidates for the use of tech niques from computational geometry. Wireless devices often have limited power supply, hence the energy consumption of communi cation is an important optimization criterion. In this pape r we use the following simple geometric graph model: Given a set Pofnpoints in R2, we consider the complete graph ( P,P×P) with edge weight ω(p,q) =|pq|αfor some constant α >1 where |pq|denotes the Euclidean distance between pandq. Forα= 2 the edge weights reﬂect the exact energy requirement for f ree space communication. For larger values of α(typically between 2 and 4), we get a popular heuristic model for absorption eﬀects. A fundamental class of problems in wireless communication i s concerned with the assignment of suitable transmission powers to wireless devices/stati ons such that (1) the resulting communi cation graph satisﬁes a certain connectivity property Π, an d (2) the overall energy assigned to all the network nodes is minimized. Many properties Π can be cons idered and have been treated in the literature before, see [7] for an overview. In this paper we consider several deﬁnitions of Π to solve the following problems: kStation Network/ kdisk Coverage: Given a set Sof stations and some constant k, we want to assign transmission powers to at most kstations (senders) such that every station in Scan receive a signal from at least one sender. khop Multicast: Given a set Sof stations, a speciﬁc source station s, a set of clients/receivers C⊆S, and some constant k, we want the communication graph to contain a directed tree r ooted atsspanning all nodes in Cwith depth at most k. TSP under squared Euklidean distance: Given a set Sofnstations, determine a permutation p0,p1,...pn−1of the nodes such that the total energy cost of the TSP tour, i.e ./summationtextn−1 i=0|pip(i+1)mod n|α is minimized. 1.1 Related Work "
190,Sequenced Route Query with Semantic Hierarchy.txt,"The trip planning query searches for preferred routes starting from a given
point through multiple Point-of-Interests (PoI) that match user requirements.
Although previous studies have investigated trip planning queries, they lack
flexibility for finding routes because all of them output routes that strictly
match user requirements. We study trip planning queries that output multiple
routes in a flexible manner. We propose a new type of query called skyline
sequenced route (SkySR) query, which searches for all preferred sequenced
routes to users by extending the shortest route search with the semantic
similarity of PoIs in the route. Flexibility is achieved by the {\it semantic
hierarchy} of the PoI category. We propose an efficient algorithm for the SkySR
query, bulk SkySR algorithm that simultaneously searches for sequenced routes
and prunes unnecessary routes effectively. Experimental evaluations show that
the proposed approach significantly outperforms the existing approaches in
terms of response time (up to four orders of magnitude). Moreover, we develop a
prototype service that uses the SkySR query, and conduct a user test to
evaluate its usefulness.","Recently,technologicaladvancesinvariousdevices,such assmart phones and automobilenavigation systems, have allowed use rs toobtainrealtimelocationinformationeasily.Thishast riggered the development of locationbased services such as Foursqu are, whichexploitrichlocationinformationtoimproveservice qual ity. The users of the locationbased services often want to ﬁ nd shortroutesthatpassthroughmultiplePointsofInteres t(PoIs); consequently,developingtripplanningqueriesthatcanﬁn dthe shortestroutesthatpassesthroughuserspeciﬁedcategor ieshas attractedconsiderableattention[4,10].IfmultiplePoIc ategories, e.g., restaurant and shopping mall, are in an ordered list (i .e., acategory sequence ), the trip planning query searches for a se quencedroute thatpassesPoIs thatmatchtheuserspeciﬁedcat egories inorder. Example 1.1. Figure 1shows a roadnetwork withthefollow ingPoIs:“Asianrestaurant”,“Italianrestaurant”,“Gift shop”,“Hobby shop”,and“Arts&Entertainment(A&E)”.Assumethatauserw ants togotoanAsianrestaurant,anA&Eplace,andagiftshopinth is order from start point /v.altq. The sequenced route query outputs routeR1 because it is the shortest route from /v.altqthat satisﬁed theuser requirements /a\}bracketle{tAsian restaurant, A&E,gift shop /a\}bracketri}ht. Existingapproachesﬁndtheshortestroutebasedontheuser query.However,suchapproachesmayﬁndanunexpectedlylon g routebecausethefoundPoIsmaybedistantfromthestartpoi nt. © 2018 Copyright held by the owner/author(s). Published in P roceedings of the 21st International Conference onExtending DatabaseTechn ology (EDBT), March 2629,2018, ISBN 9783893180783onOpenProceedings.o rg. Distributionof this paper is permitted under the terms of th e CreativeCommons license CCbyncnd4.0.A IGA I GH HA I G H GR3 R2R1Ip1p2p5 p3p4p6p7 p8p9p10 p11p12 p13 vqUserlocation Food Shop & Service Arts & EntertainmentAsian Restaurant Italian Restaurant Gift Shop Hobby Shopvq Figure1: An exampleof a road networkwith PoIs JapaneseBakery Italian AsianGift  shopHobby  shopFood Shop & Service Clothing store Men's  store Sushi Figure2: Examplesof categorytreesin Foursquare A major problemwith theexisting approaches is thatthey onl y output routes that perfectly match the given categories [5, 14, 16]. To overcome this problem, we introduce ﬂexible similar ity matching based on PoI category classiﬁcation to ﬁnd shorter routes in a ﬂexible manner. In the realworld, category clas siﬁ cation often forms a semantic hierarchy , which we refer to as acategory tree . For example, in Foursquare1, the “Food” cate gory tree includes “Asian restaurant,” “Italian restauran t,” and “Bakery” assubcategories,and the“Shop&Service” categor yin cludes“Giftshop,”“Hobbyshop,”and“Clothingstore”assu bcat egories (Figure 2). We employ this semantic hierarchy to eva l uate routes in terms of two aspects, i.e., route length and th e semantic similarity between the categories of the PoIs in th e route and those speciﬁed in the user query. As a result, we can ﬁndeﬀectivesequencedroutesthat semantically matchtheuser requirement based on the semantic hierarchy. For example, i n Figure 1, route R2 satisﬁes the user requirement because it se mantically matches the category sequence because Italian a nd Asian restaurants are in the same category tree. However, th is approach may ﬁnd a signiﬁcantly large number of sequenced routesbecausethenumberofPoIsthatﬂexiblymatchthegive n categoriesincreasessigniﬁcantly.Toreducethenumberof routes tobeoutput,weemploytheskyline concept[2],i.e., werest rict ourselves to searching for the routes that are not worse than any other routes in terms of their scores (i.e., numerical va lues to evaluate the routes). Based on this concept, we propose th e skylinesequencedroute(SkySR)query ,whichappliestheskyline concepttotheroutelengthandsemanticsimilarity(i.e.,w econ siderroutelengthandsemanticsimilarityasroutescores) .Given a start point and a sequence of PoI categories, a SkySR query 1https://developer.foursquare.com/categorytreeTable 1: Exampleroutesin New Yorkcity Approach Distance Sequenced route Existing3239meters CupcakeShop→Art Museum→JazzClub(e.g., [16]) Proposed3239meters CupcakeShop→Art Museum→JazzClub 1858meters DessertShop→Art Museum→JazzClub 1392meters DessertShop→Museum→JazzClub 823meters DessertShop→Museum→MusicVenue searches forsequencedroutes thatareno worsethananyothe r routes interms oflength and semantic similarity. Example1.2. Table1showsrealworldexamplesofsequenced routes in New York city where a user plans to go to a cupcake shop, an art museum,and then a jazz clubin this order. The ex isting approaches output a single route that matches the use r’s requirement perfectly.Theproposedapproachcanoutputth ree additionalroutesthatareshorterthantheroutefoundbyth eex isting approach. Note that the additional routes also satis fy the user query semantically. The user can select a preferred rou te amongallthefourroutesdependingonhowfarhe/shedoesnot want towalk ortheir availabletime. The SkySR query can provide eﬀective trip plans; however, it incurs signiﬁcant computationalcostbecausea largenum ber ofroutescanmatchtheuserrequirement.Therefore, theSky SR queryrequiresaneﬃcientalgorithm.Thechallengeistosea rch forSkySRs eﬃcientlybyreducingthesearch spacewithoutsa c riﬁcing the exactness of the result. We propose bulk SkySR al gorithm ( BSSRfor short)that ﬁnds exact SkySRs eﬃciently. Re call that a feature of SkySRs is that their scores are no worse thanthoseofothersequencedroutes. BSSRexploitsthebranch andboundalgorithm[9],whicheﬀectively prunesunnecess ary routes based on the upper and lower bounds of routescores. In addition,toimproveeﬃciencymore,weemployfourtechniqu es tooptimize BSSR.(1)First,weinitiallyﬁndsequencedroutesto calculate the upper bound. (2) We tighten the upper bound by arranging the priority queue and (3) tighten the lower bound byintroducingminimumdistances.(4)wekeepintermediate re sults for later processing, which refer to as ontheﬂy caching . Our approach signiﬁcantly outperforms existing approache s in terms of response time (up to four orders of magnitude) with outincreasing memoryusageorsacriﬁcingtheexactness oft he result. Themain contributionsofthis paperare as follows. •We introduce a semantic hierarchy to the route search query,which allowsustosearch forroutes ﬂexibly. •Weproposethe skylinesequencedroute(SkySR)query ,which ﬁnds all preferred routes related to a speciﬁed category sequencewith asemantic hierarchy (Section 4). •We propose an exact and eﬃcient algorithm and its op timization techniques to process SkySR queries (Section 5). •Wediscussvariations andextensions oftheSkySR query. The SkySR query can be applied to various user require ments and environments (Section6). •We demonstrate that the proposed approach works well intermsofresponsetimeandmemoryusagebyperform ing extensive experiments. (Section7). •We develop a prototype service that employs the SkySR query and conduct a user test to evaluate usefulness of theSkySR query.(Section8).Theremainderofthispaperisorganizedasfollows.Section 2 introducesrelatedwork.Section3describestheproblemfo rmu lation,andSection4deﬁnestheSkySRquery.Section5prese nts the proposedalgorithm. In Section 6, we discuss variations and extensions of the SkySR query. Sections 7 and 8 present exper i mentandusertestresults,respectively,andSection9conc ludes thepaper. 2 RELATED WORK "
106,Modeling and Designing Routing Protocols in Quantum Networks.txt,"Quantum networks enable a number of important applications such as quantum
key distribution. The basic function of a quantum network is to enable
long-distance quantum entanglement between two remote communication parties.
This work focuses on the entanglement routing problem, whose objective is to
build long-distance entanglements for the concurrent source-destination pairs
through multiple hops. Different from existing works that analyzes the
traditional routing techniques on special network topologies, we present a
comprehensive entanglement routing model that reflects the differences between
quantum networks and classical networks and new entanglement routing algorithms
that utilize the unique properties of quantum networks. Evaluation results show
that the proposed algorithm Q-CAST increases the number of successful
long-distance entanglements by a big margin compared to other methods. The
model and simulator developed by this work may encourage more network
researchers to study the entanglement routing problem.","A quantum network (also called as a quantum Internet) is an interconnection of quantum processors and repeaters that can generate, exchange, and process quantum informa tion [4, 22, 25, 47]. It facilitates the transmission of informa tion in the form of quantum bits, also called qubits , between physically separated quantum memory. Longdistance quan tum information exchange has been proposed, studied, and validated since 1980s [5, 14, 15, 31, 34, 42, 49] and many ex perimental studies have demonstrated that communication of quantum information can become successful in reality, such as the DARPA quantum network [15], SECOQC Vi enna QKD network [34], the Tokyo QKD network [42], and the satellite quantum network in China [49]. Quantum networks are not meant to replace the classical Internet communication. In fact, they supplement the clas sical Internet and enable a number of important applications such as quantum key distribution (QKD) [5, 14, 36], clock synchronization [23], secure remote computation [7], and distributed consensus [12], most of which cannot be easily achieved by the classical Internet.The basic function of a quantum network is to enable long distance quantum entanglement between two remote com munication parties. Hence, most applications of quantum networks are developed based on two important features of quantum entanglement. 1) Quantum entanglements are in herently private by the laws of quantum mechanics such as the “nocloning theorem” [33] and hence prevent a third party from eavesdropping the communication [14]. quantum entanglement is a perfect solution of the most fundamental problem of network security: key distribution (also known as key agreement) [13]. Compared to public key cryptography [40], quantum key distribution (QKD) has provable security based on information theory and forward secrecy [47], instead of relying on the computational com plexity of certain functions (such as factorization). 2) Quan tum entanglement provides strong correlation and instanta neous coordination of the communication parties. Hence, quantum entanglement can achieve tasks that are difﬁcult to coordinate in classical networks due to unexpected network latencies, such as clock synchronization [23] and distributed consensus [12]. Recent progress reveals that quantum networks could be come practical in 5 years [47], and they do not rely on the wellfunctioning quantum computers carrying a sufﬁcient amount of qubits. In fact, many applications of quantum networks can be implemented with one or two qubits. Con sidering the QKD example, we are able to distribute a secret bit with only one entanglement pair. By repeating the 1pair QKD process we can generate secret keys with a sufﬁcient length. Hence, research on quantum networks is a timing topic. To generate a longdistance quantum entanglement be tween two parties Alice and Bob, one of them should cre ate an entangled pair of photons and send one photon to the other party through a channel using certain physical media such as optical ﬁber. However, optical ﬁber is inherently lossy and the success rate pof establishing an entanglement pair decays exponentially with the physical distance between the two parties [37, 39]. Hence, to increase success rate of longdistance quantum entanglement, a number of quantum repeaters need to be deployed between two longdistance communication parties [37, 47]. Eventually a network of 1arXiv:1909.09329v3  [cs.NI]  25 Oct 2019quantum repeaters will be deployed to support anytoany communication of worldwide quantum processors, similar to the evolution of classical Internet. One critical issue is that quantum repeaters work in a completely different way from classical network routers: they use quantum swapping instead of the packet switching. Hence, new algorithms are required to be designed and how to reliably generate quan tum entanglement using the network of repeaters remains an unsolved yet important problem. This work focuses on a key problem called entanglement routing , whose objective is to build longdistance entangle ments through multiple hops for any pair of source and des tination in the network. This problem can be considered on the network layer of a quantum network [10]. Existing work that investigate the routing problem of quantum networks is limited to analyzing the traditional routing techniques (Di jkstra shortest paths, multipath routing, and greedy routing) on special network topologies (ring, sphere, or grid), such as the very recent ones [21, 32]. In this study, we present a comprehensive entanglement routing model that reﬂects the difference between quantum networks and classical net works and new entanglement routing designs that utilize the unique properties of quantum networks. The proposed algo rithms include realistic protocoldesign consideration such as arbitrary network topologies, multiple concurrent sources and destinations to compete resource, link state exchanges, and limited qubit capacity of each node, most of which have not been considered by prior studies. Evaluation results show that the proposed algorithm Q CAST increases the number of successful longdistance en tanglements by a big margin compared to other methods. More importantly, this study may encourage more network researchers to study the entanglement routing problem. We present and clarify the models and problems of entanglement routing, with the comparison of similar terms and concepts used in classical network research. A simulator with algo rithm implementation, topology generation, statistics, and network visualization functions is built and will be open to public [1]. The rest of this paper is organized as follows. § 2 presents the related work of quantum network routing and § 3 intro duces the network model. We present the algorithm designs in § 4. The evaluation results are shown in § 6. We discuss some related issues in § 7 and conclude this work in § 8. 2. RELATED WORK "
195,Estimating latent processes on a network from indirect measurements.txt,"In a communication network, point-to-point traffic volumes over time are
critical for designing protocols that route information efficiently and for
maintaining security, whether at the scale of an internet service provider or
within a corporation. While technically feasible, the direct measurement of
point-to-point traffic imposes a heavy burden on network performance and is
typically not implemented. Instead, indirect aggregate traffic volumes are
routinely collected. We consider the problem of estimating point-to-point
traffic volumes, x_t, from aggregate traffic volumes, y_t, given information
about the network routing protocol encoded in a matrix A. This estimation task
can be reformulated as finding the solutions to a sequence of ill-posed linear
inverse problems, y_t = A x_t, since the number of origin-destination routes of
interest is higher than the number of aggregate measurements available.
  Here, we introduce a novel multilevel state-space model of aggregate traffic
volumes with realistic features. We implement a naive strategy for estimating
unobserved point-to-point traffic volumes from indirect measurements of
aggregate traffic, based on particle filtering. We then develop a more
efficient two-stage inference strategy that relies on model-based
regularization: a simple model is used to calibrate regularization parameters
that lead to efficient and scalable inference in the multilevel state-space
model. We apply our methods to corporate and academic networks, where we show
that the proposed inference strategy outperforms existing approaches and scales
to larger networks. We also design a simulation study to explore the factors
that influence the performance. Our results suggest that model-based
regularization may be an efficient strategy for inference in other complex
multilevel models.",1.1 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 
134,Soft Merging of Experts with Adaptive Routing.txt,"Sparsely activated neural networks with conditional computation learn to
route their inputs through different ""expert"" subnetworks, providing a form of
modularity that densely activated models lack. Despite their possible benefits,
models with learned routing often underperform their parameter-matched densely
activated counterparts as well as models that use non-learned heuristic routing
strategies. In this paper, we hypothesize that these shortcomings stem from the
gradient estimation techniques used to train sparsely activated models that use
non-differentiable discrete routing decisions. To address this issue, we
introduce Soft Merging of Experts with Adaptive Routing (SMEAR), which avoids
discrete routing by using a single ""merged"" expert constructed via a weighted
average of all of the experts' parameters. By routing activations through a
single merged expert, SMEAR does not incur a significant increase in
computational costs and enables standard gradient-based training. We
empirically validate that models using SMEAR outperform models that route based
on metadata or learn sparse routing through gradient estimation. Furthermore,
we provide qualitative analysis demonstrating that the experts learned via
SMEAR exhibit a significant amount of specialization. All of the code used in
our experiments is publicly available.","Neural networks typically use all of their parameters to process a given input. As such, the capabilities of a model are distributed across the parameters of a model in a selforganizing way [ 1–5]. Explicitly specializing different parts of a model to different capabilities can provide various benefits, including reduced interference across downstream tasks [ 6–9] or languages [ 10–12]. Furthermore, dedicating specific parameters to specific capabilities enables a form of modularity where a capability can be added, removed, or modified by adding, removing, or modifying the corresponding parameters [ 13]. An orthogonal benefit of using only a subset of the model’s parameter for a given input is the ability to decouple the computational cost of a model from the number of parameters it has, enabling training of models at parameter scales that would otherwise be computationally infeasible [14, 15]. Conditional computation techniques provide a way to build models that adaptively choose a subset of their parameters to apply to a given input. A common way to use conditional computation in this setting is to introduce specialized subnetworks called experts that are controlled by routers that decide which experts should be active. When the model is trained on diverse data, this form of conditional computation can enable modular learning by allowing experts to specialize to different types of inputs and flexibly share knowledge [ 16]. However, because routing involves making a discrete decision as to which expert to use, the loss on the model’s prediction cannot backpropagate though the routing decision to update the router. Consequently, models with conditional computation often require gradient estimation techniques for training [17, 15, 18]. 1https://github.com/rthree/smear Preprint. Under review.arXiv:2306.03745v1  [cs.LG]  6 Jun 2023Router  Expert 1 Expert 2 Expert 3 Expert 4 Merged Expert  Expert 1  Expert 2  Expert 3  Expert 4 Router Gradient estimation Discrete Routing SMEAR Figure 1: The discrete routing decisions commonly used in models that route activations among experts require the use of gradient estimation (left). We propose SMEAR (right), which uses a given router’s distribution to average the parameters of the corresponding experts and then routes the input through a single merged expert. SMEAR achieves better performance than discrete routing, can be trained with standard backpropagation, and does not incur significant additional computational costs. In practice, past work has shown that models with conditional computation do not always learn effective routing strategies. For example, Mittal et al. [19] investigate models with a continuous router in a controlled setting and find the models do not route examples from the same group to the same experts and perform poorly compared to models with oracle routing. However, models with task or domainspecific subnetworks [ 20,21] provide evidence that it is possible to train performant models with specialized experts. As an extreme example, Roller et al. [22] achieves results comparable to learned routing with a fixed random routing. Relatedly, Fedus et al. [15] find the gain from scaling up parameters by 30 ×with a sparsely activated model is smaller than scaling up both parameters and FLOPs by 3 ×in a dense model. As a possible explanation, Clark et al. [17] study how models with conditional computation improve with scale and find a detrimental term that scales with the product of the log number of experts and active parameters. Consequently, increasing the number of experts yields limited returns and existing methods for training conditional computation models may only be helpful when the number of active parameters is moderate. In this work, we hypothesize that issues with conditional computation stem from issues with gradient estimation. Specifically, we focus on experimental settings where we can compare learned routing to a performant handdesigned heuristic routing scheme. We find that the gradient estimation techniques we consider often produce models that underperform heuristic routing, despite the fact that they could in principle learn a better routing strategy. To address this shortcoming, we introduce SoftMerging ofExperts with Adaptive Routing (SMEAR), a method for training models with specialized experts and learned routing. SMEAR works by using the router’s distribution over experts to compute a weighted average of the parameters of the individual experts. Activations are then sent through the merged expert, which results in a similar computational cost to discrete routing with a single expert. However, the fact that all components of SMEAR are fully differentiable enables standard gradient based training. Empirically, we show that SMEAR significantly attains a favorable performance/cost tradeoff to 1) discrete routing solutions found via gradient estimation, 2) heuristic routing schemes, and 3) stateoftheart baselines for learning modular models. We also qualitatively validate that the experts learned by SMEAR specialize to different types of inputs and share parameters across related tasks. Put together, our results show that SMEAR provides an effective alternative for modular models that use adaptive routing among expert subnetworks. 2 Background To provide the necessary background for our work, we first explain how sparsely activated neural networks use conditional computation, then discuss gradient estimators that enable learning discrete routing strategies. In addition, we discuss different ways to handdesign “heuristic” routing strategies as well as preexisting techniques for learning modular models that we use as baselines. 2.1 Routing Among Experts In models that use discrete routing among experts (i.e. subnetworks), experts are organized into blocks that are incorporated as an intermediate layer in a neural network. An expert routing block Bcomprises a set of Nexperts {f1, f2, . . . f N}and a router R. Experts in the same block accept 2inputs and produce outputs of the same dimensionality. Given a hiddenstate representation u, the output of the ith expert with parameters θiisfi(u, θi). In our work, the router chooses a single fito process the input of the block (though models in some other work may activate more than one expert [14, 23]). 2.2 Gradient Estimators In sparsely activated models that involve discrete adaptive routing, it is not possible to train the router’s parameters with standard gradientbased learning. Fortunately, gradient estimators can provide approximate gradients to the router parameters. There are a few common designs shared by models that use gradient estimators to train routers. Their router Roften applies a lightweight network to some intermediate hidden states vin the model. The output of the lightweight routing network R(v)parameterizes a discrete probability distribution over the Nexperts. Different gradient estimators vary in how they make the routing decision from R(v)and how they construct the output from the chosen expert. REINFORCE Gradients can be estimated through discrete operations using reinforcement learning techniques [ 24,18]. In reinforcement learning, a policy loss is used to train an agent to learn optimal actions in an environment. In this paper, we experiment with the REINFORCE algorithm which computes the policy loss as log(π)rwhere rdenotes the received reward for taking an action whose assigned probability is π. When applied to models that use discrete routing among experts, the goal is to train the model to choose the optimal expert to process a given input. Here, the router Racts an agent that samples an expert to use according to the routing probabilities. In order to train such a router, the router’s assigned probability to the sampled expert is used as πand the negative of the model’s loss is used as the reward r. The router is therefore trained to pick experts that maximize the reward which, in turn, minimizes the loss. The REINFORCE estimator often suffers from high variance because of the sampling operation. This motivates the use of baselines, which reduce variance without changing the optimal solution. In our work, we follow Clark et al. [17] and use a baseline bthat is generated by a small neural network with a single hidden layer that takes as input v and is trained with the Huber loss. The overall loss function is then L=−Ei∼R(v)αlogR(v)i(r−b)−βR(v) logR(v) +γLHuber(r, b) (1) where α,β, and γare hyperparameters that correspond to policy gradient weight, policy entropy weight, and value loss weight. In practice, we approximate the expectation in eq. (1) with a single sample. During inference, the output of the block Bis just fi(u, θi)where i= arg max R(v). Straight Through GumbelSoftmax (STGumbel) The GumbelSoftmax trick [ 25,26] provides a continuous differentiable approximation to sampling from a categorical distribution like the one parameterized by a router. Specifically, Gumbel noise is added to the logits of the distribution and a temperature scale is applied in the softmax operation. Denoting gi∼Gumbel(0, 1) andτas the temperature, the GumbelSoftmax trick produces the following modified distribution: ˆR(v)i=exp((log( R(v)i) +gi)/τ)PN j=1exp((log( R(v)i) +gi)/τ)(2) The expert fiwith the highest assigned probability is chosen by applying an arg max operation over this distribution. In order to approximate gradients through the arg max operation, we use the StraightThrough estimator which replaces fi(u, θi)with(1−sg[ˆR(v)i] +ˆR(v)i)fi(u, θi)where sg stands for the stopgradient operator. During forward pass, the multiplier for fi(u, θi)becomes 1 and the multiplier receives gradients for the term ˆR(v)iin the backward pass. In practice, the temperature τis gradually annealed from a high to low value so that the approximated samples are more and more similar to discrete samples. During inference, we choose an expert according to arg max R(v). TopkShazeer et al. [14] propose a gradient estimation scheme where the router sends the input through the kexperts that are assigned the highest probability. Fedus et al. [15] later found that this router could be used effectively when k= 1. Specifically, the estimator selects the subnetwork with the highest probability and scales its output using its corresponding routing probability. The output of the block is therefore R(v)ifi(u, θi), where i= arg max R(v). 32.3 Heuristic Routing As a point of comparison for techniques that learn adaptive routing, we experiment with three baseline routing strategies that do not require a trained router. Tag Routing If we have prior knowledge about the data that a model will be applied to, we can handdesign a heuristic routing strategy for choosing which expert to use for a given example based on data properties. Tag routing takes advantage of “tags” associated with a given example (such as its domain or task) and associates each expert in an expert routing block with a particular tag. In this work, we assume each example has a single tag and route each example to its tag’s expert. Hash Routing Roller et al. [22] propose hash routing, which uses a fixed hashing function to determine which expert to use for a given example. Specifically, each example is assigned a random expert choice in each expert routing block which is used consistently over the course of training and inference. This approach disregards any shared characteristics across examples. SingleExpert As an additional baseline, we consider models where all inputs are routed to a single expert in each routing block. To provide a fair comparison to models with Nexperts per block on the basis of both computational cost or parameter count, we consider models with a single expert with either the same number (computematched, referred to as “ 1×compute”) or N×(parametermatched, referred to as “ 1×parameters”) as many parameters as a single expert. 2.4 Methods for Learning Modular Models "
271,Bus Trajectory-Based Street-Centric Routing for Message Delivery in Urban Vehicular Ad hoc Networks.txt,"This paper focuses on the routing algorithm for the communications between
vehicles and places in urban VANET. As one of the basic transportation
facilities in an urban setting, buses periodically run along their fixed routes
and widely cover city streets. The trajectory of bus lines can be seen as a sub
map of a city. Based on the characters of bus networks, we propose a bus
trajectory-based street-centric routing algorithm (BTSC), which uses bus as
main relay to deliver message. In BTSC, we build a routing graph based on the
trajectories of bus lines by analyzing the probability of bus appearing on
every street. We propose two novel concepts, i.e. the probability of street
consistency (PSC) and the probability of path consistency (PPC) which is used
as metrics to determine routing paths for message delivery. This aims to choose
the best path with higher density of busses and lower probability of
transmission direction deviating from the routing path. In order to improve the
bus forwarding opportunity, we design a bus-based forwarding strategy with ant
colony optimization (FACO) to find a reliable and steady multi-hop link between
two relay buses in order to decrease end-to-end delay. BTSC makes the
improvements in the selection of routing path and the strategy of message
forwarding. Simulation results show that our proposed routing algorithm has a
better performance in transmission ratio, transmission delay and adaptability
to different networks.","S the development of the intelligent transportation  system (ITS), vehic ular ad hoc network (VANET) is  excepted to support more and more new applications to  improve the qualities of people's life and traffic, such as  location based services, travel planning services, traffic  accident reporting services, intelligent parking service s and  social vehicular platforms  [14]. Acting as mobile intelligent  communication equipment, vehicles are expected to access the  network wherever and whenever possible . There have been  several papers  focused on security  [58] and mobility  topics   [9,10], but efficiency also plays an import ant role in VANET.  Thus  it's significant  to design efficient routing algorith m in  VANET. In this paper, we  will focus on the design of routing algorithm s for the communication between vehicles and some  places.   In VANET, vehicles equipped with on board units (OBUs)  can spontaneously form a self organization network without  depending on other infrastructures  [1114]. Vehicle s can  directly communicate with other vehicles or infrastructures   within their communication range  by using dedicated short  range communication (DSRC) technology  or indirectly  communicate with others by multi hop links  [11,1518].  Intermediate vehicles between sender  and destination play the  role of router and deliver  packets  by using the carry and forward mechanism [17,1923]. On one hand, the movement  of vehicles is affected by the driver ’s subjective awareness,  causing the uneven distribution and unpredictable trajectories  of vehicles  [5,21]. Dense network is beneficial for multi hop  link and has a g ood routing performance. However, in sparse  network, it's difficult to find  the relay to deliver  packets.  Consequently, routing performance becomes poor [2324]. On  the other hand, the movement of vehicles makes rapid and  frequent change of the network's t opology  [2526]. Therefore,  the conventional routing based on the technology of ad hoc  network has poor performance  [2634].  As one of the  infrastructures in VANET, road side units  (RSUs) can work as the router to store and forward packets   [26,28,35]. However, the performance of RSU based routing  is limited by the number and also by the location of RSUs  [23].  Only the intensive deployment of RSU can maximize the  availability of RSU and provide a stable service for message  transmission in VANET. Otherw ise the link between vehicles  may disconnect in the blind area of communication  [36].  However, the deployment and management of RSU cause a lot  of overhead, and the limited communication range and fixed  position  cause short connection between RSU and  movin g  vehicles  [23,3637]. Therefore, the RSU based routing is  inapplicable and uneconomical.   As one of the basic transportation facilities, buses pervade  the main roads in city, and ha ve specific driving trajector ies  and departure intervals  [11,37]. Compared with the common  vehicular network, the bus network has the characteristics of  wide coverage, relatively uniform distribution  of nodes , fixed  trajectory and regular service  [3839]. Due to the unique  advantage  of buses, many researchers have paid attention to  the superiority of bus network, and proposed some  busbased  routing algorithms to solve the aforementioned routing  problem  [15,23,38,40,43]. Literature  [23] and [ 40] built the A              busbased backbone graph for routing. Literature [41] used  taxis and buses as  the communication backbone. Literatures   [15] and [ 42] proposed the bus based two tier VANET  architecture , where buses are the only relay to forward packets.  On one hand, the existing bus based routing algorithm s are all  node centric: the routing path is a multi hop link which  consists  of some buses between sender and destination, and  once the routing plan is made, only specified buses are used to  forward packets in sequence . The carrier of packet can forward  packets to the next only when it encounter s with the specified  next relay bus. And buses in different bus lines can encounter  only in the overlap of the  trajectories of their bus lines. When  carrier s miss the specified next relay bus in their meeting place,  it will take a long time before the next encounter, which  happens quite often in practice. On the other hand,  in those  existing bus based routing strategy,  bus is the only relay to  deliver packets and ordinary vehicle only serve as a sender or  receiver. Therefore, b us undertakes all the routing t asks in the  network, and the number of buses is less than the ordinary  vehicle’s, which may cause network congestion.   To solve the above problems, in this paper, we proposed the  busbased street centric routing strategy (BTSC) with  considering that the mo vement of vehicles is restricted by the  topology of streets. Firstly, we build the bus line sbased  routing graph used to select routing trajectory by analyzing the  relationship between the trajectory of bus lines and streets.  Secondly, based on our propose d routing graph , we select a  sequence of streets with high density of bus as the routing path.  Buses along the routing path work as the relay to delivery  packets to the destination by using the mechanism of carry  andforward. In the carry andforward mecha nism, the amount  of time to carry information is far greater than the amount of  time to forward information, therefore,  the time of carrying  information is the main factor  of influencing the performance  of routing. Then, we propose the bus based forwarding   strategy with ant colony optimization ( FACO). This strategy  implement s ACO algorithm to find the optimal next relay bus  when the carrier of packets cannot find next  available relay in  its communication range, aiming at  decreas ing the time of  carrying duri ng routing.  The main contributions of this paper  are listed as follows.   1) We propose the bus line based routing graph. By  analyzing the trajectory of bus lines, every edge in routing  graph is assigned a weight to reflect the density of bus on  the street corr esponding to the edge.   2) We propose two novel concept s called the probability of  street consistency (PSC)  and the probability of path  consistency (PPC) . The former  is used to describe the  consistency of bus lines between two adjacent streets , and  the latter is used  as the metric to  select the routing path  with high density of buses.   3) We design the bus based forwarding strategy with ant  colony optimization  (FACO) . During the process of  routing, buses serve as the main relay to deliver packets  from source to des tination, and ordinary vehicles works as  the secondary relay to build a multi hop link between two  buses. Ant colony optimization algorithm is used to find  an optimal next relay bus and a stable multi hop link  between two relay buses, aiming at increasing the chance  of forwarding and decreasing the delay of routing.   4) We carry out extensive simulations and analyze the  average end toend delay packet transmission  ratio of our  routing algorithm. The results of simulations show that our  proposed routing algorith m has good performance in the  delay and packet loss rate.   The remainder of this paper is as follows. Section 2  introduces the rel ated work . Section 3 presents the  preliminaries, including the system model and the definition  of link life time. Section 4 shows the detail of  BTSC , which  consists of three parts: the bus lines based routing graph, the  selection of routing path and the bus based forwarding  strategy with ACO  (FACO) . Section 5 describes the  simulation environment and the analyses of simulation resu lts.  Section 6 concludes this paper.   II. RELATED WORK  "
144,VL-ROUTE: A Cross-Layer Routing Protocol for Visible Light Ad Hoc Network.txt,"Visible Light Ad Hoc Networks (LANETs) is being perceived as an emerging
technology to complement Radio Frequency (RF) based ad hoc networks to reduce
congestion in the overloaded RF spectrum. LANET is intended to support
scenarios requiring dense deployment and high data rates. In Visible Light
Communication (VLC), most of the attention has been centered around physical
layer with emphasis on point-to-point communication. In this work, we focus on
designing a routing protocol specifically to overcome the unique challenges
like blockage and deafness that render routes in LANETs highly unstable.
Therefore, we propose a cross-layer optimized routing protocol (VL-ROUTE) that
interacts closely with the Medium Access Control (MAC) layer to maximize the
throughput of the network by taking into account the reliability of routes.
  To accomplish this in a distributed manner, we carefully formulate a Route
Reliability Score (RRS) that can be computed by each node in the network using
just the information gathered from its immediate neighbors. Each node computes
an RRS for every known sink in the network. RRS of a given node can be
considered as an estimate of the probability of reaching a given sink via that
node. The RSS value is then integrated to the utility based three-way handshake
process used by the MAC protocol (VL-MAC) to mitigate the effects of deafness,
blockage, hidden node, and maximize the probability of establishing full-duplex
links. All these factors contribute towards maximizing the network throughput.
Extensive simulation of VL-ROUTE shows 124% improvement in network throughput
over a network that uses Carrier Sense Multiple Access/Collision Avoidance
(CSMA/CA) along with shortest path routing. Additionally, VL-ROUTE also showed
up to 21% improvement in throughput over the network that uses VL-MAC along
with a geographic routing.","Visible Light Communication (VLC) is envisioned as a major alternative to mitigate the congestion experienced by the current Radio Frequency (RF) spectrum. The recent emergence of VLC along with the advancements in the enabling tech nologies such as Light Emitting Diodes (LEDs) and Photon Detectors (PDs) has lead to exploration of Visible Light Ad Hoc Networks (LANETs) [1]. Furthermore, VLC has been argued to be a critical component of the 5th Generation(5G) technology providing data rates up to 8 Gbps [2]. Accordingly, several indoor [3], [4] and outdoor applications [5] have been identiﬁed in both commercial and military domains. Indoor Applications. Modern smart homes will have de vices (TV , refrigerators thermostat among others) forming a LANET and utilizing the ubiquitous lighting infrastructure toexchange large amounts of sensor data to provide enhance autonomy and efﬁciency. Employing LANETs for these ap plications will reduce the load on traditional networks like the Wireless Fidelity (WiFi) that are currently being used for these applications. In a commercial setting, to improve efﬁciency, VLC is also envisioned as a medium of communication while constructing an interrack wireless Data Center Network (DCN) [4]. These links are usually short and demand high datarates which is where LANETs are most effective. Outdoor Civilian Applications. LANET can be employed to design intelligent transport systems, ensuring road safety [6], [7]. In Vehicle to Vehicle (V2V), for example, a com munication is established using head/tail lights as transmit ters and photodiodes/image sensors constituting receiver to provide reliable communication between vehicles. The urban infrastructures (trafﬁc lights, street lights) can also be utilized for transmitting information related to the current circulation of trafﬁc, vehicle safety, trafﬁc information broadcast, and accident signaling. Military and Space Applications. Tactical missions entail ing the deployment of ships, soldiers, and unmanned surface vehicles across various operating environment including un derwater, ground, and air can also leverage the use of LANETs as depicted in Fig. 1. For example, we envision that self organized autonomous underwater vehicles can form LANET [8] to exchange highdata rate trafﬁc via visible light carriers as a highrate shortrange alternative to acoustics. In ground applications, warﬁghters can selforganize in a LANET in case of RF interference and be connected to command; ﬁnally, in air/space LANETs, CubeSats or NanoSats can be connected to a satellite station via multihop VLC. Several of these applications will demand several hops beyond the tradition pointtopoint links that are currently employed by VLC. To make these a reality, signiﬁcant work Fig. 1: Military application of LANETarXiv:1904.05177v1  [cs.NI]  10 Apr 20192 Cross Layer  ControllerApplication Layer Transport Layer Network Layer Data Link LayerLANET PROTOCOL STACK Firmware Custom  LogicInterp DAC DUCLED  Driver Decim ADC DDC TIASignal Processing ChainLANET HARDWARE LED PD Physical Layer Fig. 2: Architecture of a crosslayer controller enabled LANET node is required at the network layer to overcome some of the chal lenges speciﬁc to LANET like deafness (due to directionality) and blockage (due to the nature of propagation) that induces highly volatile route conditions. Therefore, it is evident that reliability of route and the opportunity to change the routing decision quickly will be the critical features distinguishing a routing protocol from traditional approaches. Previously, crosslayer network optimization has been explored in RF networks [9]–[11] but is especially crucial for LANETs to combat the volatile nature of links [12]–[14]. Therefore, con sidering the above challenges, we can summarize the features essential for a routing protocol for LANETs as follows, A crosslayer framework as depicted in Fig. 2 is required to ensure collaboration of network layer with the data link layer to mitigate the degradation that is caused due to deafness and blockage and to maximize the probability of establishing fullduplex links. Due to the highly dynamic nature of LANETs, an oppor tunistic routing protocol that uses a distributed algorithm to determine the optimal hops at each intermediate node in the multihop network is required. Reliability of the routes each node can provide should be considered as a key metric while making routing decisions. The absolute channel condition itself may not be the best indicator of successful routes. II. R ELATED WORKS "
157,Application and network layers design for wireless sensor network to supervise chemical active product warehouse.txt,"Wireless sensor networks have profound effects on many application fields
like security management which need an immediate and fast system reaction.
Indeed, the monitoring of a dangerous product warehouse is a major issue in
chemical industry field. This paper describes the design of chemical warehouse
security system using the concept of active products and wireless sensor
networks. A security application layer is developed to supervise and exchange
messages between nodes and the control center to prevent industrial accident.
Different security rules are proposed on this layer to monitor the internal
state and incompatible products distance. If a critical event is detected, the
application generates alert message which need a short end to end delay and low
packet loss rate constraints by network layer. Thus, a QoS routing protocol is
also developed in the network layer. The proposed solution is implemented in
Castalia/OMNeT++ simulator. Simulation results show that the system reacts
perfectly for critical event and can meet the QoS constraints of alert message.","In recent years, the rapid technological advances in low power and highly integrated di gital electronics, small scale energy supplies, and low power radio technologies have created low cost and multifunctional intelligent devices. These devices are equipped with small battery, a tiny microprocessor, a radio transceiver and a set of sensor mo dules that used to acquire information of their surrounding environment. These technological advances lead to different new research field such as Internet of Things [1] and Active Product [2]. The active intelligent product had large expansion on the indu stry. Through this concept, the industrial product is not simply a physics entity but it is an active object which is able to communicate and exchange information with the systems. These capacities were made with the RFID identification technology (Radio F requency Identification) [3] and the Wireless Sensors Networks (WSN). However unlike RFID, WSN allows going beyond the information exchange to the sensing of ambient environment parameters (e.g. tempera ture, pressure, humidity…) [4].International Journal of Computer Science, Engineering and Applications (IJCSEA) Vol.4, No.6, December 2014 54This concept attracte d the interest of several research projects. As example, COBIS project (Collaborative Business Items) [5,6] has developed a new approach for business processes involving physical entities such as goods and tools in enterprise. COBIS improved the networked systems to create cooperative products named particles, used for various applications particularly for monitoring the industrial products. TecOlab from Karlsruhe University and MIT [7] has announces the concept of active physical documents for the integrit y management of written files to restrict accesses and keep the track of the document changes. It introduces the DigiClip system that provides a solution to convert passive paper documents to active physical entities. Moreover , CHAOS project [8] also emplo ys the intelligent object approach to secure the exchange of information in distributed systems. The security of industrial chemical products is an important issue. So, the using of active product technology may facilitate its supervising process. The sec urity of such product involves the internal reaction against the ambient values changes (e.g. temperature) and the incompatibility of chemical substances during the storage and transport phases. This paper proposes a security system of chemicals products warehouse. Such storage products may cause critical danger if security rules are not respected. The container of chemical substances is transformed into a communicating entity (i.e. active product) by embedding a wireless sensor node. Thus, the container c ould supervise its internal state and the external changes of its environment (e.g. temperature, brightness, and humidity). Moreover, the containers could control the distance between them by periodic message exchange (RSSI method [9]) to prevent the "
249,Social-aware Opportunistic Routing Protocol based on User's Interactions and Interests.txt,"Nowadays, routing proposals must deal with a panoply of heterogeneous
devices, intermittent connectivity, and the users' constant need for
communication, even in rather challenging networking scenarios. Thus, we
propose a Social-aware Content-based Opportunistic Routing Protocol, SCORP,
that considers the users' social interaction and their interests to improve
data delivery in urban, dense scenarios. Through simulations, using synthetic
mobility and human traces scenarios, we compare the performance of our solution
against other two social-aware solutions, dLife and Bubble Rap, and the
social-oblivious Spray and Wait, in order to show that the combination of
social awareness and content knowledge can be beneficial when disseminating
data in challenging networks.","Given the advent of powerful mobile devices and the fast pace of to day’s world, users crave connectivity while on the go. This leads to a networking s cenario with heterogeneous, mobile, and powerconstraint devices, as we ll as wireless networks with intermittent connectivity even in urban scenarios, d ue to the presence of wireless shadowing, and the existence of closed acces s points and expensive Internet services. Moreover, users’ requirements f or ubiquitous data access is not aligned with the current Internet architecture, sinc e users are not interested in knowing the location of data. It has been shown that focusing on the content, rather then on t he host, we can improve the performance of challenged networks [1, 2] by allo wing an2 Waldir Moreira et al. eﬃcient direct communication between producers and consumers o f content. In addition, exploiting nodes’ social interactions and structure (i.e., c ommunities [3], levels of social interaction [4, 5]) has been shown eﬃcient to increa se the performance of opportunistic routing. Thus, combining content k nowledge (i.e., contenttype,interestedparties)withsocialproximityshallbring beneﬁts(faster, better content reachability) in challenged networks. SCORP exploits social proximity and content knowledge to augment the eﬃciency of data delivery in urban, dense scenarios. We show the ad vantages thatSCORP brings to the operation of opportunistic networks (in terms of delivery, cost and latency) through simulations based on synthetic mobility and tracebased scenarios. This paper is structured as follows. Section 2 brieﬂy goes over the r elated work. In Section 3, we present SCORP. Section 4 presents our evaluation study. In Section 5, conclusions and future work are presented. It is wor th noting that the words information ,data,message, andcontentare used interchangeably throughout this paper. 2 Related Work "
